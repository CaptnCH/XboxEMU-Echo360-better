#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 8208ABB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208ABB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208ABB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208ABB4);
		  /* 8208ABB4h */ case    0:  		/* mr R28, R11 */
		/* 8208ABB4h case    0:*/		regs.R28 = regs.R11;
		/* 8208ABB4h case    0:*/		return 0x8208ABB8;
	}
	return 0x8208ABB8;
} // Block from 8208ABB4h-8208ABB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208ABB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208ABB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208ABB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208ABB8);
		  /* 8208ABB8h */ case    0:  		/* lwz R11, <#[R28]> */
		/* 8208ABB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8208ABB8h case    0:*/		return 0x8208ABBC;
		  /* 8208ABBCh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8208ABBCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208ABBCh case    1:*/		return 0x8208ABC0;
		  /* 8208ABC0h */ case    2:  		/* bc 4, CR6_EQ, -116 */
		/* 8208ABC0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8208AB4C;  }
		/* 8208ABC0h case    2:*/		return 0x8208ABC4;
	}
	return 0x8208ABC4;
} // Block from 8208ABB8h-8208ABC4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208ABC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208ABC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208ABC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208ABC4);
		  /* 8208ABC4h */ case    0:  		/* mr R3, R31 */
		/* 8208ABC4h case    0:*/		regs.R3 = regs.R31;
		/* 8208ABC4h case    0:*/		return 0x8208ABC8;
		  /* 8208ABC8h */ case    1:  		/* bl -640 */
		/* 8208ABC8h case    1:*/		regs.LR = 0x8208ABCC; return 0x8208A948;
		/* 8208ABC8h case    1:*/		return 0x8208ABCC;
		  /* 8208ABCCh */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 8208ABCCh case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8208ABCCh case    2:*/		return 0x8208ABD0;
		  /* 8208ABD0h */ case    3:  		/* bc 12, CR0_EQ, 52 */
		/* 8208ABD0h case    3:*/		if ( regs.CR[0].eq ) { return 0x8208AC04;  }
		/* 8208ABD0h case    3:*/		return 0x8208ABD4;
		  /* 8208ABD4h */ case    4:  		/* stw R30, <#[R3 + 8]> */
		/* 8208ABD4h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000008) );
		/* 8208ABD4h case    4:*/		return 0x8208ABD8;
		  /* 8208ABD8h */ case    5:  		/* stw R29, <#[R3 + 4]> */
		/* 8208ABD8h case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000004) );
		/* 8208ABD8h case    5:*/		return 0x8208ABDC;
		  /* 8208ABDCh */ case    6:  		/* lwz R11, <#[R28]> */
		/* 8208ABDCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8208ABDCh case    6:*/		return 0x8208ABE0;
		  /* 8208ABE0h */ case    7:  		/* stw R11, <#[R3]> */
		/* 8208ABE0h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8208ABE0h case    7:*/		return 0x8208ABE4;
		  /* 8208ABE4h */ case    8:  		/* stw R3, <#[R28]> */
		/* 8208ABE4h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x00000000) );
		/* 8208ABE4h case    8:*/		return 0x8208ABE8;
		  /* 8208ABE8h */ case    9:  		/* lwz R10, <#[R31 + 28]> */
		/* 8208ABE8h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 8208ABE8h case    9:*/		return 0x8208ABEC;
		  /* 8208ABECh */ case   10:  		/* lwz R11, <#[R31 + 52]> */
		/* 8208ABECh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000034) );
		/* 8208ABECh case   10:*/		return 0x8208ABF0;
		  /* 8208ABF0h */ case   11:  		/* addi R11, R11, 1 */
		/* 8208ABF0h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8208ABF0h case   11:*/		return 0x8208ABF4;
		  /* 8208ABF4h */ case   12:  		/* cmplw CR6, R30, R10 */
		/* 8208ABF4h case   12:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R10);
		/* 8208ABF4h case   12:*/		return 0x8208ABF8;
		  /* 8208ABF8h */ case   13:  		/* stw R11, <#[R31 + 52]> */
		/* 8208ABF8h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000034) );
		/* 8208ABF8h case   13:*/		return 0x8208ABFC;
		  /* 8208ABFCh */ case   14:  		/* bc 12, CR6_LT, 8 */
		/* 8208ABFCh case   14:*/		if ( regs.CR[6].lt ) { return 0x8208AC04;  }
		/* 8208ABFCh case   14:*/		return 0x8208AC00;
		  /* 8208AC00h */ case   15:  		/* stw R30, <#[R31 + 28]> */
		/* 8208AC00h case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000001C) );
		/* 8208AC00h case   15:*/		return 0x8208AC04;
	}
	return 0x8208AC04;
} // Block from 8208ABC4h-8208AC04h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8208AC04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208AC04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208AC04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208AC04);
		  /* 8208AC04h */ case    0:  		/* addi R1, R1, 128 */
		/* 8208AC04h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8208AC04h case    0:*/		return 0x8208AC08;
		  /* 8208AC08h */ case    1:  		/* b 26272 */
		/* 8208AC08h case    1:*/		return 0x820912A8;
		/* 8208AC08h case    1:*/		return 0x8208AC0C;
	}
	return 0x8208AC0C;
} // Block from 8208AC04h-8208AC0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208AC0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208AC0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208AC0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208AC0C);
		  /* 8208AC0Ch */ case    0:  		/* add R9, R29, R30 */
		/* 8208AC0Ch case    0:*/		cpu::op::add<0>(regs,&regs.R9,regs.R29,regs.R30);
		/* 8208AC0Ch case    0:*/		return 0x8208AC10;
		  /* 8208AC10h */ case    1:  		/* cmplw CR6, R9, R10 */
		/* 8208AC10h case    1:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 8208AC10h case    1:*/		return 0x8208AC14;
		  /* 8208AC14h */ case    2:  		/* bc 4, CR6_EQ, -80 */
		/* 8208AC14h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8208ABC4;  }
		/* 8208AC14h case    2:*/		return 0x8208AC18;
		  /* 8208AC18h */ case    3:  		/* lwz R10, <#[R11 + 8]> */
		/* 8208AC18h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8208AC18h case    3:*/		return 0x8208AC1C;
		  /* 8208AC1Ch */ case    4:  		/* stw R29, <#[R11 + 4]> */
		/* 8208AC1Ch case    4:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000004) );
		/* 8208AC1Ch case    4:*/		return 0x8208AC20;
		  /* 8208AC20h */ case    5:  		/* add R10, R30, R10 */
		/* 8208AC20h case    5:*/		cpu::op::add<0>(regs,&regs.R10,regs.R30,regs.R10);
		/* 8208AC20h case    5:*/		return 0x8208AC24;
		  /* 8208AC24h */ case    6:  		/* stw R10, <#[R11 + 8]> */
		/* 8208AC24h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8208AC24h case    6:*/		return 0x8208AC28;
		  /* 8208AC28h */ case    7:  		/* lwz R11, <#[R31 + 28]> */
		/* 8208AC28h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 8208AC28h case    7:*/		return 0x8208AC2C;
		  /* 8208AC2Ch */ case    8:  		/* cmplw CR6, R10, R11 */
		/* 8208AC2Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208AC2Ch case    8:*/		return 0x8208AC30;
		  /* 8208AC30h */ case    9:  		/* bc 4, CR6_GT, -44 */
		/* 8208AC30h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8208AC04;  }
		/* 8208AC30h case    9:*/		return 0x8208AC34;
		  /* 8208AC34h */ case   10:  		/* stw R10, <#[R31 + 28]> */
		/* 8208AC34h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 8208AC34h case   10:*/		return 0x8208AC38;
		  /* 8208AC38h */ case   11:  		/* b -52 */
		/* 8208AC38h case   11:*/		return 0x8208AC04;
		/* 8208AC38h case   11:*/		return 0x8208AC3C;
		  /* 8208AC3Ch */ case   12:  		/* nop */
		/* 8208AC3Ch case   12:*/		cpu::op::nop();
		/* 8208AC3Ch case   12:*/		return 0x8208AC40;
	}
	return 0x8208AC40;
} // Block from 8208AC0Ch-8208AC40h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8208AC40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208AC40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208AC40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208AC40);
		  /* 8208AC40h */ case    0:  		/* mfspr R12, LR */
		/* 8208AC40h case    0:*/		regs.R12 = regs.LR;
		/* 8208AC40h case    0:*/		return 0x8208AC44;
		  /* 8208AC44h */ case    1:  		/* bl 26120 */
		/* 8208AC44h case    1:*/		regs.LR = 0x8208AC48; return 0x8209124C;
		/* 8208AC44h case    1:*/		return 0x8208AC48;
		  /* 8208AC48h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 8208AC48h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 8208AC48h case    2:*/		return 0x8208AC4C;
		  /* 8208AC4Ch */ case    3:  		/* lwz R31, <#[R4 + 56]> */
		/* 8208AC4Ch case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R4 + 0x00000038) );
		/* 8208AC4Ch case    3:*/		return 0x8208AC50;
		  /* 8208AC50h */ case    4:  		/* addi R25, R4, 56 */
		/* 8208AC50h case    4:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R4,0x38);
		/* 8208AC50h case    4:*/		return 0x8208AC54;
		  /* 8208AC54h */ case    5:  		/* li R26, 0 */
		/* 8208AC54h case    5:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8208AC54h case    5:*/		return 0x8208AC58;
		  /* 8208AC58h */ case    6:  		/* mr R30, R4 */
		/* 8208AC58h case    6:*/		regs.R30 = regs.R4;
		/* 8208AC58h case    6:*/		return 0x8208AC5C;
		  /* 8208AC5Ch */ case    7:  		/* mr R28, R5 */
		/* 8208AC5Ch case    7:*/		regs.R28 = regs.R5;
		/* 8208AC5Ch case    7:*/		return 0x8208AC60;
		  /* 8208AC60h */ case    8:  		/* mr R27, R25 */
		/* 8208AC60h case    8:*/		regs.R27 = regs.R25;
		/* 8208AC60h case    8:*/		return 0x8208AC64;
		  /* 8208AC64h */ case    9:  		/* mr R29, R26 */
		/* 8208AC64h case    9:*/		regs.R29 = regs.R26;
		/* 8208AC64h case    9:*/		return 0x8208AC68;
		  /* 8208AC68h */ case   10:  		/* cmplwi CR6, R31, 0 */
		/* 8208AC68h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8208AC68h case   10:*/		return 0x8208AC6C;
		  /* 8208AC6Ch */ case   11:  		/* bc 12, CR6_EQ, 60 */
		/* 8208AC6Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x8208ACA8;  }
		/* 8208AC6Ch case   11:*/		return 0x8208AC70;
		  /* 8208AC70h */ case   12:  		/* lwz R11, <#[R5]> */
		/* 8208AC70h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8208AC70h case   12:*/		return 0x8208AC74;
		  /* 8208AC74h */ case   13:  		/* lwz R10, <#[R31 + 8]> */
		/* 8208AC74h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8208AC74h case   13:*/		return 0x8208AC78;
		  /* 8208AC78h */ case   14:  		/* cmplw CR6, R10, R11 */
		/* 8208AC78h case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208AC78h case   14:*/		return 0x8208AC7C;
		  /* 8208AC7Ch */ case   15:  		/* bc 12, CR6_LT, 24 */
		/* 8208AC7Ch case   15:*/		if ( regs.CR[6].lt ) { return 0x8208AC94;  }
		/* 8208AC7Ch case   15:*/		return 0x8208AC80;
		  /* 8208AC80h */ case   16:  		/* cmplwi CR6, R6, 0 */
		/* 8208AC80h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8208AC80h case   16:*/		return 0x8208AC84;
		  /* 8208AC84h */ case   17:  		/* bc 12, CR6_EQ, 48 */
		/* 8208AC84h case   17:*/		if ( regs.CR[6].eq ) { return 0x8208ACB4;  }
		/* 8208AC84h case   17:*/		return 0x8208AC88;
		  /* 8208AC88h */ case   18:  		/* lwz R10, <#[R31 + 4]> */
		/* 8208AC88h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8208AC88h case   18:*/		return 0x8208AC8C;
		  /* 8208AC8Ch */ case   19:  		/* cmplw CR6, R10, R6 */
		/* 8208AC8Ch case   19:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 8208AC8Ch case   19:*/		return 0x8208AC90;
		  /* 8208AC90h */ case   20:  		/* bc 12, CR6_EQ, 36 */
		/* 8208AC90h case   20:*/		if ( regs.CR[6].eq ) { return 0x8208ACB4;  }
		/* 8208AC90h case   20:*/		return 0x8208AC94;
	}
	return 0x8208AC94;
} // Block from 8208AC40h-8208AC94h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8208AC94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208AC94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208AC94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208AC94);
		  /* 8208AC94h */ case    0:  		/* mr R29, R31 */
		/* 8208AC94h case    0:*/		regs.R29 = regs.R31;
		/* 8208AC94h case    0:*/		return 0x8208AC98;
		  /* 8208AC98h */ case    1:  		/* mr R27, R31 */
		/* 8208AC98h case    1:*/		regs.R27 = regs.R31;
		/* 8208AC98h case    1:*/		return 0x8208AC9C;
		  /* 8208AC9Ch */ case    2:  		/* lwz R31, <#[R31]> */
		/* 8208AC9Ch case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000000) );
		/* 8208AC9Ch case    2:*/		return 0x8208ACA0;
		  /* 8208ACA0h */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 8208ACA0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8208ACA0h case    3:*/		return 0x8208ACA4;
		  /* 8208ACA4h */ case    4:  		/* bc 4, CR6_EQ, -48 */
		/* 8208ACA4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8208AC74;  }
		/* 8208ACA4h case    4:*/		return 0x8208ACA8;
	}
	return 0x8208ACA8;
} // Block from 8208AC94h-8208ACA8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208ACA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208ACA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208ACA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208ACA8);
		  /* 8208ACA8h */ case    0:  		/* li R3, 0 */
		/* 8208ACA8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208ACA8h case    0:*/		return 0x8208ACAC;
		  /* 8208ACACh */ case    1:  		/* addi R1, R1, 160 */
		/* 8208ACACh case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 8208ACACh case    1:*/		return 0x8208ACB0;
		  /* 8208ACB0h */ case    2:  		/* b 26092 */
		/* 8208ACB0h case    2:*/		return 0x8209129C;
		/* 8208ACB0h case    2:*/		return 0x8208ACB4;
	}
	return 0x8208ACB4;
} // Block from 8208ACA8h-8208ACB4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208ACB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208ACB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208ACB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208ACB4);
		  /* 8208ACB4h */ case    0:  		/* lwz R10, <#[R31 + 4]> */
		/* 8208ACB4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8208ACB4h case    0:*/		return 0x8208ACB8;
		  /* 8208ACB8h */ case    1:  		/* lwz R11, <#[R3 + 1412]> */
		/* 8208ACB8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000584) );
		/* 8208ACB8h case    1:*/		return 0x8208ACBC;
		  /* 8208ACBCh */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8208ACBCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208ACBCh case    2:*/		return 0x8208ACC0;
		  /* 8208ACC0h */ case    3:  		/* stw R10, <#[R1 + 80]> */
		/* 8208ACC0h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8208ACC0h case    3:*/		return 0x8208ACC4;
		  /* 8208ACC4h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 8208ACC4h case    4:*/		if ( regs.CR[6].eq ) { return 0x8208ACDC;  }
		/* 8208ACC4h case    4:*/		return 0x8208ACC8;
		  /* 8208ACC8h */ case    5:  		/* mr R5, R28 */
		/* 8208ACC8h case    5:*/		regs.R5 = regs.R28;
		/* 8208ACC8h case    5:*/		return 0x8208ACCC;
		  /* 8208ACCCh */ case    6:  		/* mtspr CTR, R11 */
		/* 8208ACCCh case    6:*/		regs.CTR = regs.R11;
		/* 8208ACCCh case    6:*/		return 0x8208ACD0;
		  /* 8208ACD0h */ case    7:  		/* addi R4, R1, 80 */
		/* 8208ACD0h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8208ACD0h case    7:*/		return 0x8208ACD4;
		  /* 8208ACD4h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 8208ACD4h case    8:*/		if ( 1 ) { regs.LR = 0x8208ACD8; return (uint32)regs.CTR; }
		/* 8208ACD4h case    8:*/		return 0x8208ACD8;
		  /* 8208ACD8h */ case    9:  		/* b 32 */
		/* 8208ACD8h case    9:*/		return 0x8208ACF8;
		/* 8208ACD8h case    9:*/		return 0x8208ACDC;
	}
	return 0x8208ACDC;
} // Block from 8208ACB4h-8208ACDCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 8208ACDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208ACDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208ACDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208ACDC);
		  /* 8208ACDCh */ case    0:  		/* lis R5, 24576 */
		/* 8208ACDCh case    0:*/		cpu::op::lis<0>(regs,&regs.R5,0x6000);
		/* 8208ACDCh case    0:*/		return 0x8208ACE0;
		  /* 8208ACE0h */ case    1:  		/* lwz R7, <#[R3 + 1424]> */
		/* 8208ACE0h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000590) );
		/* 8208ACE0h case    1:*/		return 0x8208ACE4;
		  /* 8208ACE4h */ case    2:  		/* li R6, 4 */
		/* 8208ACE4h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 8208ACE4h case    2:*/		return 0x8208ACE8;
		  /* 8208ACE8h */ case    3:  		/* ori R5, R5, 4096 */
		/* 8208ACE8h case    3:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x1000);
		/* 8208ACE8h case    3:*/		return 0x8208ACEC;
		  /* 8208ACECh */ case    4:  		/* mr R4, R28 */
		/* 8208ACECh case    4:*/		regs.R4 = regs.R28;
		/* 8208ACECh case    4:*/		return 0x8208ACF0;
		  /* 8208ACF0h */ case    5:  		/* addi R3, R1, 80 */
		/* 8208ACF0h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8208ACF0h case    5:*/		return 0x8208ACF4;
		  /* 8208ACF4h */ case    6:  		/* bl 1976132 */
		/* 8208ACF4h case    6:*/		regs.LR = 0x8208ACF8; return 0x8226D438;
		/* 8208ACF4h case    6:*/		return 0x8208ACF8;
	}
	return 0x8208ACF8;
} // Block from 8208ACDCh-8208ACF8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208ACF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208ACF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208ACF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208ACF8);
		  /* 8208ACF8h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 8208ACF8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8208ACF8h case    0:*/		return 0x8208ACFC;
		  /* 8208ACFCh */ case    1:  		/* bc 12, CR6_LT, -84 */
		/* 8208ACFCh case    1:*/		if ( regs.CR[6].lt ) { return 0x8208ACA8;  }
		/* 8208ACFCh case    1:*/		return 0x8208AD00;
		  /* 8208AD00h */ case    2:  		/* lhz R11, <#[R28]> */
		/* 8208AD00h case    2:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8208AD00h case    2:*/		return 0x8208AD04;
		  /* 8208AD04h */ case    3:  		/* lwz R10, <#[R30 + 48]> */
		/* 8208AD04h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000030) );
		/* 8208AD04h case    3:*/		return 0x8208AD08;
		  /* 8208AD08h */ case    4:  		/* lwz R9, <#[R30 + 28]> */
		/* 8208AD08h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000001C) );
		/* 8208AD08h case    4:*/		return 0x8208AD0C;
		  /* 8208AD0Ch */ case    5:  		/* subf R11, R11, R10 */
		/* 8208AD0Ch case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8208AD0Ch case    5:*/		return 0x8208AD10;
		  /* 8208AD10h */ case    6:  		/* stw R11, <#[R30 + 48]> */
		/* 8208AD10h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 8208AD10h case    6:*/		return 0x8208AD14;
		  /* 8208AD14h */ case    7:  		/* lwz R11, <#[R31 + 8]> */
		/* 8208AD14h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8208AD14h case    7:*/		return 0x8208AD18;
		  /* 8208AD18h */ case    8:  		/* cmplw CR6, R9, R11 */
		/* 8208AD18h case    8:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8208AD18h case    8:*/		return 0x8208AD1C;
		  /* 8208AD1Ch */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 8208AD1Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x8208AD24;  }
		/* 8208AD1Ch case    9:*/		return 0x8208AD20;
		  /* 8208AD20h */ case   10:  		/* stw R26, <#[R30 + 28]> */
		/* 8208AD20h case   10:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x0000001C) );
		/* 8208AD20h case   10:*/		return 0x8208AD24;
	}
	return 0x8208AD24;
} // Block from 8208ACF8h-8208AD24h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8208AD24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208AD24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208AD24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208AD24);
		  /* 8208AD24h */ case    0:  		/* lwz R11, <#[R30 + 64]> */
		/* 8208AD24h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000040) );
		/* 8208AD24h case    0:*/		return 0x8208AD28;
		  /* 8208AD28h */ case    1:  		/* lwz R7, <#[R1 + 80]> */
		/* 8208AD28h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 8208AD28h case    1:*/		return 0x8208AD2C;
		  /* 8208AD2Ch */ case    2:  		/* mr R3, R7 */
		/* 8208AD2Ch case    2:*/		regs.R3 = regs.R7;
		/* 8208AD2Ch case    2:*/		return 0x8208AD30;
		  /* 8208AD30h */ case    3:  		/* lbz R10, <#[R11 + 5]> */
		/* 8208AD30h case    3:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000005) );
		/* 8208AD30h case    3:*/		return 0x8208AD34;
		  /* 8208AD34h */ case    4:  		/* rlwinm. R10, R10, 0, 27, 27 */
		/* 8208AD34h case    4:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R10);
		/* 8208AD34h case    4:*/		return 0x8208AD38;
		  /* 8208AD38h */ case    5:  		/* bc 12, CR0_EQ, 28 */
		/* 8208AD38h case    5:*/		if ( regs.CR[0].eq ) { return 0x8208AD54;  }
		/* 8208AD38h case    5:*/		return 0x8208AD3C;
		  /* 8208AD3Ch */ case    6:  		/* lhz R10, <#[R11]> */
		/* 8208AD3Ch case    6:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208AD3Ch case    6:*/		return 0x8208AD40;
		  /* 8208AD40h */ case    7:  		/* lwz R9, <#[R31 + 4]> */
		/* 8208AD40h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 8208AD40h case    7:*/		return 0x8208AD44;
		  /* 8208AD44h */ case    8:  		/* rlwinm R10, R10, 4, 0, 31 */
		/* 8208AD44h case    8:*/		cpu::op::rlwinm<0,4,0,31>(regs,&regs.R10,regs.R10);
		/* 8208AD44h case    8:*/		return 0x8208AD48;
		  /* 8208AD48h */ case    9:  		/* add R10, R10, R11 */
		/* 8208AD48h case    9:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8208AD48h case    9:*/		return 0x8208AD4C;
		  /* 8208AD4Ch */ case   10:  		/* cmplw CR6, R10, R9 */
		/* 8208AD4Ch case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8208AD4Ch case   10:*/		return 0x8208AD50;
		  /* 8208AD50h */ case   11:  		/* bc 12, CR6_EQ, 112 */
		/* 8208AD50h case   11:*/		if ( regs.CR[6].eq ) { return 0x8208ADC0;  }
		/* 8208AD50h case   11:*/		return 0x8208AD54;
	}
	return 0x8208AD54;
} // Block from 8208AD24h-8208AD54h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8208AD54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208AD54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208AD54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208AD54);
		  /* 8208AD54h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 8208AD54h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8208AD54h case    0:*/		return 0x8208AD58;
		  /* 8208AD58h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 8208AD58h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8208AD64;  }
		/* 8208AD58h case    1:*/		return 0x8208AD5C;
		  /* 8208AD5Ch */ case    2:  		/* lwz R11, <#[R30 + 40]> */
		/* 8208AD5Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 8208AD5Ch case    2:*/		return 0x8208AD60;
		  /* 8208AD60h */ case    3:  		/* b 16 */
		/* 8208AD60h case    3:*/		return 0x8208AD70;
		/* 8208AD60h case    3:*/		return 0x8208AD64;
	}
	return 0x8208AD64;
} // Block from 8208AD54h-8208AD64h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208AD64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208AD64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208AD64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208AD64);
		  /* 8208AD64h */ case    0:  		/* lwz R10, <#[R29 + 8]> */
		/* 8208AD64h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 8208AD64h case    0:*/		return 0x8208AD68;
		  /* 8208AD68h */ case    1:  		/* lwz R11, <#[R29 + 4]> */
		/* 8208AD68h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8208AD68h case    1:*/		return 0x8208AD6C;
		  /* 8208AD6Ch */ case    2:  		/* add R11, R10, R11 */
		/* 8208AD6Ch case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208AD6Ch case    2:*/		return 0x8208AD70;
	}
	return 0x8208AD70;
} // Block from 8208AD64h-8208AD70h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208AD70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208AD70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208AD70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208AD70);
		  /* 8208AD70h */ case    0:  		/* lbz R10, <#[R11 + 5]> */
		/* 8208AD70h case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000005) );
		/* 8208AD70h case    0:*/		return 0x8208AD74;
		  /* 8208AD74h */ case    1:  		/* rlwinm. R10, R10, 0, 27, 27 */
		/* 8208AD74h case    1:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R10);
		/* 8208AD74h case    1:*/		return 0x8208AD78;
		  /* 8208AD78h */ case    2:  		/* bc 4, CR0_EQ, 72 */
		/* 8208AD78h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8208ADC0;  }
		/* 8208AD78h case    2:*/		return 0x8208AD7C;
		  /* 8208AD7Ch */ case    3:  		/* lwz R9, <#[R30 + 44]> */
		/* 8208AD7Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000002C) );
		/* 8208AD7Ch case    3:*/		return 0x8208AD80;
		  /* 8208AD80h */ case    4:  		/* lhz R10, <#[R11]> */
		/* 8208AD80h case    4:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208AD80h case    4:*/		return 0x8208AD84;
		  /* 8208AD84h */ case    5:  		/* mr R8, R11 */
		/* 8208AD84h case    5:*/		regs.R8 = regs.R11;
		/* 8208AD84h case    5:*/		return 0x8208AD88;
		  /* 8208AD88h */ case    6:  		/* rlwinm R10, R10, 4, 0, 31 */
		/* 8208AD88h case    6:*/		cpu::op::rlwinm<0,4,0,31>(regs,&regs.R10,regs.R10);
		/* 8208AD88h case    6:*/		return 0x8208AD8C;
		  /* 8208AD8Ch */ case    7:  		/* add R11, R10, R11 */
		/* 8208AD8Ch case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208AD8Ch case    7:*/		return 0x8208AD90;
		  /* 8208AD90h */ case    8:  		/* cmplw CR6, R11, R9 */
		/* 8208AD90h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8208AD90h case    8:*/		return 0x8208AD94;
		  /* 8208AD94h */ case    9:  		/* bc 4, CR6_LT, 32 */
		/* 8208AD94h case    9:*/		if ( !regs.CR[6].lt ) { return 0x8208ADB4;  }
		/* 8208AD94h case    9:*/		return 0x8208AD98;
		  /* 8208AD98h */ case   10:  		/* lhz R10, <#[R11]> */
		/* 8208AD98h case   10:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208AD98h case   10:*/		return 0x8208AD9C;
		  /* 8208AD9Ch */ case   11:  		/* cmplwi CR0, R10, 0 */
		/* 8208AD9Ch case   11:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 8208AD9Ch case   11:*/		return 0x8208ADA0;
		  /* 8208ADA0h */ case   12:  		/* bc 12, CR0_EQ, 20 */
		/* 8208ADA0h case   12:*/		if ( regs.CR[0].eq ) { return 0x8208ADB4;  }
		/* 8208ADA0h case   12:*/		return 0x8208ADA4;
		  /* 8208ADA4h */ case   13:  		/* lbz R10, <#[R11 + 5]> */
		/* 8208ADA4h case   13:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000005) );
		/* 8208ADA4h case   13:*/		return 0x8208ADA8;
		  /* 8208ADA8h */ case   14:  		/* rlwinm. R10, R10, 0, 27, 27 */
		/* 8208ADA8h case   14:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R10);
		/* 8208ADA8h case   14:*/		return 0x8208ADAC;
		  /* 8208ADACh */ case   15:  		/* bc 12, CR0_EQ, -44 */
		/* 8208ADACh case   15:*/		if ( regs.CR[0].eq ) { return 0x8208AD80;  }
		/* 8208ADACh case   15:*/		return 0x8208ADB0;
		  /* 8208ADB0h */ case   16:  		/* b 16 */
		/* 8208ADB0h case   16:*/		return 0x8208ADC0;
		/* 8208ADB0h case   16:*/		return 0x8208ADB4;
	}
	return 0x8208ADB4;
} // Block from 8208AD70h-8208ADB4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8208ADB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208ADB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208ADB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208ADB4);
		  /* 8208ADB4h */ case    0:  		/* cmplw CR6, R11, R7 */
		/* 8208ADB4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 8208ADB4h case    0:*/		return 0x8208ADB8;
		  /* 8208ADB8h */ case    1:  		/* bc 4, CR6_EQ, -272 */
		/* 8208ADB8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8208ACA8;  }
		/* 8208ADB8h case    1:*/		return 0x8208ADBC;
		  /* 8208ADBCh */ case    2:  		/* mr R11, R8 */
		/* 8208ADBCh case    2:*/		regs.R11 = regs.R8;
		/* 8208ADBCh case    2:*/		return 0x8208ADC0;
	}
	return 0x8208ADC0;
} // Block from 8208ADB4h-8208ADC0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208ADC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208ADC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208ADC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208ADC0);
		  /* 8208ADC0h */ case    0:  		/* lbz R10, <#[R11 + 5]> */
		/* 8208ADC0h case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000005) );
		/* 8208ADC0h case    0:*/		return 0x8208ADC4;
		  /* 8208ADC4h */ case    1:  		/* andi. R10, R10, 239 */
		/* 8208ADC4h case    1:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R10,0xEF);
		/* 8208ADC4h case    1:*/		return 0x8208ADC8;
		  /* 8208ADC8h */ case    2:  		/* stb R10, <#[R11 + 5]> */
		/* 8208ADC8h case    2:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000005) );
		/* 8208ADC8h case    2:*/		return 0x8208ADCC;
		  /* 8208ADCCh */ case    3:  		/* lwz R8, <#[R31 + 8]> */
		/* 8208ADCCh case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 8208ADCCh case    3:*/		return 0x8208ADD0;
		  /* 8208ADD0h */ case    4:  		/* lwz R9, <#[R28]> */
		/* 8208ADD0h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000000) );
		/* 8208ADD0h case    4:*/		return 0x8208ADD4;
		  /* 8208ADD4h */ case    5:  		/* lwz R10, <#[R31 + 4]> */
		/* 8208ADD4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8208ADD4h case    5:*/		return 0x8208ADD8;
		  /* 8208ADD8h */ case    6:  		/* add R10, R10, R9 */
		/* 8208ADD8h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8208ADD8h case    6:*/		return 0x8208ADDC;
		  /* 8208ADDCh */ case    7:  		/* stw R10, <#[R31 + 4]> */
		/* 8208ADDCh case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8208ADDCh case    7:*/		return 0x8208ADE0;
		  /* 8208ADE0h */ case    8:  		/* lwz R10, <#[R28]> */
		/* 8208ADE0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 8208ADE0h case    8:*/		return 0x8208ADE4;
		  /* 8208ADE4h */ case    9:  		/* subf. R10, R10, R8 */
		/* 8208ADE4h case    9:*/		cpu::op::subf<1>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8208ADE4h case    9:*/		return 0x8208ADE8;
		  /* 8208ADE8h */ case   10:  		/* stw R10, <#[R31 + 8]> */
		/* 8208ADE8h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8208ADE8h case   10:*/		return 0x8208ADEC;
		  /* 8208ADECh */ case   11:  		/* bc 4, CR0_EQ, 100 */
		/* 8208ADECh case   11:*/		if ( !regs.CR[0].eq ) { return 0x8208AE50;  }
		/* 8208ADECh case   11:*/		return 0x8208ADF0;
		  /* 8208ADF0h */ case   12:  		/* lwz R10, <#[R31 + 4]> */
		/* 8208ADF0h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8208ADF0h case   12:*/		return 0x8208ADF4;
		  /* 8208ADF4h */ case   13:  		/* lwz R9, <#[R30 + 44]> */
		/* 8208ADF4h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000002C) );
		/* 8208ADF4h case   13:*/		return 0x8208ADF8;
		  /* 8208ADF8h */ case   14:  		/* cmplw CR6, R10, R9 */
		/* 8208ADF8h case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8208ADF8h case   14:*/		return 0x8208ADFC;
		  /* 8208ADFCh */ case   15:  		/* bc 4, CR6_EQ, 20 */
		/* 8208ADFCh case   15:*/		if ( !regs.CR[6].eq ) { return 0x8208AE10;  }
		/* 8208ADFCh case   15:*/		return 0x8208AE00;
		  /* 8208AE00h */ case   16:  		/* li R10, 16 */
		/* 8208AE00h case   16:*/		cpu::op::li<0>(regs,&regs.R10,0x10);
		/* 8208AE00h case   16:*/		return 0x8208AE04;
		  /* 8208AE04h */ case   17:  		/* stb R10, <#[R3 + 5]> */
		/* 8208AE04h case   17:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R3 + 0x00000005) );
		/* 8208AE04h case   17:*/		return 0x8208AE08;
		  /* 8208AE08h */ case   18:  		/* stw R3, <#[R30 + 64]> */
		/* 8208AE08h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000040) );
		/* 8208AE08h case   18:*/		return 0x8208AE0C;
		  /* 8208AE0Ch */ case   19:  		/* b 16 */
		/* 8208AE0Ch case   19:*/		return 0x8208AE1C;
		/* 8208AE0Ch case   19:*/		return 0x8208AE10;
	}
	return 0x8208AE10;
} // Block from 8208ADC0h-8208AE10h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8208AE10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208AE10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208AE10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208AE10);
		  /* 8208AE10h */ case    0:  		/* stb R26, <#[R3 + 5]> */
		/* 8208AE10h case    0:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R3 + 0x00000005) );
		/* 8208AE10h case    0:*/		return 0x8208AE14;
		  /* 8208AE14h */ case    1:  		/* lwz R10, <#[R30 + 40]> */
		/* 8208AE14h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000028) );
		/* 8208AE14h case    1:*/		return 0x8208AE18;
		  /* 8208AE18h */ case    2:  		/* stw R10, <#[R30 + 64]> */
		/* 8208AE18h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000040) );
		/* 8208AE18h case    2:*/		return 0x8208AE1C;
	}
	return 0x8208AE1C;
} // Block from 8208AE10h-8208AE1Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208AE1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208AE1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208AE1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208AE1C);
		  /* 8208AE1Ch */ case    0:  		/* lwz R10, <#[R31]> */
		/* 8208AE1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8208AE1Ch case    0:*/		return 0x8208AE20;
		  /* 8208AE20h */ case    1:  		/* stw R10, <#[R27]> */
		/* 8208AE20h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 8208AE20h case    1:*/		return 0x8208AE24;
		  /* 8208AE24h */ case    2:  		/* lwz R10, <#[R30 + 24]> */
		/* 8208AE24h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000018) );
		/* 8208AE24h case    2:*/		return 0x8208AE28;
		  /* 8208AE28h */ case    3:  		/* lwz R10, <#[R10 + 76]> */
		/* 8208AE28h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000004C) );
		/* 8208AE28h case    3:*/		return 0x8208AE2C;
		  /* 8208AE2Ch */ case    4:  		/* stw R10, <#[R31]> */
		/* 8208AE2Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8208AE2Ch case    4:*/		return 0x8208AE30;
		  /* 8208AE30h */ case    5:  		/* lwz R10, <#[R30 + 24]> */
		/* 8208AE30h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000018) );
		/* 8208AE30h case    5:*/		return 0x8208AE34;
		  /* 8208AE34h */ case    6:  		/* stw R31, <#[R10 + 76]> */
		/* 8208AE34h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R10 + 0x0000004C) );
		/* 8208AE34h case    6:*/		return 0x8208AE38;
		  /* 8208AE38h */ case    7:  		/* stw R26, <#[R31 + 4]> */
		/* 8208AE38h case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000004) );
		/* 8208AE38h case    7:*/		return 0x8208AE3C;
		  /* 8208AE3Ch */ case    8:  		/* stw R26, <#[R31 + 8]> */
		/* 8208AE3Ch case    8:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000008) );
		/* 8208AE3Ch case    8:*/		return 0x8208AE40;
		  /* 8208AE40h */ case    9:  		/* lwz R10, <#[R30 + 52]> */
		/* 8208AE40h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000034) );
		/* 8208AE40h case    9:*/		return 0x8208AE44;
		  /* 8208AE44h */ case   10:  		/* addi R10, R10, -1 */
		/* 8208AE44h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8208AE44h case   10:*/		return 0x8208AE48;
		  /* 8208AE48h */ case   11:  		/* stw R10, <#[R30 + 52]> */
		/* 8208AE48h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000034) );
		/* 8208AE48h case   11:*/		return 0x8208AE4C;
		  /* 8208AE4Ch */ case   12:  		/* b 16 */
		/* 8208AE4Ch case   12:*/		return 0x8208AE5C;
		/* 8208AE4Ch case   12:*/		return 0x8208AE50;
	}
	return 0x8208AE50;
} // Block from 8208AE1Ch-8208AE50h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8208AE50h
// Function '?DoDisassembly@Disassembler@D3D@@QAAJTGPU_PROGRAMCONTROL@@TGPU_CONTEXTMISC@@PADII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208AE50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208AE50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208AE50);
		  /* 8208AE50h */ case    0:  		/* li R10, 16 */
		/* 8208AE50h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x10);
		/* 8208AE50h case    0:*/		return 0x8208AE54;
		  /* 8208AE54h */ case    1:  		/* stb R10, <#[R3 + 5]> */
		/* 8208AE54h case    1:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R3 + 0x00000005) );
		/* 8208AE54h case    1:*/		return 0x8208AE58;
		  /* 8208AE58h */ case    2:  		/* stw R3, <#[R30 + 64]> */
		/* 8208AE58h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000040) );
		/* 8208AE58h case    2:*/		return 0x8208AE5C;
	}
	return 0x8208AE5C;
} // Block from 8208AE50h-8208AE5Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208AE5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208AE5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208AE5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208AE5C);
		  /* 8208AE5Ch */ case    0:  		/* lbz R10, <#[R11 + 4]> */
		/* 8208AE5Ch case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8208AE5Ch case    0:*/		return 0x8208AE60;
		  /* 8208AE60h */ case    1:  		/* lbz R9, <#[R3 + 5]> */
		/* 8208AE60h case    1:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000005) );
		/* 8208AE60h case    1:*/		return 0x8208AE64;
		  /* 8208AE64h */ case    2:  		/* rlwinm. R9, R9, 0, 27, 27 */
		/* 8208AE64h case    2:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R9,regs.R9);
		/* 8208AE64h case    2:*/		return 0x8208AE68;
		  /* 8208AE68h */ case    3:  		/* stb R10, <#[R3 + 4]> */
		/* 8208AE68h case    3:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 8208AE68h case    3:*/		return 0x8208AE6C;
		  /* 8208AE6Ch */ case    4:  		/* lwz R10, <#[R28]> */
		/* 8208AE6Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 8208AE6Ch case    4:*/		return 0x8208AE70;
		  /* 8208AE70h */ case    5:  		/* rlwinm R10, R10, 28, 16, 31 */
		/* 8208AE70h case    5:*/		cpu::op::rlwinm<0,28,16,31>(regs,&regs.R10,regs.R10);
		/* 8208AE70h case    5:*/		return 0x8208AE74;
		  /* 8208AE74h */ case    6:  		/* sth R10, <#[R3]> */
		/* 8208AE74h case    6:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8208AE74h case    6:*/		return 0x8208AE78;
		  /* 8208AE78h */ case    7:  		/* lhz R11, <#[R11]> */
		/* 8208AE78h case    7:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8208AE78h case    7:*/		return 0x8208AE7C;
		  /* 8208AE7Ch */ case    8:  		/* sth R11, <#[R3 + 2]> */
		/* 8208AE7Ch case    8:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R3 + 0x00000002) );
		/* 8208AE7Ch case    8:*/		return 0x8208AE80;
		  /* 8208AE80h */ case    9:  		/* bc 4, CR0_EQ, 20 */
		/* 8208AE80h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8208AE94;  }
		/* 8208AE80h case    9:*/		return 0x8208AE84;
		  /* 8208AE84h */ case   10:  		/* rlwinm R10, R10, 0, 16, 31 */
		/* 8208AE84h case   10:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R10);
		/* 8208AE84h case   10:*/		return 0x8208AE88;
		  /* 8208AE88h */ case   11:  		/* rlwinm R11, R10, 4, 0, 31 */
		/* 8208AE88h case   11:*/		cpu::op::rlwinm<0,4,0,31>(regs,&regs.R11,regs.R10);
		/* 8208AE88h case   11:*/		return 0x8208AE8C;
		  /* 8208AE8Ch */ case   12:  		/* add R11, R11, R3 */
		/* 8208AE8Ch case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8208AE8Ch case   12:*/		return 0x8208AE90;
		  /* 8208AE90h */ case   13:  		/* sth R10, <#[R11 + 2]> */
		/* 8208AE90h case   13:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R11 + 0x00000002) );
		/* 8208AE90h case   13:*/		return 0x8208AE94;
	}
	return 0x8208AE94;
} // Block from 8208AE5Ch-8208AE94h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8208AE94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208AE94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208AE94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208AE94);
		  /* 8208AE94h */ case    0:  		/* lwz R11, <#[R30 + 28]> */
		/* 8208AE94h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 8208AE94h case    0:*/		return 0x8208AE98;
		  /* 8208AE98h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8208AE98h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208AE98h case    1:*/		return 0x8208AE9C;
		  /* 8208AE9Ch */ case    2:  		/* bc 4, CR6_EQ, -496 */
		/* 8208AE9Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x8208ACAC;  }
		/* 8208AE9Ch case    2:*/		return 0x8208AEA0;
		  /* 8208AEA0h */ case    3:  		/* lwz R11, <#[R25]> */
		/* 8208AEA0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 8208AEA0h case    3:*/		return 0x8208AEA4;
		  /* 8208AEA4h */ case    4:  		/* b 28 */
		/* 8208AEA4h case    4:*/		return 0x8208AEC0;
		/* 8208AEA4h case    4:*/		return 0x8208AEA8;
		  /* 8208AEA8h */ case    5:  		/* lwz R10, <#[R11 + 8]> */
		/* 8208AEA8h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8208AEA8h case    5:*/		return 0x8208AEAC;
		  /* 8208AEACh */ case    6:  		/* lwz R9, <#[R30 + 28]> */
		/* 8208AEACh case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000001C) );
		/* 8208AEACh case    6:*/		return 0x8208AEB0;
		  /* 8208AEB0h */ case    7:  		/* cmplw CR6, R10, R9 */
		/* 8208AEB0h case    7:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8208AEB0h case    7:*/		return 0x8208AEB4;
		  /* 8208AEB4h */ case    8:  		/* bc 12, CR6_LT, 8 */
		/* 8208AEB4h case    8:*/		if ( regs.CR[6].lt ) { return 0x8208AEBC;  }
		/* 8208AEB4h case    8:*/		return 0x8208AEB8;
		  /* 8208AEB8h */ case    9:  		/* stw R10, <#[R30 + 28]> */
		/* 8208AEB8h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x0000001C) );
		/* 8208AEB8h case    9:*/		return 0x8208AEBC;
	}
	return 0x8208AEBC;
} // Block from 8208AE94h-8208AEBCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 8208AEBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208AEBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208AEBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208AEBC);
		  /* 8208AEBCh */ case    0:  		/* lwz R11, <#[R11]> */
		/* 8208AEBCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8208AEBCh case    0:*/		return 0x8208AEC0;
	}
	return 0x8208AEC0;
} // Block from 8208AEBCh-8208AEC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208AEC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208AEC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208AEC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208AEC0);
		  /* 8208AEC0h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8208AEC0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208AEC0h case    0:*/		return 0x8208AEC4;
		  /* 8208AEC4h */ case    1:  		/* bc 4, CR6_EQ, -28 */
		/* 8208AEC4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8208AEA8;  }
		/* 8208AEC4h case    1:*/		return 0x8208AEC8;
		  /* 8208AEC8h */ case    2:  		/* b -540 */
		/* 8208AEC8h case    2:*/		return 0x8208ACAC;
		/* 8208AEC8h case    2:*/		return 0x8208AECC;
		  /* 8208AECCh */ case    3:  		/* nop */
		/* 8208AECCh case    3:*/		cpu::op::nop();
		/* 8208AECCh case    3:*/		return 0x8208AED0;
	}
	return 0x8208AED0;
} // Block from 8208AEC0h-8208AED0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208AED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208AED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208AED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208AED0);
		  /* 8208AED0h */ case    0:  		/* mfspr R12, LR */
		/* 8208AED0h case    0:*/		regs.R12 = regs.LR;
		/* 8208AED0h case    0:*/		return 0x8208AED4;
		  /* 8208AED4h */ case    1:  		/* bl 25464 */
		/* 8208AED4h case    1:*/		regs.LR = 0x8208AED8; return 0x8209124C;
		/* 8208AED4h case    1:*/		return 0x8208AED8;
		  /* 8208AED8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8208AED8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8208AED8h case    2:*/		return 0x8208AEDC;
		  /* 8208AEDCh */ case    3:  		/* lhz R11, <#[R4 + 2]> */
		/* 8208AEDCh case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000002) );
		/* 8208AEDCh case    3:*/		return 0x8208AEE0;
		  /* 8208AEE0h */ case    4:  		/* lis R10, -274 */
		/* 8208AEE0h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFEEE);
		/* 8208AEE0h case    4:*/		return 0x8208AEE4;
		  /* 8208AEE4h */ case    5:  		/* mr R29, R3 */
		/* 8208AEE4h case    5:*/		regs.R29 = regs.R3;
		/* 8208AEE4h case    5:*/		return 0x8208AEE8;
		  /* 8208AEE8h */ case    6:  		/* rlwinm R11, R11, 4, 0, 31 */
		/* 8208AEE8h case    6:*/		cpu::op::rlwinm<0,4,0,31>(regs,&regs.R11,regs.R11);
		/* 8208AEE8h case    6:*/		return 0x8208AEEC;
		  /* 8208AEECh */ case    7:  		/* mr R30, R4 */
		/* 8208AEECh case    7:*/		regs.R30 = regs.R4;
		/* 8208AEECh case    7:*/		return 0x8208AEF0;
		  /* 8208AEF0h */ case    8:  		/* subf R31, R11, R4 */
		/* 8208AEF0h case    8:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R11,regs.R4);
		/* 8208AEF0h case    8:*/		return 0x8208AEF4;
		  /* 8208AEF4h */ case    9:  		/* mr R27, R5 */
		/* 8208AEF4h case    9:*/		regs.R27 = regs.R5;
		/* 8208AEF4h case    9:*/		return 0x8208AEF8;
		  /* 8208AEF8h */ case   10:  		/* mr R28, R6 */
		/* 8208AEF8h case   10:*/		regs.R28 = regs.R6;
		/* 8208AEF8h case   10:*/		return 0x8208AEFC;
		  /* 8208AEFCh */ case   11:  		/* li R26, 1 */
		/* 8208AEFCh case   11:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 8208AEFCh case   11:*/		return 0x8208AF00;
		  /* 8208AF00h */ case   12:  		/* ori R25, R10, 65262 */
		/* 8208AF00h case   12:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R10,0xFEEE);
		/* 8208AF00h case   12:*/		return 0x8208AF04;
		  /* 8208AF04h */ case   13:  		/* cmplw CR6, R31, R4 */
		/* 8208AF04h case   13:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R4);
		/* 8208AF04h case   13:*/		return 0x8208AF08;
		  /* 8208AF08h */ case   14:  		/* bc 12, CR6_EQ, 476 */
		/* 8208AF08h case   14:*/		if ( regs.CR[6].eq ) { return 0x8208B0E4;  }
		/* 8208AF08h case   14:*/		return 0x8208AF0C;
		  /* 8208AF0Ch */ case   15:  		/* lbz R11, <#[R31 + 5]> */
		/* 8208AF0Ch case   15:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000005) );
		/* 8208AF0Ch case   15:*/		return 0x8208AF10;
		  /* 8208AF10h */ case   16:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8208AF10h case   16:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8208AF10h case   16:*/		return 0x8208AF14;
		  /* 8208AF14h */ case   17:  		/* bc 4, CR0_EQ, 464 */
		/* 8208AF14h case   17:*/		if ( !regs.CR[0].eq ) { return 0x8208B0E4;  }
		/* 8208AF14h case   17:*/		return 0x8208AF18;
		  /* 8208AF18h */ case   18:  		/* lhz R10, <#[R31]> */
		/* 8208AF18h case   18:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8208AF18h case   18:*/		return 0x8208AF1C;
		  /* 8208AF1Ch */ case   19:  		/* lwz R11, <#[R5]> */
		/* 8208AF1Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8208AF1Ch case   19:*/		return 0x8208AF20;
		  /* 8208AF20h */ case   20:  		/* add R11, R10, R11 */
		/* 8208AF20h case   20:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208AF20h case   20:*/		return 0x8208AF24;
		  /* 8208AF24h */ case   21:  		/* cmplwi CR6, R11, 61440 */
		/* 8208AF24h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000F000);
		/* 8208AF24h case   21:*/		return 0x8208AF28;
		  /* 8208AF28h */ case   22:  		/* bc 12, CR6_GT, 444 */
		/* 8208AF28h case   22:*/		if ( regs.CR[6].gt ) { return 0x8208B0E4;  }
		/* 8208AF28h case   22:*/		return 0x8208AF2C;
		  /* 8208AF2Ch */ case   23:  		/* cmplwi CR6, R6, 0 */
		/* 8208AF2Ch case   23:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8208AF2Ch case   23:*/		return 0x8208AF30;
		  /* 8208AF30h */ case   24:  		/* bc 12, CR6_EQ, 176 */
		/* 8208AF30h case   24:*/		if ( regs.CR[6].eq ) { return 0x8208AFE0;  }
		/* 8208AF30h case   24:*/		return 0x8208AF34;
		  /* 8208AF34h */ case   25:  		/* lwz R11, <#[R4 + 12]> */
		/* 8208AF34h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 8208AF34h case   25:*/		return 0x8208AF38;
		  /* 8208AF38h */ case   26:  		/* addi R9, R4, 8 */
		/* 8208AF38h case   26:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R4,0x8);
		/* 8208AF38h case   26:*/		return 0x8208AF3C;
		  /* 8208AF3Ch */ case   27:  		/* lwz R10, <#[R4 + 8]> */
		/* 8208AF3Ch case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 8208AF3Ch case   27:*/		return 0x8208AF40;
		  /* 8208AF40h */ case   28:  		/* lwz R8, <#[R11]> */
		/* 8208AF40h case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8208AF40h case   28:*/		return 0x8208AF44;
		  /* 8208AF44h */ case   29:  		/* lwz R7, <#[R10 + 4]> */
		/* 8208AF44h case   29:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 8208AF44h case   29:*/		return 0x8208AF48;
		  /* 8208AF48h */ case   30:  		/* cmplw CR6, R8, R7 */
		/* 8208AF48h case   30:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 8208AF48h case   30:*/		return 0x8208AF4C;
		  /* 8208AF4Ch */ case   31:  		/* bc 4, CR6_EQ, 72 */
		/* 8208AF4Ch case   31:*/		if ( !regs.CR[6].eq ) { return 0x8208AF94;  }
		/* 8208AF4Ch case   31:*/		return 0x8208AF50;
		  /* 8208AF50h */ case   32:  		/* cmplw CR6, R8, R9 */
		/* 8208AF50h case   32:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8208AF50h case   32:*/		return 0x8208AF54;
		  /* 8208AF54h */ case   33:  		/* bc 4, CR6_EQ, 64 */
		/* 8208AF54h case   33:*/		if ( !regs.CR[6].eq ) { return 0x8208AF94;  }
		/* 8208AF54h case   33:*/		return 0x8208AF58;
		  /* 8208AF58h */ case   34:  		/* stw R10, <#[R11]> */
		/* 8208AF58h case   34:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208AF58h case   34:*/		return 0x8208AF5C;
		  /* 8208AF5Ch */ case   35:  		/* cmplw CR6, R10, R11 */
		/* 8208AF5Ch case   35:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208AF5Ch case   35:*/		return 0x8208AF60;
		  /* 8208AF60h */ case   36:  		/* stw R11, <#[R10 + 4]> */
		/* 8208AF60h case   36:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8208AF60h case   36:*/		return 0x8208AF64;
		  /* 8208AF64h */ case   37:  		/* bc 4, CR6_EQ, 48 */
		/* 8208AF64h case   37:*/		if ( !regs.CR[6].eq ) { return 0x8208AF94;  }
		/* 8208AF64h case   37:*/		return 0x8208AF68;
		  /* 8208AF68h */ case   38:  		/* lhz R11, <#[R4]> */
		/* 8208AF68h case   38:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8208AF68h case   38:*/		return 0x8208AF6C;
		  /* 8208AF6Ch */ case   39:  		/* cmplwi CR6, R11, 128 */
		/* 8208AF6Ch case   39:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 8208AF6Ch case   39:*/		return 0x8208AF70;
		  /* 8208AF70h */ case   40:  		/* bc 4, CR6_LT, 36 */
		/* 8208AF70h case   40:*/		if ( !regs.CR[6].lt ) { return 0x8208AF94;  }
		/* 8208AF70h case   40:*/		return 0x8208AF74;
		  /* 8208AF74h */ case   41:  		/* rlwinm R10, R11, 27, 5, 31 */
		/* 8208AF74h case   41:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R11);
		/* 8208AF74h case   41:*/		return 0x8208AF78;
		  /* 8208AF78h */ case   42:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8208AF78h case   42:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8208AF78h case   42:*/		return 0x8208AF7C;
		  /* 8208AF7Ch */ case   43:  		/* addi R10, R10, 88 */
		/* 8208AF7Ch case   43:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x58);
		/* 8208AF7Ch case   43:*/		return 0x8208AF80;
		  /* 8208AF80h */ case   44:  		/* slw R9, R26, R11 */
		/* 8208AF80h case   44:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R26,regs.R11);
		/* 8208AF80h case   44:*/		return 0x8208AF84;
		  /* 8208AF84h */ case   45:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 8208AF84h case   45:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 8208AF84h case   45:*/		return 0x8208AF88;
		  /* 8208AF88h */ case   46:  		/* lwzx R10, <#[R11 + R3]> */
		/* 8208AF88h case   46:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8208AF88h case   46:*/		return 0x8208AF8C;
		  /* 8208AF8Ch */ case   47:  		/* xor R10, R9, R10 */
		/* 8208AF8Ch case   47:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8208AF8Ch case   47:*/		return 0x8208AF90;
		  /* 8208AF90h */ case   48:  		/* stwx R10, <#[R11 + R3]> */
		/* 8208AF90h case   48:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8208AF90h case   48:*/		return 0x8208AF94;
	}
	return 0x8208AF94;
} // Block from 8208AED0h-8208AF94h (49 instructions)

//////////////////////////////////////////////////////
// Block at 8208AF94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208AF94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208AF94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208AF94);
		  /* 8208AF94h */ case    0:  		/* lbz R11, <#[R30 + 5]> */
		/* 8208AF94h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208AF94h case    0:*/		return 0x8208AF98;
		  /* 8208AF98h */ case    1:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 8208AF98h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 8208AF98h case    1:*/		return 0x8208AF9C;
		  /* 8208AF9Ch */ case    2:  		/* bc 12, CR0_EQ, 48 */
		/* 8208AF9Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8208AFCC;  }
		/* 8208AF9Ch case    2:*/		return 0x8208AFA0;
		  /* 8208AFA0h */ case    3:  		/* lhz R10, <#[R30]> */
		/* 8208AFA0h case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8208AFA0h case    3:*/		return 0x8208AFA4;
		  /* 8208AFA4h */ case    4:  		/* rlwinm. R9, R11, 0, 30, 30 */
		/* 8208AFA4h case    4:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R11);
		/* 8208AFA4h case    4:*/		return 0x8208AFA8;
		  /* 8208AFA8h */ case    5:  		/* rlwinm R11, R10, 4, 0, 31 */
		/* 8208AFA8h case    5:*/		cpu::op::rlwinm<0,4,0,31>(regs,&regs.R11,regs.R10);
		/* 8208AFA8h case    5:*/		return 0x8208AFAC;
		  /* 8208AFACh */ case    6:  		/* addi R4, R11, -24 */
		/* 8208AFACh case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFE8);
		/* 8208AFACh case    6:*/		return 0x8208AFB0;
	}
	return 0x8208AFB0;
} // Block from 8208AF94h-8208AFB0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208AFB0h
// Function '?StartLine@Disassembler@D3D@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208AFB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208AFB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208AFB0);
		  /* 8208AFB0h */ case    0:  		/* bc 12, CR0_EQ, 16 */
		/* 8208AFB0h case    0:*/		if ( regs.CR[0].eq ) { return 0x8208AFC0;  }
		/* 8208AFB0h case    0:*/		return 0x8208AFB4;
		  /* 8208AFB4h */ case    1:  		/* cmplwi CR6, R4, 4 */
		/* 8208AFB4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000004);
		/* 8208AFB4h case    1:*/		return 0x8208AFB8;
		  /* 8208AFB8h */ case    2:  		/* bc 4, CR6_GT, 8 */
		/* 8208AFB8h case    2:*/		if ( !regs.CR[6].gt ) { return 0x8208AFC0;  }
		/* 8208AFB8h case    2:*/		return 0x8208AFBC;
		  /* 8208AFBCh */ case    3:  		/* addi R4, R4, -4 */
		/* 8208AFBCh case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFFFC);
		/* 8208AFBCh case    3:*/		return 0x8208AFC0;
	}
	return 0x8208AFC0;
} // Block from 8208AFB0h-8208AFC0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208AFC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208AFC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208AFC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208AFC0);
		  /* 8208AFC0h */ case    0:  		/* mr R5, R25 */
		/* 8208AFC0h case    0:*/		regs.R5 = regs.R25;
		/* 8208AFC0h case    0:*/		return 0x8208AFC4;
		  /* 8208AFC4h */ case    1:  		/* addi R3, R30, 24 */
		/* 8208AFC4h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x18);
		/* 8208AFC4h case    1:*/		return 0x8208AFC8;
		  /* 8208AFC8h */ case    2:  		/* bl 1975456 */
		/* 8208AFC8h case    2:*/		regs.LR = 0x8208AFCC; return 0x8226D468;
		/* 8208AFC8h case    2:*/		return 0x8208AFCC;
	}
	return 0x8208AFCC;
} // Block from 8208AFC0h-8208AFCCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208AFCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208AFCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208AFCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208AFCC);
		  /* 8208AFCCh */ case    0:  		/* lhz R11, <#[R30]> */
		/* 8208AFCCh case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8208AFCCh case    0:*/		return 0x8208AFD0;
		  /* 8208AFD0h */ case    1:  		/* li R28, 0 */
		/* 8208AFD0h case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8208AFD0h case    1:*/		return 0x8208AFD4;
		  /* 8208AFD4h */ case    2:  		/* lwz R10, <#[R29 + 48]> */
		/* 8208AFD4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000030) );
		/* 8208AFD4h case    2:*/		return 0x8208AFD8;
		  /* 8208AFD8h */ case    3:  		/* subf R11, R11, R10 */
		/* 8208AFD8h case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8208AFD8h case    3:*/		return 0x8208AFDC;
		  /* 8208AFDCh */ case    4:  		/* stw R11, <#[R29 + 48]> */
		/* 8208AFDCh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 8208AFDCh case    4:*/		return 0x8208AFE0;
	}
	return 0x8208AFE0;
} // Block from 8208AFCCh-8208AFE0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208AFE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208AFE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208AFE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208AFE0);
		  /* 8208AFE0h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8208AFE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8208AFE0h case    0:*/		return 0x8208AFE4;
		  /* 8208AFE4h */ case    1:  		/* addi R9, R31, 8 */
		/* 8208AFE4h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x8);
		/* 8208AFE4h case    1:*/		return 0x8208AFE8;
		  /* 8208AFE8h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 8208AFE8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8208AFE8h case    2:*/		return 0x8208AFEC;
		  /* 8208AFECh */ case    3:  		/* lwz R8, <#[R11]> */
		/* 8208AFECh case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8208AFECh case    3:*/		return 0x8208AFF0;
		  /* 8208AFF0h */ case    4:  		/* lwz R7, <#[R10 + 4]> */
		/* 8208AFF0h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 8208AFF0h case    4:*/		return 0x8208AFF4;
		  /* 8208AFF4h */ case    5:  		/* cmplw CR6, R8, R7 */
		/* 8208AFF4h case    5:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 8208AFF4h case    5:*/		return 0x8208AFF8;
		  /* 8208AFF8h */ case    6:  		/* bc 4, CR6_EQ, 72 */
		/* 8208AFF8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8208B040;  }
		/* 8208AFF8h case    6:*/		return 0x8208AFFC;
		  /* 8208AFFCh */ case    7:  		/* cmplw CR6, R8, R9 */
		/* 8208AFFCh case    7:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8208AFFCh case    7:*/		return 0x8208B000;
		  /* 8208B000h */ case    8:  		/* bc 4, CR6_EQ, 64 */
		/* 8208B000h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8208B040;  }
		/* 8208B000h case    8:*/		return 0x8208B004;
		  /* 8208B004h */ case    9:  		/* stw R10, <#[R11]> */
		/* 8208B004h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208B004h case    9:*/		return 0x8208B008;
		  /* 8208B008h */ case   10:  		/* cmplw CR6, R10, R11 */
		/* 8208B008h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208B008h case   10:*/		return 0x8208B00C;
		  /* 8208B00Ch */ case   11:  		/* stw R11, <#[R10 + 4]> */
		/* 8208B00Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8208B00Ch case   11:*/		return 0x8208B010;
		  /* 8208B010h */ case   12:  		/* bc 4, CR6_EQ, 48 */
		/* 8208B010h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8208B040;  }
		/* 8208B010h case   12:*/		return 0x8208B014;
		  /* 8208B014h */ case   13:  		/* lhz R11, <#[R31]> */
		/* 8208B014h case   13:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8208B014h case   13:*/		return 0x8208B018;
	}
	return 0x8208B018;
} // Block from 8208AFE0h-8208B018h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8208B018h
// Function '?StartInstruction@Disassembler@D3D@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B018);
		  /* 8208B018h */ case    0:  		/* cmplwi CR6, R11, 128 */
		/* 8208B018h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 8208B018h case    0:*/		return 0x8208B01C;
		  /* 8208B01Ch */ case    1:  		/* bc 4, CR6_LT, 36 */
		/* 8208B01Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x8208B040;  }
		/* 8208B01Ch case    1:*/		return 0x8208B020;
		  /* 8208B020h */ case    2:  		/* rlwinm R10, R11, 27, 5, 31 */
		/* 8208B020h case    2:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R11);
		/* 8208B020h case    2:*/		return 0x8208B024;
		  /* 8208B024h */ case    3:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8208B024h case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8208B024h case    3:*/		return 0x8208B028;
		  /* 8208B028h */ case    4:  		/* addi R10, R10, 88 */
		/* 8208B028h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x58);
		/* 8208B028h case    4:*/		return 0x8208B02C;
		  /* 8208B02Ch */ case    5:  		/* slw R9, R26, R11 */
		/* 8208B02Ch case    5:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R26,regs.R11);
		/* 8208B02Ch case    5:*/		return 0x8208B030;
		  /* 8208B030h */ case    6:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 8208B030h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 8208B030h case    6:*/		return 0x8208B034;
		  /* 8208B034h */ case    7:  		/* lwzx R10, <#[R11 + R29]> */
		/* 8208B034h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 8208B034h case    7:*/		return 0x8208B038;
		  /* 8208B038h */ case    8:  		/* xor R10, R9, R10 */
		/* 8208B038h case    8:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8208B038h case    8:*/		return 0x8208B03C;
		  /* 8208B03Ch */ case    9:  		/* stwx R10, <#[R11 + R29]> */
		/* 8208B03Ch case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 8208B03Ch case    9:*/		return 0x8208B040;
	}
	return 0x8208B040;
} // Block from 8208B018h-8208B040h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8208B040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B040);
		  /* 8208B040h */ case    0:  		/* lbz R11, <#[R31 + 5]> */
		/* 8208B040h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000005) );
		/* 8208B040h case    0:*/		return 0x8208B044;
		  /* 8208B044h */ case    1:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 8208B044h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 8208B044h case    1:*/		return 0x8208B048;
		  /* 8208B048h */ case    2:  		/* bc 12, CR0_EQ, 48 */
		/* 8208B048h case    2:*/		if ( regs.CR[0].eq ) { return 0x8208B078;  }
		/* 8208B048h case    2:*/		return 0x8208B04C;
		  /* 8208B04Ch */ case    3:  		/* lhz R10, <#[R31]> */
		/* 8208B04Ch case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8208B04Ch case    3:*/		return 0x8208B050;
		  /* 8208B050h */ case    4:  		/* rlwinm. R9, R11, 0, 30, 30 */
		/* 8208B050h case    4:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R11);
		/* 8208B050h case    4:*/		return 0x8208B054;
		  /* 8208B054h */ case    5:  		/* rlwinm R11, R10, 4, 0, 31 */
		/* 8208B054h case    5:*/		cpu::op::rlwinm<0,4,0,31>(regs,&regs.R11,regs.R10);
		/* 8208B054h case    5:*/		return 0x8208B058;
		  /* 8208B058h */ case    6:  		/* addi R4, R11, -24 */
		/* 8208B058h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFE8);
		/* 8208B058h case    6:*/		return 0x8208B05C;
		  /* 8208B05Ch */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 8208B05Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x8208B06C;  }
		/* 8208B05Ch case    7:*/		return 0x8208B060;
		  /* 8208B060h */ case    8:  		/* cmplwi CR6, R4, 4 */
		/* 8208B060h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000004);
		/* 8208B060h case    8:*/		return 0x8208B064;
		  /* 8208B064h */ case    9:  		/* bc 4, CR6_GT, 8 */
		/* 8208B064h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8208B06C;  }
		/* 8208B064h case    9:*/		return 0x8208B068;
		  /* 8208B068h */ case   10:  		/* addi R4, R4, -4 */
		/* 8208B068h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFFFC);
		/* 8208B068h case   10:*/		return 0x8208B06C;
	}
	return 0x8208B06C;
} // Block from 8208B040h-8208B06Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8208B06Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B06C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B06C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B06C);
		  /* 8208B06Ch */ case    0:  		/* mr R5, R25 */
		/* 8208B06Ch case    0:*/		regs.R5 = regs.R25;
		/* 8208B06Ch case    0:*/		return 0x8208B070;
		  /* 8208B070h */ case    1:  		/* addi R3, R31, 24 */
		/* 8208B070h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x18);
		/* 8208B070h case    1:*/		return 0x8208B074;
		  /* 8208B074h */ case    2:  		/* bl 1975284 */
		/* 8208B074h case    2:*/		regs.LR = 0x8208B078; return 0x8226D468;
		/* 8208B074h case    2:*/		return 0x8208B078;
	}
	return 0x8208B078;
} // Block from 8208B06Ch-8208B078h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208B078h
// Function '?DoPrintImp@Disassembler@D3D@@AAAXPBDZZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B078);
		  /* 8208B078h */ case    0:  		/* lbz R11, <#[R30 + 5]> */
		/* 8208B078h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208B078h case    0:*/		return 0x8208B07C;
		  /* 8208B07Ch */ case    1:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 8208B07Ch case    1:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 8208B07Ch case    1:*/		return 0x8208B080;
		  /* 8208B080h */ case    2:  		/* stb R11, <#[R31 + 5]> */
		/* 8208B080h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000005) );
		/* 8208B080h case    2:*/		return 0x8208B084;
		  /* 8208B084h */ case    3:  		/* bc 12, CR0_EQ, 24 */
		/* 8208B084h case    3:*/		if ( regs.CR[0].eq ) { return 0x8208B09C;  }
		/* 8208B084h case    3:*/		return 0x8208B088;
		  /* 8208B088h */ case    4:  		/* lbz R11, <#[R31 + 4]> */
		/* 8208B088h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8208B088h case    4:*/		return 0x8208B08C;
		  /* 8208B08Ch */ case    5:  		/* addi R11, R11, 24 */
		/* 8208B08Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 8208B08Ch case    5:*/		return 0x8208B090;
		  /* 8208B090h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8208B090h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8208B090h case    6:*/		return 0x8208B094;
		  /* 8208B094h */ case    7:  		/* lwzx R11, <#[R11 + R29]> */
		/* 8208B094h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 8208B094h case    7:*/		return 0x8208B098;
		  /* 8208B098h */ case    8:  		/* stw R31, <#[R11 + 64]> */
		/* 8208B098h case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000040) );
		/* 8208B098h case    8:*/		return 0x8208B09C;
	}
	return 0x8208B09C;
} // Block from 8208B078h-8208B09Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8208B09Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B09C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B09C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B09C);
		  /* 8208B09Ch */ case    0:  		/* lhz R10, <#[R31]> */
		/* 8208B09Ch case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8208B09Ch case    0:*/		return 0x8208B0A0;
		  /* 8208B0A0h */ case    1:  		/* mr R30, R31 */
		/* 8208B0A0h case    1:*/		regs.R30 = regs.R31;
		/* 8208B0A0h case    1:*/		return 0x8208B0A4;
		  /* 8208B0A4h */ case    2:  		/* lwz R11, <#[R27]> */
		/* 8208B0A4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8208B0A4h case    2:*/		return 0x8208B0A8;
		  /* 8208B0A8h */ case    3:  		/* add R11, R10, R11 */
		/* 8208B0A8h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208B0A8h case    3:*/		return 0x8208B0AC;
		  /* 8208B0ACh */ case    4:  		/* stw R11, <#[R27]> */
		/* 8208B0ACh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8208B0ACh case    4:*/		return 0x8208B0B0;
		  /* 8208B0B0h */ case    5:  		/* lwz R10, <#[R29 + 48]> */
		/* 8208B0B0h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000030) );
		/* 8208B0B0h case    5:*/		return 0x8208B0B4;
		  /* 8208B0B4h */ case    6:  		/* lhz R11, <#[R31]> */
		/* 8208B0B4h case    6:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8208B0B4h case    6:*/		return 0x8208B0B8;
		  /* 8208B0B8h */ case    7:  		/* subf R11, R11, R10 */
		/* 8208B0B8h case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8208B0B8h case    7:*/		return 0x8208B0BC;
		  /* 8208B0BCh */ case    8:  		/* stw R11, <#[R29 + 48]> */
		/* 8208B0BCh case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 8208B0BCh case    8:*/		return 0x8208B0C0;
		  /* 8208B0C0h */ case    9:  		/* lwz R10, <#[R27]> */
		/* 8208B0C0h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 8208B0C0h case    9:*/		return 0x8208B0C4;
		  /* 8208B0C4h */ case   10:  		/* lbz R11, <#[R31 + 5]> */
		/* 8208B0C4h case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000005) );
		/* 8208B0C4h case   10:*/		return 0x8208B0C8;
	}
	return 0x8208B0C8;
} // Block from 8208B09Ch-8208B0C8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8208B0C8h
// Function '?FindBranchTargets_StaticInstructionCallback@Disassembler@D3D@@CAJKKPATGPUSHADER_INSTRUCTION@@PAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B0C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B0C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B0C8);
		  /* 8208B0C8h */ case    0:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 8208B0C8h case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 8208B0C8h case    0:*/		return 0x8208B0CC;
		  /* 8208B0CCh */ case    1:  		/* sth R10, <#[R31]> */
		/* 8208B0CCh case    1:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8208B0CCh case    1:*/		return 0x8208B0D0;
		  /* 8208B0D0h */ case    2:  		/* bc 4, CR0_EQ, 20 */
		/* 8208B0D0h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8208B0E4;  }
		/* 8208B0D0h case    2:*/		return 0x8208B0D4;
		  /* 8208B0D4h */ case    3:  		/* lwz R10, <#[R27]> */
		/* 8208B0D4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 8208B0D4h case    3:*/		return 0x8208B0D8;
		  /* 8208B0D8h */ case    4:  		/* rlwinm R11, R10, 4, 0, 27 */
		/* 8208B0D8h case    4:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R10);
		/* 8208B0D8h case    4:*/		return 0x8208B0DC;
		  /* 8208B0DCh */ case    5:  		/* add R11, R11, R31 */
		/* 8208B0DCh case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 8208B0DCh case    5:*/		return 0x8208B0E0;
		  /* 8208B0E0h */ case    6:  		/* sth R10, <#[R11 + 2]> */
		/* 8208B0E0h case    6:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R11 + 0x00000002) );
		/* 8208B0E0h case    6:*/		return 0x8208B0E4;
	}
	return 0x8208B0E4;
} // Block from 8208B0C8h-8208B0E4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208B0E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B0E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B0E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B0E4);
		  /* 8208B0E4h */ case    0:  		/* lbz R11, <#[R30 + 5]> */
		/* 8208B0E4h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208B0E4h case    0:*/		return 0x8208B0E8;
		  /* 8208B0E8h */ case    1:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 8208B0E8h case    1:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 8208B0E8h case    1:*/		return 0x8208B0EC;
		  /* 8208B0ECh */ case    2:  		/* bc 4, CR0_EQ, 476 */
		/* 8208B0ECh case    2:*/		if ( !regs.CR[0].eq ) { return 0x8208B2C8;  }
		/* 8208B0ECh case    2:*/		return 0x8208B0F0;
		  /* 8208B0F0h */ case    3:  		/* lwz R11, <#[R27]> */
		/* 8208B0F0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8208B0F0h case    3:*/		return 0x8208B0F4;
		  /* 8208B0F4h */ case    4:  		/* rlwinm R10, R11, 4, 0, 27 */
		/* 8208B0F4h case    4:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R11);
		/* 8208B0F4h case    4:*/		return 0x8208B0F8;
		  /* 8208B0F8h */ case    5:  		/* add R31, R10, R30 */
		/* 8208B0F8h case    5:*/		cpu::op::add<0>(regs,&regs.R31,regs.R10,regs.R30);
		/* 8208B0F8h case    5:*/		return 0x8208B0FC;
		  /* 8208B0FCh */ case    6:  		/* lbz R10, <#[R31 + 5]> */
		/* 8208B0FCh case    6:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000005) );
		/* 8208B0FCh case    6:*/		return 0x8208B100;
		  /* 8208B100h */ case    7:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 8208B100h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 8208B100h case    7:*/		return 0x8208B104;
		  /* 8208B104h */ case    8:  		/* bc 4, CR0_EQ, 452 */
		/* 8208B104h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8208B2C8;  }
		/* 8208B104h case    8:*/		return 0x8208B108;
		  /* 8208B108h */ case    9:  		/* lhz R10, <#[R31]> */
		/* 8208B108h case    9:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8208B108h case    9:*/		return 0x8208B10C;
		  /* 8208B10Ch */ case   10:  		/* add R11, R10, R11 */
		/* 8208B10Ch case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208B10Ch case   10:*/		return 0x8208B110;
		  /* 8208B110h */ case   11:  		/* cmplwi CR6, R11, 61440 */
		/* 8208B110h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000F000);
		/* 8208B110h case   11:*/		return 0x8208B114;
		  /* 8208B114h */ case   12:  		/* bc 12, CR6_GT, 436 */
		/* 8208B114h case   12:*/		if ( regs.CR[6].gt ) { return 0x8208B2C8;  }
		/* 8208B114h case   12:*/		return 0x8208B118;
		  /* 8208B118h */ case   13:  		/* cmplwi CR6, R28, 0 */
		/* 8208B118h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8208B118h case   13:*/		return 0x8208B11C;
		  /* 8208B11Ch */ case   14:  		/* bc 12, CR6_EQ, 172 */
		/* 8208B11Ch case   14:*/		if ( regs.CR[6].eq ) { return 0x8208B1C8;  }
		/* 8208B11Ch case   14:*/		return 0x8208B120;
		  /* 8208B120h */ case   15:  		/* lwz R11, <#[R30 + 12]> */
		/* 8208B120h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8208B120h case   15:*/		return 0x8208B124;
		  /* 8208B124h */ case   16:  		/* addi R9, R30, 8 */
		/* 8208B124h case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0x8);
		/* 8208B124h case   16:*/		return 0x8208B128;
		  /* 8208B128h */ case   17:  		/* lwz R10, <#[R30 + 8]> */
		/* 8208B128h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 8208B128h case   17:*/		return 0x8208B12C;
		  /* 8208B12Ch */ case   18:  		/* lwz R8, <#[R11]> */
		/* 8208B12Ch case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8208B12Ch case   18:*/		return 0x8208B130;
		  /* 8208B130h */ case   19:  		/* lwz R7, <#[R10 + 4]> */
		/* 8208B130h case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 8208B130h case   19:*/		return 0x8208B134;
		  /* 8208B134h */ case   20:  		/* cmplw CR6, R8, R7 */
		/* 8208B134h case   20:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 8208B134h case   20:*/		return 0x8208B138;
		  /* 8208B138h */ case   21:  		/* bc 4, CR6_EQ, 72 */
		/* 8208B138h case   21:*/		if ( !regs.CR[6].eq ) { return 0x8208B180;  }
		/* 8208B138h case   21:*/		return 0x8208B13C;
		  /* 8208B13Ch */ case   22:  		/* cmplw CR6, R8, R9 */
		/* 8208B13Ch case   22:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8208B13Ch case   22:*/		return 0x8208B140;
		  /* 8208B140h */ case   23:  		/* bc 4, CR6_EQ, 64 */
		/* 8208B140h case   23:*/		if ( !regs.CR[6].eq ) { return 0x8208B180;  }
		/* 8208B140h case   23:*/		return 0x8208B144;
		  /* 8208B144h */ case   24:  		/* stw R10, <#[R11]> */
		/* 8208B144h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208B144h case   24:*/		return 0x8208B148;
		  /* 8208B148h */ case   25:  		/* cmplw CR6, R10, R11 */
		/* 8208B148h case   25:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208B148h case   25:*/		return 0x8208B14C;
		  /* 8208B14Ch */ case   26:  		/* stw R11, <#[R10 + 4]> */
		/* 8208B14Ch case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8208B14Ch case   26:*/		return 0x8208B150;
		  /* 8208B150h */ case   27:  		/* bc 4, CR6_EQ, 48 */
		/* 8208B150h case   27:*/		if ( !regs.CR[6].eq ) { return 0x8208B180;  }
		/* 8208B150h case   27:*/		return 0x8208B154;
		  /* 8208B154h */ case   28:  		/* lhz R11, <#[R30]> */
		/* 8208B154h case   28:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8208B154h case   28:*/		return 0x8208B158;
		  /* 8208B158h */ case   29:  		/* cmplwi CR6, R11, 128 */
		/* 8208B158h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 8208B158h case   29:*/		return 0x8208B15C;
		  /* 8208B15Ch */ case   30:  		/* bc 4, CR6_LT, 36 */
		/* 8208B15Ch case   30:*/		if ( !regs.CR[6].lt ) { return 0x8208B180;  }
		/* 8208B15Ch case   30:*/		return 0x8208B160;
		  /* 8208B160h */ case   31:  		/* rlwinm R10, R11, 27, 5, 31 */
		/* 8208B160h case   31:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R11);
		/* 8208B160h case   31:*/		return 0x8208B164;
		  /* 8208B164h */ case   32:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8208B164h case   32:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8208B164h case   32:*/		return 0x8208B168;
		  /* 8208B168h */ case   33:  		/* addi R10, R10, 88 */
		/* 8208B168h case   33:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x58);
		/* 8208B168h case   33:*/		return 0x8208B16C;
		  /* 8208B16Ch */ case   34:  		/* slw R9, R26, R11 */
		/* 8208B16Ch case   34:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R26,regs.R11);
		/* 8208B16Ch case   34:*/		return 0x8208B170;
		  /* 8208B170h */ case   35:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 8208B170h case   35:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 8208B170h case   35:*/		return 0x8208B174;
		  /* 8208B174h */ case   36:  		/* lwzx R10, <#[R11 + R29]> */
		/* 8208B174h case   36:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 8208B174h case   36:*/		return 0x8208B178;
		  /* 8208B178h */ case   37:  		/* xor R10, R9, R10 */
		/* 8208B178h case   37:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8208B178h case   37:*/		return 0x8208B17C;
		  /* 8208B17Ch */ case   38:  		/* stwx R10, <#[R11 + R29]> */
		/* 8208B17Ch case   38:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 8208B17Ch case   38:*/		return 0x8208B180;
	}
	return 0x8208B180;
} // Block from 8208B0E4h-8208B180h (39 instructions)

//////////////////////////////////////////////////////
// Block at 8208B180h
// Function '?DoPrint@Disassembler@D3D@@AAAXPBDPAD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B180);
		  /* 8208B180h */ case    0:  		/* lbz R11, <#[R30 + 5]> */
		/* 8208B180h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208B180h case    0:*/		return 0x8208B184;
		  /* 8208B184h */ case    1:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 8208B184h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 8208B184h case    1:*/		return 0x8208B188;
		  /* 8208B188h */ case    2:  		/* bc 12, CR0_EQ, 48 */
		/* 8208B188h case    2:*/		if ( regs.CR[0].eq ) { return 0x8208B1B8;  }
		/* 8208B188h case    2:*/		return 0x8208B18C;
		  /* 8208B18Ch */ case    3:  		/* lhz R10, <#[R30]> */
		/* 8208B18Ch case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8208B18Ch case    3:*/		return 0x8208B190;
		  /* 8208B190h */ case    4:  		/* rlwinm. R9, R11, 0, 30, 30 */
		/* 8208B190h case    4:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R11);
		/* 8208B190h case    4:*/		return 0x8208B194;
		  /* 8208B194h */ case    5:  		/* rlwinm R11, R10, 4, 0, 31 */
		/* 8208B194h case    5:*/		cpu::op::rlwinm<0,4,0,31>(regs,&regs.R11,regs.R10);
		/* 8208B194h case    5:*/		return 0x8208B198;
		  /* 8208B198h */ case    6:  		/* addi R4, R11, -24 */
		/* 8208B198h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFE8);
		/* 8208B198h case    6:*/		return 0x8208B19C;
		  /* 8208B19Ch */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 8208B19Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x8208B1AC;  }
		/* 8208B19Ch case    7:*/		return 0x8208B1A0;
		  /* 8208B1A0h */ case    8:  		/* cmplwi CR6, R4, 4 */
		/* 8208B1A0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000004);
		/* 8208B1A0h case    8:*/		return 0x8208B1A4;
		  /* 8208B1A4h */ case    9:  		/* bc 4, CR6_GT, 8 */
		/* 8208B1A4h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8208B1AC;  }
		/* 8208B1A4h case    9:*/		return 0x8208B1A8;
		  /* 8208B1A8h */ case   10:  		/* addi R4, R4, -4 */
		/* 8208B1A8h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFFFC);
		/* 8208B1A8h case   10:*/		return 0x8208B1AC;
	}
	return 0x8208B1AC;
} // Block from 8208B180h-8208B1ACh (11 instructions)

//////////////////////////////////////////////////////
// Block at 8208B1ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B1AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B1AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B1AC);
		  /* 8208B1ACh */ case    0:  		/* mr R5, R25 */
		/* 8208B1ACh case    0:*/		regs.R5 = regs.R25;
		/* 8208B1ACh case    0:*/		return 0x8208B1B0;
		  /* 8208B1B0h */ case    1:  		/* addi R3, R30, 24 */
		/* 8208B1B0h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x18);
		/* 8208B1B0h case    1:*/		return 0x8208B1B4;
		  /* 8208B1B4h */ case    2:  		/* bl 1974964 */
		/* 8208B1B4h case    2:*/		regs.LR = 0x8208B1B8; return 0x8226D468;
		/* 8208B1B4h case    2:*/		return 0x8208B1B8;
	}
	return 0x8208B1B8;
} // Block from 8208B1ACh-8208B1B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208B1B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B1B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B1B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B1B8);
		  /* 8208B1B8h */ case    0:  		/* lhz R11, <#[R30]> */
		/* 8208B1B8h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8208B1B8h case    0:*/		return 0x8208B1BC;
		  /* 8208B1BCh */ case    1:  		/* lwz R10, <#[R29 + 48]> */
		/* 8208B1BCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000030) );
		/* 8208B1BCh case    1:*/		return 0x8208B1C0;
		  /* 8208B1C0h */ case    2:  		/* subf R11, R11, R10 */
		/* 8208B1C0h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8208B1C0h case    2:*/		return 0x8208B1C4;
		  /* 8208B1C4h */ case    3:  		/* stw R11, <#[R29 + 48]> */
		/* 8208B1C4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 8208B1C4h case    3:*/		return 0x8208B1C8;
	}
	return 0x8208B1C8;
} // Block from 8208B1B8h-8208B1C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208B1C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B1C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B1C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B1C8);
		  /* 8208B1C8h */ case    0:  		/* lbz R11, <#[R31 + 5]> */
		/* 8208B1C8h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000005) );
		/* 8208B1C8h case    0:*/		return 0x8208B1CC;
		  /* 8208B1CCh */ case    1:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 8208B1CCh case    1:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 8208B1CCh case    1:*/		return 0x8208B1D0;
		  /* 8208B1D0h */ case    2:  		/* stb R11, <#[R30 + 5]> */
		/* 8208B1D0h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208B1D0h case    2:*/		return 0x8208B1D4;
		  /* 8208B1D4h */ case    3:  		/* bc 12, CR0_EQ, 24 */
		/* 8208B1D4h case    3:*/		if ( regs.CR[0].eq ) { return 0x8208B1EC;  }
		/* 8208B1D4h case    3:*/		return 0x8208B1D8;
		  /* 8208B1D8h */ case    4:  		/* lbz R11, <#[R30 + 4]> */
		/* 8208B1D8h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8208B1D8h case    4:*/		return 0x8208B1DC;
		  /* 8208B1DCh */ case    5:  		/* addi R11, R11, 24 */
		/* 8208B1DCh case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 8208B1DCh case    5:*/		return 0x8208B1E0;
		  /* 8208B1E0h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8208B1E0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8208B1E0h case    6:*/		return 0x8208B1E4;
		  /* 8208B1E4h */ case    7:  		/* lwzx R11, <#[R11 + R29]> */
		/* 8208B1E4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 8208B1E4h case    7:*/		return 0x8208B1E8;
		  /* 8208B1E8h */ case    8:  		/* stw R30, <#[R11 + 64]> */
		/* 8208B1E8h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000040) );
		/* 8208B1E8h case    8:*/		return 0x8208B1EC;
	}
	return 0x8208B1EC;
} // Block from 8208B1C8h-8208B1ECh (9 instructions)

//////////////////////////////////////////////////////
// Block at 8208B1ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B1EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B1EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B1EC);
		  /* 8208B1ECh */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8208B1ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8208B1ECh case    0:*/		return 0x8208B1F0;
		  /* 8208B1F0h */ case    1:  		/* addi R9, R31, 8 */
		/* 8208B1F0h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x8);
		/* 8208B1F0h case    1:*/		return 0x8208B1F4;
		  /* 8208B1F4h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 8208B1F4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8208B1F4h case    2:*/		return 0x8208B1F8;
		  /* 8208B1F8h */ case    3:  		/* lwz R8, <#[R11]> */
		/* 8208B1F8h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8208B1F8h case    3:*/		return 0x8208B1FC;
		  /* 8208B1FCh */ case    4:  		/* lwz R7, <#[R10 + 4]> */
		/* 8208B1FCh case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 8208B1FCh case    4:*/		return 0x8208B200;
		  /* 8208B200h */ case    5:  		/* cmplw CR6, R8, R7 */
		/* 8208B200h case    5:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 8208B200h case    5:*/		return 0x8208B204;
		  /* 8208B204h */ case    6:  		/* bc 4, CR6_EQ, 72 */
		/* 8208B204h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8208B24C;  }
		/* 8208B204h case    6:*/		return 0x8208B208;
		  /* 8208B208h */ case    7:  		/* cmplw CR6, R8, R9 */
		/* 8208B208h case    7:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8208B208h case    7:*/		return 0x8208B20C;
		  /* 8208B20Ch */ case    8:  		/* bc 4, CR6_EQ, 64 */
		/* 8208B20Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x8208B24C;  }
		/* 8208B20Ch case    8:*/		return 0x8208B210;
		  /* 8208B210h */ case    9:  		/* stw R10, <#[R11]> */
		/* 8208B210h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208B210h case    9:*/		return 0x8208B214;
		  /* 8208B214h */ case   10:  		/* cmplw CR6, R10, R11 */
		/* 8208B214h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208B214h case   10:*/		return 0x8208B218;
		  /* 8208B218h */ case   11:  		/* stw R11, <#[R10 + 4]> */
		/* 8208B218h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8208B218h case   11:*/		return 0x8208B21C;
		  /* 8208B21Ch */ case   12:  		/* bc 4, CR6_EQ, 48 */
		/* 8208B21Ch case   12:*/		if ( !regs.CR[6].eq ) { return 0x8208B24C;  }
		/* 8208B21Ch case   12:*/		return 0x8208B220;
		  /* 8208B220h */ case   13:  		/* lhz R11, <#[R31]> */
		/* 8208B220h case   13:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8208B220h case   13:*/		return 0x8208B224;
		  /* 8208B224h */ case   14:  		/* cmplwi CR6, R11, 128 */
		/* 8208B224h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 8208B224h case   14:*/		return 0x8208B228;
		  /* 8208B228h */ case   15:  		/* bc 4, CR6_LT, 36 */
		/* 8208B228h case   15:*/		if ( !regs.CR[6].lt ) { return 0x8208B24C;  }
		/* 8208B228h case   15:*/		return 0x8208B22C;
		  /* 8208B22Ch */ case   16:  		/* rlwinm R10, R11, 27, 5, 31 */
		/* 8208B22Ch case   16:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R11);
		/* 8208B22Ch case   16:*/		return 0x8208B230;
		  /* 8208B230h */ case   17:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8208B230h case   17:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8208B230h case   17:*/		return 0x8208B234;
		  /* 8208B234h */ case   18:  		/* addi R10, R10, 88 */
		/* 8208B234h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x58);
		/* 8208B234h case   18:*/		return 0x8208B238;
		  /* 8208B238h */ case   19:  		/* slw R9, R26, R11 */
		/* 8208B238h case   19:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R26,regs.R11);
		/* 8208B238h case   19:*/		return 0x8208B23C;
		  /* 8208B23Ch */ case   20:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 8208B23Ch case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 8208B23Ch case   20:*/		return 0x8208B240;
		  /* 8208B240h */ case   21:  		/* lwzx R10, <#[R11 + R29]> */
		/* 8208B240h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 8208B240h case   21:*/		return 0x8208B244;
		  /* 8208B244h */ case   22:  		/* xor R10, R9, R10 */
		/* 8208B244h case   22:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8208B244h case   22:*/		return 0x8208B248;
		  /* 8208B248h */ case   23:  		/* stwx R10, <#[R11 + R29]> */
		/* 8208B248h case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 8208B248h case   23:*/		return 0x8208B24C;
	}
	return 0x8208B24C;
} // Block from 8208B1ECh-8208B24Ch (24 instructions)

//////////////////////////////////////////////////////
// Block at 8208B24Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B24C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B24C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B24C);
		  /* 8208B24Ch */ case    0:  		/* lbz R11, <#[R31 + 5]> */
		/* 8208B24Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000005) );
		/* 8208B24Ch case    0:*/		return 0x8208B250;
		  /* 8208B250h */ case    1:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 8208B250h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 8208B250h case    1:*/		return 0x8208B254;
		  /* 8208B254h */ case    2:  		/* bc 12, CR0_EQ, 48 */
		/* 8208B254h case    2:*/		if ( regs.CR[0].eq ) { return 0x8208B284;  }
		/* 8208B254h case    2:*/		return 0x8208B258;
		  /* 8208B258h */ case    3:  		/* lhz R10, <#[R31]> */
		/* 8208B258h case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8208B258h case    3:*/		return 0x8208B25C;
		  /* 8208B25Ch */ case    4:  		/* rlwinm. R9, R11, 0, 30, 30 */
		/* 8208B25Ch case    4:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R11);
		/* 8208B25Ch case    4:*/		return 0x8208B260;
		  /* 8208B260h */ case    5:  		/* rlwinm R11, R10, 4, 0, 31 */
		/* 8208B260h case    5:*/		cpu::op::rlwinm<0,4,0,31>(regs,&regs.R11,regs.R10);
		/* 8208B260h case    5:*/		return 0x8208B264;
		  /* 8208B264h */ case    6:  		/* addi R4, R11, -24 */
		/* 8208B264h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFE8);
		/* 8208B264h case    6:*/		return 0x8208B268;
		  /* 8208B268h */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 8208B268h case    7:*/		if ( regs.CR[0].eq ) { return 0x8208B278;  }
		/* 8208B268h case    7:*/		return 0x8208B26C;
		  /* 8208B26Ch */ case    8:  		/* cmplwi CR6, R4, 4 */
		/* 8208B26Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000004);
		/* 8208B26Ch case    8:*/		return 0x8208B270;
		  /* 8208B270h */ case    9:  		/* bc 4, CR6_GT, 8 */
		/* 8208B270h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8208B278;  }
		/* 8208B270h case    9:*/		return 0x8208B274;
		  /* 8208B274h */ case   10:  		/* addi R4, R4, -4 */
		/* 8208B274h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFFFC);
		/* 8208B274h case   10:*/		return 0x8208B278;
	}
	return 0x8208B278;
} // Block from 8208B24Ch-8208B278h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8208B278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B278);
		  /* 8208B278h */ case    0:  		/* mr R5, R25 */
		/* 8208B278h case    0:*/		regs.R5 = regs.R25;
		/* 8208B278h case    0:*/		return 0x8208B27C;
		  /* 8208B27Ch */ case    1:  		/* addi R3, R31, 24 */
		/* 8208B27Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x18);
		/* 8208B27Ch case    1:*/		return 0x8208B280;
	}
	return 0x8208B280;
} // Block from 8208B278h-8208B280h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208B280h
// Function '?__noop@Disassembler@D3D@@AAAXPBDZZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B280);
		  /* 8208B280h */ case    0:  		/* bl 1974760 */
		/* 8208B280h case    0:*/		regs.LR = 0x8208B284; return 0x8226D468;
		/* 8208B280h case    0:*/		return 0x8208B284;
	}
	return 0x8208B284;
} // Block from 8208B280h-8208B284h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208B284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B284);
		  /* 8208B284h */ case    0:  		/* lwz R10, <#[R27]> */
		/* 8208B284h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 8208B284h case    0:*/		return 0x8208B288;
		  /* 8208B288h */ case    1:  		/* lhz R11, <#[R31]> */
		/* 8208B288h case    1:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8208B288h case    1:*/		return 0x8208B28C;
		  /* 8208B28Ch */ case    2:  		/* add R11, R11, R10 */
		/* 8208B28Ch case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8208B28Ch case    2:*/		return 0x8208B290;
		  /* 8208B290h */ case    3:  		/* stw R11, <#[R27]> */
		/* 8208B290h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8208B290h case    3:*/		return 0x8208B294;
		  /* 8208B294h */ case    4:  		/* lhz R10, <#[R31]> */
		/* 8208B294h case    4:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8208B294h case    4:*/		return 0x8208B298;
		  /* 8208B298h */ case    5:  		/* lwz R11, <#[R29 + 48]> */
		/* 8208B298h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 8208B298h case    5:*/		return 0x8208B29C;
		  /* 8208B29Ch */ case    6:  		/* subf R11, R10, R11 */
		/* 8208B29Ch case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208B29Ch case    6:*/		return 0x8208B2A0;
		  /* 8208B2A0h */ case    7:  		/* stw R11, <#[R29 + 48]> */
		/* 8208B2A0h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 8208B2A0h case    7:*/		return 0x8208B2A4;
		  /* 8208B2A4h */ case    8:  		/* lbz R11, <#[R30 + 5]> */
		/* 8208B2A4h case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208B2A4h case    8:*/		return 0x8208B2A8;
		  /* 8208B2A8h */ case    9:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 8208B2A8h case    9:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 8208B2A8h case    9:*/		return 0x8208B2AC;
		  /* 8208B2ACh */ case   10:  		/* lwz R10, <#[R27]> */
		/* 8208B2ACh case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 8208B2ACh case   10:*/		return 0x8208B2B0;
		  /* 8208B2B0h */ case   11:  		/* sth R10, <#[R30]> */
		/* 8208B2B0h case   11:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8208B2B0h case   11:*/		return 0x8208B2B4;
		  /* 8208B2B4h */ case   12:  		/* bc 4, CR0_EQ, 20 */
		/* 8208B2B4h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8208B2C8;  }
		/* 8208B2B4h case   12:*/		return 0x8208B2B8;
		  /* 8208B2B8h */ case   13:  		/* lwz R10, <#[R27]> */
		/* 8208B2B8h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 8208B2B8h case   13:*/		return 0x8208B2BC;
		  /* 8208B2BCh */ case   14:  		/* rlwinm R11, R10, 4, 0, 27 */
		/* 8208B2BCh case   14:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R10);
		/* 8208B2BCh case   14:*/		return 0x8208B2C0;
		  /* 8208B2C0h */ case   15:  		/* add R11, R11, R30 */
		/* 8208B2C0h case   15:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8208B2C0h case   15:*/		return 0x8208B2C4;
		  /* 8208B2C4h */ case   16:  		/* sth R10, <#[R11 + 2]> */
		/* 8208B2C4h case   16:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R11 + 0x00000002) );
		/* 8208B2C4h case   16:*/		return 0x8208B2C8;
	}
	return 0x8208B2C8;
} // Block from 8208B284h-8208B2C8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8208B2C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B2C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B2C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B2C8);
		  /* 8208B2C8h */ case    0:  		/* mr R3, R30 */
		/* 8208B2C8h case    0:*/		regs.R3 = regs.R30;
		/* 8208B2C8h case    0:*/		return 0x8208B2CC;
		  /* 8208B2CCh */ case    1:  		/* addi R1, R1, 144 */
		/* 8208B2CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8208B2CCh case    1:*/		return 0x8208B2D0;
		  /* 8208B2D0h */ case    2:  		/* b 24524 */
		/* 8208B2D0h case    2:*/		return 0x8209129C;
		/* 8208B2D0h case    2:*/		return 0x8208B2D4;
		  /* 8208B2D4h */ case    3:  		/* nop */
		/* 8208B2D4h case    3:*/		cpu::op::nop();
		/* 8208B2D4h case    3:*/		return 0x8208B2D8;
	}
	return 0x8208B2D8;
} // Block from 8208B2C8h-8208B2D8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208B2D8h
// Function '?PrintYieldAndPredicateClean@Disassembler@D3D@@AAAXHH_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B2D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B2D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B2D8);
		  /* 8208B2D8h */ case    0:  		/* mfspr R12, LR */
		/* 8208B2D8h case    0:*/		regs.R12 = regs.LR;
		/* 8208B2D8h case    0:*/		return 0x8208B2DC;
		  /* 8208B2DCh */ case    1:  		/* bl 24444 */
		/* 8208B2DCh case    1:*/		regs.LR = 0x8208B2E0; return 0x82091258;
		/* 8208B2DCh case    1:*/		return 0x8208B2E0;
		  /* 8208B2E0h */ case    2:  		/* lbz R31, <#[R4 + 4]> */
		/* 8208B2E0h case    2:*/		cpu::mem::load8z( regs, &regs.R31, (uint32)(regs.R4 + 0x00000004) );
		/* 8208B2E0h case    2:*/		return 0x8208B2E4;
		  /* 8208B2E4h */ case    3:  		/* lwz R11, <#[R3 + 48]> */
		/* 8208B2E4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 8208B2E4h case    3:*/		return 0x8208B2E8;
		  /* 8208B2E8h */ case    4:  		/* mr R10, R31 */
		/* 8208B2E8h case    4:*/		regs.R10 = regs.R31;
		/* 8208B2E8h case    4:*/		return 0x8208B2EC;
		  /* 8208B2ECh */ case    5:  		/* lhz R7, <#[R4 + 2]> */
		/* 8208B2ECh case    5:*/		cpu::mem::load16z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000002) );
		/* 8208B2ECh case    5:*/		return 0x8208B2F0;
		  /* 8208B2F0h */ case    6:  		/* add R11, R11, R5 */
		/* 8208B2F0h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 8208B2F0h case    6:*/		return 0x8208B2F4;
		  /* 8208B2F4h */ case    7:  		/* lbz R29, <#[R4 + 5]> */
		/* 8208B2F4h case    7:*/		cpu::mem::load8z( regs, &regs.R29, (uint32)(regs.R4 + 0x00000005) );
		/* 8208B2F4h case    7:*/		return 0x8208B2F8;
		  /* 8208B2F8h */ case    8:  		/* addi R10, R10, 24 */
		/* 8208B2F8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 8208B2F8h case    8:*/		return 0x8208B2FC;
		  /* 8208B2FCh */ case    9:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8208B2FCh case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8208B2FCh case    9:*/		return 0x8208B300;
		  /* 8208B300h */ case   10:  		/* lwzx R30, <#[R10 + R3]> */
		/* 8208B300h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 8208B300h case   10:*/		return 0x8208B304;
		  /* 8208B304h */ case   11:  		/* stw R11, <#[R3 + 48]> */
		/* 8208B304h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 8208B304h case   11:*/		return 0x8208B308;
		  /* 8208B308h */ case   12:  		/* b 236 */
		/* 8208B308h case   12:*/		return 0x8208B3F4;
		/* 8208B308h case   12:*/		return 0x8208B30C;
		  /* 8208B30Ch */ case   13:  		/* cmplwi CR6, R5, 61440 */
		/* 8208B30Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x0000F000);
		/* 8208B30Ch case   13:*/		return 0x8208B310;
		  /* 8208B310h */ case   14:  		/* bc 4, CR6_GT, 32 */
		/* 8208B310h case   14:*/		if ( !regs.CR[6].gt ) { return 0x8208B330;  }
		/* 8208B310h case   14:*/		return 0x8208B314;
		  /* 8208B314h */ case   15:  		/* li R6, -4096 */
		/* 8208B314h case   15:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFF000);
		/* 8208B314h case   15:*/		return 0x8208B318;
		  /* 8208B318h */ case   16:  		/* cmplwi CR6, R5, 61441 */
		/* 8208B318h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x0000F001);
		/* 8208B318h case   16:*/		return 0x8208B31C;
		  /* 8208B31Ch */ case   17:  		/* bc 4, CR6_EQ, 8 */
		/* 8208B31Ch case   17:*/		if ( !regs.CR[6].eq ) { return 0x8208B324;  }
		/* 8208B31Ch case   17:*/		return 0x8208B320;
		  /* 8208B320h */ case   18:  		/* li R6, -4112 */
		/* 8208B320h case   18:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFEFF0);
		/* 8208B320h case   18:*/		return 0x8208B324;
	}
	return 0x8208B324;
} // Block from 8208B2D8h-8208B324h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8208B324h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B324( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B324) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B324);
		  /* 8208B324h */ case    0:  		/* li R11, 0 */
		/* 8208B324h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8208B324h case    0:*/		return 0x8208B328;
		  /* 8208B328h */ case    1:  		/* stb R11, <#[R4 + 5]> */
		/* 8208B328h case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R4 + 0x00000005) );
		/* 8208B328h case    1:*/		return 0x8208B32C;
		  /* 8208B32Ch */ case    2:  		/* b 12 */
		/* 8208B32Ch case    2:*/		return 0x8208B338;
		/* 8208B32Ch case    2:*/		return 0x8208B330;
	}
	return 0x8208B330;
} // Block from 8208B324h-8208B330h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208B330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B330);
		  /* 8208B330h */ case    0:  		/* rlwinm R6, R5, 0, 16, 31 */
		/* 8208B330h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R6,regs.R5);
		/* 8208B330h case    0:*/		return 0x8208B334;
		  /* 8208B334h */ case    1:  		/* stb R29, <#[R4 + 5]> */
		/* 8208B334h case    1:*/		cpu::mem::store8( regs, regs.R29, (uint32)(regs.R4 + 0x00000005) );
		/* 8208B334h case    1:*/		return 0x8208B338;
	}
	return 0x8208B338;
} // Block from 8208B330h-8208B338h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208B338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B338);
		  /* 8208B338h */ case    0:  		/* lbz R11, <#[R4 + 5]> */
		/* 8208B338h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000005) );
		/* 8208B338h case    0:*/		return 0x8208B33C;
		  /* 8208B33Ch */ case    1:  		/* rlwinm R10, R6, 0, 16, 31 */
		/* 8208B33Ch case    1:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R6);
		/* 8208B33Ch case    1:*/		return 0x8208B340;
		  /* 8208B340h */ case    2:  		/* sth R7, <#[R4 + 2]> */
		/* 8208B340h case    2:*/		cpu::mem::store16( regs, regs.R7, (uint32)(regs.R4 + 0x00000002) );
		/* 8208B340h case    2:*/		return 0x8208B344;
		  /* 8208B344h */ case    3:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 8208B344h case    3:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 8208B344h case    3:*/		return 0x8208B348;
		  /* 8208B348h */ case    4:  		/* stb R31, <#[R4 + 4]> */
		/* 8208B348h case    4:*/		cpu::mem::store8( regs, regs.R31, (uint32)(regs.R4 + 0x00000004) );
		/* 8208B348h case    4:*/		return 0x8208B34C;
		  /* 8208B34Ch */ case    5:  		/* sth R6, <#[R4]> */
		/* 8208B34Ch case    5:*/		cpu::mem::store16( regs, regs.R6, (uint32)(regs.R4 + 0x00000000) );
		/* 8208B34Ch case    5:*/		return 0x8208B350;
		  /* 8208B350h */ case    6:  		/* cmplwi CR6, R10, 128 */
		/* 8208B350h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000080);
		/* 8208B350h case    6:*/		return 0x8208B354;
		  /* 8208B354h */ case    7:  		/* stb R11, <#[R4 + 5]> */
		/* 8208B354h case    7:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R4 + 0x00000005) );
		/* 8208B354h case    7:*/		return 0x8208B358;
		  /* 8208B358h */ case    8:  		/* bc 4, CR6_LT, 68 */
		/* 8208B358h case    8:*/		if ( !regs.CR[6].lt ) { return 0x8208B39C;  }
		/* 8208B358h case    8:*/		return 0x8208B35C;
		  /* 8208B35Ch */ case    9:  		/* addi R11, R10, 48 */
		/* 8208B35Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x30);
		/* 8208B35Ch case    9:*/		return 0x8208B360;
		  /* 8208B360h */ case   10:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8208B360h case   10:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8208B360h case   10:*/		return 0x8208B364;
		  /* 8208B364h */ case   11:  		/* add R11, R11, R3 */
		/* 8208B364h case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8208B364h case   11:*/		return 0x8208B368;
		  /* 8208B368h */ case   12:  		/* lwz R9, <#[R11]> */
		/* 8208B368h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8208B368h case   12:*/		return 0x8208B36C;
		  /* 8208B36Ch */ case   13:  		/* cmplw CR6, R9, R11 */
		/* 8208B36Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8208B36Ch case   13:*/		return 0x8208B370;
		  /* 8208B370h */ case   14:  		/* bc 4, CR6_EQ, 80 */
		/* 8208B370h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8208B3C0;  }
		/* 8208B370h case   14:*/		return 0x8208B374;
		  /* 8208B374h */ case   15:  		/* rlwinm R9, R10, 27, 5, 31 */
		/* 8208B374h case   15:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R9,regs.R10);
		/* 8208B374h case   15:*/		return 0x8208B378;
		  /* 8208B378h */ case   16:  		/* li R7, 1 */
		/* 8208B378h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8208B378h case   16:*/		return 0x8208B37C;
		  /* 8208B37Ch */ case   17:  		/* addi R9, R9, 88 */
		/* 8208B37Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x58);
		/* 8208B37Ch case   17:*/		return 0x8208B380;
		  /* 8208B380h */ case   18:  		/* rlwinm R8, R10, 0, 27, 31 */
		/* 8208B380h case   18:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R10);
		/* 8208B380h case   18:*/		return 0x8208B384;
		  /* 8208B384h */ case   19:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8208B384h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8208B384h case   19:*/		return 0x8208B388;
	}
	return 0x8208B388;
} // Block from 8208B338h-8208B388h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8208B388h
// Function '?PrintRTF@Disassembler@D3D@@AAAXPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B388);
		  /* 8208B388h */ case    0:  		/* slw R8, R7, R8 */
		/* 8208B388h case    0:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 8208B388h case    0:*/		return 0x8208B38C;
		  /* 8208B38Ch */ case    1:  		/* lwzx R7, <#[R9 + R3]> */
		/* 8208B38Ch case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 8208B38Ch case    1:*/		return 0x8208B390;
		  /* 8208B390h */ case    2:  		/* or R8, R8, R7 */
		/* 8208B390h case    2:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8208B390h case    2:*/		return 0x8208B394;
		  /* 8208B394h */ case    3:  		/* stwx R8, <#[R9 + R3]> */
		/* 8208B394h case    3:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 8208B394h case    3:*/		return 0x8208B398;
		  /* 8208B398h */ case    4:  		/* b 40 */
		/* 8208B398h case    4:*/		return 0x8208B3C0;
		/* 8208B398h case    4:*/		return 0x8208B39C;
	}
	return 0x8208B39C;
} // Block from 8208B388h-8208B39Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208B39Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B39C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B39C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B39C);
		  /* 8208B39Ch */ case    0:  		/* lwz R11, <#[R3 + 384]> */
		/* 8208B39Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000180) );
		/* 8208B39Ch case    0:*/		return 0x8208B3A0;
		  /* 8208B3A0h */ case    1:  		/* addi R9, R3, 384 */
		/* 8208B3A0h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x180);
		/* 8208B3A0h case    1:*/		return 0x8208B3A4;
		  /* 8208B3A4h */ case    2:  		/* b 20 */
		/* 8208B3A4h case    2:*/		return 0x8208B3B8;
		/* 8208B3A4h case    2:*/		return 0x8208B3A8;
		  /* 8208B3A8h */ case    3:  		/* lhz R8, <#[R11 - 8]> */
		/* 8208B3A8h case    3:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 8208B3A8h case    3:*/		return 0x8208B3AC;
		  /* 8208B3ACh */ case    4:  		/* cmplw CR6, R10, R8 */
		/* 8208B3ACh case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8208B3ACh case    4:*/		return 0x8208B3B0;
		  /* 8208B3B0h */ case    5:  		/* bc 4, CR6_GT, 16 */
		/* 8208B3B0h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8208B3C0;  }
		/* 8208B3B0h case    5:*/		return 0x8208B3B4;
		  /* 8208B3B4h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 8208B3B4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8208B3B4h case    6:*/		return 0x8208B3B8;
	}
	return 0x8208B3B8;
} // Block from 8208B39Ch-8208B3B8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208B3B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B3B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B3B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B3B8);
		  /* 8208B3B8h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 8208B3B8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8208B3B8h case    0:*/		return 0x8208B3BC;
		  /* 8208B3BCh */ case    1:  		/* bc 4, CR6_EQ, -20 */
		/* 8208B3BCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8208B3A8;  }
		/* 8208B3BCh case    1:*/		return 0x8208B3C0;
	}
	return 0x8208B3C0;
} // Block from 8208B3B8h-8208B3C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208B3C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B3C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B3C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B3C0);
		  /* 8208B3C0h */ case    0:  		/* lwz R28, <#[R11 + 4]> */
		/* 8208B3C0h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000004) );
		/* 8208B3C0h case    0:*/		return 0x8208B3C4;
		  /* 8208B3C4h */ case    1:  		/* addi R9, R4, 8 */
		/* 8208B3C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R4,0x8);
		/* 8208B3C4h case    1:*/		return 0x8208B3C8;
		  /* 8208B3C8h */ case    2:  		/* rlwinm R8, R10, 4, 0, 27 */
		/* 8208B3C8h case    2:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R8,regs.R10);
		/* 8208B3C8h case    2:*/		return 0x8208B3CC;
		  /* 8208B3CCh */ case    3:  		/* stw R11, <#[R4 + 8]> */
		/* 8208B3CCh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8208B3CCh case    3:*/		return 0x8208B3D0;
		  /* 8208B3D0h */ case    4:  		/* mr R7, R6 */
		/* 8208B3D0h case    4:*/		regs.R7 = regs.R6;
		/* 8208B3D0h case    4:*/		return 0x8208B3D4;
		  /* 8208B3D4h */ case    5:  		/* subf R5, R10, R5 */
		/* 8208B3D4h case    5:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R10,regs.R5);
		/* 8208B3D4h case    5:*/		return 0x8208B3D8;
		  /* 8208B3D8h */ case    6:  		/* stw R28, <#[R4 + 12]> */
		/* 8208B3D8h case    6:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R4 + 0x0000000C) );
		/* 8208B3D8h case    6:*/		return 0x8208B3DC;
		  /* 8208B3DCh */ case    7:  		/* add R4, R8, R4 */
		/* 8208B3DCh case    7:*/		cpu::op::add<0>(regs,&regs.R4,regs.R8,regs.R4);
		/* 8208B3DCh case    7:*/		return 0x8208B3E0;
	}
	return 0x8208B3E0;
} // Block from 8208B3C0h-8208B3E0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8208B3E0h
// Function '?PrintOpcode@Disassembler@D3D@@AAAXPBD_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B3E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B3E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B3E0);
		  /* 8208B3E0h */ case    0:  		/* stw R9, <#[R28]> */
		/* 8208B3E0h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R28 + 0x00000000) );
		/* 8208B3E0h case    0:*/		return 0x8208B3E4;
		  /* 8208B3E4h */ case    1:  		/* stw R9, <#[R11 + 4]> */
		/* 8208B3E4h case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8208B3E4h case    1:*/		return 0x8208B3E8;
		  /* 8208B3E8h */ case    2:  		/* lwz R11, <#[R30 + 44]> */
		/* 8208B3E8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 8208B3E8h case    2:*/		return 0x8208B3EC;
		  /* 8208B3ECh */ case    3:  		/* cmplw CR6, R4, R11 */
		/* 8208B3ECh case    3:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 8208B3ECh case    3:*/		return 0x8208B3F0;
		  /* 8208B3F0h */ case    4:  		/* bc 4, CR6_LT, 24 */
		/* 8208B3F0h case    4:*/		if ( !regs.CR[6].lt ) { return 0x8208B408;  }
		/* 8208B3F0h case    4:*/		return 0x8208B3F4;
	}
	return 0x8208B3F4;
} // Block from 8208B3E0h-8208B3F4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208B3F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B3F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B3F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B3F4);
		  /* 8208B3F4h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 8208B3F4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8208B3F4h case    0:*/		return 0x8208B3F8;
		  /* 8208B3F8h */ case    1:  		/* bc 4, CR6_EQ, -236 */
		/* 8208B3F8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8208B30C;  }
		/* 8208B3F8h case    1:*/		return 0x8208B3FC;
		  /* 8208B3FCh */ case    2:  		/* rlwinm. R11, R29, 0, 27, 27 */
		/* 8208B3FCh case    2:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R29);
		/* 8208B3FCh case    2:*/		return 0x8208B400;
		  /* 8208B400h */ case    3:  		/* bc 4, CR0_EQ, 8 */
		/* 8208B400h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8208B408;  }
		/* 8208B400h case    3:*/		return 0x8208B404;
		  /* 8208B404h */ case    4:  		/* sth R7, <#[R4 + 2]> */
		/* 8208B404h case    4:*/		cpu::mem::store16( regs, regs.R7, (uint32)(regs.R4 + 0x00000002) );
		/* 8208B404h case    4:*/		return 0x8208B408;
	}
	return 0x8208B408;
} // Block from 8208B3F4h-8208B408h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208B408h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B408);
		  /* 8208B408h */ case    0:  		/* b 24224 */
		/* 8208B408h case    0:*/		return 0x820912A8;
		/* 8208B408h case    0:*/		return 0x8208B40C;
		  /* 8208B40Ch */ case    1:  		/* nop */
		/* 8208B40Ch case    1:*/		cpu::op::nop();
		/* 8208B40Ch case    1:*/		return 0x8208B410;
	}
	return 0x8208B410;
} // Block from 8208B408h-8208B410h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208B410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B410);
		  /* 8208B410h */ case    0:  		/* mfspr R12, LR */
		/* 8208B410h case    0:*/		regs.R12 = regs.LR;
		/* 8208B410h case    0:*/		return 0x8208B414;
		  /* 8208B414h */ case    1:  		/* bl 24108 */
		/* 8208B414h case    1:*/		regs.LR = 0x8208B418; return 0x82091240;
		/* 8208B414h case    1:*/		return 0x8208B418;
		  /* 8208B418h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 8208B418h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 8208B418h case    2:*/		return 0x8208B41C;
		  /* 8208B41Ch */ case    3:  		/* lwz R11, <#[R3 + 28]> */
		/* 8208B41Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 8208B41Ch case    3:*/		return 0x8208B420;
		  /* 8208B420h */ case    4:  		/* mr R30, R3 */
		/* 8208B420h case    4:*/		regs.R30 = regs.R3;
		/* 8208B420h case    4:*/		return 0x8208B424;
		  /* 8208B424h */ case    5:  		/* mr R22, R4 */
		/* 8208B424h case    5:*/		regs.R22 = regs.R4;
		/* 8208B424h case    5:*/		return 0x8208B428;
		  /* 8208B428h */ case    6:  		/* mr R27, R5 */
		/* 8208B428h case    6:*/		regs.R27 = regs.R5;
		/* 8208B428h case    6:*/		return 0x8208B42C;
		  /* 8208B42Ch */ case    7:  		/* mr R23, R6 */
		/* 8208B42Ch case    7:*/		regs.R23 = regs.R6;
		/* 8208B42Ch case    7:*/		return 0x8208B430;
		  /* 8208B430h */ case    8:  		/* mr R29, R7 */
		/* 8208B430h case    8:*/		regs.R29 = regs.R7;
		/* 8208B430h case    8:*/		return 0x8208B434;
		  /* 8208B434h */ case    9:  		/* cmplw CR6, R7, R11 */
		/* 8208B434h case    9:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 8208B434h case    9:*/		return 0x8208B438;
		  /* 8208B438h */ case   10:  		/* bc 4, CR6_GT, 12 */
		/* 8208B438h case   10:*/		if ( !regs.CR[6].gt ) { return 0x8208B444;  }
		/* 8208B438h case   10:*/		return 0x8208B43C;
		  /* 8208B43Ch */ case   11:  		/* li R3, 0 */
		/* 8208B43Ch case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208B43Ch case   11:*/		return 0x8208B440;
		  /* 8208B440h */ case   12:  		/* b 1352 */
		/* 8208B440h case   12:*/		return 0x8208B988;
		/* 8208B440h case   12:*/		return 0x8208B444;
	}
	return 0x8208B444;
} // Block from 8208B410h-8208B444h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8208B444h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B444( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B444) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B444);
		  /* 8208B444h */ case    0:  		/* lhz R11, <#[R27]> */
		/* 8208B444h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8208B444h case    0:*/		return 0x8208B448;
		  /* 8208B448h */ case    1:  		/* li R25, 1 */
		/* 8208B448h case    1:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 8208B448h case    1:*/		return 0x8208B44C;
		  /* 8208B44Ch */ case    2:  		/* lbz R9, <#[R27 + 5]> */
		/* 8208B44Ch case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000005) );
		/* 8208B44Ch case    2:*/		return 0x8208B450;
	}
	return 0x8208B450;
} // Block from 8208B444h-8208B450h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208B450h
// Function '?PrintCFOpcode@Disassembler@D3D@@AAAXPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B450);
		  /* 8208B450h */ case    0:  		/* rlwinm R10, R11, 4, 0, 31 */
		/* 8208B450h case    0:*/		cpu::op::rlwinm<0,4,0,31>(regs,&regs.R10,regs.R11);
		/* 8208B450h case    0:*/		return 0x8208B454;
		  /* 8208B454h */ case    1:  		/* rlwinm. R8, R9, 0, 27, 27 */
		/* 8208B454h case    1:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R8,regs.R9);
		/* 8208B454h case    1:*/		return 0x8208B458;
		  /* 8208B458h */ case    2:  		/* mr R26, R9 */
		/* 8208B458h case    2:*/		regs.R26 = regs.R9;
		/* 8208B458h case    2:*/		return 0x8208B45C;
		  /* 8208B45Ch */ case    3:  		/* add R31, R10, R27 */
		/* 8208B45Ch case    3:*/		cpu::op::add<0>(regs,&regs.R31,regs.R10,regs.R27);
		/* 8208B45Ch case    3:*/		return 0x8208B460;
		  /* 8208B460h */ case    4:  		/* bc 12, CR0_EQ, 156 */
		/* 8208B460h case    4:*/		if ( regs.CR[0].eq ) { return 0x8208B4FC;  }
		/* 8208B460h case    4:*/		return 0x8208B464;
		  /* 8208B464h */ case    5:  		/* subf R10, R11, R29 */
		/* 8208B464h case    5:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R29);
		/* 8208B464h case    5:*/		return 0x8208B468;
		  /* 8208B468h */ case    6:  		/* lbz R11, <#[R27 + 4]> */
		/* 8208B468h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 8208B468h case    6:*/		return 0x8208B46C;
		  /* 8208B46Ch */ case    7:  		/* mr R6, R31 */
		/* 8208B46Ch case    7:*/		regs.R6 = regs.R31;
		/* 8208B46Ch case    7:*/		return 0x8208B470;
		  /* 8208B470h */ case    8:  		/* rlwinm R10, R10, 4, 0, 27 */
		/* 8208B470h case    8:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R10);
		/* 8208B470h case    8:*/		return 0x8208B474;
		  /* 8208B474h */ case    9:  		/* addi R11, R11, 24 */
		/* 8208B474h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 8208B474h case    9:*/		return 0x8208B478;
		  /* 8208B478h */ case   10:  		/* addis R10, R10, 1 */
		/* 8208B478h case   10:*/		cpu::op::addis<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8208B478h case   10:*/		return 0x8208B47C;
		  /* 8208B47Ch */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8208B47Ch case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8208B47Ch case   11:*/		return 0x8208B480;
		  /* 8208B480h */ case   12:  		/* addi R10, R10, -1 */
		/* 8208B480h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8208B480h case   12:*/		return 0x8208B484;
		  /* 8208B484h */ case   13:  		/* addi R5, R1, 80 */
		/* 8208B484h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8208B484h case   13:*/		return 0x8208B488;
		  /* 8208B488h */ case   14:  		/* rlwinm R10, R10, 0, 0, 15 */
		/* 8208B488h case   14:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R10,regs.R10);
		/* 8208B488h case   14:*/		return 0x8208B48C;
		  /* 8208B48Ch */ case   15:  		/* mr R3, R30 */
		/* 8208B48Ch case   15:*/		regs.R3 = regs.R30;
		/* 8208B48Ch case   15:*/		return 0x8208B490;
		  /* 8208B490h */ case   16:  		/* stw R10, <#[R1 + 80]> */
		/* 8208B490h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B490h case   16:*/		return 0x8208B494;
		  /* 8208B494h */ case   17:  		/* lwzx R4, <#[R11 + R30]> */
		/* 8208B494h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8208B494h case   17:*/		return 0x8208B498;
		  /* 8208B498h */ case   18:  		/* bl -2136 */
		/* 8208B498h case   18:*/		regs.LR = 0x8208B49C; return 0x8208AC40;
		/* 8208B498h case   18:*/		return 0x8208B49C;
		  /* 8208B49Ch */ case   19:  		/* or. R4, R3, R3 */
		/* 8208B49Ch case   19:*/		cpu::op::or<1>(regs,&regs.R4,regs.R3,regs.R3);
		/* 8208B49Ch case   19:*/		return 0x8208B4A0;
		  /* 8208B4A0h */ case   20:  		/* bc 12, CR0_EQ, -100 */
		/* 8208B4A0h case   20:*/		if ( regs.CR[0].eq ) { return 0x8208B43C;  }
		/* 8208B4A0h case   20:*/		return 0x8208B4A4;
		  /* 8208B4A4h */ case   21:  		/* lwz R11, <#[R1 + 80]> */
		/* 8208B4A4h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B4A4h case   21:*/		return 0x8208B4A8;
		  /* 8208B4A8h */ case   22:  		/* li R6, 0 */
		/* 8208B4A8h case   22:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8208B4A8h case   22:*/		return 0x8208B4AC;
		  /* 8208B4ACh */ case   23:  		/* addi R5, R1, 80 */
		/* 8208B4ACh case   23:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8208B4ACh case   23:*/		return 0x8208B4B0;
		  /* 8208B4B0h */ case   24:  		/* rlwinm R11, R11, 28, 4, 31 */
		/* 8208B4B0h case   24:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R11,regs.R11);
		/* 8208B4B0h case   24:*/		return 0x8208B4B4;
		  /* 8208B4B4h */ case   25:  		/* mr R3, R30 */
		/* 8208B4B4h case   25:*/		regs.R3 = regs.R30;
		/* 8208B4B4h case   25:*/		return 0x8208B4B8;
	}
	return 0x8208B4B8;
} // Block from 8208B450h-8208B4B8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8208B4B8h
// Function '?PrintWarning@Disassembler@D3D@@AAAX_NHPBDZZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B4B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B4B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B4B8);
		  /* 8208B4B8h */ case    0:  		/* stw R11, <#[R1 + 80]> */
		/* 8208B4B8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B4B8h case    0:*/		return 0x8208B4BC;
		  /* 8208B4BCh */ case    1:  		/* bl -1516 */
		/* 8208B4BCh case    1:*/		regs.LR = 0x8208B4C0; return 0x8208AED0;
		/* 8208B4BCh case    1:*/		return 0x8208B4C0;
		  /* 8208B4C0h */ case    2:  		/* lhz R11, <#[R27]> */
		/* 8208B4C0h case    2:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8208B4C0h case    2:*/		return 0x8208B4C4;
		  /* 8208B4C4h */ case    3:  		/* lwz R5, <#[R1 + 80]> */
		/* 8208B4C4h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B4C4h case    3:*/		return 0x8208B4C8;
		  /* 8208B4C8h */ case    4:  		/* mr R4, R3 */
		/* 8208B4C8h case    4:*/		regs.R4 = regs.R3;
		/* 8208B4C8h case    4:*/		return 0x8208B4CC;
		  /* 8208B4CCh */ case    5:  		/* lbz R28, <#[R3 + 5]> */
		/* 8208B4CCh case    5:*/		cpu::mem::load8z( regs, &regs.R28, (uint32)(regs.R3 + 0x00000005) );
		/* 8208B4CCh case    5:*/		return 0x8208B4D0;
		  /* 8208B4D0h */ case    6:  		/* add R11, R11, R5 */
		/* 8208B4D0h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 8208B4D0h case    6:*/		return 0x8208B4D4;
		  /* 8208B4D4h */ case    7:  		/* cmplw CR6, R11, R29 */
		/* 8208B4D4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 8208B4D4h case    7:*/		return 0x8208B4D8;
		  /* 8208B4D8h */ case    8:  		/* bc 4, CR6_LT, 244 */
		/* 8208B4D8h case    8:*/		if ( !regs.CR[6].lt ) { return 0x8208B5CC;  }
		/* 8208B4D8h case    8:*/		return 0x8208B4DC;
		  /* 8208B4DCh */ case    9:  		/* mr R3, R30 */
		/* 8208B4DCh case    9:*/		regs.R3 = regs.R30;
		/* 8208B4DCh case    9:*/		return 0x8208B4E0;
		  /* 8208B4E0h */ case   10:  		/* bl -520 */
		/* 8208B4E0h case   10:*/		regs.LR = 0x8208B4E4; return 0x8208B2D8;
		/* 8208B4E0h case   10:*/		return 0x8208B4E4;
		  /* 8208B4E4h */ case   11:  		/* lwz R10, <#[R30 + 48]> */
		/* 8208B4E4h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000030) );
		/* 8208B4E4h case   11:*/		return 0x8208B4E8;
		  /* 8208B4E8h */ case   12:  		/* lwz R11, <#[R1 + 80]> */
		/* 8208B4E8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B4E8h case   12:*/		return 0x8208B4EC;
		  /* 8208B4ECh */ case   13:  		/* li R3, 0 */
		/* 8208B4ECh case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208B4ECh case   13:*/		return 0x8208B4F0;
		  /* 8208B4F0h */ case   14:  		/* add R11, R10, R11 */
		/* 8208B4F0h case   14:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208B4F0h case   14:*/		return 0x8208B4F4;
		  /* 8208B4F4h */ case   15:  		/* stw R11, <#[R30 + 48]> */
		/* 8208B4F4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 8208B4F4h case   15:*/		return 0x8208B4F8;
		  /* 8208B4F8h */ case   16:  		/* b 1168 */
		/* 8208B4F8h case   16:*/		return 0x8208B988;
		/* 8208B4F8h case   16:*/		return 0x8208B4FC;
	}
	return 0x8208B4FC;
} // Block from 8208B4B8h-8208B4FCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 8208B4FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B4FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B4FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B4FC);
		  /* 8208B4FCh */ case    0:  		/* lbz R28, <#[R31 + 5]> */
		/* 8208B4FCh case    0:*/		cpu::mem::load8z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000005) );
		/* 8208B4FCh case    0:*/		return 0x8208B500;
		  /* 8208B500h */ case    1:  		/* rlwinm. R10, R28, 0, 31, 31 */
		/* 8208B500h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R28);
		/* 8208B500h case    1:*/		return 0x8208B504;
		  /* 8208B504h */ case    2:  		/* bc 4, CR0_EQ, -200 */
		/* 8208B504h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8208B43C;  }
		/* 8208B504h case    2:*/		return 0x8208B508;
		  /* 8208B508h */ case    3:  		/* lhz R10, <#[R31]> */
		/* 8208B508h case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8208B508h case    3:*/		return 0x8208B50C;
		  /* 8208B50Ch */ case    4:  		/* add R11, R10, R11 */
		/* 8208B50Ch case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208B50Ch case    4:*/		return 0x8208B510;
		  /* 8208B510h */ case    5:  		/* stw R11, <#[R1 + 80]> */
		/* 8208B510h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B510h case    5:*/		return 0x8208B514;
		  /* 8208B514h */ case    6:  		/* cmplw CR6, R11, R29 */
		/* 8208B514h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 8208B514h case    6:*/		return 0x8208B518;
		  /* 8208B518h */ case    7:  		/* bc 12, CR6_LT, -220 */
		/* 8208B518h case    7:*/		if ( regs.CR[6].lt ) { return 0x8208B43C;  }
		/* 8208B518h case    7:*/		return 0x8208B51C;
		  /* 8208B51Ch */ case    8:  		/* lwz R11, <#[R31 + 12]> */
		/* 8208B51Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8208B51Ch case    8:*/		return 0x8208B520;
		  /* 8208B520h */ case    9:  		/* addi R9, R31, 8 */
		/* 8208B520h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x8);
		/* 8208B520h case    9:*/		return 0x8208B524;
		  /* 8208B524h */ case   10:  		/* lwz R10, <#[R31 + 8]> */
		/* 8208B524h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8208B524h case   10:*/		return 0x8208B528;
		  /* 8208B528h */ case   11:  		/* lwz R8, <#[R11]> */
		/* 8208B528h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8208B528h case   11:*/		return 0x8208B52C;
		  /* 8208B52Ch */ case   12:  		/* lwz R7, <#[R10 + 4]> */
		/* 8208B52Ch case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 8208B52Ch case   12:*/		return 0x8208B530;
		  /* 8208B530h */ case   13:  		/* cmplw CR6, R8, R7 */
		/* 8208B530h case   13:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 8208B530h case   13:*/		return 0x8208B534;
		  /* 8208B534h */ case   14:  		/* bc 4, CR6_EQ, 72 */
		/* 8208B534h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8208B57C;  }
		/* 8208B534h case   14:*/		return 0x8208B538;
		  /* 8208B538h */ case   15:  		/* cmplw CR6, R8, R9 */
		/* 8208B538h case   15:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8208B538h case   15:*/		return 0x8208B53C;
		  /* 8208B53Ch */ case   16:  		/* bc 4, CR6_EQ, 64 */
		/* 8208B53Ch case   16:*/		if ( !regs.CR[6].eq ) { return 0x8208B57C;  }
		/* 8208B53Ch case   16:*/		return 0x8208B540;
		  /* 8208B540h */ case   17:  		/* stw R10, <#[R11]> */
		/* 8208B540h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208B540h case   17:*/		return 0x8208B544;
		  /* 8208B544h */ case   18:  		/* cmplw CR6, R10, R11 */
		/* 8208B544h case   18:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208B544h case   18:*/		return 0x8208B548;
		  /* 8208B548h */ case   19:  		/* stw R11, <#[R10 + 4]> */
		/* 8208B548h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8208B548h case   19:*/		return 0x8208B54C;
		  /* 8208B54Ch */ case   20:  		/* bc 4, CR6_EQ, 48 */
		/* 8208B54Ch case   20:*/		if ( !regs.CR[6].eq ) { return 0x8208B57C;  }
		/* 8208B54Ch case   20:*/		return 0x8208B550;
		  /* 8208B550h */ case   21:  		/* lhz R11, <#[R31]> */
		/* 8208B550h case   21:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8208B550h case   21:*/		return 0x8208B554;
		  /* 8208B554h */ case   22:  		/* cmplwi CR6, R11, 128 */
		/* 8208B554h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 8208B554h case   22:*/		return 0x8208B558;
		  /* 8208B558h */ case   23:  		/* bc 4, CR6_LT, 36 */
		/* 8208B558h case   23:*/		if ( !regs.CR[6].lt ) { return 0x8208B57C;  }
		/* 8208B558h case   23:*/		return 0x8208B55C;
		  /* 8208B55Ch */ case   24:  		/* rlwinm R10, R11, 27, 5, 31 */
		/* 8208B55Ch case   24:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R11);
		/* 8208B55Ch case   24:*/		return 0x8208B560;
		  /* 8208B560h */ case   25:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8208B560h case   25:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8208B560h case   25:*/		return 0x8208B564;
		  /* 8208B564h */ case   26:  		/* addi R10, R10, 88 */
		/* 8208B564h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x58);
		/* 8208B564h case   26:*/		return 0x8208B568;
		  /* 8208B568h */ case   27:  		/* slw R9, R25, R11 */
		/* 8208B568h case   27:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R25,regs.R11);
		/* 8208B568h case   27:*/		return 0x8208B56C;
		  /* 8208B56Ch */ case   28:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 8208B56Ch case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 8208B56Ch case   28:*/		return 0x8208B570;
		  /* 8208B570h */ case   29:  		/* lwzx R10, <#[R11 + R30]> */
		/* 8208B570h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8208B570h case   29:*/		return 0x8208B574;
		  /* 8208B574h */ case   30:  		/* xor R10, R9, R10 */
		/* 8208B574h case   30:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8208B574h case   30:*/		return 0x8208B578;
		  /* 8208B578h */ case   31:  		/* stwx R10, <#[R11 + R30]> */
		/* 8208B578h case   31:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8208B578h case   31:*/		return 0x8208B57C;
	}
	return 0x8208B57C;
} // Block from 8208B4FCh-8208B57Ch (32 instructions)

//////////////////////////////////////////////////////
// Block at 8208B57Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B57C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B57C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B57C);
		  /* 8208B57Ch */ case    0:  		/* lbz R11, <#[R31 + 5]> */
		/* 8208B57Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000005) );
		/* 8208B57Ch case    0:*/		return 0x8208B580;
		  /* 8208B580h */ case    1:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 8208B580h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 8208B580h case    1:*/		return 0x8208B584;
		  /* 8208B584h */ case    2:  		/* bc 12, CR0_EQ, 52 */
		/* 8208B584h case    2:*/		if ( regs.CR[0].eq ) { return 0x8208B5B8;  }
		/* 8208B584h case    2:*/		return 0x8208B588;
		  /* 8208B588h */ case    3:  		/* lhz R10, <#[R31]> */
		/* 8208B588h case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8208B588h case    3:*/		return 0x8208B58C;
		  /* 8208B58Ch */ case    4:  		/* rlwinm. R9, R11, 0, 30, 30 */
		/* 8208B58Ch case    4:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R11);
		/* 8208B58Ch case    4:*/		return 0x8208B590;
		  /* 8208B590h */ case    5:  		/* rlwinm R11, R10, 4, 0, 31 */
		/* 8208B590h case    5:*/		cpu::op::rlwinm<0,4,0,31>(regs,&regs.R11,regs.R10);
		/* 8208B590h case    5:*/		return 0x8208B594;
		  /* 8208B594h */ case    6:  		/* addi R4, R11, -24 */
		/* 8208B594h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFE8);
		/* 8208B594h case    6:*/		return 0x8208B598;
	}
	return 0x8208B598;
} // Block from 8208B57Ch-8208B598h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208B598h
// Function 'XDisassembleMicrocodeShaderRaw'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B598);
		  /* 8208B598h */ case    0:  		/* bc 12, CR0_EQ, 16 */
		/* 8208B598h case    0:*/		if ( regs.CR[0].eq ) { return 0x8208B5A8;  }
		/* 8208B598h case    0:*/		return 0x8208B59C;
		  /* 8208B59Ch */ case    1:  		/* cmplwi CR6, R4, 4 */
		/* 8208B59Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000004);
		/* 8208B59Ch case    1:*/		return 0x8208B5A0;
		  /* 8208B5A0h */ case    2:  		/* bc 4, CR6_GT, 8 */
		/* 8208B5A0h case    2:*/		if ( !regs.CR[6].gt ) { return 0x8208B5A8;  }
		/* 8208B5A0h case    2:*/		return 0x8208B5A4;
		  /* 8208B5A4h */ case    3:  		/* addi R4, R4, -4 */
		/* 8208B5A4h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFFFC);
		/* 8208B5A4h case    3:*/		return 0x8208B5A8;
	}
	return 0x8208B5A8;
} // Block from 8208B598h-8208B5A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208B5A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B5A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B5A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B5A8);
		  /* 8208B5A8h */ case    0:  		/* lis R5, -274 */
		/* 8208B5A8h case    0:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFFFEEE);
		/* 8208B5A8h case    0:*/		return 0x8208B5AC;
		  /* 8208B5ACh */ case    1:  		/* addi R3, R31, 24 */
		/* 8208B5ACh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x18);
		/* 8208B5ACh case    1:*/		return 0x8208B5B0;
		  /* 8208B5B0h */ case    2:  		/* ori R5, R5, 65262 */
		/* 8208B5B0h case    2:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0xFEEE);
		/* 8208B5B0h case    2:*/		return 0x8208B5B4;
		  /* 8208B5B4h */ case    3:  		/* bl 1973940 */
		/* 8208B5B4h case    3:*/		regs.LR = 0x8208B5B8; return 0x8226D468;
		/* 8208B5B4h case    3:*/		return 0x8208B5B8;
	}
	return 0x8208B5B8;
} // Block from 8208B5A8h-8208B5B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208B5B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B5B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B5B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B5B8);
		  /* 8208B5B8h */ case    0:  		/* lhz R10, <#[R31]> */
		/* 8208B5B8h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8208B5B8h case    0:*/		return 0x8208B5BC;
		  /* 8208B5BCh */ case    1:  		/* lwz R9, <#[R30 + 48]> */
		/* 8208B5BCh case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000030) );
		/* 8208B5BCh case    1:*/		return 0x8208B5C0;
		  /* 8208B5C0h */ case    2:  		/* lwz R11, <#[R1 + 80]> */
		/* 8208B5C0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B5C0h case    2:*/		return 0x8208B5C4;
		  /* 8208B5C4h */ case    3:  		/* subf R10, R10, R9 */
		/* 8208B5C4h case    3:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8208B5C4h case    3:*/		return 0x8208B5C8;
		  /* 8208B5C8h */ case    4:  		/* stw R10, <#[R30 + 48]> */
		/* 8208B5C8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000030) );
		/* 8208B5C8h case    4:*/		return 0x8208B5CC;
	}
	return 0x8208B5CC;
} // Block from 8208B5B8h-8208B5CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208B5CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B5CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B5CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B5CC);
		  /* 8208B5CCh */ case    0:  		/* lhz R10, <#[R27]> */
		/* 8208B5CCh case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 8208B5CCh case    0:*/		return 0x8208B5D0;
		  /* 8208B5D0h */ case    1:  		/* subf R11, R29, R11 */
		/* 8208B5D0h case    1:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 8208B5D0h case    1:*/		return 0x8208B5D4;
		  /* 8208B5D4h */ case    2:  		/* lbz R9, <#[R27 + 6]> */
		/* 8208B5D4h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000006) );
		/* 8208B5D4h case    2:*/		return 0x8208B5D8;
		  /* 8208B5D8h */ case    3:  		/* rlwinm R10, R10, 4, 0, 31 */
		/* 8208B5D8h case    3:*/		cpu::op::rlwinm<0,4,0,31>(regs,&regs.R10,regs.R10);
		/* 8208B5D8h case    3:*/		return 0x8208B5DC;
		  /* 8208B5DCh */ case    4:  		/* stw R11, <#[R1 + 80]> */
		/* 8208B5DCh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B5DCh case    4:*/		return 0x8208B5E0;
		  /* 8208B5E0h */ case    5:  		/* cmplwi CR6, R11, 2 */
		/* 8208B5E0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 8208B5E0h case    5:*/		return 0x8208B5E4;
		  /* 8208B5E4h */ case    6:  		/* subf R24, R9, R10 */
		/* 8208B5E4h case    6:*/		cpu::op::subf<0>(regs,&regs.R24,regs.R9,regs.R10);
		/* 8208B5E4h case    6:*/		return 0x8208B5E8;
		  /* 8208B5E8h */ case    7:  		/* bc 12, CR6_GT, 16 */
		/* 8208B5E8h case    7:*/		if ( regs.CR[6].gt ) { return 0x8208B5F8;  }
		/* 8208B5E8h case    7:*/		return 0x8208B5EC;
		  /* 8208B5ECh */ case    8:  		/* add R29, R11, R29 */
		/* 8208B5ECh case    8:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R29);
		/* 8208B5ECh case    8:*/		return 0x8208B5F0;
		  /* 8208B5F0h */ case    9:  		/* li R11, 0 */
		/* 8208B5F0h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8208B5F0h case    9:*/		return 0x8208B5F4;
		  /* 8208B5F4h */ case   10:  		/* stw R11, <#[R1 + 80]> */
		/* 8208B5F4h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B5F4h case   10:*/		return 0x8208B5F8;
	}
	return 0x8208B5F8;
} // Block from 8208B5CCh-8208B5F8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8208B5F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B5F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B5F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B5F8);
		  /* 8208B5F8h */ case    0:  		/* rlwinm. R10, R26, 0, 30, 30 */
		/* 8208B5F8h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R26);
		/* 8208B5F8h case    0:*/		return 0x8208B5FC;
		  /* 8208B5FCh */ case    1:  		/* bc 12, CR0_EQ, 52 */
		/* 8208B5FCh case    1:*/		if ( regs.CR[0].eq ) { return 0x8208B630;  }
		/* 8208B5FCh case    1:*/		return 0x8208B600;
		  /* 8208B600h */ case    2:  		/* lhz R10, <#[R27]> */
		/* 8208B600h case    2:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 8208B600h case    2:*/		return 0x8208B604;
		  /* 8208B604h */ case    3:  		/* rlwinm R11, R29, 4, 0, 27 */
		/* 8208B604h case    3:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R29);
		/* 8208B604h case    3:*/		return 0x8208B608;
		  /* 8208B608h */ case    4:  		/* rlwinm R10, R10, 4, 0, 31 */
		/* 8208B608h case    4:*/		cpu::op::rlwinm<0,4,0,31>(regs,&regs.R10,regs.R10);
		/* 8208B608h case    4:*/		return 0x8208B60C;
		  /* 8208B60Ch */ case    5:  		/* add R9, R11, R27 */
		/* 8208B60Ch case    5:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R27);
		/* 8208B60Ch case    5:*/		return 0x8208B610;
		  /* 8208B610h */ case    6:  		/* add R11, R10, R27 */
		/* 8208B610h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R27);
		/* 8208B610h case    6:*/		return 0x8208B614;
		  /* 8208B614h */ case    7:  		/* addi R10, R9, -16 */
		/* 8208B614h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFFFF0);
		/* 8208B614h case    7:*/		return 0x8208B618;
		  /* 8208B618h */ case    8:  		/* addi R10, R11, -16 */
		/* 8208B618h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFF0);
		/* 8208B618h case    8:*/		return 0x8208B61C;
		  /* 8208B61Ch */ case    9:  		/* ld R10, <#[R11 - 16]> */
		/* 8208B61Ch case    9:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R11 + 0xFFFFFFF0) );
		/* 8208B61Ch case    9:*/		return 0x8208B620;
		  /* 8208B620h */ case   10:  		/* std R10, <#[R9 - 16]> */
		/* 8208B620h case   10:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R9 + 0xFFFFFFF0) );
		/* 8208B620h case   10:*/		return 0x8208B624;
		  /* 8208B624h */ case   11:  		/* ld R11, <#[R11 - 8]> */
		/* 8208B624h case   11:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 8208B624h case   11:*/		return 0x8208B628;
		  /* 8208B628h */ case   12:  		/* std R11, <#[R9 - 8]> */
		/* 8208B628h case   12:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + 0xFFFFFFF8) );
		/* 8208B628h case   12:*/		return 0x8208B62C;
		  /* 8208B62Ch */ case   13:  		/* lwz R11, <#[R1 + 80]> */
		/* 8208B62Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B62Ch case   13:*/		return 0x8208B630;
	}
	return 0x8208B630;
} // Block from 8208B5F8h-8208B630h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8208B630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B630);
		  /* 8208B630h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8208B630h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208B630h case    0:*/		return 0x8208B634;
		  /* 8208B634h */ case    1:  		/* bc 4, CR6_EQ, 84 */
		/* 8208B634h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8208B688;  }
		/* 8208B634h case    1:*/		return 0x8208B638;
		  /* 8208B638h */ case    2:  		/* lbz R11, <#[R27 + 5]> */
		/* 8208B638h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000005) );
		/* 8208B638h case    2:*/		return 0x8208B63C;
		  /* 8208B63Ch */ case    3:  		/* rlwinm. R10, R28, 0, 27, 27 */
		/* 8208B63Ch case    3:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R28);
		/* 8208B63Ch case    3:*/		return 0x8208B640;
		  /* 8208B640h */ case    4:  		/* rlwinm R9, R29, 4, 0, 27 */
		/* 8208B640h case    4:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R9,regs.R29);
		/* 8208B640h case    4:*/		return 0x8208B644;
		  /* 8208B644h */ case    5:  		/* or R8, R11, R10 */
		/* 8208B644h case    5:*/		cpu::op::or<0>(regs,&regs.R8,regs.R11,regs.R10);
		/* 8208B644h case    5:*/		return 0x8208B648;
		  /* 8208B648h */ case    6:  		/* subf R9, R23, R9 */
		/* 8208B648h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R23,regs.R9);
		/* 8208B648h case    6:*/		return 0x8208B64C;
		  /* 8208B64Ch */ case    7:  		/* rlwinm R11, R29, 0, 16, 31 */
		/* 8208B64Ch case    7:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R29);
		/* 8208B64Ch case    7:*/		return 0x8208B650;
		  /* 8208B650h */ case    8:  		/* stb R8, <#[R27 + 5]> */
		/* 8208B650h case    8:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R27 + 0x00000005) );
		/* 8208B650h case    8:*/		return 0x8208B654;
		  /* 8208B654h */ case    9:  		/* stb R9, <#[R27 + 6]> */
		/* 8208B654h case    9:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R27 + 0x00000006) );
		/* 8208B654h case    9:*/		return 0x8208B658;
		  /* 8208B658h */ case   10:  		/* sth R11, <#[R27]> */
		/* 8208B658h case   10:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8208B658h case   10:*/		return 0x8208B65C;
		  /* 8208B65Ch */ case   11:  		/* bc 4, CR0_EQ, 20 */
		/* 8208B65Ch case   11:*/		if ( !regs.CR[0].eq ) { return 0x8208B670;  }
		/* 8208B65Ch case   11:*/		return 0x8208B660;
		  /* 8208B660h */ case   12:  		/* rlwinm R10, R11, 4, 12, 27 */
		/* 8208B660h case   12:*/		cpu::op::rlwinm<0,4,12,27>(regs,&regs.R10,regs.R11);
		/* 8208B660h case   12:*/		return 0x8208B664;
		  /* 8208B664h */ case   13:  		/* add R10, R10, R27 */
		/* 8208B664h case   13:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R27);
		/* 8208B664h case   13:*/		return 0x8208B668;
		  /* 8208B668h */ case   14:  		/* sth R11, <#[R10 + 2]> */
		/* 8208B668h case   14:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000002) );
		/* 8208B668h case   14:*/		return 0x8208B66C;
		  /* 8208B66Ch */ case   15:  		/* b 744 */
		/* 8208B66Ch case   15:*/		return 0x8208B954;
		/* 8208B66Ch case   15:*/		return 0x8208B670;
	}
	return 0x8208B670;
} // Block from 8208B630h-8208B670h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8208B670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B670);
		  /* 8208B670h */ case    0:  		/* lbz R11, <#[R27 + 4]> */
		/* 8208B670h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 8208B670h case    0:*/		return 0x8208B674;
		  /* 8208B674h */ case    1:  		/* addi R11, R11, 24 */
		/* 8208B674h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 8208B674h case    1:*/		return 0x8208B678;
		  /* 8208B678h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8208B678h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8208B678h case    2:*/		return 0x8208B67C;
		  /* 8208B67Ch */ case    3:  		/* lwzx R11, <#[R11 + R30]> */
		/* 8208B67Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8208B67Ch case    3:*/		return 0x8208B680;
		  /* 8208B680h */ case    4:  		/* stw R27, <#[R11 + 64]> */
		/* 8208B680h case    4:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000040) );
		/* 8208B680h case    4:*/		return 0x8208B684;
		  /* 8208B684h */ case    5:  		/* b 720 */
		/* 8208B684h case    5:*/		return 0x8208B954;
		/* 8208B684h case    5:*/		return 0x8208B688;
	}
	return 0x8208B688;
} // Block from 8208B670h-8208B688h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208B688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B688);
		  /* 8208B688h */ case    0:  		/* rlwinm R11, R29, 4, 0, 27 */
		/* 8208B688h case    0:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R29);
		/* 8208B688h case    0:*/		return 0x8208B68C;
		  /* 8208B68Ch */ case    1:  		/* rlwinm R9, R29, 0, 16, 31 */
		/* 8208B68Ch case    1:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R29);
		/* 8208B68Ch case    1:*/		return 0x8208B690;
		  /* 8208B690h */ case    2:  		/* add R31, R11, R27 */
		/* 8208B690h case    2:*/		cpu::op::add<0>(regs,&regs.R31,regs.R11,regs.R27);
		/* 8208B690h case    2:*/		return 0x8208B694;
		  /* 8208B694h */ case    3:  		/* subf R10, R23, R11 */
		/* 8208B694h case    3:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R23,regs.R11);
		/* 8208B694h case    3:*/		return 0x8208B698;
		  /* 8208B698h */ case    4:  		/* sth R9, <#[R27]> */
		/* 8208B698h case    4:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R27 + 0x00000000) );
		/* 8208B698h case    4:*/		return 0x8208B69C;
		  /* 8208B69Ch */ case    5:  		/* rlwinm. R8, R28, 0, 27, 27 */
		/* 8208B69Ch case    5:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R8,regs.R28);
		/* 8208B69Ch case    5:*/		return 0x8208B6A0;
		  /* 8208B6A0h */ case    6:  		/* stb R10, <#[R27 + 6]> */
		/* 8208B6A0h case    6:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R27 + 0x00000006) );
		/* 8208B6A0h case    6:*/		return 0x8208B6A4;
		  /* 8208B6A4h */ case    7:  		/* rlwinm R10, R28, 0, 24, 31 */
		/* 8208B6A4h case    7:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R28);
		/* 8208B6A4h case    7:*/		return 0x8208B6A8;
		  /* 8208B6A8h */ case    8:  		/* sth R9, <#[R31 + 2]> */
		/* 8208B6A8h case    8:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R31 + 0x00000002) );
		/* 8208B6A8h case    8:*/		return 0x8208B6AC;
		  /* 8208B6ACh */ case    9:  		/* lbz R11, <#[R27 + 4]> */
		/* 8208B6ACh case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 8208B6ACh case    9:*/		return 0x8208B6B0;
	}
	return 0x8208B6B0;
} // Block from 8208B688h-8208B6B0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8208B6B0h
// Function 'QueryPerformanceCounter'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B6B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B6B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B6B0);
		  /* 8208B6B0h */ case    0:  		/* stb R11, <#[R31 + 4]> */
		/* 8208B6B0h case    0:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8208B6B0h case    0:*/		return 0x8208B6B4;
		  /* 8208B6B4h */ case    1:  		/* bc 12, CR0_EQ, 100 */
		/* 8208B6B4h case    1:*/		if ( regs.CR[0].eq ) { return 0x8208B718;  }
		/* 8208B6B4h case    1:*/		return 0x8208B6B8;
		  /* 8208B6B8h */ case    2:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 8208B6B8h case    2:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8208B6B8h case    2:*/		return 0x8208B6BC;
		  /* 8208B6BCh */ case    3:  		/* rlwinm R10, R10, 0, 24, 28 */
		/* 8208B6BCh case    3:*/		cpu::op::rlwinm<0,0,24,28>(regs,&regs.R10,regs.R10);
		/* 8208B6BCh case    3:*/		return 0x8208B6C0;
		  /* 8208B6C0h */ case    4:  		/* addi R11, R11, 24 */
		/* 8208B6C0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 8208B6C0h case    4:*/		return 0x8208B6C4;
		  /* 8208B6C4h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8208B6C4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8208B6C4h case    5:*/		return 0x8208B6C8;
		  /* 8208B6C8h */ case    6:  		/* lwzx R11, <#[R11 + R30]> */
		/* 8208B6C8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8208B6C8h case    6:*/		return 0x8208B6CC;
		  /* 8208B6CCh */ case    7:  		/* stw R31, <#[R11 + 64]> */
		/* 8208B6CCh case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000040) );
		/* 8208B6CCh case    7:*/		return 0x8208B6D0;
	}
	return 0x8208B6D0;
} // Block from 8208B6B0h-8208B6D0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8208B6D0h
// Function 'QueryPerformanceFrequency'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B6D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B6D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B6D0);
		  /* 8208B6D0h */ case    0:  		/* stb R28, <#[R31 + 5]> */
		/* 8208B6D0h case    0:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R31 + 0x00000005) );
		/* 8208B6D0h case    0:*/		return 0x8208B6D4;
		  /* 8208B6D4h */ case    1:  		/* lwz R11, <#[R1 + 80]> */
		/* 8208B6D4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B6D4h case    1:*/		return 0x8208B6D8;
		  /* 8208B6D8h */ case    2:  		/* stb R10, <#[R31 + 5]> */
		/* 8208B6D8h case    2:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x00000005) );
		/* 8208B6D8h case    2:*/		return 0x8208B6DC;
		  /* 8208B6DCh */ case    3:  		/* sth R11, <#[R31]> */
		/* 8208B6DCh case    3:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8208B6DCh case    3:*/		return 0x8208B6E0;
		  /* 8208B6E0h */ case    4:  		/* lwz R11, <#[R1 + 80]> */
		/* 8208B6E0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B6E0h case    4:*/		return 0x8208B6E4;
		  /* 8208B6E4h */ case    5:  		/* rlwinm R10, R11, 0, 16, 31 */
		/* 8208B6E4h case    5:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R11);
		/* 8208B6E4h case    5:*/		return 0x8208B6E8;
		  /* 8208B6E8h */ case    6:  		/* cmplwi CR6, R10, 128 */
		/* 8208B6E8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000080);
		/* 8208B6E8h case    6:*/		return 0x8208B6EC;
		  /* 8208B6ECh */ case    7:  		/* bc 12, CR6_LT, 128 */
		/* 8208B6ECh case    7:*/		if ( regs.CR[6].lt ) { return 0x8208B76C;  }
		/* 8208B6ECh case    7:*/		return 0x8208B6F0;
		  /* 8208B6F0h */ case    8:  		/* lwz R11, <#[R30 + 384]> */
		/* 8208B6F0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000180) );
		/* 8208B6F0h case    8:*/		return 0x8208B6F4;
		  /* 8208B6F4h */ case    9:  		/* addi R9, R30, 384 */
		/* 8208B6F4h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0x180);
		/* 8208B6F4h case    9:*/		return 0x8208B6F8;
		  /* 8208B6F8h */ case   10:  		/* b 20 */
		/* 8208B6F8h case   10:*/		return 0x8208B70C;
		/* 8208B6F8h case   10:*/		return 0x8208B6FC;
		  /* 8208B6FCh */ case   11:  		/* lhz R8, <#[R11 - 8]> */
		/* 8208B6FCh case   11:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 8208B6FCh case   11:*/		return 0x8208B700;
		  /* 8208B700h */ case   12:  		/* cmplw CR6, R10, R8 */
		/* 8208B700h case   12:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8208B700h case   12:*/		return 0x8208B704;
		  /* 8208B704h */ case   13:  		/* bc 4, CR6_GT, 536 */
		/* 8208B704h case   13:*/		if ( !regs.CR[6].gt ) { return 0x8208B91C;  }
		/* 8208B704h case   13:*/		return 0x8208B708;
	}
	return 0x8208B708;
} // Block from 8208B6D0h-8208B708h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8208B708h
// Function 'XapiShowErrorAndWait'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B708);
		  /* 8208B708h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 8208B708h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8208B708h case    0:*/		return 0x8208B70C;
	}
	return 0x8208B70C;
} // Block from 8208B708h-8208B70Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208B70Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B70C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B70C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B70C);
		  /* 8208B70Ch */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 8208B70Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8208B70Ch case    0:*/		return 0x8208B710;
		  /* 8208B710h */ case    1:  		/* bc 4, CR6_EQ, -20 */
		/* 8208B710h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8208B6FC;  }
		/* 8208B710h case    1:*/		return 0x8208B714;
		  /* 8208B714h */ case    2:  		/* b 520 */
		/* 8208B714h case    2:*/		return 0x8208B91C;
		/* 8208B714h case    2:*/		return 0x8208B718;
	}
	return 0x8208B718;
} // Block from 8208B70Ch-8208B718h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208B718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B718);
		  /* 8208B718h */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 8208B718h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B718h case    0:*/		return 0x8208B71C;
		  /* 8208B71Ch */ case    1:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 8208B71Ch case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 8208B71Ch case    1:*/		return 0x8208B720;
		  /* 8208B720h */ case    2:  		/* add R29, R11, R31 */
		/* 8208B720h case    2:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R31);
		/* 8208B720h case    2:*/		return 0x8208B724;
		  /* 8208B724h */ case    3:  		/* lbz R28, <#[R29 + 5]> */
		/* 8208B724h case    3:*/		cpu::mem::load8z( regs, &regs.R28, (uint32)(regs.R29 + 0x00000005) );
		/* 8208B724h case    3:*/		return 0x8208B728;
		  /* 8208B728h */ case    4:  		/* rlwinm. R11, R28, 0, 31, 31 */
		/* 8208B728h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R28);
		/* 8208B728h case    4:*/		return 0x8208B72C;
		  /* 8208B72Ch */ case    5:  		/* bc 12, CR0_EQ, 112 */
		/* 8208B72Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x8208B79C;  }
		/* 8208B72Ch case    5:*/		return 0x8208B730;
		  /* 8208B730h */ case    6:  		/* andi. R11, R10, 239 */
		/* 8208B730h case    6:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R10,0xEF);
		/* 8208B730h case    6:*/		return 0x8208B734;
		  /* 8208B734h */ case    7:  		/* stb R11, <#[R31 + 5]> */
		/* 8208B734h case    7:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000005) );
		/* 8208B734h case    7:*/		return 0x8208B738;
		  /* 8208B738h */ case    8:  		/* lwz R11, <#[R1 + 80]> */
		/* 8208B738h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B738h case    8:*/		return 0x8208B73C;
		  /* 8208B73Ch */ case    9:  		/* sth R11, <#[R31]> */
		/* 8208B73Ch case    9:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8208B73Ch case    9:*/		return 0x8208B740;
		  /* 8208B740h */ case   10:  		/* lwz R11, <#[R1 + 80]> */
		/* 8208B740h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B740h case   10:*/		return 0x8208B744;
		  /* 8208B744h */ case   11:  		/* rlwinm R10, R11, 4, 0, 27 */
		/* 8208B744h case   11:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R11);
		/* 8208B744h case   11:*/		return 0x8208B748;
		  /* 8208B748h */ case   12:  		/* add R10, R10, R31 */
		/* 8208B748h case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R31);
		/* 8208B748h case   12:*/		return 0x8208B74C;
		  /* 8208B74Ch */ case   13:  		/* sth R11, <#[R10 + 2]> */
		/* 8208B74Ch case   13:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000002) );
		/* 8208B74Ch case   13:*/		return 0x8208B750;
		  /* 8208B750h */ case   14:  		/* lbz R11, <#[R31 + 5]> */
		/* 8208B750h case   14:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000005) );
		/* 8208B750h case   14:*/		return 0x8208B754;
		  /* 8208B754h */ case   15:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 8208B754h case   15:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 8208B754h case   15:*/		return 0x8208B758;
		  /* 8208B758h */ case   16:  		/* stb R11, <#[R31 + 5]> */
		/* 8208B758h case   16:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000005) );
		/* 8208B758h case   16:*/		return 0x8208B75C;
		  /* 8208B75Ch */ case   17:  		/* lwz R11, <#[R1 + 80]> */
		/* 8208B75Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B75Ch case   17:*/		return 0x8208B760;
		  /* 8208B760h */ case   18:  		/* rlwinm R10, R11, 0, 16, 31 */
		/* 8208B760h case   18:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R11);
		/* 8208B760h case   18:*/		return 0x8208B764;
		  /* 8208B764h */ case   19:  		/* cmplwi CR6, R10, 128 */
		/* 8208B764h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000080);
		/* 8208B764h case   19:*/		return 0x8208B768;
		  /* 8208B768h */ case   20:  		/* bc 4, CR6_LT, 12 */
		/* 8208B768h case   20:*/		if ( !regs.CR[6].lt ) { return 0x8208B774;  }
		/* 8208B768h case   20:*/		return 0x8208B76C;
	}
	return 0x8208B76C;
} // Block from 8208B718h-8208B76Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8208B76Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B76C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B76C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B76C);
		  /* 8208B76Ch */ case    0:  		/* addi R11, R10, 48 */
		/* 8208B76Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x30);
		/* 8208B76Ch case    0:*/		return 0x8208B770;
		  /* 8208B770h */ case    1:  		/* b 332 */
		/* 8208B770h case    1:*/		return 0x8208B8BC;
		/* 8208B770h case    1:*/		return 0x8208B774;
	}
	return 0x8208B774;
} // Block from 8208B76Ch-8208B774h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208B774h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B774( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B774) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B774);
		  /* 8208B774h */ case    0:  		/* lwz R11, <#[R30 + 384]> */
		/* 8208B774h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000180) );
		/* 8208B774h case    0:*/		return 0x8208B778;
		  /* 8208B778h */ case    1:  		/* addi R9, R30, 384 */
		/* 8208B778h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0x180);
		/* 8208B778h case    1:*/		return 0x8208B77C;
		  /* 8208B77Ch */ case    2:  		/* b 20 */
		/* 8208B77Ch case    2:*/		return 0x8208B790;
		/* 8208B77Ch case    2:*/		return 0x8208B780;
		  /* 8208B780h */ case    3:  		/* lhz R8, <#[R11 - 8]> */
		/* 8208B780h case    3:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 8208B780h case    3:*/		return 0x8208B784;
		  /* 8208B784h */ case    4:  		/* cmplw CR6, R10, R8 */
		/* 8208B784h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8208B784h case    4:*/		return 0x8208B788;
		  /* 8208B788h */ case    5:  		/* bc 4, CR6_GT, 404 */
		/* 8208B788h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8208B91C;  }
		/* 8208B788h case    5:*/		return 0x8208B78C;
		  /* 8208B78Ch */ case    6:  		/* lwz R11, <#[R11]> */
		/* 8208B78Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8208B78Ch case    6:*/		return 0x8208B790;
	}
	return 0x8208B790;
} // Block from 8208B774h-8208B790h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208B790h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B790);
		  /* 8208B790h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 8208B790h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8208B790h case    0:*/		return 0x8208B794;
		  /* 8208B794h */ case    1:  		/* bc 4, CR6_EQ, -20 */
		/* 8208B794h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8208B780;  }
		/* 8208B794h case    1:*/		return 0x8208B798;
		  /* 8208B798h */ case    2:  		/* b 388 */
		/* 8208B798h case    2:*/		return 0x8208B91C;
		/* 8208B798h case    2:*/		return 0x8208B79C;
	}
	return 0x8208B79C;
} // Block from 8208B790h-8208B79Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208B79Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B79C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B79C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B79C);
		  /* 8208B79Ch */ case    0:  		/* lwz R11, <#[R29 + 12]> */
		/* 8208B79Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 8208B79Ch case    0:*/		return 0x8208B7A0;
		  /* 8208B7A0h */ case    1:  		/* addi R9, R29, 8 */
		/* 8208B7A0h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R29,0x8);
		/* 8208B7A0h case    1:*/		return 0x8208B7A4;
		  /* 8208B7A4h */ case    2:  		/* lwz R10, <#[R29 + 8]> */
		/* 8208B7A4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 8208B7A4h case    2:*/		return 0x8208B7A8;
		  /* 8208B7A8h */ case    3:  		/* lwz R8, <#[R11]> */
		/* 8208B7A8h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8208B7A8h case    3:*/		return 0x8208B7AC;
		  /* 8208B7ACh */ case    4:  		/* lwz R7, <#[R10 + 4]> */
		/* 8208B7ACh case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 8208B7ACh case    4:*/		return 0x8208B7B0;
		  /* 8208B7B0h */ case    5:  		/* cmplw CR6, R8, R7 */
		/* 8208B7B0h case    5:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 8208B7B0h case    5:*/		return 0x8208B7B4;
		  /* 8208B7B4h */ case    6:  		/* bc 4, CR6_EQ, 72 */
		/* 8208B7B4h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8208B7FC;  }
		/* 8208B7B4h case    6:*/		return 0x8208B7B8;
		  /* 8208B7B8h */ case    7:  		/* cmplw CR6, R8, R9 */
		/* 8208B7B8h case    7:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8208B7B8h case    7:*/		return 0x8208B7BC;
		  /* 8208B7BCh */ case    8:  		/* bc 4, CR6_EQ, 64 */
		/* 8208B7BCh case    8:*/		if ( !regs.CR[6].eq ) { return 0x8208B7FC;  }
		/* 8208B7BCh case    8:*/		return 0x8208B7C0;
	}
	return 0x8208B7C0;
} // Block from 8208B79Ch-8208B7C0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8208B7C0h
// Function 'XapiLookupString'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B7C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B7C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B7C0);
		  /* 8208B7C0h */ case    0:  		/* stw R10, <#[R11]> */
		/* 8208B7C0h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208B7C0h case    0:*/		return 0x8208B7C4;
		  /* 8208B7C4h */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 8208B7C4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208B7C4h case    1:*/		return 0x8208B7C8;
		  /* 8208B7C8h */ case    2:  		/* stw R11, <#[R10 + 4]> */
		/* 8208B7C8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8208B7C8h case    2:*/		return 0x8208B7CC;
		  /* 8208B7CCh */ case    3:  		/* bc 4, CR6_EQ, 48 */
		/* 8208B7CCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x8208B7FC;  }
		/* 8208B7CCh case    3:*/		return 0x8208B7D0;
		  /* 8208B7D0h */ case    4:  		/* lhz R11, <#[R29]> */
		/* 8208B7D0h case    4:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8208B7D0h case    4:*/		return 0x8208B7D4;
		  /* 8208B7D4h */ case    5:  		/* cmplwi CR6, R11, 128 */
		/* 8208B7D4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 8208B7D4h case    5:*/		return 0x8208B7D8;
		  /* 8208B7D8h */ case    6:  		/* bc 4, CR6_LT, 36 */
		/* 8208B7D8h case    6:*/		if ( !regs.CR[6].lt ) { return 0x8208B7FC;  }
		/* 8208B7D8h case    6:*/		return 0x8208B7DC;
		  /* 8208B7DCh */ case    7:  		/* rlwinm R10, R11, 27, 5, 31 */
		/* 8208B7DCh case    7:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R11);
		/* 8208B7DCh case    7:*/		return 0x8208B7E0;
		  /* 8208B7E0h */ case    8:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8208B7E0h case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8208B7E0h case    8:*/		return 0x8208B7E4;
		  /* 8208B7E4h */ case    9:  		/* addi R10, R10, 88 */
		/* 8208B7E4h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x58);
		/* 8208B7E4h case    9:*/		return 0x8208B7E8;
		  /* 8208B7E8h */ case   10:  		/* slw R9, R25, R11 */
		/* 8208B7E8h case   10:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R25,regs.R11);
		/* 8208B7E8h case   10:*/		return 0x8208B7EC;
		  /* 8208B7ECh */ case   11:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 8208B7ECh case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 8208B7ECh case   11:*/		return 0x8208B7F0;
		  /* 8208B7F0h */ case   12:  		/* lwzx R10, <#[R11 + R30]> */
		/* 8208B7F0h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8208B7F0h case   12:*/		return 0x8208B7F4;
		  /* 8208B7F4h */ case   13:  		/* xor R10, R9, R10 */
		/* 8208B7F4h case   13:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8208B7F4h case   13:*/		return 0x8208B7F8;
		  /* 8208B7F8h */ case   14:  		/* stwx R10, <#[R11 + R30]> */
		/* 8208B7F8h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8208B7F8h case   14:*/		return 0x8208B7FC;
	}
	return 0x8208B7FC;
} // Block from 8208B7C0h-8208B7FCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 8208B7FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B7FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B7FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B7FC);
		  /* 8208B7FCh */ case    0:  		/* lbz R11, <#[R29 + 5]> */
		/* 8208B7FCh case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000005) );
		/* 8208B7FCh case    0:*/		return 0x8208B800;
		  /* 8208B800h */ case    1:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 8208B800h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 8208B800h case    1:*/		return 0x8208B804;
		  /* 8208B804h */ case    2:  		/* bc 12, CR0_EQ, 52 */
		/* 8208B804h case    2:*/		if ( regs.CR[0].eq ) { return 0x8208B838;  }
		/* 8208B804h case    2:*/		return 0x8208B808;
		  /* 8208B808h */ case    3:  		/* lhz R10, <#[R29]> */
		/* 8208B808h case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 8208B808h case    3:*/		return 0x8208B80C;
		  /* 8208B80Ch */ case    4:  		/* rlwinm. R9, R11, 0, 30, 30 */
		/* 8208B80Ch case    4:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R11);
		/* 8208B80Ch case    4:*/		return 0x8208B810;
		  /* 8208B810h */ case    5:  		/* rlwinm R11, R10, 4, 0, 31 */
		/* 8208B810h case    5:*/		cpu::op::rlwinm<0,4,0,31>(regs,&regs.R11,regs.R10);
		/* 8208B810h case    5:*/		return 0x8208B814;
		  /* 8208B814h */ case    6:  		/* addi R4, R11, -24 */
		/* 8208B814h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFE8);
		/* 8208B814h case    6:*/		return 0x8208B818;
		  /* 8208B818h */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 8208B818h case    7:*/		if ( regs.CR[0].eq ) { return 0x8208B828;  }
		/* 8208B818h case    7:*/		return 0x8208B81C;
		  /* 8208B81Ch */ case    8:  		/* cmplwi CR6, R4, 4 */
		/* 8208B81Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000004);
		/* 8208B81Ch case    8:*/		return 0x8208B820;
		  /* 8208B820h */ case    9:  		/* bc 4, CR6_GT, 8 */
		/* 8208B820h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8208B828;  }
		/* 8208B820h case    9:*/		return 0x8208B824;
		  /* 8208B824h */ case   10:  		/* addi R4, R4, -4 */
		/* 8208B824h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFFFC);
		/* 8208B824h case   10:*/		return 0x8208B828;
	}
	return 0x8208B828;
} // Block from 8208B7FCh-8208B828h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8208B828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B828);
		  /* 8208B828h */ case    0:  		/* lis R5, -274 */
		/* 8208B828h case    0:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFFFEEE);
		/* 8208B828h case    0:*/		return 0x8208B82C;
		  /* 8208B82Ch */ case    1:  		/* addi R3, R29, 24 */
		/* 8208B82Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R29,0x18);
		/* 8208B82Ch case    1:*/		return 0x8208B830;
		  /* 8208B830h */ case    2:  		/* ori R5, R5, 65262 */
		/* 8208B830h case    2:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0xFEEE);
		/* 8208B830h case    2:*/		return 0x8208B834;
		  /* 8208B834h */ case    3:  		/* bl 1973300 */
		/* 8208B834h case    3:*/		regs.LR = 0x8208B838; return 0x8226D468;
		/* 8208B834h case    3:*/		return 0x8208B838;
	}
	return 0x8208B838;
} // Block from 8208B828h-8208B838h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208B838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B838);
		  /* 8208B838h */ case    0:  		/* lhz R11, <#[R29]> */
		/* 8208B838h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8208B838h case    0:*/		return 0x8208B83C;
		  /* 8208B83Ch */ case    1:  		/* lwz R10, <#[R30 + 48]> */
		/* 8208B83Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000030) );
		/* 8208B83Ch case    1:*/		return 0x8208B840;
	}
	return 0x8208B840;
} // Block from 8208B838h-8208B840h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208B840h
// Function 'XapiPAL50Incompatible'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B840);
		  /* 8208B840h */ case    0:  		/* lwz R9, <#[R1 + 80]> */
		/* 8208B840h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B840h case    0:*/		return 0x8208B844;
		  /* 8208B844h */ case    1:  		/* subf R11, R11, R10 */
		/* 8208B844h case    1:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8208B844h case    1:*/		return 0x8208B848;
		  /* 8208B848h */ case    2:  		/* stw R11, <#[R30 + 48]> */
		/* 8208B848h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 8208B848h case    2:*/		return 0x8208B84C;
		  /* 8208B84Ch */ case    3:  		/* lhz R11, <#[R29]> */
		/* 8208B84Ch case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8208B84Ch case    3:*/		return 0x8208B850;
		  /* 8208B850h */ case    4:  		/* add R11, R11, R9 */
		/* 8208B850h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8208B850h case    4:*/		return 0x8208B854;
		  /* 8208B854h */ case    5:  		/* stw R11, <#[R1 + 80]> */
		/* 8208B854h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B854h case    5:*/		return 0x8208B858;
		  /* 8208B858h */ case    6:  		/* stb R28, <#[R31 + 5]> */
		/* 8208B858h case    6:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R31 + 0x00000005) );
		/* 8208B858h case    6:*/		return 0x8208B85C;
		  /* 8208B85Ch */ case    7:  		/* lwz R5, <#[R1 + 80]> */
		/* 8208B85Ch case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B85Ch case    7:*/		return 0x8208B860;
		  /* 8208B860h */ case    8:  		/* cmplwi CR6, R5, 61440 */
		/* 8208B860h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x0000F000);
		/* 8208B860h case    8:*/		return 0x8208B864;
		  /* 8208B864h */ case    9:  		/* bc 12, CR6_GT, 228 */
		/* 8208B864h case    9:*/		if ( regs.CR[6].gt ) { return 0x8208B948;  }
		/* 8208B864h case    9:*/		return 0x8208B868;
		  /* 8208B868h */ case   10:  		/* rlwinm. R10, R28, 0, 27, 27 */
		/* 8208B868h case   10:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R28);
		/* 8208B868h case   10:*/		return 0x8208B86C;
		  /* 8208B86Ch */ case   11:  		/* sth R5, <#[R31]> */
		/* 8208B86Ch case   11:*/		cpu::mem::store16( regs, regs.R5, (uint32)(regs.R31 + 0x00000000) );
		/* 8208B86Ch case   11:*/		return 0x8208B870;
		  /* 8208B870h */ case   12:  		/* bc 4, CR0_EQ, 24 */
		/* 8208B870h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8208B888;  }
		/* 8208B870h case   12:*/		return 0x8208B874;
		  /* 8208B874h */ case   13:  		/* lwz R11, <#[R1 + 80]> */
		/* 8208B874h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B874h case   13:*/		return 0x8208B878;
		  /* 8208B878h */ case   14:  		/* rlwinm R10, R11, 4, 0, 27 */
		/* 8208B878h case   14:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R11);
		/* 8208B878h case   14:*/		return 0x8208B87C;
		  /* 8208B87Ch */ case   15:  		/* add R10, R10, R31 */
		/* 8208B87Ch case   15:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R31);
		/* 8208B87Ch case   15:*/		return 0x8208B880;
		  /* 8208B880h */ case   16:  		/* sth R11, <#[R10 + 2]> */
		/* 8208B880h case   16:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000002) );
		/* 8208B880h case   16:*/		return 0x8208B884;
		  /* 8208B884h */ case   17:  		/* b 24 */
		/* 8208B884h case   17:*/		return 0x8208B89C;
		/* 8208B884h case   17:*/		return 0x8208B888;
	}
	return 0x8208B888;
} // Block from 8208B840h-8208B888h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8208B888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B888);
		  /* 8208B888h */ case    0:  		/* lbz R11, <#[R31 + 4]> */
		/* 8208B888h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8208B888h case    0:*/		return 0x8208B88C;
		  /* 8208B88Ch */ case    1:  		/* addi R11, R11, 24 */
		/* 8208B88Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 8208B88Ch case    1:*/		return 0x8208B890;
		  /* 8208B890h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8208B890h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8208B890h case    2:*/		return 0x8208B894;
		  /* 8208B894h */ case    3:  		/* lwzx R11, <#[R11 + R30]> */
		/* 8208B894h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8208B894h case    3:*/		return 0x8208B898;
		  /* 8208B898h */ case    4:  		/* stw R31, <#[R11 + 64]> */
		/* 8208B898h case    4:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000040) );
		/* 8208B898h case    4:*/		return 0x8208B89C;
	}
	return 0x8208B89C;
} // Block from 8208B888h-8208B89Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208B89Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B89C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B89C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B89C);
		  /* 8208B89Ch */ case    0:  		/* lbz R11, <#[R31 + 5]> */
		/* 8208B89Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000005) );
		/* 8208B89Ch case    0:*/		return 0x8208B8A0;
		  /* 8208B8A0h */ case    1:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 8208B8A0h case    1:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 8208B8A0h case    1:*/		return 0x8208B8A4;
		  /* 8208B8A4h */ case    2:  		/* stb R11, <#[R31 + 5]> */
		/* 8208B8A4h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000005) );
		/* 8208B8A4h case    2:*/		return 0x8208B8A8;
		  /* 8208B8A8h */ case    3:  		/* lwz R11, <#[R1 + 80]> */
		/* 8208B8A8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B8A8h case    3:*/		return 0x8208B8AC;
		  /* 8208B8ACh */ case    4:  		/* rlwinm R9, R11, 0, 16, 31 */
		/* 8208B8ACh case    4:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R11);
		/* 8208B8ACh case    4:*/		return 0x8208B8B0;
		  /* 8208B8B0h */ case    5:  		/* cmplwi CR6, R9, 128 */
		/* 8208B8B0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000080);
		/* 8208B8B0h case    5:*/		return 0x8208B8B4;
		  /* 8208B8B4h */ case    6:  		/* bc 4, CR6_LT, 68 */
		/* 8208B8B4h case    6:*/		if ( !regs.CR[6].lt ) { return 0x8208B8F8;  }
		/* 8208B8B4h case    6:*/		return 0x8208B8B8;
		  /* 8208B8B8h */ case    7:  		/* addi R11, R9, 48 */
		/* 8208B8B8h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x30);
		/* 8208B8B8h case    7:*/		return 0x8208B8BC;
	}
	return 0x8208B8BC;
} // Block from 8208B89Ch-8208B8BCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 8208B8BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B8BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B8BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B8BC);
		  /* 8208B8BCh */ case    0:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8208B8BCh case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8208B8BCh case    0:*/		return 0x8208B8C0;
		  /* 8208B8C0h */ case    1:  		/* add R11, R11, R30 */
		/* 8208B8C0h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8208B8C0h case    1:*/		return 0x8208B8C4;
		  /* 8208B8C4h */ case    2:  		/* lwz R10, <#[R11]> */
		/* 8208B8C4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208B8C4h case    2:*/		return 0x8208B8C8;
		  /* 8208B8C8h */ case    3:  		/* cmplw CR6, R10, R11 */
		/* 8208B8C8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208B8C8h case    3:*/		return 0x8208B8CC;
		  /* 8208B8CCh */ case    4:  		/* bc 4, CR6_EQ, 80 */
		/* 8208B8CCh case    4:*/		if ( !regs.CR[6].eq ) { return 0x8208B91C;  }
		/* 8208B8CCh case    4:*/		return 0x8208B8D0;
		  /* 8208B8D0h */ case    5:  		/* lhz R9, <#[R31]> */
		/* 8208B8D0h case    5:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8208B8D0h case    5:*/		return 0x8208B8D4;
		  /* 8208B8D4h */ case    6:  		/* rlwinm R10, R9, 27, 5, 31 */
		/* 8208B8D4h case    6:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R9);
		/* 8208B8D4h case    6:*/		return 0x8208B8D8;
		  /* 8208B8D8h */ case    7:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 8208B8D8h case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8208B8D8h case    7:*/		return 0x8208B8DC;
		  /* 8208B8DCh */ case    8:  		/* addi R10, R10, 88 */
		/* 8208B8DCh case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x58);
		/* 8208B8DCh case    8:*/		return 0x8208B8E0;
		  /* 8208B8E0h */ case    9:  		/* slw R9, R25, R9 */
		/* 8208B8E0h case    9:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R25,regs.R9);
		/* 8208B8E0h case    9:*/		return 0x8208B8E4;
		  /* 8208B8E4h */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8208B8E4h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8208B8E4h case   10:*/		return 0x8208B8E8;
		  /* 8208B8E8h */ case   11:  		/* lwzx R8, <#[R10 + R30]> */
		/* 8208B8E8h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 8208B8E8h case   11:*/		return 0x8208B8EC;
		  /* 8208B8ECh */ case   12:  		/* or R9, R9, R8 */
		/* 8208B8ECh case   12:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8208B8ECh case   12:*/		return 0x8208B8F0;
		  /* 8208B8F0h */ case   13:  		/* stwx R9, <#[R10 + R30]> */
		/* 8208B8F0h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 8208B8F0h case   13:*/		return 0x8208B8F4;
		  /* 8208B8F4h */ case   14:  		/* b 40 */
		/* 8208B8F4h case   14:*/		return 0x8208B91C;
		/* 8208B8F4h case   14:*/		return 0x8208B8F8;
	}
	return 0x8208B8F8;
} // Block from 8208B8BCh-8208B8F8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8208B8F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B8F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B8F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B8F8);
		  /* 8208B8F8h */ case    0:  		/* lwz R11, <#[R30 + 384]> */
		/* 8208B8F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000180) );
		/* 8208B8F8h case    0:*/		return 0x8208B8FC;
		  /* 8208B8FCh */ case    1:  		/* addi R10, R30, 384 */
		/* 8208B8FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x180);
		/* 8208B8FCh case    1:*/		return 0x8208B900;
		  /* 8208B900h */ case    2:  		/* b 20 */
		/* 8208B900h case    2:*/		return 0x8208B914;
		/* 8208B900h case    2:*/		return 0x8208B904;
		  /* 8208B904h */ case    3:  		/* lhz R8, <#[R11 - 8]> */
		/* 8208B904h case    3:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 8208B904h case    3:*/		return 0x8208B908;
		  /* 8208B908h */ case    4:  		/* cmplw CR6, R9, R8 */
		/* 8208B908h case    4:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 8208B908h case    4:*/		return 0x8208B90C;
		  /* 8208B90Ch */ case    5:  		/* bc 4, CR6_GT, 16 */
		/* 8208B90Ch case    5:*/		if ( !regs.CR[6].gt ) { return 0x8208B91C;  }
		/* 8208B90Ch case    5:*/		return 0x8208B910;
		  /* 8208B910h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 8208B910h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8208B910h case    6:*/		return 0x8208B914;
	}
	return 0x8208B914;
} // Block from 8208B8F8h-8208B914h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208B914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B914);
		  /* 8208B914h */ case    0:  		/* cmplw CR6, R10, R11 */
		/* 8208B914h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208B914h case    0:*/		return 0x8208B918;
		  /* 8208B918h */ case    1:  		/* bc 4, CR6_EQ, -20 */
		/* 8208B918h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8208B904;  }
		/* 8208B918h case    1:*/		return 0x8208B91C;
	}
	return 0x8208B91C;
} // Block from 8208B914h-8208B91Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208B91Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B91C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B91C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B91C);
		  /* 8208B91Ch */ case    0:  		/* lwz R9, <#[R11 + 4]> */
		/* 8208B91Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8208B91Ch case    0:*/		return 0x8208B920;
		  /* 8208B920h */ case    1:  		/* addi R10, R31, 8 */
		/* 8208B920h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x8);
		/* 8208B920h case    1:*/		return 0x8208B924;
		  /* 8208B924h */ case    2:  		/* stw R11, <#[R31 + 8]> */
		/* 8208B924h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8208B924h case    2:*/		return 0x8208B928;
		  /* 8208B928h */ case    3:  		/* stw R9, <#[R31 + 12]> */
		/* 8208B928h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 8208B928h case    3:*/		return 0x8208B92C;
		  /* 8208B92Ch */ case    4:  		/* stw R10, <#[R9]> */
		/* 8208B92Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8208B92Ch case    4:*/		return 0x8208B930;
		  /* 8208B930h */ case    5:  		/* stw R10, <#[R11 + 4]> */
		/* 8208B930h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8208B930h case    5:*/		return 0x8208B934;
		  /* 8208B934h */ case    6:  		/* lwz R10, <#[R1 + 80]> */
		/* 8208B934h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8208B934h case    6:*/		return 0x8208B938;
		  /* 8208B938h */ case    7:  		/* lwz R11, <#[R30 + 48]> */
		/* 8208B938h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 8208B938h case    7:*/		return 0x8208B93C;
		  /* 8208B93Ch */ case    8:  		/* add R11, R11, R10 */
		/* 8208B93Ch case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8208B93Ch case    8:*/		return 0x8208B940;
		  /* 8208B940h */ case    9:  		/* stw R11, <#[R30 + 48]> */
		/* 8208B940h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 8208B940h case    9:*/		return 0x8208B944;
		  /* 8208B944h */ case   10:  		/* b 16 */
		/* 8208B944h case   10:*/		return 0x8208B954;
		/* 8208B944h case   10:*/		return 0x8208B948;
	}
	return 0x8208B948;
} // Block from 8208B91Ch-8208B948h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8208B948h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B948( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B948) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B948);
		  /* 8208B948h */ case    0:  		/* mr R4, R31 */
		/* 8208B948h case    0:*/		regs.R4 = regs.R31;
		/* 8208B948h case    0:*/		return 0x8208B94C;
		  /* 8208B94Ch */ case    1:  		/* mr R3, R30 */
		/* 8208B94Ch case    1:*/		regs.R3 = regs.R30;
		/* 8208B94Ch case    1:*/		return 0x8208B950;
		  /* 8208B950h */ case    2:  		/* bl -1656 */
		/* 8208B950h case    2:*/		regs.LR = 0x8208B954; return 0x8208B2D8;
		/* 8208B950h case    2:*/		return 0x8208B954;
	}
	return 0x8208B954;
} // Block from 8208B948h-8208B954h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208B954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B954);
		  /* 8208B954h */ case    0:  		/* rlwinm. R11, R22, 0, 28, 28 */
		/* 8208B954h case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R22);
		/* 8208B954h case    0:*/		return 0x8208B958;
		  /* 8208B958h */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 8208B958h case    1:*/		if ( regs.CR[0].eq ) { return 0x8208B978;  }
		/* 8208B958h case    1:*/		return 0x8208B95C;
		  /* 8208B95Ch */ case    2:  		/* cmplw CR6, R23, R24 */
		/* 8208B95Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R24);
		/* 8208B95Ch case    2:*/		return 0x8208B960;
		  /* 8208B960h */ case    3:  		/* bc 4, CR6_GT, 24 */
		/* 8208B960h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8208B978;  }
		/* 8208B960h case    3:*/		return 0x8208B964;
		  /* 8208B964h */ case    4:  		/* add R11, R24, R27 */
		/* 8208B964h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R24,regs.R27);
		/* 8208B964h case    4:*/		return 0x8208B968;
		  /* 8208B968h */ case    5:  		/* subf R5, R24, R23 */
		/* 8208B968h case    5:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R24,regs.R23);
		/* 8208B968h case    5:*/		return 0x8208B96C;
		  /* 8208B96Ch */ case    6:  		/* li R4, 0 */
		/* 8208B96Ch case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208B96Ch case    6:*/		return 0x8208B970;
		  /* 8208B970h */ case    7:  		/* addi R3, R11, 16 */
		/* 8208B970h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 8208B970h case    7:*/		return 0x8208B974;
		  /* 8208B974h */ case    8:  		/* bl 22988 */
		/* 8208B974h case    8:*/		regs.LR = 0x8208B978; return 0x82091340;
		/* 8208B974h case    8:*/		return 0x8208B978;
	}
	return 0x8208B978;
} // Block from 8208B954h-8208B978h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8208B978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B978);
		  /* 8208B978h */ case    0:  		/* lbz R11, <#[R27 + 5]> */
		/* 8208B978h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000005) );
		/* 8208B978h case    0:*/		return 0x8208B97C;
		  /* 8208B97Ch */ case    1:  		/* li R3, 1 */
		/* 8208B97Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8208B97Ch case    1:*/		return 0x8208B980;
		  /* 8208B980h */ case    2:  		/* rlwimi R11, R22, 28, 24, 26 */
		/* 8208B980h case    2:*/		cpu::op::rlwimi<0,28,24,26>(regs,&regs.R11,regs.R22);
		/* 8208B980h case    2:*/		return 0x8208B984;
		  /* 8208B984h */ case    3:  		/* stb R11, <#[R27 + 5]> */
		/* 8208B984h case    3:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R27 + 0x00000005) );
		/* 8208B984h case    3:*/		return 0x8208B988;
	}
	return 0x8208B988;
} // Block from 8208B978h-8208B988h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208B988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B988);
		  /* 8208B988h */ case    0:  		/* addi R1, R1, 176 */
		/* 8208B988h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 8208B988h case    0:*/		return 0x8208B98C;
		  /* 8208B98Ch */ case    1:  		/* b 22788 */
		/* 8208B98Ch case    1:*/		return 0x82091290;
		/* 8208B98Ch case    1:*/		return 0x8208B990;
	}
	return 0x8208B990;
} // Block from 8208B988h-8208B990h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208B990h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B990);
		  /* 8208B990h */ case    0:  		/* mfspr R12, LR */
		/* 8208B990h case    0:*/		regs.R12 = regs.LR;
		/* 8208B990h case    0:*/		return 0x8208B994;
		  /* 8208B994h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8208B994h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208B994h case    1:*/		return 0x8208B998;
		  /* 8208B998h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8208B998h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208B998h case    2:*/		return 0x8208B99C;
		  /* 8208B99Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8208B99Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208B99Ch case    3:*/		return 0x8208B9A0;
		  /* 8208B9A0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8208B9A0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8208B9A0h case    4:*/		return 0x8208B9A4;
		  /* 8208B9A4h */ case    5:  		/* lwz R11, <#[R3 + 20]> */
		/* 8208B9A4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 8208B9A4h case    5:*/		return 0x8208B9A8;
		  /* 8208B9A8h */ case    6:  		/* mr R30, R3 */
		/* 8208B9A8h case    6:*/		regs.R30 = regs.R3;
		/* 8208B9A8h case    6:*/		return 0x8208B9AC;
		  /* 8208B9ACh */ case    7:  		/* mr R31, R5 */
		/* 8208B9ACh case    7:*/		regs.R31 = regs.R5;
		/* 8208B9ACh case    7:*/		return 0x8208B9B0;
		  /* 8208B9B0h */ case    8:  		/* rlwinm. R11, R11, 0, 13, 13 */
		/* 8208B9B0h case    8:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R11,regs.R11);
		/* 8208B9B0h case    8:*/		return 0x8208B9B4;
		  /* 8208B9B4h */ case    9:  		/* bc 12, CR0_EQ, 44 */
		/* 8208B9B4h case    9:*/		if ( regs.CR[0].eq ) { return 0x8208B9E0;  }
		/* 8208B9B4h case    9:*/		return 0x8208B9B8;
		  /* 8208B9B8h */ case   10:  		/* bl 1971520 */
		/* 8208B9B8h case   10:*/		regs.LR = 0x8208B9BC; return 0x8226CEF8;
		/* 8208B9B8h case   10:*/		return 0x8208B9BC;
		  /* 8208B9BCh */ case   11:  		/* lbz R11, <#[R30 + 379]> */
		/* 8208B9BCh case   11:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000017B) );
		/* 8208B9BCh case   11:*/		return 0x8208B9C0;
		  /* 8208B9C0h */ case   12:  		/* cmpw CR6, R11, R3 */
		/* 8208B9C0h case   12:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R3);
		/* 8208B9C0h case   12:*/		return 0x8208B9C4;
		  /* 8208B9C4h */ case   13:  		/* bc 12, CR6_EQ, 28 */
		/* 8208B9C4h case   13:*/		if ( regs.CR[6].eq ) { return 0x8208B9E0;  }
		/* 8208B9C4h case   13:*/		return 0x8208B9C8;
		  /* 8208B9C8h */ case   14:  		/* mr R7, R31 */
		/* 8208B9C8h case   14:*/		regs.R7 = regs.R31;
		/* 8208B9C8h case   14:*/		return 0x8208B9CC;
		  /* 8208B9CCh */ case   15:  		/* lwz R5, <#[R1 + 104]> */
		/* 8208B9CCh case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000068) );
		/* 8208B9CCh case   15:*/		return 0x8208B9D0;
		  /* 8208B9D0h */ case   16:  		/* li R6, 5206 */
		/* 8208B9D0h case   16:*/		cpu::op::li<0>(regs,&regs.R6,0x1456);
		/* 8208B9D0h case   16:*/		return 0x8208B9D4;
		  /* 8208B9D4h */ case   17:  		/* mr R4, R30 */
		/* 8208B9D4h case   17:*/		regs.R4 = regs.R30;
		/* 8208B9D4h case   17:*/		return 0x8208B9D8;
		  /* 8208B9D8h */ case   18:  		/* li R3, 244 */
		/* 8208B9D8h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0xF4);
		/* 8208B9D8h case   18:*/		return 0x8208B9DC;
		  /* 8208B9DCh */ case   19:  		/* bl 1972844 */
		/* 8208B9DCh case   19:*/		regs.LR = 0x8208B9E0; return 0x8226D448;
		/* 8208B9DCh case   19:*/		return 0x8208B9E0;
	}
	return 0x8208B9E0;
} // Block from 8208B990h-8208B9E0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8208B9E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B9E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B9E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B9E0);
		  /* 8208B9E0h */ case    0:  		/* lbz R11, <#[R31 - 11]> */
		/* 8208B9E0h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0xFFFFFFF5) );
		/* 8208B9E0h case    0:*/		return 0x8208B9E4;
		  /* 8208B9E4h */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8208B9E4h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8208B9E4h case    1:*/		return 0x8208B9E8;
		  /* 8208B9E8h */ case    2:  		/* bc 4, CR0_EQ, 12 */
		/* 8208B9E8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8208B9F4;  }
		/* 8208B9E8h case    2:*/		return 0x8208B9EC;
		  /* 8208B9ECh */ case    3:  		/* li R3, -1 */
		/* 8208B9ECh case    3:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8208B9ECh case    3:*/		return 0x8208B9F0;
		  /* 8208B9F0h */ case    4:  		/* b 48 */
		/* 8208B9F0h case    4:*/		return 0x8208BA20;
		/* 8208B9F0h case    4:*/		return 0x8208B9F4;
	}
	return 0x8208B9F4;
} // Block from 8208B9E0h-8208B9F4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208B9F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208B9F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208B9F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208B9F4);
		  /* 8208B9F4h */ case    0:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 8208B9F4h case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 8208B9F4h case    0:*/		return 0x8208B9F8;
		  /* 8208B9F8h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 8208B9F8h case    1:*/		if ( regs.CR[0].eq ) { return 0x8208BA10;  }
		/* 8208B9F8h case    1:*/		return 0x8208B9FC;
		  /* 8208B9FCh */ case    2:  		/* lhz R11, <#[R31 - 16]> */
		/* 8208B9FCh case    2:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0xFFFFFFF0) );
		/* 8208B9FCh case    2:*/		return 0x8208BA00;
		  /* 8208BA00h */ case    3:  		/* lwz R10, <#[R31 - 24]> */
		/* 8208BA00h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0xFFFFFFE8) );
		/* 8208BA00h case    3:*/		return 0x8208BA04;
		  /* 8208BA04h */ case    4:  		/* subf R11, R11, R10 */
		/* 8208BA04h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8208BA04h case    4:*/		return 0x8208BA08;
		  /* 8208BA08h */ case    5:  		/* addi R3, R11, -48 */
		/* 8208BA08h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFD0);
		/* 8208BA08h case    5:*/		return 0x8208BA0C;
		  /* 8208BA0Ch */ case    6:  		/* b 20 */
		/* 8208BA0Ch case    6:*/		return 0x8208BA20;
		/* 8208BA0Ch case    6:*/		return 0x8208BA10;
	}
	return 0x8208BA10;
} // Block from 8208B9F4h-8208BA10h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208BA10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BA10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BA10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BA10);
		  /* 8208BA10h */ case    0:  		/* lhz R11, <#[R31 - 16]> */
		/* 8208BA10h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0xFFFFFFF0) );
		/* 8208BA10h case    0:*/		return 0x8208BA14;
		  /* 8208BA14h */ case    1:  		/* lbz R10, <#[R31 - 10]> */
		/* 8208BA14h case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0xFFFFFFF6) );
		/* 8208BA14h case    1:*/		return 0x8208BA18;
		  /* 8208BA18h */ case    2:  		/* rlwinm R11, R11, 4, 0, 31 */
		/* 8208BA18h case    2:*/		cpu::op::rlwinm<0,4,0,31>(regs,&regs.R11,regs.R11);
		/* 8208BA18h case    2:*/		return 0x8208BA1C;
		  /* 8208BA1Ch */ case    3:  		/* subf R3, R10, R11 */
		/* 8208BA1Ch case    3:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8208BA1Ch case    3:*/		return 0x8208BA20;
	}
	return 0x8208BA20;
} // Block from 8208BA10h-8208BA20h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208BA20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BA20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BA20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BA20);
		  /* 8208BA20h */ case    0:  		/* addi R1, R1, 112 */
		/* 8208BA20h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8208BA20h case    0:*/		return 0x8208BA24;
		  /* 8208BA24h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8208BA24h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208BA24h case    1:*/		return 0x8208BA28;
	}
	return 0x8208BA28;
} // Block from 8208BA20h-8208BA28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208BA28h
// Function 'mainCRTStartup'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BA28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BA28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BA28);
		  /* 8208BA28h */ case    0:  		/* mtspr LR, R12 */
		/* 8208BA28h case    0:*/		regs.LR = regs.R12;
		/* 8208BA28h case    0:*/		return 0x8208BA2C;
		  /* 8208BA2Ch */ case    1:  		/* ld R30, <#[R1 - 24]> */
		/* 8208BA2Ch case    1:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208BA2Ch case    1:*/		return 0x8208BA30;
		  /* 8208BA30h */ case    2:  		/* ld R31, <#[R1 - 16]> */
		/* 8208BA30h case    2:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208BA30h case    2:*/		return 0x8208BA34;
		  /* 8208BA34h */ case    3:  		/* bclr 20, CR0_LT */
		/* 8208BA34h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208BA34h case    3:*/		return 0x8208BA38;
	}
	return 0x8208BA38;
} // Block from 8208BA28h-8208BA38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208BA38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BA38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BA38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BA38);
		  /* 8208BA38h */ case    0:  		/* mfspr R12, LR */
		/* 8208BA38h case    0:*/		regs.R12 = regs.LR;
		/* 8208BA38h case    0:*/		return 0x8208BA3C;
		  /* 8208BA3Ch */ case    1:  		/* bl 22532 */
		/* 8208BA3Ch case    1:*/		regs.LR = 0x8208BA40; return 0x82091240;
		/* 8208BA3Ch case    1:*/		return 0x8208BA40;
		  /* 8208BA40h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 8208BA40h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 8208BA40h case    2:*/		return 0x8208BA44;
		  /* 8208BA44h */ case    3:  		/* subf R10, R7, R9 */
		/* 8208BA44h case    3:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R7,regs.R9);
		/* 8208BA44h case    3:*/		return 0x8208BA48;
		  /* 8208BA48h */ case    4:  		/* stw R8, <#[R1 + 236]> */
		/* 8208BA48h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x000000EC) );
		/* 8208BA48h case    4:*/		return 0x8208BA4C;
		  /* 8208BA4Ch */ case    5:  		/* addi R11, R4, 87 */
		/* 8208BA4Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x57);
		/* 8208BA4Ch case    5:*/		return 0x8208BA50;
		  /* 8208BA50h */ case    6:  		/* srawi R10, R10, 16 */
		/* 8208BA50h case    6:*/		cpu::op::srawi<0,16>(regs,&regs.R10,regs.R10);
		/* 8208BA50h case    6:*/		return 0x8208BA54;
		  /* 8208BA54h */ case    7:  		/* mr R28, R3 */
		/* 8208BA54h case    7:*/		regs.R28 = regs.R3;
		/* 8208BA54h case    7:*/		return 0x8208BA58;
		  /* 8208BA58h */ case    8:  		/* mr R31, R4 */
		/* 8208BA58h case    8:*/		regs.R31 = regs.R4;
		/* 8208BA58h case    8:*/		return 0x8208BA5C;
		  /* 8208BA5Ch */ case    9:  		/* mr R25, R5 */
		/* 8208BA5Ch case    9:*/		regs.R25 = regs.R5;
		/* 8208BA5Ch case    9:*/		return 0x8208BA60;
		  /* 8208BA60h */ case   10:  		/* mr R23, R6 */
		/* 8208BA60h case   10:*/		regs.R23 = regs.R6;
		/* 8208BA60h case   10:*/		return 0x8208BA64;
		  /* 8208BA64h */ case   11:  		/* mr R29, R7 */
		/* 8208BA64h case   11:*/		regs.R29 = regs.R7;
		/* 8208BA64h case   11:*/		return 0x8208BA68;
		  /* 8208BA68h */ case   12:  		/* mr R27, R9 */
		/* 8208BA68h case   12:*/		regs.R27 = regs.R9;
		/* 8208BA68h case   12:*/		return 0x8208BA6C;
		  /* 8208BA6Ch */ case   13:  		/* rlwinm R30, R11, 0, 0, 27 */
		/* 8208BA6Ch case   13:*/		cpu::op::rlwinm<0,0,0,27>(regs,&regs.R30,regs.R11);
		/* 8208BA6Ch case   13:*/		return 0x8208BA70;
		  /* 8208BA70h */ case   14:  		/* cmplw CR6, R3, R7 */
		/* 8208BA70h case   14:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R7);
		/* 8208BA70h case   14:*/		return 0x8208BA74;
		  /* 8208BA74h */ case   15:  		/* addze R26, R10 */
		/* 8208BA74h case   15:*/		cpu::op::addze<0>(regs,&regs.R26,regs.R10);
		/* 8208BA74h case   15:*/		return 0x8208BA78;
		  /* 8208BA78h */ case   16:  		/* bc 4, CR6_EQ, 12 */
		/* 8208BA78h case   16:*/		if ( !regs.CR[6].eq ) { return 0x8208BA84;  }
		/* 8208BA78h case   16:*/		return 0x8208BA7C;
		  /* 8208BA7Ch */ case   17:  		/* lhz R22, <#[R3]> */
		/* 8208BA7Ch case   17:*/		cpu::mem::load16z( regs, &regs.R22, (uint32)(regs.R3 + 0x00000000) );
		/* 8208BA7Ch case   17:*/		return 0x8208BA80;
		  /* 8208BA80h */ case   18:  		/* b 8 */
		/* 8208BA80h case   18:*/		return 0x8208BA88;
		/* 8208BA80h case   18:*/		return 0x8208BA84;
	}
	return 0x8208BA84;
} // Block from 8208BA38h-8208BA84h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8208BA84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BA84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BA84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BA84);
		  /* 8208BA84h */ case    0:  		/* li R22, 0 */
		/* 8208BA84h case    0:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 8208BA84h case    0:*/		return 0x8208BA88;
	}
	return 0x8208BA88;
} // Block from 8208BA84h-8208BA88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208BA88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BA88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BA88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BA88);
		  /* 8208BA88h */ case    0:  		/* subf R10, R31, R30 */
		/* 8208BA88h case    0:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R31,regs.R30);
		/* 8208BA88h case    0:*/		return 0x8208BA8C;
		  /* 8208BA8Ch */ case    1:  		/* addi R11, R30, 16 */
		/* 8208BA8Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x10);
		/* 8208BA8Ch case    1:*/		return 0x8208BA90;
		  /* 8208BA90h */ case    2:  		/* srawi R10, R10, 4 */
		/* 8208BA90h case    2:*/		cpu::op::srawi<0,4>(regs,&regs.R10,regs.R10);
		/* 8208BA90h case    2:*/		return 0x8208BA94;
		  /* 8208BA94h */ case    3:  		/* cmplw CR6, R11, R8 */
		/* 8208BA94h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8208BA94h case    3:*/		return 0x8208BA98;
		  /* 8208BA98h */ case    4:  		/* rlwinm R24, R10, 0, 16, 31 */
		/* 8208BA98h case    4:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R24,regs.R10);
		/* 8208BA98h case    4:*/		return 0x8208BA9C;
		  /* 8208BA9Ch */ case    5:  		/* bc 12, CR6_LT, 84 */
		/* 8208BA9Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x8208BAF0;  }
		/* 8208BA9Ch case    5:*/		return 0x8208BAA0;
		  /* 8208BAA0h */ case    6:  		/* cmplw CR6, R11, R27 */
		/* 8208BAA0h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 8208BAA0h case    6:*/		return 0x8208BAA4;
		  /* 8208BAA4h */ case    7:  		/* bc 12, CR6_LT, 12 */
		/* 8208BAA4h case    7:*/		if ( regs.CR[6].lt ) { return 0x8208BAB0;  }
		/* 8208BAA4h case    7:*/		return 0x8208BAA8;
		  /* 8208BAA8h */ case    8:  		/* li R3, 0 */
		/* 8208BAA8h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208BAA8h case    8:*/		return 0x8208BAAC;
		  /* 8208BAACh */ case    9:  		/* b 236 */
		/* 8208BAACh case    9:*/		return 0x8208BB98;
		/* 8208BAACh case    9:*/		return 0x8208BAB0;
	}
	return 0x8208BAB0;
} // Block from 8208BA88h-8208BAB0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8208BAB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BAB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BAB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BAB0);
		  /* 8208BAB0h */ case    0:  		/* subf R11, R8, R30 */
		/* 8208BAB0h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R8,regs.R30);
		/* 8208BAB0h case    0:*/		return 0x8208BAB4;
		  /* 8208BAB4h */ case    1:  		/* lwz R7, <#[R28 + 1424]> */
		/* 8208BAB4h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R28 + 0x00000590) );
		/* 8208BAB4h case    1:*/		return 0x8208BAB8;
		  /* 8208BAB8h */ case    2:  		/* lis R5, 24576 */
		/* 8208BAB8h case    2:*/		cpu::op::lis<0>(regs,&regs.R5,0x6000);
		/* 8208BAB8h case    2:*/		return 0x8208BABC;
		  /* 8208BABCh */ case    3:  		/* addi R11, R11, 16 */
		/* 8208BABCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8208BABCh case    3:*/		return 0x8208BAC0;
		  /* 8208BAC0h */ case    4:  		/* li R6, 4 */
		/* 8208BAC0h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 8208BAC0h case    4:*/		return 0x8208BAC4;
		  /* 8208BAC4h */ case    5:  		/* stw R11, <#[R1 + 80]> */
		/* 8208BAC4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208BAC4h case    5:*/		return 0x8208BAC8;
		  /* 8208BAC8h */ case    6:  		/* ori R5, R5, 4096 */
		/* 8208BAC8h case    6:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x1000);
		/* 8208BAC8h case    6:*/		return 0x8208BACC;
		  /* 8208BACCh */ case    7:  		/* addi R4, R1, 80 */
		/* 8208BACCh case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8208BACCh case    7:*/		return 0x8208BAD0;
		  /* 8208BAD0h */ case    8:  		/* addi R3, R1, 236 */
		/* 8208BAD0h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xEC);
		/* 8208BAD0h case    8:*/		return 0x8208BAD4;
		  /* 8208BAD4h */ case    9:  		/* bl 1972580 */
		/* 8208BAD4h case    9:*/		regs.LR = 0x8208BAD8; return 0x8226D438;
		/* 8208BAD4h case    9:*/		return 0x8208BAD8;
		  /* 8208BAD8h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 8208BAD8h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208BAD8h case   10:*/		return 0x8208BADC;
		  /* 8208BADCh */ case   11:  		/* bc 12, CR0_LT, -52 */
		/* 8208BADCh case   11:*/		if ( regs.CR[0].lt ) { return 0x8208BAA8;  }
		/* 8208BADCh case   11:*/		return 0x8208BAE0;
		  /* 8208BAE0h */ case   12:  		/* lwz R10, <#[R1 + 236]> */
		/* 8208BAE0h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000EC) );
		/* 8208BAE0h case   12:*/		return 0x8208BAE4;
		  /* 8208BAE4h */ case   13:  		/* lwz R11, <#[R1 + 80]> */
		/* 8208BAE4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208BAE4h case   13:*/		return 0x8208BAE8;
		  /* 8208BAE8h */ case   14:  		/* add R8, R11, R10 */
		/* 8208BAE8h case   14:*/		cpu::op::add<0>(regs,&regs.R8,regs.R11,regs.R10);
		/* 8208BAE8h case   14:*/		return 0x8208BAEC;
		  /* 8208BAECh */ case   15:  		/* stw R8, <#[R1 + 236]> */
		/* 8208BAECh case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x000000EC) );
		/* 8208BAECh case   15:*/		return 0x8208BAF0;
	}
	return 0x8208BAF0;
} // Block from 8208BAB0h-8208BAF0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8208BAF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BAF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BAF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BAF0);
		  /* 8208BAF0h */ case    0:  		/* subf R11, R8, R27 */
		/* 8208BAF0h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R8,regs.R27);
		/* 8208BAF0h case    0:*/		return 0x8208BAF4;
		  /* 8208BAF4h */ case    1:  		/* sth R22, <#[R31 + 2]> */
		/* 8208BAF4h case    1:*/		cpu::mem::store16( regs, regs.R22, (uint32)(regs.R31 + 0x00000002) );
		/* 8208BAF4h case    1:*/		return 0x8208BAF8;
		  /* 8208BAF8h */ case    2:  		/* rlwinm R10, R26, 16, 0, 15 */
		/* 8208BAF8h case    2:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R10,regs.R26);
		/* 8208BAF8h case    2:*/		return 0x8208BAFC;
		  /* 8208BAFCh */ case    3:  		/* sth R24, <#[R31]> */
		/* 8208BAFCh case    3:*/		cpu::mem::store16( regs, regs.R24, (uint32)(regs.R31 + 0x00000000) );
		/* 8208BAFCh case    3:*/		return 0x8208BB00;
		  /* 8208BB00h */ case    4:  		/* srawi R11, R11, 16 */
		/* 8208BB00h case    4:*/		cpu::op::srawi<0,16>(regs,&regs.R11,regs.R11);
		/* 8208BB00h case    4:*/		return 0x8208BB04;
		  /* 8208BB04h */ case    5:  		/* stb R25, <#[R31 + 4]> */
		/* 8208BB04h case    5:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R31 + 0x00000004) );
		/* 8208BB04h case    5:*/		return 0x8208BB08;
		  /* 8208BB08h */ case    6:  		/* lis R9, -18 */
		/* 8208BB08h case    6:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFFFEE);
		/* 8208BB08h case    6:*/		return 0x8208BB0C;
		  /* 8208BB0Ch */ case    7:  		/* stw R23, <#[R31 + 20]> */
		/* 8208BB0Ch case    7:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x00000014) );
		/* 8208BB0Ch case    7:*/		return 0x8208BB10;
		  /* 8208BB10h */ case    8:  		/* addze. R11, R11 */
		/* 8208BB10h case    8:*/		cpu::op::addze<1>(regs,&regs.R11,regs.R11);
		/* 8208BB10h case    8:*/		return 0x8208BB14;
		  /* 8208BB14h */ case    9:  		/* stw R28, <#[R31 + 24]> */
		/* 8208BB14h case    9:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000018) );
		/* 8208BB14h case    9:*/		return 0x8208BB18;
		  /* 8208BB18h */ case   10:  		/* li R7, 1 */
		/* 8208BB18h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8208BB18h case   10:*/		return 0x8208BB1C;
		  /* 8208BB1Ch */ case   11:  		/* stw R29, <#[R31 + 32]> */
		/* 8208BB1Ch case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000020) );
		/* 8208BB1Ch case   11:*/		return 0x8208BB20;
		  /* 8208BB20h */ case   12:  		/* ori R9, R9, 65518 */
		/* 8208BB20h case   12:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0xFFEE);
		/* 8208BB20h case   12:*/		return 0x8208BB24;
		  /* 8208BB24h */ case   13:  		/* stw R30, <#[R31 + 40]> */
		/* 8208BB24h case   13:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000028) );
		/* 8208BB24h case   13:*/		return 0x8208BB28;
		  /* 8208BB28h */ case   14:  		/* add R10, R10, R29 */
		/* 8208BB28h case   14:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R29);
		/* 8208BB28h case   14:*/		return 0x8208BB2C;
		  /* 8208BB2Ch */ case   15:  		/* stb R7, <#[R31 + 5]> */
		/* 8208BB2Ch case   15:*/		cpu::mem::store8( regs, regs.R7, (uint32)(regs.R31 + 0x00000005) );
		/* 8208BB2Ch case   15:*/		return 0x8208BB30;
		  /* 8208BB30h */ case   16:  		/* stw R9, <#[R31 + 16]> */
		/* 8208BB30h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 8208BB30h case   16:*/		return 0x8208BB34;
		  /* 8208BB34h */ case   17:  		/* stw R10, <#[R31 + 44]> */
		/* 8208BB34h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 8208BB34h case   17:*/		return 0x8208BB38;
		  /* 8208BB38h */ case   18:  		/* stw R26, <#[R31 + 36]> */
		/* 8208BB38h case   18:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000024) );
		/* 8208BB38h case   18:*/		return 0x8208BB3C;
		  /* 8208BB3Ch */ case   19:  		/* stw R11, <#[R31 + 48]> */
		/* 8208BB3Ch case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8208BB3Ch case   19:*/		return 0x8208BB40;
		  /* 8208BB40h */ case   20:  		/* bc 12, CR0_EQ, 24 */
		/* 8208BB40h case   20:*/		if ( regs.CR[0].eq ) { return 0x8208BB58;  }
		/* 8208BB40h case   20:*/		return 0x8208BB44;
		  /* 8208BB44h */ case   21:  		/* rlwinm R5, R11, 16, 0, 15 */
		/* 8208BB44h case   21:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R5,regs.R11);
		/* 8208BB44h case   21:*/		return 0x8208BB48;
		  /* 8208BB48h */ case   22:  		/* mr R4, R8 */
		/* 8208BB48h case   22:*/		regs.R4 = regs.R8;
		/* 8208BB48h case   22:*/		return 0x8208BB4C;
		  /* 8208BB4Ch */ case   23:  		/* mr R3, R31 */
		/* 8208BB4Ch case   23:*/		regs.R3 = regs.R31;
		/* 8208BB4Ch case   23:*/		return 0x8208BB50;
		  /* 8208BB50h */ case   24:  		/* bl -4144 */
		/* 8208BB50h case   24:*/		regs.LR = 0x8208BB54; return 0x8208AB20;
		/* 8208BB50h case   24:*/		return 0x8208BB54;
		  /* 8208BB54h */ case   25:  		/* lwz R8, <#[R1 + 236]> */
		/* 8208BB54h case   25:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x000000EC) );
		/* 8208BB54h case   25:*/		return 0x8208BB58;
	}
	return 0x8208BB58;
} // Block from 8208BAF0h-8208BB58h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8208BB58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BB58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BB58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BB58);
		  /* 8208BB58h */ case    0:  		/* rlwinm R11, R25, 0, 24, 31 */
		/* 8208BB58h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R25);
		/* 8208BB58h case    0:*/		return 0x8208BB5C;
		  /* 8208BB5Ch */ case    1:  		/* li R10, 16 */
		/* 8208BB5Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x10);
		/* 8208BB5Ch case    1:*/		return 0x8208BB60;
		  /* 8208BB60h */ case    2:  		/* addi R11, R11, 24 */
		/* 8208BB60h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 8208BB60h case    2:*/		return 0x8208BB64;
		  /* 8208BB64h */ case    3:  		/* subf R9, R30, R8 */
		/* 8208BB64h case    3:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R30,regs.R8);
		/* 8208BB64h case    3:*/		return 0x8208BB68;
		  /* 8208BB68h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8208BB68h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8208BB68h case    4:*/		return 0x8208BB6C;
		  /* 8208BB6Ch */ case    5:  		/* srawi R5, R9, 4 */
		/* 8208BB6Ch case    5:*/		cpu::op::srawi<0,4>(regs,&regs.R5,regs.R9);
		/* 8208BB6Ch case    5:*/		return 0x8208BB70;
		  /* 8208BB70h */ case    6:  		/* mr R4, R30 */
		/* 8208BB70h case    6:*/		regs.R4 = regs.R30;
		/* 8208BB70h case    6:*/		return 0x8208BB74;
		  /* 8208BB74h */ case    7:  		/* mr R3, R28 */
		/* 8208BB74h case    7:*/		regs.R3 = regs.R28;
		/* 8208BB74h case    7:*/		return 0x8208BB78;
		  /* 8208BB78h */ case    8:  		/* stwx R31, <#[R11 + R28]> */
		/* 8208BB78h case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8208BB78h case    8:*/		return 0x8208BB7C;
		  /* 8208BB7Ch */ case    9:  		/* lhz R11, <#[R31]> */
		/* 8208BB7Ch case    9:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8208BB7Ch case    9:*/		return 0x8208BB80;
		  /* 8208BB80h */ case   10:  		/* stb R10, <#[R30 + 5]> */
		/* 8208BB80h case   10:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R30 + 0x00000005) );
		/* 8208BB80h case   10:*/		return 0x8208BB84;
		  /* 8208BB84h */ case   11:  		/* stw R30, <#[R31 + 64]> */
		/* 8208BB84h case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000040) );
		/* 8208BB84h case   11:*/		return 0x8208BB88;
		  /* 8208BB88h */ case   12:  		/* stb R25, <#[R30 + 4]> */
		/* 8208BB88h case   12:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R30 + 0x00000004) );
		/* 8208BB88h case   12:*/		return 0x8208BB8C;
		  /* 8208BB8Ch */ case   13:  		/* sth R11, <#[R30 + 2]> */
		/* 8208BB8Ch case   13:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R30 + 0x00000002) );
		/* 8208BB8Ch case   13:*/		return 0x8208BB90;
		  /* 8208BB90h */ case   14:  		/* bl -2232 */
		/* 8208BB90h case   14:*/		regs.LR = 0x8208BB94; return 0x8208B2D8;
		/* 8208BB90h case   14:*/		return 0x8208BB94;
		  /* 8208BB94h */ case   15:  		/* li R3, 1 */
		/* 8208BB94h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8208BB94h case   15:*/		return 0x8208BB98;
	}
	return 0x8208BB98;
} // Block from 8208BB58h-8208BB98h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8208BB98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BB98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BB98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BB98);
		  /* 8208BB98h */ case    0:  		/* addi R1, R1, 176 */
		/* 8208BB98h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 8208BB98h case    0:*/		return 0x8208BB9C;
		  /* 8208BB9Ch */ case    1:  		/* b 22260 */
		/* 8208BB9Ch case    1:*/		return 0x82091290;
		/* 8208BB9Ch case    1:*/		return 0x8208BBA0;
	}
	return 0x8208BBA0;
} // Block from 8208BB98h-8208BBA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208BBA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BBA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BBA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BBA0);
		  /* 8208BBA0h */ case    0:  		/* mfspr R12, LR */
		/* 8208BBA0h case    0:*/		regs.R12 = regs.LR;
		/* 8208BBA0h case    0:*/		return 0x8208BBA4;
		  /* 8208BBA4h */ case    1:  		/* bl 22192 */
		/* 8208BBA4h case    1:*/		regs.LR = 0x8208BBA8; return 0x82091254;
		/* 8208BBA4h case    1:*/		return 0x8208BBA8;
		  /* 8208BBA8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8208BBA8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8208BBA8h case    2:*/		return 0x8208BBAC;
		  /* 8208BBACh */ case    3:  		/* addis R11, R4, 1 */
		/* 8208BBACh case    3:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R4,0x1);
		/* 8208BBACh case    3:*/		return 0x8208BBB0;
		  /* 8208BBB0h */ case    4:  		/* mr R31, R3 */
		/* 8208BBB0h case    4:*/		regs.R31 = regs.R3;
		/* 8208BBB0h case    4:*/		return 0x8208BBB4;
		  /* 8208BBB4h */ case    5:  		/* addi R11, R11, -1 */
		/* 8208BBB4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8208BBB4h case    5:*/		return 0x8208BBB8;
		  /* 8208BBB8h */ case    6:  		/* mr R28, R4 */
		/* 8208BBB8h case    6:*/		regs.R28 = regs.R4;
		/* 8208BBB8h case    6:*/		return 0x8208BBBC;
		  /* 8208BBBCh */ case    7:  		/* rlwinm R29, R11, 16, 16, 31 */
		/* 8208BBBCh case    7:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R29,regs.R11);
		/* 8208BBBCh case    7:*/		return 0x8208BBC0;
		  /* 8208BBC0h */ case    8:  		/* li R27, 64 */
		/* 8208BBC0h case    8:*/		cpu::op::li<0>(regs,&regs.R27,0x40);
		/* 8208BBC0h case    8:*/		return 0x8208BBC4;
		  /* 8208BBC4h */ case    9:  		/* rlwinm R10, R29, 16, 0, 15 */
		/* 8208BBC4h case    9:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R10,regs.R29);
		/* 8208BBC4h case    9:*/		return 0x8208BBC8;
		  /* 8208BBC8h */ case   10:  		/* li R11, 0 */
		/* 8208BBC8h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8208BBC8h case   10:*/		return 0x8208BBCC;
		  /* 8208BBCCh */ case   11:  		/* li R30, 0 */
		/* 8208BBCCh case   11:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8208BBCCh case   11:*/		return 0x8208BBD0;
		  /* 8208BBD0h */ case   12:  		/* stw R10, <#[R1 + 88]> */
		/* 8208BBD0h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 8208BBD0h case   12:*/		return 0x8208BBD4;
		  /* 8208BBD4h */ case   13:  		/* addi R10, R30, 24 */
		/* 8208BBD4h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x18);
		/* 8208BBD4h case   13:*/		return 0x8208BBD8;
		  /* 8208BBD8h */ case   14:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8208BBD8h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8208BBD8h case   14:*/		return 0x8208BBDC;
		  /* 8208BBDCh */ case   15:  		/* lwzx R4, <#[R10 + R31]> */
		/* 8208BBDCh case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 8208BBDCh case   15:*/		return 0x8208BBE0;
		  /* 8208BBE0h */ case   16:  		/* cmplwi CR6, R4, 0 */
		/* 8208BBE0h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8208BBE0h case   16:*/		return 0x8208BBE4;
		  /* 8208BBE4h */ case   17:  		/* stw R4, <#[R1 + 84]> */
		/* 8208BBE4h case   17:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 8208BBE4h case   17:*/		return 0x8208BBE8;
		  /* 8208BBE8h */ case   18:  		/* bc 12, CR6_EQ, 112 */
		/* 8208BBE8h case   18:*/		if ( regs.CR[6].eq ) { return 0x8208BC58;  }
		/* 8208BBE8h case   18:*/		return 0x8208BBEC;
		  /* 8208BBECh */ case   19:  		/* lwz R11, <#[R4 + 48]> */
		/* 8208BBECh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000030) );
		/* 8208BBECh case   19:*/		return 0x8208BBF0;
		  /* 8208BBF0h */ case   20:  		/* cmplw CR6, R29, R11 */
		/* 8208BBF0h case   20:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8208BBF0h case   20:*/		return 0x8208BBF4;
		  /* 8208BBF4h */ case   21:  		/* bc 12, CR6_GT, 116 */
		/* 8208BBF4h case   21:*/		if ( regs.CR[6].gt ) { return 0x8208BC68;  }
		/* 8208BBF4h case   21:*/		return 0x8208BBF8;
		  /* 8208BBF8h */ case   22:  		/* lwz R11, <#[R4 + 28]> */
		/* 8208BBF8h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000001C) );
		/* 8208BBF8h case   22:*/		return 0x8208BBFC;
		  /* 8208BBFCh */ case   23:  		/* lwz R10, <#[R1 + 88]> */
		/* 8208BBFCh case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 8208BBFCh case   23:*/		return 0x8208BC00;
		  /* 8208BC00h */ case   24:  		/* cmplw CR6, R10, R11 */
		/* 8208BC00h case   24:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208BC00h case   24:*/		return 0x8208BC04;
		  /* 8208BC04h */ case   25:  		/* bc 12, CR6_GT, 100 */
		/* 8208BC04h case   25:*/		if ( regs.CR[6].gt ) { return 0x8208BC68;  }
		/* 8208BC04h case   25:*/		return 0x8208BC08;
	}
	return 0x8208BC08;
} // Block from 8208BBA0h-8208BC08h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8208BC08h
// Function 'XMemCpy'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BC08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BC08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BC08);
		  /* 8208BC08h */ case    0:  		/* li R6, 0 */
		/* 8208BC08h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8208BC08h case    0:*/		return 0x8208BC0C;
		  /* 8208BC0Ch */ case    1:  		/* addi R5, R1, 88 */
		/* 8208BC0Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 8208BC0Ch case    1:*/		return 0x8208BC10;
		  /* 8208BC10h */ case    2:  		/* mr R3, R31 */
		/* 8208BC10h case    2:*/		regs.R3 = regs.R31;
		/* 8208BC10h case    2:*/		return 0x8208BC14;
		  /* 8208BC14h */ case    3:  		/* bl -4052 */
		/* 8208BC14h case    3:*/		regs.LR = 0x8208BC18; return 0x8208AC40;
		/* 8208BC14h case    3:*/		return 0x8208BC18;
		  /* 8208BC18h */ case    4:  		/* or. R4, R3, R3 */
		/* 8208BC18h case    4:*/		cpu::op::or<1>(regs,&regs.R4,regs.R3,regs.R3);
		/* 8208BC18h case    4:*/		return 0x8208BC1C;
		  /* 8208BC1Ch */ case    5:  		/* bc 12, CR0_EQ, 76 */
		/* 8208BC1Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x8208BC68;  }
		/* 8208BC1Ch case    5:*/		return 0x8208BC20;
		  /* 8208BC20h */ case    6:  		/* lwz R11, <#[R1 + 88]> */
		/* 8208BC20h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8208BC20h case    6:*/		return 0x8208BC24;
		  /* 8208BC24h */ case    7:  		/* li R6, 0 */
		/* 8208BC24h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8208BC24h case    7:*/		return 0x8208BC28;
		  /* 8208BC28h */ case    8:  		/* addi R5, R1, 88 */
		/* 8208BC28h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 8208BC28h case    8:*/		return 0x8208BC2C;
		  /* 8208BC2Ch */ case    9:  		/* rlwinm R11, R11, 28, 4, 31 */
		/* 8208BC2Ch case    9:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R11,regs.R11);
		/* 8208BC2Ch case    9:*/		return 0x8208BC30;
		  /* 8208BC30h */ case   10:  		/* mr R3, R31 */
		/* 8208BC30h case   10:*/		regs.R3 = regs.R31;
		/* 8208BC30h case   10:*/		return 0x8208BC34;
		  /* 8208BC34h */ case   11:  		/* stw R11, <#[R1 + 88]> */
		/* 8208BC34h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8208BC34h case   11:*/		return 0x8208BC38;
		  /* 8208BC38h */ case   12:  		/* bl -3432 */
		/* 8208BC38h case   12:*/		regs.LR = 0x8208BC3C; return 0x8208AED0;
		/* 8208BC38h case   12:*/		return 0x8208BC3C;
		  /* 8208BC3Ch */ case   13:  		/* mr R30, R3 */
		/* 8208BC3Ch case   13:*/		regs.R30 = regs.R3;
		/* 8208BC3Ch case   13:*/		return 0x8208BC40;
		  /* 8208BC40h */ case   14:  		/* mr R3, R31 */
		/* 8208BC40h case   14:*/		regs.R3 = regs.R31;
		/* 8208BC40h case   14:*/		return 0x8208BC44;
		  /* 8208BC44h */ case   15:  		/* lwz R5, <#[R1 + 88]> */
		/* 8208BC44h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000058) );
		/* 8208BC44h case   15:*/		return 0x8208BC48;
		  /* 8208BC48h */ case   16:  		/* mr R4, R30 */
		/* 8208BC48h case   16:*/		regs.R4 = regs.R30;
		/* 8208BC48h case   16:*/		return 0x8208BC4C;
		  /* 8208BC4Ch */ case   17:  		/* bl -2420 */
		/* 8208BC4Ch case   17:*/		regs.LR = 0x8208BC50; return 0x8208B2D8;
		/* 8208BC4Ch case   17:*/		return 0x8208BC50;
		  /* 8208BC50h */ case   18:  		/* mr R3, R30 */
		/* 8208BC50h case   18:*/		regs.R3 = regs.R30;
		/* 8208BC50h case   18:*/		return 0x8208BC54;
		  /* 8208BC54h */ case   19:  		/* b 384 */
		/* 8208BC54h case   19:*/		return 0x8208BDD4;
		/* 8208BC54h case   19:*/		return 0x8208BC58;
	}
	return 0x8208BC58;
} // Block from 8208BC08h-8208BC58h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8208BC58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BC58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BC58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BC58);
		  /* 8208BC58h */ case    0:  		/* rlwinm R10, R27, 0, 24, 31 */
		/* 8208BC58h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R27);
		/* 8208BC58h case    0:*/		return 0x8208BC5C;
		  /* 8208BC5Ch */ case    1:  		/* cmplwi CR6, R10, 64 */
		/* 8208BC5Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000040);
		/* 8208BC5Ch case    1:*/		return 0x8208BC60;
		  /* 8208BC60h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 8208BC60h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8208BC68;  }
		/* 8208BC60h case    2:*/		return 0x8208BC64;
		  /* 8208BC64h */ case    3:  		/* mr R27, R11 */
		/* 8208BC64h case    3:*/		regs.R27 = regs.R11;
		/* 8208BC64h case    3:*/		return 0x8208BC68;
	}
	return 0x8208BC68;
} // Block from 8208BC58h-8208BC68h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208BC68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BC68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BC68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BC68);
		  /* 8208BC68h */ case    0:  		/* addi R11, R30, 1 */
		/* 8208BC68h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x1);
		/* 8208BC68h case    0:*/		return 0x8208BC6C;
		  /* 8208BC6Ch */ case    1:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 8208BC6Ch case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8208BC6Ch case    1:*/		return 0x8208BC70;
		  /* 8208BC70h */ case    2:  		/* mr R30, R11 */
		/* 8208BC70h case    2:*/		regs.R30 = regs.R11;
		/* 8208BC70h case    2:*/		return 0x8208BC74;
		  /* 8208BC74h */ case    3:  		/* cmplwi CR6, R11, 64 */
		/* 8208BC74h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000040);
		/* 8208BC74h case    3:*/		return 0x8208BC78;
		  /* 8208BC78h */ case    4:  		/* bc 12, CR6_LT, -164 */
		/* 8208BC78h case    4:*/		if ( regs.CR[6].lt ) { return 0x8208BBD4;  }
		/* 8208BC78h case    4:*/		return 0x8208BC7C;
		  /* 8208BC7Ch */ case    5:  		/* rlwinm R11, R27, 0, 24, 31 */
		/* 8208BC7Ch case    5:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R27);
		/* 8208BC7Ch case    5:*/		return 0x8208BC80;
		  /* 8208BC80h */ case    6:  		/* cmplwi CR6, R11, 64 */
		/* 8208BC80h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000040);
		/* 8208BC80h case    6:*/		return 0x8208BC84;
		  /* 8208BC84h */ case    7:  		/* bc 12, CR6_EQ, 332 */
		/* 8208BC84h case    7:*/		if ( regs.CR[6].eq ) { return 0x8208BDD0;  }
		/* 8208BC84h case    7:*/		return 0x8208BC88;
		  /* 8208BC88h */ case    8:  		/* lwz R11, <#[R31 + 20]> */
		/* 8208BC88h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8208BC88h case    8:*/		return 0x8208BC8C;
		  /* 8208BC8Ch */ case    9:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 8208BC8Ch case    9:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 8208BC8Ch case    9:*/		return 0x8208BC90;
		  /* 8208BC90h */ case   10:  		/* bc 12, CR0_EQ, 320 */
		/* 8208BC90h case   10:*/		if ( regs.CR[0].eq ) { return 0x8208BDD0;  }
		/* 8208BC90h case   10:*/		return 0x8208BC94;
		  /* 8208BC94h */ case   11:  		/* lwz R11, <#[R31 + 32]> */
		/* 8208BC94h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8208BC94h case   11:*/		return 0x8208BC98;
		  /* 8208BC98h */ case   12:  		/* addis R30, R28, 1 */
		/* 8208BC98h case   12:*/		cpu::op::addis<0>(regs,&regs.R30,regs.R28,0x1);
		/* 8208BC98h case   12:*/		return 0x8208BC9C;
		  /* 8208BC9Ch */ case   13:  		/* li R10, 0 */
		/* 8208BC9Ch case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8208BC9Ch case   13:*/		return 0x8208BCA0;
		  /* 8208BCA0h */ case   14:  		/* cmplw CR6, R30, R11 */
		/* 8208BCA0h case   14:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8208BCA0h case   14:*/		return 0x8208BCA4;
		  /* 8208BCA4h */ case   15:  		/* stw R30, <#[R1 + 80]> */
		/* 8208BCA4h case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 8208BCA4h case   15:*/		return 0x8208BCA8;
		  /* 8208BCA8h */ case   16:  		/* stw R10, <#[R1 + 84]> */
		/* 8208BCA8h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 8208BCA8h case   16:*/		return 0x8208BCAC;
		  /* 8208BCACh */ case   17:  		/* bc 12, CR6_GT, 8 */
		/* 8208BCACh case   17:*/		if ( regs.CR[6].gt ) { return 0x8208BCB4;  }
		/* 8208BCACh case   17:*/		return 0x8208BCB0;
		  /* 8208BCB0h */ case   18:  		/* stw R11, <#[R1 + 80]> */
		/* 8208BCB0h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208BCB0h case   18:*/		return 0x8208BCB4;
	}
	return 0x8208BCB4;
} // Block from 8208BC68h-8208BCB4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8208BCB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BCB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BCB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BCB4);
		  /* 8208BCB4h */ case    0:  		/* lis R5, 24576 */
		/* 8208BCB4h case    0:*/		cpu::op::lis<0>(regs,&regs.R5,0x6000);
		/* 8208BCB4h case    0:*/		return 0x8208BCB8;
		  /* 8208BCB8h */ case    1:  		/* lwz R7, <#[R31 + 1424]> */
		/* 8208BCB8h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000590) );
		/* 8208BCB8h case    1:*/		return 0x8208BCBC;
		  /* 8208BCBCh */ case    2:  		/* li R6, 4 */
		/* 8208BCBCh case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 8208BCBCh case    2:*/		return 0x8208BCC0;
		  /* 8208BCC0h */ case    3:  		/* ori R5, R5, 8192 */
		/* 8208BCC0h case    3:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x2000);
		/* 8208BCC0h case    3:*/		return 0x8208BCC4;
		  /* 8208BCC4h */ case    4:  		/* addi R4, R1, 80 */
		/* 8208BCC4h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8208BCC4h case    4:*/		return 0x8208BCC8;
		  /* 8208BCC8h */ case    5:  		/* addi R3, R1, 84 */
		/* 8208BCC8h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x54);
		/* 8208BCC8h case    5:*/		return 0x8208BCCC;
		  /* 8208BCCCh */ case    6:  		/* bl 1972076 */
		/* 8208BCCCh case    6:*/		regs.LR = 0x8208BCD0; return 0x8226D438;
		/* 8208BCCCh case    6:*/		return 0x8208BCD0;
		  /* 8208BCD0h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 8208BCD0h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208BCD0h case    7:*/		return 0x8208BCD4;
		  /* 8208BCD4h */ case    8:  		/* bc 4, CR0_LT, 80 */
		/* 8208BCD4h case    8:*/		if ( !regs.CR[0].lt ) { return 0x8208BD24;  }
		/* 8208BCD4h case    8:*/		return 0x8208BCD8;
		  /* 8208BCD8h */ case    9:  		/* lwz R11, <#[R1 + 80]> */
		/* 8208BCD8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208BCD8h case    9:*/		return 0x8208BCDC;
		  /* 8208BCDCh */ case   10:  		/* cmplw CR6, R11, R30 */
		/* 8208BCDCh case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 8208BCDCh case   10:*/		return 0x8208BCE0;
		  /* 8208BCE0h */ case   11:  		/* bc 12, CR6_EQ, 60 */
		/* 8208BCE0h case   11:*/		if ( regs.CR[6].eq ) { return 0x8208BD1C;  }
		/* 8208BCE0h case   11:*/		return 0x8208BCE4;
		  /* 8208BCE4h */ case   12:  		/* rlwinm R11, R11, 31, 1, 31 */
		/* 8208BCE4h case   12:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R11,regs.R11);
		/* 8208BCE4h case   12:*/		return 0x8208BCE8;
		  /* 8208BCE8h */ case   13:  		/* stw R11, <#[R1 + 80]> */
		/* 8208BCE8h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208BCE8h case   13:*/		return 0x8208BCEC;
		  /* 8208BCECh */ case   14:  		/* cmplw CR6, R11, R30 */
		/* 8208BCECh case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 8208BCECh case   14:*/		return 0x8208BCF0;
		  /* 8208BCF0h */ case   15:  		/* bc 4, CR6_LT, 8 */
		/* 8208BCF0h case   15:*/		if ( !regs.CR[6].lt ) { return 0x8208BCF8;  }
		/* 8208BCF0h case   15:*/		return 0x8208BCF4;
		  /* 8208BCF4h */ case   16:  		/* stw R30, <#[R1 + 80]> */
		/* 8208BCF4h case   16:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 8208BCF4h case   16:*/		return 0x8208BCF8;
	}
	return 0x8208BCF8;
} // Block from 8208BCB4h-8208BCF8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8208BCF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BCF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BCF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BCF8);
		  /* 8208BCF8h */ case    0:  		/* lis R5, 24576 */
		/* 8208BCF8h case    0:*/		cpu::op::lis<0>(regs,&regs.R5,0x6000);
		/* 8208BCF8h case    0:*/		return 0x8208BCFC;
		  /* 8208BCFCh */ case    1:  		/* lwz R7, <#[R31 + 1424]> */
		/* 8208BCFCh case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000590) );
		/* 8208BCFCh case    1:*/		return 0x8208BD00;
		  /* 8208BD00h */ case    2:  		/* li R6, 4 */
		/* 8208BD00h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 8208BD00h case    2:*/		return 0x8208BD04;
		  /* 8208BD04h */ case    3:  		/* ori R5, R5, 8192 */
		/* 8208BD04h case    3:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x2000);
		/* 8208BD04h case    3:*/		return 0x8208BD08;
		  /* 8208BD08h */ case    4:  		/* addi R4, R1, 80 */
		/* 8208BD08h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8208BD08h case    4:*/		return 0x8208BD0C;
		  /* 8208BD0Ch */ case    5:  		/* addi R3, R1, 84 */
		/* 8208BD0Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x54);
		/* 8208BD0Ch case    5:*/		return 0x8208BD10;
		  /* 8208BD10h */ case    6:  		/* bl 1972008 */
		/* 8208BD10h case    6:*/		regs.LR = 0x8208BD14; return 0x8226D438;
		/* 8208BD10h case    6:*/		return 0x8208BD14;
		  /* 8208BD14h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 8208BD14h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208BD14h case    7:*/		return 0x8208BD18;
		  /* 8208BD18h */ case    8:  		/* bc 12, CR0_LT, -64 */
		/* 8208BD18h case    8:*/		if ( regs.CR[0].lt ) { return 0x8208BCD8;  }
		/* 8208BD18h case    8:*/		return 0x8208BD1C;
	}
	return 0x8208BD1C;
} // Block from 8208BCF8h-8208BD1Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8208BD1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BD1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BD1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BD1C);
		  /* 8208BD1Ch */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 8208BD1Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8208BD1Ch case    0:*/		return 0x8208BD20;
		  /* 8208BD20h */ case    1:  		/* bc 12, CR6_LT, 176 */
		/* 8208BD20h case    1:*/		if ( regs.CR[6].lt ) { return 0x8208BDD0;  }
		/* 8208BD20h case    1:*/		return 0x8208BD24;
	}
	return 0x8208BD24;
} // Block from 8208BD1Ch-8208BD24h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208BD24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BD24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BD24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BD24);
		  /* 8208BD24h */ case    0:  		/* lwz R10, <#[R31 + 32]> */
		/* 8208BD24h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000020) );
		/* 8208BD24h case    0:*/		return 0x8208BD28;
		  /* 8208BD28h */ case    1:  		/* lwz R9, <#[R1 + 80]> */
		/* 8208BD28h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 8208BD28h case    1:*/		return 0x8208BD2C;
		  /* 8208BD2Ch */ case    2:  		/* lwz R11, <#[R31 + 36]> */
		/* 8208BD2Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 8208BD2Ch case    2:*/		return 0x8208BD30;
		  /* 8208BD30h */ case    3:  		/* add R10, R10, R9 */
		/* 8208BD30h case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8208BD30h case    3:*/		return 0x8208BD34;
		  /* 8208BD34h */ case    4:  		/* stw R30, <#[R1 + 92]> */
		/* 8208BD34h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000005C) );
		/* 8208BD34h case    4:*/		return 0x8208BD38;
		  /* 8208BD38h */ case    5:  		/* cmplw CR6, R30, R11 */
		/* 8208BD38h case    5:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8208BD38h case    5:*/		return 0x8208BD3C;
		  /* 8208BD3Ch */ case    6:  		/* stw R10, <#[R31 + 32]> */
		/* 8208BD3Ch case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000020) );
		/* 8208BD3Ch case    6:*/		return 0x8208BD40;
		  /* 8208BD40h */ case    7:  		/* bc 12, CR6_GT, 8 */
		/* 8208BD40h case    7:*/		if ( regs.CR[6].gt ) { return 0x8208BD48;  }
		/* 8208BD40h case    7:*/		return 0x8208BD44;
		  /* 8208BD44h */ case    8:  		/* stw R11, <#[R1 + 92]> */
		/* 8208BD44h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8208BD44h case    8:*/		return 0x8208BD48;
	}
	return 0x8208BD48;
} // Block from 8208BD24h-8208BD48h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8208BD48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BD48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BD48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BD48);
		  /* 8208BD48h */ case    0:  		/* lis R5, 24576 */
		/* 8208BD48h case    0:*/		cpu::op::lis<0>(regs,&regs.R5,0x6000);
		/* 8208BD48h case    0:*/		return 0x8208BD4C;
		  /* 8208BD4Ch */ case    1:  		/* lwz R7, <#[R31 + 1424]> */
		/* 8208BD4Ch case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000590) );
		/* 8208BD4Ch case    1:*/		return 0x8208BD50;
		  /* 8208BD50h */ case    2:  		/* li R6, 4 */
		/* 8208BD50h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 8208BD50h case    2:*/		return 0x8208BD54;
		  /* 8208BD54h */ case    3:  		/* ori R5, R5, 4096 */
		/* 8208BD54h case    3:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x1000);
		/* 8208BD54h case    3:*/		return 0x8208BD58;
		  /* 8208BD58h */ case    4:  		/* addi R4, R1, 92 */
		/* 8208BD58h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x5C);
		/* 8208BD58h case    4:*/		return 0x8208BD5C;
		  /* 8208BD5Ch */ case    5:  		/* addi R3, R1, 84 */
		/* 8208BD5Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x54);
		/* 8208BD5Ch case    5:*/		return 0x8208BD60;
		  /* 8208BD60h */ case    6:  		/* bl 1971928 */
		/* 8208BD60h case    6:*/		regs.LR = 0x8208BD64; return 0x8226D438;
		/* 8208BD60h case    6:*/		return 0x8208BD64;
		  /* 8208BD64h */ case    7:  		/* or. R30, R3, R3 */
		/* 8208BD64h case    7:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 8208BD64h case    7:*/		return 0x8208BD68;
		  /* 8208BD68h */ case    8:  		/* bc 12, CR0_LT, 80 */
		/* 8208BD68h case    8:*/		if ( regs.CR[0].lt ) { return 0x8208BDB8;  }
		/* 8208BD68h case    8:*/		return 0x8208BD6C;
		  /* 8208BD6Ch */ case    9:  		/* lwz R7, <#[R1 + 84]> */
		/* 8208BD6Ch case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000054) );
		/* 8208BD6Ch case    9:*/		return 0x8208BD70;
		  /* 8208BD70h */ case   10:  		/* li R6, 0 */
		/* 8208BD70h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8208BD70h case   10:*/		return 0x8208BD74;
		  /* 8208BD74h */ case   11:  		/* lwz R11, <#[R1 + 80]> */
		/* 8208BD74h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208BD74h case   11:*/		return 0x8208BD78;
		  /* 8208BD78h */ case   12:  		/* mr R5, R27 */
		/* 8208BD78h case   12:*/		regs.R5 = regs.R27;
		/* 8208BD78h case   12:*/		return 0x8208BD7C;
		  /* 8208BD7Ch */ case   13:  		/* lwz R10, <#[R1 + 92]> */
		/* 8208BD7Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 8208BD7Ch case   13:*/		return 0x8208BD80;
		  /* 8208BD80h */ case   14:  		/* mr R3, R31 */
		/* 8208BD80h case   14:*/		regs.R3 = regs.R31;
		/* 8208BD80h case   14:*/		return 0x8208BD84;
		  /* 8208BD84h */ case   15:  		/* add R9, R11, R7 */
		/* 8208BD84h case   15:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R7);
		/* 8208BD84h case   15:*/		return 0x8208BD88;
		  /* 8208BD88h */ case   16:  		/* add R8, R10, R7 */
		/* 8208BD88h case   16:*/		cpu::op::add<0>(regs,&regs.R8,regs.R10,regs.R7);
		/* 8208BD88h case   16:*/		return 0x8208BD8C;
		  /* 8208BD8Ch */ case   17:  		/* mr R4, R7 */
		/* 8208BD8Ch case   17:*/		regs.R4 = regs.R7;
		/* 8208BD8Ch case   17:*/		return 0x8208BD90;
		  /* 8208BD90h */ case   18:  		/* bl -856 */
		/* 8208BD90h case   18:*/		regs.LR = 0x8208BD94; return 0x8208BA38;
		/* 8208BD90h case   18:*/		return 0x8208BD94;
		  /* 8208BD94h */ case   19:  		/* cmplwi CR0, R3, 0 */
		/* 8208BD94h case   19:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8208BD94h case   19:*/		return 0x8208BD98;
		  /* 8208BD98h */ case   20:  		/* bc 4, CR0_EQ, 12 */
		/* 8208BD98h case   20:*/		if ( !regs.CR[0].eq ) { return 0x8208BDA4;  }
		/* 8208BD98h case   20:*/		return 0x8208BD9C;
		  /* 8208BD9Ch */ case   21:  		/* lis R30, -16384 */
		/* 8208BD9Ch case   21:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFFC000);
		/* 8208BD9Ch case   21:*/		return 0x8208BDA0;
		  /* 8208BDA0h */ case   22:  		/* ori R30, R30, 23 */
		/* 8208BDA0h case   22:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0x17);
		/* 8208BDA0h case   22:*/		return 0x8208BDA4;
	}
	return 0x8208BDA4;
} // Block from 8208BD48h-8208BDA4h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8208BDA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BDA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BDA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BDA4);
		  /* 8208BDA4h */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 8208BDA4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 8208BDA4h case    0:*/		return 0x8208BDA8;
		  /* 8208BDA8h */ case    1:  		/* bc 12, CR6_LT, 16 */
		/* 8208BDA8h case    1:*/		if ( regs.CR[6].lt ) { return 0x8208BDB8;  }
		/* 8208BDA8h case    1:*/		return 0x8208BDAC;
		  /* 8208BDACh */ case    2:  		/* lwz R11, <#[R1 + 84]> */
		/* 8208BDACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8208BDACh case    2:*/		return 0x8208BDB0;
		  /* 8208BDB0h */ case    3:  		/* lwz R3, <#[R11 + 40]> */
		/* 8208BDB0h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000028) );
		/* 8208BDB0h case    3:*/		return 0x8208BDB4;
		  /* 8208BDB4h */ case    4:  		/* b 32 */
		/* 8208BDB4h case    4:*/		return 0x8208BDD4;
		/* 8208BDB4h case    4:*/		return 0x8208BDB8;
	}
	return 0x8208BDB8;
} // Block from 8208BDA4h-8208BDB8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208BDB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BDB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BDB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BDB8);
		  /* 8208BDB8h */ case    0:  		/* lis R5, 0 */
		/* 8208BDB8h case    0:*/		cpu::op::lis<0>(regs,&regs.R5,0x0);
		/* 8208BDB8h case    0:*/		return 0x8208BDBC;
		  /* 8208BDBCh */ case    1:  		/* lwz R6, <#[R31 + 1424]> */
		/* 8208BDBCh case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000590) );
		/* 8208BDBCh case    1:*/		return 0x8208BDC0;
		  /* 8208BDC0h */ case    2:  		/* addi R4, R1, 80 */
		/* 8208BDC0h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8208BDC0h case    2:*/		return 0x8208BDC4;
		  /* 8208BDC4h */ case    3:  		/* ori R5, R5, 32768 */
		/* 8208BDC4h case    3:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x8000);
		/* 8208BDC4h case    3:*/		return 0x8208BDC8;
		  /* 8208BDC8h */ case    4:  		/* addi R3, R1, 84 */
		/* 8208BDC8h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x54);
		/* 8208BDC8h case    4:*/		return 0x8208BDCC;
		  /* 8208BDCCh */ case    5:  		/* bl 1971852 */
		/* 8208BDCCh case    5:*/		regs.LR = 0x8208BDD0; return 0x8226D458;
		/* 8208BDCCh case    5:*/		return 0x8208BDD0;
	}
	return 0x8208BDD0;
} // Block from 8208BDB8h-8208BDD0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208BDD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BDD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BDD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BDD0);
		  /* 8208BDD0h */ case    0:  		/* li R3, 0 */
		/* 8208BDD0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208BDD0h case    0:*/		return 0x8208BDD4;
	}
	return 0x8208BDD4;
} // Block from 8208BDD0h-8208BDD4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208BDD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BDD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BDD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BDD4);
		  /* 8208BDD4h */ case    0:  		/* addi R1, R1, 144 */
		/* 8208BDD4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8208BDD4h case    0:*/		return 0x8208BDD8;
		  /* 8208BDD8h */ case    1:  		/* b 21708 */
		/* 8208BDD8h case    1:*/		return 0x820912A4;
		/* 8208BDD8h case    1:*/		return 0x8208BDDC;
		  /* 8208BDDCh */ case    2:  		/* nop */
		/* 8208BDDCh case    2:*/		cpu::op::nop();
		/* 8208BDDCh case    2:*/		return 0x8208BDE0;
	}
	return 0x8208BDE0;
} // Block from 8208BDD4h-8208BDE0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208BDE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BDE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BDE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BDE0);
		  /* 8208BDE0h */ case    0:  		/* mfspr R12, LR */
		/* 8208BDE0h case    0:*/		regs.R12 = regs.LR;
		/* 8208BDE0h case    0:*/		return 0x8208BDE4;
		  /* 8208BDE4h */ case    1:  		/* bl 21584 */
		/* 8208BDE4h case    1:*/		regs.LR = 0x8208BDE8; return 0x82091234;
		/* 8208BDE4h case    1:*/		return 0x8208BDE8;
		  /* 8208BDE8h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 8208BDE8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 8208BDE8h case    2:*/		return 0x8208BDEC;
		  /* 8208BDECh */ case    3:  		/* lwz R11, <#[R3 + 1412]> */
		/* 8208BDECh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000584) );
		/* 8208BDECh case    3:*/		return 0x8208BDF0;
		  /* 8208BDF0h */ case    4:  		/* mr R29, R3 */
		/* 8208BDF0h case    4:*/		regs.R29 = regs.R3;
		/* 8208BDF0h case    4:*/		return 0x8208BDF4;
		  /* 8208BDF4h */ case    5:  		/* mr R31, R4 */
		/* 8208BDF4h case    5:*/		regs.R31 = regs.R4;
		/* 8208BDF4h case    5:*/		return 0x8208BDF8;
		  /* 8208BDF8h */ case    6:  		/* mr R24, R5 */
		/* 8208BDF8h case    6:*/		regs.R24 = regs.R5;
		/* 8208BDF8h case    6:*/		return 0x8208BDFC;
		  /* 8208BDFCh */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8208BDFCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208BDFCh case    7:*/		return 0x8208BE00;
		  /* 8208BE00h */ case    8:  		/* bc 4, CR6_EQ, 808 */
		/* 8208BE00h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8208C128;  }
		/* 8208BE00h case    8:*/		return 0x8208BE04;
		  /* 8208BE04h */ case    9:  		/* addis R10, R4, 1 */
		/* 8208BE04h case    9:*/		cpu::op::addis<0>(regs,&regs.R10,regs.R4,0x1);
		/* 8208BE04h case    9:*/		return 0x8208BE08;
		  /* 8208BE08h */ case   10:  		/* lbz R11, <#[R4 + 4]> */
		/* 8208BE08h case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 8208BE08h case   10:*/		return 0x8208BE0C;
		  /* 8208BE0Ch */ case   11:  		/* li R19, 0 */
		/* 8208BE0Ch case   11:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 8208BE0Ch case   11:*/		return 0x8208BE10;
		  /* 8208BE10h */ case   12:  		/* addi R10, R10, -1 */
		/* 8208BE10h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8208BE10h case   12:*/		return 0x8208BE14;
		  /* 8208BE14h */ case   13:  		/* addi R11, R11, 24 */
		/* 8208BE14h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 8208BE14h case   13:*/		return 0x8208BE18;
		  /* 8208BE18h */ case   14:  		/* rlwinm R9, R10, 0, 0, 15 */
		/* 8208BE18h case   14:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R9,regs.R10);
		/* 8208BE18h case   14:*/		return 0x8208BE1C;
		  /* 8208BE1Ch */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8208BE1Ch case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8208BE1Ch case   15:*/		return 0x8208BE20;
		  /* 8208BE20h */ case   16:  		/* subf R10, R4, R9 */
		/* 8208BE20h case   16:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R4,regs.R9);
		/* 8208BE20h case   16:*/		return 0x8208BE24;
		  /* 8208BE24h */ case   17:  		/* lis R7, 1 */
		/* 8208BE24h case   17:*/		cpu::op::lis<0>(regs,&regs.R7,0x1);
		/* 8208BE24h case   17:*/		return 0x8208BE28;
		  /* 8208BE28h */ case   18:  		/* srawi R10, R10, 4 */
		/* 8208BE28h case   18:*/		cpu::op::srawi<0,4>(regs,&regs.R10,regs.R10);
		/* 8208BE28h case   18:*/		return 0x8208BE2C;
		  /* 8208BE2Ch */ case   19:  		/* mr R23, R19 */
		/* 8208BE2Ch case   19:*/		regs.R23 = regs.R19;
		/* 8208BE2Ch case   19:*/		return 0x8208BE30;
		  /* 8208BE30h */ case   20:  		/* rlwinm R26, R10, 0, 16, 31 */
		/* 8208BE30h case   20:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R26,regs.R10);
		/* 8208BE30h case   20:*/		return 0x8208BE34;
		  /* 8208BE34h */ case   21:  		/* lwzx R25, <#[R11 + R3]> */
		/* 8208BE34h case   21:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8208BE34h case   21:*/		return 0x8208BE38;
		  /* 8208BE38h */ case   22:  		/* stw R9, <#[R1 + 84]> */
		/* 8208BE38h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 8208BE38h case   22:*/		return 0x8208BE3C;
		  /* 8208BE3Ch */ case   23:  		/* cmplwi CR6, R26, 1 */
		/* 8208BE3Ch case   23:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000001);
		/* 8208BE3Ch case   23:*/		return 0x8208BE40;
		  /* 8208BE40h */ case   24:  		/* bc 4, CR6_EQ, 20 */
		/* 8208BE40h case   24:*/		if ( !regs.CR[6].eq ) { return 0x8208BE54;  }
		/* 8208BE40h case   24:*/		return 0x8208BE44;
		  /* 8208BE44h */ case   25:  		/* add R9, R9, R7 */
		/* 8208BE44h case   25:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 8208BE44h case   25:*/		return 0x8208BE48;
		  /* 8208BE48h */ case   26:  		/* li R26, 4097 */
		/* 8208BE48h case   26:*/		cpu::op::li<0>(regs,&regs.R26,0x1001);
		/* 8208BE48h case   26:*/		return 0x8208BE4C;
		  /* 8208BE4Ch */ case   27:  		/* stw R9, <#[R1 + 84]> */
		/* 8208BE4Ch case   27:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 8208BE4Ch case   27:*/		return 0x8208BE50;
		  /* 8208BE50h */ case   28:  		/* b 32 */
		/* 8208BE50h case   28:*/		return 0x8208BE70;
		/* 8208BE50h case   28:*/		return 0x8208BE54;
	}
	return 0x8208BE54;
} // Block from 8208BDE0h-8208BE54h (29 instructions)

//////////////////////////////////////////////////////
// Block at 8208BE54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BE54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BE54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BE54);
		  /* 8208BE54h */ case    0:  		/* lhz R11, <#[R31 + 2]> */
		/* 8208BE54h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000002) );
		/* 8208BE54h case    0:*/		return 0x8208BE58;
		  /* 8208BE58h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 8208BE58h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8208BE58h case    1:*/		return 0x8208BE5C;
		  /* 8208BE5Ch */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 8208BE5Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8208BE70;  }
		/* 8208BE5Ch case    2:*/		return 0x8208BE60;
		  /* 8208BE60h */ case    3:  		/* cmplw CR6, R9, R31 */
		/* 8208BE60h case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R31);
		/* 8208BE60h case    3:*/		return 0x8208BE64;
		  /* 8208BE64h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 8208BE64h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8208BE70;  }
		/* 8208BE64h case    4:*/		return 0x8208BE68;
		  /* 8208BE68h */ case    5:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 8208BE68h case    5:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 8208BE68h case    5:*/		return 0x8208BE6C;
		  /* 8208BE6Ch */ case    6:  		/* subf R23, R11, R31 */
		/* 8208BE6Ch case    6:*/		cpu::op::subf<0>(regs,&regs.R23,regs.R11,regs.R31);
		/* 8208BE6Ch case    6:*/		return 0x8208BE70;
	}
	return 0x8208BE70;
} // Block from 8208BE54h-8208BE70h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208BE70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BE70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BE70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BE70);
		  /* 8208BE70h */ case    0:  		/* rlwinm R11, R24, 4, 0, 27 */
		/* 8208BE70h case    0:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R24);
		/* 8208BE70h case    0:*/		return 0x8208BE74;
		  /* 8208BE74h */ case    1:  		/* mr R20, R19 */
		/* 8208BE74h case    1:*/		regs.R20 = regs.R19;
		/* 8208BE74h case    1:*/		return 0x8208BE78;
		  /* 8208BE78h */ case    2:  		/* add R10, R11, R31 */
		/* 8208BE78h case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R31);
		/* 8208BE78h case    2:*/		return 0x8208BE7C;
		  /* 8208BE7Ch */ case    3:  		/* rlwinm R11, R10, 0, 0, 15 */
		/* 8208BE7Ch case    3:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R10);
		/* 8208BE7Ch case    3:*/		return 0x8208BE80;
		  /* 8208BE80h */ case    4:  		/* subf R8, R11, R10 */
		/* 8208BE80h case    4:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R11,regs.R10);
		/* 8208BE80h case    4:*/		return 0x8208BE84;
		  /* 8208BE84h */ case    5:  		/* srawi R8, R8, 4 */
		/* 8208BE84h case    5:*/		cpu::op::srawi<0,4>(regs,&regs.R8,regs.R8);
		/* 8208BE84h case    5:*/		return 0x8208BE88;
		  /* 8208BE88h */ case    6:  		/* rlwinm R27, R8, 0, 16, 31 */
		/* 8208BE88h case    6:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R27,regs.R8);
		/* 8208BE88h case    6:*/		return 0x8208BE8C;
		  /* 8208BE8Ch */ case    7:  		/* mr R8, R27 */
		/* 8208BE8Ch case    7:*/		regs.R8 = regs.R27;
		/* 8208BE8Ch case    7:*/		return 0x8208BE90;
		  /* 8208BE90h */ case    8:  		/* cmplwi CR6, R27, 1 */
		/* 8208BE90h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000001);
		/* 8208BE90h case    8:*/		return 0x8208BE94;
		  /* 8208BE94h */ case    9:  		/* bc 4, CR6_EQ, 16 */
		/* 8208BE94h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8208BEA4;  }
		/* 8208BE94h case    9:*/		return 0x8208BE98;
		  /* 8208BE98h */ case   10:  		/* li R27, 4097 */
		/* 8208BE98h case   10:*/		cpu::op::li<0>(regs,&regs.R27,0x1001);
		/* 8208BE98h case   10:*/		return 0x8208BE9C;
		  /* 8208BE9Ch */ case   11:  		/* subf R11, R7, R11 */
		/* 8208BE9Ch case   11:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 8208BE9Ch case   11:*/		return 0x8208BEA0;
		  /* 8208BEA0h */ case   12:  		/* b 28 */
		/* 8208BEA0h case   12:*/		return 0x8208BEBC;
		/* 8208BEA0h case   12:*/		return 0x8208BEA4;
	}
	return 0x8208BEA4;
} // Block from 8208BE70h-8208BEA4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8208BEA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BEA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BEA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BEA4);
		  /* 8208BEA4h */ case    0:  		/* cmplwi CR6, R8, 0 */
		/* 8208BEA4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8208BEA4h case    0:*/		return 0x8208BEA8;
		  /* 8208BEA8h */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 8208BEA8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8208BEBC;  }
		/* 8208BEA8h case    1:*/		return 0x8208BEAC;
		  /* 8208BEACh */ case    2:  		/* lbz R8, <#[R31 + 5]> */
		/* 8208BEACh case    2:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000005) );
		/* 8208BEACh case    2:*/		return 0x8208BEB0;
		  /* 8208BEB0h */ case    3:  		/* rlwinm. R8, R8, 0, 27, 27 */
		/* 8208BEB0h case    3:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R8,regs.R8);
		/* 8208BEB0h case    3:*/		return 0x8208BEB4;
		  /* 8208BEB4h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 8208BEB4h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8208BEBC;  }
		/* 8208BEB4h case    4:*/		return 0x8208BEB8;
		  /* 8208BEB8h */ case    5:  		/* mr R20, R10 */
		/* 8208BEB8h case    5:*/		regs.R20 = regs.R10;
		/* 8208BEB8h case    5:*/		return 0x8208BEBC;
	}
	return 0x8208BEBC;
} // Block from 8208BEA4h-8208BEBCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208BEBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BEBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BEBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BEBC);
		  /* 8208BEBCh */ case    0:  		/* rlwinm R22, R27, 4, 12, 27 */
		/* 8208BEBCh case    0:*/		cpu::op::rlwinm<0,4,12,27>(regs,&regs.R22,regs.R27);
		/* 8208BEBCh case    0:*/		return 0x8208BEC0;
		  /* 8208BEC0h */ case    1:  		/* cmplw CR6, R11, R9 */
		/* 8208BEC0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8208BEC0h case    1:*/		return 0x8208BEC4;
		  /* 8208BEC4h */ case    2:  		/* rlwinm R21, R27, 0, 16, 31 */
		/* 8208BEC4h case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R21,regs.R27);
		/* 8208BEC4h case    2:*/		return 0x8208BEC8;
		  /* 8208BEC8h */ case    3:  		/* subf R28, R22, R10 */
		/* 8208BEC8h case    3:*/		cpu::op::subf<0>(regs,&regs.R28,regs.R22,regs.R10);
		/* 8208BEC8h case    3:*/		return 0x8208BECC;
		  /* 8208BECCh */ case    4:  		/* subf R11, R9, R11 */
		/* 8208BECCh case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8208BECCh case    4:*/		return 0x8208BED0;
		  /* 8208BED0h */ case    5:  		/* bc 12, CR6_GT, 8 */
		/* 8208BED0h case    5:*/		if ( regs.CR[6].gt ) { return 0x8208BED8;  }
		/* 8208BED0h case    5:*/		return 0x8208BED4;
		  /* 8208BED4h */ case    6:  		/* mr R11, R19 */
		/* 8208BED4h case    6:*/		regs.R11 = regs.R19;
		/* 8208BED4h case    6:*/		return 0x8208BED8;
	}
	return 0x8208BED8;
} // Block from 8208BEBCh-8208BED8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208BED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BED8);
		  /* 8208BED8h */ case    0:  		/* stw R11, <#[R1 + 80]> */
		/* 8208BED8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208BED8h case    0:*/		return 0x8208BEDC;
		  /* 8208BEDCh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8208BEDCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208BEDCh case    1:*/		return 0x8208BEE0;
		  /* 8208BEE0h */ case    2:  		/* bc 12, CR6_EQ, 584 */
		/* 8208BEE0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8208C128;  }
		/* 8208BEE0h case    2:*/		return 0x8208BEE4;
		  /* 8208BEE4h */ case    3:  		/* mr R3, R25 */
		/* 8208BEE4h case    3:*/		regs.R3 = regs.R25;
		/* 8208BEE4h case    3:*/		return 0x8208BEE8;
		  /* 8208BEE8h */ case    4:  		/* bl -5536 */
		/* 8208BEE8h case    4:*/		regs.LR = 0x8208BEEC; return 0x8208A948;
		/* 8208BEE8h case    4:*/		return 0x8208BEEC;
		  /* 8208BEECh */ case    5:  		/* or. R30, R3, R3 */
		/* 8208BEECh case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 8208BEECh case    5:*/		return 0x8208BEF0;
		  /* 8208BEF0h */ case    6:  		/* bc 12, CR0_EQ, 568 */
		/* 8208BEF0h case    6:*/		if ( regs.CR[0].eq ) { return 0x8208C128;  }
		/* 8208BEF0h case    6:*/		return 0x8208BEF4;
		  /* 8208BEF4h */ case    7:  		/* li R5, 16384 */
		/* 8208BEF4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x4000);
		/* 8208BEF4h case    7:*/		return 0x8208BEF8;
		  /* 8208BEF8h */ case    8:  		/* lwz R6, <#[R29 + 1424]> */
		/* 8208BEF8h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R29 + 0x00000590) );
		/* 8208BEF8h case    8:*/		return 0x8208BEFC;
		  /* 8208BEFCh */ case    9:  		/* addi R4, R1, 80 */
		/* 8208BEFCh case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8208BEFCh case    9:*/		return 0x8208BF00;
	}
	return 0x8208BF00;
} // Block from 8208BED8h-8208BF00h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8208BF00h
// Function 'XMemAlloc'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BF00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BF00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BF00);
		  /* 8208BF00h */ case    0:  		/* addi R3, R1, 84 */
		/* 8208BF00h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x54);
		/* 8208BF00h case    0:*/		return 0x8208BF04;
		  /* 8208BF04h */ case    1:  		/* bl 1971540 */
		/* 8208BF04h case    1:*/		regs.LR = 0x8208BF08; return 0x8226D458;
		/* 8208BF04h case    1:*/		return 0x8208BF08;
		  /* 8208BF08h */ case    2:  		/* lwz R11, <#[R25 + 24]> */
		/* 8208BF08h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000018) );
		/* 8208BF08h case    2:*/		return 0x8208BF0C;
		  /* 8208BF0Ch */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 8208BF0Ch case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208BF0Ch case    3:*/		return 0x8208BF10;
		  /* 8208BF10h */ case    4:  		/* lwz R11, <#[R11 + 76]> */
		/* 8208BF10h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 8208BF10h case    4:*/		return 0x8208BF14;
		  /* 8208BF14h */ case    5:  		/* stw R11, <#[R30]> */
		/* 8208BF14h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8208BF14h case    5:*/		return 0x8208BF18;
		  /* 8208BF18h */ case    6:  		/* lwz R11, <#[R25 + 24]> */
		/* 8208BF18h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000018) );
		/* 8208BF18h case    6:*/		return 0x8208BF1C;
		  /* 8208BF1Ch */ case    7:  		/* stw R30, <#[R11 + 76]> */
		/* 8208BF1Ch case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x0000004C) );
		/* 8208BF1Ch case    7:*/		return 0x8208BF20;
		  /* 8208BF20h */ case    8:  		/* stw R19, <#[R30 + 4]> */
		/* 8208BF20h case    8:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R30 + 0x00000004) );
		/* 8208BF20h case    8:*/		return 0x8208BF24;
		  /* 8208BF24h */ case    9:  		/* stw R19, <#[R30 + 8]> */
		/* 8208BF24h case    9:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R30 + 0x00000008) );
		/* 8208BF24h case    9:*/		return 0x8208BF28;
		  /* 8208BF28h */ case   10:  		/* bc 12, CR0_LT, 512 */
		/* 8208BF28h case   10:*/		if ( regs.CR[0].lt ) { return 0x8208C128;  }
		/* 8208BF28h case   10:*/		return 0x8208BF2C;
		  /* 8208BF2Ch */ case   11:  		/* mr R3, R25 */
		/* 8208BF2Ch case   11:*/		regs.R3 = regs.R25;
		/* 8208BF2Ch case   11:*/		return 0x8208BF30;
		  /* 8208BF30h */ case   12:  		/* lwz R5, <#[R1 + 80]> */
		/* 8208BF30h case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 8208BF30h case   12:*/		return 0x8208BF34;
		  /* 8208BF34h */ case   13:  		/* lwz R4, <#[R1 + 84]> */
		/* 8208BF34h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 8208BF34h case   13:*/		return 0x8208BF38;
		  /* 8208BF38h */ case   14:  		/* bl -5144 */
		/* 8208BF38h case   14:*/		regs.LR = 0x8208BF3C; return 0x8208AB20;
		/* 8208BF38h case   14:*/		return 0x8208BF3C;
		  /* 8208BF3Ch */ case   15:  		/* lwz R9, <#[R1 + 80]> */
		/* 8208BF3Ch case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 8208BF3Ch case   15:*/		return 0x8208BF40;
		  /* 8208BF40h */ case   16:  		/* lwz R10, <#[R25 + 48]> */
		/* 8208BF40h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000030) );
		/* 8208BF40h case   16:*/		return 0x8208BF44;
		  /* 8208BF44h */ case   17:  		/* rlwinm. R11, R26, 0, 16, 31 */
		/* 8208BF44h case   17:*/		cpu::op::rlwinm<1,0,16,31>(regs,&regs.R11,regs.R26);
		/* 8208BF44h case   17:*/		return 0x8208BF48;
		  /* 8208BF48h */ case   18:  		/* rlwinm R9, R9, 16, 16, 31 */
		/* 8208BF48h case   18:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R9,regs.R9);
		/* 8208BF48h case   18:*/		return 0x8208BF4C;
		  /* 8208BF4Ch */ case   19:  		/* li R8, 1 */
		/* 8208BF4Ch case   19:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8208BF4Ch case   19:*/		return 0x8208BF50;
		  /* 8208BF50h */ case   20:  		/* add R10, R9, R10 */
		/* 8208BF50h case   20:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8208BF50h case   20:*/		return 0x8208BF54;
		  /* 8208BF54h */ case   21:  		/* stw R10, <#[R25 + 48]> */
		/* 8208BF54h case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R25 + 0x00000030) );
		/* 8208BF54h case   21:*/		return 0x8208BF58;
		  /* 8208BF58h */ case   22:  		/* bc 12, CR0_EQ, 184 */
		/* 8208BF58h case   22:*/		if ( regs.CR[0].eq ) { return 0x8208C010;  }
		/* 8208BF58h case   22:*/		return 0x8208BF5C;
		  /* 8208BF5Ch */ case   23:  		/* li R10, 16 */
		/* 8208BF5Ch case   23:*/		cpu::op::li<0>(regs,&regs.R10,0x10);
		/* 8208BF5Ch case   23:*/		return 0x8208BF60;
		  /* 8208BF60h */ case   24:  		/* sth R26, <#[R31]> */
		/* 8208BF60h case   24:*/		cpu::mem::store16( regs, regs.R26, (uint32)(regs.R31 + 0x00000000) );
		/* 8208BF60h case   24:*/		return 0x8208BF64;
		  /* 8208BF64h */ case   25:  		/* cmplwi CR6, R11, 128 */
		/* 8208BF64h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 8208BF64h case   25:*/		return 0x8208BF68;
		  /* 8208BF68h */ case   26:  		/* stb R10, <#[R31 + 5]> */
		/* 8208BF68h case   26:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x00000005) );
		/* 8208BF68h case   26:*/		return 0x8208BF6C;
		  /* 8208BF6Ch */ case   27:  		/* lwz R10, <#[R29 + 48]> */
		/* 8208BF6Ch case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000030) );
		/* 8208BF6Ch case   27:*/		return 0x8208BF70;
		  /* 8208BF70h */ case   28:  		/* add R10, R11, R10 */
		/* 8208BF70h case   28:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 8208BF70h case   28:*/		return 0x8208BF74;
		  /* 8208BF74h */ case   29:  		/* stw R10, <#[R29 + 48]> */
		/* 8208BF74h case   29:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000030) );
		/* 8208BF74h case   29:*/		return 0x8208BF78;
		  /* 8208BF78h */ case   30:  		/* stw R31, <#[R25 + 64]> */
		/* 8208BF78h case   30:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R25 + 0x00000040) );
		/* 8208BF78h case   30:*/		return 0x8208BF7C;
		  /* 8208BF7Ch */ case   31:  		/* lbz R10, <#[R31 + 5]> */
		/* 8208BF7Ch case   31:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000005) );
		/* 8208BF7Ch case   31:*/		return 0x8208BF80;
		  /* 8208BF80h */ case   32:  		/* rlwinm R10, R10, 0, 0, 28 */
		/* 8208BF80h case   32:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R10,regs.R10);
		/* 8208BF80h case   32:*/		return 0x8208BF84;
		  /* 8208BF84h */ case   33:  		/* stb R10, <#[R31 + 5]> */
		/* 8208BF84h case   33:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x00000005) );
		/* 8208BF84h case   33:*/		return 0x8208BF88;
		  /* 8208BF88h */ case   34:  		/* bc 4, CR6_LT, 68 */
		/* 8208BF88h case   34:*/		if ( !regs.CR[6].lt ) { return 0x8208BFCC;  }
		/* 8208BF88h case   34:*/		return 0x8208BF8C;
		  /* 8208BF8Ch */ case   35:  		/* addi R11, R11, 48 */
		/* 8208BF8Ch case   35:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x30);
		/* 8208BF8Ch case   35:*/		return 0x8208BF90;
		  /* 8208BF90h */ case   36:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8208BF90h case   36:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8208BF90h case   36:*/		return 0x8208BF94;
		  /* 8208BF94h */ case   37:  		/* add R11, R11, R29 */
		/* 8208BF94h case   37:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8208BF94h case   37:*/		return 0x8208BF98;
		  /* 8208BF98h */ case   38:  		/* lwz R10, <#[R11]> */
		/* 8208BF98h case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208BF98h case   38:*/		return 0x8208BF9C;
		  /* 8208BF9Ch */ case   39:  		/* cmplw CR6, R10, R11 */
		/* 8208BF9Ch case   39:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208BF9Ch case   39:*/		return 0x8208BFA0;
		  /* 8208BFA0h */ case   40:  		/* bc 4, CR6_EQ, 84 */
		/* 8208BFA0h case   40:*/		if ( !regs.CR[6].eq ) { return 0x8208BFF4;  }
		/* 8208BFA0h case   40:*/		return 0x8208BFA4;
		  /* 8208BFA4h */ case   41:  		/* lhz R9, <#[R31]> */
		/* 8208BFA4h case   41:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8208BFA4h case   41:*/		return 0x8208BFA8;
		  /* 8208BFA8h */ case   42:  		/* rlwinm R10, R9, 27, 5, 31 */
		/* 8208BFA8h case   42:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R9);
		/* 8208BFA8h case   42:*/		return 0x8208BFAC;
		  /* 8208BFACh */ case   43:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 8208BFACh case   43:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8208BFACh case   43:*/		return 0x8208BFB0;
		  /* 8208BFB0h */ case   44:  		/* addi R10, R10, 88 */
		/* 8208BFB0h case   44:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x58);
		/* 8208BFB0h case   44:*/		return 0x8208BFB4;
		  /* 8208BFB4h */ case   45:  		/* slw R9, R8, R9 */
		/* 8208BFB4h case   45:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8208BFB4h case   45:*/		return 0x8208BFB8;
		  /* 8208BFB8h */ case   46:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8208BFB8h case   46:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8208BFB8h case   46:*/		return 0x8208BFBC;
		  /* 8208BFBCh */ case   47:  		/* lwzx R7, <#[R10 + R29]> */
		/* 8208BFBCh case   47:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 8208BFBCh case   47:*/		return 0x8208BFC0;
		  /* 8208BFC0h */ case   48:  		/* or R9, R9, R7 */
		/* 8208BFC0h case   48:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 8208BFC0h case   48:*/		return 0x8208BFC4;
		  /* 8208BFC4h */ case   49:  		/* stwx R9, <#[R10 + R29]> */
		/* 8208BFC4h case   49:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 8208BFC4h case   49:*/		return 0x8208BFC8;
		  /* 8208BFC8h */ case   50:  		/* b 44 */
		/* 8208BFC8h case   50:*/		return 0x8208BFF4;
		/* 8208BFC8h case   50:*/		return 0x8208BFCC;
	}
	return 0x8208BFCC;
} // Block from 8208BF00h-8208BFCCh (51 instructions)

//////////////////////////////////////////////////////
// Block at 8208BFCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BFCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BFCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BFCC);
		  /* 8208BFCCh */ case    0:  		/* lwz R10, <#[R29 + 384]> */
		/* 8208BFCCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000180) );
		/* 8208BFCCh case    0:*/		return 0x8208BFD0;
		  /* 8208BFD0h */ case    1:  		/* addi R9, R29, 384 */
		/* 8208BFD0h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R29,0x180);
		/* 8208BFD0h case    1:*/		return 0x8208BFD4;
		  /* 8208BFD4h */ case    2:  		/* b 20 */
		/* 8208BFD4h case    2:*/		return 0x8208BFE8;
		/* 8208BFD4h case    2:*/		return 0x8208BFD8;
		  /* 8208BFD8h */ case    3:  		/* lhz R7, <#[R10 - 8]> */
		/* 8208BFD8h case    3:*/		cpu::mem::load16z( regs, &regs.R7, (uint32)(regs.R10 + 0xFFFFFFF8) );
		/* 8208BFD8h case    3:*/		return 0x8208BFDC;
		  /* 8208BFDCh */ case    4:  		/* cmplw CR6, R11, R7 */
		/* 8208BFDCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 8208BFDCh case    4:*/		return 0x8208BFE0;
		  /* 8208BFE0h */ case    5:  		/* bc 4, CR6_GT, 16 */
		/* 8208BFE0h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8208BFF0;  }
		/* 8208BFE0h case    5:*/		return 0x8208BFE4;
		  /* 8208BFE4h */ case    6:  		/* lwz R10, <#[R10]> */
		/* 8208BFE4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 8208BFE4h case    6:*/		return 0x8208BFE8;
	}
	return 0x8208BFE8;
} // Block from 8208BFCCh-8208BFE8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208BFE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BFE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BFE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BFE8);
		  /* 8208BFE8h */ case    0:  		/* cmplw CR6, R9, R10 */
		/* 8208BFE8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 8208BFE8h case    0:*/		return 0x8208BFEC;
		  /* 8208BFECh */ case    1:  		/* bc 4, CR6_EQ, -20 */
		/* 8208BFECh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8208BFD8;  }
		/* 8208BFECh case    1:*/		return 0x8208BFF0;
	}
	return 0x8208BFF0;
} // Block from 8208BFE8h-8208BFF0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208BFF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BFF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BFF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BFF0);
		  /* 8208BFF0h */ case    0:  		/* mr R11, R10 */
		/* 8208BFF0h case    0:*/		regs.R11 = regs.R10;
		/* 8208BFF0h case    0:*/		return 0x8208BFF4;
	}
	return 0x8208BFF4;
} // Block from 8208BFF0h-8208BFF4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208BFF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208BFF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208BFF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208BFF4);
		  /* 8208BFF4h */ case    0:  		/* lwz R9, <#[R11 + 4]> */
		/* 8208BFF4h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8208BFF4h case    0:*/		return 0x8208BFF8;
		  /* 8208BFF8h */ case    1:  		/* addi R10, R31, 8 */
		/* 8208BFF8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x8);
		/* 8208BFF8h case    1:*/		return 0x8208BFFC;
		  /* 8208BFFCh */ case    2:  		/* stw R11, <#[R31 + 8]> */
		/* 8208BFFCh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8208BFFCh case    2:*/		return 0x8208C000;
		  /* 8208C000h */ case    3:  		/* stw R9, <#[R31 + 12]> */
		/* 8208C000h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 8208C000h case    3:*/		return 0x8208C004;
		  /* 8208C004h */ case    4:  		/* stw R10, <#[R9]> */
		/* 8208C004h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8208C004h case    4:*/		return 0x8208C008;
		  /* 8208C008h */ case    5:  		/* stw R10, <#[R11 + 4]> */
		/* 8208C008h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8208C008h case    5:*/		return 0x8208C00C;
		  /* 8208C00Ch */ case    6:  		/* b 72 */
		/* 8208C00Ch case    6:*/		return 0x8208C054;
		/* 8208C00Ch case    6:*/		return 0x8208C010;
	}
	return 0x8208C010;
} // Block from 8208BFF4h-8208C010h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208C010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C010);
		  /* 8208C010h */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 8208C010h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 8208C010h case    0:*/		return 0x8208C014;
		  /* 8208C014h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 8208C014h case    1:*/		if ( regs.CR[6].eq ) { return 0x8208C02C;  }
		/* 8208C014h case    1:*/		return 0x8208C018;
		  /* 8208C018h */ case    2:  		/* lbz R11, <#[R23 + 5]> */
		/* 8208C018h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000005) );
		/* 8208C018h case    2:*/		return 0x8208C01C;
		  /* 8208C01Ch */ case    3:  		/* ori R11, R11, 16 */
		/* 8208C01Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8208C01Ch case    3:*/		return 0x8208C020;
		  /* 8208C020h */ case    4:  		/* stb R11, <#[R23 + 5]> */
		/* 8208C020h case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R23 + 0x00000005) );
		/* 8208C020h case    4:*/		return 0x8208C024;
		  /* 8208C024h */ case    5:  		/* stw R23, <#[R25 + 64]> */
		/* 8208C024h case    5:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R25 + 0x00000040) );
		/* 8208C024h case    5:*/		return 0x8208C028;
		  /* 8208C028h */ case    6:  		/* b 44 */
		/* 8208C028h case    6:*/		return 0x8208C054;
		/* 8208C028h case    6:*/		return 0x8208C02C;
	}
	return 0x8208C02C;
} // Block from 8208C010h-8208C02Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208C02Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C02C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C02C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C02C);
		  /* 8208C02Ch */ case    0:  		/* lwz R11, <#[R25 + 64]> */
		/* 8208C02Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000040) );
		/* 8208C02Ch case    0:*/		return 0x8208C030;
		  /* 8208C030h */ case    1:  		/* lwz R10, <#[R1 + 84]> */
		/* 8208C030h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 8208C030h case    1:*/		return 0x8208C034;
		  /* 8208C034h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 8208C034h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8208C034h case    2:*/		return 0x8208C038;
	}
	return 0x8208C038;
} // Block from 8208C02Ch-8208C038h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208C038h
// Function 'XMemFree'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C038);
		  /* 8208C038h */ case    0:  		/* bc 12, CR6_LT, 28 */
		/* 8208C038h case    0:*/		if ( regs.CR[6].lt ) { return 0x8208C054;  }
		/* 8208C038h case    0:*/		return 0x8208C03C;
		  /* 8208C03Ch */ case    1:  		/* lwz R9, <#[R1 + 80]> */
		/* 8208C03Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 8208C03Ch case    1:*/		return 0x8208C040;
		  /* 8208C040h */ case    2:  		/* add R10, R9, R10 */
		/* 8208C040h case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8208C040h case    2:*/		return 0x8208C044;
		  /* 8208C044h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 8208C044h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8208C044h case    3:*/		return 0x8208C048;
		  /* 8208C048h */ case    4:  		/* bc 4, CR6_LT, 12 */
		/* 8208C048h case    4:*/		if ( !regs.CR[6].lt ) { return 0x8208C054;  }
		/* 8208C048h case    4:*/		return 0x8208C04C;
		  /* 8208C04Ch */ case    5:  		/* lwz R11, <#[R25 + 40]> */
		/* 8208C04Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000028) );
		/* 8208C04Ch case    5:*/		return 0x8208C050;
		  /* 8208C050h */ case    6:  		/* stw R11, <#[R25 + 64]> */
		/* 8208C050h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000040) );
		/* 8208C050h case    6:*/		return 0x8208C054;
	}
	return 0x8208C054;
} // Block from 8208C038h-8208C054h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208C054h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C054( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C054) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C054);
		  /* 8208C054h */ case    0:  		/* cmplwi CR6, R21, 0 */
		/* 8208C054h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 8208C054h case    0:*/		return 0x8208C058;
	}
	return 0x8208C058;
} // Block from 8208C054h-8208C058h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208C058h
// Function 'GetCurrentThreadId'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C058);
		  /* 8208C058h */ case    0:  		/* bc 12, CR6_EQ, 192 */
		/* 8208C058h case    0:*/		if ( regs.CR[6].eq ) { return 0x8208C118;  }
		/* 8208C058h case    0:*/		return 0x8208C05C;
		  /* 8208C05Ch */ case    1:  		/* add R11, R22, R28 */
		/* 8208C05Ch case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R22,regs.R28);
		/* 8208C05Ch case    1:*/		return 0x8208C060;
		  /* 8208C060h */ case    2:  		/* sth R19, <#[R28 + 2]> */
		/* 8208C060h case    2:*/		cpu::mem::store16( regs, regs.R19, (uint32)(regs.R28 + 0x00000002) );
		/* 8208C060h case    2:*/		return 0x8208C064;
		  /* 8208C064h */ case    3:  		/* lbz R10, <#[R25 + 4]> */
		/* 8208C064h case    3:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 8208C064h case    3:*/		return 0x8208C068;
	}
	return 0x8208C068;
} // Block from 8208C058h-8208C068h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208C068h
// Function 'OutputDebugStringA'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C068);
		  /* 8208C068h */ case    0:  		/* cmplwi CR6, R21, 128 */
		/* 8208C068h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000080);
		/* 8208C068h case    0:*/		return 0x8208C06C;
		  /* 8208C06Ch */ case    1:  		/* stb R19, <#[R28 + 5]> */
		/* 8208C06Ch case    1:*/		cpu::mem::store8( regs, regs.R19, (uint32)(regs.R28 + 0x00000005) );
		/* 8208C06Ch case    1:*/		return 0x8208C070;
		  /* 8208C070h */ case    2:  		/* stb R10, <#[R28 + 4]> */
		/* 8208C070h case    2:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R28 + 0x00000004) );
		/* 8208C070h case    2:*/		return 0x8208C074;
		  /* 8208C074h */ case    3:  		/* sth R27, <#[R28]> */
		/* 8208C074h case    3:*/		cpu::mem::store16( regs, regs.R27, (uint32)(regs.R28 + 0x00000000) );
		/* 8208C074h case    3:*/		return 0x8208C078;
		  /* 8208C078h */ case    4:  		/* sth R27, <#[R11 + 2]> */
		/* 8208C078h case    4:*/		cpu::mem::store16( regs, regs.R27, (uint32)(regs.R11 + 0x00000002) );
		/* 8208C078h case    4:*/		return 0x8208C07C;
		  /* 8208C07Ch */ case    5:  		/* lbz R11, <#[R28 + 5]> */
		/* 8208C07Ch case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000005) );
		/* 8208C07Ch case    5:*/		return 0x8208C080;
		  /* 8208C080h */ case    6:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 8208C080h case    6:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 8208C080h case    6:*/		return 0x8208C084;
		  /* 8208C084h */ case    7:  		/* stb R11, <#[R28 + 5]> */
		/* 8208C084h case    7:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R28 + 0x00000005) );
		/* 8208C084h case    7:*/		return 0x8208C088;
		  /* 8208C088h */ case    8:  		/* bc 4, CR6_LT, 68 */
		/* 8208C088h case    8:*/		if ( !regs.CR[6].lt ) { return 0x8208C0CC;  }
		/* 8208C088h case    8:*/		return 0x8208C08C;
		  /* 8208C08Ch */ case    9:  		/* addi R11, R21, 48 */
		/* 8208C08Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R21,0x30);
		/* 8208C08Ch case    9:*/		return 0x8208C090;
		  /* 8208C090h */ case   10:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8208C090h case   10:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8208C090h case   10:*/		return 0x8208C094;
		  /* 8208C094h */ case   11:  		/* add R11, R11, R29 */
		/* 8208C094h case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8208C094h case   11:*/		return 0x8208C098;
		  /* 8208C098h */ case   12:  		/* lwz R10, <#[R11]> */
		/* 8208C098h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208C098h case   12:*/		return 0x8208C09C;
		  /* 8208C09Ch */ case   13:  		/* cmplw CR6, R10, R11 */
		/* 8208C09Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208C09Ch case   13:*/		return 0x8208C0A0;
		  /* 8208C0A0h */ case   14:  		/* bc 4, CR6_EQ, 80 */
		/* 8208C0A0h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8208C0F0;  }
		/* 8208C0A0h case   14:*/		return 0x8208C0A4;
		  /* 8208C0A4h */ case   15:  		/* lhz R9, <#[R28]> */
		/* 8208C0A4h case   15:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000000) );
		/* 8208C0A4h case   15:*/		return 0x8208C0A8;
	}
	return 0x8208C0A8;
} // Block from 8208C068h-8208C0A8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8208C0A8h
// Function 'RtlSleep'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C0A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C0A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C0A8);
		  /* 8208C0A8h */ case    0:  		/* rlwinm R10, R9, 27, 5, 31 */
		/* 8208C0A8h case    0:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R9);
		/* 8208C0A8h case    0:*/		return 0x8208C0AC;
		  /* 8208C0ACh */ case    1:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 8208C0ACh case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8208C0ACh case    1:*/		return 0x8208C0B0;
		  /* 8208C0B0h */ case    2:  		/* addi R10, R10, 88 */
		/* 8208C0B0h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x58);
		/* 8208C0B0h case    2:*/		return 0x8208C0B4;
		  /* 8208C0B4h */ case    3:  		/* slw R9, R8, R9 */
		/* 8208C0B4h case    3:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8208C0B4h case    3:*/		return 0x8208C0B8;
		  /* 8208C0B8h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8208C0B8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8208C0B8h case    4:*/		return 0x8208C0BC;
		  /* 8208C0BCh */ case    5:  		/* lwzx R8, <#[R10 + R29]> */
		/* 8208C0BCh case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 8208C0BCh case    5:*/		return 0x8208C0C0;
		  /* 8208C0C0h */ case    6:  		/* or R9, R9, R8 */
		/* 8208C0C0h case    6:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8208C0C0h case    6:*/		return 0x8208C0C4;
		  /* 8208C0C4h */ case    7:  		/* stwx R9, <#[R10 + R29]> */
		/* 8208C0C4h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 8208C0C4h case    7:*/		return 0x8208C0C8;
		  /* 8208C0C8h */ case    8:  		/* b 40 */
		/* 8208C0C8h case    8:*/		return 0x8208C0F0;
		/* 8208C0C8h case    8:*/		return 0x8208C0CC;
	}
	return 0x8208C0CC;
} // Block from 8208C0A8h-8208C0CCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 8208C0CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C0CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C0CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C0CC);
		  /* 8208C0CCh */ case    0:  		/* lwz R11, <#[R29 + 384]> */
		/* 8208C0CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000180) );
		/* 8208C0CCh case    0:*/		return 0x8208C0D0;
		  /* 8208C0D0h */ case    1:  		/* addi R10, R29, 384 */
		/* 8208C0D0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0x180);
		/* 8208C0D0h case    1:*/		return 0x8208C0D4;
		  /* 8208C0D4h */ case    2:  		/* b 20 */
		/* 8208C0D4h case    2:*/		return 0x8208C0E8;
		/* 8208C0D4h case    2:*/		return 0x8208C0D8;
		  /* 8208C0D8h */ case    3:  		/* lhz R9, <#[R11 - 8]> */
		/* 8208C0D8h case    3:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 8208C0D8h case    3:*/		return 0x8208C0DC;
		  /* 8208C0DCh */ case    4:  		/* cmplw CR6, R21, R9 */
		/* 8208C0DCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R9);
		/* 8208C0DCh case    4:*/		return 0x8208C0E0;
		  /* 8208C0E0h */ case    5:  		/* bc 4, CR6_GT, 16 */
		/* 8208C0E0h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8208C0F0;  }
		/* 8208C0E0h case    5:*/		return 0x8208C0E4;
		  /* 8208C0E4h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 8208C0E4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8208C0E4h case    6:*/		return 0x8208C0E8;
	}
	return 0x8208C0E8;
} // Block from 8208C0CCh-8208C0E8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208C0E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C0E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C0E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C0E8);
		  /* 8208C0E8h */ case    0:  		/* cmplw CR6, R10, R11 */
		/* 8208C0E8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208C0E8h case    0:*/		return 0x8208C0EC;
		  /* 8208C0ECh */ case    1:  		/* bc 4, CR6_EQ, -20 */
		/* 8208C0ECh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8208C0D8;  }
		/* 8208C0ECh case    1:*/		return 0x8208C0F0;
	}
	return 0x8208C0F0;
} // Block from 8208C0E8h-8208C0F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208C0F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C0F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C0F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C0F0);
		  /* 8208C0F0h */ case    0:  		/* lwz R9, <#[R11 + 4]> */
		/* 8208C0F0h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8208C0F0h case    0:*/		return 0x8208C0F4;
		  /* 8208C0F4h */ case    1:  		/* addi R10, R28, 8 */
		/* 8208C0F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0x8);
		/* 8208C0F4h case    1:*/		return 0x8208C0F8;
		  /* 8208C0F8h */ case    2:  		/* stw R11, <#[R28 + 8]> */
		/* 8208C0F8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8208C0F8h case    2:*/		return 0x8208C0FC;
		  /* 8208C0FCh */ case    3:  		/* stw R9, <#[R28 + 12]> */
		/* 8208C0FCh case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R28 + 0x0000000C) );
		/* 8208C0FCh case    3:*/		return 0x8208C100;
		  /* 8208C100h */ case    4:  		/* stw R10, <#[R9]> */
		/* 8208C100h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8208C100h case    4:*/		return 0x8208C104;
		  /* 8208C104h */ case    5:  		/* stw R10, <#[R11 + 4]> */
		/* 8208C104h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8208C104h case    5:*/		return 0x8208C108;
		  /* 8208C108h */ case    6:  		/* lwz R11, <#[R29 + 48]> */
		/* 8208C108h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 8208C108h case    6:*/		return 0x8208C10C;
		  /* 8208C10Ch */ case    7:  		/* add R11, R21, R11 */
		/* 8208C10Ch case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R21,regs.R11);
		/* 8208C10Ch case    7:*/		return 0x8208C110;
		  /* 8208C110h */ case    8:  		/* stw R11, <#[R29 + 48]> */
		/* 8208C110h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 8208C110h case    8:*/		return 0x8208C114;
		  /* 8208C114h */ case    9:  		/* b 36 */
		/* 8208C114h case    9:*/		return 0x8208C138;
		/* 8208C114h case    9:*/		return 0x8208C118;
	}
	return 0x8208C118;
} // Block from 8208C0F0h-8208C118h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8208C118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C118);
		  /* 8208C118h */ case    0:  		/* cmplwi CR6, R20, 0 */
		/* 8208C118h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 8208C118h case    0:*/		return 0x8208C11C;
		  /* 8208C11Ch */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 8208C11Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8208C138;  }
		/* 8208C11Ch case    1:*/		return 0x8208C120;
		  /* 8208C120h */ case    2:  		/* sth R19, <#[R20 + 2]> */
		/* 8208C120h case    2:*/		cpu::mem::store16( regs, regs.R19, (uint32)(regs.R20 + 0x00000002) );
		/* 8208C120h case    2:*/		return 0x8208C124;
		  /* 8208C124h */ case    3:  		/* b 20 */
		/* 8208C124h case    3:*/		return 0x8208C138;
		/* 8208C124h case    3:*/		return 0x8208C128;
	}
	return 0x8208C128;
} // Block from 8208C118h-8208C128h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208C128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C128);
		  /* 8208C128h */ case    0:  		/* mr R5, R24 */
		/* 8208C128h case    0:*/		regs.R5 = regs.R24;
		/* 8208C128h case    0:*/		return 0x8208C12C;
		  /* 8208C12Ch */ case    1:  		/* mr R4, R31 */
		/* 8208C12Ch case    1:*/		regs.R4 = regs.R31;
		/* 8208C12Ch case    1:*/		return 0x8208C130;
		  /* 8208C130h */ case    2:  		/* mr R3, R29 */
		/* 8208C130h case    2:*/		regs.R3 = regs.R29;
		/* 8208C130h case    2:*/		return 0x8208C134;
		  /* 8208C134h */ case    3:  		/* bl -3676 */
		/* 8208C134h case    3:*/		regs.LR = 0x8208C138; return 0x8208B2D8;
		/* 8208C134h case    3:*/		return 0x8208C138;
	}
	return 0x8208C138;
} // Block from 8208C128h-8208C138h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208C138h
// Function 'Sleep'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C138);
		  /* 8208C138h */ case    0:  		/* addi R1, R1, 208 */
		/* 8208C138h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 8208C138h case    0:*/		return 0x8208C13C;
		  /* 8208C13Ch */ case    1:  		/* b 20808 */
		/* 8208C13Ch case    1:*/		return 0x82091284;
		/* 8208C13Ch case    1:*/		return 0x8208C140;
	}
	return 0x8208C140;
} // Block from 8208C138h-8208C140h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208C140h
// Function 'GetTickCount'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C140);
		  /* 8208C140h */ case    0:  		/* lwz R17, <#[R6 - 11576]> */
		/* 8208C140h case    0:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 8208C140h case    0:*/		return 0x8208C144;
		  /* 8208C144h */ case    1:  		/* lwz R16, <#[R4 - 15600]> */
		/* 8208C144h case    1:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC310) );
		/* 8208C144h case    1:*/		return 0x8208C148;
	}
	return 0x8208C148;
} // Block from 8208C140h-8208C148h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208C148h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C148);
		  /* 8208C148h */ case    0:  		/* mfspr R12, LR */
		/* 8208C148h case    0:*/		regs.R12 = regs.LR;
		/* 8208C148h case    0:*/		return 0x8208C14C;
		  /* 8208C14Ch */ case    1:  		/* bl 20716 */
		/* 8208C14Ch case    1:*/		regs.LR = 0x8208C150; return 0x82091238;
		/* 8208C14Ch case    1:*/		return 0x8208C150;
	}
	return 0x8208C150;
} // Block from 8208C148h-8208C150h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208C150h
// Function 'CreateFileA'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C150);
		  /* 8208C150h */ case    0:  		/* addi R31, R1, -288 */
		/* 8208C150h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFEE0);
		/* 8208C150h case    0:*/		return 0x8208C154;
		  /* 8208C154h */ case    1:  		/* stwu R1, <#[R1 - 288]> */
		/* 8208C154h case    1:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEE0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEE0);
		/* 8208C154h case    1:*/		return 0x8208C158;
		  /* 8208C158h */ case    2:  		/* mr R23, R3 */
		/* 8208C158h case    2:*/		regs.R23 = regs.R3;
		/* 8208C158h case    2:*/		return 0x8208C15C;
		  /* 8208C15Ch */ case    3:  		/* stw R3, <#[R31 + 308]> */
		/* 8208C15Ch case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000134) );
		/* 8208C15Ch case    3:*/		return 0x8208C160;
		  /* 8208C160h */ case    4:  		/* li R11, 6 */
		/* 8208C160h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x6);
		/* 8208C160h case    4:*/		return 0x8208C164;
		  /* 8208C164h */ case    5:  		/* li R21, 0 */
		/* 8208C164h case    5:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 8208C164h case    5:*/		return 0x8208C168;
		  /* 8208C168h */ case    6:  		/* addi R10, R31, 128 */
		/* 8208C168h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x80);
		/* 8208C168h case    6:*/		return 0x8208C16C;
		  /* 8208C16Ch */ case    7:  		/* mr R29, R4 */
		/* 8208C16Ch case    7:*/		regs.R29 = regs.R4;
		/* 8208C16Ch case    7:*/		return 0x8208C170;
		  /* 8208C170h */ case    8:  		/* stw R21, <#[R31 + 80]> */
		/* 8208C170h case    8:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C170h case    8:*/		return 0x8208C174;
		  /* 8208C174h */ case    9:  		/* mtspr CTR, R11 */
		/* 8208C174h case    9:*/		regs.CTR = regs.R11;
		/* 8208C174h case    9:*/		return 0x8208C178;
		  /* 8208C178h */ case   10:  		/* mr R20, R7 */
		/* 8208C178h case   10:*/		regs.R20 = regs.R7;
		/* 8208C178h case   10:*/		return 0x8208C17C;
		  /* 8208C17Ch */ case   11:  		/* stw R4, <#[R31 + 316]> */
		/* 8208C17Ch case   11:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R31 + 0x0000013C) );
		/* 8208C17Ch case   11:*/		return 0x8208C180;
		  /* 8208C180h */ case   12:  		/* mr R30, R21 */
		/* 8208C180h case   12:*/		regs.R30 = regs.R21;
		/* 8208C180h case   12:*/		return 0x8208C184;
		  /* 8208C184h */ case   13:  		/* stw R5, <#[R31 + 324]> */
		/* 8208C184h case   13:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R31 + 0x00000144) );
		/* 8208C184h case   13:*/		return 0x8208C188;
		  /* 8208C188h */ case   14:  		/* addi R11, R10, -8 */
		/* 8208C188h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFF8);
		/* 8208C188h case   14:*/		return 0x8208C18C;
		  /* 8208C18Ch */ case   15:  		/* stw R6, <#[R31 + 332]> */
		/* 8208C18Ch case   15:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R31 + 0x0000014C) );
		/* 8208C18Ch case   15:*/		return 0x8208C190;
		  /* 8208C190h */ case   16:  		/* stw R7, <#[R31 + 340]> */
		/* 8208C190h case   16:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x00000154) );
		/* 8208C190h case   16:*/		return 0x8208C194;
		  /* 8208C194h */ case   17:  		/* mr R10, R21 */
		/* 8208C194h case   17:*/		regs.R10 = regs.R21;
		/* 8208C194h case   17:*/		return 0x8208C198;
		  /* 8208C198h */ case   18:  		/* stdu R10, <#[R11 + 8]> */
		/* 8208C198h case   18:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		regs.R11 = (uint32)(regs.R11 + 0x00000008);
		/* 8208C198h case   18:*/		return 0x8208C19C;
		  /* 8208C19Ch */ case   19:  		/* bc 16, CR0_LT, -4 */
		/* 8208C19Ch case   19:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8208C198;  }
		/* 8208C19Ch case   19:*/		return 0x8208C1A0;
		  /* 8208C1A0h */ case   20:  		/* cmplwi CR6, R8, 0 */
		/* 8208C1A0h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8208C1A0h case   20:*/		return 0x8208C1A4;
		  /* 8208C1A4h */ case   21:  		/* bc 12, CR6_EQ, 104 */
		/* 8208C1A4h case   21:*/		if ( regs.CR[6].eq ) { return 0x8208C20C;  }
		/* 8208C1A4h case   21:*/		return 0x8208C1A8;
		  /* 8208C1A8h */ case   22:  		/* nop */
		/* 8208C1A8h case   22:*/		cpu::op::nop();
		/* 8208C1A8h case   22:*/		return 0x8208C1AC;
		  /* 8208C1ACh */ case   23:  		/* nop */
		/* 8208C1ACh case   23:*/		cpu::op::nop();
		/* 8208C1ACh case   23:*/		return 0x8208C1B0;
	}
	return 0x8208C1B0;
} // Block from 8208C150h-8208C1B0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8208C1B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C1B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C1B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C1B0);
		  /* 8208C1B0h */ case    0:  		/* lwz R11, <#[R8]> */
		/* 8208C1B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8208C1B0h case    0:*/		return 0x8208C1B4;
		  /* 8208C1B4h */ case    1:  		/* cmplwi CR6, R11, 48 */
		/* 8208C1B4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 8208C1B4h case    1:*/		return 0x8208C1B8;
		  /* 8208C1B8h */ case    2:  		/* bc 4, CR6_EQ, 24 */
		/* 8208C1B8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8208C1D0;  }
		/* 8208C1B8h case    2:*/		return 0x8208C1BC;
		  /* 8208C1BCh */ case    3:  		/* li R5, 48 */
		/* 8208C1BCh case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x30);
		/* 8208C1BCh case    3:*/		return 0x8208C1C0;
		  /* 8208C1C0h */ case    4:  		/* mr R4, R8 */
		/* 8208C1C0h case    4:*/		regs.R4 = regs.R8;
		/* 8208C1C0h case    4:*/		return 0x8208C1C4;
		  /* 8208C1C4h */ case    5:  		/* addi R3, R31, 128 */
		/* 8208C1C4h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x80);
		/* 8208C1C4h case    5:*/		return 0x8208C1C8;
		  /* 8208C1C8h */ case    6:  		/* bl 23896 */
		/* 8208C1C8h case    6:*/		regs.LR = 0x8208C1CC; return 0x82091F20;
		/* 8208C1C8h case    6:*/		return 0x8208C1CC;
		  /* 8208C1CCh */ case    7:  		/* lwz R5, <#[R31 + 324]> */
		/* 8208C1CCh case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000144) );
		/* 8208C1CCh case    7:*/		return 0x8208C1D0;
	}
	return 0x8208C1D0;
} // Block from 8208C1B0h-8208C1D0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8208C1D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C1D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C1D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C1D0);
		  /* 8208C1D0h */ case    0:  		/* nop */
		/* 8208C1D0h case    0:*/		cpu::op::nop();
		/* 8208C1D0h case    0:*/		return 0x8208C1D4;
		  /* 8208C1D4h */ case    1:  		/* nop */
		/* 8208C1D4h case    1:*/		cpu::op::nop();
		/* 8208C1D4h case    1:*/		return 0x8208C1D8;
		  /* 8208C1D8h */ case    2:  		/* nop */
		/* 8208C1D8h case    2:*/		cpu::op::nop();
		/* 8208C1D8h case    2:*/		return 0x8208C1DC;
		  /* 8208C1DCh */ case    3:  		/* b 28 */
		/* 8208C1DCh case    3:*/		return 0x8208C1F8;
		/* 8208C1DCh case    3:*/		return 0x8208C1E0;
	}
	return 0x8208C1E0;
} // Block from 8208C1D0h-8208C1E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208C1E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C1E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C1E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C1E0);
		  /* 8208C1E0h */ case    0:  		/* mr R30, R3 */
		/* 8208C1E0h case    0:*/		regs.R30 = regs.R3;
		/* 8208C1E0h case    0:*/		return 0x8208C1E4;
		  /* 8208C1E4h */ case    1:  		/* lwz R20, <#[R31 + 340]> */
		/* 8208C1E4h case    1:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R31 + 0x00000154) );
		/* 8208C1E4h case    1:*/		return 0x8208C1E8;
		  /* 8208C1E8h */ case    2:  		/* li R21, 0 */
		/* 8208C1E8h case    2:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 8208C1E8h case    2:*/		return 0x8208C1EC;
		  /* 8208C1ECh */ case    3:  		/* lwz R5, <#[R31 + 324]> */
		/* 8208C1ECh case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000144) );
		/* 8208C1ECh case    3:*/		return 0x8208C1F0;
		  /* 8208C1F0h */ case    4:  		/* lwz R29, <#[R31 + 316]> */
		/* 8208C1F0h case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x0000013C) );
		/* 8208C1F0h case    4:*/		return 0x8208C1F4;
		  /* 8208C1F4h */ case    5:  		/* lwz R23, <#[R31 + 308]> */
		/* 8208C1F4h case    5:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R31 + 0x00000134) );
		/* 8208C1F4h case    5:*/		return 0x8208C1F8;
	}
	return 0x8208C1F8;
} // Block from 8208C1E0h-8208C1F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208C1F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C1F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C1F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C1F8);
		  /* 8208C1F8h */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 8208C1F8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 8208C1F8h case    0:*/		return 0x8208C1FC;
		  /* 8208C1FCh */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 8208C1FCh case    1:*/		if ( !regs.CR[6].lt ) { return 0x8208C208;  }
		/* 8208C1FCh case    1:*/		return 0x8208C200;
		  /* 8208C200h */ case    2:  		/* li R3, 0 */
		/* 8208C200h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208C200h case    2:*/		return 0x8208C204;
		  /* 8208C204h */ case    3:  		/* b 1272 */
		/* 8208C204h case    3:*/		return 0x8208C6FC;
		/* 8208C204h case    3:*/		return 0x8208C208;
	}
	return 0x8208C208;
} // Block from 8208C1F8h-8208C208h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208C208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C208);
		  /* 8208C208h */ case    0:  		/* lwz R6, <#[R31 + 332]> */
		/* 8208C208h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x0000014C) );
		/* 8208C208h case    0:*/		return 0x8208C20C;
	}
	return 0x8208C20C;
} // Block from 8208C208h-8208C20Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208C20Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C20C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C20C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C20C);
		  /* 8208C20Ch */ case    0:  		/* lis R22, -32215 */
		/* 8208C20Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R22,0xFFFF8229);
		/* 8208C20Ch case    0:*/		return 0x8208C210;
		  /* 8208C210h */ case    1:  		/* lwz R11, <#[R22 - 25540]> */
		/* 8208C210h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0xFFFF9C3C) );
		/* 8208C210h case    1:*/		return 0x8208C214;
		  /* 8208C214h */ case    2:  		/* rlwinm. R11, R11, 0, 10, 10 */
		/* 8208C214h case    2:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R11,regs.R11);
		/* 8208C214h case    2:*/		return 0x8208C218;
		  /* 8208C218h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 8208C218h case    3:*/		if ( regs.CR[0].eq ) { return 0x8208C220;  }
		/* 8208C218h case    3:*/		return 0x8208C21C;
		  /* 8208C21Ch */ case    4:  		/* ori R23, R23, 128 */
		/* 8208C21Ch case    4:*/		cpu::op::ori<0>(regs,&regs.R23,regs.R23,0x80);
		/* 8208C21Ch case    4:*/		return 0x8208C220;
	}
	return 0x8208C220;
} // Block from 8208C20Ch-8208C220h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208C220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C220);
		  /* 8208C220h */ case    0:  		/* lwz R11, <#[R31 + 132]> */
		/* 8208C220h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 8208C220h case    0:*/		return 0x8208C224;
		  /* 8208C224h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8208C224h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208C224h case    1:*/		return 0x8208C228;
		  /* 8208C228h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 8208C228h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8208C238;  }
		/* 8208C228h case    2:*/		return 0x8208C22C;
		  /* 8208C22Ch */ case    3:  		/* lis R11, -32217 */
		/* 8208C22Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 8208C22Ch case    3:*/		return 0x8208C230;
		  /* 8208C230h */ case    4:  		/* lwz R11, <#[R11 + 6900]> */
		/* 8208C230h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00001AF4) );
		/* 8208C230h case    4:*/		return 0x8208C234;
		  /* 8208C234h */ case    5:  		/* stw R11, <#[R31 + 132]> */
		/* 8208C234h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 8208C234h case    5:*/		return 0x8208C238;
	}
	return 0x8208C238;
} // Block from 8208C220h-8208C238h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208C238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C238);
		  /* 8208C238h */ case    0:  		/* lwz R11, <#[R31 + 136]> */
		/* 8208C238h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000088) );
		/* 8208C238h case    0:*/		return 0x8208C23C;
		  /* 8208C23Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8208C23Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208C23Ch case    1:*/		return 0x8208C240;
		  /* 8208C240h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 8208C240h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8208C250;  }
		/* 8208C240h case    2:*/		return 0x8208C244;
		  /* 8208C244h */ case    3:  		/* lis R11, -32217 */
		/* 8208C244h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 8208C244h case    3:*/		return 0x8208C248;
		  /* 8208C248h */ case    4:  		/* lwz R11, <#[R11 + 6904]> */
		/* 8208C248h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00001AF8) );
		/* 8208C248h case    4:*/		return 0x8208C24C;
		  /* 8208C24Ch */ case    5:  		/* stw R11, <#[R31 + 136]> */
		/* 8208C24Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000088) );
		/* 8208C24Ch case    5:*/		return 0x8208C250;
	}
	return 0x8208C250;
} // Block from 8208C238h-8208C250h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208C250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C250);
		  /* 8208C250h */ case    0:  		/* lwz R11, <#[R31 + 140]> */
		/* 8208C250h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000008C) );
		/* 8208C250h case    0:*/		return 0x8208C254;
		  /* 8208C254h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8208C254h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208C254h case    1:*/		return 0x8208C258;
		  /* 8208C258h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 8208C258h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8208C268;  }
		/* 8208C258h case    2:*/		return 0x8208C25C;
		  /* 8208C25Ch */ case    3:  		/* lis R11, -32217 */
		/* 8208C25Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 8208C25Ch case    3:*/		return 0x8208C260;
		  /* 8208C260h */ case    4:  		/* lwz R11, <#[R11 + 6912]> */
		/* 8208C260h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00001B00) );
		/* 8208C260h case    4:*/		return 0x8208C264;
		  /* 8208C264h */ case    5:  		/* stw R11, <#[R31 + 140]> */
		/* 8208C264h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000008C) );
		/* 8208C264h case    5:*/		return 0x8208C268;
	}
	return 0x8208C268;
} // Block from 8208C250h-8208C268h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208C268h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C268);
		  /* 8208C268h */ case    0:  		/* lwz R11, <#[R31 + 144]> */
		/* 8208C268h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000090) );
		/* 8208C268h case    0:*/		return 0x8208C26C;
		  /* 8208C26Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8208C26Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208C26Ch case    1:*/		return 0x8208C270;
		  /* 8208C270h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 8208C270h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8208C280;  }
		/* 8208C270h case    2:*/		return 0x8208C274;
		  /* 8208C274h */ case    3:  		/* lis R11, -32217 */
		/* 8208C274h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 8208C274h case    3:*/		return 0x8208C278;
		  /* 8208C278h */ case    4:  		/* lwz R11, <#[R11 + 6908]> */
		/* 8208C278h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00001AFC) );
		/* 8208C278h case    4:*/		return 0x8208C27C;
		  /* 8208C27Ch */ case    5:  		/* stw R11, <#[R31 + 144]> */
		/* 8208C27Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000090) );
		/* 8208C27Ch case    5:*/		return 0x8208C280;
	}
	return 0x8208C280;
} // Block from 8208C268h-8208C280h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208C280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C280);
		  /* 8208C280h */ case    0:  		/* lwz R11, <#[R31 + 148]> */
		/* 8208C280h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000094) );
		/* 8208C280h case    0:*/		return 0x8208C284;
		  /* 8208C284h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8208C284h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208C284h case    1:*/		return 0x8208C288;
		  /* 8208C288h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 8208C288h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8208C298;  }
		/* 8208C288h case    2:*/		return 0x8208C28C;
		  /* 8208C28Ch */ case    3:  		/* lis R11, 32764 */
		/* 8208C28Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FFC);
		/* 8208C28Ch case    3:*/		return 0x8208C290;
		  /* 8208C290h */ case    4:  		/* ori R11, R11, 65535 */
		/* 8208C290h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFFF);
		/* 8208C290h case    4:*/		return 0x8208C294;
		  /* 8208C294h */ case    5:  		/* stw R11, <#[R31 + 148]> */
		/* 8208C294h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000094) );
		/* 8208C294h case    5:*/		return 0x8208C298;
	}
	return 0x8208C298;
} // Block from 8208C280h-8208C298h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208C298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C298);
		  /* 8208C298h */ case    0:  		/* lwz R11, <#[R31 + 152]> */
		/* 8208C298h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000098) );
		/* 8208C298h case    0:*/		return 0x8208C29C;
		  /* 8208C29Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8208C29Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208C29Ch case    1:*/		return 0x8208C2A0;
		  /* 8208C2A0h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8208C2A0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8208C2B0;  }
		/* 8208C2A0h case    2:*/		return 0x8208C2A4;
		  /* 8208C2A4h */ case    3:  		/* lis R10, 15 */
		/* 8208C2A4h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xF);
		/* 8208C2A4h case    3:*/		return 0x8208C2A8;
		  /* 8208C2A8h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 8208C2A8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8208C2A8h case    4:*/		return 0x8208C2AC;
		  /* 8208C2ACh */ case    5:  		/* bc 4, CR6_GT, 12 */
		/* 8208C2ACh case    5:*/		if ( !regs.CR[6].gt ) { return 0x8208C2B8;  }
		/* 8208C2ACh case    5:*/		return 0x8208C2B0;
	}
	return 0x8208C2B0;
} // Block from 8208C298h-8208C2B0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208C2B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C2B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C2B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C2B0);
		  /* 8208C2B0h */ case    0:  		/* lis R11, 15 */
		/* 8208C2B0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xF);
		/* 8208C2B0h case    0:*/		return 0x8208C2B4;
		  /* 8208C2B4h */ case    1:  		/* stw R11, <#[R31 + 152]> */
		/* 8208C2B4h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000098) );
		/* 8208C2B4h case    1:*/		return 0x8208C2B8;
	}
	return 0x8208C2B8;
} // Block from 8208C2B0h-8208C2B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208C2B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C2B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C2B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C2B8);
		  /* 8208C2B8h */ case    0:  		/* cmplwi CR6, R6, 0 */
		/* 8208C2B8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8208C2B8h case    0:*/		return 0x8208C2BC;
		  /* 8208C2BCh */ case    1:  		/* lis R30, 1 */
		/* 8208C2BCh case    1:*/		cpu::op::lis<0>(regs,&regs.R30,0x1);
		/* 8208C2BCh case    1:*/		return 0x8208C2C0;
		  /* 8208C2C0h */ case    2:  		/* bc 4, CR6_EQ, 80 */
		/* 8208C2C0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8208C310;  }
		/* 8208C2C0h case    2:*/		return 0x8208C2C4;
		  /* 8208C2C4h */ case    3:  		/* cmplwi CR6, R5, 0 */
		/* 8208C2C4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8208C2C4h case    3:*/		return 0x8208C2C8;
		  /* 8208C2C8h */ case    4:  		/* stw R30, <#[R31 + 332]> */
		/* 8208C2C8h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000014C) );
		/* 8208C2C8h case    4:*/		return 0x8208C2CC;
		  /* 8208C2CCh */ case    5:  		/* bc 4, CR6_EQ, 20 */
		/* 8208C2CCh case    5:*/		if ( !regs.CR[6].eq ) { return 0x8208C2E0;  }
		/* 8208C2CCh case    5:*/		return 0x8208C2D0;
		  /* 8208C2D0h */ case    6:  		/* lis R11, 64 */
		/* 8208C2D0h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0x40);
		/* 8208C2D0h case    6:*/		return 0x8208C2D4;
		  /* 8208C2D4h */ case    7:  		/* lis R10, 0 */
		/* 8208C2D4h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 8208C2D4h case    7:*/		return 0x8208C2D8;
		  /* 8208C2D8h */ case    8:  		/* ori R25, R10, 65535 */
		/* 8208C2D8h case    8:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R10,0xFFFF);
		/* 8208C2D8h case    8:*/		return 0x8208C2DC;
		  /* 8208C2DCh */ case    9:  		/* b 20 */
		/* 8208C2DCh case    9:*/		return 0x8208C2F0;
		/* 8208C2DCh case    9:*/		return 0x8208C2E0;
	}
	return 0x8208C2E0;
} // Block from 8208C2B8h-8208C2E0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8208C2E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C2E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C2E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C2E0);
		  /* 8208C2E0h */ case    0:  		/* lis R11, 0 */
		/* 8208C2E0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x0);
		/* 8208C2E0h case    0:*/		return 0x8208C2E4;
		  /* 8208C2E4h */ case    1:  		/* ori R25, R11, 65535 */
		/* 8208C2E4h case    1:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R11,0xFFFF);
		/* 8208C2E4h case    1:*/		return 0x8208C2E8;
		  /* 8208C2E8h */ case    2:  		/* add R11, R5, R25 */
		/* 8208C2E8h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R5,regs.R25);
		/* 8208C2E8h case    2:*/		return 0x8208C2EC;
		  /* 8208C2ECh */ case    3:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 8208C2ECh case    3:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 8208C2ECh case    3:*/		return 0x8208C2F0;
	}
	return 0x8208C2F0;
} // Block from 8208C2E0h-8208C2F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208C2F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C2F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C2F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C2F0);
		  /* 8208C2F0h */ case    0:  		/* stw R11, <#[R31 + 324]> */
		/* 8208C2F0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000144) );
		/* 8208C2F0h case    0:*/		return 0x8208C2F4;
		  /* 8208C2F4h */ case    1:  		/* rlwinm. R11, R23, 0, 31, 31 */
		/* 8208C2F4h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R23);
		/* 8208C2F4h case    1:*/		return 0x8208C2F8;
		  /* 8208C2F8h */ case    2:  		/* li R24, 1432 */
		/* 8208C2F8h case    2:*/		cpu::op::li<0>(regs,&regs.R24,0x598);
		/* 8208C2F8h case    2:*/		return 0x8208C2FC;
		  /* 8208C2FCh */ case    3:  		/* cmplwi CR6, R20, 0 */
		/* 8208C2FCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 8208C2FCh case    3:*/		return 0x8208C300;
		  /* 8208C300h */ case    4:  		/* bc 4, CR0_EQ, 72 */
		/* 8208C300h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8208C348;  }
		/* 8208C300h case    4:*/		return 0x8208C304;
		  /* 8208C304h */ case    5:  		/* bc 12, CR6_EQ, 56 */
		/* 8208C304h case    5:*/		if ( regs.CR[6].eq ) { return 0x8208C33C;  }
		/* 8208C304h case    5:*/		return 0x8208C308;
		  /* 8208C308h */ case    6:  		/* oris R23, R23, 32768 */
		/* 8208C308h case    6:*/		cpu::op::oris<0>(regs,&regs.R23,regs.R23,0x8000);
		/* 8208C308h case    6:*/		return 0x8208C30C;
		  /* 8208C30Ch */ case    7:  		/* b 64 */
		/* 8208C30Ch case    7:*/		return 0x8208C34C;
		/* 8208C30Ch case    7:*/		return 0x8208C310;
	}
	return 0x8208C310;
} // Block from 8208C2F0h-8208C310h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8208C310h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C310( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C310) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C310);
		  /* 8208C310h */ case    0:  		/* lis R11, 0 */
		/* 8208C310h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x0);
		/* 8208C310h case    0:*/		return 0x8208C314;
		  /* 8208C314h */ case    1:  		/* cmplwi CR6, R5, 0 */
		/* 8208C314h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8208C314h case    1:*/		return 0x8208C318;
		  /* 8208C318h */ case    2:  		/* ori R25, R11, 65535 */
		/* 8208C318h case    2:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R11,0xFFFF);
		/* 8208C318h case    2:*/		return 0x8208C31C;
		  /* 8208C31Ch */ case    3:  		/* add R11, R6, R25 */
		/* 8208C31Ch case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R6,regs.R25);
		/* 8208C31Ch case    3:*/		return 0x8208C320;
		  /* 8208C320h */ case    4:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 8208C320h case    4:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 8208C320h case    4:*/		return 0x8208C324;
		  /* 8208C324h */ case    5:  		/* stw R11, <#[R31 + 332]> */
		/* 8208C324h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000014C) );
		/* 8208C324h case    5:*/		return 0x8208C328;
		  /* 8208C328h */ case    6:  		/* bc 4, CR6_EQ, -64 */
		/* 8208C328h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8208C2E8;  }
		/* 8208C328h case    6:*/		return 0x8208C32C;
		  /* 8208C32Ch */ case    7:  		/* addis R11, R11, 16 */
		/* 8208C32Ch case    7:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8208C32Ch case    7:*/		return 0x8208C330;
		  /* 8208C330h */ case    8:  		/* addi R11, R11, -1 */
		/* 8208C330h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8208C330h case    8:*/		return 0x8208C334;
		  /* 8208C334h */ case    9:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 8208C334h case    9:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 8208C334h case    9:*/		return 0x8208C338;
		  /* 8208C338h */ case   10:  		/* b -72 */
		/* 8208C338h case   10:*/		return 0x8208C2F0;
		/* 8208C338h case   10:*/		return 0x8208C33C;
	}
	return 0x8208C33C;
} // Block from 8208C310h-8208C33Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8208C33Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C33C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C33C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C33C);
		  /* 8208C33Ch */ case    0:  		/* li R24, 1460 */
		/* 8208C33Ch case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x5B4);
		/* 8208C33Ch case    0:*/		return 0x8208C340;
		  /* 8208C340h */ case    1:  		/* li R20, -1 */
		/* 8208C340h case    1:*/		cpu::op::li<0>(regs,&regs.R20,0xFFFFFFFF);
		/* 8208C340h case    1:*/		return 0x8208C344;
		  /* 8208C344h */ case    2:  		/* b 8 */
		/* 8208C344h case    2:*/		return 0x8208C34C;
		/* 8208C344h case    2:*/		return 0x8208C348;
	}
	return 0x8208C348;
} // Block from 8208C33Ch-8208C348h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208C348h
// Function 'SetFilePointer'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C348);
		  /* 8208C348h */ case    0:  		/* bc 4, CR6_EQ, -328 */
		/* 8208C348h case    0:*/		if ( !regs.CR[6].eq ) { return 0x8208C200;  }
		/* 8208C348h case    0:*/		return 0x8208C34C;
	}
	return 0x8208C34C;
} // Block from 8208C348h-8208C34Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208C34Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C34C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C34C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C34C);
		  /* 8208C34Ch */ case    0:  		/* rlwinm. R11, R23, 0, 12, 12 */
		/* 8208C34Ch case    0:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R11,regs.R23);
		/* 8208C34Ch case    0:*/		return 0x8208C350;
		  /* 8208C350h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 8208C350h case    1:*/		if ( regs.CR[0].eq ) { return 0x8208C364;  }
		/* 8208C350h case    1:*/		return 0x8208C354;
		  /* 8208C354h */ case    2:  		/* bl 1969060 */
		/* 8208C354h case    2:*/		regs.LR = 0x8208C358; return 0x8226CEF8;
		/* 8208C354h case    2:*/		return 0x8208C358;
		  /* 8208C358h */ case    3:  		/* cmpwi CR6, R3, 1 */
		/* 8208C358h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8208C358h case    3:*/		return 0x8208C35C;
		  /* 8208C35Ch */ case    4:  		/* li R27, 3 */
		/* 8208C35Ch case    4:*/		cpu::op::li<0>(regs,&regs.R27,0x3);
		/* 8208C35Ch case    4:*/		return 0x8208C360;
		  /* 8208C360h */ case    5:  		/* bc 12, CR6_EQ, 8 */
		/* 8208C360h case    5:*/		if ( regs.CR[6].eq ) { return 0x8208C368;  }
		/* 8208C360h case    5:*/		return 0x8208C364;
	}
	return 0x8208C364;
} // Block from 8208C34Ch-8208C364h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208C364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C364);
		  /* 8208C364h */ case    0:  		/* mr R27, R21 */
		/* 8208C364h case    0:*/		regs.R27 = regs.R21;
		/* 8208C364h case    0:*/		return 0x8208C368;
	}
	return 0x8208C368;
} // Block from 8208C364h-8208C368h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208C368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C368);
		  /* 8208C368h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 8208C368h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8208C368h case    0:*/		return 0x8208C36C;
		  /* 8208C36Ch */ case    1:  		/* lwz R11, <#[R31 + 164]> */
		/* 8208C36Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000A4) );
		/* 8208C36Ch case    1:*/		return 0x8208C370;
		  /* 8208C370h */ case    2:  		/* bc 12, CR6_EQ, 256 */
		/* 8208C370h case    2:*/		if ( regs.CR[6].eq ) { return 0x8208C470;  }
		/* 8208C370h case    2:*/		return 0x8208C374;
		  /* 8208C374h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8208C374h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208C374h case    3:*/		return 0x8208C378;
		  /* 8208C378h */ case    4:  		/* bc 12, CR6_EQ, 76 */
		/* 8208C378h case    4:*/		if ( regs.CR[6].eq ) { return 0x8208C3C4;  }
		/* 8208C378h case    4:*/		return 0x8208C37C;
		  /* 8208C37Ch */ case    5:  		/* lwz R10, <#[R31 + 156]> */
		/* 8208C37Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000009C) );
		/* 8208C37Ch case    5:*/		return 0x8208C380;
		  /* 8208C380h */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 8208C380h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8208C380h case    6:*/		return 0x8208C384;
		  /* 8208C384h */ case    7:  		/* bc 12, CR6_EQ, -388 */
		/* 8208C384h case    7:*/		if ( regs.CR[6].eq ) { return 0x8208C200;  }
		/* 8208C384h case    7:*/		return 0x8208C388;
		  /* 8208C388h */ case    8:  		/* lwz R11, <#[R31 + 160]> */
		/* 8208C388h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000A0) );
		/* 8208C388h case    8:*/		return 0x8208C38C;
		  /* 8208C38Ch */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 8208C38Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208C38Ch case    9:*/		return 0x8208C390;
		  /* 8208C390h */ case   10:  		/* bc 12, CR6_EQ, -400 */
		/* 8208C390h case   10:*/		if ( regs.CR[6].eq ) { return 0x8208C200;  }
		/* 8208C390h case   10:*/		return 0x8208C394;
		  /* 8208C394h */ case   11:  		/* cmplw CR6, R10, R11 */
		/* 8208C394h case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208C394h case   11:*/		return 0x8208C398;
		  /* 8208C398h */ case   12:  		/* bc 12, CR6_GT, -408 */
		/* 8208C398h case   12:*/		if ( regs.CR[6].gt ) { return 0x8208C200;  }
		/* 8208C398h case   12:*/		return 0x8208C39C;
		  /* 8208C39Ch */ case   13:  		/* rlwinm. R9, R23, 0, 30, 30 */
		/* 8208C39Ch case   13:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R23);
		/* 8208C39Ch case   13:*/		return 0x8208C3A0;
		  /* 8208C3A0h */ case   14:  		/* bc 4, CR0_EQ, -416 */
		/* 8208C3A0h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8208C200;  }
		/* 8208C3A0h case   14:*/		return 0x8208C3A4;
		  /* 8208C3A4h */ case   15:  		/* lis R5, 1 */
		/* 8208C3A4h case   15:*/		cpu::op::lis<0>(regs,&regs.R5,0x1);
		/* 8208C3A4h case   15:*/		return 0x8208C3A8;
		  /* 8208C3A8h */ case   16:  		/* stw R29, <#[R31 + 84]> */
		/* 8208C3A8h case   16:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000054) );
		/* 8208C3A8h case   16:*/		return 0x8208C3AC;
		  /* 8208C3ACh */ case   17:  		/* li R4, 0 */
		/* 8208C3ACh case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208C3ACh case   17:*/		return 0x8208C3B0;
		  /* 8208C3B0h */ case   18:  		/* stw R11, <#[R31 + 324]> */
		/* 8208C3B0h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000144) );
		/* 8208C3B0h case   18:*/		return 0x8208C3B4;
		  /* 8208C3B4h */ case   19:  		/* mr R3, R29 */
		/* 8208C3B4h case   19:*/		regs.R3 = regs.R29;
		/* 8208C3B4h case   19:*/		return 0x8208C3B8;
		  /* 8208C3B8h */ case   20:  		/* add R28, R10, R29 */
		/* 8208C3B8h case   20:*/		cpu::op::add<0>(regs,&regs.R28,regs.R10,regs.R29);
		/* 8208C3B8h case   20:*/		return 0x8208C3BC;
		  /* 8208C3BCh */ case   21:  		/* bl 20356 */
		/* 8208C3BCh case   21:*/		regs.LR = 0x8208C3C0; return 0x82091340;
		/* 8208C3BCh case   21:*/		return 0x8208C3C0;
		  /* 8208C3C0h */ case   22:  		/* b 160 */
		/* 8208C3C0h case   22:*/		return 0x8208C460;
		/* 8208C3C0h case   22:*/		return 0x8208C3C4;
	}
	return 0x8208C3C4;
} // Block from 8208C368h-8208C3C4h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8208C3C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C3C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C3C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C3C4);
		  /* 8208C3C4h */ case    0:  		/* mr R5, R27 */
		/* 8208C3C4h case    0:*/		regs.R5 = regs.R27;
		/* 8208C3C4h case    0:*/		return 0x8208C3C8;
		  /* 8208C3C8h */ case    1:  		/* addi R4, R31, 96 */
		/* 8208C3C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x60);
		/* 8208C3C8h case    1:*/		return 0x8208C3CC;
		  /* 8208C3CCh */ case    2:  		/* mr R3, R29 */
		/* 8208C3CCh case    2:*/		regs.R3 = regs.R29;
		/* 8208C3CCh case    2:*/		return 0x8208C3D0;
		  /* 8208C3D0h */ case    3:  		/* bl 1970344 */
		/* 8208C3D0h case    3:*/		regs.LR = 0x8208C3D4; return 0x8226D478;
		/* 8208C3D0h case    3:*/		return 0x8208C3D4;
		  /* 8208C3D4h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 8208C3D4h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208C3D4h case    4:*/		return 0x8208C3D8;
		  /* 8208C3D8h */ case    5:  		/* bc 12, CR0_LT, -472 */
		/* 8208C3D8h case    5:*/		if ( regs.CR[0].lt ) { return 0x8208C200;  }
		/* 8208C3D8h case    5:*/		return 0x8208C3DC;
		  /* 8208C3DCh */ case    6:  		/* lwz R3, <#[R31 + 96]> */
		/* 8208C3DCh case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000060) );
		/* 8208C3DCh case    6:*/		return 0x8208C3E0;
		  /* 8208C3E0h */ case    7:  		/* cmplw CR6, R3, R29 */
		/* 8208C3E0h case    7:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R29);
		/* 8208C3E0h case    7:*/		return 0x8208C3E4;
		  /* 8208C3E4h */ case    8:  		/* bc 4, CR6_EQ, -484 */
		/* 8208C3E4h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8208C200;  }
		/* 8208C3E4h case    8:*/		return 0x8208C3E8;
		  /* 8208C3E8h */ case    9:  		/* lwz R11, <#[R31 + 112]> */
		/* 8208C3E8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 8208C3E8h case    9:*/		return 0x8208C3EC;
		  /* 8208C3ECh */ case   10:  		/* cmplw CR6, R11, R30 */
		/* 8208C3ECh case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 8208C3ECh case   10:*/		return 0x8208C3F0;
		  /* 8208C3F0h */ case   11:  		/* bc 12, CR6_EQ, -496 */
		/* 8208C3F0h case   11:*/		if ( regs.CR[6].eq ) { return 0x8208C200;  }
		/* 8208C3F0h case   11:*/		return 0x8208C3F4;
		  /* 8208C3F4h */ case   12:  		/* stw R3, <#[R31 + 84]> */
		/* 8208C3F4h case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000054) );
		/* 8208C3F4h case   12:*/		return 0x8208C3F8;
		  /* 8208C3F8h */ case   13:  		/* cmplwi CR6, R11, 4096 */
		/* 8208C3F8h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00001000);
		/* 8208C3F8h case   13:*/		return 0x8208C3FC;
		  /* 8208C3FCh */ case   14:  		/* bc 4, CR6_EQ, 92 */
		/* 8208C3FCh case   14:*/		if ( !regs.CR[6].eq ) { return 0x8208C458;  }
		/* 8208C3FCh case   14:*/		return 0x8208C400;
		  /* 8208C400h */ case   15:  		/* lis R5, 1 */
		/* 8208C400h case   15:*/		cpu::op::lis<0>(regs,&regs.R5,0x1);
		/* 8208C400h case   15:*/		return 0x8208C404;
		  /* 8208C404h */ case   16:  		/* li R4, 0 */
		/* 8208C404h case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208C404h case   16:*/		return 0x8208C408;
		  /* 8208C408h */ case   17:  		/* bl 20280 */
		/* 8208C408h case   17:*/		regs.LR = 0x8208C40C; return 0x82091340;
		/* 8208C408h case   17:*/		return 0x8208C40C;
		  /* 8208C40Ch */ case   18:  		/* lwz R11, <#[R31 + 108]> */
		/* 8208C40Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 8208C40Ch case   18:*/		return 0x8208C410;
		  /* 8208C410h */ case   19:  		/* lwz R10, <#[R31 + 84]> */
		/* 8208C410h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000054) );
		/* 8208C410h case   19:*/		return 0x8208C414;
		  /* 8208C414h */ case   20:  		/* mr R5, R27 */
		/* 8208C414h case   20:*/		regs.R5 = regs.R27;
		/* 8208C414h case   20:*/		return 0x8208C418;
		  /* 8208C418h */ case   21:  		/* addi R4, R31, 96 */
		/* 8208C418h case   21:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x60);
		/* 8208C418h case   21:*/		return 0x8208C41C;
		  /* 8208C41Ch */ case   22:  		/* add R28, R11, R10 */
		/* 8208C41Ch case   22:*/		cpu::op::add<0>(regs,&regs.R28,regs.R11,regs.R10);
		/* 8208C41Ch case   22:*/		return 0x8208C420;
		  /* 8208C420h */ case   23:  		/* stw R11, <#[R31 + 332]> */
		/* 8208C420h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000014C) );
		/* 8208C420h case   23:*/		return 0x8208C424;
		  /* 8208C424h */ case   24:  		/* mr R3, R28 */
		/* 8208C424h case   24:*/		regs.R3 = regs.R28;
		/* 8208C424h case   24:*/		return 0x8208C428;
		  /* 8208C428h */ case   25:  		/* bl 1970256 */
		/* 8208C428h case   25:*/		regs.LR = 0x8208C42C; return 0x8226D478;
		/* 8208C428h case   25:*/		return 0x8208C42C;
		  /* 8208C42Ch */ case   26:  		/* lwz R11, <#[R31 + 332]> */
		/* 8208C42Ch case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000014C) );
		/* 8208C42Ch case   26:*/		return 0x8208C430;
		  /* 8208C430h */ case   27:  		/* cmpwi CR0, R3, 0 */
		/* 8208C430h case   27:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208C430h case   27:*/		return 0x8208C434;
		  /* 8208C434h */ case   28:  		/* stw R11, <#[R31 + 324]> */
		/* 8208C434h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000144) );
		/* 8208C434h case   28:*/		return 0x8208C438;
		  /* 8208C438h */ case   29:  		/* bc 12, CR0_LT, 40 */
		/* 8208C438h case   29:*/		if ( regs.CR[0].lt ) { return 0x8208C460;  }
		/* 8208C438h case   29:*/		return 0x8208C43C;
		  /* 8208C43Ch */ case   30:  		/* lwz R10, <#[R31 + 112]> */
		/* 8208C43Ch case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000070) );
		/* 8208C43Ch case   30:*/		return 0x8208C440;
		  /* 8208C440h */ case   31:  		/* cmplwi CR6, R10, 8192 */
		/* 8208C440h case   31:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00002000);
		/* 8208C440h case   31:*/		return 0x8208C444;
		  /* 8208C444h */ case   32:  		/* bc 4, CR6_EQ, 28 */
		/* 8208C444h case   32:*/		if ( !regs.CR[6].eq ) { return 0x8208C460;  }
		/* 8208C444h case   32:*/		return 0x8208C448;
		  /* 8208C448h */ case   33:  		/* lwz R10, <#[R31 + 108]> */
		/* 8208C448h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000006C) );
		/* 8208C448h case   33:*/		return 0x8208C44C;
		  /* 8208C44Ch */ case   34:  		/* add R11, R10, R11 */
		/* 8208C44Ch case   34:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208C44Ch case   34:*/		return 0x8208C450;
		  /* 8208C450h */ case   35:  		/* stw R11, <#[R31 + 324]> */
		/* 8208C450h case   35:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000144) );
		/* 8208C450h case   35:*/		return 0x8208C454;
		  /* 8208C454h */ case   36:  		/* b 12 */
		/* 8208C454h case   36:*/		return 0x8208C460;
		/* 8208C454h case   36:*/		return 0x8208C458;
	}
	return 0x8208C458;
} // Block from 8208C3C4h-8208C458h (37 instructions)

//////////////////////////////////////////////////////
// Block at 8208C458h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C458);
		  /* 8208C458h */ case    0:  		/* mr R28, R3 */
		/* 8208C458h case    0:*/		regs.R28 = regs.R3;
		/* 8208C458h case    0:*/		return 0x8208C45C;
		  /* 8208C45Ch */ case    1:  		/* stw R30, <#[R31 + 332]> */
		/* 8208C45Ch case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000014C) );
		/* 8208C45Ch case    1:*/		return 0x8208C460;
	}
	return 0x8208C460;
} // Block from 8208C458h-8208C460h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208C460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C460);
		  /* 8208C460h */ case    0:  		/* mr R10, R29 */
		/* 8208C460h case    0:*/		regs.R10 = regs.R29;
		/* 8208C460h case    0:*/		return 0x8208C464;
		  /* 8208C464h */ case    1:  		/* li R26, 1 */
		/* 8208C464h case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 8208C464h case    1:*/		return 0x8208C468;
		  /* 8208C468h */ case    2:  		/* stw R29, <#[R31 + 80]> */
		/* 8208C468h case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C468h case    2:*/		return 0x8208C46C;
		  /* 8208C46Ch */ case    3:  		/* b 80 */
		/* 8208C46Ch case    3:*/		return 0x8208C4BC;
		/* 8208C46Ch case    3:*/		return 0x8208C470;
	}
	return 0x8208C470;
} // Block from 8208C460h-8208C470h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208C470h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C470);
		  /* 8208C470h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8208C470h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208C470h case    0:*/		return 0x8208C474;
		  /* 8208C474h */ case    1:  		/* bc 4, CR6_EQ, -628 */
		/* 8208C474h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8208C200;  }
		/* 8208C474h case    1:*/		return 0x8208C478;
		  /* 8208C478h */ case    2:  		/* lis R5, 24576 */
		/* 8208C478h case    2:*/		cpu::op::lis<0>(regs,&regs.R5,0x6000);
		/* 8208C478h case    2:*/		return 0x8208C47C;
		  /* 8208C47Ch */ case    3:  		/* mr R7, R27 */
		/* 8208C47Ch case    3:*/		regs.R7 = regs.R27;
		/* 8208C47Ch case    3:*/		return 0x8208C480;
		  /* 8208C480h */ case    4:  		/* li R6, 4 */
		/* 8208C480h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 8208C480h case    4:*/		return 0x8208C484;
		  /* 8208C484h */ case    5:  		/* ori R5, R5, 8192 */
		/* 8208C484h case    5:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x2000);
		/* 8208C484h case    5:*/		return 0x8208C488;
		  /* 8208C488h */ case    6:  		/* addi R4, R31, 324 */
		/* 8208C488h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x144);
		/* 8208C488h case    6:*/		return 0x8208C48C;
		  /* 8208C48Ch */ case    7:  		/* addi R3, R31, 80 */
		/* 8208C48Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x50);
		/* 8208C48Ch case    7:*/		return 0x8208C490;
		  /* 8208C490h */ case    8:  		/* bl 1970088 */
		/* 8208C490h case    8:*/		regs.LR = 0x8208C494; return 0x8226D438;
		/* 8208C490h case    8:*/		return 0x8208C494;
		  /* 8208C494h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 8208C494h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208C494h case    9:*/		return 0x8208C498;
		  /* 8208C498h */ case   10:  		/* bc 12, CR0_LT, -664 */
		/* 8208C498h case   10:*/		if ( regs.CR[0].lt ) { return 0x8208C200;  }
		/* 8208C498h case   10:*/		return 0x8208C49C;
		  /* 8208C49Ch */ case   11:  		/* lwz R11, <#[R31 + 332]> */
		/* 8208C49Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000014C) );
		/* 8208C49Ch case   11:*/		return 0x8208C4A0;
		  /* 8208C4A0h */ case   12:  		/* mr R26, R21 */
		/* 8208C4A0h case   12:*/		regs.R26 = regs.R21;
		/* 8208C4A0h case   12:*/		return 0x8208C4A4;
		  /* 8208C4A4h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 8208C4A4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208C4A4h case   13:*/		return 0x8208C4A8;
		  /* 8208C4A8h */ case   14:  		/* bc 4, CR6_EQ, 8 */
		/* 8208C4A8h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8208C4B0;  }
		/* 8208C4A8h case   14:*/		return 0x8208C4AC;
		  /* 8208C4ACh */ case   15:  		/* stw R30, <#[R31 + 332]> */
		/* 8208C4ACh case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000014C) );
		/* 8208C4ACh case   15:*/		return 0x8208C4B0;
	}
	return 0x8208C4B0;
} // Block from 8208C470h-8208C4B0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8208C4B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C4B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C4B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C4B0);
		  /* 8208C4B0h */ case    0:  		/* lwz R10, <#[R31 + 80]> */
		/* 8208C4B0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C4B0h case    0:*/		return 0x8208C4B4;
		  /* 8208C4B4h */ case    1:  		/* stw R10, <#[R31 + 84]> */
		/* 8208C4B4h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000054) );
		/* 8208C4B4h case    1:*/		return 0x8208C4B8;
	}
	return 0x8208C4B8;
} // Block from 8208C4B0h-8208C4B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208C4B8h
// Function 'SetEndOfFile'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C4B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C4B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C4B8);
		  /* 8208C4B8h */ case    0:  		/* mr R28, R10 */
		/* 8208C4B8h case    0:*/		regs.R28 = regs.R10;
		/* 8208C4B8h case    0:*/		return 0x8208C4BC;
	}
	return 0x8208C4BC;
} // Block from 8208C4B8h-8208C4BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208C4BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C4BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C4BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C4BC);
		  /* 8208C4BCh */ case    0:  		/* lwz R11, <#[R31 + 84]> */
		/* 8208C4BCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 8208C4BCh case    0:*/		return 0x8208C4C0;
		  /* 8208C4C0h */ case    1:  		/* cmplw CR6, R11, R28 */
		/* 8208C4C0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 8208C4C0h case    1:*/		return 0x8208C4C4;
		  /* 8208C4C4h */ case    2:  		/* bc 4, CR6_EQ, 88 */
		/* 8208C4C4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8208C51C;  }
		/* 8208C4C4h case    2:*/		return 0x8208C4C8;
		  /* 8208C4C8h */ case    3:  		/* lis R5, 24576 */
		/* 8208C4C8h case    3:*/		cpu::op::lis<0>(regs,&regs.R5,0x6000);
		/* 8208C4C8h case    3:*/		return 0x8208C4CC;
		  /* 8208C4CCh */ case    4:  		/* mr R7, R27 */
		/* 8208C4CCh case    4:*/		regs.R7 = regs.R27;
		/* 8208C4CCh case    4:*/		return 0x8208C4D0;
		  /* 8208C4D0h */ case    5:  		/* li R6, 4 */
		/* 8208C4D0h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 8208C4D0h case    5:*/		return 0x8208C4D4;
		  /* 8208C4D4h */ case    6:  		/* ori R5, R5, 4096 */
		/* 8208C4D4h case    6:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x1000);
		/* 8208C4D4h case    6:*/		return 0x8208C4D8;
		  /* 8208C4D8h */ case    7:  		/* addi R4, R31, 332 */
		/* 8208C4D8h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x14C);
		/* 8208C4D8h case    7:*/		return 0x8208C4DC;
		  /* 8208C4DCh */ case    8:  		/* addi R3, R31, 84 */
		/* 8208C4DCh case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x54);
		/* 8208C4DCh case    8:*/		return 0x8208C4E0;
		  /* 8208C4E0h */ case    9:  		/* bl 1970008 */
		/* 8208C4E0h case    9:*/		regs.LR = 0x8208C4E4; return 0x8226D438;
		/* 8208C4E0h case    9:*/		return 0x8208C4E4;
		  /* 8208C4E4h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 8208C4E4h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208C4E4h case   10:*/		return 0x8208C4E8;
		  /* 8208C4E8h */ case   11:  		/* bc 4, CR0_LT, 40 */
		/* 8208C4E8h case   11:*/		if ( !regs.CR[0].lt ) { return 0x8208C510;  }
		/* 8208C4E8h case   11:*/		return 0x8208C4EC;
		  /* 8208C4ECh */ case   12:  		/* cmplwi CR6, R29, 0 */
		/* 8208C4ECh case   12:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8208C4ECh case   12:*/		return 0x8208C4F0;
		  /* 8208C4F0h */ case   13:  		/* bc 4, CR6_EQ, -752 */
		/* 8208C4F0h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8208C200;  }
		/* 8208C4F0h case   13:*/		return 0x8208C4F4;
		  /* 8208C4F4h */ case   14:  		/* lis R5, 0 */
		/* 8208C4F4h case   14:*/		cpu::op::lis<0>(regs,&regs.R5,0x0);
		/* 8208C4F4h case   14:*/		return 0x8208C4F8;
		  /* 8208C4F8h */ case   15:  		/* mr R6, R27 */
		/* 8208C4F8h case   15:*/		regs.R6 = regs.R27;
		/* 8208C4F8h case   15:*/		return 0x8208C4FC;
		  /* 8208C4FCh */ case   16:  		/* ori R5, R5, 32768 */
		/* 8208C4FCh case   16:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x8000);
		/* 8208C4FCh case   16:*/		return 0x8208C500;
		  /* 8208C500h */ case   17:  		/* addi R4, R31, 324 */
		/* 8208C500h case   17:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x144);
		/* 8208C500h case   17:*/		return 0x8208C504;
		  /* 8208C504h */ case   18:  		/* addi R3, R31, 80 */
		/* 8208C504h case   18:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x50);
		/* 8208C504h case   18:*/		return 0x8208C508;
		  /* 8208C508h */ case   19:  		/* bl 1970000 */
		/* 8208C508h case   19:*/		regs.LR = 0x8208C50C; return 0x8226D458;
		/* 8208C508h case   19:*/		return 0x8208C50C;
		  /* 8208C50Ch */ case   20:  		/* b -780 */
		/* 8208C50Ch case   20:*/		return 0x8208C200;
		/* 8208C50Ch case   20:*/		return 0x8208C510;
	}
	return 0x8208C510;
} // Block from 8208C4BCh-8208C510h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8208C510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C510);
		  /* 8208C510h */ case    0:  		/* lwz R11, <#[R31 + 332]> */
		/* 8208C510h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000014C) );
		/* 8208C510h case    0:*/		return 0x8208C514;
		  /* 8208C514h */ case    1:  		/* lwz R10, <#[R31 + 80]> */
		/* 8208C514h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C514h case    1:*/		return 0x8208C518;
		  /* 8208C518h */ case    2:  		/* add R28, R28, R11 */
		/* 8208C518h case    2:*/		cpu::op::add<0>(regs,&regs.R28,regs.R28,regs.R11);
		/* 8208C518h case    2:*/		return 0x8208C51C;
	}
	return 0x8208C51C;
} // Block from 8208C510h-8208C51Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208C51Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C51C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C51C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C51C);
		  /* 8208C51Ch */ case    0:  		/* li R8, 8 */
		/* 8208C51Ch case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x8);
		/* 8208C51Ch case    0:*/		return 0x8208C520;
		  /* 8208C520h */ case    1:  		/* addi R11, R10, 1439 */
		/* 8208C520h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x59F);
		/* 8208C520h case    1:*/		return 0x8208C524;
		  /* 8208C524h */ case    2:  		/* addi R9, R24, 128 */
		/* 8208C524h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R24,0x80);
		/* 8208C524h case    2:*/		return 0x8208C528;
		  /* 8208C528h */ case    3:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 8208C528h case    3:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 8208C528h case    3:*/		return 0x8208C52C;
		  /* 8208C52Ch */ case    4:  		/* addi R10, R10, 76 */
		/* 8208C52Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4C);
		/* 8208C52Ch case    4:*/		return 0x8208C530;
		  /* 8208C530h */ case    5:  		/* mtspr CTR, R8 */
		/* 8208C530h case    5:*/		regs.CTR = regs.R8;
		/* 8208C530h case    5:*/		return 0x8208C534;
		  /* 8208C534h */ case    6:  		/* stw R11, <#[R10]> */
		/* 8208C534h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8208C534h case    6:*/		return 0x8208C538;
		  /* 8208C538h */ case    7:  		/* mr R10, R11 */
		/* 8208C538h case    7:*/		regs.R10 = regs.R11;
		/* 8208C538h case    7:*/		return 0x8208C53C;
		  /* 8208C53Ch */ case    8:  		/* addi R11, R11, 16 */
		/* 8208C53Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8208C53Ch case    8:*/		return 0x8208C540;
		  /* 8208C540h */ case    9:  		/* bc 16, CR0_LT, -12 */
		/* 8208C540h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8208C534;  }
		/* 8208C540h case    9:*/		return 0x8208C544;
		  /* 8208C544h */ case   10:  		/* stw R21, <#[R10]> */
		/* 8208C544h case   10:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R10 + 0x00000000) );
		/* 8208C544h case   10:*/		return 0x8208C548;
		  /* 8208C548h */ case   11:  		/* mr R29, R11 */
		/* 8208C548h case   11:*/		regs.R29 = regs.R11;
		/* 8208C548h case   11:*/		return 0x8208C54C;
		  /* 8208C54Ch */ case   12:  		/* lwz R10, <#[R22 - 25540]> */
		/* 8208C54Ch case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0xFFFF9C3C) );
		/* 8208C54Ch case   12:*/		return 0x8208C550;
		  /* 8208C550h */ case   13:  		/* rlwinm. R10, R10, 0, 20, 20 */
		/* 8208C550h case   13:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R10,regs.R10);
		/* 8208C550h case   13:*/		return 0x8208C554;
		  /* 8208C554h */ case   14:  		/* bc 12, CR0_EQ, 40 */
		/* 8208C554h case   14:*/		if ( regs.CR[0].eq ) { return 0x8208C57C;  }
		/* 8208C554h case   14:*/		return 0x8208C558;
		  /* 8208C558h */ case   15:  		/* lwz R10, <#[R31 + 80]> */
		/* 8208C558h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C558h case   15:*/		return 0x8208C55C;
		  /* 8208C55Ch */ case   16:  		/* addi R11, R11, 7 */
		/* 8208C55Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7);
		/* 8208C55Ch case   16:*/		return 0x8208C560;
	}
	return 0x8208C560;
} // Block from 8208C51Ch-8208C560h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8208C560h
// Function 'WaitForSingleObject'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C560);
		  /* 8208C560h */ case    0:  		/* addi R9, R9, 1548 */
		/* 8208C560h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x60C);
		/* 8208C560h case    0:*/		return 0x8208C564;
		  /* 8208C564h */ case    1:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 8208C564h case    1:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 8208C564h case    1:*/		return 0x8208C568;
	}
	return 0x8208C568;
} // Block from 8208C560h-8208C568h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208C568h
// Function 'WriteFile'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C568);
		  /* 8208C568h */ case    0:  		/* stw R11, <#[R10 + 380]> */
		/* 8208C568h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x0000017C) );
		/* 8208C568h case    0:*/		return 0x8208C56C;
		  /* 8208C56Ch */ case    1:  		/* lwz R11, <#[R31 + 80]> */
		/* 8208C56Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C56Ch case    1:*/		return 0x8208C570;
		  /* 8208C570h */ case    2:  		/* lwz R10, <#[R11 + 380]> */
		/* 8208C570h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000017C) );
		/* 8208C570h case    2:*/		return 0x8208C574;
		  /* 8208C574h */ case    3:  		/* addi R29, R10, 1548 */
		/* 8208C574h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R10,0x60C);
		/* 8208C574h case    3:*/		return 0x8208C578;
		  /* 8208C578h */ case    4:  		/* b 8 */
		/* 8208C578h case    4:*/		return 0x8208C580;
		/* 8208C578h case    4:*/		return 0x8208C57C;
	}
	return 0x8208C57C;
} // Block from 8208C568h-8208C57Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208C57Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C57C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C57C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C57C);
		  /* 8208C57Ch */ case    0:  		/* lwz R11, <#[R31 + 80]> */
		/* 8208C57Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C57Ch case    0:*/		return 0x8208C580;
	}
	return 0x8208C580;
} // Block from 8208C57Ch-8208C580h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208C580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C580);
		  /* 8208C580h */ case    0:  		/* addi R10, R9, 15 */
		/* 8208C580h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xF);
		/* 8208C580h case    0:*/		return 0x8208C584;
		  /* 8208C584h */ case    1:  		/* lis R9, -4353 */
		/* 8208C584h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFEEFF);
		/* 8208C584h case    1:*/		return 0x8208C588;
		  /* 8208C588h */ case    2:  		/* rlwinm R30, R10, 0, 0, 27 */
		/* 8208C588h case    2:*/		cpu::op::rlwinm<0,0,0,27>(regs,&regs.R30,regs.R10);
		/* 8208C588h case    2:*/		return 0x8208C58C;
		  /* 8208C58Ch */ case    3:  		/* li R10, 1 */
		/* 8208C58Ch case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8208C58Ch case    3:*/		return 0x8208C590;
		  /* 8208C590h */ case    4:  		/* rlwinm R8, R30, 28, 16, 31 */
		/* 8208C590h case    4:*/		cpu::op::rlwinm<0,28,16,31>(regs,&regs.R8,regs.R30);
		/* 8208C590h case    4:*/		return 0x8208C594;
		  /* 8208C594h */ case    5:  		/* ori R9, R9, 61183 */
		/* 8208C594h case    5:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0xEEFF);
		/* 8208C594h case    5:*/		return 0x8208C598;
		  /* 8208C598h */ case    6:  		/* sth R8, <#[R11]> */
		/* 8208C598h case    6:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8208C598h case    6:*/		return 0x8208C59C;
		  /* 8208C59Ch */ case    7:  		/* lis R12, 24577 */
		/* 8208C59Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R12,0x6001);
		/* 8208C59Ch case    7:*/		return 0x8208C5A0;
		  /* 8208C5A0h */ case    8:  		/* ori R12, R12, 125 */
		/* 8208C5A0h case    8:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0x7D);
		/* 8208C5A0h case    8:*/		return 0x8208C5A4;
		  /* 8208C5A4h */ case    9:  		/* and R11, R23, R12 */
		/* 8208C5A4h case    9:*/		cpu::op::and<0>(regs,&regs.R11,regs.R23,regs.R12);
		/* 8208C5A4h case    9:*/		return 0x8208C5A8;
		  /* 8208C5A8h */ case   10:  		/* lwz R8, <#[R31 + 80]> */
		/* 8208C5A8h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C5A8h case   10:*/		return 0x8208C5AC;
		  /* 8208C5ACh */ case   11:  		/* stb R10, <#[R8 + 5]> */
		/* 8208C5ACh case   11:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R8 + 0x00000005) );
		/* 8208C5ACh case   11:*/		return 0x8208C5B0;
		  /* 8208C5B0h */ case   12:  		/* lwz R10, <#[R31 + 80]> */
		/* 8208C5B0h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C5B0h case   12:*/		return 0x8208C5B4;
		  /* 8208C5B4h */ case   13:  		/* stw R9, <#[R10 + 16]> */
		/* 8208C5B4h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 8208C5B4h case   13:*/		return 0x8208C5B8;
		  /* 8208C5B8h */ case   14:  		/* lwz R10, <#[R31 + 80]> */
		/* 8208C5B8h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C5B8h case   14:*/		return 0x8208C5BC;
		  /* 8208C5BCh */ case   15:  		/* stw R23, <#[R10 + 20]> */
		/* 8208C5BCh case   15:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R10 + 0x00000014) );
		/* 8208C5BCh case   15:*/		return 0x8208C5C0;
		  /* 8208C5C0h */ case   16:  		/* lwz R10, <#[R31 + 80]> */
		/* 8208C5C0h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C5C0h case   16:*/		return 0x8208C5C4;
		  /* 8208C5C4h */ case   17:  		/* stw R11, <#[R10 + 24]> */
		/* 8208C5C4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000018) );
		/* 8208C5C4h case   17:*/		return 0x8208C5C8;
		  /* 8208C5C8h */ case   18:  		/* lwz R11, <#[R31 + 80]> */
		/* 8208C5C8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C5C8h case   18:*/		return 0x8208C5CC;
		  /* 8208C5CCh */ case   19:  		/* sth R25, <#[R11 + 368]> */
		/* 8208C5CCh case   19:*/		cpu::mem::store16( regs, regs.R25, (uint32)(regs.R11 + 0x00000170) );
		/* 8208C5CCh case   19:*/		return 0x8208C5D0;
		  /* 8208C5D0h */ case   20:  		/* lwz R11, <#[R31 + 80]> */
		/* 8208C5D0h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C5D0h case   20:*/		return 0x8208C5D4;
		  /* 8208C5D4h */ case   21:  		/* subf R10, R11, R29 */
		/* 8208C5D4h case   21:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R29);
		/* 8208C5D4h case   21:*/		return 0x8208C5D8;
		  /* 8208C5D8h */ case   22:  		/* sth R10, <#[R11 + 58]> */
		/* 8208C5D8h case   22:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R11 + 0x0000003A) );
		/* 8208C5D8h case   22:*/		return 0x8208C5DC;
		  /* 8208C5DCh */ case   23:  		/* lwz R11, <#[R31 + 80]> */
		/* 8208C5DCh case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C5DCh case   23:*/		return 0x8208C5E0;
		  /* 8208C5E0h */ case   24:  		/* stw R21, <#[R11 + 60]> */
		/* 8208C5E0h case   24:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R11 + 0x0000003C) );
		/* 8208C5E0h case   24:*/		return 0x8208C5E4;
		  /* 8208C5E4h */ case   25:  		/* bl 1968404 */
		/* 8208C5E4h case   25:*/		regs.LR = 0x8208C5E8; return 0x8226CEF8;
		/* 8208C5E4h case   25:*/		return 0x8208C5E8;
		  /* 8208C5E8h */ case   26:  		/* lwz R10, <#[R31 + 80]> */
		/* 8208C5E8h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C5E8h case   26:*/		return 0x8208C5EC;
		  /* 8208C5ECh */ case   27:  		/* li R11, 128 */
		/* 8208C5ECh case   27:*/		cpu::op::li<0>(regs,&regs.R11,0x80);
		/* 8208C5ECh case   27:*/		return 0x8208C5F0;
		  /* 8208C5F0h */ case   28:  		/* stb R3, <#[R10 + 379]> */
		/* 8208C5F0h case   28:*/		cpu::mem::store8( regs, regs.R3, (uint32)(regs.R10 + 0x0000017B) );
		/* 8208C5F0h case   28:*/		return 0x8208C5F4;
		  /* 8208C5F4h */ case   29:  		/* lwz R10, <#[R31 + 80]> */
		/* 8208C5F4h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C5F4h case   29:*/		return 0x8208C5F8;
		  /* 8208C5F8h */ case   30:  		/* mtspr CTR, R11 */
		/* 8208C5F8h case   30:*/		regs.CTR = regs.R11;
		/* 8208C5F8h case   30:*/		return 0x8208C5FC;
		  /* 8208C5FCh */ case   31:  		/* stw R27, <#[R10 + 1424]> */
		/* 8208C5FCh case   31:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R10 + 0x00000590) );
		/* 8208C5FCh case   31:*/		return 0x8208C600;
		  /* 8208C600h */ case   32:  		/* lwz R11, <#[R31 + 80]> */
		/* 8208C600h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C600h case   32:*/		return 0x8208C604;
		  /* 8208C604h */ case   33:  		/* addi R11, R11, 384 */
		/* 8208C604h case   33:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x180);
		/* 8208C604h case   33:*/		return 0x8208C608;
		  /* 8208C608h */ case   34:  		/* stw R11, <#[R11]> */
		/* 8208C608h case   34:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8208C608h case   34:*/		return 0x8208C60C;
		  /* 8208C60Ch */ case   35:  		/* stw R11, <#[R11 + 4]> */
		/* 8208C60Ch case   35:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8208C60Ch case   35:*/		return 0x8208C610;
		  /* 8208C610h */ case   36:  		/* addi R11, R11, 8 */
		/* 8208C610h case   36:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8208C610h case   36:*/		return 0x8208C614;
		  /* 8208C614h */ case   37:  		/* bc 16, CR0_LT, -12 */
		/* 8208C614h case   37:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8208C608;  }
		/* 8208C614h case   37:*/		return 0x8208C618;
		  /* 8208C618h */ case   38:  		/* lwz R10, <#[R31 + 80]> */
		/* 8208C618h case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C618h case   38:*/		return 0x8208C61C;
		  /* 8208C61Ch */ case   39:  		/* cmpwi CR6, R20, -1 */
		/* 8208C61Ch case   39:*/		cpu::op::cmpwi<6>(regs,regs.R20,0xFFFFFFFF);
		/* 8208C61Ch case   39:*/		return 0x8208C620;
		  /* 8208C620h */ case   40:  		/* addi R11, R10, 88 */
		/* 8208C620h case   40:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x58);
		/* 8208C620h case   40:*/		return 0x8208C624;
		  /* 8208C624h */ case   41:  		/* stw R11, <#[R10 + 88]> */
		/* 8208C624h case   41:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000058) );
		/* 8208C624h case   41:*/		return 0x8208C628;
		  /* 8208C628h */ case   42:  		/* stw R11, <#[R10 + 92]> */
		/* 8208C628h case   42:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x0000005C) );
		/* 8208C628h case   42:*/		return 0x8208C62C;
		  /* 8208C62Ch */ case   43:  		/* bc 4, CR6_EQ, 16 */
		/* 8208C62Ch case   43:*/		if ( !regs.CR[6].eq ) { return 0x8208C63C;  }
		/* 8208C62Ch case   43:*/		return 0x8208C630;
		  /* 8208C630h */ case   44:  		/* mr R3, R29 */
		/* 8208C630h case   44:*/		regs.R3 = regs.R29;
		/* 8208C630h case   44:*/		return 0x8208C634;
		  /* 8208C634h */ case   45:  		/* mr R20, R29 */
		/* 8208C634h case   45:*/		regs.R20 = regs.R29;
		/* 8208C634h case   45:*/		return 0x8208C638;
		  /* 8208C638h */ case   46:  		/* bl 1968688 */
		/* 8208C638h case   46:*/		regs.LR = 0x8208C63C; return 0x8226D068;
		/* 8208C638h case   46:*/		return 0x8208C63C;
	}
	return 0x8208C63C;
} // Block from 8208C580h-8208C63Ch (47 instructions)

//////////////////////////////////////////////////////
// Block at 8208C63Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C63C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C63C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C63C);
		  /* 8208C63Ch */ case    0:  		/* lwz R11, <#[R31 + 80]> */
		/* 8208C63Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C63Ch case    0:*/		return 0x8208C640;
		  /* 8208C640h */ case    1:  		/* mr R8, R28 */
		/* 8208C640h case    1:*/		regs.R8 = regs.R28;
		/* 8208C640h case    1:*/		return 0x8208C644;
		  /* 8208C644h */ case    2:  		/* mr R6, R26 */
		/* 8208C644h case    2:*/		regs.R6 = regs.R26;
		/* 8208C644h case    2:*/		return 0x8208C648;
		  /* 8208C648h */ case    3:  		/* li R5, 0 */
		/* 8208C648h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8208C648h case    3:*/		return 0x8208C64C;
		  /* 8208C64Ch */ case    4:  		/* stw R20, <#[R11 + 1408]> */
		/* 8208C64Ch case    4:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R11 + 0x00000580) );
		/* 8208C64Ch case    4:*/		return 0x8208C650;
		  /* 8208C650h */ case    5:  		/* lwz R11, <#[R31 + 324]> */
		/* 8208C650h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000144) );
		/* 8208C650h case    5:*/		return 0x8208C654;
		  /* 8208C654h */ case    6:  		/* lwz R3, <#[R31 + 80]> */
		/* 8208C654h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C654h case    6:*/		return 0x8208C658;
		  /* 8208C658h */ case    7:  		/* add R4, R30, R3 */
		/* 8208C658h case    7:*/		cpu::op::add<0>(regs,&regs.R4,regs.R30,regs.R3);
		/* 8208C658h case    7:*/		return 0x8208C65C;
		  /* 8208C65Ch */ case    8:  		/* lwz R7, <#[R31 + 84]> */
		/* 8208C65Ch case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000054) );
		/* 8208C65Ch case    8:*/		return 0x8208C660;
		  /* 8208C660h */ case    9:  		/* add R9, R7, R11 */
		/* 8208C660h case    9:*/		cpu::op::add<0>(regs,&regs.R9,regs.R7,regs.R11);
		/* 8208C660h case    9:*/		return 0x8208C664;
		  /* 8208C664h */ case   10:  		/* bl -3116 */
		/* 8208C664h case   10:*/		regs.LR = 0x8208C668; return 0x8208BA38;
		/* 8208C664h case   10:*/		return 0x8208C668;
		  /* 8208C668h */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 8208C668h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8208C668h case   11:*/		return 0x8208C66C;
		  /* 8208C66Ch */ case   12:  		/* bc 12, CR0_EQ, -1132 */
		/* 8208C66Ch case   12:*/		if ( regs.CR[0].eq ) { return 0x8208C200;  }
		/* 8208C66Ch case   12:*/		return 0x8208C670;
		  /* 8208C670h */ case   13:  		/* lwz R11, <#[R31 + 80]> */
		/* 8208C670h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C670h case   13:*/		return 0x8208C674;
		  /* 8208C674h */ case   14:  		/* rlwinm. R10, R23, 0, 15, 15 */
		/* 8208C674h case   14:*/		cpu::op::rlwinm<1,0,15,15>(regs,&regs.R10,regs.R23);
		/* 8208C674h case   14:*/		return 0x8208C678;
		  /* 8208C678h */ case   15:  		/* sth R21, <#[R11 + 56]> */
		/* 8208C678h case   15:*/		cpu::mem::store16( regs, regs.R21, (uint32)(regs.R11 + 0x00000038) );
		/* 8208C678h case   15:*/		return 0x8208C67C;
		  /* 8208C67Ch */ case   16:  		/* lwz R11, <#[R31 + 132]> */
		/* 8208C67Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 8208C67Ch case   16:*/		return 0x8208C680;
		  /* 8208C680h */ case   17:  		/* lwz R10, <#[R31 + 80]> */
		/* 8208C680h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C680h case   17:*/		return 0x8208C684;
		  /* 8208C684h */ case   18:  		/* stw R11, <#[R10 + 32]> */
		/* 8208C684h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000020) );
		/* 8208C684h case   18:*/		return 0x8208C688;
		  /* 8208C688h */ case   19:  		/* lwz R11, <#[R31 + 80]> */
		/* 8208C688h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C688h case   19:*/		return 0x8208C68C;
		  /* 8208C68Ch */ case   20:  		/* lwz R10, <#[R31 + 136]> */
		/* 8208C68Ch case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000088) );
		/* 8208C68Ch case   20:*/		return 0x8208C690;
	}
	return 0x8208C690;
} // Block from 8208C63Ch-8208C690h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8208C690h
// Function 'CreateEventA'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C690);
		  /* 8208C690h */ case    0:  		/* stw R10, <#[R11 + 36]> */
		/* 8208C690h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000024) );
		/* 8208C690h case    0:*/		return 0x8208C694;
		  /* 8208C694h */ case    1:  		/* lwz R11, <#[R31 + 80]> */
		/* 8208C694h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C694h case    1:*/		return 0x8208C698;
		  /* 8208C698h */ case    2:  		/* lwz R10, <#[R31 + 140]> */
		/* 8208C698h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000008C) );
		/* 8208C698h case    2:*/		return 0x8208C69C;
		  /* 8208C69Ch */ case    3:  		/* rlwinm R10, R10, 28, 4, 31 */
		/* 8208C69Ch case    3:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R10,regs.R10);
		/* 8208C69Ch case    3:*/		return 0x8208C6A0;
		  /* 8208C6A0h */ case    4:  		/* stw R10, <#[R11 + 40]> */
		/* 8208C6A0h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000028) );
		/* 8208C6A0h case    4:*/		return 0x8208C6A4;
		  /* 8208C6A4h */ case    5:  		/* lwz R11, <#[R31 + 144]> */
		/* 8208C6A4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000090) );
		/* 8208C6A4h case    5:*/		return 0x8208C6A8;
		  /* 8208C6A8h */ case    6:  		/* rlwinm R11, R11, 28, 4, 31 */
		/* 8208C6A8h case    6:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R11,regs.R11);
		/* 8208C6A8h case    6:*/		return 0x8208C6AC;
		  /* 8208C6ACh */ case    7:  		/* lwz R10, <#[R31 + 80]> */
		/* 8208C6ACh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C6ACh case    7:*/		return 0x8208C6B0;
		  /* 8208C6B0h */ case    8:  		/* stw R11, <#[R10 + 44]> */
		/* 8208C6B0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x0000002C) );
		/* 8208C6B0h case    8:*/		return 0x8208C6B4;
		  /* 8208C6B4h */ case    9:  		/* lwz R11, <#[R31 + 80]> */
		/* 8208C6B4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C6B4h case    9:*/		return 0x8208C6B8;
		  /* 8208C6B8h */ case   10:  		/* lwz R10, <#[R31 + 148]> */
		/* 8208C6B8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000094) );
		/* 8208C6B8h case   10:*/		return 0x8208C6BC;
		  /* 8208C6BCh */ case   11:  		/* stw R10, <#[R11 + 52]> */
		/* 8208C6BCh case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000034) );
		/* 8208C6BCh case   11:*/		return 0x8208C6C0;
		  /* 8208C6C0h */ case   12:  		/* lwz R11, <#[R31 + 80]> */
		/* 8208C6C0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C6C0h case   12:*/		return 0x8208C6C4;
		  /* 8208C6C4h */ case   13:  		/* lwz R10, <#[R31 + 152]> */
		/* 8208C6C4h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000098) );
		/* 8208C6C4h case   13:*/		return 0x8208C6C8;
		  /* 8208C6C8h */ case   14:  		/* addi R10, R10, 15 */
		/* 8208C6C8h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xF);
		/* 8208C6C8h case   14:*/		return 0x8208C6CC;
		  /* 8208C6CCh */ case   15:  		/* rlwinm R10, R10, 28, 4, 31 */
		/* 8208C6CCh case   15:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R10,regs.R10);
		/* 8208C6CCh case   15:*/		return 0x8208C6D0;
		  /* 8208C6D0h */ case   16:  		/* stw R10, <#[R11 + 28]> */
		/* 8208C6D0h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000001C) );
		/* 8208C6D0h case   16:*/		return 0x8208C6D4;
		  /* 8208C6D4h */ case   17:  		/* lwz R11, <#[R31 + 164]> */
		/* 8208C6D4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000A4) );
		/* 8208C6D4h case   17:*/		return 0x8208C6D8;
		  /* 8208C6D8h */ case   18:  		/* lwz R10, <#[R31 + 80]> */
		/* 8208C6D8h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C6D8h case   18:*/		return 0x8208C6DC;
		  /* 8208C6DCh */ case   19:  		/* stw R11, <#[R10 + 1412]> */
		/* 8208C6DCh case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000584) );
		/* 8208C6DCh case   19:*/		return 0x8208C6E0;
		  /* 8208C6E0h */ case   20:  		/* lwz R11, <#[R31 + 80]> */
		/* 8208C6E0h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C6E0h case   20:*/		return 0x8208C6E4;
		  /* 8208C6E4h */ case   21:  		/* li R10, 31 */
		/* 8208C6E4h case   21:*/		cpu::op::li<0>(regs,&regs.R10,0x1F);
		/* 8208C6E4h case   21:*/		return 0x8208C6E8;
		  /* 8208C6E8h */ case   22:  		/* li R9, -16 */
		/* 8208C6E8h case   22:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFF0);
		/* 8208C6E8h case   22:*/		return 0x8208C6EC;
		  /* 8208C6ECh */ case   23:  		/* stw R10, <#[R11 + 80]> */
		/* 8208C6ECh case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000050) );
		/* 8208C6ECh case   23:*/		return 0x8208C6F0;
		  /* 8208C6F0h */ case   24:  		/* lwz R11, <#[R31 + 80]> */
		/* 8208C6F0h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C6F0h case   24:*/		return 0x8208C6F4;
		  /* 8208C6F4h */ case   25:  		/* stw R9, <#[R11 + 84]> */
		/* 8208C6F4h case   25:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000054) );
		/* 8208C6F4h case   25:*/		return 0x8208C6F8;
		  /* 8208C6F8h */ case   26:  		/* lwz R3, <#[R31 + 80]> */
		/* 8208C6F8h case   26:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C6F8h case   26:*/		return 0x8208C6FC;
	}
	return 0x8208C6FC;
} // Block from 8208C690h-8208C6FCh (27 instructions)

//////////////////////////////////////////////////////
// Block at 8208C6FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C6FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C6FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C6FC);
		  /* 8208C6FCh */ case    0:  		/* addi R1, R31, 288 */
		/* 8208C6FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0x120);
		/* 8208C6FCh case    0:*/		return 0x8208C700;
		  /* 8208C700h */ case    1:  		/* b 19336 */
		/* 8208C700h case    1:*/		return 0x82091288;
		/* 8208C700h case    1:*/		return 0x8208C704;
	}
	return 0x8208C704;
} // Block from 8208C6FCh-8208C704h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208C704h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C704( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C704) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C704);
		  /* 8208C704h */ case    0:  		/* li R3, 1 */
		/* 8208C704h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8208C704h case    0:*/		return 0x8208C708;
		  /* 8208C708h */ case    1:  		/* nop */
		/* 8208C708h case    1:*/		cpu::op::nop();
		/* 8208C708h case    1:*/		return 0x8208C70C;
		  /* 8208C70Ch */ case    2:  		/* bclr 20, CR0_LT */
		/* 8208C70Ch case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208C70Ch case    2:*/		return 0x8208C710;
	}
	return 0x8208C710;
} // Block from 8208C704h-8208C710h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208C710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C710);
		  /* 8208C710h */ case    0:  		/* lwz R17, <#[R6 - 11576]> */
		/* 8208C710h case    0:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 8208C710h case    0:*/		return 0x8208C714;
		  /* 8208C714h */ case    1:  		/* lwz R16, <#[R4 - 15576]> */
		/* 8208C714h case    1:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC328) );
		/* 8208C714h case    1:*/		return 0x8208C718;
	}
	return 0x8208C718;
} // Block from 8208C710h-8208C718h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208C718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C718);
		  /* 8208C718h */ case    0:  		/* mfspr R12, LR */
		/* 8208C718h case    0:*/		regs.R12 = regs.LR;
		/* 8208C718h case    0:*/		return 0x8208C71C;
		  /* 8208C71Ch */ case    1:  		/* bl 19236 */
		/* 8208C71Ch case    1:*/		regs.LR = 0x8208C720; return 0x82091240;
		/* 8208C71Ch case    1:*/		return 0x8208C720;
		  /* 8208C720h */ case    2:  		/* addi R31, R1, -320 */
		/* 8208C720h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFEC0);
		/* 8208C720h case    2:*/		return 0x8208C724;
		  /* 8208C724h */ case    3:  		/* stwu R1, <#[R1 - 320]> */
		/* 8208C724h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEC0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEC0);
		/* 8208C724h case    3:*/		return 0x8208C728;
		  /* 8208C728h */ case    4:  		/* mr R30, R3 */
		/* 8208C728h case    4:*/		regs.R30 = regs.R3;
		/* 8208C728h case    4:*/		return 0x8208C72C;
		  /* 8208C72Ch */ case    5:  		/* mr R29, R4 */
		/* 8208C72Ch case    5:*/		regs.R29 = regs.R4;
		/* 8208C72Ch case    5:*/		return 0x8208C730;
	}
	return 0x8208C730;
} // Block from 8208C718h-8208C730h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208C730h
// Function 'GetDiskFreeSpaceExA'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C730);
		  /* 8208C730h */ case    0:  		/* mr R25, R5 */
		/* 8208C730h case    0:*/		regs.R25 = regs.R5;
		/* 8208C730h case    0:*/		return 0x8208C734;
		  /* 8208C734h */ case    1:  		/* lwz R11, <#[R3 + 20]> */
		/* 8208C734h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 8208C734h case    1:*/		return 0x8208C738;
		  /* 8208C738h */ case    2:  		/* li R24, 0 */
		/* 8208C738h case    2:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 8208C738h case    2:*/		return 0x8208C73C;
		  /* 8208C73Ch */ case    3:  		/* mr R28, R3 */
		/* 8208C73Ch case    3:*/		regs.R28 = regs.R3;
		/* 8208C73Ch case    3:*/		return 0x8208C740;
		  /* 8208C740h */ case    4:  		/* mr R22, R24 */
		/* 8208C740h case    4:*/		regs.R22 = regs.R24;
		/* 8208C740h case    4:*/		return 0x8208C744;
		  /* 8208C744h */ case    5:  		/* stw R24, <#[R31 + 100]> */
		/* 8208C744h case    5:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000064) );
		/* 8208C744h case    5:*/		return 0x8208C748;
		  /* 8208C748h */ case    6:  		/* rlwinm. R11, R11, 0, 13, 13 */
		/* 8208C748h case    6:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R11,regs.R11);
		/* 8208C748h case    6:*/		return 0x8208C74C;
		  /* 8208C74Ch */ case    7:  		/* stw R3, <#[R31 + 124]> */
		/* 8208C74Ch case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000007C) );
		/* 8208C74Ch case    7:*/		return 0x8208C750;
		  /* 8208C750h */ case    8:  		/* stw R24, <#[R31 + 104]> */
		/* 8208C750h case    8:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000068) );
		/* 8208C750h case    8:*/		return 0x8208C754;
		  /* 8208C754h */ case    9:  		/* bc 12, CR0_EQ, 44 */
		/* 8208C754h case    9:*/		if ( regs.CR[0].eq ) { return 0x8208C780;  }
		/* 8208C754h case    9:*/		return 0x8208C758;
		  /* 8208C758h */ case   10:  		/* bl 1968032 */
		/* 8208C758h case   10:*/		regs.LR = 0x8208C75C; return 0x8226CEF8;
		/* 8208C758h case   10:*/		return 0x8208C75C;
		  /* 8208C75Ch */ case   11:  		/* lbz R11, <#[R28 + 379]> */
		/* 8208C75Ch case   11:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000017B) );
		/* 8208C75Ch case   11:*/		return 0x8208C760;
		  /* 8208C760h */ case   12:  		/* cmpw CR6, R11, R3 */
		/* 8208C760h case   12:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R3);
		/* 8208C760h case   12:*/		return 0x8208C764;
		  /* 8208C764h */ case   13:  		/* bc 12, CR6_EQ, 28 */
		/* 8208C764h case   13:*/		if ( regs.CR[6].eq ) { return 0x8208C780;  }
		/* 8208C764h case   13:*/		return 0x8208C768;
		  /* 8208C768h */ case   14:  		/* mr R7, R25 */
		/* 8208C768h case   14:*/		regs.R7 = regs.R25;
		/* 8208C768h case   14:*/		return 0x8208C76C;
		  /* 8208C76Ch */ case   15:  		/* li R6, 1515 */
		/* 8208C76Ch case   15:*/		cpu::op::li<0>(regs,&regs.R6,0x5EB);
		/* 8208C76Ch case   15:*/		return 0x8208C770;
		  /* 8208C770h */ case   16:  		/* lwz R5, <#[R31 + 312]> */
		/* 8208C770h case   16:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000138) );
		/* 8208C770h case   16:*/		return 0x8208C774;
		  /* 8208C774h */ case   17:  		/* mr R4, R28 */
		/* 8208C774h case   17:*/		regs.R4 = regs.R28;
		/* 8208C774h case   17:*/		return 0x8208C778;
		  /* 8208C778h */ case   18:  		/* li R3, 244 */
		/* 8208C778h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0xF4);
		/* 8208C778h case   18:*/		return 0x8208C77C;
		  /* 8208C77Ch */ case   19:  		/* bl 1969356 */
		/* 8208C77Ch case   19:*/		regs.LR = 0x8208C780; return 0x8226D448;
		/* 8208C77Ch case   19:*/		return 0x8208C780;
	}
	return 0x8208C780;
} // Block from 8208C730h-8208C780h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8208C780h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C780);
		  /* 8208C780h */ case    0:  		/* lwz R11, <#[R30 + 24]> */
		/* 8208C780h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 8208C780h case    0:*/		return 0x8208C784;
		  /* 8208C784h */ case    1:  		/* cmplwi CR6, R25, 0 */
		/* 8208C784h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 8208C784h case    1:*/		return 0x8208C788;
		  /* 8208C788h */ case    2:  		/* or R23, R11, R29 */
		/* 8208C788h case    2:*/		cpu::op::or<0>(regs,&regs.R23,regs.R11,regs.R29);
		/* 8208C788h case    2:*/		return 0x8208C78C;
		  /* 8208C78Ch */ case    3:  		/* li R27, 1 */
		/* 8208C78Ch case    3:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 8208C78Ch case    3:*/		return 0x8208C790;
		  /* 8208C790h */ case    4:  		/* mr R11, R25 */
		/* 8208C790h case    4:*/		regs.R11 = regs.R25;
		/* 8208C790h case    4:*/		return 0x8208C794;
		  /* 8208C794h */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 8208C794h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8208C79C;  }
		/* 8208C794h case    5:*/		return 0x8208C798;
		  /* 8208C798h */ case    6:  		/* mr R11, R27 */
		/* 8208C798h case    6:*/		regs.R11 = regs.R27;
		/* 8208C798h case    6:*/		return 0x8208C79C;
	}
	return 0x8208C79C;
} // Block from 8208C780h-8208C79Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208C79Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C79C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C79C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C79C);
		  /* 8208C79Ch */ case    0:  		/* addi R11, R11, 31 */
		/* 8208C79Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1F);
		/* 8208C79Ch case    0:*/		return 0x8208C7A0;
		  /* 8208C7A0h */ case    1:  		/* rlwinm R4, R11, 0, 0, 27 */
		/* 8208C7A0h case    1:*/		cpu::op::rlwinm<0,0,0,27>(regs,&regs.R4,regs.R11);
		/* 8208C7A0h case    1:*/		return 0x8208C7A4;
		  /* 8208C7A4h */ case    2:  		/* stw R4, <#[R31 + 88]> */
		/* 8208C7A4h case    2:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R31 + 0x00000058) );
		/* 8208C7A4h case    2:*/		return 0x8208C7A8;
		  /* 8208C7A8h */ case    3:  		/* rlwinm R29, R4, 28, 4, 31 */
		/* 8208C7A8h case    3:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R29,regs.R4);
		/* 8208C7A8h case    3:*/		return 0x8208C7AC;
		  /* 8208C7ACh */ case    4:  		/* nop */
		/* 8208C7ACh case    4:*/		cpu::op::nop();
		/* 8208C7ACh case    4:*/		return 0x8208C7B0;
	}
	return 0x8208C7B0;
} // Block from 8208C79Ch-8208C7B0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208C7B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C7B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C7B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C7B0);
		  /* 8208C7B0h */ case    0:  		/* rlwinm. R11, R23, 0, 31, 31 */
		/* 8208C7B0h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R23);
		/* 8208C7B0h case    0:*/		return 0x8208C7B4;
		  /* 8208C7B4h */ case    1:  		/* bc 4, CR0_EQ, 24 */
		/* 8208C7B4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8208C7CC;  }
		/* 8208C7B4h case    1:*/		return 0x8208C7B8;
		  /* 8208C7B8h */ case    2:  		/* lwz R3, <#[R30 + 1408]> */
		/* 8208C7B8h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000580) );
		/* 8208C7B8h case    2:*/		return 0x8208C7BC;
		  /* 8208C7BCh */ case    3:  		/* bl 1968252 */
		/* 8208C7BCh case    3:*/		regs.LR = 0x8208C7C0; return 0x8226D038;
		/* 8208C7BCh case    3:*/		return 0x8208C7C0;
		  /* 8208C7C0h */ case    4:  		/* mr R22, R27 */
		/* 8208C7C0h case    4:*/		regs.R22 = regs.R27;
		/* 8208C7C0h case    4:*/		return 0x8208C7C4;
		  /* 8208C7C4h */ case    5:  		/* stw R27, <#[R31 + 104]> */
		/* 8208C7C4h case    5:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000068) );
		/* 8208C7C4h case    5:*/		return 0x8208C7C8;
		  /* 8208C7C8h */ case    6:  		/* lwz R4, <#[R31 + 88]> */
		/* 8208C7C8h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000058) );
		/* 8208C7C8h case    6:*/		return 0x8208C7CC;
	}
	return 0x8208C7CC;
} // Block from 8208C7B0h-8208C7CCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208C7CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C7CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C7CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C7CC);
		  /* 8208C7CCh */ case    0:  		/* cmplwi CR6, R29, 128 */
		/* 8208C7CCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000080);
		/* 8208C7CCh case    0:*/		return 0x8208C7D0;
		  /* 8208C7D0h */ case    1:  		/* bc 4, CR6_LT, 500 */
		/* 8208C7D0h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8208C9C4;  }
		/* 8208C7D0h case    1:*/		return 0x8208C7D4;
		  /* 8208C7D4h */ case    2:  		/* addi R11, R29, 48 */
		/* 8208C7D4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x30);
		/* 8208C7D4h case    2:*/		return 0x8208C7D8;
		  /* 8208C7D8h */ case    3:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8208C7D8h case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8208C7D8h case    3:*/		return 0x8208C7DC;
		  /* 8208C7DCh */ case    4:  		/* add R11, R11, R30 */
		/* 8208C7DCh case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8208C7DCh case    4:*/		return 0x8208C7E0;
		  /* 8208C7E0h */ case    5:  		/* lwz R10, <#[R11]> */
		/* 8208C7E0h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208C7E0h case    5:*/		return 0x8208C7E4;
		  /* 8208C7E4h */ case    6:  		/* cmplw CR6, R10, R11 */
		/* 8208C7E4h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208C7E4h case    6:*/		return 0x8208C7E8;
		  /* 8208C7E8h */ case    7:  		/* bc 12, CR6_EQ, 160 */
		/* 8208C7E8h case    7:*/		if ( regs.CR[6].eq ) { return 0x8208C888;  }
		/* 8208C7E8h case    7:*/		return 0x8208C7EC;
		  /* 8208C7ECh */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 8208C7ECh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8208C7ECh case    8:*/		return 0x8208C7F0;
		  /* 8208C7F0h */ case    9:  		/* addi R11, R11, -8 */
		/* 8208C7F0h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFF8);
		/* 8208C7F0h case    9:*/		return 0x8208C7F4;
		  /* 8208C7F4h */ case   10:  		/* stw R11, <#[R31 + 92]> */
		/* 8208C7F4h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208C7F4h case   10:*/		return 0x8208C7F8;
		  /* 8208C7F8h */ case   11:  		/* addi R8, R11, 8 */
		/* 8208C7F8h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x8);
		/* 8208C7F8h case   11:*/		return 0x8208C7FC;
		  /* 8208C7FCh */ case   12:  		/* lbz R6, <#[R11 + 5]> */
		/* 8208C7FCh case   12:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000005) );
		/* 8208C7FCh case   12:*/		return 0x8208C800;
		  /* 8208C800h */ case   13:  		/* stb R6, <#[R31 + 80]> */
		/* 8208C800h case   13:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R31 + 0x00000050) );
		/* 8208C800h case   13:*/		return 0x8208C804;
		  /* 8208C804h */ case   14:  		/* lwz R10, <#[R11 + 12]> */
		/* 8208C804h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8208C804h case   14:*/		return 0x8208C808;
		  /* 8208C808h */ case   15:  		/* lwz R9, <#[R11 + 8]> */
		/* 8208C808h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8208C808h case   15:*/		return 0x8208C80C;
		  /* 8208C80Ch */ case   16:  		/* lwz R7, <#[R10]> */
		/* 8208C80Ch case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 8208C80Ch case   16:*/		return 0x8208C810;
		  /* 8208C810h */ case   17:  		/* lwz R5, <#[R9 + 4]> */
		/* 8208C810h case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000004) );
		/* 8208C810h case   17:*/		return 0x8208C814;
		  /* 8208C814h */ case   18:  		/* cmplw CR6, R7, R5 */
		/* 8208C814h case   18:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R5);
		/* 8208C814h case   18:*/		return 0x8208C818;
		  /* 8208C818h */ case   19:  		/* bc 4, CR6_EQ, 64 */
		/* 8208C818h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8208C858;  }
		/* 8208C818h case   19:*/		return 0x8208C81C;
		  /* 8208C81Ch */ case   20:  		/* cmplw CR6, R7, R8 */
		/* 8208C81Ch case   20:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 8208C81Ch case   20:*/		return 0x8208C820;
		  /* 8208C820h */ case   21:  		/* bc 4, CR6_EQ, 56 */
		/* 8208C820h case   21:*/		if ( !regs.CR[6].eq ) { return 0x8208C858;  }
		/* 8208C820h case   21:*/		return 0x8208C824;
		  /* 8208C824h */ case   22:  		/* stw R9, <#[R10]> */
		/* 8208C824h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8208C824h case   22:*/		return 0x8208C828;
		  /* 8208C828h */ case   23:  		/* cmplw CR6, R9, R10 */
		/* 8208C828h case   23:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 8208C828h case   23:*/		return 0x8208C82C;
		  /* 8208C82Ch */ case   24:  		/* stw R10, <#[R9 + 4]> */
		/* 8208C82Ch case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 8208C82Ch case   24:*/		return 0x8208C830;
		  /* 8208C830h */ case   25:  		/* bc 4, CR6_EQ, 40 */
		/* 8208C830h case   25:*/		if ( !regs.CR[6].eq ) { return 0x8208C858;  }
		/* 8208C830h case   25:*/		return 0x8208C834;
		  /* 8208C834h */ case   26:  		/* lhz R9, <#[R11]> */
		/* 8208C834h case   26:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8208C834h case   26:*/		return 0x8208C838;
		  /* 8208C838h */ case   27:  		/* rlwinm R10, R9, 27, 5, 31 */
		/* 8208C838h case   27:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R9);
		/* 8208C838h case   27:*/		return 0x8208C83C;
		  /* 8208C83Ch */ case   28:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 8208C83Ch case   28:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8208C83Ch case   28:*/		return 0x8208C840;
	}
	return 0x8208C840;
} // Block from 8208C7CCh-8208C840h (29 instructions)

//////////////////////////////////////////////////////
// Block at 8208C840h
// Function 'CloseHandle'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C840);
		  /* 8208C840h */ case    0:  		/* addi R10, R10, 88 */
		/* 8208C840h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x58);
		/* 8208C840h case    0:*/		return 0x8208C844;
		  /* 8208C844h */ case    1:  		/* slw R9, R27, R9 */
		/* 8208C844h case    1:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R27,regs.R9);
		/* 8208C844h case    1:*/		return 0x8208C848;
		  /* 8208C848h */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8208C848h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8208C848h case    2:*/		return 0x8208C84C;
		  /* 8208C84Ch */ case    3:  		/* lwzx R8, <#[R10 + R30]> */
		/* 8208C84Ch case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 8208C84Ch case    3:*/		return 0x8208C850;
		  /* 8208C850h */ case    4:  		/* xor R9, R8, R9 */
		/* 8208C850h case    4:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8208C850h case    4:*/		return 0x8208C854;
		  /* 8208C854h */ case    5:  		/* stwx R9, <#[R10 + R30]> */
		/* 8208C854h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 8208C854h case    5:*/		return 0x8208C858;
	}
	return 0x8208C858;
} // Block from 8208C840h-8208C858h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208C858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C858);
		  /* 8208C858h */ case    0:  		/* lwz R10, <#[R30 + 48]> */
		/* 8208C858h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000030) );
		/* 8208C858h case    0:*/		return 0x8208C85C;
		  /* 8208C85Ch */ case    1:  		/* mr R26, R11 */
		/* 8208C85Ch case    1:*/		regs.R26 = regs.R11;
		/* 8208C85Ch case    1:*/		return 0x8208C860;
		  /* 8208C860h */ case    2:  		/* subf R10, R29, R10 */
		/* 8208C860h case    2:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R29,regs.R10);
		/* 8208C860h case    2:*/		return 0x8208C864;
		  /* 8208C864h */ case    3:  		/* rlwimi R6, R27, 0, 28, 26 */
		/* 8208C864h case    3:*/		cpu::op::rlwimi<0,0,28,26>(regs,&regs.R6,regs.R27);
		/* 8208C864h case    3:*/		return 0x8208C868;
		  /* 8208C868h */ case    4:  		/* stw R10, <#[R30 + 48]> */
		/* 8208C868h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000030) );
		/* 8208C868h case    4:*/		return 0x8208C86C;
		  /* 8208C86Ch */ case    5:  		/* stw R11, <#[R31 + 128]> */
		/* 8208C86Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000080) );
		/* 8208C86Ch case    5:*/		return 0x8208C870;
		  /* 8208C870h */ case    6:  		/* stb R6, <#[R11 + 5]> */
		/* 8208C870h case    6:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R11 + 0x00000005) );
		/* 8208C870h case    6:*/		return 0x8208C874;
		  /* 8208C874h */ case    7:  		/* lwz R10, <#[R31 + 88]> */
		/* 8208C874h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000058) );
		/* 8208C874h case    7:*/		return 0x8208C878;
		  /* 8208C878h */ case    8:  		/* subf R10, R25, R10 */
		/* 8208C878h case    8:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R25,regs.R10);
		/* 8208C878h case    8:*/		return 0x8208C87C;
		  /* 8208C87Ch */ case    9:  		/* stb R10, <#[R11 + 6]> */
		/* 8208C87Ch case    9:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000006) );
		/* 8208C87Ch case    9:*/		return 0x8208C880;
		  /* 8208C880h */ case   10:  		/* stb R24, <#[R11 + 7]> */
		/* 8208C880h case   10:*/		cpu::mem::store8( regs, regs.R24, (uint32)(regs.R11 + 0x00000007) );
		/* 8208C880h case   10:*/		return 0x8208C884;
		  /* 8208C884h */ case   11:  		/* b 1480 */
		/* 8208C884h case   11:*/		return 0x8208CE4C;
		/* 8208C884h case   11:*/		return 0x8208C888;
	}
	return 0x8208C888;
} // Block from 8208C858h-8208C888h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8208C888h
// Function 'DeleteFileA'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C888);
		  /* 8208C888h */ case    0:  		/* rlwinm R10, R29, 0, 27, 31 */
		/* 8208C888h case    0:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R29);
		/* 8208C888h case    0:*/		return 0x8208C88C;
		  /* 8208C88Ch */ case    1:  		/* rlwinm R11, R29, 27, 5, 31 */
		/* 8208C88Ch case    1:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R29);
		/* 8208C88Ch case    1:*/		return 0x8208C890;
		  /* 8208C890h */ case    2:  		/* slw R10, R27, R10 */
		/* 8208C890h case    2:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R27,regs.R10);
		/* 8208C890h case    2:*/		return 0x8208C894;
		  /* 8208C894h */ case    3:  		/* addi R9, R11, 88 */
		/* 8208C894h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x58);
		/* 8208C894h case    3:*/		return 0x8208C898;
		  /* 8208C898h */ case    4:  		/* addi R8, R10, -1 */
		/* 8208C898h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xFFFFFFFF);
		/* 8208C898h case    4:*/		return 0x8208C89C;
		  /* 8208C89Ch */ case    5:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 8208C89Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 8208C89Ch case    5:*/		return 0x8208C8A0;
		  /* 8208C8A0h */ case    6:  		/* cmplwi CR6, R11, 1 */
		/* 8208C8A0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8208C8A0h case    6:*/		return 0x8208C8A4;
		  /* 8208C8A4h */ case    7:  		/* add R9, R10, R30 */
		/* 8208C8A4h case    7:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R30);
		/* 8208C8A4h case    7:*/		return 0x8208C8A8;
		  /* 8208C8A8h */ case    8:  		/* stw R9, <#[R31 + 96]> */
		/* 8208C8A8h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000060) );
		/* 8208C8A8h case    8:*/		return 0x8208C8AC;
		  /* 8208C8ACh */ case    9:  		/* lwz R10, <#[R9]> */
		/* 8208C8ACh case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8208C8ACh case    9:*/		return 0x8208C8B0;
		  /* 8208C8B0h */ case   10:  		/* addi R9, R9, 4 */
		/* 8208C8B0h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8208C8B0h case   10:*/		return 0x8208C8B4;
		  /* 8208C8B4h */ case   11:  		/* andc R10, R10, R8 */
		/* 8208C8B4h case   11:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8208C8B4h case   11:*/		return 0x8208C8B8;
		  /* 8208C8B8h */ case   12:  		/* stw R10, <#[R31 + 108]> */
		/* 8208C8B8h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000006C) );
		/* 8208C8B8h case   12:*/		return 0x8208C8BC;
		  /* 8208C8BCh */ case   13:  		/* stw R9, <#[R31 + 96]> */
		/* 8208C8BCh case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000060) );
		/* 8208C8BCh case   13:*/		return 0x8208C8C0;
		  /* 8208C8C0h */ case   14:  		/* bc 12, CR6_LT, 24 */
		/* 8208C8C0h case   14:*/		if ( regs.CR[6].lt ) { return 0x8208C8D8;  }
		/* 8208C8C0h case   14:*/		return 0x8208C8C4;
		  /* 8208C8C4h */ case   15:  		/* bc 12, CR6_EQ, 52 */
		/* 8208C8C4h case   15:*/		if ( regs.CR[6].eq ) { return 0x8208C8F8;  }
		/* 8208C8C4h case   15:*/		return 0x8208C8C8;
		  /* 8208C8C8h */ case   16:  		/* cmplwi CR6, R11, 3 */
		/* 8208C8C8h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8208C8C8h case   16:*/		return 0x8208C8CC;
		  /* 8208C8CCh */ case   17:  		/* bc 12, CR6_LT, 76 */
		/* 8208C8CCh case   17:*/		if ( regs.CR[6].lt ) { return 0x8208C918;  }
		/* 8208C8CCh case   17:*/		return 0x8208C8D0;
		  /* 8208C8D0h */ case   18:  		/* bc 12, CR6_EQ, 104 */
		/* 8208C8D0h case   18:*/		if ( regs.CR[6].eq ) { return 0x8208C938;  }
		/* 8208C8D0h case   18:*/		return 0x8208C8D4;
		  /* 8208C8D4h */ case   19:  		/* b 252 */
		/* 8208C8D4h case   19:*/		return 0x8208C9D0;
		/* 8208C8D4h case   19:*/		return 0x8208C8D8;
	}
	return 0x8208C8D8;
} // Block from 8208C888h-8208C8D8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8208C8D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C8D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C8D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C8D8);
		  /* 8208C8D8h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 8208C8D8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8208C8D8h case    0:*/		return 0x8208C8DC;
		  /* 8208C8DCh */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8208C8DCh case    1:*/		if ( regs.CR[6].eq ) { return 0x8208C8E8;  }
		/* 8208C8DCh case    1:*/		return 0x8208C8E0;
		  /* 8208C8E0h */ case    2:  		/* addi R9, R30, 384 */
		/* 8208C8E0h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0x180);
		/* 8208C8E0h case    2:*/		return 0x8208C8E4;
		  /* 8208C8E4h */ case    3:  		/* b 96 */
		/* 8208C8E4h case    3:*/		return 0x8208C944;
		/* 8208C8E4h case    3:*/		return 0x8208C8E8;
	}
	return 0x8208C8E8;
} // Block from 8208C8D8h-8208C8E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208C8E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C8E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C8E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C8E8);
		  /* 8208C8E8h */ case    0:  		/* lwz R10, <#[R9]> */
		/* 8208C8E8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8208C8E8h case    0:*/		return 0x8208C8EC;
		  /* 8208C8ECh */ case    1:  		/* addi R9, R9, 4 */
		/* 8208C8ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8208C8ECh case    1:*/		return 0x8208C8F0;
		  /* 8208C8F0h */ case    2:  		/* stw R10, <#[R31 + 108]> */
		/* 8208C8F0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000006C) );
		/* 8208C8F0h case    2:*/		return 0x8208C8F4;
		  /* 8208C8F4h */ case    3:  		/* stw R9, <#[R31 + 96]> */
		/* 8208C8F4h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000060) );
		/* 8208C8F4h case    3:*/		return 0x8208C8F8;
	}
	return 0x8208C8F8;
} // Block from 8208C8E8h-8208C8F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208C8F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C8F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C8F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C8F8);
		  /* 8208C8F8h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 8208C8F8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8208C8F8h case    0:*/		return 0x8208C8FC;
		  /* 8208C8FCh */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8208C8FCh case    1:*/		if ( regs.CR[6].eq ) { return 0x8208C908;  }
		/* 8208C8FCh case    1:*/		return 0x8208C900;
		  /* 8208C900h */ case    2:  		/* addi R9, R30, 640 */
		/* 8208C900h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0x280);
		/* 8208C900h case    2:*/		return 0x8208C904;
		  /* 8208C904h */ case    3:  		/* b 64 */
		/* 8208C904h case    3:*/		return 0x8208C944;
		/* 8208C904h case    3:*/		return 0x8208C908;
	}
	return 0x8208C908;
} // Block from 8208C8F8h-8208C908h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208C908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C908);
		  /* 8208C908h */ case    0:  		/* lwz R10, <#[R9]> */
		/* 8208C908h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8208C908h case    0:*/		return 0x8208C90C;
		  /* 8208C90Ch */ case    1:  		/* addi R9, R9, 4 */
		/* 8208C90Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8208C90Ch case    1:*/		return 0x8208C910;
		  /* 8208C910h */ case    2:  		/* stw R10, <#[R31 + 108]> */
		/* 8208C910h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000006C) );
		/* 8208C910h case    2:*/		return 0x8208C914;
		  /* 8208C914h */ case    3:  		/* stw R9, <#[R31 + 96]> */
		/* 8208C914h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000060) );
		/* 8208C914h case    3:*/		return 0x8208C918;
	}
	return 0x8208C918;
} // Block from 8208C908h-8208C918h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208C918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C918);
		  /* 8208C918h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 8208C918h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8208C918h case    0:*/		return 0x8208C91C;
		  /* 8208C91Ch */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8208C91Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8208C928;  }
		/* 8208C91Ch case    1:*/		return 0x8208C920;
		  /* 8208C920h */ case    2:  		/* addi R9, R30, 896 */
		/* 8208C920h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0x380);
		/* 8208C920h case    2:*/		return 0x8208C924;
		  /* 8208C924h */ case    3:  		/* b 32 */
		/* 8208C924h case    3:*/		return 0x8208C944;
		/* 8208C924h case    3:*/		return 0x8208C928;
	}
	return 0x8208C928;
} // Block from 8208C918h-8208C928h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208C928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C928);
		  /* 8208C928h */ case    0:  		/* lwz R10, <#[R9]> */
		/* 8208C928h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8208C928h case    0:*/		return 0x8208C92C;
		  /* 8208C92Ch */ case    1:  		/* addi R11, R9, 4 */
		/* 8208C92Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x4);
		/* 8208C92Ch case    1:*/		return 0x8208C930;
		  /* 8208C930h */ case    2:  		/* stw R10, <#[R31 + 108]> */
		/* 8208C930h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000006C) );
		/* 8208C930h case    2:*/		return 0x8208C934;
		  /* 8208C934h */ case    3:  		/* stw R11, <#[R31 + 96]> */
		/* 8208C934h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 8208C934h case    3:*/		return 0x8208C938;
	}
	return 0x8208C938;
} // Block from 8208C928h-8208C938h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208C938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C938);
		  /* 8208C938h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 8208C938h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8208C938h case    0:*/		return 0x8208C93C;
		  /* 8208C93Ch */ case    1:  		/* bc 12, CR6_EQ, 148 */
		/* 8208C93Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8208C9D0;  }
		/* 8208C93Ch case    1:*/		return 0x8208C940;
	}
	return 0x8208C940;
} // Block from 8208C938h-8208C940h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208C940h
// Function 'FreeLibrary'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C940);
		  /* 8208C940h */ case    0:  		/* addi R9, R30, 1152 */
		/* 8208C940h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0x480);
		/* 8208C940h case    0:*/		return 0x8208C944;
	}
	return 0x8208C944;
} // Block from 8208C940h-8208C944h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208C944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C944);
		  /* 8208C944h */ case    0:  		/* addi R11, R10, -1 */
		/* 8208C944h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 8208C944h case    0:*/		return 0x8208C948;
		  /* 8208C948h */ case    1:  		/* andc R11, R10, R11 */
		/* 8208C948h case    1:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208C948h case    1:*/		return 0x8208C94C;
		  /* 8208C94Ch */ case    2:  		/* cntlzw R11, R11 */
		/* 8208C94Ch case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8208C94Ch case    2:*/		return 0x8208C950;
		  /* 8208C950h */ case    3:  		/* subfic R11, R11, 31 */
		/* 8208C950h case    3:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x1F);
		/* 8208C950h case    3:*/		return 0x8208C954;
		  /* 8208C954h */ case    4:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8208C954h case    4:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8208C954h case    4:*/		return 0x8208C958;
		  /* 8208C958h */ case    5:  		/* add R11, R11, R9 */
		/* 8208C958h case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8208C958h case    5:*/		return 0x8208C95C;
		  /* 8208C95Ch */ case    6:  		/* lwz R11, <#[R11 + 4]> */
		/* 8208C95Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8208C95Ch case    6:*/		return 0x8208C960;
		  /* 8208C960h */ case    7:  		/* addi R3, R11, -8 */
		/* 8208C960h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFF8);
		/* 8208C960h case    7:*/		return 0x8208C964;
		  /* 8208C964h */ case    8:  		/* stw R3, <#[R31 + 92]> */
		/* 8208C964h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208C964h case    8:*/		return 0x8208C968;
		  /* 8208C968h */ case    9:  		/* addi R9, R3, 8 */
		/* 8208C968h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x8);
		/* 8208C968h case    9:*/		return 0x8208C96C;
		  /* 8208C96Ch */ case   10:  		/* lwz R11, <#[R3 + 12]> */
		/* 8208C96Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8208C96Ch case   10:*/		return 0x8208C970;
		  /* 8208C970h */ case   11:  		/* lwz R10, <#[R3 + 8]> */
		/* 8208C970h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 8208C970h case   11:*/		return 0x8208C974;
		  /* 8208C974h */ case   12:  		/* lwz R8, <#[R11]> */
		/* 8208C974h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8208C974h case   12:*/		return 0x8208C978;
	}
	return 0x8208C978;
} // Block from 8208C944h-8208C978h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8208C978h
// Function 'GetProcAddress'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C978);
		  /* 8208C978h */ case    0:  		/* lwz R7, <#[R10 + 4]> */
		/* 8208C978h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 8208C978h case    0:*/		return 0x8208C97C;
		  /* 8208C97Ch */ case    1:  		/* cmplw CR6, R8, R7 */
		/* 8208C97Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 8208C97Ch case    1:*/		return 0x8208C980;
		  /* 8208C980h */ case    2:  		/* bc 4, CR6_EQ, 292 */
		/* 8208C980h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8208CAA4;  }
		/* 8208C980h case    2:*/		return 0x8208C984;
		  /* 8208C984h */ case    3:  		/* cmplw CR6, R8, R9 */
		/* 8208C984h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8208C984h case    3:*/		return 0x8208C988;
		  /* 8208C988h */ case    4:  		/* bc 4, CR6_EQ, 284 */
		/* 8208C988h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8208CAA4;  }
		/* 8208C988h case    4:*/		return 0x8208C98C;
		  /* 8208C98Ch */ case    5:  		/* stw R10, <#[R11]> */
		/* 8208C98Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208C98Ch case    5:*/		return 0x8208C990;
		  /* 8208C990h */ case    6:  		/* cmplw CR6, R10, R11 */
		/* 8208C990h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208C990h case    6:*/		return 0x8208C994;
		  /* 8208C994h */ case    7:  		/* stw R11, <#[R10 + 4]> */
		/* 8208C994h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8208C994h case    7:*/		return 0x8208C998;
		  /* 8208C998h */ case    8:  		/* bc 4, CR6_EQ, 268 */
		/* 8208C998h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8208CAA4;  }
		/* 8208C998h case    8:*/		return 0x8208C99C;
		  /* 8208C99Ch */ case    9:  		/* lhz R10, <#[R3]> */
		/* 8208C99Ch case    9:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8208C99Ch case    9:*/		return 0x8208C9A0;
		  /* 8208C9A0h */ case   10:  		/* rlwinm R11, R10, 27, 5, 31 */
		/* 8208C9A0h case   10:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R10);
		/* 8208C9A0h case   10:*/		return 0x8208C9A4;
		  /* 8208C9A4h */ case   11:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 8208C9A4h case   11:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 8208C9A4h case   11:*/		return 0x8208C9A8;
		  /* 8208C9A8h */ case   12:  		/* addi R11, R11, 88 */
		/* 8208C9A8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x58);
		/* 8208C9A8h case   12:*/		return 0x8208C9AC;
		  /* 8208C9ACh */ case   13:  		/* slw R10, R27, R10 */
		/* 8208C9ACh case   13:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R27,regs.R10);
		/* 8208C9ACh case   13:*/		return 0x8208C9B0;
		  /* 8208C9B0h */ case   14:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8208C9B0h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8208C9B0h case   14:*/		return 0x8208C9B4;
		  /* 8208C9B4h */ case   15:  		/* lwzx R9, <#[R11 + R30]> */
		/* 8208C9B4h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8208C9B4h case   15:*/		return 0x8208C9B8;
		  /* 8208C9B8h */ case   16:  		/* xor R10, R9, R10 */
		/* 8208C9B8h case   16:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8208C9B8h case   16:*/		return 0x8208C9BC;
		  /* 8208C9BCh */ case   17:  		/* stwx R10, <#[R11 + R30]> */
		/* 8208C9BCh case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8208C9BCh case   17:*/		return 0x8208C9C0;
		  /* 8208C9C0h */ case   18:  		/* b 228 */
		/* 8208C9C0h case   18:*/		return 0x8208CAA4;
		/* 8208C9C0h case   18:*/		return 0x8208C9C4;
	}
	return 0x8208C9C4;
} // Block from 8208C978h-8208C9C4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8208C9C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C9C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C9C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C9C4);
		  /* 8208C9C4h */ case    0:  		/* lwz R11, <#[R30 + 28]> */
		/* 8208C9C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 8208C9C4h case    0:*/		return 0x8208C9C8;
		  /* 8208C9C8h */ case    1:  		/* cmplw CR6, R29, R11 */
		/* 8208C9C8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8208C9C8h case    1:*/		return 0x8208C9CC;
		  /* 8208C9CCh */ case    2:  		/* bc 12, CR6_GT, 1212 */
		/* 8208C9CCh case    2:*/		if ( regs.CR[6].gt ) { return 0x8208CE88;  }
		/* 8208C9CCh case    2:*/		return 0x8208C9D0;
	}
	return 0x8208C9D0;
} // Block from 8208C9C4h-8208C9D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208C9D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C9D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C9D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C9D0);
		  /* 8208C9D0h */ case    0:  		/* lwz R11, <#[R30 + 388]> */
		/* 8208C9D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000184) );
		/* 8208C9D0h case    0:*/		return 0x8208C9D4;
		  /* 8208C9D4h */ case    1:  		/* addi R10, R30, 384 */
		/* 8208C9D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x180);
		/* 8208C9D4h case    1:*/		return 0x8208C9D8;
		  /* 8208C9D8h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 8208C9D8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208C9D8h case    2:*/		return 0x8208C9DC;
		  /* 8208C9DCh */ case    3:  		/* stw R11, <#[R31 + 112]> */
		/* 8208C9DCh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 8208C9DCh case    3:*/		return 0x8208C9E0;
		  /* 8208C9E0h */ case    4:  		/* bc 12, CR6_EQ, 128 */
		/* 8208C9E0h case    4:*/		if ( regs.CR[6].eq ) { return 0x8208CA60;  }
		/* 8208C9E0h case    4:*/		return 0x8208C9E4;
		  /* 8208C9E4h */ case    5:  		/* addi R11, R11, -8 */
		/* 8208C9E4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFF8);
		/* 8208C9E4h case    5:*/		return 0x8208C9E8;
	}
	return 0x8208C9E8;
} // Block from 8208C9D0h-8208C9E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208C9E8h
// Function 'LoadLibraryA'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208C9E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208C9E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208C9E8);
		  /* 8208C9E8h */ case    0:  		/* stw R11, <#[R31 + 92]> */
		/* 8208C9E8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208C9E8h case    0:*/		return 0x8208C9EC;
		  /* 8208C9ECh */ case    1:  		/* lhz R11, <#[R11]> */
		/* 8208C9ECh case    1:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8208C9ECh case    1:*/		return 0x8208C9F0;
		  /* 8208C9F0h */ case    2:  		/* cmplw CR6, R11, R29 */
		/* 8208C9F0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 8208C9F0h case    2:*/		return 0x8208C9F4;
		  /* 8208C9F4h */ case    3:  		/* bc 12, CR6_LT, 108 */
		/* 8208C9F4h case    3:*/		if ( regs.CR[6].lt ) { return 0x8208CA60;  }
		/* 8208C9F4h case    3:*/		return 0x8208C9F8;
		  /* 8208C9F8h */ case    4:  		/* lwz R11, <#[R10]> */
		/* 8208C9F8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8208C9F8h case    4:*/		return 0x8208C9FC;
		  /* 8208C9FCh */ case    5:  		/* stw R11, <#[R31 + 112]> */
		/* 8208C9FCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 8208C9FCh case    5:*/		return 0x8208CA00;
		  /* 8208CA00h */ case    6:  		/* cmplw CR6, R10, R11 */
		/* 8208CA00h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208CA00h case    6:*/		return 0x8208CA04;
		  /* 8208CA04h */ case    7:  		/* bc 12, CR6_EQ, 92 */
		/* 8208CA04h case    7:*/		if ( regs.CR[6].eq ) { return 0x8208CA60;  }
		/* 8208CA04h case    7:*/		return 0x8208CA08;
		  /* 8208CA08h */ case    8:  		/* addi R3, R11, -8 */
		/* 8208CA08h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFF8);
		/* 8208CA08h case    8:*/		return 0x8208CA0C;
		  /* 8208CA0Ch */ case    9:  		/* stw R3, <#[R31 + 92]> */
		/* 8208CA0Ch case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208CA0Ch case    9:*/		return 0x8208CA10;
		  /* 8208CA10h */ case   10:  		/* lhz R9, <#[R3]> */
		/* 8208CA10h case   10:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 8208CA10h case   10:*/		return 0x8208CA14;
		  /* 8208CA14h */ case   11:  		/* cmplw CR6, R9, R29 */
		/* 8208CA14h case   11:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R29);
		/* 8208CA14h case   11:*/		return 0x8208CA18;
		  /* 8208CA18h */ case   12:  		/* bc 4, CR6_LT, 20 */
		/* 8208CA18h case   12:*/		if ( !regs.CR[6].lt ) { return 0x8208CA2C;  }
		/* 8208CA18h case   12:*/		return 0x8208CA1C;
		  /* 8208CA1Ch */ case   13:  		/* lwz R11, <#[R11]> */
		/* 8208CA1Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8208CA1Ch case   13:*/		return 0x8208CA20;
		  /* 8208CA20h */ case   14:  		/* stw R11, <#[R31 + 112]> */
		/* 8208CA20h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 8208CA20h case   14:*/		return 0x8208CA24;
		  /* 8208CA24h */ case   15:  		/* nop */
		/* 8208CA24h case   15:*/		cpu::op::nop();
		/* 8208CA24h case   15:*/		return 0x8208CA28;
		  /* 8208CA28h */ case   16:  		/* b -40 */
		/* 8208CA28h case   16:*/		return 0x8208CA00;
		/* 8208CA28h case   16:*/		return 0x8208CA2C;
	}
	return 0x8208CA2C;
} // Block from 8208C9E8h-8208CA2Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8208CA2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CA2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CA2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CA2C);
		  /* 8208CA2Ch */ case    0:  		/* lwz R10, <#[R3 + 12]> */
		/* 8208CA2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 8208CA2Ch case    0:*/		return 0x8208CA30;
	}
	return 0x8208CA30;
} // Block from 8208CA2Ch-8208CA30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208CA30h
// Function 'PIXAddCounter'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CA30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CA30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CA30);
		  /* 8208CA30h */ case    0:  		/* addi R11, R3, 8 */
		/* 8208CA30h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x8);
		/* 8208CA30h case    0:*/		return 0x8208CA34;
		  /* 8208CA34h */ case    1:  		/* lwz R9, <#[R3 + 8]> */
		/* 8208CA34h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 8208CA34h case    1:*/		return 0x8208CA38;
		  /* 8208CA38h */ case    2:  		/* lwz R8, <#[R10]> */
		/* 8208CA38h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8208CA38h case    2:*/		return 0x8208CA3C;
		  /* 8208CA3Ch */ case    3:  		/* lwz R7, <#[R9 + 4]> */
		/* 8208CA3Ch case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000004) );
		/* 8208CA3Ch case    3:*/		return 0x8208CA40;
		  /* 8208CA40h */ case    4:  		/* cmplw CR6, R8, R7 */
		/* 8208CA40h case    4:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 8208CA40h case    4:*/		return 0x8208CA44;
		  /* 8208CA44h */ case    5:  		/* bc 4, CR6_EQ, 20 */
		/* 8208CA44h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8208CA58;  }
		/* 8208CA44h case    5:*/		return 0x8208CA48;
		  /* 8208CA48h */ case    6:  		/* cmplw CR6, R8, R11 */
		/* 8208CA48h case    6:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8208CA48h case    6:*/		return 0x8208CA4C;
		  /* 8208CA4Ch */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 8208CA4Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x8208CA58;  }
		/* 8208CA4Ch case    7:*/		return 0x8208CA50;
		  /* 8208CA50h */ case    8:  		/* stw R9, <#[R10]> */
		/* 8208CA50h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8208CA50h case    8:*/		return 0x8208CA54;
		  /* 8208CA54h */ case    9:  		/* stw R10, <#[R9 + 4]> */
		/* 8208CA54h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 8208CA54h case    9:*/		return 0x8208CA58;
	}
	return 0x8208CA58;
} // Block from 8208CA30h-8208CA58h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8208CA58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CA58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CA58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CA58);
		  /* 8208CA58h */ case    0:  		/* nop */
		/* 8208CA58h case    0:*/		cpu::op::nop();
		/* 8208CA58h case    0:*/		return 0x8208CA5C;
		  /* 8208CA5Ch */ case    1:  		/* b 72 */
		/* 8208CA5Ch case    1:*/		return 0x8208CAA4;
		/* 8208CA5Ch case    1:*/		return 0x8208CA60;
	}
	return 0x8208CA60;
} // Block from 8208CA58h-8208CA60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208CA60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CA60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CA60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CA60);
		  /* 8208CA60h */ case    0:  		/* mr R3, R28 */
		/* 8208CA60h case    0:*/		regs.R3 = regs.R28;
		/* 8208CA60h case    0:*/		return 0x8208CA64;
		  /* 8208CA64h */ case    1:  		/* bl -3780 */
		/* 8208CA64h case    1:*/		regs.LR = 0x8208CA68; return 0x8208BBA0;
		/* 8208CA64h case    1:*/		return 0x8208CA68;
		  /* 8208CA68h */ case    2:  		/* stw R3, <#[R31 + 92]> */
		/* 8208CA68h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208CA68h case    2:*/		return 0x8208CA6C;
		  /* 8208CA6Ch */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 8208CA6Ch case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8208CA6Ch case    3:*/		return 0x8208CA70;
		  /* 8208CA70h */ case    4:  		/* bc 12, CR0_EQ, 1244 */
		/* 8208CA70h case    4:*/		if ( regs.CR[0].eq ) { return 0x8208CF4C;  }
		/* 8208CA70h case    4:*/		return 0x8208CA74;
		  /* 8208CA74h */ case    5:  		/* lwz R10, <#[R3 + 12]> */
		/* 8208CA74h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 8208CA74h case    5:*/		return 0x8208CA78;
		  /* 8208CA78h */ case    6:  		/* addi R11, R3, 8 */
		/* 8208CA78h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x8);
		/* 8208CA78h case    6:*/		return 0x8208CA7C;
		  /* 8208CA7Ch */ case    7:  		/* lwz R9, <#[R3 + 8]> */
		/* 8208CA7Ch case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 8208CA7Ch case    7:*/		return 0x8208CA80;
		  /* 8208CA80h */ case    8:  		/* lwz R8, <#[R10]> */
		/* 8208CA80h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8208CA80h case    8:*/		return 0x8208CA84;
		  /* 8208CA84h */ case    9:  		/* lwz R7, <#[R9 + 4]> */
		/* 8208CA84h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000004) );
		/* 8208CA84h case    9:*/		return 0x8208CA88;
		  /* 8208CA88h */ case   10:  		/* cmplw CR6, R8, R7 */
		/* 8208CA88h case   10:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 8208CA88h case   10:*/		return 0x8208CA8C;
		  /* 8208CA8Ch */ case   11:  		/* bc 4, CR6_EQ, 20 */
		/* 8208CA8Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x8208CAA0;  }
		/* 8208CA8Ch case   11:*/		return 0x8208CA90;
		  /* 8208CA90h */ case   12:  		/* cmplw CR6, R8, R11 */
		/* 8208CA90h case   12:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8208CA90h case   12:*/		return 0x8208CA94;
		  /* 8208CA94h */ case   13:  		/* bc 4, CR6_EQ, 12 */
		/* 8208CA94h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8208CAA0;  }
		/* 8208CA94h case   13:*/		return 0x8208CA98;
	}
	return 0x8208CA98;
} // Block from 8208CA60h-8208CA98h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8208CA98h
// Function 'PIXSubmitDrPixCounters'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CA98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CA98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CA98);
		  /* 8208CA98h */ case    0:  		/* stw R9, <#[R10]> */
		/* 8208CA98h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8208CA98h case    0:*/		return 0x8208CA9C;
		  /* 8208CA9Ch */ case    1:  		/* stw R10, <#[R9 + 4]> */
		/* 8208CA9Ch case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 8208CA9Ch case    1:*/		return 0x8208CAA0;
	}
	return 0x8208CAA0;
} // Block from 8208CA98h-8208CAA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208CAA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CAA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CAA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CAA0);
		  /* 8208CAA0h */ case    0:  		/* nop */
		/* 8208CAA0h case    0:*/		cpu::op::nop();
		/* 8208CAA0h case    0:*/		return 0x8208CAA4;
	}
	return 0x8208CAA4;
} // Block from 8208CAA0h-8208CAA4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208CAA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CAA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CAA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CAA4);
		  /* 8208CAA4h */ case    0:  		/* lbz R10, <#[R3 + 5]> */
		/* 8208CAA4h case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000005) );
		/* 8208CAA4h case    0:*/		return 0x8208CAA8;
		  /* 8208CAA8h */ case    1:  		/* mr R26, R3 */
		/* 8208CAA8h case    1:*/		regs.R26 = regs.R3;
		/* 8208CAA8h case    1:*/		return 0x8208CAAC;
		  /* 8208CAACh */ case    2:  		/* rlwinm R11, R29, 0, 16, 31 */
		/* 8208CAACh case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R29);
		/* 8208CAACh case    2:*/		return 0x8208CAB0;
		  /* 8208CAB0h */ case    3:  		/* stb R10, <#[R31 + 80]> */
		/* 8208CAB0h case    3:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 8208CAB0h case    3:*/		return 0x8208CAB4;
		  /* 8208CAB4h */ case    4:  		/* lhz R9, <#[R3]> */
		/* 8208CAB4h case    4:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 8208CAB4h case    4:*/		return 0x8208CAB8;
		  /* 8208CAB8h */ case    5:  		/* lwz R8, <#[R28 + 48]> */
		/* 8208CAB8h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R28 + 0x00000030) );
		/* 8208CAB8h case    5:*/		return 0x8208CABC;
		  /* 8208CABCh */ case    6:  		/* subf R9, R9, R8 */
		/* 8208CABCh case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8208CABCh case    6:*/		return 0x8208CAC0;
		  /* 8208CAC0h */ case    7:  		/* stw R9, <#[R28 + 48]> */
		/* 8208CAC0h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R28 + 0x00000030) );
		/* 8208CAC0h case    7:*/		return 0x8208CAC4;
		  /* 8208CAC4h */ case    8:  		/* stw R3, <#[R31 + 128]> */
		/* 8208CAC4h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000080) );
		/* 8208CAC4h case    8:*/		return 0x8208CAC8;
		  /* 8208CAC8h */ case    9:  		/* stb R27, <#[R3 + 5]> */
		/* 8208CAC8h case    9:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R3 + 0x00000005) );
		/* 8208CAC8h case    9:*/		return 0x8208CACC;
		  /* 8208CACCh */ case   10:  		/* lhz R9, <#[R3]> */
		/* 8208CACCh case   10:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 8208CACCh case   10:*/		return 0x8208CAD0;
		  /* 8208CAD0h */ case   11:  		/* subf. R6, R29, R9 */
		/* 8208CAD0h case   11:*/		cpu::op::subf<1>(regs,&regs.R6,regs.R29,regs.R9);
		/* 8208CAD0h case   11:*/		return 0x8208CAD4;
		  /* 8208CAD4h */ case   12:  		/* sth R11, <#[R3]> */
		/* 8208CAD4h case   12:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8208CAD4h case   12:*/		return 0x8208CAD8;
		  /* 8208CAD8h */ case   13:  		/* lwz R9, <#[R31 + 88]> */
		/* 8208CAD8h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000058) );
		/* 8208CAD8h case   13:*/		return 0x8208CADC;
		  /* 8208CADCh */ case   14:  		/* subf R9, R25, R9 */
		/* 8208CADCh case   14:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R25,regs.R9);
		/* 8208CADCh case   14:*/		return 0x8208CAE0;
		  /* 8208CAE0h */ case   15:  		/* stb R9, <#[R3 + 6]> */
		/* 8208CAE0h case   15:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R3 + 0x00000006) );
		/* 8208CAE0h case   15:*/		return 0x8208CAE4;
		  /* 8208CAE4h */ case   16:  		/* stb R24, <#[R3 + 7]> */
		/* 8208CAE4h case   16:*/		cpu::mem::store8( regs, regs.R24, (uint32)(regs.R3 + 0x00000007) );
		/* 8208CAE4h case   16:*/		return 0x8208CAE8;
		  /* 8208CAE8h */ case   17:  		/* bc 12, CR0_EQ, 848 */
		/* 8208CAE8h case   17:*/		if ( regs.CR[0].eq ) { return 0x8208CE38;  }
		/* 8208CAE8h case   17:*/		return 0x8208CAEC;
		  /* 8208CAECh */ case   18:  		/* cmplwi CR6, R6, 1 */
		/* 8208CAECh case   18:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000001);
		/* 8208CAECh case   18:*/		return 0x8208CAF0;
		  /* 8208CAF0h */ case   19:  		/* bc 4, CR6_EQ, 32 */
		/* 8208CAF0h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8208CB10;  }
		/* 8208CAF0h case   19:*/		return 0x8208CAF4;
		  /* 8208CAF4h */ case   20:  		/* lhz R11, <#[R3]> */
		/* 8208CAF4h case   20:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8208CAF4h case   20:*/		return 0x8208CAF8;
		  /* 8208CAF8h */ case   21:  		/* addi R11, R11, 1 */
		/* 8208CAF8h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8208CAF8h case   21:*/		return 0x8208CAFC;
		  /* 8208CAFCh */ case   22:  		/* sth R11, <#[R3]> */
		/* 8208CAFCh case   22:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8208CAFCh case   22:*/		return 0x8208CB00;
		  /* 8208CB00h */ case   23:  		/* lbz R11, <#[R3 + 6]> */
		/* 8208CB00h case   23:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000006) );
		/* 8208CB00h case   23:*/		return 0x8208CB04;
		  /* 8208CB04h */ case   24:  		/* addi R11, R11, 16 */
		/* 8208CB04h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8208CB04h case   24:*/		return 0x8208CB08;
		  /* 8208CB08h */ case   25:  		/* stb R11, <#[R3 + 6]> */
		/* 8208CB08h case   25:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000006) );
		/* 8208CB08h case   25:*/		return 0x8208CB0C;
		  /* 8208CB0Ch */ case   26:  		/* b 812 */
		/* 8208CB0Ch case   26:*/		return 0x8208CE38;
		/* 8208CB0Ch case   26:*/		return 0x8208CB10;
	}
	return 0x8208CB10;
} // Block from 8208CAA4h-8208CB10h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8208CB10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CB10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CB10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CB10);
		  /* 8208CB10h */ case    0:  		/* rlwinm R9, R29, 4, 0, 27 */
		/* 8208CB10h case    0:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R9,regs.R29);
		/* 8208CB10h case    0:*/		return 0x8208CB14;
		  /* 8208CB14h */ case    1:  		/* rlwinm. R8, R10, 0, 27, 27 */
		/* 8208CB14h case    1:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R8,regs.R10);
		/* 8208CB14h case    1:*/		return 0x8208CB18;
		  /* 8208CB18h */ case    2:  		/* add R30, R9, R3 */
		/* 8208CB18h case    2:*/		cpu::op::add<0>(regs,&regs.R30,regs.R9,regs.R3);
		/* 8208CB18h case    2:*/		return 0x8208CB1C;
		  /* 8208CB1Ch */ case    3:  		/* rlwinm R9, R6, 0, 16, 31 */
		/* 8208CB1Ch case    3:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R6);
		/* 8208CB1Ch case    3:*/		return 0x8208CB20;
		  /* 8208CB20h */ case    4:  		/* stb R10, <#[R30 + 5]> */
		/* 8208CB20h case    4:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R30 + 0x00000005) );
		/* 8208CB20h case    4:*/		return 0x8208CB24;
		  /* 8208CB24h */ case    5:  		/* sth R11, <#[R30 + 2]> */
		/* 8208CB24h case    5:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R30 + 0x00000002) );
		/* 8208CB24h case    5:*/		return 0x8208CB28;
		  /* 8208CB28h */ case    6:  		/* lbz R11, <#[R3 + 4]> */
		/* 8208CB28h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8208CB28h case    6:*/		return 0x8208CB2C;
		  /* 8208CB2Ch */ case    7:  		/* stb R11, <#[R30 + 4]> */
		/* 8208CB2Ch case    7:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8208CB2Ch case    7:*/		return 0x8208CB30;
		  /* 8208CB30h */ case    8:  		/* sth R9, <#[R30]> */
		/* 8208CB30h case    8:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 8208CB30h case    8:*/		return 0x8208CB34;
		  /* 8208CB34h */ case    9:  		/* bc 12, CR0_EQ, 156 */
		/* 8208CB34h case    9:*/		if ( regs.CR[0].eq ) { return 0x8208CBD0;  }
		/* 8208CB34h case    9:*/		return 0x8208CB38;
		  /* 8208CB38h */ case   10:  		/* rlwinm R9, R9, 0, 16, 31 */
		/* 8208CB38h case   10:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R9);
		/* 8208CB38h case   10:*/		return 0x8208CB3C;
		  /* 8208CB3Ch */ case   11:  		/* cmplwi CR6, R9, 128 */
		/* 8208CB3Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000080);
		/* 8208CB3Ch case   11:*/		return 0x8208CB40;
		  /* 8208CB40h */ case   12:  		/* bc 4, CR6_LT, 76 */
		/* 8208CB40h case   12:*/		if ( !regs.CR[6].lt ) { return 0x8208CB8C;  }
		/* 8208CB40h case   12:*/		return 0x8208CB44;
		  /* 8208CB44h */ case   13:  		/* addi R11, R9, 48 */
		/* 8208CB44h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x30);
		/* 8208CB44h case   13:*/		return 0x8208CB48;
		  /* 8208CB48h */ case   14:  		/* lbz R10, <#[R30 + 5]> */
		/* 8208CB48h case   14:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000005) );
		/* 8208CB48h case   14:*/		return 0x8208CB4C;
		  /* 8208CB4Ch */ case   15:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8208CB4Ch case   15:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8208CB4Ch case   15:*/		return 0x8208CB50;
		  /* 8208CB50h */ case   16:  		/* rlwinm R10, R10, 0, 27, 27 */
		/* 8208CB50h case   16:*/		cpu::op::rlwinm<0,0,27,27>(regs,&regs.R10,regs.R10);
		/* 8208CB50h case   16:*/		return 0x8208CB54;
		  /* 8208CB54h */ case   17:  		/* add R11, R11, R28 */
		/* 8208CB54h case   17:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 8208CB54h case   17:*/		return 0x8208CB58;
		  /* 8208CB58h */ case   18:  		/* stb R10, <#[R30 + 5]> */
		/* 8208CB58h case   18:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R30 + 0x00000005) );
		/* 8208CB58h case   18:*/		return 0x8208CB5C;
		  /* 8208CB5Ch */ case   19:  		/* lwz R10, <#[R11]> */
		/* 8208CB5Ch case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208CB5Ch case   19:*/		return 0x8208CB60;
		  /* 8208CB60h */ case   20:  		/* cmplw CR6, R10, R11 */
		/* 8208CB60h case   20:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208CB60h case   20:*/		return 0x8208CB64;
		  /* 8208CB64h */ case   21:  		/* bc 4, CR6_EQ, 216 */
		/* 8208CB64h case   21:*/		if ( !regs.CR[6].eq ) { return 0x8208CC3C;  }
		/* 8208CB64h case   21:*/		return 0x8208CB68;
		  /* 8208CB68h */ case   22:  		/* lhz R9, <#[R30]> */
		/* 8208CB68h case   22:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 8208CB68h case   22:*/		return 0x8208CB6C;
		  /* 8208CB6Ch */ case   23:  		/* rlwinm R10, R9, 27, 5, 31 */
		/* 8208CB6Ch case   23:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R9);
		/* 8208CB6Ch case   23:*/		return 0x8208CB70;
		  /* 8208CB70h */ case   24:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 8208CB70h case   24:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8208CB70h case   24:*/		return 0x8208CB74;
		  /* 8208CB74h */ case   25:  		/* addi R10, R10, 88 */
		/* 8208CB74h case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x58);
		/* 8208CB74h case   25:*/		return 0x8208CB78;
		  /* 8208CB78h */ case   26:  		/* slw R9, R27, R9 */
		/* 8208CB78h case   26:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R27,regs.R9);
		/* 8208CB78h case   26:*/		return 0x8208CB7C;
		  /* 8208CB7Ch */ case   27:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8208CB7Ch case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8208CB7Ch case   27:*/		return 0x8208CB80;
		  /* 8208CB80h */ case   28:  		/* lwzx R8, <#[R10 + R28]> */
		/* 8208CB80h case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 8208CB80h case   28:*/		return 0x8208CB84;
		  /* 8208CB84h */ case   29:  		/* or R9, R9, R8 */
		/* 8208CB84h case   29:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8208CB84h case   29:*/		return 0x8208CB88;
		  /* 8208CB88h */ case   30:  		/* b 176 */
		/* 8208CB88h case   30:*/		return 0x8208CC38;
		/* 8208CB88h case   30:*/		return 0x8208CB8C;
	}
	return 0x8208CB8C;
} // Block from 8208CB10h-8208CB8Ch (31 instructions)

//////////////////////////////////////////////////////
// Block at 8208CB8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CB8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CB8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CB8C);
		  /* 8208CB8Ch */ case    0:  		/* lbz R11, <#[R30 + 5]> */
		/* 8208CB8Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208CB8Ch case    0:*/		return 0x8208CB90;
		  /* 8208CB90h */ case    1:  		/* addi R10, R28, 384 */
		/* 8208CB90h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0x180);
		/* 8208CB90h case    1:*/		return 0x8208CB94;
		  /* 8208CB94h */ case    2:  		/* rlwinm R11, R11, 0, 27, 27 */
		/* 8208CB94h case    2:*/		cpu::op::rlwinm<0,0,27,27>(regs,&regs.R11,regs.R11);
		/* 8208CB94h case    2:*/		return 0x8208CB98;
		  /* 8208CB98h */ case    3:  		/* stb R11, <#[R30 + 5]> */
		/* 8208CB98h case    3:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208CB98h case    3:*/		return 0x8208CB9C;
		  /* 8208CB9Ch */ case    4:  		/* lwz R11, <#[R28 + 384]> */
		/* 8208CB9Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000180) );
		/* 8208CB9Ch case    4:*/		return 0x8208CBA0;
		  /* 8208CBA0h */ case    5:  		/* stw R11, <#[R31 + 132]> */
		/* 8208CBA0h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 8208CBA0h case    5:*/		return 0x8208CBA4;
		  /* 8208CBA4h */ case    6:  		/* cmplw CR6, R10, R11 */
		/* 8208CBA4h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208CBA4h case    6:*/		return 0x8208CBA8;
		  /* 8208CBA8h */ case    7:  		/* bc 12, CR6_EQ, 148 */
		/* 8208CBA8h case    7:*/		if ( regs.CR[6].eq ) { return 0x8208CC3C;  }
		/* 8208CBA8h case    7:*/		return 0x8208CBAC;
		  /* 8208CBACh */ case    8:  		/* lhz R8, <#[R11 - 8]> */
		/* 8208CBACh case    8:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 8208CBACh case    8:*/		return 0x8208CBB0;
		  /* 8208CBB0h */ case    9:  		/* addi R7, R11, -8 */
		/* 8208CBB0h case    9:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFF8);
		/* 8208CBB0h case    9:*/		return 0x8208CBB4;
		  /* 8208CBB4h */ case   10:  		/* stw R7, <#[R31 + 116]> */
		/* 8208CBB4h case   10:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x00000074) );
		/* 8208CBB4h case   10:*/		return 0x8208CBB8;
	}
	return 0x8208CBB8;
} // Block from 8208CB8Ch-8208CBB8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8208CBB8h
// Function 'PIXGetCaptureState'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CBB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CBB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CBB8);
		  /* 8208CBB8h */ case    0:  		/* cmplw CR6, R9, R8 */
		/* 8208CBB8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 8208CBB8h case    0:*/		return 0x8208CBBC;
		  /* 8208CBBCh */ case    1:  		/* bc 4, CR6_GT, 128 */
		/* 8208CBBCh case    1:*/		if ( !regs.CR[6].gt ) { return 0x8208CC3C;  }
		/* 8208CBBCh case    1:*/		return 0x8208CBC0;
		  /* 8208CBC0h */ case    2:  		/* lwz R11, <#[R11]> */
		/* 8208CBC0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8208CBC0h case    2:*/		return 0x8208CBC4;
		  /* 8208CBC4h */ case    3:  		/* stw R11, <#[R31 + 132]> */
		/* 8208CBC4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 8208CBC4h case    3:*/		return 0x8208CBC8;
		  /* 8208CBC8h */ case    4:  		/* nop */
		/* 8208CBC8h case    4:*/		cpu::op::nop();
		/* 8208CBC8h case    4:*/		return 0x8208CBCC;
		  /* 8208CBCCh */ case    5:  		/* b -40 */
		/* 8208CBCCh case    5:*/		return 0x8208CBA4;
		/* 8208CBCCh case    5:*/		return 0x8208CBD0;
	}
	return 0x8208CBD0;
} // Block from 8208CBB8h-8208CBD0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208CBD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CBD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CBD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CBD0);
		  /* 8208CBD0h */ case    0:  		/* rlwinm R11, R6, 4, 0, 27 */
		/* 8208CBD0h case    0:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R6);
		/* 8208CBD0h case    0:*/		return 0x8208CBD4;
		  /* 8208CBD4h */ case    1:  		/* add R11, R11, R30 */
		/* 8208CBD4h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8208CBD4h case    1:*/		return 0x8208CBD8;
		  /* 8208CBD8h */ case    2:  		/* lbz R10, <#[R11 + 5]> */
		/* 8208CBD8h case    2:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000005) );
		/* 8208CBD8h case    2:*/		return 0x8208CBDC;
		  /* 8208CBDCh */ case    3:  		/* rlwinm. R8, R10, 0, 31, 31 */
		/* 8208CBDCh case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R8,regs.R10);
		/* 8208CBDCh case    3:*/		return 0x8208CBE0;
		  /* 8208CBE0h */ case    4:  		/* bc 12, CR0_EQ, 192 */
		/* 8208CBE0h case    4:*/		if ( regs.CR[0].eq ) { return 0x8208CCA0;  }
		/* 8208CBE0h case    4:*/		return 0x8208CBE4;
		  /* 8208CBE4h */ case    5:  		/* rlwinm R8, R9, 0, 16, 31 */
		/* 8208CBE4h case    5:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R8,regs.R9);
		/* 8208CBE4h case    5:*/		return 0x8208CBE8;
	}
	return 0x8208CBE8;
} // Block from 8208CBD0h-8208CBE8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208CBE8h
// Function 'SetUnhandledExceptionFilter'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CBE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CBE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CBE8);
		  /* 8208CBE8h */ case    0:  		/* sth R9, <#[R11 + 2]> */
		/* 8208CBE8h case    0:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R11 + 0x00000002) );
		/* 8208CBE8h case    0:*/		return 0x8208CBEC;
		  /* 8208CBECh */ case    1:  		/* cmplwi CR6, R8, 128 */
		/* 8208CBECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000080);
		/* 8208CBECh case    1:*/		return 0x8208CBF0;
		  /* 8208CBF0h */ case    2:  		/* lbz R11, <#[R30 + 5]> */
		/* 8208CBF0h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208CBF0h case    2:*/		return 0x8208CBF4;
		  /* 8208CBF4h */ case    3:  		/* bc 4, CR6_LT, 108 */
		/* 8208CBF4h case    3:*/		if ( !regs.CR[6].lt ) { return 0x8208CC60;  }
		/* 8208CBF4h case    3:*/		return 0x8208CBF8;
		  /* 8208CBF8h */ case    4:  		/* addi R10, R8, 48 */
		/* 8208CBF8h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R8,0x30);
		/* 8208CBF8h case    4:*/		return 0x8208CBFC;
		  /* 8208CBFCh */ case    5:  		/* rlwinm R9, R11, 0, 27, 27 */
		/* 8208CBFCh case    5:*/		cpu::op::rlwinm<0,0,27,27>(regs,&regs.R9,regs.R11);
		/* 8208CBFCh case    5:*/		return 0x8208CC00;
	}
	return 0x8208CC00;
} // Block from 8208CBE8h-8208CC00h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208CC00h
// Function 'XSetThreadProcessor'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CC00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CC00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CC00);
		  /* 8208CC00h */ case    0:  		/* rlwinm R11, R10, 3, 0, 28 */
		/* 8208CC00h case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R10);
		/* 8208CC00h case    0:*/		return 0x8208CC04;
		  /* 8208CC04h */ case    1:  		/* stb R9, <#[R30 + 5]> */
		/* 8208CC04h case    1:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R30 + 0x00000005) );
		/* 8208CC04h case    1:*/		return 0x8208CC08;
		  /* 8208CC08h */ case    2:  		/* add R11, R11, R28 */
		/* 8208CC08h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 8208CC08h case    2:*/		return 0x8208CC0C;
		  /* 8208CC0Ch */ case    3:  		/* lwz R10, <#[R11]> */
		/* 8208CC0Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208CC0Ch case    3:*/		return 0x8208CC10;
		  /* 8208CC10h */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 8208CC10h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208CC10h case    4:*/		return 0x8208CC14;
		  /* 8208CC14h */ case    5:  		/* bc 4, CR6_EQ, 40 */
		/* 8208CC14h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8208CC3C;  }
		/* 8208CC14h case    5:*/		return 0x8208CC18;
		  /* 8208CC18h */ case    6:  		/* lhz R9, <#[R30]> */
		/* 8208CC18h case    6:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 8208CC18h case    6:*/		return 0x8208CC1C;
		  /* 8208CC1Ch */ case    7:  		/* rlwinm R10, R9, 27, 5, 31 */
		/* 8208CC1Ch case    7:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R9);
		/* 8208CC1Ch case    7:*/		return 0x8208CC20;
		  /* 8208CC20h */ case    8:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 8208CC20h case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8208CC20h case    8:*/		return 0x8208CC24;
		  /* 8208CC24h */ case    9:  		/* addi R10, R10, 88 */
		/* 8208CC24h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x58);
		/* 8208CC24h case    9:*/		return 0x8208CC28;
		  /* 8208CC28h */ case   10:  		/* slw R9, R27, R9 */
		/* 8208CC28h case   10:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R27,regs.R9);
		/* 8208CC28h case   10:*/		return 0x8208CC2C;
		  /* 8208CC2Ch */ case   11:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8208CC2Ch case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8208CC2Ch case   11:*/		return 0x8208CC30;
		  /* 8208CC30h */ case   12:  		/* lwzx R8, <#[R10 + R28]> */
		/* 8208CC30h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 8208CC30h case   12:*/		return 0x8208CC34;
		  /* 8208CC34h */ case   13:  		/* or R9, R8, R9 */
		/* 8208CC34h case   13:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8208CC34h case   13:*/		return 0x8208CC38;
	}
	return 0x8208CC38;
} // Block from 8208CC00h-8208CC38h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8208CC38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CC38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CC38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CC38);
		  /* 8208CC38h */ case    0:  		/* stwx R9, <#[R10 + R28]> */
		/* 8208CC38h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 8208CC38h case    0:*/		return 0x8208CC3C;
	}
	return 0x8208CC3C;
} // Block from 8208CC38h-8208CC3Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208CC3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CC3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CC3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CC3C);
		  /* 8208CC3Ch */ case    0:  		/* lwz R9, <#[R11 + 4]> */
		/* 8208CC3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8208CC3Ch case    0:*/		return 0x8208CC40;
		  /* 8208CC40h */ case    1:  		/* stw R11, <#[R30 + 8]> */
		/* 8208CC40h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8208CC40h case    1:*/		return 0x8208CC44;
		  /* 8208CC44h */ case    2:  		/* stw R9, <#[R30 + 12]> */
		/* 8208CC44h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x0000000C) );
		/* 8208CC44h case    2:*/		return 0x8208CC48;
		  /* 8208CC48h */ case    3:  		/* addi R10, R30, 8 */
		/* 8208CC48h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x8);
		/* 8208CC48h case    3:*/		return 0x8208CC4C;
		  /* 8208CC4Ch */ case    4:  		/* stw R10, <#[R9]> */
		/* 8208CC4Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8208CC4Ch case    4:*/		return 0x8208CC50;
		  /* 8208CC50h */ case    5:  		/* stw R10, <#[R11 + 4]> */
		/* 8208CC50h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8208CC50h case    5:*/		return 0x8208CC54;
		  /* 8208CC54h */ case    6:  		/* lwz R11, <#[R28 + 48]> */
		/* 8208CC54h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000030) );
		/* 8208CC54h case    6:*/		return 0x8208CC58;
		  /* 8208CC58h */ case    7:  		/* add R11, R6, R11 */
		/* 8208CC58h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R6,regs.R11);
		/* 8208CC58h case    7:*/		return 0x8208CC5C;
		  /* 8208CC5Ch */ case    8:  		/* b 416 */
		/* 8208CC5Ch case    8:*/		return 0x8208CDFC;
		/* 8208CC5Ch case    8:*/		return 0x8208CC60;
	}
	return 0x8208CC60;
} // Block from 8208CC3Ch-8208CC60h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8208CC60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CC60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CC60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CC60);
		  /* 8208CC60h */ case    0:  		/* addi R10, R28, 384 */
		/* 8208CC60h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0x180);
		/* 8208CC60h case    0:*/		return 0x8208CC64;
		  /* 8208CC64h */ case    1:  		/* rlwinm R11, R11, 0, 27, 27 */
		/* 8208CC64h case    1:*/		cpu::op::rlwinm<0,0,27,27>(regs,&regs.R11,regs.R11);
		/* 8208CC64h case    1:*/		return 0x8208CC68;
		  /* 8208CC68h */ case    2:  		/* stb R11, <#[R30 + 5]> */
		/* 8208CC68h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208CC68h case    2:*/		return 0x8208CC6C;
		  /* 8208CC6Ch */ case    3:  		/* lwz R11, <#[R28 + 384]> */
		/* 8208CC6Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000180) );
		/* 8208CC6Ch case    3:*/		return 0x8208CC70;
		  /* 8208CC70h */ case    4:  		/* stw R11, <#[R31 + 120]> */
		/* 8208CC70h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000078) );
		/* 8208CC70h case    4:*/		return 0x8208CC74;
		  /* 8208CC74h */ case    5:  		/* cmplw CR6, R10, R11 */
		/* 8208CC74h case    5:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208CC74h case    5:*/		return 0x8208CC78;
		  /* 8208CC78h */ case    6:  		/* bc 12, CR6_EQ, -60 */
		/* 8208CC78h case    6:*/		if ( regs.CR[6].eq ) { return 0x8208CC3C;  }
		/* 8208CC78h case    6:*/		return 0x8208CC7C;
		  /* 8208CC7Ch */ case    7:  		/* lhz R9, <#[R11 - 8]> */
		/* 8208CC7Ch case    7:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 8208CC7Ch case    7:*/		return 0x8208CC80;
		  /* 8208CC80h */ case    8:  		/* addi R7, R11, -8 */
		/* 8208CC80h case    8:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFF8);
		/* 8208CC80h case    8:*/		return 0x8208CC84;
		  /* 8208CC84h */ case    9:  		/* stw R7, <#[R31 + 116]> */
		/* 8208CC84h case    9:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x00000074) );
		/* 8208CC84h case    9:*/		return 0x8208CC88;
		  /* 8208CC88h */ case   10:  		/* cmplw CR6, R8, R9 */
		/* 8208CC88h case   10:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8208CC88h case   10:*/		return 0x8208CC8C;
		  /* 8208CC8Ch */ case   11:  		/* bc 4, CR6_GT, -80 */
		/* 8208CC8Ch case   11:*/		if ( !regs.CR[6].gt ) { return 0x8208CC3C;  }
		/* 8208CC8Ch case   11:*/		return 0x8208CC90;
		  /* 8208CC90h */ case   12:  		/* lwz R11, <#[R11]> */
		/* 8208CC90h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8208CC90h case   12:*/		return 0x8208CC94;
		  /* 8208CC94h */ case   13:  		/* stw R11, <#[R31 + 120]> */
		/* 8208CC94h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000078) );
		/* 8208CC94h case   13:*/		return 0x8208CC98;
		  /* 8208CC98h */ case   14:  		/* nop */
		/* 8208CC98h case   14:*/		cpu::op::nop();
		/* 8208CC98h case   14:*/		return 0x8208CC9C;
		  /* 8208CC9Ch */ case   15:  		/* b -40 */
		/* 8208CC9Ch case   15:*/		return 0x8208CC74;
		/* 8208CC9Ch case   15:*/		return 0x8208CCA0;
	}
	return 0x8208CCA0;
} // Block from 8208CC60h-8208CCA0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8208CCA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CCA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CCA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CCA0);
		  /* 8208CCA0h */ case    0:  		/* stb R10, <#[R30 + 5]> */
		/* 8208CCA0h case    0:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R30 + 0x00000005) );
		/* 8208CCA0h case    0:*/		return 0x8208CCA4;
		  /* 8208CCA4h */ case    1:  		/* addi R8, R11, 8 */
		/* 8208CCA4h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x8);
		/* 8208CCA4h case    1:*/		return 0x8208CCA8;
		  /* 8208CCA8h */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 8208CCA8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8208CCA8h case    2:*/		return 0x8208CCAC;
		  /* 8208CCACh */ case    3:  		/* lwz R10, <#[R11 + 12]> */
		/* 8208CCACh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8208CCACh case    3:*/		return 0x8208CCB0;
	}
	return 0x8208CCB0;
} // Block from 8208CCA0h-8208CCB0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208CCB0h
// Function 'UnhandledExceptionFilter'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CCB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CCB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CCB0);
		  /* 8208CCB0h */ case    0:  		/* lwz R5, <#[R9 + 4]> */
		/* 8208CCB0h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000004) );
		/* 8208CCB0h case    0:*/		return 0x8208CCB4;
		  /* 8208CCB4h */ case    1:  		/* lwz R7, <#[R10]> */
		/* 8208CCB4h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 8208CCB4h case    1:*/		return 0x8208CCB8;
		  /* 8208CCB8h */ case    2:  		/* cmplw CR6, R7, R5 */
		/* 8208CCB8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R5);
		/* 8208CCB8h case    2:*/		return 0x8208CCBC;
		  /* 8208CCBCh */ case    3:  		/* bc 4, CR6_EQ, 72 */
		/* 8208CCBCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x8208CD04;  }
		/* 8208CCBCh case    3:*/		return 0x8208CCC0;
		  /* 8208CCC0h */ case    4:  		/* cmplw CR6, R7, R8 */
		/* 8208CCC0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 8208CCC0h case    4:*/		return 0x8208CCC4;
		  /* 8208CCC4h */ case    5:  		/* bc 4, CR6_EQ, 64 */
		/* 8208CCC4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8208CD04;  }
		/* 8208CCC4h case    5:*/		return 0x8208CCC8;
		  /* 8208CCC8h */ case    6:  		/* stw R9, <#[R10]> */
		/* 8208CCC8h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8208CCC8h case    6:*/		return 0x8208CCCC;
		  /* 8208CCCCh */ case    7:  		/* cmplw CR6, R9, R10 */
		/* 8208CCCCh case    7:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 8208CCCCh case    7:*/		return 0x8208CCD0;
		  /* 8208CCD0h */ case    8:  		/* stw R10, <#[R9 + 4]> */
		/* 8208CCD0h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 8208CCD0h case    8:*/		return 0x8208CCD4;
		  /* 8208CCD4h */ case    9:  		/* bc 4, CR6_EQ, 48 */
		/* 8208CCD4h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8208CD04;  }
		/* 8208CCD4h case    9:*/		return 0x8208CCD8;
		  /* 8208CCD8h */ case   10:  		/* lhz R10, <#[R11]> */
		/* 8208CCD8h case   10:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208CCD8h case   10:*/		return 0x8208CCDC;
		  /* 8208CCDCh */ case   11:  		/* cmplwi CR6, R10, 128 */
		/* 8208CCDCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000080);
		/* 8208CCDCh case   11:*/		return 0x8208CCE0;
		  /* 8208CCE0h */ case   12:  		/* bc 4, CR6_LT, 36 */
		/* 8208CCE0h case   12:*/		if ( !regs.CR[6].lt ) { return 0x8208CD04;  }
		/* 8208CCE0h case   12:*/		return 0x8208CCE4;
		  /* 8208CCE4h */ case   13:  		/* rlwinm R9, R10, 27, 5, 31 */
		/* 8208CCE4h case   13:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R9,regs.R10);
		/* 8208CCE4h case   13:*/		return 0x8208CCE8;
		  /* 8208CCE8h */ case   14:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 8208CCE8h case   14:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 8208CCE8h case   14:*/		return 0x8208CCEC;
		  /* 8208CCECh */ case   15:  		/* addi R9, R9, 88 */
		/* 8208CCECh case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x58);
		/* 8208CCECh case   15:*/		return 0x8208CCF0;
		  /* 8208CCF0h */ case   16:  		/* slw R8, R27, R10 */
		/* 8208CCF0h case   16:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R27,regs.R10);
		/* 8208CCF0h case   16:*/		return 0x8208CCF4;
		  /* 8208CCF4h */ case   17:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 8208CCF4h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 8208CCF4h case   17:*/		return 0x8208CCF8;
		  /* 8208CCF8h */ case   18:  		/* lwzx R9, <#[R10 + R28]> */
		/* 8208CCF8h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 8208CCF8h case   18:*/		return 0x8208CCFC;
		  /* 8208CCFCh */ case   19:  		/* xor R9, R8, R9 */
		/* 8208CCFCh case   19:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8208CCFCh case   19:*/		return 0x8208CD00;
		  /* 8208CD00h */ case   20:  		/* stwx R9, <#[R10 + R28]> */
		/* 8208CD00h case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 8208CD00h case   20:*/		return 0x8208CD04;
	}
	return 0x8208CD04;
} // Block from 8208CCB0h-8208CD04h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8208CD04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CD04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CD04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CD04);
		  /* 8208CD04h */ case    0:  		/* lhz R10, <#[R11]> */
		/* 8208CD04h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208CD04h case    0:*/		return 0x8208CD08;
		  /* 8208CD08h */ case    1:  		/* lwz R9, <#[R28 + 48]> */
		/* 8208CD08h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000030) );
		/* 8208CD08h case    1:*/		return 0x8208CD0C;
		  /* 8208CD0Ch */ case    2:  		/* subf R10, R10, R9 */
		/* 8208CD0Ch case    2:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8208CD0Ch case    2:*/		return 0x8208CD10;
		  /* 8208CD10h */ case    3:  		/* stw R10, <#[R28 + 48]> */
		/* 8208CD10h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + 0x00000030) );
		/* 8208CD10h case    3:*/		return 0x8208CD14;
		  /* 8208CD14h */ case    4:  		/* lhz R11, <#[R11]> */
		/* 8208CD14h case    4:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8208CD14h case    4:*/		return 0x8208CD18;
		  /* 8208CD18h */ case    5:  		/* add R5, R11, R6 */
		/* 8208CD18h case    5:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R6);
		/* 8208CD18h case    5:*/		return 0x8208CD1C;
		  /* 8208CD1Ch */ case    6:  		/* cmplwi CR6, R5, 61440 */
		/* 8208CD1Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x0000F000);
		/* 8208CD1Ch case    6:*/		return 0x8208CD20;
		  /* 8208CD20h */ case    7:  		/* bc 12, CR6_GT, 228 */
		/* 8208CD20h case    7:*/		if ( regs.CR[6].gt ) { return 0x8208CE04;  }
		/* 8208CD20h case    7:*/		return 0x8208CD24;
		  /* 8208CD24h */ case    8:  		/* rlwinm R11, R5, 0, 16, 31 */
		/* 8208CD24h case    8:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R5);
		/* 8208CD24h case    8:*/		return 0x8208CD28;
		  /* 8208CD28h */ case    9:  		/* sth R11, <#[R30]> */
		/* 8208CD28h case    9:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8208CD28h case    9:*/		return 0x8208CD2C;
		  /* 8208CD2Ch */ case   10:  		/* lbz R10, <#[R30 + 5]> */
		/* 8208CD2Ch case   10:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000005) );
		/* 8208CD2Ch case   10:*/		return 0x8208CD30;
		  /* 8208CD30h */ case   11:  		/* rlwinm. R10, R10, 0, 27, 27 */
		/* 8208CD30h case   11:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R10);
		/* 8208CD30h case   11:*/		return 0x8208CD34;
		  /* 8208CD34h */ case   12:  		/* bc 4, CR0_EQ, 16 */
		/* 8208CD34h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8208CD44;  }
		/* 8208CD34h case   12:*/		return 0x8208CD38;
		  /* 8208CD38h */ case   13:  		/* rlwinm R10, R5, 4, 0, 27 */
		/* 8208CD38h case   13:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R5);
		/* 8208CD38h case   13:*/		return 0x8208CD3C;
		  /* 8208CD3Ch */ case   14:  		/* add R10, R10, R30 */
		/* 8208CD3Ch case   14:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R30);
		/* 8208CD3Ch case   14:*/		return 0x8208CD40;
	}
	return 0x8208CD40;
} // Block from 8208CD04h-8208CD40h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8208CD40h
// Function 'CreateThread'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CD40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CD40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CD40);
		  /* 8208CD40h */ case    0:  		/* sth R11, <#[R10 + 2]> */
		/* 8208CD40h case    0:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000002) );
		/* 8208CD40h case    0:*/		return 0x8208CD44;
	}
	return 0x8208CD44;
} // Block from 8208CD40h-8208CD44h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208CD44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CD44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CD44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CD44);
		  /* 8208CD44h */ case    0:  		/* rlwinm R9, R11, 0, 16, 31 */
		/* 8208CD44h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R11);
		/* 8208CD44h case    0:*/		return 0x8208CD48;
		  /* 8208CD48h */ case    1:  		/* cmplwi CR6, R9, 128 */
		/* 8208CD48h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000080);
		/* 8208CD48h case    1:*/		return 0x8208CD4C;
		  /* 8208CD4Ch */ case    2:  		/* lbz R11, <#[R30 + 5]> */
		/* 8208CD4Ch case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208CD4Ch case    2:*/		return 0x8208CD50;
	}
	return 0x8208CD50;
} // Block from 8208CD44h-8208CD50h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208CD50h
// Function 'XGetOverlappedResult'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CD50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CD50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CD50);
		  /* 8208CD50h */ case    0:  		/* bc 4, CR6_LT, 76 */
		/* 8208CD50h case    0:*/		if ( !regs.CR[6].lt ) { return 0x8208CD9C;  }
		/* 8208CD50h case    0:*/		return 0x8208CD54;
		  /* 8208CD54h */ case    1:  		/* addi R10, R9, 48 */
		/* 8208CD54h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x30);
		/* 8208CD54h case    1:*/		return 0x8208CD58;
		  /* 8208CD58h */ case    2:  		/* rlwinm R9, R11, 0, 27, 27 */
		/* 8208CD58h case    2:*/		cpu::op::rlwinm<0,0,27,27>(regs,&regs.R9,regs.R11);
		/* 8208CD58h case    2:*/		return 0x8208CD5C;
		  /* 8208CD5Ch */ case    3:  		/* rlwinm R11, R10, 3, 0, 28 */
		/* 8208CD5Ch case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R10);
		/* 8208CD5Ch case    3:*/		return 0x8208CD60;
		  /* 8208CD60h */ case    4:  		/* stb R9, <#[R30 + 5]> */
		/* 8208CD60h case    4:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R30 + 0x00000005) );
		/* 8208CD60h case    4:*/		return 0x8208CD64;
		  /* 8208CD64h */ case    5:  		/* add R11, R11, R28 */
		/* 8208CD64h case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 8208CD64h case    5:*/		return 0x8208CD68;
		  /* 8208CD68h */ case    6:  		/* lwz R10, <#[R11]> */
		/* 8208CD68h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208CD68h case    6:*/		return 0x8208CD6C;
		  /* 8208CD6Ch */ case    7:  		/* cmplw CR6, R10, R11 */
		/* 8208CD6Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208CD6Ch case    7:*/		return 0x8208CD70;
		  /* 8208CD70h */ case    8:  		/* bc 4, CR6_EQ, 108 */
		/* 8208CD70h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8208CDDC;  }
		/* 8208CD70h case    8:*/		return 0x8208CD74;
		  /* 8208CD74h */ case    9:  		/* lhz R9, <#[R30]> */
		/* 8208CD74h case    9:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 8208CD74h case    9:*/		return 0x8208CD78;
		  /* 8208CD78h */ case   10:  		/* rlwinm R10, R9, 27, 5, 31 */
		/* 8208CD78h case   10:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R9);
		/* 8208CD78h case   10:*/		return 0x8208CD7C;
		  /* 8208CD7Ch */ case   11:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 8208CD7Ch case   11:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8208CD7Ch case   11:*/		return 0x8208CD80;
		  /* 8208CD80h */ case   12:  		/* addi R10, R10, 88 */
		/* 8208CD80h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x58);
		/* 8208CD80h case   12:*/		return 0x8208CD84;
		  /* 8208CD84h */ case   13:  		/* slw R9, R27, R9 */
		/* 8208CD84h case   13:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R27,regs.R9);
		/* 8208CD84h case   13:*/		return 0x8208CD88;
		  /* 8208CD88h */ case   14:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8208CD88h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8208CD88h case   14:*/		return 0x8208CD8C;
		  /* 8208CD8Ch */ case   15:  		/* lwzx R8, <#[R10 + R28]> */
		/* 8208CD8Ch case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 8208CD8Ch case   15:*/		return 0x8208CD90;
		  /* 8208CD90h */ case   16:  		/* or R9, R8, R9 */
		/* 8208CD90h case   16:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8208CD90h case   16:*/		return 0x8208CD94;
		  /* 8208CD94h */ case   17:  		/* stwx R9, <#[R10 + R28]> */
		/* 8208CD94h case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 8208CD94h case   17:*/		return 0x8208CD98;
		  /* 8208CD98h */ case   18:  		/* b 68 */
		/* 8208CD98h case   18:*/		return 0x8208CDDC;
		/* 8208CD98h case   18:*/		return 0x8208CD9C;
	}
	return 0x8208CD9C;
} // Block from 8208CD50h-8208CD9Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8208CD9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CD9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CD9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CD9C);
		  /* 8208CD9Ch */ case    0:  		/* addi R10, R28, 384 */
		/* 8208CD9Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0x180);
		/* 8208CD9Ch case    0:*/		return 0x8208CDA0;
		  /* 8208CDA0h */ case    1:  		/* rlwinm R11, R11, 0, 27, 27 */
		/* 8208CDA0h case    1:*/		cpu::op::rlwinm<0,0,27,27>(regs,&regs.R11,regs.R11);
		/* 8208CDA0h case    1:*/		return 0x8208CDA4;
		  /* 8208CDA4h */ case    2:  		/* stb R11, <#[R30 + 5]> */
		/* 8208CDA4h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208CDA4h case    2:*/		return 0x8208CDA8;
		  /* 8208CDA8h */ case    3:  		/* lwz R11, <#[R28 + 384]> */
		/* 8208CDA8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000180) );
		/* 8208CDA8h case    3:*/		return 0x8208CDAC;
		  /* 8208CDACh */ case    4:  		/* stw R11, <#[R31 + 136]> */
		/* 8208CDACh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000088) );
		/* 8208CDACh case    4:*/		return 0x8208CDB0;
		  /* 8208CDB0h */ case    5:  		/* cmplw CR6, R10, R11 */
		/* 8208CDB0h case    5:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208CDB0h case    5:*/		return 0x8208CDB4;
		  /* 8208CDB4h */ case    6:  		/* bc 12, CR6_EQ, 40 */
		/* 8208CDB4h case    6:*/		if ( regs.CR[6].eq ) { return 0x8208CDDC;  }
		/* 8208CDB4h case    6:*/		return 0x8208CDB8;
		  /* 8208CDB8h */ case    7:  		/* lhz R8, <#[R11 - 8]> */
		/* 8208CDB8h case    7:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 8208CDB8h case    7:*/		return 0x8208CDBC;
		  /* 8208CDBCh */ case    8:  		/* addi R7, R11, -8 */
		/* 8208CDBCh case    8:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFF8);
		/* 8208CDBCh case    8:*/		return 0x8208CDC0;
		  /* 8208CDC0h */ case    9:  		/* stw R7, <#[R31 + 116]> */
		/* 8208CDC0h case    9:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x00000074) );
		/* 8208CDC0h case    9:*/		return 0x8208CDC4;
		  /* 8208CDC4h */ case   10:  		/* cmplw CR6, R9, R8 */
		/* 8208CDC4h case   10:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 8208CDC4h case   10:*/		return 0x8208CDC8;
		  /* 8208CDC8h */ case   11:  		/* bc 4, CR6_GT, 20 */
		/* 8208CDC8h case   11:*/		if ( !regs.CR[6].gt ) { return 0x8208CDDC;  }
		/* 8208CDC8h case   11:*/		return 0x8208CDCC;
		  /* 8208CDCCh */ case   12:  		/* lwz R11, <#[R11]> */
		/* 8208CDCCh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8208CDCCh case   12:*/		return 0x8208CDD0;
		  /* 8208CDD0h */ case   13:  		/* stw R11, <#[R31 + 136]> */
		/* 8208CDD0h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000088) );
		/* 8208CDD0h case   13:*/		return 0x8208CDD4;
		  /* 8208CDD4h */ case   14:  		/* nop */
		/* 8208CDD4h case   14:*/		cpu::op::nop();
		/* 8208CDD4h case   14:*/		return 0x8208CDD8;
		  /* 8208CDD8h */ case   15:  		/* b -40 */
		/* 8208CDD8h case   15:*/		return 0x8208CDB0;
		/* 8208CDD8h case   15:*/		return 0x8208CDDC;
	}
	return 0x8208CDDC;
} // Block from 8208CD9Ch-8208CDDCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 8208CDDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CDDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CDDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CDDC);
		  /* 8208CDDCh */ case    0:  		/* lwz R9, <#[R11 + 4]> */
		/* 8208CDDCh case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8208CDDCh case    0:*/		return 0x8208CDE0;
		  /* 8208CDE0h */ case    1:  		/* stw R11, <#[R30 + 8]> */
		/* 8208CDE0h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8208CDE0h case    1:*/		return 0x8208CDE4;
		  /* 8208CDE4h */ case    2:  		/* stw R9, <#[R30 + 12]> */
		/* 8208CDE4h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x0000000C) );
		/* 8208CDE4h case    2:*/		return 0x8208CDE8;
	}
	return 0x8208CDE8;
} // Block from 8208CDDCh-8208CDE8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208CDE8h
// Function 'GetCommandLineA'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CDE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CDE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CDE8);
		  /* 8208CDE8h */ case    0:  		/* addi R10, R30, 8 */
		/* 8208CDE8h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x8);
		/* 8208CDE8h case    0:*/		return 0x8208CDEC;
		  /* 8208CDECh */ case    1:  		/* stw R10, <#[R9]> */
		/* 8208CDECh case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8208CDECh case    1:*/		return 0x8208CDF0;
		  /* 8208CDF0h */ case    2:  		/* stw R10, <#[R11 + 4]> */
		/* 8208CDF0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8208CDF0h case    2:*/		return 0x8208CDF4;
		  /* 8208CDF4h */ case    3:  		/* lwz R11, <#[R28 + 48]> */
		/* 8208CDF4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000030) );
		/* 8208CDF4h case    3:*/		return 0x8208CDF8;
	}
	return 0x8208CDF8;
} // Block from 8208CDE8h-8208CDF8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208CDF8h
// Function '_cinit'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CDF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CDF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CDF8);
		  /* 8208CDF8h */ case    0:  		/* add R11, R5, R11 */
		/* 8208CDF8h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R5,regs.R11);
		/* 8208CDF8h case    0:*/		return 0x8208CDFC;
	}
	return 0x8208CDFC;
} // Block from 8208CDF8h-8208CDFCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208CDFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CDFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CDFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CDFC);
		  /* 8208CDFCh */ case    0:  		/* stw R11, <#[R28 + 48]> */
		/* 8208CDFCh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000030) );
		/* 8208CDFCh case    0:*/		return 0x8208CE00;
		  /* 8208CE00h */ case    1:  		/* b 16 */
		/* 8208CE00h case    1:*/		return 0x8208CE10;
		/* 8208CE00h case    1:*/		return 0x8208CE04;
	}
	return 0x8208CE04;
} // Block from 8208CDFCh-8208CE04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208CE04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CE04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CE04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CE04);
		  /* 8208CE04h */ case    0:  		/* mr R4, R30 */
		/* 8208CE04h case    0:*/		regs.R4 = regs.R30;
		/* 8208CE04h case    0:*/		return 0x8208CE08;
		  /* 8208CE08h */ case    1:  		/* mr R3, R28 */
		/* 8208CE08h case    1:*/		regs.R3 = regs.R28;
		/* 8208CE08h case    1:*/		return 0x8208CE0C;
		  /* 8208CE0Ch */ case    2:  		/* bl -6964 */
		/* 8208CE0Ch case    2:*/		regs.LR = 0x8208CE10; return 0x8208B2D8;
		/* 8208CE0Ch case    2:*/		return 0x8208CE10;
	}
	return 0x8208CE10;
} // Block from 8208CE04h-8208CE10h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208CE10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CE10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CE10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CE10);
		  /* 8208CE10h */ case    0:  		/* mr R10, R24 */
		/* 8208CE10h case    0:*/		regs.R10 = regs.R24;
		/* 8208CE10h case    0:*/		return 0x8208CE14;
		  /* 8208CE14h */ case    1:  		/* stb R24, <#[R31 + 80]> */
		/* 8208CE14h case    1:*/		cpu::mem::store8( regs, regs.R24, (uint32)(regs.R31 + 0x00000050) );
		/* 8208CE14h case    1:*/		return 0x8208CE18;
		  /* 8208CE18h */ case    2:  		/* lbz R11, <#[R30 + 5]> */
		/* 8208CE18h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208CE18h case    2:*/		return 0x8208CE1C;
		  /* 8208CE1Ch */ case    3:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 8208CE1Ch case    3:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 8208CE1Ch case    3:*/		return 0x8208CE20;
		  /* 8208CE20h */ case    4:  		/* bc 12, CR0_EQ, 24 */
		/* 8208CE20h case    4:*/		if ( regs.CR[0].eq ) { return 0x8208CE38;  }
		/* 8208CE20h case    4:*/		return 0x8208CE24;
		  /* 8208CE24h */ case    5:  		/* lbz R11, <#[R30 + 4]> */
		/* 8208CE24h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8208CE24h case    5:*/		return 0x8208CE28;
		  /* 8208CE28h */ case    6:  		/* addi R11, R11, 24 */
		/* 8208CE28h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 8208CE28h case    6:*/		return 0x8208CE2C;
		  /* 8208CE2Ch */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8208CE2Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8208CE2Ch case    7:*/		return 0x8208CE30;
		  /* 8208CE30h */ case    8:  		/* lwzx R11, <#[R11 + R28]> */
		/* 8208CE30h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8208CE30h case    8:*/		return 0x8208CE34;
		  /* 8208CE34h */ case    9:  		/* stw R30, <#[R11 + 64]> */
		/* 8208CE34h case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000040) );
		/* 8208CE34h case    9:*/		return 0x8208CE38;
	}
	return 0x8208CE38;
} // Block from 8208CE10h-8208CE38h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8208CE38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CE38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CE38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CE38);
		  /* 8208CE38h */ case    0:  		/* rlwinm. R11, R10, 0, 27, 27 */
		/* 8208CE38h case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R10);
		/* 8208CE38h case    0:*/		return 0x8208CE3C;
		  /* 8208CE3Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8208CE3Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8208CE4C;  }
		/* 8208CE3Ch case    1:*/		return 0x8208CE40;
		  /* 8208CE40h */ case    2:  		/* lbz R11, <#[R26 + 5]> */
		/* 8208CE40h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000005) );
		/* 8208CE40h case    2:*/		return 0x8208CE44;
		  /* 8208CE44h */ case    3:  		/* ori R11, R11, 16 */
		/* 8208CE44h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8208CE44h case    3:*/		return 0x8208CE48;
		  /* 8208CE48h */ case    4:  		/* stb R11, <#[R26 + 5]> */
		/* 8208CE48h case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R26 + 0x00000005) );
		/* 8208CE48h case    4:*/		return 0x8208CE4C;
	}
	return 0x8208CE4C;
} // Block from 8208CE38h-8208CE4Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208CE4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CE4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CE4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CE4C);
		  /* 8208CE4Ch */ case    0:  		/* addi R30, R26, 16 */
		/* 8208CE4Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R26,0x10);
		/* 8208CE4Ch case    0:*/		return 0x8208CE50;
		  /* 8208CE50h */ case    1:  		/* cmplwi CR6, R22, 0 */
		/* 8208CE50h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 8208CE50h case    1:*/		return 0x8208CE54;
		  /* 8208CE54h */ case    2:  		/* stw R30, <#[R31 + 100]> */
		/* 8208CE54h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000064) );
		/* 8208CE54h case    2:*/		return 0x8208CE58;
		  /* 8208CE58h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 8208CE58h case    3:*/		if ( regs.CR[6].eq ) { return 0x8208CE6C;  }
		/* 8208CE58h case    3:*/		return 0x8208CE5C;
		  /* 8208CE5Ch */ case    4:  		/* lwz R3, <#[R28 + 1408]> */
		/* 8208CE5Ch case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000580) );
		/* 8208CE5Ch case    4:*/		return 0x8208CE60;
		  /* 8208CE60h */ case    5:  		/* bl 1966536 */
		/* 8208CE60h case    5:*/		regs.LR = 0x8208CE64; return 0x8226D028;
		/* 8208CE60h case    5:*/		return 0x8208CE64;
		  /* 8208CE64h */ case    6:  		/* mr R22, R24 */
		/* 8208CE64h case    6:*/		regs.R22 = regs.R24;
		/* 8208CE64h case    6:*/		return 0x8208CE68;
		  /* 8208CE68h */ case    7:  		/* stw R24, <#[R31 + 104]> */
		/* 8208CE68h case    7:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000068) );
		/* 8208CE68h case    7:*/		return 0x8208CE6C;
	}
	return 0x8208CE6C;
} // Block from 8208CE4Ch-8208CE6Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8208CE6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CE6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CE6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CE6C);
		  /* 8208CE6Ch */ case    0:  		/* rlwinm. R11, R23, 0, 28, 28 */
		/* 8208CE6Ch case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R23);
		/* 8208CE6Ch case    0:*/		return 0x8208CE70;
		  /* 8208CE70h */ case    1:  		/* bc 12, CR0_EQ, 272 */
		/* 8208CE70h case    1:*/		if ( regs.CR[0].eq ) { return 0x8208CF80;  }
		/* 8208CE70h case    1:*/		return 0x8208CE74;
		  /* 8208CE74h */ case    2:  		/* mr R5, R25 */
		/* 8208CE74h case    2:*/		regs.R5 = regs.R25;
		/* 8208CE74h case    2:*/		return 0x8208CE78;
		  /* 8208CE78h */ case    3:  		/* li R4, 0 */
		/* 8208CE78h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208CE78h case    3:*/		return 0x8208CE7C;
		  /* 8208CE7Ch */ case    4:  		/* mr R3, R30 */
		/* 8208CE7Ch case    4:*/		regs.R3 = regs.R30;
		/* 8208CE7Ch case    4:*/		return 0x8208CE80;
		  /* 8208CE80h */ case    5:  		/* bl 17600 */
		/* 8208CE80h case    5:*/		regs.LR = 0x8208CE84; return 0x82091340;
		/* 8208CE80h case    5:*/		return 0x8208CE84;
		  /* 8208CE84h */ case    6:  		/* b 252 */
		/* 8208CE84h case    6:*/		return 0x8208CF80;
		/* 8208CE84h case    6:*/		return 0x8208CE88;
	}
	return 0x8208CE88;
} // Block from 8208CE6Ch-8208CE88h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208CE88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CE88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CE88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CE88);
		  /* 8208CE88h */ case    0:  		/* lwz R11, <#[R30 + 20]> */
		/* 8208CE88h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 8208CE88h case    0:*/		return 0x8208CE8C;
		  /* 8208CE8Ch */ case    1:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 8208CE8Ch case    1:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 8208CE8Ch case    1:*/		return 0x8208CE90;
		  /* 8208CE90h */ case    2:  		/* bc 12, CR0_EQ, 192 */
		/* 8208CE90h case    2:*/		if ( regs.CR[0].eq ) { return 0x8208CF50;  }
		/* 8208CE90h case    2:*/		return 0x8208CE94;
		  /* 8208CE94h */ case    3:  		/* addi R11, R4, 32 */
		/* 8208CE94h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x20);
		/* 8208CE94h case    3:*/		return 0x8208CE98;
		  /* 8208CE98h */ case    4:  		/* stw R24, <#[R31 + 84]> */
		/* 8208CE98h case    4:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000054) );
		/* 8208CE98h case    4:*/		return 0x8208CE9C;
		  /* 8208CE9Ch */ case    5:  		/* nor R10, R23, R23 */
		/* 8208CE9Ch case    5:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R23,regs.R23);
		/* 8208CE9Ch case    5:*/		return 0x8208CEA0;
		  /* 8208CEA0h */ case    6:  		/* stw R11, <#[R31 + 88]> */
		/* 8208CEA0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 8208CEA0h case    6:*/		return 0x8208CEA4;
		  /* 8208CEA4h */ case    7:  		/* li R6, 4 */
		/* 8208CEA4h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 8208CEA4h case    7:*/		return 0x8208CEA8;
		  /* 8208CEA8h */ case    8:  		/* rlwinm R11, R10, 20, 8, 8 */
		/* 8208CEA8h case    8:*/		cpu::op::rlwinm<0,20,8,8>(regs,&regs.R11,regs.R10);
		/* 8208CEA8h case    8:*/		return 0x8208CEAC;
		  /* 8208CEACh */ case    9:  		/* lwz R7, <#[R30 + 1424]> */
		/* 8208CEACh case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000590) );
		/* 8208CEACh case    9:*/		return 0x8208CEB0;
		  /* 8208CEB0h */ case   10:  		/* addi R4, R31, 88 */
		/* 8208CEB0h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x58);
		/* 8208CEB0h case   10:*/		return 0x8208CEB4;
		  /* 8208CEB4h */ case   11:  		/* oris R5, R11, 24576 */
		/* 8208CEB4h case   11:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R11,0x6000);
		/* 8208CEB4h case   11:*/		return 0x8208CEB8;
		  /* 8208CEB8h */ case   12:  		/* ori R5, R5, 4096 */
		/* 8208CEB8h case   12:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x1000);
		/* 8208CEB8h case   12:*/		return 0x8208CEBC;
		  /* 8208CEBCh */ case   13:  		/* addi R3, R31, 84 */
		/* 8208CEBCh case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x54);
		/* 8208CEBCh case   13:*/		return 0x8208CEC0;
		  /* 8208CEC0h */ case   14:  		/* bl 1967480 */
		/* 8208CEC0h case   14:*/		regs.LR = 0x8208CEC4; return 0x8226D438;
		/* 8208CEC0h case   14:*/		return 0x8208CEC4;
		  /* 8208CEC4h */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 8208CEC4h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208CEC4h case   15:*/		return 0x8208CEC8;
		  /* 8208CEC8h */ case   16:  		/* bc 12, CR0_LT, 132 */
		/* 8208CEC8h case   16:*/		if ( regs.CR[0].lt ) { return 0x8208CF4C;  }
		/* 8208CEC8h case   16:*/		return 0x8208CECC;
		  /* 8208CECCh */ case   17:  		/* li R5, 48 */
		/* 8208CECCh case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x30);
		/* 8208CECCh case   17:*/		return 0x8208CED0;
		  /* 8208CED0h */ case   18:  		/* lwz R3, <#[R31 + 84]> */
		/* 8208CED0h case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000054) );
		/* 8208CED0h case   18:*/		return 0x8208CED4;
		  /* 8208CED4h */ case   19:  		/* li R4, 0 */
		/* 8208CED4h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208CED4h case   19:*/		return 0x8208CED8;
	}
	return 0x8208CED8;
} // Block from 8208CE88h-8208CED8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8208CED8h
// Function '_rtinit'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CED8);
		  /* 8208CED8h */ case    0:  		/* bl 17512 */
		/* 8208CED8h case    0:*/		regs.LR = 0x8208CEDC; return 0x82091340;
		/* 8208CED8h case    0:*/		return 0x8208CEDC;
		  /* 8208CEDCh */ case    1:  		/* li R10, 11 */
		/* 8208CEDCh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0xB);
		/* 8208CEDCh case    1:*/		return 0x8208CEE0;
		  /* 8208CEE0h */ case    2:  		/* addi R11, R30, 88 */
		/* 8208CEE0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x58);
		/* 8208CEE0h case    2:*/		return 0x8208CEE4;
		  /* 8208CEE4h */ case    3:  		/* lwz R9, <#[R31 + 88]> */
		/* 8208CEE4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000058) );
		/* 8208CEE4h case    3:*/		return 0x8208CEE8;
		  /* 8208CEE8h */ case    4:  		/* lwz R8, <#[R31 + 84]> */
		/* 8208CEE8h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000054) );
		/* 8208CEE8h case    4:*/		return 0x8208CEEC;
		  /* 8208CEECh */ case    5:  		/* subf R9, R25, R9 */
		/* 8208CEECh case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R25,regs.R9);
		/* 8208CEECh case    5:*/		return 0x8208CEF0;
		  /* 8208CEF0h */ case    6:  		/* addis R9, R9, 1 */
		/* 8208CEF0h case    6:*/		cpu::op::addis<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8208CEF0h case    6:*/		return 0x8208CEF4;
		  /* 8208CEF4h */ case    7:  		/* addi R9, R9, -48 */
		/* 8208CEF4h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFD0);
		/* 8208CEF4h case    7:*/		return 0x8208CEF8;
		  /* 8208CEF8h */ case    8:  		/* sth R9, <#[R8 + 32]> */
		/* 8208CEF8h case    8:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R8 + 0x00000020) );
		/* 8208CEF8h case    8:*/		return 0x8208CEFC;
		  /* 8208CEFCh */ case    9:  		/* lwz R9, <#[R31 + 84]> */
		/* 8208CEFCh case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000054) );
		/* 8208CEFCh case    9:*/		return 0x8208CF00;
		  /* 8208CF00h */ case   10:  		/* stb R10, <#[R9 + 37]> */
		/* 8208CF00h case   10:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R9 + 0x00000025) );
		/* 8208CF00h case   10:*/		return 0x8208CF04;
		  /* 8208CF04h */ case   11:  		/* lwz R10, <#[R31 + 84]> */
		/* 8208CF04h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000054) );
		/* 8208CF04h case   11:*/		return 0x8208CF08;
		  /* 8208CF08h */ case   12:  		/* lwz R9, <#[R31 + 88]> */
		/* 8208CF08h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000058) );
		/* 8208CF08h case   12:*/		return 0x8208CF0C;
		  /* 8208CF0Ch */ case   13:  		/* stw R9, <#[R10 + 24]> */
		/* 8208CF0Ch case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000018) );
		/* 8208CF0Ch case   13:*/		return 0x8208CF10;
		  /* 8208CF10h */ case   14:  		/* lwz R10, <#[R31 + 84]> */
		/* 8208CF10h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000054) );
		/* 8208CF10h case   14:*/		return 0x8208CF14;
		  /* 8208CF14h */ case   15:  		/* lwz R9, <#[R31 + 88]> */
		/* 8208CF14h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000058) );
		/* 8208CF14h case   15:*/		return 0x8208CF18;
		  /* 8208CF18h */ case   16:  		/* stw R9, <#[R10 + 28]> */
		/* 8208CF18h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x0000001C) );
		/* 8208CF18h case   16:*/		return 0x8208CF1C;
		  /* 8208CF1Ch */ case   17:  		/* lwz R10, <#[R31 + 84]> */
		/* 8208CF1Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000054) );
		/* 8208CF1Ch case   17:*/		return 0x8208CF20;
		  /* 8208CF20h */ case   18:  		/* lwz R9, <#[R30 + 92]> */
		/* 8208CF20h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000005C) );
		/* 8208CF20h case   18:*/		return 0x8208CF24;
		  /* 8208CF24h */ case   19:  		/* stw R11, <#[R10]> */
		/* 8208CF24h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8208CF24h case   19:*/		return 0x8208CF28;
		  /* 8208CF28h */ case   20:  		/* lwz R11, <#[R31 + 84]> */
		/* 8208CF28h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 8208CF28h case   20:*/		return 0x8208CF2C;
		  /* 8208CF2Ch */ case   21:  		/* stw R9, <#[R11 + 4]> */
		/* 8208CF2Ch case   21:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8208CF2Ch case   21:*/		return 0x8208CF30;
		  /* 8208CF30h */ case   22:  		/* lwz R11, <#[R31 + 84]> */
		/* 8208CF30h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 8208CF30h case   22:*/		return 0x8208CF34;
		  /* 8208CF34h */ case   23:  		/* stw R11, <#[R9]> */
		/* 8208CF34h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8208CF34h case   23:*/		return 0x8208CF38;
		  /* 8208CF38h */ case   24:  		/* lwz R11, <#[R31 + 84]> */
		/* 8208CF38h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 8208CF38h case   24:*/		return 0x8208CF3C;
		  /* 8208CF3Ch */ case   25:  		/* addi R10, R11, 48 */
		/* 8208CF3Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x30);
		/* 8208CF3Ch case   25:*/		return 0x8208CF40;
		  /* 8208CF40h */ case   26:  		/* stw R11, <#[R30 + 92]> */
		/* 8208CF40h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000005C) );
		/* 8208CF40h case   26:*/		return 0x8208CF44;
		  /* 8208CF44h */ case   27:  		/* stw R10, <#[R31 + 100]> */
		/* 8208CF44h case   27:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000064) );
		/* 8208CF44h case   27:*/		return 0x8208CF48;
		  /* 8208CF48h */ case   28:  		/* b 56 */
		/* 8208CF48h case   28:*/		return 0x8208CF80;
		/* 8208CF48h case   28:*/		return 0x8208CF4C;
	}
	return 0x8208CF4C;
} // Block from 8208CED8h-8208CF4Ch (29 instructions)

//////////////////////////////////////////////////////
// Block at 8208CF4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CF4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CF4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CF4C);
		  /* 8208CF4Ch */ case    0:  		/* lwz R4, <#[R31 + 88]> */
		/* 8208CF4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000058) );
		/* 8208CF4Ch case    0:*/		return 0x8208CF50;
	}
	return 0x8208CF50;
} // Block from 8208CF4Ch-8208CF50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208CF50h
// Function 'XapiCallThreadNotifyRoutines'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CF50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CF50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CF50);
		  /* 8208CF50h */ case    0:  		/* rlwinm. R11, R23, 0, 29, 29 */
		/* 8208CF50h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R23);
		/* 8208CF50h case    0:*/		return 0x8208CF54;
		  /* 8208CF54h */ case    1:  		/* bc 12, CR0_EQ, 40 */
		/* 8208CF54h case    1:*/		if ( regs.CR[0].eq ) { return 0x8208CF7C;  }
		/* 8208CF54h case    1:*/		return 0x8208CF58;
		  /* 8208CF58h */ case    2:  		/* lis R11, -16384 */
		/* 8208CF58h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC000);
		/* 8208CF58h case    2:*/		return 0x8208CF5C;
		  /* 8208CF5Ch */ case    3:  		/* addi R3, R31, 144 */
		/* 8208CF5Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x90);
		/* 8208CF5Ch case    3:*/		return 0x8208CF60;
		  /* 8208CF60h */ case    4:  		/* ori R11, R11, 23 */
		/* 8208CF60h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x17);
		/* 8208CF60h case    4:*/		return 0x8208CF64;
		  /* 8208CF64h */ case    5:  		/* stw R11, <#[R31 + 144]> */
		/* 8208CF64h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000090) );
		/* 8208CF64h case    5:*/		return 0x8208CF68;
		  /* 8208CF68h */ case    6:  		/* stw R24, <#[R31 + 152]> */
		/* 8208CF68h case    6:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000098) );
		/* 8208CF68h case    6:*/		return 0x8208CF6C;
		  /* 8208CF6Ch */ case    7:  		/* stw R27, <#[R31 + 160]> */
		/* 8208CF6Ch case    7:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x000000A0) );
		/* 8208CF6Ch case    7:*/		return 0x8208CF70;
		  /* 8208CF70h */ case    8:  		/* stw R24, <#[R31 + 148]> */
		/* 8208CF70h case    8:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000094) );
		/* 8208CF70h case    8:*/		return 0x8208CF74;
		  /* 8208CF74h */ case    9:  		/* stw R4, <#[R31 + 164]> */
		/* 8208CF74h case    9:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R31 + 0x000000A4) );
		/* 8208CF74h case    9:*/		return 0x8208CF78;
		  /* 8208CF78h */ case   10:  		/* bl 1966960 */
		/* 8208CF78h case   10:*/		regs.LR = 0x8208CF7C; return 0x8226D2E8;
		/* 8208CF78h case   10:*/		return 0x8208CF7C;
	}
	return 0x8208CF7C;
} // Block from 8208CF50h-8208CF7Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8208CF7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CF7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CF7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CF7C);
		  /* 8208CF7Ch */ case    0:  		/* stw R24, <#[R31 + 100]> */
		/* 8208CF7Ch case    0:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000064) );
		/* 8208CF7Ch case    0:*/		return 0x8208CF80;
	}
	return 0x8208CF80;
} // Block from 8208CF7Ch-8208CF80h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208CF80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CF80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CF80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CF80);
		  /* 8208CF80h */ case    0:  		/* nop */
		/* 8208CF80h case    0:*/		cpu::op::nop();
		/* 8208CF80h case    0:*/		return 0x8208CF84;
		  /* 8208CF84h */ case    1:  		/* addi R12, R31, 320 */
		/* 8208CF84h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R31,0x140);
		/* 8208CF84h case    1:*/		return 0x8208CF88;
		  /* 8208CF88h */ case    2:  		/* bl 56 */
		/* 8208CF88h case    2:*/		regs.LR = 0x8208CF8C; return 0x8208CFC0;
		/* 8208CF88h case    2:*/		return 0x8208CF8C;
		  /* 8208CF8Ch */ case    3:  		/* lwz R3, <#[R31 + 100]> */
		/* 8208CF8Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000064) );
		/* 8208CF8Ch case    3:*/		return 0x8208CF90;
		  /* 8208CF90h */ case    4:  		/* addi R1, R31, 320 */
		/* 8208CF90h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0x140);
		/* 8208CF90h case    4:*/		return 0x8208CF94;
		  /* 8208CF94h */ case    5:  		/* b 17148 */
		/* 8208CF94h case    5:*/		return 0x82091290;
		/* 8208CF94h case    5:*/		return 0x8208CF98;
	}
	return 0x8208CF98;
} // Block from 8208CF80h-8208CF98h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208CF98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CF98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CF98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CF98);
		  /* 8208CF98h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8208CF98h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208CF98h case    0:*/		return 0x8208CF9C;
		  /* 8208CF9Ch */ case    1:  		/* addi R31, R12, -320 */
		/* 8208CF9Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFEC0);
		/* 8208CF9Ch case    1:*/		return 0x8208CFA0;
		  /* 8208CFA0h */ case    2:  		/* std R28, <#[R1 - 16]> */
		/* 8208CFA0h case    2:*/		cpu::mem::store64( regs, regs.R28, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208CFA0h case    2:*/		return 0x8208CFA4;
		  /* 8208CFA4h */ case    3:  		/* std R22, <#[R1 - 24]> */
		/* 8208CFA4h case    3:*/		cpu::mem::store64( regs, regs.R22, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208CFA4h case    3:*/		return 0x8208CFA8;
		  /* 8208CFA8h */ case    4:  		/* mfspr R12, LR */
		/* 8208CFA8h case    4:*/		regs.R12 = regs.LR;
		/* 8208CFA8h case    4:*/		return 0x8208CFAC;
		  /* 8208CFACh */ case    5:  		/* stw R12, <#[R1 - 32]> */
		/* 8208CFACh case    5:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 8208CFACh case    5:*/		return 0x8208CFB0;
		  /* 8208CFB0h */ case    6:  		/* stwu R1, <#[R1 - 112]> */
		/* 8208CFB0h case    6:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8208CFB0h case    6:*/		return 0x8208CFB4;
		  /* 8208CFB4h */ case    7:  		/* lwz R28, <#[R31 + 124]> */
		/* 8208CFB4h case    7:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x0000007C) );
		/* 8208CFB4h case    7:*/		return 0x8208CFB8;
	}
	return 0x8208CFB8;
} // Block from 8208CF98h-8208CFB8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8208CFB8h
// Function 'XRegisterThreadNotifyRoutine'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CFB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CFB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CFB8);
		  /* 8208CFB8h */ case    0:  		/* lwz R22, <#[R31 + 104]> */
		/* 8208CFB8h case    0:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R31 + 0x00000068) );
		/* 8208CFB8h case    0:*/		return 0x8208CFBC;
		  /* 8208CFBCh */ case    1:  		/* b 32 */
		/* 8208CFBCh case    1:*/		return 0x8208CFDC;
		/* 8208CFBCh case    1:*/		return 0x8208CFC0;
	}
	return 0x8208CFC0;
} // Block from 8208CFB8h-8208CFC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208CFC0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CFC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CFC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CFC0);
		  /* 8208CFC0h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8208CFC0h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208CFC0h case    0:*/		return 0x8208CFC4;
		  /* 8208CFC4h */ case    1:  		/* addi R31, R12, -320 */
		/* 8208CFC4h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFEC0);
		/* 8208CFC4h case    1:*/		return 0x8208CFC8;
		  /* 8208CFC8h */ case    2:  		/* std R28, <#[R1 - 16]> */
		/* 8208CFC8h case    2:*/		cpu::mem::store64( regs, regs.R28, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208CFC8h case    2:*/		return 0x8208CFCC;
		  /* 8208CFCCh */ case    3:  		/* std R22, <#[R1 - 24]> */
		/* 8208CFCCh case    3:*/		cpu::mem::store64( regs, regs.R22, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208CFCCh case    3:*/		return 0x8208CFD0;
		  /* 8208CFD0h */ case    4:  		/* mfspr R12, LR */
		/* 8208CFD0h case    4:*/		regs.R12 = regs.LR;
		/* 8208CFD0h case    4:*/		return 0x8208CFD4;
		  /* 8208CFD4h */ case    5:  		/* stw R12, <#[R1 - 32]> */
		/* 8208CFD4h case    5:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 8208CFD4h case    5:*/		return 0x8208CFD8;
		  /* 8208CFD8h */ case    6:  		/* stwu R1, <#[R1 - 112]> */
		/* 8208CFD8h case    6:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8208CFD8h case    6:*/		return 0x8208CFDC;
	}
	return 0x8208CFDC;
} // Block from 8208CFC0h-8208CFDCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208CFDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CFDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CFDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CFDC);
		  /* 8208CFDCh */ case    0:  		/* cmplwi CR6, R22, 0 */
		/* 8208CFDCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 8208CFDCh case    0:*/		return 0x8208CFE0;
		  /* 8208CFE0h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8208CFE0h case    1:*/		if ( regs.CR[6].eq ) { return 0x8208CFEC;  }
		/* 8208CFE0h case    1:*/		return 0x8208CFE4;
		  /* 8208CFE4h */ case    2:  		/* lwz R3, <#[R28 + 1408]> */
		/* 8208CFE4h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000580) );
		/* 8208CFE4h case    2:*/		return 0x8208CFE8;
		  /* 8208CFE8h */ case    3:  		/* bl 1966144 */
		/* 8208CFE8h case    3:*/		regs.LR = 0x8208CFEC; return 0x8226D028;
		/* 8208CFE8h case    3:*/		return 0x8208CFEC;
	}
	return 0x8208CFEC;
} // Block from 8208CFDCh-8208CFECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208CFECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208CFEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208CFEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208CFEC);
		  /* 8208CFECh */ case    0:  		/* lwz R1, <#[R1]> */
		/* 8208CFECh case    0:*/		cpu::mem::load32z( regs, &regs.R1, (uint32)(regs.R1 + 0x00000000) );
		/* 8208CFECh case    0:*/		return 0x8208CFF0;
		  /* 8208CFF0h */ case    1:  		/* ld R31, <#[R1 - 8]> */
		/* 8208CFF0h case    1:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208CFF0h case    1:*/		return 0x8208CFF4;
		  /* 8208CFF4h */ case    2:  		/* ld R28, <#[R1 - 16]> */
		/* 8208CFF4h case    2:*/		cpu::mem::load64( regs, &regs.R28, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208CFF4h case    2:*/		return 0x8208CFF8;
		  /* 8208CFF8h */ case    3:  		/* ld R22, <#[R1 - 24]> */
		/* 8208CFF8h case    3:*/		cpu::mem::load64( regs, &regs.R22, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208CFF8h case    3:*/		return 0x8208CFFC;
		  /* 8208CFFCh */ case    4:  		/* lwz R12, <#[R1 - 32]> */
		/* 8208CFFCh case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 8208CFFCh case    4:*/		return 0x8208D000;
		  /* 8208D000h */ case    5:  		/* mtspr LR, R12 */
		/* 8208D000h case    5:*/		regs.LR = regs.R12;
		/* 8208D000h case    5:*/		return 0x8208D004;
		  /* 8208D004h */ case    6:  		/* bclr 20, CR0_LT */
		/* 8208D004h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208D004h case    6:*/		return 0x8208D008;
	}
	return 0x8208D008;
} // Block from 8208CFECh-8208D008h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208D008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D008);
		  /* 8208D008h */ case    0:  		/* lwz R17, <#[R6 - 11576]> */
		/* 8208D008h case    0:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 8208D008h case    0:*/		return 0x8208D00C;
		  /* 8208D00Ch */ case    1:  		/* lwz R16, <#[R4 - 15552]> */
		/* 8208D00Ch case    1:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC340) );
		/* 8208D00Ch case    1:*/		return 0x8208D010;
	}
	return 0x8208D010;
} // Block from 8208D008h-8208D010h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208D010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D010);
		  /* 8208D010h */ case    0:  		/* mfspr R12, LR */
		/* 8208D010h case    0:*/		regs.R12 = regs.LR;
		/* 8208D010h case    0:*/		return 0x8208D014;
		  /* 8208D014h */ case    1:  		/* bl 16956 */
		/* 8208D014h case    1:*/		regs.LR = 0x8208D018; return 0x82091250;
		/* 8208D014h case    1:*/		return 0x8208D018;
		  /* 8208D018h */ case    2:  		/* addi R31, R1, -160 */
		/* 8208D018h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFF60);
		/* 8208D018h case    2:*/		return 0x8208D01C;
		  /* 8208D01Ch */ case    3:  		/* stwu R1, <#[R1 - 160]> */
		/* 8208D01Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 8208D01Ch case    3:*/		return 0x8208D020;
		  /* 8208D020h */ case    4:  		/* mr R30, R3 */
		/* 8208D020h case    4:*/		regs.R30 = regs.R3;
		/* 8208D020h case    4:*/		return 0x8208D024;
		  /* 8208D024h */ case    5:  		/* mr R28, R4 */
		/* 8208D024h case    5:*/		regs.R28 = regs.R4;
		/* 8208D024h case    5:*/		return 0x8208D028;
	}
	return 0x8208D028;
} // Block from 8208D010h-8208D028h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208D028h
// Function 'XapiInitHeap'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D028);
		  /* 8208D028h */ case    0:  		/* mr R29, R5 */
		/* 8208D028h case    0:*/		regs.R29 = regs.R5;
		/* 8208D028h case    0:*/		return 0x8208D02C;
		  /* 8208D02Ch */ case    1:  		/* lwz R11, <#[R3 + 20]> */
		/* 8208D02Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 8208D02Ch case    1:*/		return 0x8208D030;
		  /* 8208D030h */ case    2:  		/* li R27, 1 */
		/* 8208D030h case    2:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 8208D030h case    2:*/		return 0x8208D034;
		  /* 8208D034h */ case    3:  		/* li R26, 0 */
		/* 8208D034h case    3:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8208D034h case    3:*/		return 0x8208D038;
		  /* 8208D038h */ case    4:  		/* rlwinm. R11, R11, 0, 13, 13 */
		/* 8208D038h case    4:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R11,regs.R11);
		/* 8208D038h case    4:*/		return 0x8208D03C;
		  /* 8208D03Ch */ case    5:  		/* stw R3, <#[R31 + 100]> */
		/* 8208D03Ch case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000064) );
		/* 8208D03Ch case    5:*/		return 0x8208D040;
		  /* 8208D040h */ case    6:  		/* stw R26, <#[R31 + 84]> */
		/* 8208D040h case    6:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000054) );
		/* 8208D040h case    6:*/		return 0x8208D044;
		  /* 8208D044h */ case    7:  		/* stw R27, <#[R31 + 88]> */
		/* 8208D044h case    7:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000058) );
		/* 8208D044h case    7:*/		return 0x8208D048;
		  /* 8208D048h */ case    8:  		/* bc 12, CR0_EQ, 44 */
		/* 8208D048h case    8:*/		if ( regs.CR[0].eq ) { return 0x8208D074;  }
		/* 8208D048h case    8:*/		return 0x8208D04C;
		  /* 8208D04Ch */ case    9:  		/* bl 1965740 */
		/* 8208D04Ch case    9:*/		regs.LR = 0x8208D050; return 0x8226CEF8;
		/* 8208D04Ch case    9:*/		return 0x8208D050;
		  /* 8208D050h */ case   10:  		/* lbz R11, <#[R30 + 379]> */
		/* 8208D050h case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000017B) );
		/* 8208D050h case   10:*/		return 0x8208D054;
		  /* 8208D054h */ case   11:  		/* cmpw CR6, R11, R3 */
		/* 8208D054h case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R3);
		/* 8208D054h case   11:*/		return 0x8208D058;
		  /* 8208D058h */ case   12:  		/* bc 12, CR6_EQ, 28 */
		/* 8208D058h case   12:*/		if ( regs.CR[6].eq ) { return 0x8208D074;  }
		/* 8208D058h case   12:*/		return 0x8208D05C;
		  /* 8208D05Ch */ case   13:  		/* mr R7, R29 */
		/* 8208D05Ch case   13:*/		regs.R7 = regs.R29;
		/* 8208D05Ch case   13:*/		return 0x8208D060;
		  /* 8208D060h */ case   14:  		/* li R6, 4450 */
		/* 8208D060h case   14:*/		cpu::op::li<0>(regs,&regs.R6,0x1162);
		/* 8208D060h case   14:*/		return 0x8208D064;
		  /* 8208D064h */ case   15:  		/* lwz R5, <#[R31 + 152]> */
		/* 8208D064h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000098) );
		/* 8208D064h case   15:*/		return 0x8208D068;
		  /* 8208D068h */ case   16:  		/* mr R4, R30 */
		/* 8208D068h case   16:*/		regs.R4 = regs.R30;
		/* 8208D068h case   16:*/		return 0x8208D06C;
		  /* 8208D06Ch */ case   17:  		/* li R3, 244 */
		/* 8208D06Ch case   17:*/		cpu::op::li<0>(regs,&regs.R3,0xF4);
		/* 8208D06Ch case   17:*/		return 0x8208D070;
		  /* 8208D070h */ case   18:  		/* bl 1967064 */
		/* 8208D070h case   18:*/		regs.LR = 0x8208D074; return 0x8226D448;
		/* 8208D070h case   18:*/		return 0x8208D074;
	}
	return 0x8208D074;
} // Block from 8208D028h-8208D074h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8208D074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D074);
		  /* 8208D074h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 8208D074h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8208D074h case    0:*/		return 0x8208D078;
		  /* 8208D078h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 8208D078h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8208D084;  }
		/* 8208D078h case    1:*/		return 0x8208D07C;
		  /* 8208D07Ch */ case    2:  		/* li R3, 1 */
		/* 8208D07Ch case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8208D07Ch case    2:*/		return 0x8208D080;
		  /* 8208D080h */ case    3:  		/* b 516 */
		/* 8208D080h case    3:*/		return 0x8208D284;
		/* 8208D080h case    3:*/		return 0x8208D084;
	}
	return 0x8208D084;
} // Block from 8208D074h-8208D084h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208D084h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D084( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D084) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D084);
		  /* 8208D084h */ case    0:  		/* lwz R11, <#[R30 + 24]> */
		/* 8208D084h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 8208D084h case    0:*/		return 0x8208D088;
		  /* 8208D088h */ case    1:  		/* addi R29, R29, -16 */
		/* 8208D088h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0xFFFFFFF0);
		/* 8208D088h case    1:*/		return 0x8208D08C;
		  /* 8208D08Ch */ case    2:  		/* or R11, R11, R28 */
		/* 8208D08Ch case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 8208D08Ch case    2:*/		return 0x8208D090;
		  /* 8208D090h */ case    3:  		/* nop */
		/* 8208D090h case    3:*/		cpu::op::nop();
		/* 8208D090h case    3:*/		return 0x8208D094;
	}
	return 0x8208D094;
} // Block from 8208D084h-8208D094h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208D094h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D094( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D094) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D094);
		  /* 8208D094h */ case    0:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8208D094h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8208D094h case    0:*/		return 0x8208D098;
		  /* 8208D098h */ case    1:  		/* bc 4, CR0_EQ, 20 */
		/* 8208D098h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8208D0AC;  }
		/* 8208D098h case    1:*/		return 0x8208D09C;
		  /* 8208D09Ch */ case    2:  		/* lwz R3, <#[R30 + 1408]> */
		/* 8208D09Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000580) );
		/* 8208D09Ch case    2:*/		return 0x8208D0A0;
		  /* 8208D0A0h */ case    3:  		/* bl 1965976 */
		/* 8208D0A0h case    3:*/		regs.LR = 0x8208D0A4; return 0x8226D038;
		/* 8208D0A0h case    3:*/		return 0x8208D0A4;
		  /* 8208D0A4h */ case    4:  		/* mr R26, R27 */
		/* 8208D0A4h case    4:*/		regs.R26 = regs.R27;
		/* 8208D0A4h case    4:*/		return 0x8208D0A8;
		  /* 8208D0A8h */ case    5:  		/* stw R27, <#[R31 + 84]> */
		/* 8208D0A8h case    5:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000054) );
		/* 8208D0A8h case    5:*/		return 0x8208D0AC;
	}
	return 0x8208D0AC;
} // Block from 8208D094h-8208D0ACh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208D0ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D0AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D0AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D0AC);
		  /* 8208D0ACh */ case    0:  		/* lbz R11, <#[R29 + 5]> */
		/* 8208D0ACh case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000005) );
		/* 8208D0ACh case    0:*/		return 0x8208D0B0;
		  /* 8208D0B0h */ case    1:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 8208D0B0h case    1:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 8208D0B0h case    1:*/		return 0x8208D0B4;
		  /* 8208D0B4h */ case    2:  		/* bc 4, CR0_EQ, 352 */
		/* 8208D0B4h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8208D214;  }
		/* 8208D0B4h case    2:*/		return 0x8208D0B8;
		  /* 8208D0B8h */ case    3:  		/* lhz R11, <#[R29]> */
		/* 8208D0B8h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8208D0B8h case    3:*/		return 0x8208D0BC;
		  /* 8208D0BCh */ case    4:  		/* li R6, 0 */
		/* 8208D0BCh case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8208D0BCh case    4:*/		return 0x8208D0C0;
		  /* 8208D0C0h */ case    5:  		/* addi R5, R31, 80 */
		/* 8208D0C0h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x50);
		/* 8208D0C0h case    5:*/		return 0x8208D0C4;
		  /* 8208D0C4h */ case    6:  		/* mr R3, R30 */
		/* 8208D0C4h case    6:*/		regs.R3 = regs.R30;
		/* 8208D0C4h case    6:*/		return 0x8208D0C8;
		  /* 8208D0C8h */ case    7:  		/* mr R4, R29 */
		/* 8208D0C8h case    7:*/		regs.R4 = regs.R29;
		/* 8208D0C8h case    7:*/		return 0x8208D0CC;
		  /* 8208D0CCh */ case    8:  		/* stw R11, <#[R31 + 80]> */
		/* 8208D0CCh case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208D0CCh case    8:*/		return 0x8208D0D0;
		  /* 8208D0D0h */ case    9:  		/* bl -8704 */
		/* 8208D0D0h case    9:*/		regs.LR = 0x8208D0D4; return 0x8208AED0;
		/* 8208D0D0h case    9:*/		return 0x8208D0D4;
		  /* 8208D0D4h */ case   10:  		/* lwz R5, <#[R31 + 80]> */
		/* 8208D0D4h case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000050) );
		/* 8208D0D4h case   10:*/		return 0x8208D0D8;
		  /* 8208D0D8h */ case   11:  		/* mr R4, R3 */
		/* 8208D0D8h case   11:*/		regs.R4 = regs.R3;
		/* 8208D0D8h case   11:*/		return 0x8208D0DC;
		  /* 8208D0DCh */ case   12:  		/* cmplwi CR6, R5, 128 */
		/* 8208D0DCh case   12:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000080);
		/* 8208D0DCh case   12:*/		return 0x8208D0E0;
		  /* 8208D0E0h */ case   13:  		/* bc 4, CR6_LT, 124 */
		/* 8208D0E0h case   13:*/		if ( !regs.CR[6].lt ) { return 0x8208D15C;  }
		/* 8208D0E0h case   13:*/		return 0x8208D0E4;
		  /* 8208D0E4h */ case   14:  		/* lbz R11, <#[R3 + 5]> */
		/* 8208D0E4h case   14:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000005) );
		/* 8208D0E4h case   14:*/		return 0x8208D0E8;
		  /* 8208D0E8h */ case   15:  		/* rlwinm R11, R11, 0, 27, 27 */
		/* 8208D0E8h case   15:*/		cpu::op::rlwinm<0,0,27,27>(regs,&regs.R11,regs.R11);
		/* 8208D0E8h case   15:*/		return 0x8208D0EC;
		  /* 8208D0ECh */ case   16:  		/* stb R11, <#[R3 + 5]> */
		/* 8208D0ECh case   16:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000005) );
		/* 8208D0ECh case   16:*/		return 0x8208D0F0;
		  /* 8208D0F0h */ case   17:  		/* lwz R11, <#[R31 + 80]> */
		/* 8208D0F0h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208D0F0h case   17:*/		return 0x8208D0F4;
		  /* 8208D0F4h */ case   18:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8208D0F4h case   18:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8208D0F4h case   18:*/		return 0x8208D0F8;
		  /* 8208D0F8h */ case   19:  		/* addi R11, R11, 48 */
		/* 8208D0F8h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x30);
		/* 8208D0F8h case   19:*/		return 0x8208D0FC;
		  /* 8208D0FCh */ case   20:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8208D0FCh case   20:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8208D0FCh case   20:*/		return 0x8208D100;
	}
	return 0x8208D100;
} // Block from 8208D0ACh-8208D100h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8208D100h
// Function 'XapiInitProcess'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D100);
		  /* 8208D100h */ case    0:  		/* add R11, R11, R30 */
		/* 8208D100h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8208D100h case    0:*/		return 0x8208D104;
		  /* 8208D104h */ case    1:  		/* lwz R10, <#[R11]> */
		/* 8208D104h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208D104h case    1:*/		return 0x8208D108;
		  /* 8208D108h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 8208D108h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208D108h case    2:*/		return 0x8208D10C;
		  /* 8208D10Ch */ case    3:  		/* bc 4, CR6_EQ, 40 */
		/* 8208D10Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8208D134;  }
		/* 8208D10Ch case    3:*/		return 0x8208D110;
		  /* 8208D110h */ case    4:  		/* lhz R9, <#[R3]> */
		/* 8208D110h case    4:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 8208D110h case    4:*/		return 0x8208D114;
		  /* 8208D114h */ case    5:  		/* rlwinm R10, R9, 27, 5, 31 */
		/* 8208D114h case    5:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R9);
		/* 8208D114h case    5:*/		return 0x8208D118;
		  /* 8208D118h */ case    6:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 8208D118h case    6:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8208D118h case    6:*/		return 0x8208D11C;
		  /* 8208D11Ch */ case    7:  		/* addi R10, R10, 88 */
		/* 8208D11Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x58);
		/* 8208D11Ch case    7:*/		return 0x8208D120;
		  /* 8208D120h */ case    8:  		/* slw R9, R27, R9 */
		/* 8208D120h case    8:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R27,regs.R9);
		/* 8208D120h case    8:*/		return 0x8208D124;
		  /* 8208D124h */ case    9:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8208D124h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8208D124h case    9:*/		return 0x8208D128;
		  /* 8208D128h */ case   10:  		/* lwzx R8, <#[R10 + R30]> */
		/* 8208D128h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 8208D128h case   10:*/		return 0x8208D12C;
		  /* 8208D12Ch */ case   11:  		/* or R9, R9, R8 */
		/* 8208D12Ch case   11:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8208D12Ch case   11:*/		return 0x8208D130;
		  /* 8208D130h */ case   12:  		/* stwx R9, <#[R10 + R30]> */
		/* 8208D130h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 8208D130h case   12:*/		return 0x8208D134;
	}
	return 0x8208D134;
} // Block from 8208D100h-8208D134h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8208D134h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D134( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D134) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D134);
		  /* 8208D134h */ case    0:  		/* lwz R9, <#[R11 + 4]> */
		/* 8208D134h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8208D134h case    0:*/		return 0x8208D138;
		  /* 8208D138h */ case    1:  		/* addi R10, R4, 8 */
		/* 8208D138h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x8);
		/* 8208D138h case    1:*/		return 0x8208D13C;
		  /* 8208D13Ch */ case    2:  		/* stw R11, <#[R4 + 8]> */
		/* 8208D13Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8208D13Ch case    2:*/		return 0x8208D140;
		  /* 8208D140h */ case    3:  		/* stw R9, <#[R4 + 12]> */
		/* 8208D140h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R4 + 0x0000000C) );
		/* 8208D140h case    3:*/		return 0x8208D144;
		  /* 8208D144h */ case    4:  		/* stw R10, <#[R9]> */
		/* 8208D144h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8208D144h case    4:*/		return 0x8208D148;
		  /* 8208D148h */ case    5:  		/* stw R10, <#[R11 + 4]> */
		/* 8208D148h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8208D148h case    5:*/		return 0x8208D14C;
		  /* 8208D14Ch */ case    6:  		/* lwz R11, <#[R31 + 80]> */
		/* 8208D14Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208D14Ch case    6:*/		return 0x8208D150;
		  /* 8208D150h */ case    7:  		/* lwz R10, <#[R30 + 48]> */
		/* 8208D150h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000030) );
		/* 8208D150h case    7:*/		return 0x8208D154;
		  /* 8208D154h */ case    8:  		/* add R11, R10, R11 */
		/* 8208D154h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208D154h case    8:*/		return 0x8208D158;
		  /* 8208D158h */ case    9:  		/* b 168 */
		/* 8208D158h case    9:*/		return 0x8208D200;
		/* 8208D158h case    9:*/		return 0x8208D15C;
	}
	return 0x8208D15C;
} // Block from 8208D134h-8208D15Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8208D15Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D15C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D15C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D15C);
		  /* 8208D15Ch */ case    0:  		/* lwz R11, <#[R30 + 40]> */
		/* 8208D15Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 8208D15Ch case    0:*/		return 0x8208D160;
	}
	return 0x8208D160;
} // Block from 8208D15Ch-8208D160h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208D160h
// Function 'XMemCpyStreaming128_Writecombined_Helper'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D160);
		  /* 8208D160h */ case    0:  		/* cmplw CR6, R5, R11 */
		/* 8208D160h case    0:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 8208D160h case    0:*/		return 0x8208D164;
		  /* 8208D164h */ case    1:  		/* bc 12, CR6_LT, 36 */
		/* 8208D164h case    1:*/		if ( regs.CR[6].lt ) { return 0x8208D188;  }
		/* 8208D164h case    1:*/		return 0x8208D168;
		  /* 8208D168h */ case    2:  		/* lwz R11, <#[R30 + 48]> */
		/* 8208D168h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 8208D168h case    2:*/		return 0x8208D16C;
		  /* 8208D16Ch */ case    3:  		/* lwz R10, <#[R30 + 44]> */
		/* 8208D16Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000002C) );
		/* 8208D16Ch case    3:*/		return 0x8208D170;
		  /* 8208D170h */ case    4:  		/* add R11, R11, R5 */
		/* 8208D170h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 8208D170h case    4:*/		return 0x8208D174;
		  /* 8208D174h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 8208D174h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8208D174h case    5:*/		return 0x8208D178;
		  /* 8208D178h */ case    6:  		/* bc 12, CR6_LT, 16 */
		/* 8208D178h case    6:*/		if ( regs.CR[6].lt ) { return 0x8208D188;  }
		/* 8208D178h case    6:*/		return 0x8208D17C;
		  /* 8208D17Ch */ case    7:  		/* mr R3, R30 */
		/* 8208D17Ch case    7:*/		regs.R3 = regs.R30;
		/* 8208D17Ch case    7:*/		return 0x8208D180;
		  /* 8208D180h */ case    8:  		/* bl -5024 */
		/* 8208D180h case    8:*/		regs.LR = 0x8208D184; return 0x8208BDE0;
		/* 8208D180h case    8:*/		return 0x8208D184;
		  /* 8208D184h */ case    9:  		/* b 240 */
		/* 8208D184h case    9:*/		return 0x8208D274;
		/* 8208D184h case    9:*/		return 0x8208D188;
	}
	return 0x8208D188;
} // Block from 8208D160h-8208D188h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8208D188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D188);
		  /* 8208D188h */ case    0:  		/* cmplwi CR6, R5, 61440 */
		/* 8208D188h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x0000F000);
		/* 8208D188h case    0:*/		return 0x8208D18C;
		  /* 8208D18Ch */ case    1:  		/* bc 12, CR6_GT, 124 */
		/* 8208D18Ch case    1:*/		if ( regs.CR[6].gt ) { return 0x8208D208;  }
		/* 8208D18Ch case    1:*/		return 0x8208D190;
		  /* 8208D190h */ case    2:  		/* lbz R11, <#[R4 + 5]> */
		/* 8208D190h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000005) );
		/* 8208D190h case    2:*/		return 0x8208D194;
		  /* 8208D194h */ case    3:  		/* addi R10, R30, 384 */
		/* 8208D194h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x180);
		/* 8208D194h case    3:*/		return 0x8208D198;
		  /* 8208D198h */ case    4:  		/* rlwinm R11, R11, 0, 27, 27 */
		/* 8208D198h case    4:*/		cpu::op::rlwinm<0,0,27,27>(regs,&regs.R11,regs.R11);
		/* 8208D198h case    4:*/		return 0x8208D19C;
		  /* 8208D19Ch */ case    5:  		/* stb R11, <#[R4 + 5]> */
		/* 8208D19Ch case    5:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R4 + 0x00000005) );
		/* 8208D19Ch case    5:*/		return 0x8208D1A0;
		  /* 8208D1A0h */ case    6:  		/* lwz R11, <#[R30 + 384]> */
		/* 8208D1A0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000180) );
		/* 8208D1A0h case    6:*/		return 0x8208D1A4;
		  /* 8208D1A4h */ case    7:  		/* stw R11, <#[R31 + 92]> */
		/* 8208D1A4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208D1A4h case    7:*/		return 0x8208D1A8;
		  /* 8208D1A8h */ case    8:  		/* cmplw CR6, R10, R11 */
		/* 8208D1A8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208D1A8h case    8:*/		return 0x8208D1AC;
		  /* 8208D1ACh */ case    9:  		/* bc 12, CR6_EQ, 48 */
		/* 8208D1ACh case    9:*/		if ( regs.CR[6].eq ) { return 0x8208D1DC;  }
		/* 8208D1ACh case    9:*/		return 0x8208D1B0;
		  /* 8208D1B0h */ case   10:  		/* lwz R9, <#[R31 + 80]> */
		/* 8208D1B0h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000050) );
		/* 8208D1B0h case   10:*/		return 0x8208D1B4;
		  /* 8208D1B4h */ case   11:  		/* addi R8, R11, -8 */
		/* 8208D1B4h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFF8);
		/* 8208D1B4h case   11:*/		return 0x8208D1B8;
		  /* 8208D1B8h */ case   12:  		/* lhz R7, <#[R11 - 8]> */
		/* 8208D1B8h case   12:*/		cpu::mem::load16z( regs, &regs.R7, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 8208D1B8h case   12:*/		return 0x8208D1BC;
		  /* 8208D1BCh */ case   13:  		/* rlwinm R9, R9, 0, 16, 31 */
		/* 8208D1BCh case   13:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R9);
		/* 8208D1BCh case   13:*/		return 0x8208D1C0;
		  /* 8208D1C0h */ case   14:  		/* stw R8, <#[R31 + 96]> */
		/* 8208D1C0h case   14:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000060) );
		/* 8208D1C0h case   14:*/		return 0x8208D1C4;
		  /* 8208D1C4h */ case   15:  		/* cmplw CR6, R9, R7 */
		/* 8208D1C4h case   15:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 8208D1C4h case   15:*/		return 0x8208D1C8;
		  /* 8208D1C8h */ case   16:  		/* bc 4, CR6_GT, 20 */
		/* 8208D1C8h case   16:*/		if ( !regs.CR[6].gt ) { return 0x8208D1DC;  }
		/* 8208D1C8h case   16:*/		return 0x8208D1CC;
		  /* 8208D1CCh */ case   17:  		/* lwz R11, <#[R11]> */
		/* 8208D1CCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8208D1CCh case   17:*/		return 0x8208D1D0;
		  /* 8208D1D0h */ case   18:  		/* stw R11, <#[R31 + 92]> */
		/* 8208D1D0h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208D1D0h case   18:*/		return 0x8208D1D4;
		  /* 8208D1D4h */ case   19:  		/* nop */
		/* 8208D1D4h case   19:*/		cpu::op::nop();
		/* 8208D1D4h case   19:*/		return 0x8208D1D8;
		  /* 8208D1D8h */ case   20:  		/* b -48 */
		/* 8208D1D8h case   20:*/		return 0x8208D1A8;
		/* 8208D1D8h case   20:*/		return 0x8208D1DC;
	}
	return 0x8208D1DC;
} // Block from 8208D188h-8208D1DCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 8208D1DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D1DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D1DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D1DC);
		  /* 8208D1DCh */ case    0:  		/* lwz R9, <#[R11 + 4]> */
		/* 8208D1DCh case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8208D1DCh case    0:*/		return 0x8208D1E0;
		  /* 8208D1E0h */ case    1:  		/* addi R10, R4, 8 */
		/* 8208D1E0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x8);
		/* 8208D1E0h case    1:*/		return 0x8208D1E4;
		  /* 8208D1E4h */ case    2:  		/* stw R11, <#[R4 + 8]> */
		/* 8208D1E4h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8208D1E4h case    2:*/		return 0x8208D1E8;
		  /* 8208D1E8h */ case    3:  		/* stw R9, <#[R4 + 12]> */
		/* 8208D1E8h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R4 + 0x0000000C) );
		/* 8208D1E8h case    3:*/		return 0x8208D1EC;
		  /* 8208D1ECh */ case    4:  		/* stw R10, <#[R9]> */
		/* 8208D1ECh case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8208D1ECh case    4:*/		return 0x8208D1F0;
		  /* 8208D1F0h */ case    5:  		/* stw R10, <#[R11 + 4]> */
		/* 8208D1F0h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8208D1F0h case    5:*/		return 0x8208D1F4;
		  /* 8208D1F4h */ case    6:  		/* lwz R10, <#[R30 + 48]> */
		/* 8208D1F4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000030) );
		/* 8208D1F4h case    6:*/		return 0x8208D1F8;
		  /* 8208D1F8h */ case    7:  		/* lwz R11, <#[R31 + 80]> */
		/* 8208D1F8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208D1F8h case    7:*/		return 0x8208D1FC;
		  /* 8208D1FCh */ case    8:  		/* add R11, R11, R10 */
		/* 8208D1FCh case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8208D1FCh case    8:*/		return 0x8208D200;
	}
	return 0x8208D200;
} // Block from 8208D1DCh-8208D200h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8208D200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D200);
		  /* 8208D200h */ case    0:  		/* stw R11, <#[R30 + 48]> */
		/* 8208D200h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 8208D200h case    0:*/		return 0x8208D204;
		  /* 8208D204h */ case    1:  		/* b 112 */
		/* 8208D204h case    1:*/		return 0x8208D274;
		/* 8208D204h case    1:*/		return 0x8208D208;
	}
	return 0x8208D208;
} // Block from 8208D200h-8208D208h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208D208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D208);
		  /* 8208D208h */ case    0:  		/* mr R3, R30 */
		/* 8208D208h case    0:*/		regs.R3 = regs.R30;
		/* 8208D208h case    0:*/		return 0x8208D20C;
		  /* 8208D20Ch */ case    1:  		/* bl -7988 */
		/* 8208D20Ch case    1:*/		regs.LR = 0x8208D210; return 0x8208B2D8;
		/* 8208D20Ch case    1:*/		return 0x8208D210;
		  /* 8208D210h */ case    2:  		/* b 100 */
		/* 8208D210h case    2:*/		return 0x8208D274;
		/* 8208D210h case    2:*/		return 0x8208D214;
	}
	return 0x8208D214;
} // Block from 8208D208h-8208D214h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208D214h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D214( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D214) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D214);
		  /* 8208D214h */ case    0:  		/* addi R11, R29, -32 */
		/* 8208D214h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFE0);
		/* 8208D214h case    0:*/		return 0x8208D218;
		  /* 8208D218h */ case    1:  		/* cmplwi CR6, R26, 0 */
		/* 8208D218h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 8208D218h case    1:*/		return 0x8208D21C;
		  /* 8208D21Ch */ case    2:  		/* stw R11, <#[R31 + 96]> */
		/* 8208D21Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 8208D21Ch case    2:*/		return 0x8208D220;
		  /* 8208D220h */ case    3:  		/* lwz R11, <#[R29 - 32]> */
		/* 8208D220h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0xFFFFFFE0) );
		/* 8208D220h case    3:*/		return 0x8208D224;
		  /* 8208D224h */ case    4:  		/* lwz R10, <#[R29 - 28]> */
		/* 8208D224h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0xFFFFFFE4) );
		/* 8208D224h case    4:*/		return 0x8208D228;
		  /* 8208D228h */ case    5:  		/* stw R11, <#[R10]> */
		/* 8208D228h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8208D228h case    5:*/		return 0x8208D22C;
		  /* 8208D22Ch */ case    6:  		/* stw R10, <#[R11 + 4]> */
		/* 8208D22Ch case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8208D22Ch case    6:*/		return 0x8208D230;
		  /* 8208D230h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 8208D230h case    7:*/		if ( regs.CR[6].eq ) { return 0x8208D244;  }
		/* 8208D230h case    7:*/		return 0x8208D234;
		  /* 8208D234h */ case    8:  		/* lwz R3, <#[R30 + 1408]> */
		/* 8208D234h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000580) );
		/* 8208D234h case    8:*/		return 0x8208D238;
		  /* 8208D238h */ case    9:  		/* bl 1965552 */
		/* 8208D238h case    9:*/		regs.LR = 0x8208D23C; return 0x8226D028;
		/* 8208D238h case    9:*/		return 0x8208D23C;
		  /* 8208D23Ch */ case   10:  		/* li R26, 0 */
		/* 8208D23Ch case   10:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8208D23Ch case   10:*/		return 0x8208D240;
		  /* 8208D240h */ case   11:  		/* stw R26, <#[R31 + 84]> */
		/* 8208D240h case   11:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000054) );
		/* 8208D240h case   11:*/		return 0x8208D244;
	}
	return 0x8208D244;
} // Block from 8208D214h-8208D244h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8208D244h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D244( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D244) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D244);
		  /* 8208D244h */ case    0:  		/* li R11, 0 */
		/* 8208D244h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8208D244h case    0:*/		return 0x8208D248;
		  /* 8208D248h */ case    1:  		/* lis R5, 0 */
		/* 8208D248h case    1:*/		cpu::op::lis<0>(regs,&regs.R5,0x0);
		/* 8208D248h case    1:*/		return 0x8208D24C;
		  /* 8208D24Ch */ case    2:  		/* stw R11, <#[R31 + 80]> */
		/* 8208D24Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208D24Ch case    2:*/		return 0x8208D250;
		  /* 8208D250h */ case    3:  		/* addi R4, R31, 80 */
		/* 8208D250h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x50);
		/* 8208D250h case    3:*/		return 0x8208D254;
		  /* 8208D254h */ case    4:  		/* ori R5, R5, 32768 */
		/* 8208D254h case    4:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x8000);
		/* 8208D254h case    4:*/		return 0x8208D258;
		  /* 8208D258h */ case    5:  		/* lwz R6, <#[R30 + 1424]> */
		/* 8208D258h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000590) );
		/* 8208D258h case    5:*/		return 0x8208D25C;
		  /* 8208D25Ch */ case    6:  		/* addi R3, R31, 96 */
		/* 8208D25Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x60);
		/* 8208D25Ch case    6:*/		return 0x8208D260;
		  /* 8208D260h */ case    7:  		/* bl 1966584 */
		/* 8208D260h case    7:*/		regs.LR = 0x8208D264; return 0x8226D458;
		/* 8208D260h case    7:*/		return 0x8208D264;
		  /* 8208D264h */ case    8:  		/* rlwinm R11, R3, 1, 31, 31 */
		/* 8208D264h case    8:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R3);
		/* 8208D264h case    8:*/		return 0x8208D268;
		  /* 8208D268h */ case    9:  		/* addi R11, R11, -1 */
		/* 8208D268h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8208D268h case    9:*/		return 0x8208D26C;
		  /* 8208D26Ch */ case   10:  		/* and R11, R11, R27 */
		/* 8208D26Ch case   10:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 8208D26Ch case   10:*/		return 0x8208D270;
		  /* 8208D270h */ case   11:  		/* stw R11, <#[R31 + 88]> */
		/* 8208D270h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 8208D270h case   11:*/		return 0x8208D274;
	}
	return 0x8208D274;
} // Block from 8208D244h-8208D274h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8208D274h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D274( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D274) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D274);
		  /* 8208D274h */ case    0:  		/* nop */
		/* 8208D274h case    0:*/		cpu::op::nop();
		/* 8208D274h case    0:*/		return 0x8208D278;
		  /* 8208D278h */ case    1:  		/* addi R12, R31, 160 */
		/* 8208D278h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R31,0xA0);
		/* 8208D278h case    1:*/		return 0x8208D27C;
		  /* 8208D27Ch */ case    2:  		/* bl 56 */
		/* 8208D27Ch case    2:*/		regs.LR = 0x8208D280; return 0x8208D2B4;
		/* 8208D27Ch case    2:*/		return 0x8208D280;
		  /* 8208D280h */ case    3:  		/* lwz R3, <#[R31 + 88]> */
		/* 8208D280h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000058) );
		/* 8208D280h case    3:*/		return 0x8208D284;
	}
	return 0x8208D284;
} // Block from 8208D274h-8208D284h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208D284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D284);
		  /* 8208D284h */ case    0:  		/* addi R1, R31, 160 */
		/* 8208D284h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0xA0);
		/* 8208D284h case    0:*/		return 0x8208D288;
		  /* 8208D288h */ case    1:  		/* b 16408 */
		/* 8208D288h case    1:*/		return 0x820912A0;
		/* 8208D288h case    1:*/		return 0x8208D28C;
	}
	return 0x8208D28C;
} // Block from 8208D284h-8208D28Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208D28Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D28C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D28C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D28C);
		  /* 8208D28Ch */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8208D28Ch case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208D28Ch case    0:*/		return 0x8208D290;
		  /* 8208D290h */ case    1:  		/* addi R31, R12, -160 */
		/* 8208D290h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFF60);
		/* 8208D290h case    1:*/		return 0x8208D294;
		  /* 8208D294h */ case    2:  		/* std R30, <#[R1 - 16]> */
		/* 8208D294h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208D294h case    2:*/		return 0x8208D298;
		  /* 8208D298h */ case    3:  		/* std R26, <#[R1 - 24]> */
		/* 8208D298h case    3:*/		cpu::mem::store64( regs, regs.R26, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208D298h case    3:*/		return 0x8208D29C;
		  /* 8208D29Ch */ case    4:  		/* mfspr R12, LR */
		/* 8208D29Ch case    4:*/		regs.R12 = regs.LR;
		/* 8208D29Ch case    4:*/		return 0x8208D2A0;
		  /* 8208D2A0h */ case    5:  		/* stw R12, <#[R1 - 32]> */
		/* 8208D2A0h case    5:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 8208D2A0h case    5:*/		return 0x8208D2A4;
		  /* 8208D2A4h */ case    6:  		/* stwu R1, <#[R1 - 112]> */
		/* 8208D2A4h case    6:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8208D2A4h case    6:*/		return 0x8208D2A8;
		  /* 8208D2A8h */ case    7:  		/* lwz R30, <#[R31 + 100]> */
		/* 8208D2A8h case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000064) );
		/* 8208D2A8h case    7:*/		return 0x8208D2AC;
		  /* 8208D2ACh */ case    8:  		/* lwz R26, <#[R31 + 84]> */
		/* 8208D2ACh case    8:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R31 + 0x00000054) );
		/* 8208D2ACh case    8:*/		return 0x8208D2B0;
		  /* 8208D2B0h */ case    9:  		/* b 32 */
		/* 8208D2B0h case    9:*/		return 0x8208D2D0;
		/* 8208D2B0h case    9:*/		return 0x8208D2B4;
	}
	return 0x8208D2B4;
} // Block from 8208D28Ch-8208D2B4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8208D2B4h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D2B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D2B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D2B4);
		  /* 8208D2B4h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8208D2B4h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208D2B4h case    0:*/		return 0x8208D2B8;
		  /* 8208D2B8h */ case    1:  		/* addi R31, R12, -160 */
		/* 8208D2B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFF60);
		/* 8208D2B8h case    1:*/		return 0x8208D2BC;
		  /* 8208D2BCh */ case    2:  		/* std R30, <#[R1 - 16]> */
		/* 8208D2BCh case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208D2BCh case    2:*/		return 0x8208D2C0;
		  /* 8208D2C0h */ case    3:  		/* std R26, <#[R1 - 24]> */
		/* 8208D2C0h case    3:*/		cpu::mem::store64( regs, regs.R26, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208D2C0h case    3:*/		return 0x8208D2C4;
		  /* 8208D2C4h */ case    4:  		/* mfspr R12, LR */
		/* 8208D2C4h case    4:*/		regs.R12 = regs.LR;
		/* 8208D2C4h case    4:*/		return 0x8208D2C8;
		  /* 8208D2C8h */ case    5:  		/* stw R12, <#[R1 - 32]> */
		/* 8208D2C8h case    5:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 8208D2C8h case    5:*/		return 0x8208D2CC;
		  /* 8208D2CCh */ case    6:  		/* stwu R1, <#[R1 - 112]> */
		/* 8208D2CCh case    6:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8208D2CCh case    6:*/		return 0x8208D2D0;
	}
	return 0x8208D2D0;
} // Block from 8208D2B4h-8208D2D0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208D2D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D2D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D2D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D2D0);
		  /* 8208D2D0h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 8208D2D0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 8208D2D0h case    0:*/		return 0x8208D2D4;
		  /* 8208D2D4h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8208D2D4h case    1:*/		if ( regs.CR[6].eq ) { return 0x8208D2E0;  }
		/* 8208D2D4h case    1:*/		return 0x8208D2D8;
		  /* 8208D2D8h */ case    2:  		/* lwz R3, <#[R30 + 1408]> */
		/* 8208D2D8h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000580) );
		/* 8208D2D8h case    2:*/		return 0x8208D2DC;
		  /* 8208D2DCh */ case    3:  		/* bl 1965388 */
		/* 8208D2DCh case    3:*/		regs.LR = 0x8208D2E0; return 0x8226D028;
		/* 8208D2DCh case    3:*/		return 0x8208D2E0;
	}
	return 0x8208D2E0;
} // Block from 8208D2D0h-8208D2E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208D2E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D2E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D2E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D2E0);
		  /* 8208D2E0h */ case    0:  		/* lwz R1, <#[R1]> */
		/* 8208D2E0h case    0:*/		cpu::mem::load32z( regs, &regs.R1, (uint32)(regs.R1 + 0x00000000) );
		/* 8208D2E0h case    0:*/		return 0x8208D2E4;
		  /* 8208D2E4h */ case    1:  		/* ld R31, <#[R1 - 8]> */
		/* 8208D2E4h case    1:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208D2E4h case    1:*/		return 0x8208D2E8;
		  /* 8208D2E8h */ case    2:  		/* ld R30, <#[R1 - 16]> */
		/* 8208D2E8h case    2:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208D2E8h case    2:*/		return 0x8208D2EC;
		  /* 8208D2ECh */ case    3:  		/* ld R26, <#[R1 - 24]> */
		/* 8208D2ECh case    3:*/		cpu::mem::load64( regs, &regs.R26, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208D2ECh case    3:*/		return 0x8208D2F0;
		  /* 8208D2F0h */ case    4:  		/* lwz R12, <#[R1 - 32]> */
		/* 8208D2F0h case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 8208D2F0h case    4:*/		return 0x8208D2F4;
		  /* 8208D2F4h */ case    5:  		/* mtspr LR, R12 */
		/* 8208D2F4h case    5:*/		regs.LR = regs.R12;
		/* 8208D2F4h case    5:*/		return 0x8208D2F8;
		  /* 8208D2F8h */ case    6:  		/* bclr 20, CR0_LT */
		/* 8208D2F8h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208D2F8h case    6:*/		return 0x8208D2FC;
	}
	return 0x8208D2FC;
} // Block from 8208D2E0h-8208D2FCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208D2FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D2FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D2FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D2FC);
		  /* 8208D2FCh */ case    0:  		/* nop */
		/* 8208D2FCh case    0:*/		cpu::op::nop();
		/* 8208D2FCh case    0:*/		return 0x8208D300;
		  /* 8208D300h */ case    1:  		/* lwz R17, <#[R6 - 11576]> */
		/* 8208D300h case    1:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 8208D300h case    1:*/		return 0x8208D304;
		  /* 8208D304h */ case    2:  		/* lwz R16, <#[R4 - 15528]> */
		/* 8208D304h case    2:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC358) );
		/* 8208D304h case    2:*/		return 0x8208D308;
	}
	return 0x8208D308;
} // Block from 8208D2FCh-8208D308h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208D308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D308);
		  /* 8208D308h */ case    0:  		/* mfspr R12, LR */
		/* 8208D308h case    0:*/		regs.R12 = regs.LR;
		/* 8208D308h case    0:*/		return 0x8208D30C;
		  /* 8208D30Ch */ case    1:  		/* bl 16168 */
		/* 8208D30Ch case    1:*/		regs.LR = 0x8208D310; return 0x82091234;
		/* 8208D30Ch case    1:*/		return 0x8208D310;
		  /* 8208D310h */ case    2:  		/* addi R31, R1, -320 */
		/* 8208D310h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFEC0);
		/* 8208D310h case    2:*/		return 0x8208D314;
		  /* 8208D314h */ case    3:  		/* stwu R1, <#[R1 - 320]> */
		/* 8208D314h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEC0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEC0);
		/* 8208D314h case    3:*/		return 0x8208D318;
		  /* 8208D318h */ case    4:  		/* mr R27, R3 */
		/* 8208D318h case    4:*/		regs.R27 = regs.R3;
		/* 8208D318h case    4:*/		return 0x8208D31C;
		  /* 8208D31Ch */ case    5:  		/* stw R3, <#[R31 + 340]> */
		/* 8208D31Ch case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000154) );
		/* 8208D31Ch case    5:*/		return 0x8208D320;
		  /* 8208D320h */ case    6:  		/* lwz R11, <#[R3 + 20]> */
		/* 8208D320h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 8208D320h case    6:*/		return 0x8208D324;
		  /* 8208D324h */ case    7:  		/* li R19, 0 */
		/* 8208D324h case    7:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 8208D324h case    7:*/		return 0x8208D328;
		  /* 8208D328h */ case    8:  		/* mr R20, R5 */
		/* 8208D328h case    8:*/		regs.R20 = regs.R5;
		/* 8208D328h case    8:*/		return 0x8208D32C;
		  /* 8208D32Ch */ case    9:  		/* rlwinm. R11, R11, 0, 13, 13 */
		/* 8208D32Ch case    9:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R11,regs.R11);
		/* 8208D32Ch case    9:*/		return 0x8208D330;
		  /* 8208D330h */ case   10:  		/* stw R19, <#[R31 + 96]> */
		/* 8208D330h case   10:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R31 + 0x00000060) );
		/* 8208D330h case   10:*/		return 0x8208D334;
		  /* 8208D334h */ case   11:  		/* mr R26, R6 */
		/* 8208D334h case   11:*/		regs.R26 = regs.R6;
		/* 8208D334h case   11:*/		return 0x8208D338;
		  /* 8208D338h */ case   12:  		/* stw R5, <#[R31 + 356]> */
		/* 8208D338h case   12:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R31 + 0x00000164) );
		/* 8208D338h case   12:*/		return 0x8208D33C;
		  /* 8208D33Ch */ case   13:  		/* mr R21, R3 */
		/* 8208D33Ch case   13:*/		regs.R21 = regs.R3;
		/* 8208D33Ch case   13:*/		return 0x8208D340;
		  /* 8208D340h */ case   14:  		/* stw R6, <#[R31 + 364]> */
		/* 8208D340h case   14:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R31 + 0x0000016C) );
		/* 8208D340h case   14:*/		return 0x8208D344;
		  /* 8208D344h */ case   15:  		/* mr R30, R4 */
		/* 8208D344h case   15:*/		regs.R30 = regs.R4;
		/* 8208D344h case   15:*/		return 0x8208D348;
		  /* 8208D348h */ case   16:  		/* stw R3, <#[R31 + 84]> */
		/* 8208D348h case   16:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000054) );
		/* 8208D348h case   16:*/		return 0x8208D34C;
		  /* 8208D34Ch */ case   17:  		/* bc 12, CR0_EQ, 44 */
		/* 8208D34Ch case   17:*/		if ( regs.CR[0].eq ) { return 0x8208D378;  }
		/* 8208D34Ch case   17:*/		return 0x8208D350;
		  /* 8208D350h */ case   18:  		/* bl 1964968 */
		/* 8208D350h case   18:*/		regs.LR = 0x8208D354; return 0x8226CEF8;
		/* 8208D350h case   18:*/		return 0x8208D354;
		  /* 8208D354h */ case   19:  		/* lbz R11, <#[R21 + 379]> */
		/* 8208D354h case   19:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R21 + 0x0000017B) );
		/* 8208D354h case   19:*/		return 0x8208D358;
		  /* 8208D358h */ case   20:  		/* cmpw CR6, R11, R3 */
		/* 8208D358h case   20:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R3);
		/* 8208D358h case   20:*/		return 0x8208D35C;
		  /* 8208D35Ch */ case   21:  		/* bc 12, CR6_EQ, 28 */
		/* 8208D35Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x8208D378;  }
		/* 8208D35Ch case   21:*/		return 0x8208D360;
		  /* 8208D360h */ case   22:  		/* mr R7, R20 */
		/* 8208D360h case   22:*/		regs.R7 = regs.R20;
		/* 8208D360h case   22:*/		return 0x8208D364;
		  /* 8208D364h */ case   23:  		/* li R6, 3198 */
		/* 8208D364h case   23:*/		cpu::op::li<0>(regs,&regs.R6,0xC7E);
		/* 8208D364h case   23:*/		return 0x8208D368;
		  /* 8208D368h */ case   24:  		/* lwz R5, <#[R31 + 312]> */
		/* 8208D368h case   24:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000138) );
		/* 8208D368h case   24:*/		return 0x8208D36C;
		  /* 8208D36Ch */ case   25:  		/* mr R4, R21 */
		/* 8208D36Ch case   25:*/		regs.R4 = regs.R21;
		/* 8208D36Ch case   25:*/		return 0x8208D370;
		  /* 8208D370h */ case   26:  		/* li R3, 244 */
		/* 8208D370h case   26:*/		cpu::op::li<0>(regs,&regs.R3,0xF4);
		/* 8208D370h case   26:*/		return 0x8208D374;
		  /* 8208D374h */ case   27:  		/* bl 1966292 */
		/* 8208D374h case   27:*/		regs.LR = 0x8208D378; return 0x8226D448;
		/* 8208D374h case   27:*/		return 0x8208D378;
	}
	return 0x8208D378;
} // Block from 8208D308h-8208D378h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8208D378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D378);
		  /* 8208D378h */ case    0:  		/* cmplwi CR6, R20, 0 */
		/* 8208D378h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 8208D378h case    0:*/		return 0x8208D37C;
		  /* 8208D37Ch */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 8208D37Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8208D388;  }
		/* 8208D37Ch case    1:*/		return 0x8208D380;
		  /* 8208D380h */ case    2:  		/* li R3, 0 */
		/* 8208D380h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208D380h case    2:*/		return 0x8208D384;
		  /* 8208D384h */ case    3:  		/* b 1988 */
		/* 8208D384h case    3:*/		return 0x8208DB48;
		/* 8208D384h case    3:*/		return 0x8208D388;
	}
	return 0x8208D388;
} // Block from 8208D378h-8208D388h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208D388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D388);
		  /* 8208D388h */ case    0:  		/* lis R11, 32767 */
		/* 8208D388h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FFF);
		/* 8208D388h case    0:*/		return 0x8208D38C;
		  /* 8208D38Ch */ case    1:  		/* lwz R10, <#[R27 + 24]> */
		/* 8208D38Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000018) );
		/* 8208D38Ch case    1:*/		return 0x8208D390;
		  /* 8208D390h */ case    2:  		/* ori R11, R11, 65535 */
		/* 8208D390h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFFF);
		/* 8208D390h case    2:*/		return 0x8208D394;
		  /* 8208D394h */ case    3:  		/* or R23, R10, R30 */
		/* 8208D394h case    3:*/		cpu::op::or<0>(regs,&regs.R23,regs.R10,regs.R30);
		/* 8208D394h case    3:*/		return 0x8208D398;
		  /* 8208D398h */ case    4:  		/* cmplw CR6, R26, R11 */
		/* 8208D398h case    4:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 8208D398h case    4:*/		return 0x8208D39C;
		  /* 8208D39Ch */ case    5:  		/* bc 12, CR6_GT, -28 */
		/* 8208D39Ch case    5:*/		if ( regs.CR[6].gt ) { return 0x8208D380;  }
		/* 8208D39Ch case    5:*/		return 0x8208D3A0;
		  /* 8208D3A0h */ case    6:  		/* cmplwi CR6, R26, 0 */
		/* 8208D3A0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 8208D3A0h case    6:*/		return 0x8208D3A4;
		  /* 8208D3A4h */ case    7:  		/* li R22, 1 */
		/* 8208D3A4h case    7:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 8208D3A4h case    7:*/		return 0x8208D3A8;
		  /* 8208D3A8h */ case    8:  		/* mr R11, R26 */
		/* 8208D3A8h case    8:*/		regs.R11 = regs.R26;
		/* 8208D3A8h case    8:*/		return 0x8208D3AC;
		  /* 8208D3ACh */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 8208D3ACh case    9:*/		if ( !regs.CR[6].eq ) { return 0x8208D3B4;  }
		/* 8208D3ACh case    9:*/		return 0x8208D3B0;
		  /* 8208D3B0h */ case   10:  		/* mr R11, R22 */
		/* 8208D3B0h case   10:*/		regs.R11 = regs.R22;
		/* 8208D3B0h case   10:*/		return 0x8208D3B4;
	}
	return 0x8208D3B4;
} // Block from 8208D388h-8208D3B4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8208D3B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D3B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D3B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D3B4);
		  /* 8208D3B4h */ case    0:  		/* lwz R10, <#[R27 + 80]> */
		/* 8208D3B4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000050) );
		/* 8208D3B4h case    0:*/		return 0x8208D3B8;
		  /* 8208D3B8h */ case    1:  		/* rlwinm R9, R23, 0, 2, 23 */
		/* 8208D3B8h case    1:*/		cpu::op::rlwinm<0,0,2,23>(regs,&regs.R9,regs.R23);
		/* 8208D3B8h case    1:*/		return 0x8208D3BC;
		  /* 8208D3BCh */ case    2:  		/* rlwinm. R9, R9, 0, 23, 5 */
		/* 8208D3BCh case    2:*/		cpu::op::rlwinm<1,0,23,5>(regs,&regs.R9,regs.R9);
		/* 8208D3BCh case    2:*/		return 0x8208D3C0;
		  /* 8208D3C0h */ case    3:  		/* lwz R8, <#[R27 + 84]> */
		/* 8208D3C0h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000054) );
		/* 8208D3C0h case    3:*/		return 0x8208D3C4;
		  /* 8208D3C4h */ case    4:  		/* add R11, R10, R11 */
		/* 8208D3C4h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208D3C4h case    4:*/		return 0x8208D3C8;
		  /* 8208D3C8h */ case    5:  		/* and R24, R11, R8 */
		/* 8208D3C8h case    5:*/		cpu::op::and<0>(regs,&regs.R24,regs.R11,regs.R8);
		/* 8208D3C8h case    5:*/		return 0x8208D3CC;
		  /* 8208D3CCh */ case    6:  		/* stw R24, <#[R31 + 80]> */
		/* 8208D3CCh case    6:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000050) );
		/* 8208D3CCh case    6:*/		return 0x8208D3D0;
		  /* 8208D3D0h */ case    7:  		/* bc 4, CR0_EQ, 28 */
		/* 8208D3D0h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8208D3EC;  }
		/* 8208D3D0h case    7:*/		return 0x8208D3D4;
		  /* 8208D3D4h */ case    8:  		/* lwz R11, <#[R27 + 380]> */
		/* 8208D3D4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000017C) );
		/* 8208D3D4h case    8:*/		return 0x8208D3D8;
		  /* 8208D3D8h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 8208D3D8h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208D3D8h case    9:*/		return 0x8208D3DC;
		  /* 8208D3DCh */ case   10:  		/* bc 4, CR6_EQ, 16 */
		/* 8208D3DCh case   10:*/		if ( !regs.CR[6].eq ) { return 0x8208D3EC;  }
		/* 8208D3DCh case   10:*/		return 0x8208D3E0;
		  /* 8208D3E0h */ case   11:  		/* lbz R11, <#[R20 - 11]> */
		/* 8208D3E0h case   11:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R20 + 0xFFFFFFF5) );
		/* 8208D3E0h case   11:*/		return 0x8208D3E4;
		  /* 8208D3E4h */ case   12:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 8208D3E4h case   12:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 8208D3E4h case   12:*/		return 0x8208D3E8;
		  /* 8208D3E8h */ case   13:  		/* bc 12, CR0_EQ, 12 */
		/* 8208D3E8h case   13:*/		if ( regs.CR[0].eq ) { return 0x8208D3F4;  }
		/* 8208D3E8h case   13:*/		return 0x8208D3EC;
	}
	return 0x8208D3EC;
} // Block from 8208D3B4h-8208D3ECh (14 instructions)

//////////////////////////////////////////////////////
// Block at 8208D3ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D3EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D3EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D3EC);
		  /* 8208D3ECh */ case    0:  		/* addi R24, R24, 16 */
		/* 8208D3ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x10);
		/* 8208D3ECh case    0:*/		return 0x8208D3F0;
		  /* 8208D3F0h */ case    1:  		/* stw R24, <#[R31 + 80]> */
		/* 8208D3F0h case    1:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000050) );
		/* 8208D3F0h case    1:*/		return 0x8208D3F4;
	}
	return 0x8208D3F4;
} // Block from 8208D3ECh-8208D3F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208D3F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D3F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D3F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D3F4);
		  /* 8208D3F4h */ case    0:  		/* ori R0, R0, 0 */
		/* 8208D3F4h case    0:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 8208D3F4h case    0:*/		return 0x8208D3F8;
		  /* 8208D3F8h */ case    1:  		/* nop */
		/* 8208D3F8h case    1:*/		cpu::op::nop();
		/* 8208D3F8h case    1:*/		return 0x8208D3FC;
	}
	return 0x8208D3FC;
} // Block from 8208D3F4h-8208D3FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208D3FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D3FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D3FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D3FC);
		  /* 8208D3FCh */ case    0:  		/* rlwinm. R11, R23, 0, 31, 31 */
		/* 8208D3FCh case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R23);
		/* 8208D3FCh case    0:*/		return 0x8208D400;
		  /* 8208D400h */ case    1:  		/* bc 4, CR0_EQ, 24 */
		/* 8208D400h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8208D418;  }
		/* 8208D400h case    1:*/		return 0x8208D404;
		  /* 8208D404h */ case    2:  		/* lwz R3, <#[R27 + 1408]> */
		/* 8208D404h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x00000580) );
		/* 8208D404h case    2:*/		return 0x8208D408;
		  /* 8208D408h */ case    3:  		/* bl 1965104 */
		/* 8208D408h case    3:*/		regs.LR = 0x8208D40C; return 0x8226D038;
		/* 8208D408h case    3:*/		return 0x8208D40C;
		  /* 8208D40Ch */ case    4:  		/* xori R23, R23, 1 */
		/* 8208D40Ch case    4:*/		cpu::op::xori<0>(regs,&regs.R23,regs.R23,0x1);
		/* 8208D40Ch case    4:*/		return 0x8208D410;
		  /* 8208D410h */ case    5:  		/* stw R22, <#[R31 + 96]> */
		/* 8208D410h case    5:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000060) );
		/* 8208D410h case    5:*/		return 0x8208D414;
		  /* 8208D414h */ case    6:  		/* stw R23, <#[R31 + 348]> */
		/* 8208D414h case    6:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x0000015C) );
		/* 8208D414h case    6:*/		return 0x8208D418;
	}
	return 0x8208D418;
} // Block from 8208D3FCh-8208D418h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208D418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D418);
		  /* 8208D418h */ case    0:  		/* ori R0, R0, 0 */
		/* 8208D418h case    0:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 8208D418h case    0:*/		return 0x8208D41C;
		  /* 8208D41Ch */ case    1:  		/* nop */
		/* 8208D41Ch case    1:*/		cpu::op::nop();
		/* 8208D41Ch case    1:*/		return 0x8208D420;
		  /* 8208D420h */ case    2:  		/* nop */
		/* 8208D420h case    2:*/		cpu::op::nop();
		/* 8208D420h case    2:*/		return 0x8208D424;
	}
	return 0x8208D424;
} // Block from 8208D418h-8208D424h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208D424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D424);
		  /* 8208D424h */ case    0:  		/* addi R30, R20, -16 */
		/* 8208D424h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R20,0xFFFFFFF0);
		/* 8208D424h case    0:*/		return 0x8208D428;
		  /* 8208D428h */ case    1:  		/* stw R30, <#[R31 + 124]> */
		/* 8208D428h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000007C) );
		/* 8208D428h case    1:*/		return 0x8208D42C;
		  /* 8208D42Ch */ case    2:  		/* lbz R7, <#[R30 + 5]> */
		/* 8208D42Ch case    2:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000005) );
		/* 8208D42Ch case    2:*/		return 0x8208D430;
		  /* 8208D430h */ case    3:  		/* rlwinm. R11, R7, 0, 31, 31 */
		/* 8208D430h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R7);
		/* 8208D430h case    3:*/		return 0x8208D434;
		  /* 8208D434h */ case    4:  		/* bc 12, CR0_EQ, 1768 */
		/* 8208D434h case    4:*/		if ( regs.CR[0].eq ) { return 0x8208DB1C;  }
		/* 8208D434h case    4:*/		return 0x8208D438;
		  /* 8208D438h */ case    5:  		/* rlwinm. R6, R7, 0, 28, 28 */
		/* 8208D438h case    5:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R6,regs.R7);
		/* 8208D438h case    5:*/		return 0x8208D43C;
		  /* 8208D43Ch */ case    6:  		/* lhz R11, <#[R30]> */
		/* 8208D43Ch case    6:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8208D43Ch case    6:*/		return 0x8208D440;
		  /* 8208D440h */ case    7:  		/* bc 12, CR0_EQ, 64 */
		/* 8208D440h case    7:*/		if ( regs.CR[0].eq ) { return 0x8208D480;  }
		/* 8208D440h case    7:*/		return 0x8208D444;
		  /* 8208D444h */ case    8:  		/* addi R9, R24, 32 */
		/* 8208D444h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R24,0x20);
		/* 8208D444h case    8:*/		return 0x8208D448;
		  /* 8208D448h */ case    9:  		/* lwz R8, <#[R30 - 8]> */
		/* 8208D448h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0xFFFFFFF8) );
		/* 8208D448h case    9:*/		return 0x8208D44C;
		  /* 8208D44Ch */ case   10:  		/* addi R10, R30, -32 */
		/* 8208D44Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0xFFFFFFE0);
		/* 8208D44Ch case   10:*/		return 0x8208D450;
		  /* 8208D450h */ case   11:  		/* addis R5, R9, 1 */
		/* 8208D450h case   11:*/		cpu::op::addis<0>(regs,&regs.R5,regs.R9,0x1);
		/* 8208D450h case   11:*/		return 0x8208D454;
		  /* 8208D454h */ case   12:  		/* addi R5, R5, -1 */
		/* 8208D454h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0xFFFFFFFF);
		/* 8208D454h case   12:*/		return 0x8208D458;
		  /* 8208D458h */ case   13:  		/* mr R4, R8 */
		/* 8208D458h case   13:*/		regs.R4 = regs.R8;
		/* 8208D458h case   13:*/		return 0x8208D45C;
		  /* 8208D45Ch */ case   14:  		/* subf R8, R11, R8 */
		/* 8208D45Ch case   14:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R11,regs.R8);
		/* 8208D45Ch case   14:*/		return 0x8208D460;
		  /* 8208D460h */ case   15:  		/* stw R9, <#[R31 + 80]> */
		/* 8208D460h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000050) );
		/* 8208D460h case   15:*/		return 0x8208D464;
		  /* 8208D464h */ case   16:  		/* rlwinm R24, R5, 0, 0, 15 */
		/* 8208D464h case   16:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R24,regs.R5);
		/* 8208D464h case   16:*/		return 0x8208D468;
		  /* 8208D468h */ case   17:  		/* stw R10, <#[R31 + 92]> */
		/* 8208D468h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208D468h case   17:*/		return 0x8208D46C;
		  /* 8208D46Ch */ case   18:  		/* addi R25, R8, -48 */
		/* 8208D46Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R8,0xFFFFFFD0);
		/* 8208D46Ch case   18:*/		return 0x8208D470;
		  /* 8208D470h */ case   19:  		/* stw R10, <#[R31 + 92]> */
		/* 8208D470h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208D470h case   19:*/		return 0x8208D474;
		  /* 8208D474h */ case   20:  		/* rlwinm R29, R4, 28, 4, 31 */
		/* 8208D474h case   20:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R29,regs.R4);
		/* 8208D474h case   20:*/		return 0x8208D478;
		  /* 8208D478h */ case   21:  		/* stw R24, <#[R31 + 80]> */
		/* 8208D478h case   21:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000050) );
		/* 8208D478h case   21:*/		return 0x8208D47C;
		  /* 8208D47Ch */ case   22:  		/* b 20 */
		/* 8208D47Ch case   22:*/		return 0x8208D490;
		/* 8208D47Ch case   22:*/		return 0x8208D480;
	}
	return 0x8208D480;
} // Block from 8208D424h-8208D480h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8208D480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D480);
		  /* 8208D480h */ case    0:  		/* lbz R10, <#[R30 + 6]> */
		/* 8208D480h case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000006) );
		/* 8208D480h case    0:*/		return 0x8208D484;
	}
	return 0x8208D484;
} // Block from 8208D480h-8208D484h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208D484h
// Function 'XMemCpyStreaming_Unaligned_Writecombined_Helper'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D484);
		  /* 8208D484h */ case    0:  		/* rlwinm R9, R11, 4, 0, 31 */
		/* 8208D484h case    0:*/		cpu::op::rlwinm<0,4,0,31>(regs,&regs.R9,regs.R11);
		/* 8208D484h case    0:*/		return 0x8208D488;
		  /* 8208D488h */ case    1:  		/* mr R29, R11 */
		/* 8208D488h case    1:*/		regs.R29 = regs.R11;
		/* 8208D488h case    1:*/		return 0x8208D48C;
		  /* 8208D48Ch */ case    2:  		/* subf R25, R10, R9 */
		/* 8208D48Ch case    2:*/		cpu::op::subf<0>(regs,&regs.R25,regs.R10,regs.R9);
		/* 8208D48Ch case    2:*/		return 0x8208D490;
	}
	return 0x8208D490;
} // Block from 8208D484h-8208D490h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208D490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D490);
		  /* 8208D490h */ case    0:  		/* stw R25, <#[R31 + 92]> */
		/* 8208D490h case    0:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208D490h case    0:*/		return 0x8208D494;
		  /* 8208D494h */ case    1:  		/* rlwinm R28, R24, 28, 4, 31 */
		/* 8208D494h case    1:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R28,regs.R24);
		/* 8208D494h case    1:*/		return 0x8208D498;
		  /* 8208D498h */ case    2:  		/* stw R28, <#[R31 + 100]> */
		/* 8208D498h case    2:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000064) );
		/* 8208D498h case    2:*/		return 0x8208D49C;
		  /* 8208D49Ch */ case    3:  		/* cmplw CR6, R28, R29 */
		/* 8208D49Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R29);
		/* 8208D49Ch case    3:*/		return 0x8208D4A0;
		  /* 8208D4A0h */ case    4:  		/* bc 12, CR6_GT, 1100 */
		/* 8208D4A0h case    4:*/		if ( regs.CR[6].gt ) { return 0x8208D8EC;  }
		/* 8208D4A0h case    4:*/		return 0x8208D4A4;
		  /* 8208D4A4h */ case    5:  		/* addi R10, R28, 1 */
		/* 8208D4A4h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0x1);
		/* 8208D4A4h case    5:*/		return 0x8208D4A8;
		  /* 8208D4A8h */ case    6:  		/* cmplw CR6, R10, R29 */
		/* 8208D4A8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 8208D4A8h case    6:*/		return 0x8208D4AC;
		  /* 8208D4ACh */ case    7:  		/* bc 4, CR6_EQ, 20 */
		/* 8208D4ACh case    7:*/		if ( !regs.CR[6].eq ) { return 0x8208D4C0;  }
		/* 8208D4ACh case    7:*/		return 0x8208D4B0;
		  /* 8208D4B0h */ case    8:  		/* mr R28, R10 */
		/* 8208D4B0h case    8:*/		regs.R28 = regs.R10;
		/* 8208D4B0h case    8:*/		return 0x8208D4B4;
		  /* 8208D4B4h */ case    9:  		/* addi R24, R24, 16 */
		/* 8208D4B4h case    9:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x10);
		/* 8208D4B4h case    9:*/		return 0x8208D4B8;
		  /* 8208D4B8h */ case   10:  		/* stw R10, <#[R31 + 100]> */
		/* 8208D4B8h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000064) );
		/* 8208D4B8h case   10:*/		return 0x8208D4BC;
		  /* 8208D4BCh */ case   11:  		/* stw R24, <#[R31 + 80]> */
		/* 8208D4BCh case   11:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000050) );
		/* 8208D4BCh case   11:*/		return 0x8208D4C0;
	}
	return 0x8208D4C0;
} // Block from 8208D490h-8208D4C0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8208D4C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D4C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D4C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D4C0);
		  /* 8208D4C0h */ case    0:  		/* cmplwi CR6, R6, 0 */
		/* 8208D4C0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8208D4C0h case    0:*/		return 0x8208D4C4;
		  /* 8208D4C4h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 8208D4C4h case    1:*/		if ( regs.CR[6].eq ) { return 0x8208D4DC;  }
		/* 8208D4C4h case    1:*/		return 0x8208D4C8;
		  /* 8208D4C8h */ case    2:  		/* subf R11, R26, R24 */
		/* 8208D4C8h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R26,regs.R24);
		/* 8208D4C8h case    2:*/		return 0x8208D4CC;
		  /* 8208D4CCh */ case    3:  		/* addis R11, R11, 1 */
		/* 8208D4CCh case    3:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8208D4CCh case    3:*/		return 0x8208D4D0;
		  /* 8208D4D0h */ case    4:  		/* addi R11, R11, -48 */
		/* 8208D4D0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFD0);
		/* 8208D4D0h case    4:*/		return 0x8208D4D4;
		  /* 8208D4D4h */ case    5:  		/* sth R11, <#[R30]> */
		/* 8208D4D4h case    5:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8208D4D4h case    5:*/		return 0x8208D4D8;
		  /* 8208D4D8h */ case    6:  		/* b 68 */
		/* 8208D4D8h case    6:*/		return 0x8208D51C;
		/* 8208D4D8h case    6:*/		return 0x8208D4DC;
	}
	return 0x8208D4DC;
} // Block from 8208D4C0h-8208D4DCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208D4DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D4DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D4DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D4DC);
		  /* 8208D4DCh */ case    0:  		/* rlwinm. R10, R7, 0, 30, 30 */
		/* 8208D4DCh case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R7);
		/* 8208D4DCh case    0:*/		return 0x8208D4E0;
		  /* 8208D4E0h */ case    1:  		/* bc 12, CR0_EQ, 52 */
		/* 8208D4E0h case    1:*/		if ( regs.CR[0].eq ) { return 0x8208D514;  }
		/* 8208D4E0h case    1:*/		return 0x8208D4E4;
		  /* 8208D4E4h */ case    2:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 8208D4E4h case    2:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 8208D4E4h case    2:*/		return 0x8208D4E8;
		  /* 8208D4E8h */ case    3:  		/* rlwinm R9, R28, 4, 0, 27 */
		/* 8208D4E8h case    3:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R9,regs.R28);
		/* 8208D4E8h case    3:*/		return 0x8208D4EC;
		  /* 8208D4ECh */ case    4:  		/* add R10, R11, R30 */
		/* 8208D4ECh case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R30);
		/* 8208D4ECh case    4:*/		return 0x8208D4F0;
		  /* 8208D4F0h */ case    5:  		/* add R11, R9, R30 */
		/* 8208D4F0h case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R30);
		/* 8208D4F0h case    5:*/		return 0x8208D4F4;
		  /* 8208D4F4h */ case    6:  		/* subf R9, R26, R24 */
		/* 8208D4F4h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R26,regs.R24);
		/* 8208D4F4h case    6:*/		return 0x8208D4F8;
		  /* 8208D4F8h */ case    7:  		/* addi R11, R11, -16 */
		/* 8208D4F8h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFF0);
		/* 8208D4F8h case    7:*/		return 0x8208D4FC;
		  /* 8208D4FCh */ case    8:  		/* ld R8, <#[R10 - 16]> */
		/* 8208D4FCh case    8:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R10 + 0xFFFFFFF0) );
		/* 8208D4FCh case    8:*/		return 0x8208D500;
		  /* 8208D500h */ case    9:  		/* std R8, <#[R11]> */
		/* 8208D500h case    9:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8208D500h case    9:*/		return 0x8208D504;
		  /* 8208D504h */ case   10:  		/* ld R10, <#[R10 - 8]> */
		/* 8208D504h case   10:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R10 + 0xFFFFFFF8) );
		/* 8208D504h case   10:*/		return 0x8208D508;
		  /* 8208D508h */ case   11:  		/* std R10, <#[R11 + 8]> */
		/* 8208D508h case   11:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8208D508h case   11:*/		return 0x8208D50C;
		  /* 8208D50Ch */ case   12:  		/* stb R9, <#[R30 + 6]> */
		/* 8208D50Ch case   12:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R30 + 0x00000006) );
		/* 8208D50Ch case   12:*/		return 0x8208D510;
		  /* 8208D510h */ case   13:  		/* b 12 */
		/* 8208D510h case   13:*/		return 0x8208D51C;
		/* 8208D510h case   13:*/		return 0x8208D514;
	}
	return 0x8208D514;
} // Block from 8208D4DCh-8208D514h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8208D514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D514);
		  /* 8208D514h */ case    0:  		/* subf R11, R26, R24 */
		/* 8208D514h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R26,regs.R24);
		/* 8208D514h case    0:*/		return 0x8208D518;
		  /* 8208D518h */ case    1:  		/* stb R11, <#[R30 + 6]> */
		/* 8208D518h case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000006) );
		/* 8208D518h case    1:*/		return 0x8208D51C;
	}
	return 0x8208D51C;
} // Block from 8208D514h-8208D51Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208D51Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D51C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D51C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D51C);
		  /* 8208D51Ch */ case    0:  		/* cmplw CR6, R26, R25 */
		/* 8208D51Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R25);
		/* 8208D51Ch case    0:*/		return 0x8208D520;
		  /* 8208D520h */ case    1:  		/* bc 4, CR6_GT, 28 */
		/* 8208D520h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8208D53C;  }
		/* 8208D520h case    1:*/		return 0x8208D524;
		  /* 8208D524h */ case    2:  		/* rlwinm. R11, R23, 0, 28, 28 */
		/* 8208D524h case    2:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R23);
		/* 8208D524h case    2:*/		return 0x8208D528;
		  /* 8208D528h */ case    3:  		/* bc 12, CR0_EQ, 20 */
		/* 8208D528h case    3:*/		if ( regs.CR[0].eq ) { return 0x8208D53C;  }
		/* 8208D528h case    3:*/		return 0x8208D52C;
		  /* 8208D52Ch */ case    4:  		/* subf R5, R25, R26 */
		/* 8208D52Ch case    4:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R25,regs.R26);
		/* 8208D52Ch case    4:*/		return 0x8208D530;
		  /* 8208D530h */ case    5:  		/* li R4, 0 */
		/* 8208D530h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208D530h case    5:*/		return 0x8208D534;
		  /* 8208D534h */ case    6:  		/* add R3, R25, R20 */
		/* 8208D534h case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R25,regs.R20);
		/* 8208D534h case    6:*/		return 0x8208D538;
		  /* 8208D538h */ case    7:  		/* bl 15880 */
		/* 8208D538h case    7:*/		regs.LR = 0x8208D53C; return 0x82091340;
		/* 8208D538h case    7:*/		return 0x8208D53C;
	}
	return 0x8208D53C;
} // Block from 8208D51Ch-8208D53Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8208D53Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D53C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D53C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D53C);
		  /* 8208D53Ch */ case    0:  		/* cmplw CR6, R28, R29 */
		/* 8208D53Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R29);
		/* 8208D53Ch case    0:*/		return 0x8208D540;
		  /* 8208D540h */ case    1:  		/* bc 12, CR6_EQ, 1448 */
		/* 8208D540h case    1:*/		if ( regs.CR[6].eq ) { return 0x8208DAE8;  }
		/* 8208D540h case    1:*/		return 0x8208D544;
		  /* 8208D544h */ case    2:  		/* lbz R11, <#[R30 + 5]> */
		/* 8208D544h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208D544h case    2:*/		return 0x8208D548;
		  /* 8208D548h */ case    3:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8208D548h case    3:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8208D548h case    3:*/		return 0x8208D54C;
		  /* 8208D54Ch */ case    4:  		/* rlwinm. R10, R11, 0, 28, 28 */
		/* 8208D54Ch case    4:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R10,regs.R11);
		/* 8208D54Ch case    4:*/		return 0x8208D550;
		  /* 8208D550h */ case    5:  		/* bc 12, CR0_EQ, 80 */
		/* 8208D550h case    5:*/		if ( regs.CR[0].eq ) { return 0x8208D5A0;  }
		/* 8208D550h case    5:*/		return 0x8208D554;
		  /* 8208D554h */ case    6:  		/* addi R30, R30, -32 */
		/* 8208D554h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0xFFFFFFE0);
		/* 8208D554h case    6:*/		return 0x8208D558;
		  /* 8208D558h */ case    7:  		/* rlwinm R11, R29, 4, 0, 27 */
		/* 8208D558h case    7:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R29);
		/* 8208D558h case    7:*/		return 0x8208D55C;
		  /* 8208D55Ch */ case    8:  		/* add R10, R30, R24 */
		/* 8208D55Ch case    8:*/		cpu::op::add<0>(regs,&regs.R10,regs.R30,regs.R24);
		/* 8208D55Ch case    8:*/		return 0x8208D560;
		  /* 8208D560h */ case    9:  		/* subf R11, R24, R11 */
		/* 8208D560h case    9:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R24,regs.R11);
		/* 8208D560h case    9:*/		return 0x8208D564;
		  /* 8208D564h */ case   10:  		/* stw R10, <#[R31 + 104]> */
		/* 8208D564h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000068) );
		/* 8208D564h case   10:*/		return 0x8208D568;
		  /* 8208D568h */ case   11:  		/* lis R5, 0 */
		/* 8208D568h case   11:*/		cpu::op::lis<0>(regs,&regs.R5,0x0);
		/* 8208D568h case   11:*/		return 0x8208D56C;
		  /* 8208D56Ch */ case   12:  		/* stw R11, <#[R31 + 88]> */
		/* 8208D56Ch case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 8208D56Ch case   12:*/		return 0x8208D570;
		  /* 8208D570h */ case   13:  		/* addi R4, R31, 88 */
		/* 8208D570h case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x58);
		/* 8208D570h case   13:*/		return 0x8208D574;
		  /* 8208D574h */ case   14:  		/* ori R5, R5, 32768 */
		/* 8208D574h case   14:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x8000);
		/* 8208D574h case   14:*/		return 0x8208D578;
		  /* 8208D578h */ case   15:  		/* lwz R6, <#[R27 + 1424]> */
		/* 8208D578h case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R27 + 0x00000590) );
		/* 8208D578h case   15:*/		return 0x8208D57C;
		  /* 8208D57Ch */ case   16:  		/* addi R3, R31, 104 */
		/* 8208D57Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x68);
		/* 8208D57Ch case   16:*/		return 0x8208D580;
		  /* 8208D580h */ case   17:  		/* bl 1965784 */
		/* 8208D580h case   17:*/		regs.LR = 0x8208D584; return 0x8226D458;
		/* 8208D580h case   17:*/		return 0x8208D584;
		  /* 8208D584h */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 8208D584h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208D584h case   18:*/		return 0x8208D588;
		  /* 8208D588h */ case   19:  		/* bc 12, CR0_LT, 1376 */
		/* 8208D588h case   19:*/		if ( regs.CR[0].lt ) { return 0x8208DAE8;  }
		/* 8208D588h case   19:*/		return 0x8208D58C;
		  /* 8208D58Ch */ case   20:  		/* lwz R11, <#[R30 + 24]> */
		/* 8208D58Ch case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 8208D58Ch case   20:*/		return 0x8208D590;
		  /* 8208D590h */ case   21:  		/* lwz R10, <#[R31 + 88]> */
		/* 8208D590h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000058) );
		/* 8208D590h case   21:*/		return 0x8208D594;
		  /* 8208D594h */ case   22:  		/* subf R11, R10, R11 */
		/* 8208D594h case   22:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208D594h case   22:*/		return 0x8208D598;
		  /* 8208D598h */ case   23:  		/* stw R11, <#[R30 + 24]> */
		/* 8208D598h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 8208D598h case   23:*/		return 0x8208D59C;
		  /* 8208D59Ch */ case   24:  		/* b 1356 */
		/* 8208D59Ch case   24:*/		return 0x8208DAE8;
		/* 8208D59Ch case   24:*/		return 0x8208D5A0;
	}
	return 0x8208D5A0;
} // Block from 8208D53Ch-8208D5A0h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8208D5A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D5A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D5A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D5A0);
		  /* 8208D5A0h */ case    0:  		/* rlwinm R10, R28, 4, 0, 27 */
		/* 8208D5A0h case    0:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R28);
		/* 8208D5A0h case    0:*/		return 0x8208D5A4;
		  /* 8208D5A4h */ case    1:  		/* rlwinm R9, R28, 0, 16, 31 */
		/* 8208D5A4h case    1:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R28);
		/* 8208D5A4h case    1:*/		return 0x8208D5A8;
		  /* 8208D5A8h */ case    2:  		/* add R29, R10, R30 */
		/* 8208D5A8h case    2:*/		cpu::op::add<0>(regs,&regs.R29,regs.R10,regs.R30);
		/* 8208D5A8h case    2:*/		return 0x8208D5AC;
		  /* 8208D5ACh */ case    3:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 8208D5ACh case    3:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 8208D5ACh case    3:*/		return 0x8208D5B0;
		  /* 8208D5B0h */ case    4:  		/* stb R11, <#[R29 + 5]> */
		/* 8208D5B0h case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R29 + 0x00000005) );
		/* 8208D5B0h case    4:*/		return 0x8208D5B4;
		  /* 8208D5B4h */ case    5:  		/* sth R9, <#[R29 + 2]> */
		/* 8208D5B4h case    5:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R29 + 0x00000002) );
		/* 8208D5B4h case    5:*/		return 0x8208D5B8;
		  /* 8208D5B8h */ case    6:  		/* lbz R11, <#[R30 + 4]> */
		/* 8208D5B8h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8208D5B8h case    6:*/		return 0x8208D5BC;
		  /* 8208D5BCh */ case    7:  		/* stb R11, <#[R29 + 4]> */
		/* 8208D5BCh case    7:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8208D5BCh case    7:*/		return 0x8208D5C0;
		  /* 8208D5C0h */ case    8:  		/* lhz R11, <#[R30]> */
		/* 8208D5C0h case    8:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8208D5C0h case    8:*/		return 0x8208D5C4;
		  /* 8208D5C4h */ case    9:  		/* subf R28, R28, R11 */
		/* 8208D5C4h case    9:*/		cpu::op::subf<0>(regs,&regs.R28,regs.R28,regs.R11);
		/* 8208D5C4h case    9:*/		return 0x8208D5C8;
		  /* 8208D5C8h */ case   10:  		/* sth R9, <#[R30]> */
		/* 8208D5C8h case   10:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 8208D5C8h case   10:*/		return 0x8208D5CC;
		  /* 8208D5CCh */ case   11:  		/* lbz R11, <#[R30 + 5]> */
		/* 8208D5CCh case   11:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208D5CCh case   11:*/		return 0x8208D5D0;
		  /* 8208D5D0h */ case   12:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 8208D5D0h case   12:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8208D5D0h case   12:*/		return 0x8208D5D4;
		  /* 8208D5D4h */ case   13:  		/* rlwinm R11, R11, 0, 28, 26 */
		/* 8208D5D4h case   13:*/		cpu::op::rlwinm<0,0,28,26>(regs,&regs.R11,regs.R11);
		/* 8208D5D4h case   13:*/		return 0x8208D5D8;
		  /* 8208D5D8h */ case   14:  		/* stb R11, <#[R30 + 5]> */
		/* 8208D5D8h case   14:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208D5D8h case   14:*/		return 0x8208D5DC;
		  /* 8208D5DCh */ case   15:  		/* bc 12, CR0_EQ, 120 */
		/* 8208D5DCh case   15:*/		if ( regs.CR[0].eq ) { return 0x8208D654;  }
		/* 8208D5DCh case   15:*/		return 0x8208D5E0;
		  /* 8208D5E0h */ case   16:  		/* lbz R11, <#[R29 + 4]> */
		/* 8208D5E0h case   16:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8208D5E0h case   16:*/		return 0x8208D5E4;
		  /* 8208D5E4h */ case   17:  		/* addi R10, R11, 24 */
		/* 8208D5E4h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x18);
		/* 8208D5E4h case   17:*/		return 0x8208D5E8;
		  /* 8208D5E8h */ case   18:  		/* rlwinm R11, R28, 0, 16, 31 */
		/* 8208D5E8h case   18:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R28);
		/* 8208D5E8h case   18:*/		return 0x8208D5EC;
		  /* 8208D5ECh */ case   19:  		/* rlwinm R9, R10, 2, 0, 29 */
		/* 8208D5ECh case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R10);
		/* 8208D5ECh case   19:*/		return 0x8208D5F0;
		  /* 8208D5F0h */ case   20:  		/* mr R10, R11 */
		/* 8208D5F0h case   20:*/		regs.R10 = regs.R11;
		/* 8208D5F0h case   20:*/		return 0x8208D5F4;
		  /* 8208D5F4h */ case   21:  		/* cmplwi CR6, R11, 128 */
		/* 8208D5F4h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 8208D5F4h case   21:*/		return 0x8208D5F8;
		  /* 8208D5F8h */ case   22:  		/* lwzx R9, <#[R9 + R27]> */
		/* 8208D5F8h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R27 + 0x00000000) );
		/* 8208D5F8h case   22:*/		return 0x8208D5FC;
		  /* 8208D5FCh */ case   23:  		/* stw R29, <#[R9 + 64]> */
		/* 8208D5FCh case   23:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R9 + 0x00000040) );
		/* 8208D5FCh case   23:*/		return 0x8208D600;
		  /* 8208D600h */ case   24:  		/* sth R11, <#[R29]> */
		/* 8208D600h case   24:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8208D600h case   24:*/		return 0x8208D604;
		  /* 8208D604h */ case   25:  		/* lbz R11, <#[R29 + 5]> */
		/* 8208D604h case   25:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000005) );
		/* 8208D604h case   25:*/		return 0x8208D608;
		  /* 8208D608h */ case   26:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 8208D608h case   26:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 8208D608h case   26:*/		return 0x8208D60C;
		  /* 8208D60Ch */ case   27:  		/* stb R11, <#[R29 + 5]> */
		/* 8208D60Ch case   27:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R29 + 0x00000005) );
		/* 8208D60Ch case   27:*/		return 0x8208D610;
		  /* 8208D610h */ case   28:  		/* bc 4, CR6_LT, 12 */
		/* 8208D610h case   28:*/		if ( !regs.CR[6].lt ) { return 0x8208D61C;  }
		/* 8208D610h case   28:*/		return 0x8208D614;
		  /* 8208D614h */ case   29:  		/* addi R11, R10, 48 */
		/* 8208D614h case   29:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x30);
		/* 8208D614h case   29:*/		return 0x8208D618;
		  /* 8208D618h */ case   30:  		/* b 120 */
		/* 8208D618h case   30:*/		return 0x8208D690;
		/* 8208D618h case   30:*/		return 0x8208D61C;
	}
	return 0x8208D61C;
} // Block from 8208D5A0h-8208D61Ch (31 instructions)

//////////////////////////////////////////////////////
// Block at 8208D61Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D61C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D61C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D61C);
		  /* 8208D61Ch */ case    0:  		/* lwz R11, <#[R27 + 384]> */
		/* 8208D61Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000180) );
		/* 8208D61Ch case    0:*/		return 0x8208D620;
		  /* 8208D620h */ case    1:  		/* addi R9, R27, 384 */
		/* 8208D620h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R27,0x180);
		/* 8208D620h case    1:*/		return 0x8208D624;
		  /* 8208D624h */ case    2:  		/* stw R11, <#[R31 + 108]> */
		/* 8208D624h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 8208D624h case    2:*/		return 0x8208D628;
		  /* 8208D628h */ case    3:  		/* cmplw CR6, R9, R11 */
		/* 8208D628h case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8208D628h case    3:*/		return 0x8208D62C;
		  /* 8208D62Ch */ case    4:  		/* bc 12, CR6_EQ, 156 */
		/* 8208D62Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x8208D6C8;  }
		/* 8208D62Ch case    4:*/		return 0x8208D630;
		  /* 8208D630h */ case    5:  		/* lhz R8, <#[R11 - 8]> */
		/* 8208D630h case    5:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 8208D630h case    5:*/		return 0x8208D634;
		  /* 8208D634h */ case    6:  		/* addi R7, R11, -8 */
		/* 8208D634h case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFF8);
		/* 8208D634h case    6:*/		return 0x8208D638;
		  /* 8208D638h */ case    7:  		/* stw R7, <#[R31 + 92]> */
		/* 8208D638h case    7:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208D638h case    7:*/		return 0x8208D63C;
		  /* 8208D63Ch */ case    8:  		/* cmplw CR6, R10, R8 */
		/* 8208D63Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8208D63Ch case    8:*/		return 0x8208D640;
		  /* 8208D640h */ case    9:  		/* bc 4, CR6_GT, 136 */
		/* 8208D640h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8208D6C8;  }
		/* 8208D640h case    9:*/		return 0x8208D644;
		  /* 8208D644h */ case   10:  		/* lwz R11, <#[R11]> */
		/* 8208D644h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8208D644h case   10:*/		return 0x8208D648;
		  /* 8208D648h */ case   11:  		/* stw R11, <#[R31 + 108]> */
		/* 8208D648h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 8208D648h case   11:*/		return 0x8208D64C;
		  /* 8208D64Ch */ case   12:  		/* nop */
		/* 8208D64Ch case   12:*/		cpu::op::nop();
		/* 8208D64Ch case   12:*/		return 0x8208D650;
		  /* 8208D650h */ case   13:  		/* b -40 */
		/* 8208D650h case   13:*/		return 0x8208D628;
		/* 8208D650h case   13:*/		return 0x8208D654;
	}
	return 0x8208D654;
} // Block from 8208D61Ch-8208D654h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8208D654h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D654( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D654) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D654);
		  /* 8208D654h */ case    0:  		/* rlwinm R11, R28, 4, 0, 27 */
		/* 8208D654h case    0:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R28);
		/* 8208D654h case    0:*/		return 0x8208D658;
		  /* 8208D658h */ case    1:  		/* add R30, R11, R29 */
		/* 8208D658h case    1:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R29);
		/* 8208D658h case    1:*/		return 0x8208D65C;
		  /* 8208D65Ch */ case    2:  		/* lbz R11, <#[R30 + 5]> */
		/* 8208D65Ch case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208D65Ch case    2:*/		return 0x8208D660;
		  /* 8208D660h */ case    3:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8208D660h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8208D660h case    3:*/		return 0x8208D664;
		  /* 8208D664h */ case    4:  		/* bc 12, CR0_EQ, 192 */
		/* 8208D664h case    4:*/		if ( regs.CR[0].eq ) { return 0x8208D724;  }
		/* 8208D664h case    4:*/		return 0x8208D668;
		  /* 8208D668h */ case    5:  		/* rlwinm R11, R28, 0, 16, 31 */
		/* 8208D668h case    5:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R28);
		/* 8208D668h case    5:*/		return 0x8208D66C;
		  /* 8208D66Ch */ case    6:  		/* sth R11, <#[R29]> */
		/* 8208D66Ch case    6:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8208D66Ch case    6:*/		return 0x8208D670;
		  /* 8208D670h */ case    7:  		/* mr R9, R11 */
		/* 8208D670h case    7:*/		regs.R9 = regs.R11;
		/* 8208D670h case    7:*/		return 0x8208D674;
		  /* 8208D674h */ case    8:  		/* sth R11, <#[R30 + 2]> */
		/* 8208D674h case    8:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R30 + 0x00000002) );
		/* 8208D674h case    8:*/		return 0x8208D678;
		  /* 8208D678h */ case    9:  		/* cmplwi CR6, R11, 128 */
		/* 8208D678h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 8208D678h case    9:*/		return 0x8208D67C;
		  /* 8208D67Ch */ case   10:  		/* lbz R11, <#[R29 + 5]> */
		/* 8208D67Ch case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000005) );
		/* 8208D67Ch case   10:*/		return 0x8208D680;
		  /* 8208D680h */ case   11:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 8208D680h case   11:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 8208D680h case   11:*/		return 0x8208D684;
		  /* 8208D684h */ case   12:  		/* stb R11, <#[R29 + 5]> */
		/* 8208D684h case   12:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R29 + 0x00000005) );
		/* 8208D684h case   12:*/		return 0x8208D688;
		  /* 8208D688h */ case   13:  		/* bc 4, CR6_LT, 100 */
		/* 8208D688h case   13:*/		if ( !regs.CR[6].lt ) { return 0x8208D6EC;  }
		/* 8208D688h case   13:*/		return 0x8208D68C;
		  /* 8208D68Ch */ case   14:  		/* addi R11, R9, 48 */
		/* 8208D68Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x30);
		/* 8208D68Ch case   14:*/		return 0x8208D690;
	}
	return 0x8208D690;
} // Block from 8208D654h-8208D690h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8208D690h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D690);
		  /* 8208D690h */ case    0:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8208D690h case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8208D690h case    0:*/		return 0x8208D694;
		  /* 8208D694h */ case    1:  		/* add R11, R11, R27 */
		/* 8208D694h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 8208D694h case    1:*/		return 0x8208D698;
		  /* 8208D698h */ case    2:  		/* lwz R10, <#[R11]> */
		/* 8208D698h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208D698h case    2:*/		return 0x8208D69C;
		  /* 8208D69Ch */ case    3:  		/* cmplw CR6, R10, R11 */
		/* 8208D69Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208D69Ch case    3:*/		return 0x8208D6A0;
		  /* 8208D6A0h */ case    4:  		/* bc 4, CR6_EQ, 40 */
		/* 8208D6A0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8208D6C8;  }
		/* 8208D6A0h case    4:*/		return 0x8208D6A4;
		  /* 8208D6A4h */ case    5:  		/* lhz R9, <#[R29]> */
		/* 8208D6A4h case    5:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000000) );
		/* 8208D6A4h case    5:*/		return 0x8208D6A8;
		  /* 8208D6A8h */ case    6:  		/* rlwinm R10, R9, 27, 5, 31 */
		/* 8208D6A8h case    6:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R9);
		/* 8208D6A8h case    6:*/		return 0x8208D6AC;
		  /* 8208D6ACh */ case    7:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 8208D6ACh case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8208D6ACh case    7:*/		return 0x8208D6B0;
		  /* 8208D6B0h */ case    8:  		/* addi R10, R10, 88 */
		/* 8208D6B0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x58);
		/* 8208D6B0h case    8:*/		return 0x8208D6B4;
		  /* 8208D6B4h */ case    9:  		/* slw R9, R22, R9 */
		/* 8208D6B4h case    9:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R22,regs.R9);
		/* 8208D6B4h case    9:*/		return 0x8208D6B8;
		  /* 8208D6B8h */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8208D6B8h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8208D6B8h case   10:*/		return 0x8208D6BC;
		  /* 8208D6BCh */ case   11:  		/* lwzx R8, <#[R10 + R27]> */
		/* 8208D6BCh case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 8208D6BCh case   11:*/		return 0x8208D6C0;
		  /* 8208D6C0h */ case   12:  		/* or R9, R8, R9 */
		/* 8208D6C0h case   12:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8208D6C0h case   12:*/		return 0x8208D6C4;
		  /* 8208D6C4h */ case   13:  		/* stwx R9, <#[R10 + R27]> */
		/* 8208D6C4h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 8208D6C4h case   13:*/		return 0x8208D6C8;
	}
	return 0x8208D6C8;
} // Block from 8208D690h-8208D6C8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8208D6C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D6C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D6C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D6C8);
		  /* 8208D6C8h */ case    0:  		/* lwz R9, <#[R11 + 4]> */
		/* 8208D6C8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8208D6C8h case    0:*/		return 0x8208D6CC;
		  /* 8208D6CCh */ case    1:  		/* addi R10, R29, 8 */
		/* 8208D6CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0x8);
		/* 8208D6CCh case    1:*/		return 0x8208D6D0;
		  /* 8208D6D0h */ case    2:  		/* stw R11, <#[R29 + 8]> */
		/* 8208D6D0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8208D6D0h case    2:*/		return 0x8208D6D4;
		  /* 8208D6D4h */ case    3:  		/* stw R9, <#[R29 + 12]> */
		/* 8208D6D4h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R29 + 0x0000000C) );
		/* 8208D6D4h case    3:*/		return 0x8208D6D8;
		  /* 8208D6D8h */ case    4:  		/* stw R10, <#[R9]> */
		/* 8208D6D8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8208D6D8h case    4:*/		return 0x8208D6DC;
		  /* 8208D6DCh */ case    5:  		/* stw R10, <#[R11 + 4]> */
		/* 8208D6DCh case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8208D6DCh case    5:*/		return 0x8208D6E0;
		  /* 8208D6E0h */ case    6:  		/* lwz R11, <#[R21 + 48]> */
		/* 8208D6E0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000030) );
		/* 8208D6E0h case    6:*/		return 0x8208D6E4;
		  /* 8208D6E4h */ case    7:  		/* add R11, R28, R11 */
		/* 8208D6E4h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 8208D6E4h case    7:*/		return 0x8208D6E8;
		  /* 8208D6E8h */ case    8:  		/* b 492 */
		/* 8208D6E8h case    8:*/		return 0x8208D8D4;
		/* 8208D6E8h case    8:*/		return 0x8208D6EC;
	}
	return 0x8208D6EC;
} // Block from 8208D6C8h-8208D6ECh (9 instructions)

//////////////////////////////////////////////////////
// Block at 8208D6ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D6EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D6EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D6EC);
		  /* 8208D6ECh */ case    0:  		/* lwz R11, <#[R27 + 384]> */
		/* 8208D6ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000180) );
		/* 8208D6ECh case    0:*/		return 0x8208D6F0;
		  /* 8208D6F0h */ case    1:  		/* addi R10, R27, 384 */
		/* 8208D6F0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0x180);
		/* 8208D6F0h case    1:*/		return 0x8208D6F4;
		  /* 8208D6F4h */ case    2:  		/* stw R11, <#[R31 + 112]> */
		/* 8208D6F4h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 8208D6F4h case    2:*/		return 0x8208D6F8;
		  /* 8208D6F8h */ case    3:  		/* cmplw CR6, R10, R11 */
		/* 8208D6F8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208D6F8h case    3:*/		return 0x8208D6FC;
		  /* 8208D6FCh */ case    4:  		/* bc 12, CR6_EQ, -52 */
		/* 8208D6FCh case    4:*/		if ( regs.CR[6].eq ) { return 0x8208D6C8;  }
		/* 8208D6FCh case    4:*/		return 0x8208D700;
		  /* 8208D700h */ case    5:  		/* lhz R8, <#[R11 - 8]> */
		/* 8208D700h case    5:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 8208D700h case    5:*/		return 0x8208D704;
		  /* 8208D704h */ case    6:  		/* addi R7, R11, -8 */
		/* 8208D704h case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFF8);
		/* 8208D704h case    6:*/		return 0x8208D708;
		  /* 8208D708h */ case    7:  		/* stw R7, <#[R31 + 92]> */
		/* 8208D708h case    7:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208D708h case    7:*/		return 0x8208D70C;
		  /* 8208D70Ch */ case    8:  		/* cmplw CR6, R9, R8 */
		/* 8208D70Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 8208D70Ch case    8:*/		return 0x8208D710;
		  /* 8208D710h */ case    9:  		/* bc 4, CR6_GT, -72 */
		/* 8208D710h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8208D6C8;  }
		/* 8208D710h case    9:*/		return 0x8208D714;
		  /* 8208D714h */ case   10:  		/* lwz R11, <#[R11]> */
		/* 8208D714h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8208D714h case   10:*/		return 0x8208D718;
		  /* 8208D718h */ case   11:  		/* stw R11, <#[R31 + 112]> */
		/* 8208D718h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 8208D718h case   11:*/		return 0x8208D71C;
		  /* 8208D71Ch */ case   12:  		/* nop */
		/* 8208D71Ch case   12:*/		cpu::op::nop();
		/* 8208D71Ch case   12:*/		return 0x8208D720;
		  /* 8208D720h */ case   13:  		/* b -40 */
		/* 8208D720h case   13:*/		return 0x8208D6F8;
		/* 8208D720h case   13:*/		return 0x8208D724;
	}
	return 0x8208D724;
} // Block from 8208D6ECh-8208D724h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8208D724h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D724( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D724) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D724);
		  /* 8208D724h */ case    0:  		/* stb R11, <#[R29 + 5]> */
		/* 8208D724h case    0:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R29 + 0x00000005) );
		/* 8208D724h case    0:*/		return 0x8208D728;
		  /* 8208D728h */ case    1:  		/* addi R9, R30, 8 */
		/* 8208D728h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0x8);
		/* 8208D728h case    1:*/		return 0x8208D72C;
		  /* 8208D72Ch */ case    2:  		/* lwz R11, <#[R30 + 12]> */
		/* 8208D72Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8208D72Ch case    2:*/		return 0x8208D730;
		  /* 8208D730h */ case    3:  		/* lwz R10, <#[R30 + 8]> */
		/* 8208D730h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 8208D730h case    3:*/		return 0x8208D734;
		  /* 8208D734h */ case    4:  		/* lwz R8, <#[R11]> */
		/* 8208D734h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8208D734h case    4:*/		return 0x8208D738;
		  /* 8208D738h */ case    5:  		/* lwz R7, <#[R10 + 4]> */
		/* 8208D738h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 8208D738h case    5:*/		return 0x8208D73C;
		  /* 8208D73Ch */ case    6:  		/* cmplw CR6, R8, R7 */
		/* 8208D73Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 8208D73Ch case    6:*/		return 0x8208D740;
		  /* 8208D740h */ case    7:  		/* bc 4, CR6_EQ, 72 */
		/* 8208D740h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8208D788;  }
		/* 8208D740h case    7:*/		return 0x8208D744;
		  /* 8208D744h */ case    8:  		/* cmplw CR6, R8, R9 */
		/* 8208D744h case    8:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8208D744h case    8:*/		return 0x8208D748;
		  /* 8208D748h */ case    9:  		/* bc 4, CR6_EQ, 64 */
		/* 8208D748h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8208D788;  }
		/* 8208D748h case    9:*/		return 0x8208D74C;
		  /* 8208D74Ch */ case   10:  		/* stw R10, <#[R11]> */
		/* 8208D74Ch case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208D74Ch case   10:*/		return 0x8208D750;
		  /* 8208D750h */ case   11:  		/* cmplw CR6, R10, R11 */
		/* 8208D750h case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208D750h case   11:*/		return 0x8208D754;
		  /* 8208D754h */ case   12:  		/* stw R11, <#[R10 + 4]> */
		/* 8208D754h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8208D754h case   12:*/		return 0x8208D758;
		  /* 8208D758h */ case   13:  		/* bc 4, CR6_EQ, 48 */
		/* 8208D758h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8208D788;  }
		/* 8208D758h case   13:*/		return 0x8208D75C;
		  /* 8208D75Ch */ case   14:  		/* lhz R11, <#[R30]> */
		/* 8208D75Ch case   14:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8208D75Ch case   14:*/		return 0x8208D760;
		  /* 8208D760h */ case   15:  		/* cmplwi CR6, R11, 128 */
		/* 8208D760h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 8208D760h case   15:*/		return 0x8208D764;
		  /* 8208D764h */ case   16:  		/* bc 4, CR6_LT, 36 */
		/* 8208D764h case   16:*/		if ( !regs.CR[6].lt ) { return 0x8208D788;  }
		/* 8208D764h case   16:*/		return 0x8208D768;
		  /* 8208D768h */ case   17:  		/* rlwinm R10, R11, 27, 5, 31 */
		/* 8208D768h case   17:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R11);
		/* 8208D768h case   17:*/		return 0x8208D76C;
		  /* 8208D76Ch */ case   18:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8208D76Ch case   18:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8208D76Ch case   18:*/		return 0x8208D770;
		  /* 8208D770h */ case   19:  		/* addi R10, R10, 88 */
		/* 8208D770h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x58);
		/* 8208D770h case   19:*/		return 0x8208D774;
		  /* 8208D774h */ case   20:  		/* slw R9, R22, R11 */
		/* 8208D774h case   20:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R22,regs.R11);
		/* 8208D774h case   20:*/		return 0x8208D778;
		  /* 8208D778h */ case   21:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 8208D778h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 8208D778h case   21:*/		return 0x8208D77C;
		  /* 8208D77Ch */ case   22:  		/* lwzx R10, <#[R11 + R27]> */
		/* 8208D77Ch case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 8208D77Ch case   22:*/		return 0x8208D780;
		  /* 8208D780h */ case   23:  		/* xor R10, R10, R9 */
		/* 8208D780h case   23:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8208D780h case   23:*/		return 0x8208D784;
		  /* 8208D784h */ case   24:  		/* stwx R10, <#[R11 + R27]> */
		/* 8208D784h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 8208D784h case   24:*/		return 0x8208D788;
	}
	return 0x8208D788;
} // Block from 8208D724h-8208D788h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8208D788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D788);
		  /* 8208D788h */ case    0:  		/* lbz R11, <#[R30 + 5]> */
		/* 8208D788h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208D788h case    0:*/		return 0x8208D78C;
		  /* 8208D78Ch */ case    1:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 8208D78Ch case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 8208D78Ch case    1:*/		return 0x8208D790;
		  /* 8208D790h */ case    2:  		/* bc 12, CR0_EQ, 60 */
		/* 8208D790h case    2:*/		if ( regs.CR[0].eq ) { return 0x8208D7CC;  }
		/* 8208D790h case    2:*/		return 0x8208D794;
		  /* 8208D794h */ case    3:  		/* lhz R10, <#[R30]> */
		/* 8208D794h case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8208D794h case    3:*/		return 0x8208D798;
		  /* 8208D798h */ case    4:  		/* rlwinm. R9, R11, 0, 30, 30 */
		/* 8208D798h case    4:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R11);
		/* 8208D798h case    4:*/		return 0x8208D79C;
		  /* 8208D79Ch */ case    5:  		/* rlwinm R11, R10, 4, 0, 31 */
		/* 8208D79Ch case    5:*/		cpu::op::rlwinm<0,4,0,31>(regs,&regs.R11,regs.R10);
		/* 8208D79Ch case    5:*/		return 0x8208D7A0;
		  /* 8208D7A0h */ case    6:  		/* addi R4, R11, -24 */
		/* 8208D7A0h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFE8);
		/* 8208D7A0h case    6:*/		return 0x8208D7A4;
		  /* 8208D7A4h */ case    7:  		/* stw R4, <#[R31 + 116]> */
		/* 8208D7A4h case    7:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R31 + 0x00000074) );
		/* 8208D7A4h case    7:*/		return 0x8208D7A8;
		  /* 8208D7A8h */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 8208D7A8h case    8:*/		if ( regs.CR[0].eq ) { return 0x8208D7BC;  }
		/* 8208D7A8h case    8:*/		return 0x8208D7AC;
		  /* 8208D7ACh */ case    9:  		/* cmplwi CR6, R4, 4 */
		/* 8208D7ACh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000004);
		/* 8208D7ACh case    9:*/		return 0x8208D7B0;
		  /* 8208D7B0h */ case   10:  		/* bc 4, CR6_GT, 12 */
		/* 8208D7B0h case   10:*/		if ( !regs.CR[6].gt ) { return 0x8208D7BC;  }
		/* 8208D7B0h case   10:*/		return 0x8208D7B4;
		  /* 8208D7B4h */ case   11:  		/* addi R4, R4, -4 */
		/* 8208D7B4h case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFFFC);
		/* 8208D7B4h case   11:*/		return 0x8208D7B8;
		  /* 8208D7B8h */ case   12:  		/* stw R4, <#[R31 + 116]> */
		/* 8208D7B8h case   12:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R31 + 0x00000074) );
		/* 8208D7B8h case   12:*/		return 0x8208D7BC;
	}
	return 0x8208D7BC;
} // Block from 8208D788h-8208D7BCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 8208D7BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D7BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D7BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D7BC);
		  /* 8208D7BCh */ case    0:  		/* lis R5, -274 */
		/* 8208D7BCh case    0:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFFFEEE);
		/* 8208D7BCh case    0:*/		return 0x8208D7C0;
		  /* 8208D7C0h */ case    1:  		/* ori R5, R5, 65262 */
		/* 8208D7C0h case    1:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0xFEEE);
		/* 8208D7C0h case    1:*/		return 0x8208D7C4;
		  /* 8208D7C4h */ case    2:  		/* addi R3, R30, 24 */
		/* 8208D7C4h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x18);
		/* 8208D7C4h case    2:*/		return 0x8208D7C8;
		  /* 8208D7C8h */ case    3:  		/* bl 1965216 */
		/* 8208D7C8h case    3:*/		regs.LR = 0x8208D7CC; return 0x8226D468;
		/* 8208D7C8h case    3:*/		return 0x8208D7CC;
	}
	return 0x8208D7CC;
} // Block from 8208D7BCh-8208D7CCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208D7CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D7CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D7CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D7CC);
		  /* 8208D7CCh */ case    0:  		/* lhz R11, <#[R30]> */
		/* 8208D7CCh case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8208D7CCh case    0:*/		return 0x8208D7D0;
		  /* 8208D7D0h */ case    1:  		/* lwz R10, <#[R27 + 48]> */
		/* 8208D7D0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000030) );
		/* 8208D7D0h case    1:*/		return 0x8208D7D4;
		  /* 8208D7D4h */ case    2:  		/* subf R11, R11, R10 */
		/* 8208D7D4h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8208D7D4h case    2:*/		return 0x8208D7D8;
		  /* 8208D7D8h */ case    3:  		/* stw R11, <#[R27 + 48]> */
		/* 8208D7D8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000030) );
		/* 8208D7D8h case    3:*/		return 0x8208D7DC;
		  /* 8208D7DCh */ case    4:  		/* lhz R11, <#[R30]> */
		/* 8208D7DCh case    4:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8208D7DCh case    4:*/		return 0x8208D7E0;
		  /* 8208D7E0h */ case    5:  		/* add R5, R11, R28 */
		/* 8208D7E0h case    5:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R28);
		/* 8208D7E0h case    5:*/		return 0x8208D7E4;
		  /* 8208D7E4h */ case    6:  		/* cmplwi CR6, R5, 61440 */
		/* 8208D7E4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x0000F000);
		/* 8208D7E4h case    6:*/		return 0x8208D7E8;
		  /* 8208D7E8h */ case    7:  		/* bc 12, CR6_GT, 244 */
		/* 8208D7E8h case    7:*/		if ( regs.CR[6].gt ) { return 0x8208D8DC;  }
		/* 8208D7E8h case    7:*/		return 0x8208D7EC;
		  /* 8208D7ECh */ case    8:  		/* rlwinm R11, R5, 0, 16, 31 */
		/* 8208D7ECh case    8:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R5);
		/* 8208D7ECh case    8:*/		return 0x8208D7F0;
		  /* 8208D7F0h */ case    9:  		/* sth R11, <#[R29]> */
		/* 8208D7F0h case    9:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8208D7F0h case    9:*/		return 0x8208D7F4;
		  /* 8208D7F4h */ case   10:  		/* lbz R10, <#[R29 + 5]> */
		/* 8208D7F4h case   10:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000005) );
		/* 8208D7F4h case   10:*/		return 0x8208D7F8;
		  /* 8208D7F8h */ case   11:  		/* rlwinm. R10, R10, 0, 27, 27 */
		/* 8208D7F8h case   11:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R10);
		/* 8208D7F8h case   11:*/		return 0x8208D7FC;
		  /* 8208D7FCh */ case   12:  		/* bc 4, CR0_EQ, 20 */
		/* 8208D7FCh case   12:*/		if ( !regs.CR[0].eq ) { return 0x8208D810;  }
		/* 8208D7FCh case   12:*/		return 0x8208D800;
		  /* 8208D800h */ case   13:  		/* rlwinm R10, R5, 4, 0, 27 */
		/* 8208D800h case   13:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R5);
		/* 8208D800h case   13:*/		return 0x8208D804;
		  /* 8208D804h */ case   14:  		/* add R10, R10, R29 */
		/* 8208D804h case   14:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R29);
		/* 8208D804h case   14:*/		return 0x8208D808;
		  /* 8208D808h */ case   15:  		/* sth R11, <#[R10 + 2]> */
		/* 8208D808h case   15:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000002) );
		/* 8208D808h case   15:*/		return 0x8208D80C;
		  /* 8208D80Ch */ case   16:  		/* b 24 */
		/* 8208D80Ch case   16:*/		return 0x8208D824;
		/* 8208D80Ch case   16:*/		return 0x8208D810;
	}
	return 0x8208D810;
} // Block from 8208D7CCh-8208D810h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8208D810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D810);
		  /* 8208D810h */ case    0:  		/* lbz R10, <#[R29 + 4]> */
		/* 8208D810h case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000004) );
		/* 8208D810h case    0:*/		return 0x8208D814;
		  /* 8208D814h */ case    1:  		/* addi R10, R10, 24 */
		/* 8208D814h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 8208D814h case    1:*/		return 0x8208D818;
		  /* 8208D818h */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8208D818h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8208D818h case    2:*/		return 0x8208D81C;
		  /* 8208D81Ch */ case    3:  		/* lwzx R10, <#[R10 + R27]> */
		/* 8208D81Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 8208D81Ch case    3:*/		return 0x8208D820;
		  /* 8208D820h */ case    4:  		/* stw R29, <#[R10 + 64]> */
		/* 8208D820h case    4:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R10 + 0x00000040) );
		/* 8208D820h case    4:*/		return 0x8208D824;
	}
	return 0x8208D824;
} // Block from 8208D810h-8208D824h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208D824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D824);
		  /* 8208D824h */ case    0:  		/* lbz R9, <#[R29 + 5]> */
		/* 8208D824h case    0:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000005) );
		/* 8208D824h case    0:*/		return 0x8208D828;
		  /* 8208D828h */ case    1:  		/* rlwinm R10, R11, 0, 16, 31 */
		/* 8208D828h case    1:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R11);
		/* 8208D828h case    1:*/		return 0x8208D82C;
		  /* 8208D82Ch */ case    2:  		/* rlwinm R11, R9, 0, 0, 28 */
		/* 8208D82Ch case    2:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R9);
		/* 8208D82Ch case    2:*/		return 0x8208D830;
		  /* 8208D830h */ case    3:  		/* cmplwi CR6, R10, 128 */
		/* 8208D830h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000080);
		/* 8208D830h case    3:*/		return 0x8208D834;
		  /* 8208D834h */ case    4:  		/* stb R11, <#[R29 + 5]> */
		/* 8208D834h case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R29 + 0x00000005) );
		/* 8208D834h case    4:*/		return 0x8208D838;
		  /* 8208D838h */ case    5:  		/* bc 4, CR6_LT, 68 */
		/* 8208D838h case    5:*/		if ( !regs.CR[6].lt ) { return 0x8208D87C;  }
		/* 8208D838h case    5:*/		return 0x8208D83C;
		  /* 8208D83Ch */ case    6:  		/* addi R11, R10, 48 */
		/* 8208D83Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x30);
		/* 8208D83Ch case    6:*/		return 0x8208D840;
		  /* 8208D840h */ case    7:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8208D840h case    7:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8208D840h case    7:*/		return 0x8208D844;
		  /* 8208D844h */ case    8:  		/* add R11, R11, R27 */
		/* 8208D844h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 8208D844h case    8:*/		return 0x8208D848;
		  /* 8208D848h */ case    9:  		/* lwz R10, <#[R11]> */
		/* 8208D848h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208D848h case    9:*/		return 0x8208D84C;
		  /* 8208D84Ch */ case   10:  		/* cmplw CR6, R10, R11 */
		/* 8208D84Ch case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208D84Ch case   10:*/		return 0x8208D850;
		  /* 8208D850h */ case   11:  		/* bc 4, CR6_EQ, 100 */
		/* 8208D850h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8208D8B4;  }
		/* 8208D850h case   11:*/		return 0x8208D854;
		  /* 8208D854h */ case   12:  		/* lhz R9, <#[R29]> */
		/* 8208D854h case   12:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000000) );
		/* 8208D854h case   12:*/		return 0x8208D858;
		  /* 8208D858h */ case   13:  		/* rlwinm R10, R9, 27, 5, 31 */
		/* 8208D858h case   13:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R9);
		/* 8208D858h case   13:*/		return 0x8208D85C;
		  /* 8208D85Ch */ case   14:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 8208D85Ch case   14:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8208D85Ch case   14:*/		return 0x8208D860;
		  /* 8208D860h */ case   15:  		/* addi R10, R10, 88 */
		/* 8208D860h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x58);
		/* 8208D860h case   15:*/		return 0x8208D864;
		  /* 8208D864h */ case   16:  		/* slw R9, R22, R9 */
		/* 8208D864h case   16:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R22,regs.R9);
		/* 8208D864h case   16:*/		return 0x8208D868;
		  /* 8208D868h */ case   17:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8208D868h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8208D868h case   17:*/		return 0x8208D86C;
		  /* 8208D86Ch */ case   18:  		/* lwzx R8, <#[R10 + R27]> */
		/* 8208D86Ch case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 8208D86Ch case   18:*/		return 0x8208D870;
		  /* 8208D870h */ case   19:  		/* or R9, R8, R9 */
		/* 8208D870h case   19:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8208D870h case   19:*/		return 0x8208D874;
		  /* 8208D874h */ case   20:  		/* stwx R9, <#[R10 + R27]> */
		/* 8208D874h case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 8208D874h case   20:*/		return 0x8208D878;
		  /* 8208D878h */ case   21:  		/* b 60 */
		/* 8208D878h case   21:*/		return 0x8208D8B4;
		/* 8208D878h case   21:*/		return 0x8208D87C;
	}
	return 0x8208D87C;
} // Block from 8208D824h-8208D87Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 8208D87Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D87C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D87C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D87C);
		  /* 8208D87Ch */ case    0:  		/* lwz R11, <#[R27 + 384]> */
		/* 8208D87Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000180) );
		/* 8208D87Ch case    0:*/		return 0x8208D880;
		  /* 8208D880h */ case    1:  		/* addi R9, R27, 384 */
		/* 8208D880h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R27,0x180);
		/* 8208D880h case    1:*/		return 0x8208D884;
		  /* 8208D884h */ case    2:  		/* stw R11, <#[R31 + 120]> */
		/* 8208D884h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000078) );
		/* 8208D884h case    2:*/		return 0x8208D888;
		  /* 8208D888h */ case    3:  		/* cmplw CR6, R9, R11 */
		/* 8208D888h case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8208D888h case    3:*/		return 0x8208D88C;
		  /* 8208D88Ch */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 8208D88Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x8208D8B4;  }
		/* 8208D88Ch case    4:*/		return 0x8208D890;
		  /* 8208D890h */ case    5:  		/* lhz R8, <#[R11 - 8]> */
		/* 8208D890h case    5:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 8208D890h case    5:*/		return 0x8208D894;
		  /* 8208D894h */ case    6:  		/* addi R7, R11, -8 */
		/* 8208D894h case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFF8);
		/* 8208D894h case    6:*/		return 0x8208D898;
		  /* 8208D898h */ case    7:  		/* stw R7, <#[R31 + 92]> */
		/* 8208D898h case    7:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208D898h case    7:*/		return 0x8208D89C;
		  /* 8208D89Ch */ case    8:  		/* cmplw CR6, R10, R8 */
		/* 8208D89Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8208D89Ch case    8:*/		return 0x8208D8A0;
		  /* 8208D8A0h */ case    9:  		/* bc 4, CR6_GT, 20 */
		/* 8208D8A0h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8208D8B4;  }
		/* 8208D8A0h case    9:*/		return 0x8208D8A4;
		  /* 8208D8A4h */ case   10:  		/* lwz R11, <#[R11]> */
		/* 8208D8A4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8208D8A4h case   10:*/		return 0x8208D8A8;
		  /* 8208D8A8h */ case   11:  		/* stw R11, <#[R31 + 120]> */
		/* 8208D8A8h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000078) );
		/* 8208D8A8h case   11:*/		return 0x8208D8AC;
		  /* 8208D8ACh */ case   12:  		/* nop */
		/* 8208D8ACh case   12:*/		cpu::op::nop();
		/* 8208D8ACh case   12:*/		return 0x8208D8B0;
		  /* 8208D8B0h */ case   13:  		/* b -40 */
		/* 8208D8B0h case   13:*/		return 0x8208D888;
		/* 8208D8B0h case   13:*/		return 0x8208D8B4;
	}
	return 0x8208D8B4;
} // Block from 8208D87Ch-8208D8B4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8208D8B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D8B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D8B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D8B4);
		  /* 8208D8B4h */ case    0:  		/* lwz R9, <#[R11 + 4]> */
		/* 8208D8B4h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8208D8B4h case    0:*/		return 0x8208D8B8;
		  /* 8208D8B8h */ case    1:  		/* addi R10, R29, 8 */
		/* 8208D8B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0x8);
		/* 8208D8B8h case    1:*/		return 0x8208D8BC;
		  /* 8208D8BCh */ case    2:  		/* stw R11, <#[R29 + 8]> */
		/* 8208D8BCh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8208D8BCh case    2:*/		return 0x8208D8C0;
		  /* 8208D8C0h */ case    3:  		/* stw R9, <#[R29 + 12]> */
		/* 8208D8C0h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R29 + 0x0000000C) );
		/* 8208D8C0h case    3:*/		return 0x8208D8C4;
		  /* 8208D8C4h */ case    4:  		/* stw R10, <#[R9]> */
		/* 8208D8C4h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8208D8C4h case    4:*/		return 0x8208D8C8;
		  /* 8208D8C8h */ case    5:  		/* stw R10, <#[R11 + 4]> */
		/* 8208D8C8h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8208D8C8h case    5:*/		return 0x8208D8CC;
		  /* 8208D8CCh */ case    6:  		/* lwz R11, <#[R21 + 48]> */
		/* 8208D8CCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000030) );
		/* 8208D8CCh case    6:*/		return 0x8208D8D0;
		  /* 8208D8D0h */ case    7:  		/* add R11, R5, R11 */
		/* 8208D8D0h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R5,regs.R11);
		/* 8208D8D0h case    7:*/		return 0x8208D8D4;
	}
	return 0x8208D8D4;
} // Block from 8208D8B4h-8208D8D4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8208D8D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D8D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D8D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D8D4);
		  /* 8208D8D4h */ case    0:  		/* stw R11, <#[R21 + 48]> */
		/* 8208D8D4h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R21 + 0x00000030) );
		/* 8208D8D4h case    0:*/		return 0x8208D8D8;
		  /* 8208D8D8h */ case    1:  		/* b 528 */
		/* 8208D8D8h case    1:*/		return 0x8208DAE8;
		/* 8208D8D8h case    1:*/		return 0x8208D8DC;
	}
	return 0x8208D8DC;
} // Block from 8208D8D4h-8208D8DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208D8DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D8DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D8DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D8DC);
		  /* 8208D8DCh */ case    0:  		/* mr R4, R29 */
		/* 8208D8DCh case    0:*/		regs.R4 = regs.R29;
		/* 8208D8DCh case    0:*/		return 0x8208D8E0;
		  /* 8208D8E0h */ case    1:  		/* mr R3, R27 */
		/* 8208D8E0h case    1:*/		regs.R3 = regs.R27;
		/* 8208D8E0h case    1:*/		return 0x8208D8E4;
		  /* 8208D8E4h */ case    2:  		/* bl -9740 */
		/* 8208D8E4h case    2:*/		regs.LR = 0x8208D8E8; return 0x8208B2D8;
		/* 8208D8E4h case    2:*/		return 0x8208D8E8;
		  /* 8208D8E8h */ case    3:  		/* b 512 */
		/* 8208D8E8h case    3:*/		return 0x8208DAE8;
		/* 8208D8E8h case    3:*/		return 0x8208D8EC;
	}
	return 0x8208D8EC;
} // Block from 8208D8DCh-8208D8ECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208D8ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D8EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D8EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D8EC);
		  /* 8208D8ECh */ case    0:  		/* cmplwi CR6, R6, 0 */
		/* 8208D8ECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8208D8ECh case    0:*/		return 0x8208D8F0;
		  /* 8208D8F0h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 8208D8F0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8208D914;  }
		/* 8208D8F0h case    1:*/		return 0x8208D8F4;
		  /* 8208D8F4h */ case    2:  		/* mr R7, R28 */
		/* 8208D8F4h case    2:*/		regs.R7 = regs.R28;
		/* 8208D8F4h case    2:*/		return 0x8208D8F8;
		  /* 8208D8F8h */ case    3:  		/* mr R6, R26 */
		/* 8208D8F8h case    3:*/		regs.R6 = regs.R26;
		/* 8208D8F8h case    3:*/		return 0x8208D8FC;
		  /* 8208D8FCh */ case    4:  		/* mr R5, R30 */
		/* 8208D8FCh case    4:*/		regs.R5 = regs.R30;
		/* 8208D8FCh case    4:*/		return 0x8208D900;
		  /* 8208D900h */ case    5:  		/* mr R4, R23 */
		/* 8208D900h case    5:*/		regs.R4 = regs.R23;
		/* 8208D900h case    5:*/		return 0x8208D904;
		  /* 8208D904h */ case    6:  		/* mr R3, R27 */
		/* 8208D904h case    6:*/		regs.R3 = regs.R27;
		/* 8208D904h case    6:*/		return 0x8208D908;
		  /* 8208D908h */ case    7:  		/* bl -9464 */
		/* 8208D908h case    7:*/		regs.LR = 0x8208D90C; return 0x8208B410;
		/* 8208D908h case    7:*/		return 0x8208D90C;
		  /* 8208D90Ch */ case    8:  		/* cmplwi CR0, R3, 0 */
		/* 8208D90Ch case    8:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8208D90Ch case    8:*/		return 0x8208D910;
		  /* 8208D910h */ case    9:  		/* bc 4, CR0_EQ, 472 */
		/* 8208D910h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8208DAE8;  }
		/* 8208D910h case    9:*/		return 0x8208D914;
	}
	return 0x8208D914;
} // Block from 8208D8ECh-8208D914h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8208D914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D914);
		  /* 8208D914h */ case    0:  		/* rlwinm. R11, R23, 0, 27, 27 */
		/* 8208D914h case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R23);
		/* 8208D914h case    0:*/		return 0x8208D918;
		  /* 8208D918h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8208D918h case    1:*/		if ( regs.CR[0].eq ) { return 0x8208D924;  }
		/* 8208D918h case    1:*/		return 0x8208D91C;
		  /* 8208D91Ch */ case    2:  		/* stw R19, <#[R31 + 356]> */
		/* 8208D91Ch case    2:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R31 + 0x00000164) );
		/* 8208D91Ch case    2:*/		return 0x8208D920;
		  /* 8208D920h */ case    3:  		/* b 464 */
		/* 8208D920h case    3:*/		return 0x8208DAF0;
		/* 8208D920h case    3:*/		return 0x8208D924;
	}
	return 0x8208D924;
} // Block from 8208D914h-8208D924h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208D924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D924);
		  /* 8208D924h */ case    0:  		/* rlwinm R23, R23, 0, 14, 1 */
		/* 8208D924h case    0:*/		cpu::op::rlwinm<0,0,14,1>(regs,&regs.R23,regs.R23);
		/* 8208D924h case    0:*/		return 0x8208D928;
		  /* 8208D928h */ case    1:  		/* stw R23, <#[R31 + 348]> */
		/* 8208D928h case    1:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x0000015C) );
		/* 8208D928h case    1:*/		return 0x8208D92C;
		  /* 8208D92Ch */ case    2:  		/* lbz R11, <#[R30 + 5]> */
		/* 8208D92Ch case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208D92Ch case    2:*/		return 0x8208D930;
		  /* 8208D930h */ case    3:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 8208D930h case    3:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 8208D930h case    3:*/		return 0x8208D934;
		  /* 8208D934h */ case    4:  		/* bc 12, CR0_EQ, 184 */
		/* 8208D934h case    4:*/		if ( regs.CR[0].eq ) { return 0x8208D9EC;  }
		/* 8208D934h case    4:*/		return 0x8208D938;
		  /* 8208D938h */ case    5:  		/* rlwinm R11, R23, 0, 23, 19 */
		/* 8208D938h case    5:*/		cpu::op::rlwinm<0,0,23,19>(regs,&regs.R11,regs.R23);
		/* 8208D938h case    5:*/		return 0x8208D93C;
		  /* 8208D93Ch */ case    6:  		/* li R10, 256 */
		/* 8208D93Ch case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x100);
		/* 8208D93Ch case    6:*/		return 0x8208D940;
		  /* 8208D940h */ case    7:  		/* stw R11, <#[R31 + 348]> */
		/* 8208D940h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000015C) );
		/* 8208D940h case    7:*/		return 0x8208D944;
		  /* 8208D944h */ case    8:  		/* lbz R9, <#[R30 + 5]> */
		/* 8208D944h case    8:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000005) );
		/* 8208D944h case    8:*/		return 0x8208D948;
		  /* 8208D948h */ case    9:  		/* rlwimi R10, R9, 4, 20, 22 */
		/* 8208D948h case    9:*/		cpu::op::rlwimi<0,4,20,22>(regs,&regs.R10,regs.R9);
		/* 8208D948h case    9:*/		return 0x8208D94C;
		  /* 8208D94Ch */ case   10:  		/* rlwinm. R9, R9, 0, 28, 28 */
		/* 8208D94Ch case   10:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R9,regs.R9);
		/* 8208D94Ch case   10:*/		return 0x8208D950;
	}
	return 0x8208D950;
} // Block from 8208D924h-8208D950h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8208D950h
// Function 'XMemCpyStreaming128_Cached_Helper'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D950);
		  /* 8208D950h */ case    0:  		/* or R23, R10, R11 */
		/* 8208D950h case    0:*/		cpu::op::or<0>(regs,&regs.R23,regs.R10,regs.R11);
		/* 8208D950h case    0:*/		return 0x8208D954;
		  /* 8208D954h */ case    1:  		/* stw R23, <#[R31 + 348]> */
		/* 8208D954h case    1:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x0000015C) );
		/* 8208D954h case    1:*/		return 0x8208D958;
		  /* 8208D958h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8208D958h case    2:*/		if ( regs.CR[0].eq ) { return 0x8208D968;  }
		/* 8208D958h case    2:*/		return 0x8208D95C;
		  /* 8208D95Ch */ case    3:  		/* addi R11, R30, -32 */
		/* 8208D95Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFE0);
		/* 8208D95Ch case    3:*/		return 0x8208D960;
		  /* 8208D960h */ case    4:  		/* addi R11, R11, 8 */
		/* 8208D960h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8208D960h case    4:*/		return 0x8208D964;
		  /* 8208D964h */ case    5:  		/* b 20 */
		/* 8208D964h case    5:*/		return 0x8208D978;
		/* 8208D964h case    5:*/		return 0x8208D968;
	}
	return 0x8208D968;
} // Block from 8208D950h-8208D968h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208D968h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D968);
		  /* 8208D968h */ case    0:  		/* lhz R11, <#[R30]> */
		/* 8208D968h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8208D968h case    0:*/		return 0x8208D96C;
		  /* 8208D96Ch */ case    1:  		/* rlwinm R11, R11, 4, 0, 31 */
		/* 8208D96Ch case    1:*/		cpu::op::rlwinm<0,4,0,31>(regs,&regs.R11,regs.R11);
		/* 8208D96Ch case    1:*/		return 0x8208D970;
		  /* 8208D970h */ case    2:  		/* add R11, R11, R30 */
		/* 8208D970h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8208D970h case    2:*/		return 0x8208D974;
		  /* 8208D974h */ case    3:  		/* addi R11, R11, -16 */
		/* 8208D974h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFF0);
		/* 8208D974h case    3:*/		return 0x8208D978;
	}
	return 0x8208D978;
} // Block from 8208D968h-8208D978h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208D978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D978);
		  /* 8208D978h */ case    0:  		/* ori R0, R0, 0 */
		/* 8208D978h case    0:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 8208D978h case    0:*/		return 0x8208D97C;
		  /* 8208D97Ch */ case    1:  		/* nop */
		/* 8208D97Ch case    1:*/		cpu::op::nop();
		/* 8208D97Ch case    1:*/		return 0x8208D980;
		  /* 8208D980h */ case    2:  		/* nop */
		/* 8208D980h case    2:*/		cpu::op::nop();
		/* 8208D980h case    2:*/		return 0x8208D984;
	}
	return 0x8208D984;
} // Block from 8208D978h-8208D984h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208D984h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D984( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D984) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D984);
		  /* 8208D984h */ case    0:  		/* lhz R11, <#[R11 + 2]> */
		/* 8208D984h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000002) );
		/* 8208D984h case    0:*/		return 0x8208D988;
		  /* 8208D988h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 8208D988h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8208D988h case    1:*/		return 0x8208D98C;
		  /* 8208D98Ch */ case    2:  		/* bc 12, CR0_EQ, 24 */
		/* 8208D98Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8208D9A4;  }
		/* 8208D98Ch case    2:*/		return 0x8208D990;
		  /* 8208D990h */ case    3:  		/* rlwinm. R10, R11, 0, 16, 16 */
		/* 8208D990h case    3:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R10,regs.R11);
		/* 8208D990h case    3:*/		return 0x8208D994;
		  /* 8208D994h */ case    4:  		/* bc 4, CR0_EQ, 16 */
		/* 8208D994h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8208D9A4;  }
		/* 8208D994h case    4:*/		return 0x8208D998;
		  /* 8208D998h */ case    5:  		/* rlwinm R11, R11, 18, 0, 13 */
		/* 8208D998h case    5:*/		cpu::op::rlwinm<0,18,0,13>(regs,&regs.R11,regs.R11);
		/* 8208D998h case    5:*/		return 0x8208D99C;
		  /* 8208D99Ch */ case    6:  		/* or R23, R11, R23 */
		/* 8208D99Ch case    6:*/		cpu::op::or<0>(regs,&regs.R23,regs.R11,regs.R23);
		/* 8208D99Ch case    6:*/		return 0x8208D9A0;
		  /* 8208D9A0h */ case    7:  		/* stw R23, <#[R31 + 348]> */
		/* 8208D9A0h case    7:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x0000015C) );
		/* 8208D9A0h case    7:*/		return 0x8208D9A4;
	}
	return 0x8208D9A4;
} // Block from 8208D984h-8208D9A4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8208D9A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D9A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D9A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D9A4);
		  /* 8208D9A4h */ case    0:  		/* nop */
		/* 8208D9A4h case    0:*/		cpu::op::nop();
		/* 8208D9A4h case    0:*/		return 0x8208D9A8;
		  /* 8208D9A8h */ case    1:  		/* nop */
		/* 8208D9A8h case    1:*/		cpu::op::nop();
		/* 8208D9A8h case    1:*/		return 0x8208D9AC;
		  /* 8208D9ACh */ case    2:  		/* nop */
		/* 8208D9ACh case    2:*/		cpu::op::nop();
		/* 8208D9ACh case    2:*/		return 0x8208D9B0;
		  /* 8208D9B0h */ case    3:  		/* b 84 */
		/* 8208D9B0h case    3:*/		return 0x8208DA04;
		/* 8208D9B0h case    3:*/		return 0x8208D9B4;
	}
	return 0x8208D9B4;
} // Block from 8208D9A4h-8208D9B4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208D9B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D9B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D9B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D9B4);
		  /* 8208D9B4h */ case    0:  		/* lwz R30, <#[R31 + 124]> */
		/* 8208D9B4h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000007C) );
		/* 8208D9B4h case    0:*/		return 0x8208D9B8;
		  /* 8208D9B8h */ case    1:  		/* lbz R11, <#[R30 + 5]> */
		/* 8208D9B8h case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208D9B8h case    1:*/		return 0x8208D9BC;
		  /* 8208D9BCh */ case    2:  		/* andi. R11, R11, 253 */
		/* 8208D9BCh case    2:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0xFD);
		/* 8208D9BCh case    2:*/		return 0x8208D9C0;
		  /* 8208D9C0h */ case    3:  		/* stb R11, <#[R30 + 5]> */
		/* 8208D9C0h case    3:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208D9C0h case    3:*/		return 0x8208D9C4;
		  /* 8208D9C4h */ case    4:  		/* li R19, 0 */
		/* 8208D9C4h case    4:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 8208D9C4h case    4:*/		return 0x8208D9C8;
		  /* 8208D9C8h */ case    5:  		/* lwz R26, <#[R31 + 364]> */
		/* 8208D9C8h case    5:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R31 + 0x0000016C) );
		/* 8208D9C8h case    5:*/		return 0x8208D9CC;
		  /* 8208D9CCh */ case    6:  		/* li R22, 1 */
		/* 8208D9CCh case    6:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 8208D9CCh case    6:*/		return 0x8208D9D0;
		  /* 8208D9D0h */ case    7:  		/* lwz R20, <#[R31 + 356]> */
		/* 8208D9D0h case    7:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R31 + 0x00000164) );
		/* 8208D9D0h case    7:*/		return 0x8208D9D4;
		  /* 8208D9D4h */ case    8:  		/* lwz R23, <#[R31 + 348]> */
		/* 8208D9D4h case    8:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R31 + 0x0000015C) );
		/* 8208D9D4h case    8:*/		return 0x8208D9D8;
		  /* 8208D9D8h */ case    9:  		/* lwz R27, <#[R31 + 340]> */
		/* 8208D9D8h case    9:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R31 + 0x00000154) );
		/* 8208D9D8h case    9:*/		return 0x8208D9DC;
		  /* 8208D9DCh */ case   10:  		/* lwz R21, <#[R31 + 84]> */
		/* 8208D9DCh case   10:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R31 + 0x00000054) );
		/* 8208D9DCh case   10:*/		return 0x8208D9E0;
		  /* 8208D9E0h */ case   11:  		/* lwz R24, <#[R31 + 80]> */
		/* 8208D9E0h case   11:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R31 + 0x00000050) );
		/* 8208D9E0h case   11:*/		return 0x8208D9E4;
		  /* 8208D9E4h */ case   12:  		/* lwz R25, <#[R31 + 92]> */
		/* 8208D9E4h case   12:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208D9E4h case   12:*/		return 0x8208D9E8;
		  /* 8208D9E8h */ case   13:  		/* b 28 */
		/* 8208D9E8h case   13:*/		return 0x8208DA04;
		/* 8208D9E8h case   13:*/		return 0x8208D9EC;
	}
	return 0x8208D9EC;
} // Block from 8208D9B4h-8208D9ECh (14 instructions)

//////////////////////////////////////////////////////
// Block at 8208D9ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208D9EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208D9EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208D9EC);
		  /* 8208D9ECh */ case    0:  		/* lbz R11, <#[R30 + 7]> */
		/* 8208D9ECh case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000007) );
		/* 8208D9ECh case    0:*/		return 0x8208D9F0;
		  /* 8208D9F0h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 8208D9F0h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8208D9F0h case    1:*/		return 0x8208D9F4;
		  /* 8208D9F4h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8208D9F4h case    2:*/		if ( regs.CR[0].eq ) { return 0x8208DA04;  }
		/* 8208D9F4h case    2:*/		return 0x8208D9F8;
		  /* 8208D9F8h */ case    3:  		/* rlwinm R11, R11, 18, 0, 13 */
		/* 8208D9F8h case    3:*/		cpu::op::rlwinm<0,18,0,13>(regs,&regs.R11,regs.R11);
		/* 8208D9F8h case    3:*/		return 0x8208D9FC;
		  /* 8208D9FCh */ case    4:  		/* or R23, R11, R23 */
		/* 8208D9FCh case    4:*/		cpu::op::or<0>(regs,&regs.R23,regs.R11,regs.R23);
		/* 8208D9FCh case    4:*/		return 0x8208DA00;
		  /* 8208DA00h */ case    5:  		/* stw R23, <#[R31 + 348]> */
		/* 8208DA00h case    5:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x0000015C) );
		/* 8208DA00h case    5:*/		return 0x8208DA04;
	}
	return 0x8208DA04;
} // Block from 8208D9ECh-8208DA04h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208DA04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DA04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DA04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DA04);
		  /* 8208DA04h */ case    0:  		/* mr R5, R26 */
		/* 8208DA04h case    0:*/		regs.R5 = regs.R26;
		/* 8208DA04h case    0:*/		return 0x8208DA08;
		  /* 8208DA08h */ case    1:  		/* rlwinm R4, R23, 0, 29, 27 */
		/* 8208DA08h case    1:*/		cpu::op::rlwinm<0,0,29,27>(regs,&regs.R4,regs.R23);
		/* 8208DA08h case    1:*/		return 0x8208DA0C;
		  /* 8208DA0Ch */ case    2:  		/* mr R3, R27 */
		/* 8208DA0Ch case    2:*/		regs.R3 = regs.R27;
		/* 8208DA0Ch case    2:*/		return 0x8208DA10;
		  /* 8208DA10h */ case    3:  		/* bl -4856 */
		/* 8208DA10h case    3:*/		regs.LR = 0x8208DA14; return 0x8208C718;
		/* 8208DA10h case    3:*/		return 0x8208DA14;
		  /* 8208DA14h */ case    4:  		/* or. R29, R3, R3 */
		/* 8208DA14h case    4:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 8208DA14h case    4:*/		return 0x8208DA18;
		  /* 8208DA18h */ case    5:  		/* bc 12, CR0_EQ, 200 */
		/* 8208DA18h case    5:*/		if ( regs.CR[0].eq ) { return 0x8208DAE0;  }
		/* 8208DA18h case    5:*/		return 0x8208DA1C;
		  /* 8208DA1Ch */ case    6:  		/* lbz R10, <#[R29 - 11]> */
		/* 8208DA1Ch case    6:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R29 + 0xFFFFFFF5) );
		/* 8208DA1Ch case    6:*/		return 0x8208DA20;
		  /* 8208DA20h */ case    7:  		/* addi R11, R29, -16 */
		/* 8208DA20h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFF0);
		/* 8208DA20h case    7:*/		return 0x8208DA24;
		  /* 8208DA24h */ case    8:  		/* rlwinm. R9, R10, 0, 30, 30 */
		/* 8208DA24h case    8:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R10);
		/* 8208DA24h case    8:*/		return 0x8208DA28;
		  /* 8208DA28h */ case    9:  		/* bc 12, CR0_EQ, 108 */
		/* 8208DA28h case    9:*/		if ( regs.CR[0].eq ) { return 0x8208DA94;  }
		/* 8208DA28h case    9:*/		return 0x8208DA2C;
		  /* 8208DA2Ch */ case   10:  		/* rlwinm. R10, R10, 0, 28, 28 */
		/* 8208DA2Ch case   10:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R10,regs.R10);
		/* 8208DA2Ch case   10:*/		return 0x8208DA30;
		  /* 8208DA30h */ case   11:  		/* bc 12, CR0_EQ, 16 */
		/* 8208DA30h case   11:*/		if ( regs.CR[0].eq ) { return 0x8208DA40;  }
		/* 8208DA30h case   11:*/		return 0x8208DA34;
		  /* 8208DA34h */ case   12:  		/* addi R11, R11, -32 */
		/* 8208DA34h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFE0);
		/* 8208DA34h case   12:*/		return 0x8208DA38;
		  /* 8208DA38h */ case   13:  		/* addi R10, R11, 8 */
		/* 8208DA38h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x8);
		/* 8208DA38h case   13:*/		return 0x8208DA3C;
		  /* 8208DA3Ch */ case   14:  		/* b 20 */
		/* 8208DA3Ch case   14:*/		return 0x8208DA50;
		/* 8208DA3Ch case   14:*/		return 0x8208DA40;
	}
	return 0x8208DA40;
} // Block from 8208DA04h-8208DA40h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8208DA40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DA40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DA40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DA40);
		  /* 8208DA40h */ case    0:  		/* lhz R10, <#[R11]> */
		/* 8208DA40h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208DA40h case    0:*/		return 0x8208DA44;
		  /* 8208DA44h */ case    1:  		/* rlwinm R10, R10, 4, 0, 31 */
		/* 8208DA44h case    1:*/		cpu::op::rlwinm<0,4,0,31>(regs,&regs.R10,regs.R10);
		/* 8208DA44h case    1:*/		return 0x8208DA48;
		  /* 8208DA48h */ case    2:  		/* add R11, R10, R11 */
		/* 8208DA48h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208DA48h case    2:*/		return 0x8208DA4C;
		  /* 8208DA4Ch */ case    3:  		/* addi R10, R11, -16 */
		/* 8208DA4Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFF0);
		/* 8208DA4Ch case    3:*/		return 0x8208DA50;
	}
	return 0x8208DA50;
} // Block from 8208DA40h-8208DA50h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208DA50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DA50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DA50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DA50);
		  /* 8208DA50h */ case    0:  		/* lbz R11, <#[R30 + 5]> */
		/* 8208DA50h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 8208DA50h case    0:*/		return 0x8208DA54;
		  /* 8208DA54h */ case    1:  		/* rlwinm. R9, R11, 0, 30, 30 */
		/* 8208DA54h case    1:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R11);
		/* 8208DA54h case    1:*/		return 0x8208DA58;
		  /* 8208DA58h */ case    2:  		/* bc 12, CR0_EQ, 52 */
		/* 8208DA58h case    2:*/		if ( regs.CR[0].eq ) { return 0x8208DA8C;  }
		/* 8208DA58h case    2:*/		return 0x8208DA5C;
		  /* 8208DA5Ch */ case    3:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 8208DA5Ch case    3:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 8208DA5Ch case    3:*/		return 0x8208DA60;
		  /* 8208DA60h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 8208DA60h case    4:*/		if ( regs.CR[0].eq ) { return 0x8208DA70;  }
		/* 8208DA60h case    4:*/		return 0x8208DA64;
		  /* 8208DA64h */ case    5:  		/* addi R11, R30, -32 */
		/* 8208DA64h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFE0);
		/* 8208DA64h case    5:*/		return 0x8208DA68;
		  /* 8208DA68h */ case    6:  		/* addi R11, R11, 8 */
		/* 8208DA68h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8208DA68h case    6:*/		return 0x8208DA6C;
		  /* 8208DA6Ch */ case    7:  		/* b 20 */
		/* 8208DA6Ch case    7:*/		return 0x8208DA80;
		/* 8208DA6Ch case    7:*/		return 0x8208DA70;
	}
	return 0x8208DA70;
} // Block from 8208DA50h-8208DA70h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8208DA70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DA70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DA70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DA70);
		  /* 8208DA70h */ case    0:  		/* lhz R11, <#[R30]> */
		/* 8208DA70h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8208DA70h case    0:*/		return 0x8208DA74;
		  /* 8208DA74h */ case    1:  		/* rlwinm R11, R11, 4, 0, 31 */
		/* 8208DA74h case    1:*/		cpu::op::rlwinm<0,4,0,31>(regs,&regs.R11,regs.R11);
		/* 8208DA74h case    1:*/		return 0x8208DA78;
		  /* 8208DA78h */ case    2:  		/* add R11, R11, R30 */
		/* 8208DA78h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8208DA78h case    2:*/		return 0x8208DA7C;
		  /* 8208DA7Ch */ case    3:  		/* addi R11, R11, -16 */
		/* 8208DA7Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFF0);
		/* 8208DA7Ch case    3:*/		return 0x8208DA80;
	}
	return 0x8208DA80;
} // Block from 8208DA70h-8208DA80h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208DA80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DA80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DA80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DA80);
		  /* 8208DA80h */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 8208DA80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8208DA80h case    0:*/		return 0x8208DA84;
		  /* 8208DA84h */ case    1:  		/* stw R11, <#[R10 + 4]> */
		/* 8208DA84h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8208DA84h case    1:*/		return 0x8208DA88;
		  /* 8208DA88h */ case    2:  		/* b 12 */
		/* 8208DA88h case    2:*/		return 0x8208DA94;
		/* 8208DA88h case    2:*/		return 0x8208DA8C;
	}
	return 0x8208DA8C;
} // Block from 8208DA80h-8208DA8Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208DA8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DA8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DA8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DA8C);
		  /* 8208DA8Ch */ case    0:  		/* std R19, <#[R10]> */
		/* 8208DA8Ch case    0:*/		cpu::mem::store64( regs, regs.R19, (uint32)(regs.R10 + 0x00000000) );
		/* 8208DA8Ch case    0:*/		return 0x8208DA90;
		  /* 8208DA90h */ case    1:  		/* std R19, <#[R10 + 8]> */
		/* 8208DA90h case    1:*/		cpu::mem::store64( regs, regs.R19, (uint32)(regs.R10 + 0x00000008) );
		/* 8208DA90h case    1:*/		return 0x8208DA94;
	}
	return 0x8208DA94;
} // Block from 8208DA8Ch-8208DA94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208DA94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DA94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DA94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DA94);
		  /* 8208DA94h */ case    0:  		/* cmplw CR6, R26, R25 */
		/* 8208DA94h case    0:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R25);
		/* 8208DA94h case    0:*/		return 0x8208DA98;
		  /* 8208DA98h */ case    1:  		/* mr R5, R26 */
		/* 8208DA98h case    1:*/		regs.R5 = regs.R26;
		/* 8208DA98h case    1:*/		return 0x8208DA9C;
		  /* 8208DA9Ch */ case    2:  		/* bc 12, CR6_LT, 8 */
		/* 8208DA9Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x8208DAA4;  }
		/* 8208DA9Ch case    2:*/		return 0x8208DAA0;
		  /* 8208DAA0h */ case    3:  		/* mr R5, R25 */
		/* 8208DAA0h case    3:*/		regs.R5 = regs.R25;
		/* 8208DAA0h case    3:*/		return 0x8208DAA4;
	}
	return 0x8208DAA4;
} // Block from 8208DA94h-8208DAA4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208DAA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DAA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DAA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DAA4);
		  /* 8208DAA4h */ case    0:  		/* mr R4, R20 */
		/* 8208DAA4h case    0:*/		regs.R4 = regs.R20;
		/* 8208DAA4h case    0:*/		return 0x8208DAA8;
		  /* 8208DAA8h */ case    1:  		/* mr R3, R29 */
		/* 8208DAA8h case    1:*/		regs.R3 = regs.R29;
		/* 8208DAA8h case    1:*/		return 0x8208DAAC;
		  /* 8208DAACh */ case    2:  		/* bl 17524 */
		/* 8208DAACh case    2:*/		regs.LR = 0x8208DAB0; return 0x82091F20;
		/* 8208DAACh case    2:*/		return 0x8208DAB0;
		  /* 8208DAB0h */ case    3:  		/* cmplw CR6, R26, R25 */
		/* 8208DAB0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R25);
		/* 8208DAB0h case    3:*/		return 0x8208DAB4;
		  /* 8208DAB4h */ case    4:  		/* bc 4, CR6_GT, 28 */
		/* 8208DAB4h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8208DAD0;  }
		/* 8208DAB4h case    4:*/		return 0x8208DAB8;
		  /* 8208DAB8h */ case    5:  		/* rlwinm. R11, R23, 0, 28, 28 */
		/* 8208DAB8h case    5:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R23);
		/* 8208DAB8h case    5:*/		return 0x8208DABC;
		  /* 8208DABCh */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 8208DABCh case    6:*/		if ( regs.CR[0].eq ) { return 0x8208DAD0;  }
		/* 8208DABCh case    6:*/		return 0x8208DAC0;
		  /* 8208DAC0h */ case    7:  		/* subf R5, R25, R26 */
		/* 8208DAC0h case    7:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R25,regs.R26);
		/* 8208DAC0h case    7:*/		return 0x8208DAC4;
		  /* 8208DAC4h */ case    8:  		/* li R4, 0 */
		/* 8208DAC4h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208DAC4h case    8:*/		return 0x8208DAC8;
		  /* 8208DAC8h */ case    9:  		/* add R3, R29, R25 */
		/* 8208DAC8h case    9:*/		cpu::op::add<0>(regs,&regs.R3,regs.R29,regs.R25);
		/* 8208DAC8h case    9:*/		return 0x8208DACC;
		  /* 8208DACCh */ case   10:  		/* bl 14452 */
		/* 8208DACCh case   10:*/		regs.LR = 0x8208DAD0; return 0x82091340;
		/* 8208DACCh case   10:*/		return 0x8208DAD0;
	}
	return 0x8208DAD0;
} // Block from 8208DAA4h-8208DAD0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8208DAD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DAD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DAD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DAD0);
		  /* 8208DAD0h */ case    0:  		/* mr R5, R20 */
		/* 8208DAD0h case    0:*/		regs.R5 = regs.R20;
		/* 8208DAD0h case    0:*/		return 0x8208DAD4;
		  /* 8208DAD4h */ case    1:  		/* mr R4, R23 */
		/* 8208DAD4h case    1:*/		regs.R4 = regs.R23;
		/* 8208DAD4h case    1:*/		return 0x8208DAD8;
		  /* 8208DAD8h */ case    2:  		/* mr R3, R27 */
		/* 8208DAD8h case    2:*/		regs.R3 = regs.R27;
		/* 8208DAD8h case    2:*/		return 0x8208DADC;
		  /* 8208DADCh */ case    3:  		/* bl -2764 */
		/* 8208DADCh case    3:*/		regs.LR = 0x8208DAE0; return 0x8208D010;
		/* 8208DADCh case    3:*/		return 0x8208DAE0;
	}
	return 0x8208DAE0;
} // Block from 8208DAD0h-8208DAE0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208DAE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DAE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DAE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DAE0);
		  /* 8208DAE0h */ case    0:  		/* mr R20, R29 */
		/* 8208DAE0h case    0:*/		regs.R20 = regs.R29;
		/* 8208DAE0h case    0:*/		return 0x8208DAE4;
		  /* 8208DAE4h */ case    1:  		/* stw R29, <#[R31 + 356]> */
		/* 8208DAE4h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000164) );
		/* 8208DAE4h case    1:*/		return 0x8208DAE8;
	}
	return 0x8208DAE8;
} // Block from 8208DAE0h-8208DAE8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208DAE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DAE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DAE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DAE8);
		  /* 8208DAE8h */ case    0:  		/* cmplwi CR6, R20, 0 */
		/* 8208DAE8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 8208DAE8h case    0:*/		return 0x8208DAEC;
		  /* 8208DAECh */ case    1:  		/* bc 4, CR6_EQ, 48 */
		/* 8208DAECh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8208DB1C;  }
		/* 8208DAECh case    1:*/		return 0x8208DAF0;
	}
	return 0x8208DAF0;
} // Block from 8208DAE8h-8208DAF0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208DAF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DAF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DAF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DAF0);
		  /* 8208DAF0h */ case    0:  		/* rlwinm. R11, R23, 0, 29, 29 */
		/* 8208DAF0h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R23);
		/* 8208DAF0h case    0:*/		return 0x8208DAF4;
		  /* 8208DAF4h */ case    1:  		/* bc 12, CR0_EQ, 40 */
		/* 8208DAF4h case    1:*/		if ( regs.CR[0].eq ) { return 0x8208DB1C;  }
		/* 8208DAF4h case    1:*/		return 0x8208DAF8;
		  /* 8208DAF8h */ case    2:  		/* lis R11, -16384 */
		/* 8208DAF8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC000);
		/* 8208DAF8h case    2:*/		return 0x8208DAFC;
		  /* 8208DAFCh */ case    3:  		/* addi R3, R31, 128 */
		/* 8208DAFCh case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x80);
		/* 8208DAFCh case    3:*/		return 0x8208DB00;
		  /* 8208DB00h */ case    4:  		/* ori R11, R11, 23 */
		/* 8208DB00h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x17);
		/* 8208DB00h case    4:*/		return 0x8208DB04;
		  /* 8208DB04h */ case    5:  		/* stw R11, <#[R31 + 128]> */
		/* 8208DB04h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000080) );
		/* 8208DB04h case    5:*/		return 0x8208DB08;
		  /* 8208DB08h */ case    6:  		/* stw R19, <#[R31 + 136]> */
		/* 8208DB08h case    6:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R31 + 0x00000088) );
		/* 8208DB08h case    6:*/		return 0x8208DB0C;
		  /* 8208DB0Ch */ case    7:  		/* stw R22, <#[R31 + 144]> */
		/* 8208DB0Ch case    7:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000090) );
		/* 8208DB0Ch case    7:*/		return 0x8208DB10;
		  /* 8208DB10h */ case    8:  		/* stw R19, <#[R31 + 132]> */
		/* 8208DB10h case    8:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R31 + 0x00000084) );
		/* 8208DB10h case    8:*/		return 0x8208DB14;
		  /* 8208DB14h */ case    9:  		/* stw R24, <#[R31 + 148]> */
		/* 8208DB14h case    9:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000094) );
		/* 8208DB14h case    9:*/		return 0x8208DB18;
		  /* 8208DB18h */ case   10:  		/* bl 1963984 */
		/* 8208DB18h case   10:*/		regs.LR = 0x8208DB1C; return 0x8226D2E8;
		/* 8208DB18h case   10:*/		return 0x8208DB1C;
	}
	return 0x8208DB1C;
} // Block from 8208DAF0h-8208DB1Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8208DB1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DB1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DB1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DB1C);
		  /* 8208DB1Ch */ case    0:  		/* nop */
		/* 8208DB1Ch case    0:*/		cpu::op::nop();
		/* 8208DB1Ch case    0:*/		return 0x8208DB20;
		  /* 8208DB20h */ case    1:  		/* nop */
		/* 8208DB20h case    1:*/		cpu::op::nop();
		/* 8208DB20h case    1:*/		return 0x8208DB24;
		  /* 8208DB24h */ case    2:  		/* nop */
		/* 8208DB24h case    2:*/		cpu::op::nop();
		/* 8208DB24h case    2:*/		return 0x8208DB28;
		  /* 8208DB28h */ case    3:  		/* b 16 */
		/* 8208DB28h case    3:*/		return 0x8208DB38;
		/* 8208DB28h case    3:*/		return 0x8208DB2C;
	}
	return 0x8208DB2C;
} // Block from 8208DB1Ch-8208DB2Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208DB2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DB2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DB2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DB2C);
		  /* 8208DB2Ch */ case    0:  		/* li R11, 0 */
		/* 8208DB2Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8208DB2Ch case    0:*/		return 0x8208DB30;
		  /* 8208DB30h */ case    1:  		/* stw R11, <#[R31 + 356]> */
		/* 8208DB30h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000164) );
		/* 8208DB30h case    1:*/		return 0x8208DB34;
		  /* 8208DB34h */ case    2:  		/* lwz R21, <#[R31 + 84]> */
		/* 8208DB34h case    2:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R31 + 0x00000054) );
		/* 8208DB34h case    2:*/		return 0x8208DB38;
	}
	return 0x8208DB38;
} // Block from 8208DB2Ch-8208DB38h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208DB38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DB38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DB38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DB38);
		  /* 8208DB38h */ case    0:  		/* nop */
		/* 8208DB38h case    0:*/		cpu::op::nop();
		/* 8208DB38h case    0:*/		return 0x8208DB3C;
		  /* 8208DB3Ch */ case    1:  		/* addi R12, R31, 320 */
		/* 8208DB3Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R31,0x140);
		/* 8208DB3Ch case    1:*/		return 0x8208DB40;
		  /* 8208DB40h */ case    2:  		/* bl 48 */
		/* 8208DB40h case    2:*/		regs.LR = 0x8208DB44; return 0x8208DB70;
		/* 8208DB40h case    2:*/		return 0x8208DB44;
		  /* 8208DB44h */ case    3:  		/* lwz R3, <#[R31 + 356]> */
		/* 8208DB44h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000164) );
		/* 8208DB44h case    3:*/		return 0x8208DB48;
	}
	return 0x8208DB48;
} // Block from 8208DB38h-8208DB48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208DB48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DB48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DB48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DB48);
		  /* 8208DB48h */ case    0:  		/* addi R1, R31, 320 */
		/* 8208DB48h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0x140);
		/* 8208DB48h case    0:*/		return 0x8208DB4C;
		  /* 8208DB4Ch */ case    1:  		/* b 14136 */
		/* 8208DB4Ch case    1:*/		return 0x82091284;
		/* 8208DB4Ch case    1:*/		return 0x8208DB50;
	}
	return 0x8208DB50;
} // Block from 8208DB48h-8208DB50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208DB50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DB50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DB50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DB50);
		  /* 8208DB50h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8208DB50h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208DB50h case    0:*/		return 0x8208DB54;
		  /* 8208DB54h */ case    1:  		/* addi R31, R12, -320 */
		/* 8208DB54h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFEC0);
		/* 8208DB54h case    1:*/		return 0x8208DB58;
		  /* 8208DB58h */ case    2:  		/* std R21, <#[R1 - 16]> */
		/* 8208DB58h case    2:*/		cpu::mem::store64( regs, regs.R21, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208DB58h case    2:*/		return 0x8208DB5C;
		  /* 8208DB5Ch */ case    3:  		/* mfspr R12, LR */
		/* 8208DB5Ch case    3:*/		regs.R12 = regs.LR;
		/* 8208DB5Ch case    3:*/		return 0x8208DB60;
		  /* 8208DB60h */ case    4:  		/* stw R12, <#[R1 - 24]> */
		/* 8208DB60h case    4:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208DB60h case    4:*/		return 0x8208DB64;
		  /* 8208DB64h */ case    5:  		/* stwu R1, <#[R1 - 112]> */
		/* 8208DB64h case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8208DB64h case    5:*/		return 0x8208DB68;
		  /* 8208DB68h */ case    6:  		/* lwz R21, <#[R31 + 84]> */
		/* 8208DB68h case    6:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R31 + 0x00000054) );
		/* 8208DB68h case    6:*/		return 0x8208DB6C;
		  /* 8208DB6Ch */ case    7:  		/* b 28 */
		/* 8208DB6Ch case    7:*/		return 0x8208DB88;
		/* 8208DB6Ch case    7:*/		return 0x8208DB70;
	}
	return 0x8208DB70;
} // Block from 8208DB50h-8208DB70h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8208DB70h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DB70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DB70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DB70);
		  /* 8208DB70h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8208DB70h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208DB70h case    0:*/		return 0x8208DB74;
		  /* 8208DB74h */ case    1:  		/* addi R31, R12, -320 */
		/* 8208DB74h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFEC0);
		/* 8208DB74h case    1:*/		return 0x8208DB78;
		  /* 8208DB78h */ case    2:  		/* std R21, <#[R1 - 16]> */
		/* 8208DB78h case    2:*/		cpu::mem::store64( regs, regs.R21, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208DB78h case    2:*/		return 0x8208DB7C;
		  /* 8208DB7Ch */ case    3:  		/* mfspr R12, LR */
		/* 8208DB7Ch case    3:*/		regs.R12 = regs.LR;
		/* 8208DB7Ch case    3:*/		return 0x8208DB80;
		  /* 8208DB80h */ case    4:  		/* stw R12, <#[R1 - 24]> */
		/* 8208DB80h case    4:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208DB80h case    4:*/		return 0x8208DB84;
		  /* 8208DB84h */ case    5:  		/* stwu R1, <#[R1 - 112]> */
		/* 8208DB84h case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8208DB84h case    5:*/		return 0x8208DB88;
	}
	return 0x8208DB88;
} // Block from 8208DB70h-8208DB88h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208DB88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DB88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DB88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DB88);
		  /* 8208DB88h */ case    0:  		/* lwz R11, <#[R31 + 96]> */
		/* 8208DB88h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 8208DB88h case    0:*/		return 0x8208DB8C;
		  /* 8208DB8Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8208DB8Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208DB8Ch case    1:*/		return 0x8208DB90;
		  /* 8208DB90h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8208DB90h case    2:*/		if ( regs.CR[6].eq ) { return 0x8208DB9C;  }
		/* 8208DB90h case    2:*/		return 0x8208DB94;
		  /* 8208DB94h */ case    3:  		/* lwz R3, <#[R21 + 1408]> */
		/* 8208DB94h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R21 + 0x00000580) );
		/* 8208DB94h case    3:*/		return 0x8208DB98;
		  /* 8208DB98h */ case    4:  		/* bl 1963152 */
		/* 8208DB98h case    4:*/		regs.LR = 0x8208DB9C; return 0x8226D028;
		/* 8208DB98h case    4:*/		return 0x8208DB9C;
	}
	return 0x8208DB9C;
} // Block from 8208DB88h-8208DB9Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208DB9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DB9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DB9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DB9C);
		  /* 8208DB9Ch */ case    0:  		/* lwz R1, <#[R1]> */
		/* 8208DB9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R1, (uint32)(regs.R1 + 0x00000000) );
		/* 8208DB9Ch case    0:*/		return 0x8208DBA0;
		  /* 8208DBA0h */ case    1:  		/* ld R31, <#[R1 - 8]> */
		/* 8208DBA0h case    1:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208DBA0h case    1:*/		return 0x8208DBA4;
		  /* 8208DBA4h */ case    2:  		/* ld R21, <#[R1 - 16]> */
		/* 8208DBA4h case    2:*/		cpu::mem::load64( regs, &regs.R21, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208DBA4h case    2:*/		return 0x8208DBA8;
		  /* 8208DBA8h */ case    3:  		/* lwz R12, <#[R1 - 24]> */
		/* 8208DBA8h case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208DBA8h case    3:*/		return 0x8208DBAC;
		  /* 8208DBACh */ case    4:  		/* mtspr LR, R12 */
		/* 8208DBACh case    4:*/		regs.LR = regs.R12;
		/* 8208DBACh case    4:*/		return 0x8208DBB0;
		  /* 8208DBB0h */ case    5:  		/* bclr 20, CR0_LT */
		/* 8208DBB0h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208DBB0h case    5:*/		return 0x8208DBB4;
	}
	return 0x8208DBB4;
} // Block from 8208DB9Ch-8208DBB4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208DBB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DBB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DBB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DBB4);
		  /* 8208DBB4h */ case    0:  		/* lis R11, -16384 */
		/* 8208DBB4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC000);
		/* 8208DBB4h case    0:*/		return 0x8208DBB8;
		  /* 8208DBB8h */ case    1:  		/* ori R11, R11, 23 */
		/* 8208DBB8h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x17);
		/* 8208DBB8h case    1:*/		return 0x8208DBBC;
		  /* 8208DBBCh */ case    2:  		/* lwz R10, <#[R3]> */
		/* 8208DBBCh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8208DBBCh case    2:*/		return 0x8208DBC0;
		  /* 8208DBC0h */ case    3:  		/* lwz R10, <#[R10]> */
		/* 8208DBC0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 8208DBC0h case    3:*/		return 0x8208DBC4;
		  /* 8208DBC4h */ case    4:  		/* subf R11, R10, R11 */
		/* 8208DBC4h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208DBC4h case    4:*/		return 0x8208DBC8;
		  /* 8208DBC8h */ case    5:  		/* addic R10, R11, -1 */
		/* 8208DBC8h case    5:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 8208DBC8h case    5:*/		return 0x8208DBCC;
		  /* 8208DBCCh */ case    6:  		/* subfe R3, R10, R11 */
		/* 8208DBCCh case    6:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8208DBCCh case    6:*/		return 0x8208DBD0;
		  /* 8208DBD0h */ case    7:  		/* nop */
		/* 8208DBD0h case    7:*/		cpu::op::nop();
		/* 8208DBD0h case    7:*/		return 0x8208DBD4;
		  /* 8208DBD4h */ case    8:  		/* bclr 20, CR0_LT */
		/* 8208DBD4h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208DBD4h case    8:*/		return 0x8208DBD8;
	}
	return 0x8208DBD8;
} // Block from 8208DBB4h-8208DBD8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8208DBD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DBD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DBD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DBD8);
		  /* 8208DBD8h */ case    0:  		/* li R3, 1 */
		/* 8208DBD8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8208DBD8h case    0:*/		return 0x8208DBDC;
		  /* 8208DBDCh */ case    1:  		/* nop */
		/* 8208DBDCh case    1:*/		cpu::op::nop();
		/* 8208DBDCh case    1:*/		return 0x8208DBE0;
		  /* 8208DBE0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8208DBE0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208DBE0h case    2:*/		return 0x8208DBE4;
	}
	return 0x8208DBE4;
} // Block from 8208DBD8h-8208DBE4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208DBE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DBE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DBE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DBE4);
		  /* 8208DBE4h */ case    0:  		/* nop */
		/* 8208DBE4h case    0:*/		cpu::op::nop();
		/* 8208DBE4h case    0:*/		return 0x8208DBE8;
	}
	return 0x8208DBE8;
} // Block from 8208DBE4h-8208DBE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208DBE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DBE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DBE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DBE8);
		  /* 8208DBE8h */ case    0:  		/* mfspr R12, LR */
		/* 8208DBE8h case    0:*/		regs.R12 = regs.LR;
		/* 8208DBE8h case    0:*/		return 0x8208DBEC;
		  /* 8208DBECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8208DBECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208DBECh case    1:*/		return 0x8208DBF0;
		  /* 8208DBF0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8208DBF0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208DBF0h case    2:*/		return 0x8208DBF4;
		  /* 8208DBF4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8208DBF4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208DBF4h case    3:*/		return 0x8208DBF8;
		  /* 8208DBF8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8208DBF8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8208DBF8h case    4:*/		return 0x8208DBFC;
		  /* 8208DBFCh */ case    5:  		/* mr R31, R3 */
		/* 8208DBFCh case    5:*/		regs.R31 = regs.R3;
		/* 8208DBFCh case    5:*/		return 0x8208DC00;
		  /* 8208DC00h */ case    6:  		/* mr R30, R4 */
		/* 8208DC00h case    6:*/		regs.R30 = regs.R4;
		/* 8208DC00h case    6:*/		return 0x8208DC04;
		  /* 8208DC04h */ case    7:  		/* bl 300 */
		/* 8208DC04h case    7:*/		regs.LR = 0x8208DC08; return 0x8208DD30;
		/* 8208DC04h case    7:*/		return 0x8208DC08;
		  /* 8208DC08h */ case    8:  		/* rlwinm R4, R31, 29, 28, 28 */
		/* 8208DC08h case    8:*/		cpu::op::rlwinm<0,29,28,28>(regs,&regs.R4,regs.R31);
		/* 8208DC08h case    8:*/		return 0x8208DC0C;
		  /* 8208DC0Ch */ case    9:  		/* mr R5, R30 */
		/* 8208DC0Ch case    9:*/		regs.R5 = regs.R30;
		/* 8208DC0Ch case    9:*/		return 0x8208DC10;
		  /* 8208DC10h */ case   10:  		/* bl -5368 */
		/* 8208DC10h case   10:*/		regs.LR = 0x8208DC14; return 0x8208C718;
		/* 8208DC10h case   10:*/		return 0x8208DC14;
		  /* 8208DC14h */ case   11:  		/* addi R1, R1, 112 */
		/* 8208DC14h case   11:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8208DC14h case   11:*/		return 0x8208DC18;
		  /* 8208DC18h */ case   12:  		/* lwz R12, <#[R1 - 8]> */
		/* 8208DC18h case   12:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208DC18h case   12:*/		return 0x8208DC1C;
		  /* 8208DC1Ch */ case   13:  		/* mtspr LR, R12 */
		/* 8208DC1Ch case   13:*/		regs.LR = regs.R12;
		/* 8208DC1Ch case   13:*/		return 0x8208DC20;
		  /* 8208DC20h */ case   14:  		/* ld R30, <#[R1 - 24]> */
		/* 8208DC20h case   14:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208DC20h case   14:*/		return 0x8208DC24;
		  /* 8208DC24h */ case   15:  		/* ld R31, <#[R1 - 16]> */
		/* 8208DC24h case   15:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208DC24h case   15:*/		return 0x8208DC28;
		  /* 8208DC28h */ case   16:  		/* bclr 20, CR0_LT */
		/* 8208DC28h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208DC28h case   16:*/		return 0x8208DC2C;
	}
	return 0x8208DC2C;
} // Block from 8208DBE8h-8208DC2Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8208DC2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DC2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DC2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DC2C);
		  /* 8208DC2Ch */ case    0:  		/* nop */
		/* 8208DC2Ch case    0:*/		cpu::op::nop();
		/* 8208DC2Ch case    0:*/		return 0x8208DC30;
	}
	return 0x8208DC30;
} // Block from 8208DC2Ch-8208DC30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208DC30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DC30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DC30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DC30);
		  /* 8208DC30h */ case    0:  		/* mfspr R12, LR */
		/* 8208DC30h case    0:*/		regs.R12 = regs.LR;
		/* 8208DC30h case    0:*/		return 0x8208DC34;
		  /* 8208DC34h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8208DC34h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208DC34h case    1:*/		return 0x8208DC38;
		  /* 8208DC38h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8208DC38h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208DC38h case    2:*/		return 0x8208DC3C;
		  /* 8208DC3Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8208DC3Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8208DC3Ch case    3:*/		return 0x8208DC40;
		  /* 8208DC40h */ case    4:  		/* mr R31, R3 */
		/* 8208DC40h case    4:*/		regs.R31 = regs.R3;
		/* 8208DC40h case    4:*/		return 0x8208DC44;
		  /* 8208DC44h */ case    5:  		/* bl 236 */
		/* 8208DC44h case    5:*/		regs.LR = 0x8208DC48; return 0x8208DD30;
		/* 8208DC44h case    5:*/		return 0x8208DC48;
		  /* 8208DC48h */ case    6:  		/* li R4, 0 */
		/* 8208DC48h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208DC48h case    6:*/		return 0x8208DC4C;
		  /* 8208DC4Ch */ case    7:  		/* mr R5, R31 */
		/* 8208DC4Ch case    7:*/		regs.R5 = regs.R31;
		/* 8208DC4Ch case    7:*/		return 0x8208DC50;
		  /* 8208DC50h */ case    8:  		/* bl -3136 */
		/* 8208DC50h case    8:*/		regs.LR = 0x8208DC54; return 0x8208D010;
		/* 8208DC50h case    8:*/		return 0x8208DC54;
		  /* 8208DC54h */ case    9:  		/* addic R11, R3, -1 */
		/* 8208DC54h case    9:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R3,0xFFFFFFFF);
		/* 8208DC54h case    9:*/		return 0x8208DC58;
		  /* 8208DC58h */ case   10:  		/* subfe R11, R11, R11 */
		/* 8208DC58h case   10:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8208DC58h case   10:*/		return 0x8208DC5C;
		  /* 8208DC5Ch */ case   11:  		/* and R3, R11, R31 */
		/* 8208DC5Ch case   11:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R31);
		/* 8208DC5Ch case   11:*/		return 0x8208DC60;
		  /* 8208DC60h */ case   12:  		/* addi R1, R1, 96 */
		/* 8208DC60h case   12:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8208DC60h case   12:*/		return 0x8208DC64;
		  /* 8208DC64h */ case   13:  		/* lwz R12, <#[R1 - 8]> */
		/* 8208DC64h case   13:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208DC64h case   13:*/		return 0x8208DC68;
		  /* 8208DC68h */ case   14:  		/* mtspr LR, R12 */
		/* 8208DC68h case   14:*/		regs.LR = regs.R12;
		/* 8208DC68h case   14:*/		return 0x8208DC6C;
		  /* 8208DC6Ch */ case   15:  		/* ld R31, <#[R1 - 16]> */
		/* 8208DC6Ch case   15:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208DC6Ch case   15:*/		return 0x8208DC70;
		  /* 8208DC70h */ case   16:  		/* bclr 20, CR0_LT */
		/* 8208DC70h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208DC70h case   16:*/		return 0x8208DC74;
	}
	return 0x8208DC74;
} // Block from 8208DC30h-8208DC74h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8208DC74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DC74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DC74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DC74);
		  /* 8208DC74h */ case    0:  		/* nop */
		/* 8208DC74h case    0:*/		cpu::op::nop();
		/* 8208DC74h case    0:*/		return 0x8208DC78;
		  /* 8208DC78h */ case    1:  		/* nop */
		/* 8208DC78h case    1:*/		cpu::op::nop();
		/* 8208DC78h case    1:*/		return 0x8208DC7C;
		  /* 8208DC7Ch */ case    2:  		/* nop */
		/* 8208DC7Ch case    2:*/		cpu::op::nop();
		/* 8208DC7Ch case    2:*/		return 0x8208DC80;
	}
	return 0x8208DC80;
} // Block from 8208DC74h-8208DC80h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208DC80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DC80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DC80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DC80);
		  /* 8208DC80h */ case    0:  		/* twi 31, R0, 20 */
		/* 8208DC80h case    0:*/		cpu::op::trap(regs, 0x8208DC80, regs.R0, 0x00000014);
		/* 8208DC80h case    0:*/		return 0x8208DC84;
		  /* 8208DC84h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8208DC84h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208DC84h case    1:*/		return 0x8208DC88;
	}
	return 0x8208DC88;
} // Block from 8208DC80h-8208DC88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208DC88h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DC88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DC88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DC88);
		  /* 8208DC88h */ case    0:  		/* cmpwi CR6, R4, -1 */
		/* 8208DC88h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 8208DC88h case    0:*/		return 0x8208DC8C;
		  /* 8208DC8Ch */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 8208DC8Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8208DC98;  }
		/* 8208DC8Ch case    1:*/		return 0x8208DC90;
		  /* 8208DC90h */ case    2:  		/* li R3, 0 */
		/* 8208DC90h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208DC90h case    2:*/		return 0x8208DC94;
		  /* 8208DC94h */ case    3:  		/* bclr 20, CR0_LT */
		/* 8208DC94h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208DC94h case    3:*/		return 0x8208DC98;
	}
	return 0x8208DC98;
} // Block from 8208DC88h-8208DC98h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208DC98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DC98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DC98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DC98);
		  /* 8208DC98h */ case    0:  		/* rldicl R11, R4, 0, 32 */
		/* 8208DC98h case    0:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R4);
		/* 8208DC98h case    0:*/		return 0x8208DC9C;
		  /* 8208DC9Ch */ case    1:  		/* mulli R11, R11, -10000 */
		/* 8208DC9Ch case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xFFFFD8F0);
		/* 8208DC9Ch case    1:*/		return 0x8208DCA0;
		  /* 8208DCA0h */ case    2:  		/* std R11, <#[R3]> */
		/* 8208DCA0h case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8208DCA0h case    2:*/		return 0x8208DCA4;
		  /* 8208DCA4h */ case    3:  		/* bclr 20, CR0_LT */
		/* 8208DCA4h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208DCA4h case    3:*/		return 0x8208DCA8;
	}
	return 0x8208DCA8;
} // Block from 8208DC98h-8208DCA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208DCA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DCA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DCA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DCA8);
		  /* 8208DCA8h */ case    0:  		/* lwz R17, <#[R6 - 11576]> */
		/* 8208DCA8h case    0:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 8208DCA8h case    0:*/		return 0x8208DCAC;
		  /* 8208DCACh */ case    1:  		/* lwz R16, <#[R4 - 15472]> */
		/* 8208DCACh case    1:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC390) );
		/* 8208DCACh case    1:*/		return 0x8208DCB0;
	}
	return 0x8208DCB0;
} // Block from 8208DCA8h-8208DCB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208DCB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DCB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DCB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DCB0);
		  /* 8208DCB0h */ case    0:  		/* mfspr R12, LR */
		/* 8208DCB0h case    0:*/		regs.R12 = regs.LR;
		/* 8208DCB0h case    0:*/		return 0x8208DCB4;
		  /* 8208DCB4h */ case    1:  		/* bl 13736 */
		/* 8208DCB4h case    1:*/		regs.LR = 0x8208DCB8; return 0x8209125C;
		/* 8208DCB4h case    1:*/		return 0x8208DCB8;
		  /* 8208DCB8h */ case    2:  		/* addi R31, R1, -128 */
		/* 8208DCB8h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFF80);
		/* 8208DCB8h case    2:*/		return 0x8208DCBC;
		  /* 8208DCBCh */ case    3:  		/* stwu R1, <#[R1 - 128]> */
		/* 8208DCBCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8208DCBCh case    3:*/		return 0x8208DCC0;
		  /* 8208DCC0h */ case    4:  		/* mr R30, R3 */
		/* 8208DCC0h case    4:*/		regs.R30 = regs.R3;
		/* 8208DCC0h case    4:*/		return 0x8208DCC4;
		  /* 8208DCC4h */ case    5:  		/* mr R29, R4 */
		/* 8208DCC4h case    5:*/		regs.R29 = regs.R4;
		/* 8208DCC4h case    5:*/		return 0x8208DCC8;
		  /* 8208DCC8h */ case    6:  		/* li R11, 0 */
		/* 8208DCC8h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8208DCC8h case    6:*/		return 0x8208DCCC;
		  /* 8208DCCCh */ case    7:  		/* stw R11, <#[R31 + 80]> */
		/* 8208DCCCh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208DCCCh case    7:*/		return 0x8208DCD0;
		  /* 8208DCD0h */ case    8:  		/* nop */
		/* 8208DCD0h case    8:*/		cpu::op::nop();
		/* 8208DCD0h case    8:*/		return 0x8208DCD4;
		  /* 8208DCD4h */ case    9:  		/* nop */
		/* 8208DCD4h case    9:*/		cpu::op::nop();
		/* 8208DCD4h case    9:*/		return 0x8208DCD8;
	}
	return 0x8208DCD8;
} // Block from 8208DCB0h-8208DCD8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8208DCD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DCD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DCD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DCD8);
		  /* 8208DCD8h */ case    0:  		/* li R3, 1 */
		/* 8208DCD8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8208DCD8h case    0:*/		return 0x8208DCDC;
		  /* 8208DCDCh */ case    1:  		/* bl -19084 */
		/* 8208DCDCh case    1:*/		regs.LR = 0x8208DCE0; return 0x82089250;
		/* 8208DCDCh case    1:*/		return 0x8208DCE0;
	}
	return 0x8208DCE0;
} // Block from 8208DCD8h-8208DCE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208DCE0h
// Function 'XMemCpyStreaming_Unaligned_Cached_Helper'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DCE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DCE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DCE0);
		  /* 8208DCE0h */ case    0:  		/* mr R3, R29 */
		/* 8208DCE0h case    0:*/		regs.R3 = regs.R29;
		/* 8208DCE0h case    0:*/		return 0x8208DCE4;
		  /* 8208DCE4h */ case    1:  		/* mtspr CTR, R30 */
		/* 8208DCE4h case    1:*/		regs.CTR = regs.R30;
		/* 8208DCE4h case    1:*/		return 0x8208DCE8;
		  /* 8208DCE8h */ case    2:  		/* bcctrl 20, CR0_LT */
		/* 8208DCE8h case    2:*/		if ( 1 ) { regs.LR = 0x8208DCEC; return (uint32)regs.CTR; }
		/* 8208DCE8h case    2:*/		return 0x8208DCEC;
		  /* 8208DCECh */ case    3:  		/* stw R3, <#[R31 + 80]> */
		/* 8208DCECh case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 8208DCECh case    3:*/		return 0x8208DCF0;
		  /* 8208DCF0h */ case    4:  		/* li R3, 0 */
		/* 8208DCF0h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208DCF0h case    4:*/		return 0x8208DCF4;
		  /* 8208DCF4h */ case    5:  		/* bl -19108 */
		/* 8208DCF4h case    5:*/		regs.LR = 0x8208DCF8; return 0x82089250;
		/* 8208DCF4h case    5:*/		return 0x8208DCF8;
	}
	return 0x8208DCF8;
} // Block from 8208DCE0h-8208DCF8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208DCF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DCF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DCF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DCF8);
		  /* 8208DCF8h */ case    0:  		/* nop */
		/* 8208DCF8h case    0:*/		cpu::op::nop();
		/* 8208DCF8h case    0:*/		return 0x8208DCFC;
		  /* 8208DCFCh */ case    1:  		/* nop */
		/* 8208DCFCh case    1:*/		cpu::op::nop();
		/* 8208DCFCh case    1:*/		return 0x8208DD00;
		  /* 8208DD00h */ case    2:  		/* nop */
		/* 8208DD00h case    2:*/		cpu::op::nop();
		/* 8208DD00h case    2:*/		return 0x8208DD04;
	}
	return 0x8208DD04;
} // Block from 8208DCF8h-8208DD04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208DD04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DD04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DD04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DD04);
		  /* 8208DD04h */ case    0:  		/* lwz R3, <#[R31 + 80]> */
		/* 8208DD04h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 8208DD04h case    0:*/		return 0x8208DD08;
		  /* 8208DD08h */ case    1:  		/* bl 1963904 */
		/* 8208DD08h case    1:*/		regs.LR = 0x8208DD0C; return 0x8226D488;
		/* 8208DD08h case    1:*/		return 0x8208DD0C;
	}
	return 0x8208DD0C;
} // Block from 8208DD04h-8208DD0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208DD0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DD0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DD0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DD0C);
		  /* 8208DD0Ch */ case    0:  		/* mfspr R12, LR */
		/* 8208DD0Ch case    0:*/		regs.R12 = regs.LR;
		/* 8208DD0Ch case    0:*/		return 0x8208DD10;
		  /* 8208DD10h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8208DD10h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208DD10h case    1:*/		return 0x8208DD14;
		  /* 8208DD14h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8208DD14h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8208DD14h case    2:*/		return 0x8208DD18;
		  /* 8208DD18h */ case    3:  		/* bl -19816 */
		/* 8208DD18h case    3:*/		regs.LR = 0x8208DD1C; return 0x82088FB0;
		/* 8208DD18h case    3:*/		return 0x8208DD1C;
		  /* 8208DD1Ch */ case    4:  		/* nop */
		/* 8208DD1Ch case    4:*/		cpu::op::nop();
		/* 8208DD1Ch case    4:*/		return 0x8208DD20;
		  /* 8208DD20h */ case    5:  		/* lwz R1, <#[R1]> */
		/* 8208DD20h case    5:*/		cpu::mem::load32z( regs, &regs.R1, (uint32)(regs.R1 + 0x00000000) );
		/* 8208DD20h case    5:*/		return 0x8208DD24;
		  /* 8208DD24h */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 8208DD24h case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208DD24h case    6:*/		return 0x8208DD28;
		  /* 8208DD28h */ case    7:  		/* mtspr LR, R12 */
		/* 8208DD28h case    7:*/		regs.LR = regs.R12;
		/* 8208DD28h case    7:*/		return 0x8208DD2C;
		  /* 8208DD2Ch */ case    8:  		/* bclr 20, CR0_LT */
		/* 8208DD2Ch case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208DD2Ch case    8:*/		return 0x8208DD30;
	}
	return 0x8208DD30;
} // Block from 8208DD0Ch-8208DD30h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8208DD30h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DD30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DD30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DD30);
		  /* 8208DD30h */ case    0:  		/* lis R11, -32215 */
		/* 8208DD30h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8208DD30h case    0:*/		return 0x8208DD34;
		  /* 8208DD34h */ case    1:  		/* lwz R3, <#[R11 - 25544]> */
		/* 8208DD34h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFF9C38) );
		/* 8208DD34h case    1:*/		return 0x8208DD38;
		  /* 8208DD38h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8208DD38h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208DD38h case    2:*/		return 0x8208DD3C;
	}
	return 0x8208DD3C;
} // Block from 8208DD30h-8208DD3Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208DD3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DD3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DD3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DD3C);
		  /* 8208DD3Ch */ case    0:  		/* nop */
		/* 8208DD3Ch case    0:*/		cpu::op::nop();
		/* 8208DD3Ch case    0:*/		return 0x8208DD40;
	}
	return 0x8208DD40;
} // Block from 8208DD3Ch-8208DD40h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208DD40h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DD40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DD40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DD40);
		  /* 8208DD40h */ case    0:  		/* li R11, 0 */
		/* 8208DD40h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8208DD40h case    0:*/		return 0x8208DD44;
		  /* 8208DD44h */ case    1:  		/* stw R11, <#[R3]> */
		/* 8208DD44h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8208DD44h case    1:*/		return 0x8208DD48;
		  /* 8208DD48h */ case    2:  		/* stw R11, <#[R3 + 4]> */
		/* 8208DD48h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8208DD48h case    2:*/		return 0x8208DD4C;
		  /* 8208DD4Ch */ case    3:  		/* stw R11, <#[R3 + 8]> */
		/* 8208DD4Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8208DD4Ch case    3:*/		return 0x8208DD50;
		  /* 8208DD50h */ case    4:  		/* stw R11, <#[R3 + 12]> */
		/* 8208DD50h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8208DD50h case    4:*/		return 0x8208DD54;
		  /* 8208DD54h */ case    5:  		/* stw R11, <#[R3 + 16]> */
		/* 8208DD54h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8208DD54h case    5:*/		return 0x8208DD58;
		  /* 8208DD58h */ case    6:  		/* stw R11, <#[R3 + 20]> */
		/* 8208DD58h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 8208DD58h case    6:*/		return 0x8208DD5C;
		  /* 8208DD5Ch */ case    7:  		/* stw R11, <#[R3 + 24]> */
		/* 8208DD5Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 8208DD5Ch case    7:*/		return 0x8208DD60;
		  /* 8208DD60h */ case    8:  		/* bclr 20, CR0_LT */
		/* 8208DD60h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208DD60h case    8:*/		return 0x8208DD64;
	}
	return 0x8208DD64;
} // Block from 8208DD40h-8208DD64h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8208DD64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DD64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DD64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DD64);
		  /* 8208DD64h */ case    0:  		/* nop */
		/* 8208DD64h case    0:*/		cpu::op::nop();
		/* 8208DD64h case    0:*/		return 0x8208DD68;
	}
	return 0x8208DD68;
} // Block from 8208DD64h-8208DD68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208DD68h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DD68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DD68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DD68);
		  /* 8208DD68h */ case    0:  		/* mfspr R12, LR */
		/* 8208DD68h case    0:*/		regs.R12 = regs.LR;
		/* 8208DD68h case    0:*/		return 0x8208DD6C;
		  /* 8208DD6Ch */ case    1:  		/* bl 13548 */
		/* 8208DD6Ch case    1:*/		regs.LR = 0x8208DD70; return 0x82091258;
		/* 8208DD6Ch case    1:*/		return 0x8208DD70;
		  /* 8208DD70h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8208DD70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8208DD70h case    2:*/		return 0x8208DD74;
		  /* 8208DD74h */ case    3:  		/* lwz R11, <#[R3 + 16]> */
		/* 8208DD74h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8208DD74h case    3:*/		return 0x8208DD78;
		  /* 8208DD78h */ case    4:  		/* mr R31, R3 */
		/* 8208DD78h case    4:*/		regs.R31 = regs.R3;
		/* 8208DD78h case    4:*/		return 0x8208DD7C;
		  /* 8208DD7Ch */ case    5:  		/* mr R28, R4 */
		/* 8208DD7Ch case    5:*/		regs.R28 = regs.R4;
		/* 8208DD7Ch case    5:*/		return 0x8208DD80;
		  /* 8208DD80h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 8208DD80h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208DD80h case    6:*/		return 0x8208DD84;
		  /* 8208DD84h */ case    7:  		/* bc 12, CR6_EQ, 80 */
		/* 8208DD84h case    7:*/		if ( regs.CR[6].eq ) { return 0x8208DDD4;  }
		/* 8208DD84h case    7:*/		return 0x8208DD88;
		  /* 8208DD88h */ case    8:  		/* cmplwi CR6, R4, 0 */
		/* 8208DD88h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8208DD88h case    8:*/		return 0x8208DD8C;
		  /* 8208DD8Ch */ case    9:  		/* bc 12, CR6_EQ, 72 */
		/* 8208DD8Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x8208DDD4;  }
		/* 8208DD8Ch case    9:*/		return 0x8208DD90;
		  /* 8208DD90h */ case   10:  		/* lwz R11, <#[R3 + 20]> */
		/* 8208DD90h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 8208DD90h case   10:*/		return 0x8208DD94;
		  /* 8208DD94h */ case   11:  		/* li R30, 0 */
		/* 8208DD94h case   11:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8208DD94h case   11:*/		return 0x8208DD98;
		  /* 8208DD98h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 8208DD98h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208DD98h case   12:*/		return 0x8208DD9C;
		  /* 8208DD9Ch */ case   13:  		/* bc 4, CR6_GT, 56 */
		/* 8208DD9Ch case   13:*/		if ( !regs.CR[6].gt ) { return 0x8208DDD4;  }
		/* 8208DD9Ch case   13:*/		return 0x8208DDA0;
		  /* 8208DDA0h */ case   14:  		/* li R29, 0 */
		/* 8208DDA0h case   14:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8208DDA0h case   14:*/		return 0x8208DDA4;
		  /* 8208DDA4h */ case   15:  		/* lwz R11, <#[R31 + 16]> */
		/* 8208DDA4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8208DDA4h case   15:*/		return 0x8208DDA8;
		  /* 8208DDA8h */ case   16:  		/* mr R3, R28 */
		/* 8208DDA8h case   16:*/		regs.R3 = regs.R28;
		/* 8208DDA8h case   16:*/		return 0x8208DDAC;
		  /* 8208DDACh */ case   17:  		/* add R11, R29, R11 */
		/* 8208DDACh case   17:*/		cpu::op::add<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 8208DDACh case   17:*/		return 0x8208DDB0;
		  /* 8208DDB0h */ case   18:  		/* lwz R4, <#[R11 + 12]> */
		/* 8208DDB0h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000000C) );
		/* 8208DDB0h case   18:*/		return 0x8208DDB4;
		  /* 8208DDB4h */ case   19:  		/* bl 22140 */
		/* 8208DDB4h case   19:*/		regs.LR = 0x8208DDB8; return 0x82093430;
		/* 8208DDB4h case   19:*/		return 0x8208DDB8;
		  /* 8208DDB8h */ case   20:  		/* cmpwi CR0, R3, 0 */
		/* 8208DDB8h case   20:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208DDB8h case   20:*/		return 0x8208DDBC;
		  /* 8208DDBCh */ case   21:  		/* bc 12, CR0_EQ, 36 */
		/* 8208DDBCh case   21:*/		if ( regs.CR[0].eq ) { return 0x8208DDE0;  }
		/* 8208DDBCh case   21:*/		return 0x8208DDC0;
		  /* 8208DDC0h */ case   22:  		/* lwz R11, <#[R31 + 20]> */
		/* 8208DDC0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8208DDC0h case   22:*/		return 0x8208DDC4;
		  /* 8208DDC4h */ case   23:  		/* addi R30, R30, 1 */
		/* 8208DDC4h case   23:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8208DDC4h case   23:*/		return 0x8208DDC8;
		  /* 8208DDC8h */ case   24:  		/* addi R29, R29, 16 */
		/* 8208DDC8h case   24:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x10);
		/* 8208DDC8h case   24:*/		return 0x8208DDCC;
		  /* 8208DDCCh */ case   25:  		/* cmplw CR6, R30, R11 */
		/* 8208DDCCh case   25:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8208DDCCh case   25:*/		return 0x8208DDD0;
		  /* 8208DDD0h */ case   26:  		/* bc 12, CR6_LT, -44 */
		/* 8208DDD0h case   26:*/		if ( regs.CR[6].lt ) { return 0x8208DDA4;  }
		/* 8208DDD0h case   26:*/		return 0x8208DDD4;
	}
	return 0x8208DDD4;
} // Block from 8208DD68h-8208DDD4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8208DDD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DDD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DDD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DDD4);
		  /* 8208DDD4h */ case    0:  		/* li R3, 0 */
		/* 8208DDD4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208DDD4h case    0:*/		return 0x8208DDD8;
		  /* 8208DDD8h */ case    1:  		/* addi R1, R1, 128 */
		/* 8208DDD8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8208DDD8h case    1:*/		return 0x8208DDDC;
		  /* 8208DDDCh */ case    2:  		/* b 13516 */
		/* 8208DDDCh case    2:*/		return 0x820912A8;
		/* 8208DDDCh case    2:*/		return 0x8208DDE0;
	}
	return 0x8208DDE0;
} // Block from 8208DDD4h-8208DDE0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208DDE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DDE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DDE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DDE0);
		  /* 8208DDE0h */ case    0:  		/* lwz R9, <#[R31 + 16]> */
		/* 8208DDE0h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 8208DDE0h case    0:*/		return 0x8208DDE4;
		  /* 8208DDE4h */ case    1:  		/* rlwinm R11, R30, 4, 0, 27 */
		/* 8208DDE4h case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R30);
		/* 8208DDE4h case    1:*/		return 0x8208DDE8;
		  /* 8208DDE8h */ case    2:  		/* lwz R10, <#[R31]> */
		/* 8208DDE8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8208DDE8h case    2:*/		return 0x8208DDEC;
		  /* 8208DDECh */ case    3:  		/* add R11, R11, R9 */
		/* 8208DDECh case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8208DDECh case    3:*/		return 0x8208DDF0;
		  /* 8208DDF0h */ case    4:  		/* lwz R11, <#[R11 + 4]> */
		/* 8208DDF0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8208DDF0h case    4:*/		return 0x8208DDF4;
		  /* 8208DDF4h */ case    5:  		/* add R3, R11, R10 */
		/* 8208DDF4h case    5:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 8208DDF4h case    5:*/		return 0x8208DDF8;
		  /* 8208DDF8h */ case    6:  		/* b -32 */
		/* 8208DDF8h case    6:*/		return 0x8208DDD8;
		/* 8208DDF8h case    6:*/		return 0x8208DDFC;
		  /* 8208DDFCh */ case    7:  		/* nop */
		/* 8208DDFCh case    7:*/		cpu::op::nop();
		/* 8208DDFCh case    7:*/		return 0x8208DE00;
	}
	return 0x8208DE00;
} // Block from 8208DDE0h-8208DE00h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8208DE00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DE00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DE00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DE00);
		  /* 8208DE00h */ case    0:  		/* mfspr R12, LR */
		/* 8208DE00h case    0:*/		regs.R12 = regs.LR;
		/* 8208DE00h case    0:*/		return 0x8208DE04;
		  /* 8208DE04h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8208DE04h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208DE04h case    1:*/		return 0x8208DE08;
		  /* 8208DE08h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8208DE08h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208DE08h case    2:*/		return 0x8208DE0C;
		  /* 8208DE0Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8208DE0Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208DE0Ch case    3:*/		return 0x8208DE10;
		  /* 8208DE10h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8208DE10h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8208DE10h case    4:*/		return 0x8208DE14;
		  /* 8208DE14h */ case    5:  		/* mr R31, R3 */
		/* 8208DE14h case    5:*/		regs.R31 = regs.R3;
		/* 8208DE14h case    5:*/		return 0x8208DE18;
		  /* 8208DE18h */ case    6:  		/* lwz R3, <#[R3]> */
		/* 8208DE18h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 8208DE18h case    6:*/		return 0x8208DE1C;
		  /* 8208DE1Ch */ case    7:  		/* bl 17740 */
		/* 8208DE1Ch case    7:*/		regs.LR = 0x8208DE20; return 0x82092368;
		/* 8208DE1Ch case    7:*/		return 0x8208DE20;
		  /* 8208DE20h */ case    8:  		/* lwz R3, <#[R31 + 8]> */
		/* 8208DE20h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 8208DE20h case    8:*/		return 0x8208DE24;
		  /* 8208DE24h */ case    9:  		/* li R30, 0 */
		/* 8208DE24h case    9:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8208DE24h case    9:*/		return 0x8208DE28;
		  /* 8208DE28h */ case   10:  		/* cmplwi CR6, R3, 0 */
		/* 8208DE28h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8208DE28h case   10:*/		return 0x8208DE2C;
		  /* 8208DE2Ch */ case   11:  		/* stw R30, <#[R31]> */
		/* 8208DE2Ch case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000000) );
		/* 8208DE2Ch case   11:*/		return 0x8208DE30;
		  /* 8208DE30h */ case   12:  		/* stw R30, <#[R31 + 4]> */
		/* 8208DE30h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 8208DE30h case   12:*/		return 0x8208DE34;
		  /* 8208DE34h */ case   13:  		/* bc 12, CR6_EQ, 12 */
		/* 8208DE34h case   13:*/		if ( regs.CR[6].eq ) { return 0x8208DE40;  }
		/* 8208DE34h case   13:*/		return 0x8208DE38;
		  /* 8208DE38h */ case   14:  		/* lis R4, -32641 */
		/* 8208DE38h case   14:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF807F);
		/* 8208DE38h case   14:*/		return 0x8208DE3C;
		  /* 8208DE3Ch */ case   15:  		/* bl -23300 */
		/* 8208DE3Ch case   15:*/		regs.LR = 0x8208DE40; return 0x82088338;
		/* 8208DE3Ch case   15:*/		return 0x8208DE40;
	}
	return 0x8208DE40;
} // Block from 8208DE00h-8208DE40h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8208DE40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DE40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DE40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DE40);
		  /* 8208DE40h */ case    0:  		/* stw R30, <#[R31 + 8]> */
		/* 8208DE40h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000008) );
		/* 8208DE40h case    0:*/		return 0x8208DE44;
		  /* 8208DE44h */ case    1:  		/* stw R30, <#[R31 + 12]> */
		/* 8208DE44h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 8208DE44h case    1:*/		return 0x8208DE48;
		  /* 8208DE48h */ case    2:  		/* stw R30, <#[R31 + 16]> */
		/* 8208DE48h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000010) );
		/* 8208DE48h case    2:*/		return 0x8208DE4C;
		  /* 8208DE4Ch */ case    3:  		/* stw R30, <#[R31 + 20]> */
		/* 8208DE4Ch case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000014) );
		/* 8208DE4Ch case    3:*/		return 0x8208DE50;
		  /* 8208DE50h */ case    4:  		/* stw R30, <#[R31 + 24]> */
		/* 8208DE50h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000018) );
		/* 8208DE50h case    4:*/		return 0x8208DE54;
		  /* 8208DE54h */ case    5:  		/* addi R1, R1, 112 */
		/* 8208DE54h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8208DE54h case    5:*/		return 0x8208DE58;
		  /* 8208DE58h */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 8208DE58h case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208DE58h case    6:*/		return 0x8208DE5C;
		  /* 8208DE5Ch */ case    7:  		/* mtspr LR, R12 */
		/* 8208DE5Ch case    7:*/		regs.LR = regs.R12;
		/* 8208DE5Ch case    7:*/		return 0x8208DE60;
		  /* 8208DE60h */ case    8:  		/* ld R30, <#[R1 - 24]> */
		/* 8208DE60h case    8:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208DE60h case    8:*/		return 0x8208DE64;
		  /* 8208DE64h */ case    9:  		/* ld R31, <#[R1 - 16]> */
		/* 8208DE64h case    9:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208DE64h case    9:*/		return 0x8208DE68;
		  /* 8208DE68h */ case   10:  		/* bclr 20, CR0_LT */
		/* 8208DE68h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208DE68h case   10:*/		return 0x8208DE6C;
	}
	return 0x8208DE6C;
} // Block from 8208DE40h-8208DE6Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8208DE6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DE6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DE6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DE6C);
		  /* 8208DE6Ch */ case    0:  		/* nop */
		/* 8208DE6Ch case    0:*/		cpu::op::nop();
		/* 8208DE6Ch case    0:*/		return 0x8208DE70;
		  /* 8208DE70h */ case    1:  		/* lwz R3, <#[R3 + 24]> */
		/* 8208DE70h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000018) );
		/* 8208DE70h case    1:*/		return 0x8208DE74;
		  /* 8208DE74h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8208DE74h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208DE74h case    2:*/		return 0x8208DE78;
	}
	return 0x8208DE78;
} // Block from 8208DE6Ch-8208DE78h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208DE78h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DE78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DE78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DE78);
		  /* 8208DE78h */ case    0:  		/* b -120 */
		/* 8208DE78h case    0:*/		return 0x8208DE00;
		/* 8208DE78h case    0:*/		return 0x8208DE7C;
		  /* 8208DE7Ch */ case    1:  		/* nop */
		/* 8208DE7Ch case    1:*/		cpu::op::nop();
		/* 8208DE7Ch case    1:*/		return 0x8208DE80;
	}
	return 0x8208DE80;
} // Block from 8208DE78h-8208DE80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208DE80h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DE80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DE80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DE80);
		  /* 8208DE80h */ case    0:  		/* mfspr R12, LR */
		/* 8208DE80h case    0:*/		regs.R12 = regs.LR;
		/* 8208DE80h case    0:*/		return 0x8208DE84;
		  /* 8208DE84h */ case    1:  		/* bl 13272 */
		/* 8208DE84h case    1:*/		regs.LR = 0x8208DE88; return 0x8209125C;
		/* 8208DE84h case    1:*/		return 0x8208DE88;
		  /* 8208DE88h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8208DE88h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8208DE88h case    2:*/		return 0x8208DE8C;
		  /* 8208DE8Ch */ case    3:  		/* mr R29, R4 */
		/* 8208DE8Ch case    3:*/		regs.R29 = regs.R4;
		/* 8208DE8Ch case    3:*/		return 0x8208DE90;
		  /* 8208DE90h */ case    4:  		/* mr R31, R3 */
		/* 8208DE90h case    4:*/		regs.R31 = regs.R3;
		/* 8208DE90h case    4:*/		return 0x8208DE94;
		  /* 8208DE94h */ case    5:  		/* li R9, 0 */
		/* 8208DE94h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8208DE94h case    5:*/		return 0x8208DE98;
		  /* 8208DE98h */ case    6:  		/* li R8, 1 */
		/* 8208DE98h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8208DE98h case    6:*/		return 0x8208DE9C;
		  /* 8208DE9Ch */ case    7:  		/* li R7, 3 */
		/* 8208DE9Ch case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 8208DE9Ch case    7:*/		return 0x8208DEA0;
		  /* 8208DEA0h */ case    8:  		/* li R6, 0 */
		/* 8208DEA0h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8208DEA0h case    8:*/		return 0x8208DEA4;
		  /* 8208DEA4h */ case    9:  		/* li R5, 1 */
		/* 8208DEA4h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8208DEA4h case    9:*/		return 0x8208DEA8;
		  /* 8208DEA8h */ case   10:  		/* lis R4, -32768 */
		/* 8208DEA8h case   10:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8000);
		/* 8208DEA8h case   10:*/		return 0x8208DEAC;
		  /* 8208DEACh */ case   11:  		/* mr R3, R29 */
		/* 8208DEACh case   11:*/		regs.R3 = regs.R29;
		/* 8208DEACh case   11:*/		return 0x8208DEB0;
		  /* 8208DEB0h */ case   12:  		/* bl -20928 */
		/* 8208DEB0h case   12:*/		regs.LR = 0x8208DEB4; return 0x82088CF0;
		/* 8208DEB0h case   12:*/		return 0x8208DEB4;
		  /* 8208DEB4h */ case   13:  		/* mr R30, R3 */
		/* 8208DEB4h case   13:*/		regs.R30 = regs.R3;
		/* 8208DEB4h case   13:*/		return 0x8208DEB8;
		  /* 8208DEB8h */ case   14:  		/* cmpwi CR6, R3, -1 */
		/* 8208DEB8h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8208DEB8h case   14:*/		return 0x8208DEBC;
		  /* 8208DEBCh */ case   15:  		/* bc 4, CR6_EQ, 48 */
		/* 8208DEBCh case   15:*/		if ( !regs.CR[6].eq ) { return 0x8208DEEC;  }
		/* 8208DEBCh case   15:*/		return 0x8208DEC0;
		  /* 8208DEC0h */ case   16:  		/* lis R11, -32255 */
		/* 8208DEC0h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208DEC0h case   16:*/		return 0x8208DEC4;
		  /* 8208DEC4h */ case   17:  		/* lis R10, -32256 */
		/* 8208DEC4h case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8208DEC4h case   17:*/		return 0x8208DEC8;
		  /* 8208DEC8h */ case   18:  		/* addi R4, R11, -28248 */
		/* 8208DEC8h case   18:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFF91A8);
		/* 8208DEC8h case   18:*/		return 0x8208DECC;
		  /* 8208DECCh */ case   19:  		/* addi R3, R10, 2596 */
		/* 8208DECCh case   19:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 8208DECCh case   19:*/		return 0x8208DED0;
		  /* 8208DED0h */ case   20:  		/* li R5, 118 */
		/* 8208DED0h case   20:*/		cpu::op::li<0>(regs,&regs.R5,0x76);
		/* 8208DED0h case   20:*/		return 0x8208DED4;
		  /* 8208DED4h */ case   21:  		/* bl 6756 */
		/* 8208DED4h case   21:*/		regs.LR = 0x8208DED8; return 0x8208F938;
		/* 8208DED4h case   21:*/		return 0x8208DED8;
		  /* 8208DED8h */ case   22:  		/* lis R11, -32255 */
		/* 8208DED8h case   22:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208DED8h case   22:*/		return 0x8208DEDC;
		  /* 8208DEDCh */ case   23:  		/* mr R4, R29 */
		/* 8208DEDCh case   23:*/		regs.R4 = regs.R29;
		/* 8208DEDCh case   23:*/		return 0x8208DEE0;
		  /* 8208DEE0h */ case   24:  		/* addi R3, R11, -28272 */
		/* 8208DEE0h case   24:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF9190);
		/* 8208DEE0h case   24:*/		return 0x8208DEE4;
		  /* 8208DEE4h */ case   25:  		/* bl 6740 */
		/* 8208DEE4h case   25:*/		regs.LR = 0x8208DEE8; return 0x8208F938;
		/* 8208DEE4h case   25:*/		return 0x8208DEE8;
		  /* 8208DEE8h */ case   26:  		/* b 580 */
		/* 8208DEE8h case   26:*/		return 0x8208E12C;
		/* 8208DEE8h case   26:*/		return 0x8208DEEC;
	}
	return 0x8208DEEC;
} // Block from 8208DE80h-8208DEECh (27 instructions)

//////////////////////////////////////////////////////
// Block at 8208DEECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DEEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DEEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DEEC);
		  /* 8208DEECh */ case    0:  		/* li R7, 0 */
		/* 8208DEECh case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8208DEECh case    0:*/		return 0x8208DEF0;
		  /* 8208DEF0h */ case    1:  		/* addi R6, R1, 80 */
		/* 8208DEF0h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 8208DEF0h case    1:*/		return 0x8208DEF4;
		  /* 8208DEF4h */ case    2:  		/* li R5, 12 */
		/* 8208DEF4h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0xC);
		/* 8208DEF4h case    2:*/		return 0x8208DEF8;
		  /* 8208DEF8h */ case    3:  		/* addi R4, R1, 88 */
		/* 8208DEF8h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x58);
		/* 8208DEF8h case    3:*/		return 0x8208DEFC;
		  /* 8208DEFCh */ case    4:  		/* mr R3, R30 */
		/* 8208DEFCh case    4:*/		regs.R3 = regs.R30;
		/* 8208DEFCh case    4:*/		return 0x8208DF00;
		  /* 8208DF00h */ case    5:  		/* bl 1937888 */
		/* 8208DF00h case    5:*/		regs.LR = 0x8208DF04; return 0x822670E0;
		/* 8208DF00h case    5:*/		return 0x8208DF04;
		  /* 8208DF04h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 8208DF04h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208DF04h case    6:*/		return 0x8208DF08;
		  /* 8208DF08h */ case    7:  		/* bc 4, CR0_EQ, 48 */
		/* 8208DF08h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8208DF38;  }
		/* 8208DF08h case    7:*/		return 0x8208DF0C;
		  /* 8208DF0Ch */ case    8:  		/* lis R11, -32255 */
		/* 8208DF0Ch case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208DF0Ch case    8:*/		return 0x8208DF10;
		  /* 8208DF10h */ case    9:  		/* lis R10, -32256 */
		/* 8208DF10h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8208DF10h case    9:*/		return 0x8208DF14;
		  /* 8208DF14h */ case   10:  		/* addi R4, R11, -28248 */
		/* 8208DF14h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFF91A8);
		/* 8208DF14h case   10:*/		return 0x8208DF18;
		  /* 8208DF18h */ case   11:  		/* addi R3, R10, 2596 */
		/* 8208DF18h case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 8208DF18h case   11:*/		return 0x8208DF1C;
		  /* 8208DF1Ch */ case   12:  		/* li R5, 126 */
		/* 8208DF1Ch case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x7E);
		/* 8208DF1Ch case   12:*/		return 0x8208DF20;
		  /* 8208DF20h */ case   13:  		/* bl 6680 */
		/* 8208DF20h case   13:*/		regs.LR = 0x8208DF24; return 0x8208F938;
		/* 8208DF20h case   13:*/		return 0x8208DF24;
		  /* 8208DF24h */ case   14:  		/* lis R11, -32255 */
		/* 8208DF24h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208DF24h case   14:*/		return 0x8208DF28;
		  /* 8208DF28h */ case   15:  		/* mr R4, R29 */
		/* 8208DF28h case   15:*/		regs.R4 = regs.R29;
		/* 8208DF28h case   15:*/		return 0x8208DF2C;
		  /* 8208DF2Ch */ case   16:  		/* addi R3, R11, -28312 */
		/* 8208DF2Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF9168);
		/* 8208DF2Ch case   16:*/		return 0x8208DF30;
		  /* 8208DF30h */ case   17:  		/* bl 6664 */
		/* 8208DF30h case   17:*/		regs.LR = 0x8208DF34; return 0x8208F938;
		/* 8208DF30h case   17:*/		return 0x8208DF34;
		  /* 8208DF34h */ case   18:  		/* b 496 */
		/* 8208DF34h case   18:*/		return 0x8208E124;
		/* 8208DF34h case   18:*/		return 0x8208DF38;
	}
	return 0x8208DF38;
} // Block from 8208DEECh-8208DF38h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8208DF38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DF38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DF38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DF38);
		  /* 8208DF38h */ case    0:  		/* lis R11, 22608 */
		/* 8208DF38h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x5850);
		/* 8208DF38h case    0:*/		return 0x8208DF3C;
		  /* 8208DF3Ch */ case    1:  		/* lwz R10, <#[R1 + 88]> */
		/* 8208DF3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 8208DF3Ch case    1:*/		return 0x8208DF40;
		  /* 8208DF40h */ case    2:  		/* ori R11, R11, 21042 */
		/* 8208DF40h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x5232);
		/* 8208DF40h case    2:*/		return 0x8208DF44;
		  /* 8208DF44h */ case    3:  		/* cmplw CR6, R10, R11 */
		/* 8208DF44h case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208DF44h case    3:*/		return 0x8208DF48;
		  /* 8208DF48h */ case    4:  		/* bc 12, CR6_EQ, 44 */
		/* 8208DF48h case    4:*/		if ( regs.CR[6].eq ) { return 0x8208DF74;  }
		/* 8208DF48h case    4:*/		return 0x8208DF4C;
		  /* 8208DF4Ch */ case    5:  		/* lis R11, -32255 */
		/* 8208DF4Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208DF4Ch case    5:*/		return 0x8208DF50;
		  /* 8208DF50h */ case    6:  		/* lis R10, -32256 */
		/* 8208DF50h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8208DF50h case    6:*/		return 0x8208DF54;
		  /* 8208DF54h */ case    7:  		/* addi R4, R11, -28248 */
		/* 8208DF54h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFF91A8);
		/* 8208DF54h case    7:*/		return 0x8208DF58;
		  /* 8208DF58h */ case    8:  		/* addi R3, R10, 2596 */
		/* 8208DF58h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 8208DF58h case    8:*/		return 0x8208DF5C;
		  /* 8208DF5Ch */ case    9:  		/* li R5, 137 */
		/* 8208DF5Ch case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x89);
		/* 8208DF5Ch case    9:*/		return 0x8208DF60;
		  /* 8208DF60h */ case   10:  		/* bl 6616 */
		/* 8208DF60h case   10:*/		regs.LR = 0x8208DF64; return 0x8208F938;
		/* 8208DF60h case   10:*/		return 0x8208DF64;
		  /* 8208DF64h */ case   11:  		/* lis R11, -32255 */
		/* 8208DF64h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208DF64h case   11:*/		return 0x8208DF68;
		  /* 8208DF68h */ case   12:  		/* lwz R4, <#[R1 + 88]> */
		/* 8208DF68h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000058) );
		/* 8208DF68h case   12:*/		return 0x8208DF6C;
		  /* 8208DF6Ch */ case   13:  		/* addi R3, R11, -28372 */
		/* 8208DF6Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF912C);
		/* 8208DF6Ch case   13:*/		return 0x8208DF70;
		  /* 8208DF70h */ case   14:  		/* b -64 */
		/* 8208DF70h case   14:*/		return 0x8208DF30;
		/* 8208DF70h case   14:*/		return 0x8208DF74;
	}
	return 0x8208DF74;
} // Block from 8208DF38h-8208DF74h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8208DF74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DF74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DF74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DF74);
		  /* 8208DF74h */ case    0:  		/* lwz R11, <#[R1 + 96]> */
		/* 8208DF74h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 8208DF74h case    0:*/		return 0x8208DF78;
		  /* 8208DF78h */ case    1:  		/* lwz R3, <#[R1 + 92]> */
		/* 8208DF78h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000005C) );
		/* 8208DF78h case    1:*/		return 0x8208DF7C;
		  /* 8208DF7Ch */ case    2:  		/* stw R11, <#[R31 + 12]> */
		/* 8208DF7Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8208DF7Ch case    2:*/		return 0x8208DF80;
		  /* 8208DF80h */ case    3:  		/* stw R3, <#[R31 + 4]> */
		/* 8208DF80h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 8208DF80h case    3:*/		return 0x8208DF84;
		  /* 8208DF84h */ case    4:  		/* bl 22468 */
		/* 8208DF84h case    4:*/		regs.LR = 0x8208DF88; return 0x82093748;
		/* 8208DF84h case    4:*/		return 0x8208DF88;
		  /* 8208DF88h */ case    5:  		/* stw R3, <#[R31]> */
		/* 8208DF88h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8208DF88h case    5:*/		return 0x8208DF8C;
		  /* 8208DF8Ch */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 8208DF8Ch case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8208DF8Ch case    6:*/		return 0x8208DF90;
		  /* 8208DF90h */ case    7:  		/* bc 4, CR0_EQ, 52 */
		/* 8208DF90h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8208DFC4;  }
		/* 8208DF90h case    7:*/		return 0x8208DF94;
		  /* 8208DF94h */ case    8:  		/* lis R11, -32255 */
		/* 8208DF94h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208DF94h case    8:*/		return 0x8208DF98;
		  /* 8208DF98h */ case    9:  		/* lis R10, -32256 */
		/* 8208DF98h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8208DF98h case    9:*/		return 0x8208DF9C;
		  /* 8208DF9Ch */ case   10:  		/* addi R4, R11, -28248 */
		/* 8208DF9Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFF91A8);
		/* 8208DF9Ch case   10:*/		return 0x8208DFA0;
		  /* 8208DFA0h */ case   11:  		/* addi R3, R10, 2596 */
		/* 8208DFA0h case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 8208DFA0h case   11:*/		return 0x8208DFA4;
		  /* 8208DFA4h */ case   12:  		/* li R5, 150 */
		/* 8208DFA4h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x96);
		/* 8208DFA4h case   12:*/		return 0x8208DFA8;
		  /* 8208DFA8h */ case   13:  		/* bl 6544 */
		/* 8208DFA8h case   13:*/		regs.LR = 0x8208DFAC; return 0x8208F938;
		/* 8208DFA8h case   13:*/		return 0x8208DFAC;
		  /* 8208DFACh */ case   14:  		/* lis R11, -32255 */
		/* 8208DFACh case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208DFACh case   14:*/		return 0x8208DFB0;
		  /* 8208DFB0h */ case   15:  		/* addi R3, R11, -28408 */
		/* 8208DFB0h case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF9108);
		/* 8208DFB0h case   15:*/		return 0x8208DFB4;
		  /* 8208DFB4h */ case   16:  		/* bl 6532 */
		/* 8208DFB4h case   16:*/		regs.LR = 0x8208DFB8; return 0x8208F938;
		/* 8208DFB4h case   16:*/		return 0x8208DFB8;
		  /* 8208DFB8h */ case   17:  		/* li R11, 0 */
		/* 8208DFB8h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8208DFB8h case   17:*/		return 0x8208DFBC;
		  /* 8208DFBCh */ case   18:  		/* stw R11, <#[R31 + 4]> */
		/* 8208DFBCh case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8208DFBCh case   18:*/		return 0x8208DFC0;
		  /* 8208DFC0h */ case   19:  		/* b 364 */
		/* 8208DFC0h case   19:*/		return 0x8208E12C;
		/* 8208DFC0h case   19:*/		return 0x8208DFC4;
	}
	return 0x8208DFC4;
} // Block from 8208DF74h-8208DFC4h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8208DFC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208DFC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208DFC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208DFC4);
		  /* 8208DFC4h */ case    0:  		/* lis R4, -17281 */
		/* 8208DFC4h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFBC7F);
		/* 8208DFC4h case    0:*/		return 0x8208DFC8;
		  /* 8208DFC8h */ case    1:  		/* lwz R3, <#[R31 + 12]> */
		/* 8208DFC8h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 8208DFC8h case    1:*/		return 0x8208DFCC;
		  /* 8208DFCCh */ case    2:  		/* bl -24012 */
		/* 8208DFCCh case    2:*/		regs.LR = 0x8208DFD0; return 0x82088200;
		/* 8208DFCCh case    2:*/		return 0x8208DFD0;
		  /* 8208DFD0h */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 8208DFD0h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8208DFD0h case    3:*/		return 0x8208DFD4;
		  /* 8208DFD4h */ case    4:  		/* stw R3, <#[R31 + 8]> */
		/* 8208DFD4h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 8208DFD4h case    4:*/		return 0x8208DFD8;
		  /* 8208DFD8h */ case    5:  		/* bc 4, CR0_EQ, 68 */
		/* 8208DFD8h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8208E01C;  }
		/* 8208DFD8h case    5:*/		return 0x8208DFDC;
		  /* 8208DFDCh */ case    6:  		/* lis R11, -32255 */
		/* 8208DFDCh case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208DFDCh case    6:*/		return 0x8208DFE0;
		  /* 8208DFE0h */ case    7:  		/* lis R10, -32256 */
		/* 8208DFE0h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8208DFE0h case    7:*/		return 0x8208DFE4;
		  /* 8208DFE4h */ case    8:  		/* addi R4, R11, -28248 */
		/* 8208DFE4h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFF91A8);
		/* 8208DFE4h case    8:*/		return 0x8208DFE8;
		  /* 8208DFE8h */ case    9:  		/* addi R3, R10, 2596 */
		/* 8208DFE8h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 8208DFE8h case    9:*/		return 0x8208DFEC;
		  /* 8208DFECh */ case   10:  		/* li R5, 157 */
		/* 8208DFECh case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x9D);
		/* 8208DFECh case   10:*/		return 0x8208DFF0;
		  /* 8208DFF0h */ case   11:  		/* bl 6472 */
		/* 8208DFF0h case   11:*/		regs.LR = 0x8208DFF4; return 0x8208F938;
		/* 8208DFF0h case   11:*/		return 0x8208DFF4;
		  /* 8208DFF4h */ case   12:  		/* lis R11, -32255 */
		/* 8208DFF4h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208DFF4h case   12:*/		return 0x8208DFF8;
		  /* 8208DFF8h */ case   13:  		/* addi R3, R11, -28448 */
		/* 8208DFF8h case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF90E0);
		/* 8208DFF8h case   13:*/		return 0x8208DFFC;
		  /* 8208DFFCh */ case   14:  		/* bl 6460 */
		/* 8208DFFCh case   14:*/		regs.LR = 0x8208E000; return 0x8208F938;
		/* 8208DFFCh case   14:*/		return 0x8208E000;
		  /* 8208E000h */ case   15:  		/* li R30, 0 */
		/* 8208E000h case   15:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8208E000h case   15:*/		return 0x8208E004;
		  /* 8208E004h */ case   16:  		/* lwz R3, <#[R31]> */
		/* 8208E004h case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8208E004h case   16:*/		return 0x8208E008;
		  /* 8208E008h */ case   17:  		/* stw R30, <#[R31 + 4]> */
		/* 8208E008h case   17:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 8208E008h case   17:*/		return 0x8208E00C;
		  /* 8208E00Ch */ case   18:  		/* stw R30, <#[R31 + 12]> */
		/* 8208E00Ch case   18:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 8208E00Ch case   18:*/		return 0x8208E010;
		  /* 8208E010h */ case   19:  		/* bl 17240 */
		/* 8208E010h case   19:*/		regs.LR = 0x8208E014; return 0x82092368;
		/* 8208E010h case   19:*/		return 0x8208E014;
		  /* 8208E014h */ case   20:  		/* stw R30, <#[R31]> */
		/* 8208E014h case   20:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000000) );
		/* 8208E014h case   20:*/		return 0x8208E018;
		  /* 8208E018h */ case   21:  		/* b 276 */
		/* 8208E018h case   21:*/		return 0x8208E12C;
		/* 8208E018h case   21:*/		return 0x8208E01C;
	}
	return 0x8208E01C;
} // Block from 8208DFC4h-8208E01Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 8208E01Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E01C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E01C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E01C);
		  /* 8208E01Ch */ case    0:  		/* li R7, 0 */
		/* 8208E01Ch case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8208E01Ch case    0:*/		return 0x8208E020;
		  /* 8208E020h */ case    1:  		/* lwz R5, <#[R31 + 4]> */
		/* 8208E020h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000004) );
		/* 8208E020h case    1:*/		return 0x8208E024;
		  /* 8208E024h */ case    2:  		/* addi R6, R1, 80 */
		/* 8208E024h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 8208E024h case    2:*/		return 0x8208E028;
		  /* 8208E028h */ case    3:  		/* lwz R4, <#[R31]> */
		/* 8208E028h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 8208E028h case    3:*/		return 0x8208E02C;
		  /* 8208E02Ch */ case    4:  		/* mr R3, R30 */
		/* 8208E02Ch case    4:*/		regs.R3 = regs.R30;
		/* 8208E02Ch case    4:*/		return 0x8208E030;
		  /* 8208E030h */ case    5:  		/* bl 1937584 */
		/* 8208E030h case    5:*/		regs.LR = 0x8208E034; return 0x822670E0;
		/* 8208E030h case    5:*/		return 0x8208E034;
		  /* 8208E034h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 8208E034h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208E034h case    6:*/		return 0x8208E038;
		  /* 8208E038h */ case    7:  		/* bc 12, CR0_EQ, 200 */
		/* 8208E038h case    7:*/		if ( regs.CR[0].eq ) { return 0x8208E100;  }
		/* 8208E038h case    7:*/		return 0x8208E03C;
		  /* 8208E03Ch */ case    8:  		/* li R7, 0 */
		/* 8208E03Ch case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8208E03Ch case    8:*/		return 0x8208E040;
		  /* 8208E040h */ case    9:  		/* lwz R5, <#[R31 + 12]> */
		/* 8208E040h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 8208E040h case    9:*/		return 0x8208E044;
		  /* 8208E044h */ case   10:  		/* addi R6, R1, 80 */
		/* 8208E044h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 8208E044h case   10:*/		return 0x8208E048;
		  /* 8208E048h */ case   11:  		/* lwz R4, <#[R31 + 8]> */
		/* 8208E048h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 8208E048h case   11:*/		return 0x8208E04C;
		  /* 8208E04Ch */ case   12:  		/* mr R3, R30 */
		/* 8208E04Ch case   12:*/		regs.R3 = regs.R30;
		/* 8208E04Ch case   12:*/		return 0x8208E050;
		  /* 8208E050h */ case   13:  		/* bl 1937552 */
		/* 8208E050h case   13:*/		regs.LR = 0x8208E054; return 0x822670E0;
		/* 8208E050h case   13:*/		return 0x8208E054;
		  /* 8208E054h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 8208E054h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208E054h case   14:*/		return 0x8208E058;
		  /* 8208E058h */ case   15:  		/* bc 12, CR0_EQ, 168 */
		/* 8208E058h case   15:*/		if ( regs.CR[0].eq ) { return 0x8208E100;  }
		/* 8208E058h case   15:*/		return 0x8208E05C;
		  /* 8208E05Ch */ case   16:  		/* mr R3, R30 */
		/* 8208E05Ch case   16:*/		regs.R3 = regs.R30;
		/* 8208E05Ch case   16:*/		return 0x8208E060;
		  /* 8208E060h */ case   17:  		/* bl -22616 */
		/* 8208E060h case   17:*/		regs.LR = 0x8208E064; return 0x82088808;
		/* 8208E060h case   17:*/		return 0x8208E064;
		  /* 8208E064h */ case   18:  		/* lwz R11, <#[R31]> */
		/* 8208E064h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8208E064h case   18:*/		return 0x8208E068;
		  /* 8208E068h */ case   19:  		/* li R30, 0 */
		/* 8208E068h case   19:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8208E068h case   19:*/		return 0x8208E06C;
		  /* 8208E06Ch */ case   20:  		/* addi R10, R11, 4 */
		/* 8208E06Ch case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8208E06Ch case   20:*/		return 0x8208E070;
		  /* 8208E070h */ case   21:  		/* mr R29, R30 */
		/* 8208E070h case   21:*/		regs.R29 = regs.R30;
		/* 8208E070h case   21:*/		return 0x8208E074;
		  /* 8208E074h */ case   22:  		/* lwz R11, <#[R11]> */
		/* 8208E074h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8208E074h case   22:*/		return 0x8208E078;
		  /* 8208E078h */ case   23:  		/* stw R10, <#[R31 + 16]> */
		/* 8208E078h case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 8208E078h case   23:*/		return 0x8208E07C;
		  /* 8208E07Ch */ case   24:  		/* stw R11, <#[R31 + 20]> */
		/* 8208E07Ch case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8208E07Ch case   24:*/		return 0x8208E080;
		  /* 8208E080h */ case   25:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 8208E080h case   25:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 8208E080h case   25:*/		return 0x8208E084;
		  /* 8208E084h */ case   26:  		/* cmplwi CR6, R11, 0 */
		/* 8208E084h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208E084h case   26:*/		return 0x8208E088;
		  /* 8208E088h */ case   27:  		/* bc 4, CR6_GT, 104 */
		/* 8208E088h case   27:*/		if ( !regs.CR[6].gt ) { return 0x8208E0F0;  }
		/* 8208E088h case   27:*/		return 0x8208E08C;
		  /* 8208E08Ch */ case   28:  		/* lwz R11, <#[R31 + 16]> */
		/* 8208E08Ch case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8208E08Ch case   28:*/		return 0x8208E090;
		  /* 8208E090h */ case   29:  		/* lis R8, 21592 */
		/* 8208E090h case   29:*/		cpu::op::lis<0>(regs,&regs.R8,0x5458);
		/* 8208E090h case   29:*/		return 0x8208E094;
		  /* 8208E094h */ case   30:  		/* lwz R9, <#[R31]> */
		/* 8208E094h case   30:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8208E094h case   30:*/		return 0x8208E098;
		  /* 8208E098h */ case   31:  		/* add R11, R11, R30 */
		/* 8208E098h case   31:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8208E098h case   31:*/		return 0x8208E09C;
		  /* 8208E09Ch */ case   32:  		/* addi R10, R11, 12 */
		/* 8208E09Ch case   32:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xC);
		/* 8208E09Ch case   32:*/		return 0x8208E0A0;
		  /* 8208E0A0h */ case   33:  		/* lwz R10, <#[R11 + 12]> */
		/* 8208E0A0h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8208E0A0h case   33:*/		return 0x8208E0A4;
		  /* 8208E0A4h */ case   34:  		/* add R10, R10, R9 */
		/* 8208E0A4h case   34:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8208E0A4h case   34:*/		return 0x8208E0A8;
		  /* 8208E0A8h */ case   35:  		/* stw R10, <#[R11 + 12]> */
		/* 8208E0A8h case   35:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8208E0A8h case   35:*/		return 0x8208E0AC;
		  /* 8208E0ACh */ case   36:  		/* lwz R11, <#[R31 + 16]> */
		/* 8208E0ACh case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8208E0ACh case   36:*/		return 0x8208E0B0;
		  /* 8208E0B0h */ case   37:  		/* add R11, R11, R30 */
		/* 8208E0B0h case   37:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8208E0B0h case   37:*/		return 0x8208E0B4;
		  /* 8208E0B4h */ case   38:  		/* lwz R10, <#[R11]> */
		/* 8208E0B4h case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208E0B4h case   38:*/		return 0x8208E0B8;
		  /* 8208E0B8h */ case   39:  		/* rlwinm R10, R10, 0, 0, 15 */
		/* 8208E0B8h case   39:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R10,regs.R10);
		/* 8208E0B8h case   39:*/		return 0x8208E0BC;
		  /* 8208E0BCh */ case   40:  		/* cmplw CR6, R10, R8 */
		/* 8208E0BCh case   40:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8208E0BCh case   40:*/		return 0x8208E0C0;
		  /* 8208E0C0h */ case   41:  		/* bc 4, CR6_EQ, 28 */
		/* 8208E0C0h case   41:*/		if ( !regs.CR[6].eq ) { return 0x8208E0DC;  }
		/* 8208E0C0h case   41:*/		return 0x8208E0C4;
		  /* 8208E0C4h */ case   42:  		/* lwz R10, <#[R11 + 4]> */
		/* 8208E0C4h case   42:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8208E0C4h case   42:*/		return 0x8208E0C8;
		  /* 8208E0C8h */ case   43:  		/* lwz R4, <#[R31 + 8]> */
		/* 8208E0C8h case   43:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 8208E0C8h case   43:*/		return 0x8208E0CC;
		  /* 8208E0CCh */ case   44:  		/* lwz R11, <#[R31]> */
		/* 8208E0CCh case   44:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8208E0CCh case   44:*/		return 0x8208E0D0;
		  /* 8208E0D0h */ case   45:  		/* mr R5, R4 */
		/* 8208E0D0h case   45:*/		regs.R5 = regs.R4;
		/* 8208E0D0h case   45:*/		return 0x8208E0D4;
		  /* 8208E0D4h */ case   46:  		/* add R3, R10, R11 */
		/* 8208E0D4h case   46:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8208E0D4h case   46:*/		return 0x8208E0D8;
		  /* 8208E0D8h */ case   47:  		/* bl 752792 */
		/* 8208E0D8h case   47:*/		regs.LR = 0x8208E0DC; return 0x82145D70;
		/* 8208E0D8h case   47:*/		return 0x8208E0DC;
	}
	return 0x8208E0DC;
} // Block from 8208E01Ch-8208E0DCh (48 instructions)

//////////////////////////////////////////////////////
// Block at 8208E0DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E0DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E0DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E0DC);
		  /* 8208E0DCh */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 8208E0DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8208E0DCh case    0:*/		return 0x8208E0E0;
		  /* 8208E0E0h */ case    1:  		/* addi R29, R29, 1 */
		/* 8208E0E0h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8208E0E0h case    1:*/		return 0x8208E0E4;
		  /* 8208E0E4h */ case    2:  		/* addi R30, R30, 16 */
		/* 8208E0E4h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x10);
		/* 8208E0E4h case    2:*/		return 0x8208E0E8;
		  /* 8208E0E8h */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 8208E0E8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8208E0E8h case    3:*/		return 0x8208E0EC;
		  /* 8208E0ECh */ case    4:  		/* bc 12, CR6_LT, -96 */
		/* 8208E0ECh case    4:*/		if ( regs.CR[6].lt ) { return 0x8208E08C;  }
		/* 8208E0ECh case    4:*/		return 0x8208E0F0;
	}
	return 0x8208E0F0;
} // Block from 8208E0DCh-8208E0F0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208E0F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E0F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E0F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E0F0);
		  /* 8208E0F0h */ case    0:  		/* li R11, 1 */
		/* 8208E0F0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8208E0F0h case    0:*/		return 0x8208E0F4;
		  /* 8208E0F4h */ case    1:  		/* li R3, 0 */
		/* 8208E0F4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208E0F4h case    1:*/		return 0x8208E0F8;
		  /* 8208E0F8h */ case    2:  		/* stw R11, <#[R31 + 24]> */
		/* 8208E0F8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8208E0F8h case    2:*/		return 0x8208E0FC;
		  /* 8208E0FCh */ case    3:  		/* b 56 */
		/* 8208E0FCh case    3:*/		return 0x8208E134;
		/* 8208E0FCh case    3:*/		return 0x8208E100;
	}
	return 0x8208E100;
} // Block from 8208E0F0h-8208E100h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208E100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E100);
		  /* 8208E100h */ case    0:  		/* lis R11, -32255 */
		/* 8208E100h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208E100h case    0:*/		return 0x8208E104;
		  /* 8208E104h */ case    1:  		/* lis R10, -32256 */
		/* 8208E104h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8208E104h case    1:*/		return 0x8208E108;
		  /* 8208E108h */ case    2:  		/* addi R4, R11, -28248 */
		/* 8208E108h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFF91A8);
		/* 8208E108h case    2:*/		return 0x8208E10C;
		  /* 8208E10Ch */ case    3:  		/* addi R3, R10, 2596 */
		/* 8208E10Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 8208E10Ch case    3:*/		return 0x8208E110;
		  /* 8208E110h */ case    4:  		/* li R5, 169 */
		/* 8208E110h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0xA9);
		/* 8208E110h case    4:*/		return 0x8208E114;
		  /* 8208E114h */ case    5:  		/* bl 6180 */
		/* 8208E114h case    5:*/		regs.LR = 0x8208E118; return 0x8208F938;
		/* 8208E114h case    5:*/		return 0x8208E118;
		  /* 8208E118h */ case    6:  		/* lis R11, -32255 */
		/* 8208E118h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208E118h case    6:*/		return 0x8208E11C;
		  /* 8208E11Ch */ case    7:  		/* addi R3, R11, -28500 */
		/* 8208E11Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF90AC);
		/* 8208E11Ch case    7:*/		return 0x8208E120;
		  /* 8208E120h */ case    8:  		/* bl 6168 */
		/* 8208E120h case    8:*/		regs.LR = 0x8208E124; return 0x8208F938;
		/* 8208E120h case    8:*/		return 0x8208E124;
	}
	return 0x8208E124;
} // Block from 8208E100h-8208E124h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8208E124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E124);
		  /* 8208E124h */ case    0:  		/* mr R3, R30 */
		/* 8208E124h case    0:*/		regs.R3 = regs.R30;
		/* 8208E124h case    0:*/		return 0x8208E128;
		  /* 8208E128h */ case    1:  		/* bl -22816 */
		/* 8208E128h case    1:*/		regs.LR = 0x8208E12C; return 0x82088808;
		/* 8208E128h case    1:*/		return 0x8208E12C;
	}
	return 0x8208E12C;
} // Block from 8208E124h-8208E12Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208E12Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E12C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E12C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E12C);
		  /* 8208E12Ch */ case    0:  		/* lis R3, -32768 */
		/* 8208E12Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8208E12Ch case    0:*/		return 0x8208E130;
		  /* 8208E130h */ case    1:  		/* ori R3, R3, 16389 */
		/* 8208E130h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8208E130h case    1:*/		return 0x8208E134;
	}
	return 0x8208E134;
} // Block from 8208E12Ch-8208E134h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208E134h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E134( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E134) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E134);
		  /* 8208E134h */ case    0:  		/* addi R1, R1, 144 */
		/* 8208E134h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8208E134h case    0:*/		return 0x8208E138;
		  /* 8208E138h */ case    1:  		/* b 12660 */
		/* 8208E138h case    1:*/		return 0x820912AC;
		/* 8208E138h case    1:*/		return 0x8208E13C;
		  /* 8208E13Ch */ case    2:  		/* nop */
		/* 8208E13Ch case    2:*/		cpu::op::nop();
		/* 8208E13Ch case    2:*/		return 0x8208E140;
	}
	return 0x8208E140;
} // Block from 8208E134h-8208E140h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208E140h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E140);
		  /* 8208E140h */ case    0:  		/* mfspr R12, LR */
		/* 8208E140h case    0:*/		regs.R12 = regs.LR;
		/* 8208E140h case    0:*/		return 0x8208E144;
		  /* 8208E144h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8208E144h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208E144h case    1:*/		return 0x8208E148;
		  /* 8208E148h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8208E148h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208E148h case    2:*/		return 0x8208E14C;
		  /* 8208E14Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8208E14Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208E14Ch case    3:*/		return 0x8208E150;
		  /* 8208E150h */ case    4:  		/* stfd FR31, <#[R1 - 32]> */
		/* 8208E150h case    4:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 8208E150h case    4:*/		return 0x8208E154;
		  /* 8208E154h */ case    5:  		/* stwu R1, <#[R1 - 112]> */
		/* 8208E154h case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8208E154h case    5:*/		return 0x8208E158;
		  /* 8208E158h */ case    6:  		/* mr R30, R3 */
		/* 8208E158h case    6:*/		regs.R30 = regs.R3;
		/* 8208E158h case    6:*/		return 0x8208E15C;
		  /* 8208E15Ch */ case    7:  		/* bl -1052 */
		/* 8208E15Ch case    7:*/		regs.LR = 0x8208E160; return 0x8208DD40;
		/* 8208E15Ch case    7:*/		return 0x8208E160;
		  /* 8208E160h */ case    8:  		/* lis R11, -32256 */
		/* 8208E160h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8208E160h case    8:*/		return 0x8208E164;
		  /* 8208E164h */ case    9:  		/* lis R10, -32256 */
		/* 8208E164h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8208E164h case    9:*/		return 0x8208E168;
		  /* 8208E168h */ case   10:  		/* li R31, 0 */
		/* 8208E168h case   10:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8208E168h case   10:*/		return 0x8208E16C;
		  /* 8208E16Ch */ case   11:  		/* lis R9, -32256 */
		/* 8208E16Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 8208E16Ch case   11:*/		return 0x8208E170;
		  /* 8208E170h */ case   12:  		/* stw R31, <#[R30 + 112]> */
		/* 8208E170h case   12:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000070) );
		/* 8208E170h case   12:*/		return 0x8208E174;
		  /* 8208E174h */ case   13:  		/* lfs FR0, <#[R11 + 1816]> */
		/* 8208E174h case   13:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000718) );
		/* 8208E174h case   13:*/		return 0x8208E178;
		  /* 8208E178h */ case   14:  		/* stw R31, <#[R30 + 104]> */
		/* 8208E178h case   14:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000068) );
		/* 8208E178h case   14:*/		return 0x8208E17C;
		  /* 8208E17Ch */ case   15:  		/* lfs FR13, <#[R10 + 1792]> */
		/* 8208E17Ch case   15:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000700) );
		/* 8208E17Ch case   15:*/		return 0x8208E180;
		  /* 8208E180h */ case   16:  		/* stw R31, <#[R30 + 108]> */
		/* 8208E180h case   16:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x0000006C) );
		/* 8208E180h case   16:*/		return 0x8208E184;
		  /* 8208E184h */ case   17:  		/* stfs FR0, <#[R30 + 88]> */
		/* 8208E184h case   17:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R30 + 0x00000058) );
		/* 8208E184h case   17:*/		return 0x8208E188;
		  /* 8208E188h */ case   18:  		/* stw R31, <#[R30 + 188]> */
		/* 8208E188h case   18:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x000000BC) );
		/* 8208E188h case   18:*/		return 0x8208E18C;
		  /* 8208E18Ch */ case   19:  		/* stfs FR0, <#[R30 + 92]> */
		/* 8208E18Ch case   19:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R30 + 0x0000005C) );
		/* 8208E18Ch case   19:*/		return 0x8208E190;
		  /* 8208E190h */ case   20:  		/* stfs FR13, <#[R30 + 44]> */
		/* 8208E190h case   20:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R30 + 0x0000002C) );
		/* 8208E190h case   20:*/		return 0x8208E194;
		  /* 8208E194h */ case   21:  		/* stfs FR13, <#[R30 + 48]> */
		/* 8208E194h case   21:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R30 + 0x00000030) );
		/* 8208E194h case   21:*/		return 0x8208E198;
		  /* 8208E198h */ case   22:  		/* stfs FR0, <#[R30 + 52]> */
		/* 8208E198h case   22:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R30 + 0x00000034) );
		/* 8208E198h case   22:*/		return 0x8208E19C;
		  /* 8208E19Ch */ case   23:  		/* lfd FR31, <#[R9 + 1808]> */
		/* 8208E19Ch case   23:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R9 + 0x00000710) );
		/* 8208E19Ch case   23:*/		return 0x8208E1A0;
		  /* 8208E1A0h */ case   24:  		/* fmr FR1, FR31 */
		/* 8208E1A0h case   24:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8208E1A0h case   24:*/		return 0x8208E1A4;
		  /* 8208E1A4h */ case   25:  		/* bl 10756 */
		/* 8208E1A4h case   25:*/		regs.LR = 0x8208E1A8; return 0x82090BA8;
		/* 8208E1A4h case   25:*/		return 0x8208E1A8;
		  /* 8208E1A8h */ case   26:  		/* stfd FR1, <#[R30 + 56]> */
		/* 8208E1A8h case   26:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R30 + 0x00000038) );
		/* 8208E1A8h case   26:*/		return 0x8208E1AC;
		  /* 8208E1ACh */ case   27:  		/* fmr FR1, FR31 */
		/* 8208E1ACh case   27:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8208E1ACh case   27:*/		return 0x8208E1B0;
		  /* 8208E1B0h */ case   28:  		/* bl 10520 */
		/* 8208E1B0h case   28:*/		regs.LR = 0x8208E1B4; return 0x82090AC8;
		/* 8208E1B0h case   28:*/		return 0x8208E1B4;
		  /* 8208E1B4h */ case   29:  		/* stfd FR1, <#[R30 + 64]> */
		/* 8208E1B4h case   29:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R30 + 0x00000040) );
		/* 8208E1B4h case   29:*/		return 0x8208E1B8;
		  /* 8208E1B8h */ case   30:  		/* stw R31, <#[R30 + 96]> */
		/* 8208E1B8h case   30:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000060) );
		/* 8208E1B8h case   30:*/		return 0x8208E1BC;
		  /* 8208E1BCh */ case   31:  		/* mr R3, R30 */
		/* 8208E1BCh case   31:*/		regs.R3 = regs.R30;
		/* 8208E1BCh case   31:*/		return 0x8208E1C0;
		  /* 8208E1C0h */ case   32:  		/* stw R31, <#[R30 + 100]> */
		/* 8208E1C0h case   32:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000064) );
		/* 8208E1C0h case   32:*/		return 0x8208E1C4;
		  /* 8208E1C4h */ case   33:  		/* stw R31, <#[R30 + 180]> */
		/* 8208E1C4h case   33:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x000000B4) );
		/* 8208E1C4h case   33:*/		return 0x8208E1C8;
		  /* 8208E1C8h */ case   34:  		/* addi R1, R1, 112 */
		/* 8208E1C8h case   34:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8208E1C8h case   34:*/		return 0x8208E1CC;
		  /* 8208E1CCh */ case   35:  		/* lwz R12, <#[R1 - 8]> */
		/* 8208E1CCh case   35:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208E1CCh case   35:*/		return 0x8208E1D0;
		  /* 8208E1D0h */ case   36:  		/* mtspr LR, R12 */
		/* 8208E1D0h case   36:*/		regs.LR = regs.R12;
		/* 8208E1D0h case   36:*/		return 0x8208E1D4;
		  /* 8208E1D4h */ case   37:  		/* lfd FR31, <#[R1 - 32]> */
		/* 8208E1D4h case   37:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 8208E1D4h case   37:*/		return 0x8208E1D8;
		  /* 8208E1D8h */ case   38:  		/* ld R30, <#[R1 - 24]> */
		/* 8208E1D8h case   38:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208E1D8h case   38:*/		return 0x8208E1DC;
		  /* 8208E1DCh */ case   39:  		/* ld R31, <#[R1 - 16]> */
		/* 8208E1DCh case   39:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208E1DCh case   39:*/		return 0x8208E1E0;
		  /* 8208E1E0h */ case   40:  		/* bclr 20, CR0_LT */
		/* 8208E1E0h case   40:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208E1E0h case   40:*/		return 0x8208E1E4;
	}
	return 0x8208E1E4;
} // Block from 8208E140h-8208E1E4h (41 instructions)

//////////////////////////////////////////////////////
// Block at 8208E1E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E1E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E1E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E1E4);
		  /* 8208E1E4h */ case    0:  		/* nop */
		/* 8208E1E4h case    0:*/		cpu::op::nop();
		/* 8208E1E4h case    0:*/		return 0x8208E1E8;
	}
	return 0x8208E1E8;
} // Block from 8208E1E4h-8208E1E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208E1E8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E1E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E1E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E1E8);
		  /* 8208E1E8h */ case    0:  		/* lwz R11, <#[R4]> */
		/* 8208E1E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8208E1E8h case    0:*/		return 0x8208E1EC;
		  /* 8208E1ECh */ case    1:  		/* lis R10, -32256 */
		/* 8208E1ECh case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8208E1ECh case    1:*/		return 0x8208E1F0;
		  /* 8208E1F0h */ case    2:  		/* stw R11, <#[R3 + 72]> */
		/* 8208E1F0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000048) );
		/* 8208E1F0h case    2:*/		return 0x8208E1F4;
		  /* 8208E1F4h */ case    3:  		/* lfs FR0, <#[R10 + 1816]> */
		/* 8208E1F4h case    3:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000718) );
		/* 8208E1F4h case    3:*/		return 0x8208E1F8;
		  /* 8208E1F8h */ case    4:  		/* lwz R11, <#[R4 + 4]> */
		/* 8208E1F8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 8208E1F8h case    4:*/		return 0x8208E1FC;
		  /* 8208E1FCh */ case    5:  		/* stw R11, <#[R3 + 76]> */
		/* 8208E1FCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000004C) );
		/* 8208E1FCh case    5:*/		return 0x8208E200;
	}
	return 0x8208E200;
} // Block from 8208E1E8h-8208E200h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208E200h
// Function 'CopyMisalignedCachelines'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E200);
		  /* 8208E200h */ case    0:  		/* lwz R11, <#[R4 + 8]> */
		/* 8208E200h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8208E200h case    0:*/		return 0x8208E204;
		  /* 8208E204h */ case    1:  		/* stw R11, <#[R3 + 80]> */
		/* 8208E204h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000050) );
		/* 8208E204h case    1:*/		return 0x8208E208;
		  /* 8208E208h */ case    2:  		/* lwz R11, <#[R4 + 12]> */
		/* 8208E208h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 8208E208h case    2:*/		return 0x8208E20C;
		  /* 8208E20Ch */ case    3:  		/* stfs FR0, <#[R3 + 88]> */
		/* 8208E20Ch case    3:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x00000058) );
		/* 8208E20Ch case    3:*/		return 0x8208E210;
		  /* 8208E210h */ case    4:  		/* stfs FR0, <#[R3 + 92]> */
		/* 8208E210h case    4:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x0000005C) );
		/* 8208E210h case    4:*/		return 0x8208E214;
		  /* 8208E214h */ case    5:  		/* stw R11, <#[R3 + 84]> */
		/* 8208E214h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000054) );
		/* 8208E214h case    5:*/		return 0x8208E218;
		  /* 8208E218h */ case    6:  		/* bclr 20, CR0_LT */
		/* 8208E218h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208E218h case    6:*/		return 0x8208E21C;
	}
	return 0x8208E21C;
} // Block from 8208E200h-8208E21Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208E21Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E21C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E21C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E21C);
		  /* 8208E21Ch */ case    0:  		/* nop */
		/* 8208E21Ch case    0:*/		cpu::op::nop();
		/* 8208E21Ch case    0:*/		return 0x8208E220;
		  /* 8208E220h */ case    1:  		/* lis R11, -32256 */
		/* 8208E220h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8208E220h case    1:*/		return 0x8208E224;
		  /* 8208E224h */ case    2:  		/* li R8, 0 */
		/* 8208E224h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8208E224h case    2:*/		return 0x8208E228;
		  /* 8208E228h */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 8208E228h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8208E228h case    3:*/		return 0x8208E22C;
		  /* 8208E22Ch */ case    4:  		/* lfs FR13, <#[R11 + 1816]> */
		/* 8208E22Ch case    4:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000718) );
		/* 8208E22Ch case    4:*/		return 0x8208E230;
		  /* 8208E230h */ case    5:  		/* bc 12, CR6_EQ, 168 */
		/* 8208E230h case    5:*/		if ( regs.CR[6].eq ) { return 0x8208E2D8;  }
		/* 8208E230h case    5:*/		return 0x8208E234;
		  /* 8208E234h */ case    6:  		/* lfs FR0, <#[R3 + 28]> */
		/* 8208E234h case    6:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R3 + 0x0000001C) );
		/* 8208E234h case    6:*/		return 0x8208E238;
		  /* 8208E238h */ case    7:  		/* li R10, 0 */
		/* 8208E238h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8208E238h case    7:*/		return 0x8208E23C;
		  /* 8208E23Ch */ case    8:  		/* fcmpu CR6, FR0, FR13 */
		/* 8208E23Ch case    8:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 8208E23Ch case    8:*/		return 0x8208E240;
		  /* 8208E240h */ case    9:  		/* bc 4, CR6_GT, 8 */
		/* 8208E240h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8208E248;  }
		/* 8208E240h case    9:*/		return 0x8208E244;
		  /* 8208E244h */ case   10:  		/* fmr FR13, FR0 */
		/* 8208E244h case   10:*/		cpu::op::fmr<0>(regs,&regs.FR13,regs.FR0);
		/* 8208E244h case   10:*/		return 0x8208E248;
	}
	return 0x8208E248;
} // Block from 8208E21Ch-8208E248h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8208E248h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E248);
		  /* 8208E248h */ case    0:  		/* lhz R11, <#[R4]> */
		/* 8208E248h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8208E248h case    0:*/		return 0x8208E24C;
		  /* 8208E24Ch */ case    1:  		/* b 132 */
		/* 8208E24Ch case    1:*/		return 0x8208E2D0;
		/* 8208E24Ch case    1:*/		return 0x8208E250;
		  /* 8208E250h */ case    2:  		/* addi R4, R4, 2 */
		/* 8208E250h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x2);
		/* 8208E250h case    2:*/		return 0x8208E254;
		  /* 8208E254h */ case    3:  		/* cmplwi CR6, R11, 10 */
		/* 8208E254h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000A);
		/* 8208E254h case    3:*/		return 0x8208E258;
		  /* 8208E258h */ case    4:  		/* bc 4, CR6_EQ, 36 */
		/* 8208E258h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8208E27C;  }
		/* 8208E258h case    4:*/		return 0x8208E25C;
		  /* 8208E25Ch */ case    5:  		/* cmpwi CR6, R7, 0 */
		/* 8208E25Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 8208E25Ch case    5:*/		return 0x8208E260;
		  /* 8208E260h */ case    6:  		/* bc 4, CR6_EQ, 120 */
		/* 8208E260h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8208E2D8;  }
		/* 8208E260h case    6:*/		return 0x8208E264;
		  /* 8208E264h */ case    7:  		/* lfs FR12, <#[R3 + 40]> */
		/* 8208E264h case    7:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R3 + 0x00000028) );
		/* 8208E264h case    7:*/		return 0x8208E268;
		  /* 8208E268h */ case    8:  		/* li R10, 0 */
		/* 8208E268h case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8208E268h case    8:*/		return 0x8208E26C;
		  /* 8208E26Ch */ case    9:  		/* fadds FR0, FR12, FR0 */
		/* 8208E26Ch case    9:*/		cpu::op::fadds<0>(regs,&regs.FR0,regs.FR12,regs.FR0);
		/* 8208E26Ch case    9:*/		return 0x8208E270;
		  /* 8208E270h */ case   10:  		/* fcmpu CR6, FR0, FR13 */
		/* 8208E270h case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 8208E270h case   10:*/		return 0x8208E274;
		  /* 8208E274h */ case   11:  		/* bc 4, CR6_GT, 16 */
		/* 8208E274h case   11:*/		if ( !regs.CR[6].gt ) { return 0x8208E284;  }
		/* 8208E274h case   11:*/		return 0x8208E278;
		  /* 8208E278h */ case   12:  		/* fmr FR13, FR0 */
		/* 8208E278h case   12:*/		cpu::op::fmr<0>(regs,&regs.FR13,regs.FR0);
		/* 8208E278h case   12:*/		return 0x8208E27C;
	}
	return 0x8208E27C;
} // Block from 8208E248h-8208E27Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8208E27Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E27C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E27C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E27C);
		  /* 8208E27Ch */ case    0:  		/* cmplwi CR6, R11, 13 */
		/* 8208E27Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000D);
		/* 8208E27Ch case    0:*/		return 0x8208E280;
		  /* 8208E280h */ case    1:  		/* bc 12, CR6_EQ, 76 */
		/* 8208E280h case    1:*/		if ( regs.CR[6].eq ) { return 0x8208E2CC;  }
		/* 8208E280h case    1:*/		return 0x8208E284;
	}
	return 0x8208E284;
} // Block from 8208E27Ch-8208E284h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208E284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E284);
		  /* 8208E284h */ case    0:  		/* lwz R9, <#[R3 + 96]> */
		/* 8208E284h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000060) );
		/* 8208E284h case    0:*/		return 0x8208E288;
		  /* 8208E288h */ case    1:  		/* cmplw CR6, R11, R9 */
		/* 8208E288h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8208E288h case    1:*/		return 0x8208E28C;
		  /* 8208E28Ch */ case    2:  		/* bc 4, CR6_GT, 12 */
		/* 8208E28Ch case    2:*/		if ( !regs.CR[6].gt ) { return 0x8208E298;  }
		/* 8208E28Ch case    2:*/		return 0x8208E290;
		  /* 8208E290h */ case    3:  		/* li R9, 0 */
		/* 8208E290h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8208E290h case    3:*/		return 0x8208E294;
		  /* 8208E294h */ case    4:  		/* b 16 */
		/* 8208E294h case    4:*/		return 0x8208E2A4;
		/* 8208E294h case    4:*/		return 0x8208E298;
	}
	return 0x8208E298;
} // Block from 8208E284h-8208E298h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208E298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E298);
		  /* 8208E298h */ case    0:  		/* lwz R9, <#[R3 + 100]> */
		/* 8208E298h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000064) );
		/* 8208E298h case    0:*/		return 0x8208E29C;
		  /* 8208E29Ch */ case    1:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 8208E29Ch case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 8208E29Ch case    1:*/		return 0x8208E2A0;
		  /* 8208E2A0h */ case    2:  		/* lhzx R9, <#[R11 + R9]> */
		/* 8208E2A0h case    2:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8208E2A0h case    2:*/		return 0x8208E2A4;
	}
	return 0x8208E2A4;
} // Block from 8208E298h-8208E2A4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208E2A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E2A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E2A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E2A4);
		  /* 8208E2A4h */ case    0:  		/* lwz R11, <#[R3 + 108]> */
		/* 8208E2A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000006C) );
		/* 8208E2A4h case    0:*/		return 0x8208E2A8;
		  /* 8208E2A8h */ case    1:  		/* rlwinm R9, R9, 4, 0, 27 */
		/* 8208E2A8h case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R9,regs.R9);
		/* 8208E2A8h case    1:*/		return 0x8208E2AC;
		  /* 8208E2ACh */ case    2:  		/* add R11, R9, R11 */
		/* 8208E2ACh case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8208E2ACh case    2:*/		return 0x8208E2B0;
		  /* 8208E2B0h */ case    3:  		/* lha R9, <#[R11 + 8]> */
		/* 8208E2B0h case    3:*/		cpu::mem::load16a( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8208E2B0h case    3:*/		return 0x8208E2B4;
		  /* 8208E2B4h */ case    4:  		/* lha R11, <#[R11 + 12]> */
		/* 8208E2B4h case    4:*/		cpu::mem::load16a( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8208E2B4h case    4:*/		return 0x8208E2B8;
		  /* 8208E2B8h */ case    5:  		/* add R11, R11, R9 */
		/* 8208E2B8h case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8208E2B8h case    5:*/		return 0x8208E2BC;
		  /* 8208E2BCh */ case    6:  		/* add R10, R11, R10 */
		/* 8208E2BCh case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 8208E2BCh case    6:*/		return 0x8208E2C0;
	}
	return 0x8208E2C0;
} // Block from 8208E2A4h-8208E2C0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208E2C0h
// Function 'XMemHeapAlloc'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E2C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E2C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E2C0);
		  /* 8208E2C0h */ case    0:  		/* cmpw CR6, R10, R8 */
		/* 8208E2C0h case    0:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R8);
		/* 8208E2C0h case    0:*/		return 0x8208E2C4;
		  /* 8208E2C4h */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 8208E2C4h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8208E2CC;  }
		/* 8208E2C4h case    1:*/		return 0x8208E2C8;
		  /* 8208E2C8h */ case    2:  		/* mr R8, R10 */
		/* 8208E2C8h case    2:*/		regs.R8 = regs.R10;
		/* 8208E2C8h case    2:*/		return 0x8208E2CC;
	}
	return 0x8208E2CC;
} // Block from 8208E2C0h-8208E2CCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208E2CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E2CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E2CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E2CC);
		  /* 8208E2CCh */ case    0:  		/* lhz R11, <#[R4]> */
		/* 8208E2CCh case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8208E2CCh case    0:*/		return 0x8208E2D0;
	}
	return 0x8208E2D0;
} // Block from 8208E2CCh-8208E2D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208E2D0h
// Function 'XMemHeapFree'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E2D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E2D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E2D0);
		  /* 8208E2D0h */ case    0:  		/* cmplwi CR0, R11, 0 */
		/* 8208E2D0h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8208E2D0h case    0:*/		return 0x8208E2D4;
		  /* 8208E2D4h */ case    1:  		/* bc 4, CR0_EQ, -132 */
		/* 8208E2D4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8208E250;  }
		/* 8208E2D4h case    1:*/		return 0x8208E2D8;
	}
	return 0x8208E2D8;
} // Block from 8208E2D0h-8208E2D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208E2D8h
// Function 'XPhysicalAlloc'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E2D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E2D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E2D8);
		  /* 8208E2D8h */ case    0:  		/* lfs FR0, <#[R3 + 48]> */
		/* 8208E2D8h case    0:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R3 + 0x00000030) );
		/* 8208E2D8h case    0:*/		return 0x8208E2DC;
		  /* 8208E2DCh */ case    1:  		/* extsw R11, R8 */
		/* 8208E2DCh case    1:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R8);
		/* 8208E2DCh case    1:*/		return 0x8208E2E0;
		  /* 8208E2E0h */ case    2:  		/* fmuls FR0, FR0, FR13 */
		/* 8208E2E0h case    2:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR0,regs.FR13);
		/* 8208E2E0h case    2:*/		return 0x8208E2E4;
		  /* 8208E2E4h */ case    3:  		/* stfs FR0, <#[R6]> */
		/* 8208E2E4h case    3:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R6 + 0x00000000) );
		/* 8208E2E4h case    3:*/		return 0x8208E2E8;
		  /* 8208E2E8h */ case    4:  		/* std R11, <#[R1 - 16]> */
		/* 8208E2E8h case    4:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208E2E8h case    4:*/		return 0x8208E2EC;
		  /* 8208E2ECh */ case    5:  		/* lfd FR0, <#[R1 - 16]> */
		/* 8208E2ECh case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208E2ECh case    5:*/		return 0x8208E2F0;
		  /* 8208E2F0h */ case    6:  		/* fcfid FR0, FR0 */
		/* 8208E2F0h case    6:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 8208E2F0h case    6:*/		return 0x8208E2F4;
		  /* 8208E2F4h */ case    7:  		/* lfs FR13, <#[R3 + 44]> */
		/* 8208E2F4h case    7:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R3 + 0x0000002C) );
		/* 8208E2F4h case    7:*/		return 0x8208E2F8;
		  /* 8208E2F8h */ case    8:  		/* frsp FR0, FR0 */
		/* 8208E2F8h case    8:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 8208E2F8h case    8:*/		return 0x8208E2FC;
		  /* 8208E2FCh */ case    9:  		/* fmuls FR0, FR13, FR0 */
		/* 8208E2FCh case    9:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 8208E2FCh case    9:*/		return 0x8208E300;
		  /* 8208E300h */ case   10:  		/* stfs FR0, <#[R5]> */
		/* 8208E300h case   10:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R5 + 0x00000000) );
		/* 8208E300h case   10:*/		return 0x8208E304;
		  /* 8208E304h */ case   11:  		/* bclr 20, CR0_LT */
		/* 8208E304h case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208E304h case   11:*/		return 0x8208E308;
	}
	return 0x8208E308;
} // Block from 8208E2D8h-8208E308h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8208E308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E308);
		  /* 8208E308h */ case    0:  		/* mfspr R12, LR */
		/* 8208E308h case    0:*/		regs.R12 = regs.LR;
		/* 8208E308h case    0:*/		return 0x8208E30C;
		  /* 8208E30Ch */ case    1:  		/* bl 12104 */
		/* 8208E30Ch case    1:*/		regs.LR = 0x8208E310; return 0x82091254;
		/* 8208E30Ch case    1:*/		return 0x8208E310;
		  /* 8208E310h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 8208E310h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 8208E310h case    2:*/		return 0x8208E314;
		  /* 8208E314h */ case    3:  		/* lis R11, -32215 */
		/* 8208E314h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8208E314h case    3:*/		return 0x8208E318;
		  /* 8208E318h */ case    4:  		/* addi R30, R11, -31256 */
		/* 8208E318h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFF85E8);
		/* 8208E318h case    4:*/		return 0x8208E31C;
		  /* 8208E31Ch */ case    5:  		/* lwz R3, <#[R11 - 31256]> */
		/* 8208E31Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFF85E8) );
		/* 8208E31Ch case    5:*/		return 0x8208E320;
		  /* 8208E320h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 8208E320h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8208E320h case    6:*/		return 0x8208E324;
		  /* 8208E324h */ case    7:  		/* bc 4, CR6_EQ, 368 */
		/* 8208E324h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8208E494;  }
		/* 8208E324h case    7:*/		return 0x8208E328;
		  /* 8208E328h */ case    8:  		/* lis R11, -32215 */
		/* 8208E328h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8208E328h case    8:*/		return 0x8208E32C;
		  /* 8208E32Ch */ case    9:  		/* lis R10, -32255 */
		/* 8208E32Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8208E32Ch case    9:*/		return 0x8208E330;
		  /* 8208E330h */ case   10:  		/* mr R5, R30 */
		/* 8208E330h case   10:*/		regs.R5 = regs.R30;
		/* 8208E330h case   10:*/		return 0x8208E334;
		  /* 8208E334h */ case   11:  		/* addi R4, R10, -27100 */
		/* 8208E334h case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0xFFFF9624);
		/* 8208E334h case   11:*/		return 0x8208E338;
		  /* 8208E338h */ case   12:  		/* lwz R3, <#[R11 - 31244]> */
		/* 8208E338h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFF85F4) );
		/* 8208E338h case   12:*/		return 0x8208E33C;
		  /* 8208E33Ch */ case   13:  		/* bl 7940 */
		/* 8208E33Ch case   13:*/		regs.LR = 0x8208E340; return 0x82090240;
		/* 8208E33Ch case   13:*/		return 0x8208E340;
		  /* 8208E340h */ case   14:  		/* or. R31, R3, R3 */
		/* 8208E340h case   14:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 8208E340h case   14:*/		return 0x8208E344;
		  /* 8208E344h */ case   15:  		/* li R27, 0 */
		/* 8208E344h case   15:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8208E344h case   15:*/		return 0x8208E348;
		  /* 8208E348h */ case   16:  		/* bc 12, CR0_LT, 316 */
		/* 8208E348h case   16:*/		if ( regs.CR[0].lt ) { return 0x8208E484;  }
		/* 8208E348h case   16:*/		return 0x8208E34C;
		  /* 8208E34Ch */ case   17:  		/* lis R11, -32255 */
		/* 8208E34Ch case   17:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208E34Ch case   17:*/		return 0x8208E350;
		  /* 8208E350h */ case   18:  		/* stw R27, <#[R1 + 92]> */
		/* 8208E350h case   18:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x0000005C) );
		/* 8208E350h case   18:*/		return 0x8208E354;
		  /* 8208E354h */ case   19:  		/* lis R10, -32255 */
		/* 8208E354h case   19:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8208E354h case   19:*/		return 0x8208E358;
		  /* 8208E358h */ case   20:  		/* stw R27, <#[R1 + 84]> */
		/* 8208E358h case   20:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000054) );
		/* 8208E358h case   20:*/		return 0x8208E35C;
		  /* 8208E35Ch */ case   21:  		/* addi R28, R11, -28232 */
		/* 8208E35Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0xFFFF91B8);
		/* 8208E35Ch case   21:*/		return 0x8208E360;
	}
	return 0x8208E360;
} // Block from 8208E308h-8208E360h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8208E360h
// Function 'XPhysicalAllocEx'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E360);
		  /* 8208E360h */ case    0:  		/* lis R11, -32255 */
		/* 8208E360h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208E360h case    0:*/		return 0x8208E364;
		  /* 8208E364h */ case    1:  		/* addi R8, R10, -27108 */
		/* 8208E364h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xFFFF961C);
		/* 8208E364h case    1:*/		return 0x8208E368;
		  /* 8208E368h */ case    2:  		/* addi R7, R11, -27128 */
		/* 8208E368h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFF9608);
		/* 8208E368h case    2:*/		return 0x8208E36C;
		  /* 8208E36Ch */ case    3:  		/* mr R3, R28 */
		/* 8208E36Ch case    3:*/		regs.R3 = regs.R28;
		/* 8208E36Ch case    3:*/		return 0x8208E370;
		  /* 8208E370h */ case    4:  		/* addi R10, R1, 96 */
		/* 8208E370h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 8208E370h case    4:*/		return 0x8208E374;
		  /* 8208E374h */ case    5:  		/* li R9, 0 */
		/* 8208E374h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8208E374h case    5:*/		return 0x8208E378;
		  /* 8208E378h */ case    6:  		/* li R6, 0 */
		/* 8208E378h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8208E378h case    6:*/		return 0x8208E37C;
		  /* 8208E37Ch */ case    7:  		/* li R5, 0 */
		/* 8208E37Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8208E37Ch case    7:*/		return 0x8208E380;
		  /* 8208E380h */ case    8:  		/* li R4, 1076 */
		/* 8208E380h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x434);
		/* 8208E380h case    8:*/		return 0x8208E384;
		  /* 8208E384h */ case    9:  		/* bl 71620 */
		/* 8208E384h case    9:*/		regs.LR = 0x8208E388; return 0x8209FB48;
		/* 8208E384h case    9:*/		return 0x8208E388;
		  /* 8208E388h */ case   10:  		/* or. R31, R3, R3 */
		/* 8208E388h case   10:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 8208E388h case   10:*/		return 0x8208E38C;
		  /* 8208E38Ch */ case   11:  		/* bc 12, CR0_LT, 240 */
		/* 8208E38Ch case   11:*/		if ( regs.CR[0].lt ) { return 0x8208E47C;  }
		/* 8208E38Ch case   11:*/		return 0x8208E390;
		  /* 8208E390h */ case   12:  		/* lwz R3, <#[R1 + 96]> */
		/* 8208E390h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 8208E390h case   12:*/		return 0x8208E394;
		  /* 8208E394h */ case   13:  		/* lwz R11, <#[R3]> */
		/* 8208E394h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8208E394h case   13:*/		return 0x8208E398;
		  /* 8208E398h */ case   14:  		/* lwz R11, <#[R11 + 12]> */
		/* 8208E398h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8208E398h case   14:*/		return 0x8208E39C;
		  /* 8208E39Ch */ case   15:  		/* mtspr CTR, R11 */
		/* 8208E39Ch case   15:*/		regs.CTR = regs.R11;
		/* 8208E39Ch case   15:*/		return 0x8208E3A0;
		  /* 8208E3A0h */ case   16:  		/* bcctrl 20, CR0_LT */
		/* 8208E3A0h case   16:*/		if ( 1 ) { regs.LR = 0x8208E3A4; return (uint32)regs.CTR; }
		/* 8208E3A0h case   16:*/		return 0x8208E3A4;
		  /* 8208E3A4h */ case   17:  		/* bl -145628 */
		/* 8208E3A4h case   17:*/		regs.LR = 0x8208E3A8; return 0x8206AAC8;
		/* 8208E3A4h case   17:*/		return 0x8208E3A8;
		  /* 8208E3A8h */ case   18:  		/* mr R11, R3 */
		/* 8208E3A8h case   18:*/		regs.R11 = regs.R3;
		/* 8208E3A8h case   18:*/		return 0x8208E3AC;
		  /* 8208E3ACh */ case   19:  		/* lwz R3, <#[R1 + 96]> */
		/* 8208E3ACh case   19:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 8208E3ACh case   19:*/		return 0x8208E3B0;
		  /* 8208E3B0h */ case   20:  		/* lis R10, -32761 */
		/* 8208E3B0h case   20:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8007);
		/* 8208E3B0h case   20:*/		return 0x8208E3B4;
		  /* 8208E3B4h */ case   21:  		/* stw R11, <#[R30 + 4]> */
		/* 8208E3B4h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8208E3B4h case   21:*/		return 0x8208E3B8;
		  /* 8208E3B8h */ case   22:  		/* addic R11, R11, -1 */
		/* 8208E3B8h case   22:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8208E3B8h case   22:*/		return 0x8208E3BC;
		  /* 8208E3BCh */ case   23:  		/* ori R29, R10, 14 */
		/* 8208E3BCh case   23:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R10,0xE);
		/* 8208E3BCh case   23:*/		return 0x8208E3C0;
		  /* 8208E3C0h */ case   24:  		/* subfe R11, R11, R11 */
		/* 8208E3C0h case   24:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8208E3C0h case   24:*/		return 0x8208E3C4;
		  /* 8208E3C4h */ case   25:  		/* lwz R10, <#[R3]> */
		/* 8208E3C4h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8208E3C4h case   25:*/		return 0x8208E3C8;
		  /* 8208E3C8h */ case   26:  		/* and R31, R11, R29 */
		/* 8208E3C8h case   26:*/		cpu::op::and<0>(regs,&regs.R31,regs.R11,regs.R29);
		/* 8208E3C8h case   26:*/		return 0x8208E3CC;
		  /* 8208E3CCh */ case   27:  		/* lwz R10, <#[R10 + 8]> */
		/* 8208E3CCh case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8208E3CCh case   27:*/		return 0x8208E3D0;
	}
	return 0x8208E3D0;
} // Block from 8208E360h-8208E3D0h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8208E3D0h
// Function 'XPhysicalFree'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E3D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E3D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E3D0);
		  /* 8208E3D0h */ case    0:  		/* mtspr CTR, R10 */
		/* 8208E3D0h case    0:*/		regs.CTR = regs.R10;
		/* 8208E3D0h case    0:*/		return 0x8208E3D4;
		  /* 8208E3D4h */ case    1:  		/* bcctrl 20, CR0_LT */
		/* 8208E3D4h case    1:*/		if ( 1 ) { regs.LR = 0x8208E3D8; return (uint32)regs.CTR; }
		/* 8208E3D4h case    1:*/		return 0x8208E3D8;
		  /* 8208E3D8h */ case    2:  		/* cmpwi CR6, R31, 0 */
		/* 8208E3D8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 8208E3D8h case    2:*/		return 0x8208E3DC;
		  /* 8208E3DCh */ case    3:  		/* bc 12, CR6_LT, 152 */
		/* 8208E3DCh case    3:*/		if ( regs.CR[6].lt ) { return 0x8208E474;  }
		/* 8208E3DCh case    3:*/		return 0x8208E3E0;
	}
	return 0x8208E3E0;
} // Block from 8208E3D0h-8208E3E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208E3E0h
// Function 'RtlOutputDebugString'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E3E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E3E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E3E0);
		  /* 8208E3E0h */ case    0:  		/* lis R10, -32255 */
		/* 8208E3E0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8208E3E0h case    0:*/		return 0x8208E3E4;
		  /* 8208E3E4h */ case    1:  		/* stw R27, <#[R1 + 92]> */
		/* 8208E3E4h case    1:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x0000005C) );
		/* 8208E3E4h case    1:*/		return 0x8208E3E8;
		  /* 8208E3E8h */ case    2:  		/* lis R11, -32255 */
		/* 8208E3E8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208E3E8h case    2:*/		return 0x8208E3EC;
		  /* 8208E3ECh */ case    3:  		/* stw R27, <#[R1 + 84]> */
		/* 8208E3ECh case    3:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000054) );
		/* 8208E3ECh case    3:*/		return 0x8208E3F0;
	}
	return 0x8208E3F0;
} // Block from 8208E3E0h-8208E3F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208E3F0h
// Function 'SetLastError'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E3F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E3F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E3F0);
		  /* 8208E3F0h */ case    0:  		/* addi R7, R10, -27144 */
		/* 8208E3F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFF95F8);
		/* 8208E3F0h case    0:*/		return 0x8208E3F4;
		  /* 8208E3F4h */ case    1:  		/* addi R8, R11, -27152 */
		/* 8208E3F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFF95F0);
		/* 8208E3F4h case    1:*/		return 0x8208E3F8;
	}
	return 0x8208E3F8;
} // Block from 8208E3F0h-8208E3F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208E3F8h
// Function 'RtlSetLastError'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E3F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E3F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E3F8);
		  /* 8208E3F8h */ case    0:  		/* mr R3, R28 */
		/* 8208E3F8h case    0:*/		regs.R3 = regs.R28;
		/* 8208E3F8h case    0:*/		return 0x8208E3FC;
		  /* 8208E3FCh */ case    1:  		/* addi R10, R1, 96 */
		/* 8208E3FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 8208E3FCh case    1:*/		return 0x8208E400;
		  /* 8208E400h */ case    2:  		/* li R9, 0 */
		/* 8208E400h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8208E400h case    2:*/		return 0x8208E404;
		  /* 8208E404h */ case    3:  		/* li R6, 0 */
		/* 8208E404h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8208E404h case    3:*/		return 0x8208E408;
		  /* 8208E408h */ case    4:  		/* li R5, 0 */
		/* 8208E408h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8208E408h case    4:*/		return 0x8208E40C;
		  /* 8208E40Ch */ case    5:  		/* li R4, 1076 */
		/* 8208E40Ch case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x434);
		/* 8208E40Ch case    5:*/		return 0x8208E410;
	}
	return 0x8208E410;
} // Block from 8208E3F8h-8208E410h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208E410h
// Function 'RtlSetLastNTError'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E410);
		  /* 8208E410h */ case    0:  		/* bl 71480 */
		/* 8208E410h case    0:*/		regs.LR = 0x8208E414; return 0x8209FB48;
		/* 8208E410h case    0:*/		return 0x8208E414;
		  /* 8208E414h */ case    1:  		/* or. R31, R3, R3 */
		/* 8208E414h case    1:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 8208E414h case    1:*/		return 0x8208E418;
		  /* 8208E418h */ case    2:  		/* bc 12, CR0_LT, 84 */
		/* 8208E418h case    2:*/		if ( regs.CR[0].lt ) { return 0x8208E46C;  }
		/* 8208E418h case    2:*/		return 0x8208E41C;
		  /* 8208E41Ch */ case    3:  		/* lwz R3, <#[R1 + 96]> */
		/* 8208E41Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 8208E41Ch case    3:*/		return 0x8208E420;
		  /* 8208E420h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 8208E420h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8208E420h case    4:*/		return 0x8208E424;
		  /* 8208E424h */ case    5:  		/* lwz R11, <#[R11 + 12]> */
		/* 8208E424h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8208E424h case    5:*/		return 0x8208E428;
		  /* 8208E428h */ case    6:  		/* mtspr CTR, R11 */
		/* 8208E428h case    6:*/		regs.CTR = regs.R11;
		/* 8208E428h case    6:*/		return 0x8208E42C;
		  /* 8208E42Ch */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 8208E42Ch case    7:*/		if ( 1 ) { regs.LR = 0x8208E430; return (uint32)regs.CTR; }
		/* 8208E42Ch case    7:*/		return 0x8208E430;
		  /* 8208E430h */ case    8:  		/* bl -146256 */
		/* 8208E430h case    8:*/		regs.LR = 0x8208E434; return 0x8206A8E0;
		/* 8208E430h case    8:*/		return 0x8208E434;
		  /* 8208E434h */ case    9:  		/* mr R11, R3 */
		/* 8208E434h case    9:*/		regs.R11 = regs.R3;
		/* 8208E434h case    9:*/		return 0x8208E438;
		  /* 8208E438h */ case   10:  		/* lwz R3, <#[R1 + 96]> */
		/* 8208E438h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 8208E438h case   10:*/		return 0x8208E43C;
		  /* 8208E43Ch */ case   11:  		/* stw R11, <#[R30 + 8]> */
		/* 8208E43Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8208E43Ch case   11:*/		return 0x8208E440;
		  /* 8208E440h */ case   12:  		/* addic R11, R11, -1 */
		/* 8208E440h case   12:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8208E440h case   12:*/		return 0x8208E444;
		  /* 8208E444h */ case   13:  		/* subfe R11, R11, R11 */
		/* 8208E444h case   13:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8208E444h case   13:*/		return 0x8208E448;
	}
	return 0x8208E448;
} // Block from 8208E410h-8208E448h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8208E448h
// Function 'RtlGetLastError'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E448);
		  /* 8208E448h */ case    0:  		/* lwz R10, <#[R3]> */
		/* 8208E448h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8208E448h case    0:*/		return 0x8208E44C;
		  /* 8208E44Ch */ case    1:  		/* and R31, R11, R29 */
		/* 8208E44Ch case    1:*/		cpu::op::and<0>(regs,&regs.R31,regs.R11,regs.R29);
		/* 8208E44Ch case    1:*/		return 0x8208E450;
		  /* 8208E450h */ case    2:  		/* lwz R10, <#[R10 + 8]> */
		/* 8208E450h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8208E450h case    2:*/		return 0x8208E454;
		  /* 8208E454h */ case    3:  		/* mtspr CTR, R10 */
		/* 8208E454h case    3:*/		regs.CTR = regs.R10;
		/* 8208E454h case    3:*/		return 0x8208E458;
		  /* 8208E458h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8208E458h case    4:*/		if ( 1 ) { regs.LR = 0x8208E45C; return (uint32)regs.CTR; }
		/* 8208E458h case    4:*/		return 0x8208E45C;
		  /* 8208E45Ch */ case    5:  		/* cmpwi CR6, R31, 0 */
		/* 8208E45Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 8208E45Ch case    5:*/		return 0x8208E460;
		  /* 8208E460h */ case    6:  		/* bc 12, CR6_LT, 12 */
		/* 8208E460h case    6:*/		if ( regs.CR[6].lt ) { return 0x8208E46C;  }
		/* 8208E460h case    6:*/		return 0x8208E464;
		  /* 8208E464h */ case    7:  		/* mr R31, R27 */
		/* 8208E464h case    7:*/		regs.R31 = regs.R27;
		/* 8208E464h case    7:*/		return 0x8208E468;
	}
	return 0x8208E468;
} // Block from 8208E448h-8208E468h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8208E468h
// Function 'WaitForSingleObjectEx'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E468( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E468) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E468);
		  /* 8208E468h */ case    0:  		/* b 36 */
		/* 8208E468h case    0:*/		return 0x8208E48C;
		/* 8208E468h case    0:*/		return 0x8208E46C;
	}
	return 0x8208E46C;
} // Block from 8208E468h-8208E46Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208E46Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E46C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E46C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E46C);
		  /* 8208E46Ch */ case    0:  		/* lwz R3, <#[R30 + 4]> */
		/* 8208E46Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000004) );
		/* 8208E46Ch case    0:*/		return 0x8208E470;
		  /* 8208E470h */ case    1:  		/* bl -115496 */
		/* 8208E470h case    1:*/		regs.LR = 0x8208E474; return 0x82072148;
		/* 8208E470h case    1:*/		return 0x8208E474;
	}
	return 0x8208E474;
} // Block from 8208E46Ch-8208E474h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208E474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E474);
		  /* 8208E474h */ case    0:  		/* mr R11, R27 */
		/* 8208E474h case    0:*/		regs.R11 = regs.R27;
		/* 8208E474h case    0:*/		return 0x8208E478;
		  /* 8208E478h */ case    1:  		/* stw R27, <#[R30 + 4]> */
		/* 8208E478h case    1:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R30 + 0x00000004) );
		/* 8208E478h case    1:*/		return 0x8208E47C;
	}
	return 0x8208E47C;
} // Block from 8208E474h-8208E47Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208E47Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E47C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E47C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E47C);
		  /* 8208E47Ch */ case    0:  		/* lwz R3, <#[R30]> */
		/* 8208E47Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 8208E47Ch case    0:*/		return 0x8208E480;
		  /* 8208E480h */ case    1:  		/* bl -115512 */
		/* 8208E480h case    1:*/		regs.LR = 0x8208E484; return 0x82072148;
		/* 8208E480h case    1:*/		return 0x8208E484;
	}
	return 0x8208E484;
} // Block from 8208E47Ch-8208E484h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208E484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E484);
		  /* 8208E484h */ case    0:  		/* mr R11, R27 */
		/* 8208E484h case    0:*/		regs.R11 = regs.R27;
		/* 8208E484h case    0:*/		return 0x8208E488;
		  /* 8208E488h */ case    1:  		/* stw R27, <#[R30]> */
		/* 8208E488h case    1:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R30 + 0x00000000) );
		/* 8208E488h case    1:*/		return 0x8208E48C;
	}
	return 0x8208E48C;
} // Block from 8208E484h-8208E48Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208E48Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E48C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E48C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E48C);
		  /* 8208E48Ch */ case    0:  		/* mr R3, R31 */
		/* 8208E48Ch case    0:*/		regs.R3 = regs.R31;
		/* 8208E48Ch case    0:*/		return 0x8208E490;
		  /* 8208E490h */ case    1:  		/* b 28 */
		/* 8208E490h case    1:*/		return 0x8208E4AC;
		/* 8208E490h case    1:*/		return 0x8208E494;
	}
	return 0x8208E494;
} // Block from 8208E48Ch-8208E494h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208E494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E494);
		  /* 8208E494h */ case    0:  		/* bl -118460 */
		/* 8208E494h case    0:*/		regs.LR = 0x8208E498; return 0x820715D8;
		/* 8208E494h case    0:*/		return 0x8208E498;
		  /* 8208E498h */ case    1:  		/* lwz R3, <#[R30 + 4]> */
		/* 8208E498h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000004) );
		/* 8208E498h case    1:*/		return 0x8208E49C;
		  /* 8208E49Ch */ case    2:  		/* bl -118468 */
		/* 8208E49Ch case    2:*/		regs.LR = 0x8208E4A0; return 0x820715D8;
		/* 8208E49Ch case    2:*/		return 0x8208E4A0;
		  /* 8208E4A0h */ case    3:  		/* lwz R3, <#[R30 + 8]> */
		/* 8208E4A0h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000008) );
		/* 8208E4A0h case    3:*/		return 0x8208E4A4;
		  /* 8208E4A4h */ case    4:  		/* bl -118476 */
		/* 8208E4A4h case    4:*/		regs.LR = 0x8208E4A8; return 0x820715D8;
		/* 8208E4A4h case    4:*/		return 0x8208E4A8;
		  /* 8208E4A8h */ case    5:  		/* li R3, 0 */
		/* 8208E4A8h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208E4A8h case    5:*/		return 0x8208E4AC;
	}
	return 0x8208E4AC;
} // Block from 8208E494h-8208E4ACh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208E4ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E4AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E4AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E4AC);
		  /* 8208E4ACh */ case    0:  		/* addi R1, R1, 160 */
		/* 8208E4ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 8208E4ACh case    0:*/		return 0x8208E4B0;
		  /* 8208E4B0h */ case    1:  		/* b 11764 */
		/* 8208E4B0h case    1:*/		return 0x820912A4;
		/* 8208E4B0h case    1:*/		return 0x8208E4B4;
		  /* 8208E4B4h */ case    2:  		/* nop */
		/* 8208E4B4h case    2:*/		cpu::op::nop();
		/* 8208E4B4h case    2:*/		return 0x8208E4B8;
	}
	return 0x8208E4B8;
} // Block from 8208E4ACh-8208E4B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208E4B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E4B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E4B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E4B8);
		  /* 8208E4B8h */ case    0:  		/* mfspr R12, LR */
		/* 8208E4B8h case    0:*/		regs.R12 = regs.LR;
		/* 8208E4B8h case    0:*/		return 0x8208E4BC;
		  /* 8208E4BCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8208E4BCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208E4BCh case    1:*/		return 0x8208E4C0;
		  /* 8208E4C0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8208E4C0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208E4C0h case    2:*/		return 0x8208E4C4;
		  /* 8208E4C4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8208E4C4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8208E4C4h case    3:*/		return 0x8208E4C8;
		  /* 8208E4C8h */ case    4:  		/* lis R11, -32215 */
		/* 8208E4C8h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8208E4C8h case    4:*/		return 0x8208E4CC;
		  /* 8208E4CCh */ case    5:  		/* addi R31, R11, -31256 */
		/* 8208E4CCh case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFF85E8);
		/* 8208E4CCh case    5:*/		return 0x8208E4D0;
	}
	return 0x8208E4D0;
} // Block from 8208E4B8h-8208E4D0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208E4D0h
// Function 'XapiFormatObjectAttributes'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E4D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E4D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E4D0);
		  /* 8208E4D0h */ case    0:  		/* lwz R3, <#[R31 + 8]> */
		/* 8208E4D0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 8208E4D0h case    0:*/		return 0x8208E4D4;
		  /* 8208E4D4h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8208E4D4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8208E4D4h case    1:*/		return 0x8208E4D8;
		  /* 8208E4D8h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 8208E4D8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8208E4F4;  }
		/* 8208E4D8h case    2:*/		return 0x8208E4DC;
		  /* 8208E4DCh */ case    3:  		/* bl -115604 */
		/* 8208E4DCh case    3:*/		regs.LR = 0x8208E4E0; return 0x82072148;
		/* 8208E4DCh case    3:*/		return 0x8208E4E0;
		  /* 8208E4E0h */ case    4:  		/* subfic R11, R3, 0 */
		/* 8208E4E0h case    4:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R3,0x0);
		/* 8208E4E0h case    4:*/		return 0x8208E4E4;
		  /* 8208E4E4h */ case    5:  		/* lwz R11, <#[R31 + 8]> */
		/* 8208E4E4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8208E4E4h case    5:*/		return 0x8208E4E8;
		  /* 8208E4E8h */ case    6:  		/* subfe R10, R10, R10 */
		/* 8208E4E8h case    6:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8208E4E8h case    6:*/		return 0x8208E4EC;
		  /* 8208E4ECh */ case    7:  		/* and R11, R10, R11 */
		/* 8208E4ECh case    7:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208E4ECh case    7:*/		return 0x8208E4F0;
		  /* 8208E4F0h */ case    8:  		/* stw R11, <#[R31 + 8]> */
		/* 8208E4F0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8208E4F0h case    8:*/		return 0x8208E4F4;
	}
	return 0x8208E4F4;
} // Block from 8208E4D0h-8208E4F4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8208E4F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E4F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E4F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E4F4);
		  /* 8208E4F4h */ case    0:  		/* lwz R3, <#[R31 + 4]> */
		/* 8208E4F4h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 8208E4F4h case    0:*/		return 0x8208E4F8;
		  /* 8208E4F8h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8208E4F8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8208E4F8h case    1:*/		return 0x8208E4FC;
		  /* 8208E4FCh */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 8208E4FCh case    2:*/		if ( regs.CR[6].eq ) { return 0x8208E518;  }
		/* 8208E4FCh case    2:*/		return 0x8208E500;
		  /* 8208E500h */ case    3:  		/* bl -115640 */
		/* 8208E500h case    3:*/		regs.LR = 0x8208E504; return 0x82072148;
		/* 8208E500h case    3:*/		return 0x8208E504;
		  /* 8208E504h */ case    4:  		/* subfic R11, R3, 0 */
		/* 8208E504h case    4:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R3,0x0);
		/* 8208E504h case    4:*/		return 0x8208E508;
		  /* 8208E508h */ case    5:  		/* lwz R11, <#[R31 + 4]> */
		/* 8208E508h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8208E508h case    5:*/		return 0x8208E50C;
		  /* 8208E50Ch */ case    6:  		/* subfe R10, R10, R10 */
		/* 8208E50Ch case    6:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8208E50Ch case    6:*/		return 0x8208E510;
		  /* 8208E510h */ case    7:  		/* and R11, R10, R11 */
		/* 8208E510h case    7:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208E510h case    7:*/		return 0x8208E514;
		  /* 8208E514h */ case    8:  		/* stw R11, <#[R31 + 4]> */
		/* 8208E514h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8208E514h case    8:*/		return 0x8208E518;
	}
	return 0x8208E518;
} // Block from 8208E4F4h-8208E518h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8208E518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E518);
		  /* 8208E518h */ case    0:  		/* lwz R3, <#[R31]> */
		/* 8208E518h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8208E518h case    0:*/		return 0x8208E51C;
		  /* 8208E51Ch */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8208E51Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8208E51Ch case    1:*/		return 0x8208E520;
		  /* 8208E520h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 8208E520h case    2:*/		if ( regs.CR[6].eq ) { return 0x8208E53C;  }
		/* 8208E520h case    2:*/		return 0x8208E524;
		  /* 8208E524h */ case    3:  		/* bl -115676 */
		/* 8208E524h case    3:*/		regs.LR = 0x8208E528; return 0x82072148;
		/* 8208E524h case    3:*/		return 0x8208E528;
	}
	return 0x8208E528;
} // Block from 8208E518h-8208E528h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208E528h
// Function 'GetLastError'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E528);
		  /* 8208E528h */ case    0:  		/* subfic R11, R3, 0 */
		/* 8208E528h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R3,0x0);
		/* 8208E528h case    0:*/		return 0x8208E52C;
		  /* 8208E52Ch */ case    1:  		/* lwz R11, <#[R31]> */
		/* 8208E52Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8208E52Ch case    1:*/		return 0x8208E530;
	}
	return 0x8208E530;
} // Block from 8208E528h-8208E530h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208E530h
// Function 'XapiSetLastNTError'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E530);
		  /* 8208E530h */ case    0:  		/* subfe R10, R10, R10 */
		/* 8208E530h case    0:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8208E530h case    0:*/		return 0x8208E534;
		  /* 8208E534h */ case    1:  		/* and R11, R10, R11 */
		/* 8208E534h case    1:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208E534h case    1:*/		return 0x8208E538;
	}
	return 0x8208E538;
} // Block from 8208E530h-8208E538h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208E538h
// Function 'XapipCreateThread'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E538);
		  /* 8208E538h */ case    0:  		/* stw R11, <#[R31]> */
		/* 8208E538h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8208E538h case    0:*/		return 0x8208E53C;
	}
	return 0x8208E53C;
} // Block from 8208E538h-8208E53Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208E53Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E53C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E53C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E53C);
		  /* 8208E53Ch */ case    0:  		/* addi R1, R1, 96 */
		/* 8208E53Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8208E53Ch case    0:*/		return 0x8208E540;
		  /* 8208E540h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8208E540h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208E540h case    1:*/		return 0x8208E544;
		  /* 8208E544h */ case    2:  		/* mtspr LR, R12 */
		/* 8208E544h case    2:*/		regs.LR = regs.R12;
		/* 8208E544h case    2:*/		return 0x8208E548;
		  /* 8208E548h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8208E548h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208E548h case    3:*/		return 0x8208E54C;
		  /* 8208E54Ch */ case    4:  		/* bclr 20, CR0_LT */
		/* 8208E54Ch case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208E54Ch case    4:*/		return 0x8208E550;
	}
	return 0x8208E550;
} // Block from 8208E53Ch-8208E550h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208E550h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E550);
		  /* 8208E550h */ case    0:  		/* mfspr R12, LR */
		/* 8208E550h case    0:*/		regs.R12 = regs.LR;
		/* 8208E550h case    0:*/		return 0x8208E554;
		  /* 8208E554h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8208E554h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208E554h case    1:*/		return 0x8208E558;
		  /* 8208E558h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8208E558h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208E558h case    2:*/		return 0x8208E55C;
		  /* 8208E55Ch */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 8208E55Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8208E55Ch case    3:*/		return 0x8208E560;
		  /* 8208E560h */ case    4:  		/* stw R4, <#[R3 + 112]> */
		/* 8208E560h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000070) );
		/* 8208E560h case    4:*/		return 0x8208E564;
		  /* 8208E564h */ case    5:  		/* mr R31, R3 */
		/* 8208E564h case    5:*/		regs.R31 = regs.R3;
		/* 8208E564h case    5:*/		return 0x8208E568;
		  /* 8208E568h */ case    6:  		/* lwz R11, <#[R5]> */
		/* 8208E568h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8208E568h case    6:*/		return 0x8208E56C;
		  /* 8208E56Ch */ case    7:  		/* cmplwi CR6, R11, 5 */
		/* 8208E56Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 8208E56Ch case    7:*/		return 0x8208E570;
		  /* 8208E570h */ case    8:  		/* bc 4, CR6_EQ, 196 */
		/* 8208E570h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8208E634;  }
		/* 8208E570h case    8:*/		return 0x8208E574;
		  /* 8208E574h */ case    9:  		/* lfs FR0, <#[R5 + 4]> */
		/* 8208E574h case    9:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R5 + 0x00000004) );
		/* 8208E574h case    9:*/		return 0x8208E578;
		  /* 8208E578h */ case   10:  		/* addi R10, R5, 22 */
		/* 8208E578h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0x16);
		/* 8208E578h case   10:*/		return 0x8208E57C;
		  /* 8208E57Ch */ case   11:  		/* stfs FR0, <#[R3 + 28]> */
		/* 8208E57Ch case   11:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x0000001C) );
		/* 8208E57Ch case   11:*/		return 0x8208E580;
		  /* 8208E580h */ case   12:  		/* lfs FR0, <#[R5 + 8]> */
		/* 8208E580h case   12:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R5 + 0x00000008) );
		/* 8208E580h case   12:*/		return 0x8208E584;
		  /* 8208E584h */ case   13:  		/* stfs FR0, <#[R3 + 32]> */
		/* 8208E584h case   13:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x00000020) );
		/* 8208E584h case   13:*/		return 0x8208E588;
		  /* 8208E588h */ case   14:  		/* lfs FR0, <#[R5 + 12]> */
		/* 8208E588h case   14:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R5 + 0x0000000C) );
		/* 8208E588h case   14:*/		return 0x8208E58C;
		  /* 8208E58Ch */ case   15:  		/* stfs FR0, <#[R3 + 36]> */
		/* 8208E58Ch case   15:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x00000024) );
		/* 8208E58Ch case   15:*/		return 0x8208E590;
		  /* 8208E590h */ case   16:  		/* lfs FR0, <#[R5 + 16]> */
		/* 8208E590h case   16:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R5 + 0x00000010) );
		/* 8208E590h case   16:*/		return 0x8208E594;
		  /* 8208E594h */ case   17:  		/* stfs FR0, <#[R3 + 40]> */
		/* 8208E594h case   17:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x00000028) );
		/* 8208E594h case   17:*/		return 0x8208E598;
		  /* 8208E598h */ case   18:  		/* lhz R11, <#[R5 + 20]> */
		/* 8208E598h case   18:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000014) );
		/* 8208E598h case   18:*/		return 0x8208E59C;
		  /* 8208E59Ch */ case   19:  		/* stw R11, <#[R3 + 96]> */
		/* 8208E59Ch case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000060) );
		/* 8208E59Ch case   19:*/		return 0x8208E5A0;
		  /* 8208E5A0h */ case   20:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 8208E5A0h case   20:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 8208E5A0h case   20:*/		return 0x8208E5A4;
		  /* 8208E5A4h */ case   21:  		/* addi R11, R11, 12 */
		/* 8208E5A4h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8208E5A4h case   21:*/		return 0x8208E5A8;
	}
	return 0x8208E5A8;
} // Block from 8208E550h-8208E5A8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8208E5A8h
// Function 'XapiInitDebugHeap'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E5A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E5A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E5A8);
		  /* 8208E5A8h */ case    0:  		/* stw R10, <#[R3 + 100]> */
		/* 8208E5A8h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000064) );
		/* 8208E5A8h case    0:*/		return 0x8208E5AC;
		  /* 8208E5ACh */ case    1:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 8208E5ACh case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 8208E5ACh case    1:*/		return 0x8208E5B0;
		  /* 8208E5B0h */ case    2:  		/* add R11, R11, R5 */
		/* 8208E5B0h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 8208E5B0h case    2:*/		return 0x8208E5B4;
		  /* 8208E5B4h */ case    3:  		/* addi R10, R11, 4 */
		/* 8208E5B4h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8208E5B4h case    3:*/		return 0x8208E5B8;
		  /* 8208E5B8h */ case    4:  		/* lwz R11, <#[R11]> */
		/* 8208E5B8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8208E5B8h case    4:*/		return 0x8208E5BC;
		  /* 8208E5BCh */ case    5:  		/* stw R11, <#[R3 + 104]> */
		/* 8208E5BCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000068) );
		/* 8208E5BCh case    5:*/		return 0x8208E5C0;
		  /* 8208E5C0h */ case    6:  		/* stw R10, <#[R3 + 108]> */
		/* 8208E5C0h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x0000006C) );
		/* 8208E5C0h case    6:*/		return 0x8208E5C4;
		  /* 8208E5C4h */ case    7:  		/* bl -700 */
		/* 8208E5C4h case    7:*/		regs.LR = 0x8208E5C8; return 0x8208E308;
		/* 8208E5C4h case    7:*/		return 0x8208E5C8;
		  /* 8208E5C8h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 8208E5C8h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208E5C8h case    8:*/		return 0x8208E5CC;
		  /* 8208E5CCh */ case    9:  		/* bc 4, CR0_LT, 40 */
		/* 8208E5CCh case    9:*/		if ( !regs.CR[0].lt ) { return 0x8208E5F4;  }
		/* 8208E5CCh case    9:*/		return 0x8208E5D0;
		  /* 8208E5D0h */ case   10:  		/* lis R11, -32255 */
		/* 8208E5D0h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208E5D0h case   10:*/		return 0x8208E5D4;
		  /* 8208E5D4h */ case   11:  		/* lis R10, -32256 */
		/* 8208E5D4h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8208E5D4h case   11:*/		return 0x8208E5D8;
		  /* 8208E5D8h */ case   12:  		/* addi R4, R11, -26980 */
		/* 8208E5D8h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFF969C);
		/* 8208E5D8h case   12:*/		return 0x8208E5DC;
		  /* 8208E5DCh */ case   13:  		/* addi R3, R10, 2596 */
		/* 8208E5DCh case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 8208E5DCh case   13:*/		return 0x8208E5E0;
		  /* 8208E5E0h */ case   14:  		/* li R5, 354 */
		/* 8208E5E0h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x162);
		/* 8208E5E0h case   14:*/		return 0x8208E5E4;
		  /* 8208E5E4h */ case   15:  		/* bl 4948 */
		/* 8208E5E4h case   15:*/		regs.LR = 0x8208E5E8; return 0x8208F938;
		/* 8208E5E4h case   15:*/		return 0x8208E5E8;
		  /* 8208E5E8h */ case   16:  		/* lis R11, -32255 */
		/* 8208E5E8h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208E5E8h case   16:*/		return 0x8208E5EC;
		  /* 8208E5ECh */ case   17:  		/* addi R3, R11, -27012 */
		/* 8208E5ECh case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF967C);
		/* 8208E5ECh case   17:*/		return 0x8208E5F0;
		  /* 8208E5F0h */ case   18:  		/* b 100 */
		/* 8208E5F0h case   18:*/		return 0x8208E654;
		/* 8208E5F0h case   18:*/		return 0x8208E5F4;
	}
	return 0x8208E5F4;
} // Block from 8208E5A8h-8208E5F4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8208E5F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E5F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E5F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E5F4);
		  /* 8208E5F4h */ case    0:  		/* lis R11, -32215 */
		/* 8208E5F4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8208E5F4h case    0:*/		return 0x8208E5F8;
		  /* 8208E5F8h */ case    1:  		/* addi R5, R1, 80 */
		/* 8208E5F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8208E5F8h case    1:*/		return 0x8208E5FC;
		  /* 8208E5FCh */ case    2:  		/* li R4, 0 */
		/* 8208E5FCh case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208E5FCh case    2:*/		return 0x8208E600;
		  /* 8208E600h */ case    3:  		/* lwz R3, <#[R11 - 31244]> */
		/* 8208E600h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFF85F4) );
		/* 8208E600h case    3:*/		return 0x8208E604;
		  /* 8208E604h */ case    4:  		/* bl -103100 */
		/* 8208E604h case    4:*/		regs.LR = 0x8208E608; return 0x82075348;
		/* 8208E604h case    4:*/		return 0x8208E608;
		  /* 8208E608h */ case    5:  		/* li R11, 0 */
		/* 8208E608h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8208E608h case    5:*/		return 0x8208E60C;
		  /* 8208E60Ch */ case    6:  		/* li R10, 1 */
		/* 8208E60Ch case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8208E60Ch case    6:*/		return 0x8208E610;
		  /* 8208E610h */ case    7:  		/* stw R11, <#[R31 + 72]> */
		/* 8208E610h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 8208E610h case    7:*/		return 0x8208E614;
		  /* 8208E614h */ case    8:  		/* li R3, 0 */
		/* 8208E614h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208E614h case    8:*/		return 0x8208E618;
		  /* 8208E618h */ case    9:  		/* stw R11, <#[R31 + 76]> */
		/* 8208E618h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 8208E618h case    9:*/		return 0x8208E61C;
		  /* 8208E61Ch */ case   10:  		/* stw R10, <#[R31 + 184]> */
		/* 8208E61Ch case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x000000B8) );
		/* 8208E61Ch case   10:*/		return 0x8208E620;
		  /* 8208E620h */ case   11:  		/* lwz R11, <#[R1 + 80]> */
		/* 8208E620h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208E620h case   11:*/		return 0x8208E624;
		  /* 8208E624h */ case   12:  		/* lwz R10, <#[R1 + 84]> */
		/* 8208E624h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 8208E624h case   12:*/		return 0x8208E628;
		  /* 8208E628h */ case   13:  		/* stw R11, <#[R31 + 80]> */
		/* 8208E628h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208E628h case   13:*/		return 0x8208E62C;
		  /* 8208E62Ch */ case   14:  		/* stw R10, <#[R31 + 84]> */
		/* 8208E62Ch case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000054) );
		/* 8208E62Ch case   14:*/		return 0x8208E630;
		  /* 8208E630h */ case   15:  		/* b 48 */
		/* 8208E630h case   15:*/		return 0x8208E660;
		/* 8208E630h case   15:*/		return 0x8208E634;
	}
	return 0x8208E634;
} // Block from 8208E5F4h-8208E634h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8208E634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E634);
		  /* 8208E634h */ case    0:  		/* lis R11, -32255 */
		/* 8208E634h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208E634h case    0:*/		return 0x8208E638;
		  /* 8208E638h */ case    1:  		/* lis R10, -32256 */
		/* 8208E638h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8208E638h case    1:*/		return 0x8208E63C;
		  /* 8208E63Ch */ case    2:  		/* addi R4, R11, -26980 */
		/* 8208E63Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFF969C);
		/* 8208E63Ch case    2:*/		return 0x8208E640;
		  /* 8208E640h */ case    3:  		/* addi R3, R10, 2596 */
		/* 8208E640h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 8208E640h case    3:*/		return 0x8208E644;
		  /* 8208E644h */ case    4:  		/* li R5, 347 */
		/* 8208E644h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x15B);
		/* 8208E644h case    4:*/		return 0x8208E648;
	}
	return 0x8208E648;
} // Block from 8208E634h-8208E648h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208E648h
// Function 'RtlpCreateUnCommittedRange'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E648);
		  /* 8208E648h */ case    0:  		/* bl 4848 */
		/* 8208E648h case    0:*/		regs.LR = 0x8208E64C; return 0x8208F938;
		/* 8208E648h case    0:*/		return 0x8208E64C;
		  /* 8208E64Ch */ case    1:  		/* lis R11, -32255 */
		/* 8208E64Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208E64Ch case    1:*/		return 0x8208E650;
		  /* 8208E650h */ case    2:  		/* addi R3, R11, -27052 */
		/* 8208E650h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF9654);
		/* 8208E650h case    2:*/		return 0x8208E654;
	}
	return 0x8208E654;
} // Block from 8208E648h-8208E654h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208E654h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E654( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E654) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E654);
		  /* 8208E654h */ case    0:  		/* bl 4836 */
		/* 8208E654h case    0:*/		regs.LR = 0x8208E658; return 0x8208F938;
		/* 8208E654h case    0:*/		return 0x8208E658;
		  /* 8208E658h */ case    1:  		/* lis R3, -32768 */
		/* 8208E658h case    1:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8208E658h case    1:*/		return 0x8208E65C;
		  /* 8208E65Ch */ case    2:  		/* ori R3, R3, 16389 */
		/* 8208E65Ch case    2:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8208E65Ch case    2:*/		return 0x8208E660;
	}
	return 0x8208E660;
} // Block from 8208E654h-8208E660h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208E660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E660);
		  /* 8208E660h */ case    0:  		/* addi R1, R1, 112 */
		/* 8208E660h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8208E660h case    0:*/		return 0x8208E664;
		  /* 8208E664h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8208E664h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208E664h case    1:*/		return 0x8208E668;
		  /* 8208E668h */ case    2:  		/* mtspr LR, R12 */
		/* 8208E668h case    2:*/		regs.LR = regs.R12;
		/* 8208E668h case    2:*/		return 0x8208E66C;
		  /* 8208E66Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8208E66Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208E66Ch case    3:*/		return 0x8208E670;
		  /* 8208E670h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8208E670h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208E670h case    4:*/		return 0x8208E674;
	}
	return 0x8208E674;
} // Block from 8208E660h-8208E674h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208E674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E674);
		  /* 8208E674h */ case    0:  		/* nop */
		/* 8208E674h case    0:*/		cpu::op::nop();
		/* 8208E674h case    0:*/		return 0x8208E678;
	}
	return 0x8208E678;
} // Block from 8208E674h-8208E678h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208E678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E678);
		  /* 8208E678h */ case    0:  		/* mfspr R12, LR */
		/* 8208E678h case    0:*/		regs.R12 = regs.LR;
		/* 8208E678h case    0:*/		return 0x8208E67C;
		  /* 8208E67Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8208E67Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208E67Ch case    1:*/		return 0x8208E680;
		  /* 8208E680h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8208E680h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208E680h case    2:*/		return 0x8208E684;
		  /* 8208E684h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8208E684h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8208E684h case    3:*/		return 0x8208E688;
		  /* 8208E688h */ case    4:  		/* li R11, 0 */
		/* 8208E688h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8208E688h case    4:*/		return 0x8208E68C;
		  /* 8208E68Ch */ case    5:  		/* mr R31, R3 */
		/* 8208E68Ch case    5:*/		regs.R31 = regs.R3;
		/* 8208E68Ch case    5:*/		return 0x8208E690;
		  /* 8208E690h */ case    6:  		/* stw R11, <#[R3 + 112]> */
		/* 8208E690h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000070) );
		/* 8208E690h case    6:*/		return 0x8208E694;
		  /* 8208E694h */ case    7:  		/* stw R11, <#[R3 + 104]> */
		/* 8208E694h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000068) );
		/* 8208E694h case    7:*/		return 0x8208E698;
		  /* 8208E698h */ case    8:  		/* stw R11, <#[R3 + 108]> */
		/* 8208E698h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000006C) );
		/* 8208E698h case    8:*/		return 0x8208E69C;
		  /* 8208E69Ch */ case    9:  		/* stw R11, <#[R3 + 96]> */
		/* 8208E69Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000060) );
		/* 8208E69Ch case    9:*/		return 0x8208E6A0;
		  /* 8208E6A0h */ case   10:  		/* stw R11, <#[R3 + 100]> */
		/* 8208E6A0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000064) );
		/* 8208E6A0h case   10:*/		return 0x8208E6A4;
		  /* 8208E6A4h */ case   11:  		/* stw R11, <#[R3 + 180]> */
		/* 8208E6A4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000B4) );
		/* 8208E6A4h case   11:*/		return 0x8208E6A8;
		  /* 8208E6A8h */ case   12:  		/* bl -496 */
		/* 8208E6A8h case   12:*/		regs.LR = 0x8208E6AC; return 0x8208E4B8;
		/* 8208E6A8h case   12:*/		return 0x8208E6AC;
		  /* 8208E6ACh */ case   13:  		/* mr R3, R31 */
		/* 8208E6ACh case   13:*/		regs.R3 = regs.R31;
		/* 8208E6ACh case   13:*/		return 0x8208E6B0;
		  /* 8208E6B0h */ case   14:  		/* bl -2112 */
		/* 8208E6B0h case   14:*/		regs.LR = 0x8208E6B4; return 0x8208DE70;
		/* 8208E6B0h case   14:*/		return 0x8208E6B4;
		  /* 8208E6B4h */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 8208E6B4h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208E6B4h case   15:*/		return 0x8208E6B8;
		  /* 8208E6B8h */ case   16:  		/* bc 12, CR0_EQ, 12 */
		/* 8208E6B8h case   16:*/		if ( regs.CR[0].eq ) { return 0x8208E6C4;  }
		/* 8208E6B8h case   16:*/		return 0x8208E6BC;
		  /* 8208E6BCh */ case   17:  		/* mr R3, R31 */
		/* 8208E6BCh case   17:*/		regs.R3 = regs.R31;
		/* 8208E6BCh case   17:*/		return 0x8208E6C0;
		  /* 8208E6C0h */ case   18:  		/* bl -2240 */
		/* 8208E6C0h case   18:*/		regs.LR = 0x8208E6C4; return 0x8208DE00;
		/* 8208E6C0h case   18:*/		return 0x8208E6C4;
	}
	return 0x8208E6C4;
} // Block from 8208E678h-8208E6C4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8208E6C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E6C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E6C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E6C4);
		  /* 8208E6C4h */ case    0:  		/* addi R1, R1, 96 */
		/* 8208E6C4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8208E6C4h case    0:*/		return 0x8208E6C8;
		  /* 8208E6C8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8208E6C8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208E6C8h case    1:*/		return 0x8208E6CC;
		  /* 8208E6CCh */ case    2:  		/* mtspr LR, R12 */
		/* 8208E6CCh case    2:*/		regs.LR = regs.R12;
		/* 8208E6CCh case    2:*/		return 0x8208E6D0;
		  /* 8208E6D0h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8208E6D0h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208E6D0h case    3:*/		return 0x8208E6D4;
		  /* 8208E6D4h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8208E6D4h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208E6D4h case    4:*/		return 0x8208E6D8;
	}
	return 0x8208E6D8;
} // Block from 8208E6C4h-8208E6D8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208E6D8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E6D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E6D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E6D8);
		  /* 8208E6D8h */ case    0:  		/* mfspr R12, LR */
		/* 8208E6D8h case    0:*/		regs.R12 = regs.LR;
		/* 8208E6D8h case    0:*/		return 0x8208E6DC;
		  /* 8208E6DCh */ case    1:  		/* bl 11136 */
		/* 8208E6DCh case    1:*/		regs.LR = 0x8208E6E0; return 0x8209125C;
		/* 8208E6DCh case    1:*/		return 0x8208E6E0;
		  /* 8208E6E0h */ case    2:  		/* stfd FR29, <#[R1 - 56]> */
		/* 8208E6E0h case    2:*/		cpu::mem::store64f( regs, regs.FR29, (uint32)(regs.R1 + 0xFFFFFFC8) );
		/* 8208E6E0h case    2:*/		return 0x8208E6E4;
		  /* 8208E6E4h */ case    3:  		/* stfd FR30, <#[R1 - 48]> */
		/* 8208E6E4h case    3:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFFD0) );
		/* 8208E6E4h case    3:*/		return 0x8208E6E8;
		  /* 8208E6E8h */ case    4:  		/* stfd FR31, <#[R1 - 40]> */
		/* 8208E6E8h case    4:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFD8) );
		/* 8208E6E8h case    4:*/		return 0x8208E6EC;
		  /* 8208E6ECh */ case    5:  		/* stwu R1, <#[R1 - 192]> */
		/* 8208E6ECh case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 8208E6ECh case    5:*/		return 0x8208E6F0;
		  /* 8208E6F0h */ case    6:  		/* lwz R11, <#[R3 + 180]> */
		/* 8208E6F0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000B4) );
		/* 8208E6F0h case    6:*/		return 0x8208E6F4;
		  /* 8208E6F4h */ case    7:  		/* mr R30, R3 */
		/* 8208E6F4h case    7:*/		regs.R30 = regs.R3;
		/* 8208E6F4h case    7:*/		return 0x8208E6F8;
		  /* 8208E6F8h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 8208E6F8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208E6F8h case    8:*/		return 0x8208E6FC;
		  /* 8208E6FCh */ case    9:  		/* bc 4, CR6_EQ, 644 */
		/* 8208E6FCh case    9:*/		if ( !regs.CR[6].eq ) { return 0x8208E980;  }
		/* 8208E6FCh case    9:*/		return 0x8208E700;
		  /* 8208E700h */ case   10:  		/* lis R11, -32215 */
		/* 8208E700h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8208E700h case   10:*/		return 0x8208E704;
		  /* 8208E704h */ case   11:  		/* lwz R10, <#[R3 + 184]> */
		/* 8208E704h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x000000B8) );
		/* 8208E704h case   11:*/		return 0x8208E708;
		  /* 8208E708h */ case   12:  		/* cmpwi CR6, R10, 0 */
		/* 8208E708h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8208E708h case   12:*/		return 0x8208E70C;
		  /* 8208E70Ch */ case   13:  		/* lwz R31, <#[R11 - 31244]> */
		/* 8208E70Ch case   13:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0xFFFF85F4) );
		/* 8208E70Ch case   13:*/		return 0x8208E710;
		  /* 8208E710h */ case   14:  		/* bc 12, CR6_EQ, 212 */
		/* 8208E710h case   14:*/		if ( regs.CR[6].eq ) { return 0x8208E7E4;  }
		/* 8208E710h case   14:*/		return 0x8208E714;
		  /* 8208E714h */ case   15:  		/* mr R3, R31 */
		/* 8208E714h case   15:*/		regs.R3 = regs.R31;
		/* 8208E714h case   15:*/		return 0x8208E718;
		  /* 8208E718h */ case   16:  		/* bl -181104 */
		/* 8208E718h case   16:*/		regs.LR = 0x8208E71C; return 0x820623A8;
		/* 8208E718h case   16:*/		return 0x8208E71C;
		  /* 8208E71Ch */ case   17:  		/* stw R3, <#[R30 + 116]> */
		/* 8208E71Ch case   17:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000074) );
		/* 8208E71Ch case   17:*/		return 0x8208E720;
		  /* 8208E720h */ case   18:  		/* mr R3, R31 */
		/* 8208E720h case   18:*/		regs.R3 = regs.R31;
		/* 8208E720h case   18:*/		return 0x8208E724;
		  /* 8208E724h */ case   19:  		/* bl -180828 */
		/* 8208E724h case   19:*/		regs.LR = 0x8208E728; return 0x820624C8;
		/* 8208E724h case   19:*/		return 0x8208E728;
		  /* 8208E728h */ case   20:  		/* stw R3, <#[R30 + 120]> */
		/* 8208E728h case   20:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000078) );
		/* 8208E728h case   20:*/		return 0x8208E72C;
		  /* 8208E72Ch */ case   21:  		/* mr R3, R31 */
		/* 8208E72Ch case   21:*/		regs.R3 = regs.R31;
		/* 8208E72Ch case   21:*/		return 0x8208E730;
		  /* 8208E730h */ case   22:  		/* bl -180696 */
		/* 8208E730h case   22:*/		regs.LR = 0x8208E734; return 0x82062558;
		/* 8208E730h case   22:*/		return 0x8208E734;
		  /* 8208E734h */ case   23:  		/* stw R3, <#[R30 + 124]> */
		/* 8208E734h case   23:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000007C) );
		/* 8208E734h case   23:*/		return 0x8208E738;
		  /* 8208E738h */ case   24:  		/* mr R3, R31 */
		/* 8208E738h case   24:*/		regs.R3 = regs.R31;
		/* 8208E738h case   24:*/		return 0x8208E73C;
		  /* 8208E73Ch */ case   25:  		/* bl -180996 */
		/* 8208E73Ch case   25:*/		regs.LR = 0x8208E740; return 0x82062438;
		/* 8208E73Ch case   25:*/		return 0x8208E740;
		  /* 8208E740h */ case   26:  		/* stw R3, <#[R30 + 128]> */
		/* 8208E740h case   26:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000080) );
		/* 8208E740h case   26:*/		return 0x8208E744;
		  /* 8208E744h */ case   27:  		/* mr R3, R31 */
		/* 8208E744h case   27:*/		regs.R3 = regs.R31;
		/* 8208E744h case   27:*/		return 0x8208E748;
		  /* 8208E748h */ case   28:  		/* bl -181296 */
		/* 8208E748h case   28:*/		regs.LR = 0x8208E74C; return 0x82062318;
		/* 8208E748h case   28:*/		return 0x8208E74C;
		  /* 8208E74Ch */ case   29:  		/* stw R3, <#[R30 + 132]> */
		/* 8208E74Ch case   29:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000084) );
		/* 8208E74Ch case   29:*/		return 0x8208E750;
		  /* 8208E750h */ case   30:  		/* mr R3, R31 */
		/* 8208E750h case   30:*/		regs.R3 = regs.R31;
		/* 8208E750h case   30:*/		return 0x8208E754;
		  /* 8208E754h */ case   31:  		/* bl -180172 */
		/* 8208E754h case   31:*/		regs.LR = 0x8208E758; return 0x82062788;
		/* 8208E754h case   31:*/		return 0x8208E758;
		  /* 8208E758h */ case   32:  		/* stw R3, <#[R30 + 136]> */
		/* 8208E758h case   32:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000088) );
		/* 8208E758h case   32:*/		return 0x8208E75C;
		  /* 8208E75Ch */ case   33:  		/* mr R3, R31 */
		/* 8208E75Ch case   33:*/		regs.R3 = regs.R31;
		/* 8208E75Ch case   33:*/		return 0x8208E760;
		  /* 8208E760h */ case   34:  		/* bl -180112 */
		/* 8208E760h case   34:*/		regs.LR = 0x8208E764; return 0x820627D0;
		/* 8208E760h case   34:*/		return 0x8208E764;
		  /* 8208E764h */ case   35:  		/* stw R3, <#[R30 + 140]> */
		/* 8208E764h case   35:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000008C) );
		/* 8208E764h case   35:*/		return 0x8208E768;
		  /* 8208E768h */ case   36:  		/* mr R3, R31 */
		/* 8208E768h case   36:*/		regs.R3 = regs.R31;
		/* 8208E768h case   36:*/		return 0x8208E76C;
		  /* 8208E76Ch */ case   37:  		/* bl -181388 */
		/* 8208E76Ch case   37:*/		regs.LR = 0x8208E770; return 0x820622E0;
		/* 8208E76Ch case   37:*/		return 0x8208E770;
		  /* 8208E770h */ case   38:  		/* stw R3, <#[R30 + 144]> */
		/* 8208E770h case   38:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000090) );
		/* 8208E770h case   38:*/		return 0x8208E774;
		  /* 8208E774h */ case   39:  		/* mr R3, R31 */
		/* 8208E774h case   39:*/		regs.R3 = regs.R31;
		/* 8208E774h case   39:*/		return 0x8208E778;
		  /* 8208E778h */ case   40:  		/* bl -181448 */
		/* 8208E778h case   40:*/		regs.LR = 0x8208E77C; return 0x820622B0;
		/* 8208E778h case   40:*/		return 0x8208E77C;
		  /* 8208E77Ch */ case   41:  		/* stw R3, <#[R30 + 148]> */
		/* 8208E77Ch case   41:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000094) );
		/* 8208E77Ch case   41:*/		return 0x8208E780;
		  /* 8208E780h */ case   42:  		/* mr R3, R31 */
		/* 8208E780h case   42:*/		regs.R3 = regs.R31;
		/* 8208E780h case   42:*/		return 0x8208E784;
		  /* 8208E784h */ case   43:  		/* bl -179604 */
		/* 8208E784h case   43:*/		regs.LR = 0x8208E788; return 0x820629F0;
		/* 8208E784h case   43:*/		return 0x8208E788;
		  /* 8208E788h */ case   44:  		/* stw R3, <#[R30 + 152]> */
		/* 8208E788h case   44:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000098) );
		/* 8208E788h case   44:*/		return 0x8208E78C;
		  /* 8208E78Ch */ case   45:  		/* mr R3, R31 */
		/* 8208E78Ch case   45:*/		regs.R3 = regs.R31;
		/* 8208E78Ch case   45:*/		return 0x8208E790;
		  /* 8208E790h */ case   46:  		/* bl -179448 */
		/* 8208E790h case   46:*/		regs.LR = 0x8208E794; return 0x82062A98;
		/* 8208E790h case   46:*/		return 0x8208E794;
		  /* 8208E794h */ case   47:  		/* stw R3, <#[R30 + 156]> */
		/* 8208E794h case   47:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000009C) );
		/* 8208E794h case   47:*/		return 0x8208E798;
		  /* 8208E798h */ case   48:  		/* mr R3, R31 */
		/* 8208E798h case   48:*/		regs.R3 = regs.R31;
		/* 8208E798h case   48:*/		return 0x8208E79C;
		  /* 8208E79Ch */ case   49:  		/* bl -176796 */
		/* 8208E79Ch case   49:*/		regs.LR = 0x8208E7A0; return 0x82063500;
		/* 8208E79Ch case   49:*/		return 0x8208E7A0;
		  /* 8208E7A0h */ case   50:  		/* stw R3, <#[R30 + 160]> */
		/* 8208E7A0h case   50:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x000000A0) );
		/* 8208E7A0h case   50:*/		return 0x8208E7A4;
		  /* 8208E7A4h */ case   51:  		/* li R4, 0 */
		/* 8208E7A4h case   51:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208E7A4h case   51:*/		return 0x8208E7A8;
		  /* 8208E7A8h */ case   52:  		/* mr R3, R31 */
		/* 8208E7A8h case   52:*/		regs.R3 = regs.R31;
		/* 8208E7A8h case   52:*/		return 0x8208E7AC;
		  /* 8208E7ACh */ case   53:  		/* bl -175028 */
		/* 8208E7ACh case   53:*/		regs.LR = 0x8208E7B0; return 0x82063BF8;
		/* 8208E7ACh case   53:*/		return 0x8208E7B0;
		  /* 8208E7B0h */ case   54:  		/* stw R3, <#[R30 + 164]> */
		/* 8208E7B0h case   54:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x000000A4) );
		/* 8208E7B0h case   54:*/		return 0x8208E7B4;
		  /* 8208E7B4h */ case   55:  		/* li R4, 0 */
		/* 8208E7B4h case   55:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208E7B4h case   55:*/		return 0x8208E7B8;
		  /* 8208E7B8h */ case   56:  		/* mr R3, R31 */
		/* 8208E7B8h case   56:*/		regs.R3 = regs.R31;
		/* 8208E7B8h case   56:*/		return 0x8208E7BC;
		  /* 8208E7BCh */ case   57:  		/* bl -174620 */
		/* 8208E7BCh case   57:*/		regs.LR = 0x8208E7C0; return 0x82063DA0;
		/* 8208E7BCh case   57:*/		return 0x8208E7C0;
		  /* 8208E7C0h */ case   58:  		/* stw R3, <#[R30 + 168]> */
		/* 8208E7C0h case   58:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x000000A8) );
		/* 8208E7C0h case   58:*/		return 0x8208E7C4;
		  /* 8208E7C4h */ case   59:  		/* li R4, 0 */
		/* 8208E7C4h case   59:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208E7C4h case   59:*/		return 0x8208E7C8;
		  /* 8208E7C8h */ case   60:  		/* mr R3, R31 */
		/* 8208E7C8h case   60:*/		regs.R3 = regs.R31;
		/* 8208E7C8h case   60:*/		return 0x8208E7CC;
		  /* 8208E7CCh */ case   61:  		/* bl -173292 */
		/* 8208E7CCh case   61:*/		regs.LR = 0x8208E7D0; return 0x820642E0;
		/* 8208E7CCh case   61:*/		return 0x8208E7D0;
		  /* 8208E7D0h */ case   62:  		/* stw R3, <#[R30 + 172]> */
		/* 8208E7D0h case   62:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x000000AC) );
		/* 8208E7D0h case   62:*/		return 0x8208E7D4;
		  /* 8208E7D4h */ case   63:  		/* li R4, 0 */
		/* 8208E7D4h case   63:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208E7D4h case   63:*/		return 0x8208E7D8;
		  /* 8208E7D8h */ case   64:  		/* mr R3, R31 */
		/* 8208E7D8h case   64:*/		regs.R3 = regs.R31;
		/* 8208E7D8h case   64:*/		return 0x8208E7DC;
		  /* 8208E7DCh */ case   65:  		/* bl -173228 */
		/* 8208E7DCh case   65:*/		regs.LR = 0x8208E7E0; return 0x82064330;
		/* 8208E7DCh case   65:*/		return 0x8208E7E0;
		  /* 8208E7E0h */ case   66:  		/* stw R3, <#[R30 + 176]> */
		/* 8208E7E0h case   66:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x000000B0) );
		/* 8208E7E0h case   66:*/		return 0x8208E7E4;
	}
	return 0x8208E7E4;
} // Block from 8208E6D8h-8208E7E4h (67 instructions)

//////////////////////////////////////////////////////
// Block at 8208E7E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E7E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E7E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E7E4);
		  /* 8208E7E4h */ case    0:  		/* addi R5, R1, 96 */
		/* 8208E7E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 8208E7E4h case    0:*/		return 0x8208E7E8;
		  /* 8208E7E8h */ case    1:  		/* lwz R3, <#[R30 + 112]> */
		/* 8208E7E8h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000070) );
		/* 8208E7E8h case    1:*/		return 0x8208E7EC;
		  /* 8208E7ECh */ case    2:  		/* li R4, 0 */
		/* 8208E7ECh case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208E7ECh case    2:*/		return 0x8208E7F0;
		  /* 8208E7F0h */ case    3:  		/* bl -162528 */
		/* 8208E7F0h case    3:*/		regs.LR = 0x8208E7F4; return 0x82066D10;
		/* 8208E7F0h case    3:*/		return 0x8208E7F4;
		  /* 8208E7F4h */ case    4:  		/* li R6, 0 */
		/* 8208E7F4h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8208E7F4h case    4:*/		return 0x8208E7F8;
		  /* 8208E7F8h */ case    5:  		/* li R4, 0 */
		/* 8208E7F8h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208E7F8h case    5:*/		return 0x8208E7FC;
		  /* 8208E7FCh */ case    6:  		/* lwz R5, <#[R30 + 112]> */
		/* 8208E7FCh case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000070) );
		/* 8208E7FCh case    6:*/		return 0x8208E800;
		  /* 8208E800h */ case    7:  		/* oris R6, R6, 32768 */
		/* 8208E800h case    7:*/		cpu::op::oris<0>(regs,&regs.R6,regs.R6,0x8000);
		/* 8208E800h case    7:*/		return 0x8208E804;
		  /* 8208E804h */ case    8:  		/* mr R3, R31 */
		/* 8208E804h case    8:*/		regs.R3 = regs.R31;
		/* 8208E804h case    8:*/		return 0x8208E808;
		  /* 8208E808h */ case    9:  		/* bl -161944 */
		/* 8208E808h case    9:*/		regs.LR = 0x8208E80C; return 0x82066F70;
		/* 8208E808h case    9:*/		return 0x8208E80C;
		  /* 8208E80Ch */ case   10:  		/* lis R11, -32256 */
		/* 8208E80Ch case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8208E80Ch case   10:*/		return 0x8208E810;
		  /* 8208E810h */ case   11:  		/* lis R10, -32256 */
		/* 8208E810h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8208E810h case   11:*/		return 0x8208E814;
		  /* 8208E814h */ case   12:  		/* li R4, 1 */
		/* 8208E814h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8208E814h case   12:*/		return 0x8208E818;
		  /* 8208E818h */ case   13:  		/* mr R3, R31 */
		/* 8208E818h case   13:*/		regs.R3 = regs.R31;
		/* 8208E818h case   13:*/		return 0x8208E81C;
		  /* 8208E81Ch */ case   14:  		/* lfs FR0, <#[R11 + 1792]> */
		/* 8208E81Ch case   14:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000700) );
		/* 8208E81Ch case   14:*/		return 0x8208E820;
	}
	return 0x8208E820;
} // Block from 8208E7E4h-8208E820h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8208E820h
// Function 'RtlpInsertUnCommittedPages'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E820);
		  /* 8208E820h */ case    0:  		/* lfs FR31, <#[R10 + 1816]> */
		/* 8208E820h case    0:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R10 + 0x00000718) );
		/* 8208E820h case    0:*/		return 0x8208E824;
		  /* 8208E824h */ case    1:  		/* lwz R11, <#[R1 + 124]> */
		/* 8208E824h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000007C) );
		/* 8208E824h case    1:*/		return 0x8208E828;
		  /* 8208E828h */ case    2:  		/* lwz R10, <#[R1 + 120]> */
		/* 8208E828h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000078) );
		/* 8208E828h case    2:*/		return 0x8208E82C;
		  /* 8208E82Ch */ case    3:  		/* std R11, <#[R1 + 80]> */
		/* 8208E82Ch case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208E82Ch case    3:*/		return 0x8208E830;
		  /* 8208E830h */ case    4:  		/* lfd FR13, <#[R1 + 80]> */
		/* 8208E830h case    4:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 8208E830h case    4:*/		return 0x8208E834;
		  /* 8208E834h */ case    5:  		/* std R10, <#[R1 + 80]> */
		/* 8208E834h case    5:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8208E834h case    5:*/		return 0x8208E838;
		  /* 8208E838h */ case    6:  		/* lfd FR12, <#[R1 + 80]> */
		/* 8208E838h case    6:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R1 + 0x00000050) );
		/* 8208E838h case    6:*/		return 0x8208E83C;
		  /* 8208E83Ch */ case    7:  		/* fcfid FR12, FR12 */
		/* 8208E83Ch case    7:*/		cpu::op::fcfid<0>(regs,&regs.FR12,regs.FR12);
		/* 8208E83Ch case    7:*/		return 0x8208E840;
		  /* 8208E840h */ case    8:  		/* fcfid FR13, FR13 */
		/* 8208E840h case    8:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 8208E840h case    8:*/		return 0x8208E844;
		  /* 8208E844h */ case    9:  		/* frsp FR12, FR12 */
		/* 8208E844h case    9:*/		cpu::op::frsp<0>(regs,&regs.FR12,regs.FR12);
		/* 8208E844h case    9:*/		return 0x8208E848;
		  /* 8208E848h */ case   10:  		/* frsp FR13, FR13 */
		/* 8208E848h case   10:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 8208E848h case   10:*/		return 0x8208E84C;
		  /* 8208E84Ch */ case   11:  		/* fdivs FR30, FR0, FR12 */
		/* 8208E84Ch case   11:*/		cpu::op::fdivs<0>(regs,&regs.FR30,regs.FR0,regs.FR12);
		/* 8208E84Ch case   11:*/		return 0x8208E850;
		  /* 8208E850h */ case   12:  		/* fdivs FR29, FR0, FR13 */
		/* 8208E850h case   12:*/		cpu::op::fdivs<0>(regs,&regs.FR29,regs.FR0,regs.FR13);
		/* 8208E850h case   12:*/		return 0x8208E854;
		  /* 8208E854h */ case   13:  		/* bl -181548 */
		/* 8208E854h case   13:*/		regs.LR = 0x8208E858; return 0x82062328;
		/* 8208E854h case   13:*/		return 0x8208E858;
		  /* 8208E858h */ case   14:  		/* li R4, 6 */
		/* 8208E858h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x6);
		/* 8208E858h case   14:*/		return 0x8208E85C;
		  /* 8208E85Ch */ case   15:  		/* mr R3, R31 */
		/* 8208E85Ch case   15:*/		regs.R3 = regs.R31;
		/* 8208E85Ch case   15:*/		return 0x8208E860;
		  /* 8208E860h */ case   16:  		/* bl -181272 */
		/* 8208E860h case   16:*/		regs.LR = 0x8208E864; return 0x82062448;
		/* 8208E860h case   16:*/		return 0x8208E864;
		  /* 8208E864h */ case   17:  		/* li R4, 7 */
		/* 8208E864h case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x7);
		/* 8208E864h case   17:*/		return 0x8208E868;
		  /* 8208E868h */ case   18:  		/* mr R3, R31 */
		/* 8208E868h case   18:*/		regs.R3 = regs.R31;
		/* 8208E868h case   18:*/		return 0x8208E86C;
		  /* 8208E86Ch */ case   19:  		/* bl -181140 */
		/* 8208E86Ch case   19:*/		regs.LR = 0x8208E870; return 0x820624D8;
		/* 8208E86Ch case   19:*/		return 0x8208E870;
		  /* 8208E870h */ case   20:  		/* li R4, 0 */
		/* 8208E870h case   20:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208E870h case   20:*/		return 0x8208E874;
		  /* 8208E874h */ case   21:  		/* mr R3, R31 */
		/* 8208E874h case   21:*/		regs.R3 = regs.R31;
		/* 8208E874h case   21:*/		return 0x8208E878;
		  /* 8208E878h */ case   22:  		/* bl -181440 */
		/* 8208E878h case   22:*/		regs.LR = 0x8208E87C; return 0x820623B8;
		/* 8208E878h case   22:*/		return 0x8208E87C;
		  /* 8208E87Ch */ case   23:  		/* li R4, 1 */
		/* 8208E87Ch case   23:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8208E87Ch case   23:*/		return 0x8208E880;
		  /* 8208E880h */ case   24:  		/* mr R3, R31 */
		/* 8208E880h case   24:*/		regs.R3 = regs.R31;
		/* 8208E880h case   24:*/		return 0x8208E884;
		  /* 8208E884h */ case   25:  		/* bl -181652 */
		/* 8208E884h case   25:*/		regs.LR = 0x8208E888; return 0x820622F0;
		/* 8208E884h case   25:*/		return 0x8208E888;
		  /* 8208E888h */ case   26:  		/* li R4, 8 */
		/* 8208E888h case   26:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 8208E888h case   26:*/		return 0x8208E88C;
		  /* 8208E88Ch */ case   27:  		/* mr R3, R31 */
		/* 8208E88Ch case   27:*/		regs.R3 = regs.R31;
		/* 8208E88Ch case   27:*/		return 0x8208E890;
		  /* 8208E890h */ case   28:  		/* bl -180544 */
		/* 8208E890h case   28:*/		regs.LR = 0x8208E894; return 0x82062750;
		/* 8208E890h case   28:*/		return 0x8208E894;
		  /* 8208E894h */ case   29:  		/* li R4, 6 */
		/* 8208E894h case   29:*/		cpu::op::li<0>(regs,&regs.R4,0x6);
		/* 8208E894h case   29:*/		return 0x8208E898;
		  /* 8208E898h */ case   30:  		/* mr R3, R31 */
		/* 8208E898h case   30:*/		regs.R3 = regs.R31;
		/* 8208E898h case   30:*/		return 0x8208E89C;
		  /* 8208E89Ch */ case   31:  		/* bl -180460 */
		/* 8208E89Ch case   31:*/		regs.LR = 0x8208E8A0; return 0x820627B0;
		/* 8208E89Ch case   31:*/		return 0x8208E8A0;
		  /* 8208E8A0h */ case   32:  		/* li R4, 0 */
		/* 8208E8A0h case   32:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208E8A0h case   32:*/		return 0x8208E8A4;
		  /* 8208E8A4h */ case   33:  		/* mr R3, R31 */
		/* 8208E8A4h case   33:*/		regs.R3 = regs.R31;
		/* 8208E8A4h case   33:*/		return 0x8208E8A8;
		  /* 8208E8A8h */ case   34:  		/* bl -181736 */
		/* 8208E8A8h case   34:*/		regs.LR = 0x8208E8AC; return 0x820622C0;
		/* 8208E8A8h case   34:*/		return 0x8208E8AC;
		  /* 8208E8ACh */ case   35:  		/* li R4, 6 */
		/* 8208E8ACh case   35:*/		cpu::op::li<0>(regs,&regs.R4,0x6);
		/* 8208E8ACh case   35:*/		return 0x8208E8B0;
		  /* 8208E8B0h */ case   36:  		/* mr R3, R31 */
		/* 8208E8B0h case   36:*/		regs.R3 = regs.R31;
		/* 8208E8B0h case   36:*/		return 0x8208E8B4;
		  /* 8208E8B4h */ case   37:  		/* bl -181796 */
		/* 8208E8B4h case   37:*/		regs.LR = 0x8208E8B8; return 0x82062290;
		/* 8208E8B4h case   37:*/		return 0x8208E8B8;
		  /* 8208E8B8h */ case   38:  		/* li R4, 0 */
		/* 8208E8B8h case   38:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208E8B8h case   38:*/		return 0x8208E8BC;
		  /* 8208E8BCh */ case   39:  		/* mr R3, R31 */
		/* 8208E8BCh case   39:*/		regs.R3 = regs.R31;
		/* 8208E8BCh case   39:*/		return 0x8208E8C0;
		  /* 8208E8C0h */ case   40:  		/* bl -179976 */
		/* 8208E8C0h case   40:*/		regs.LR = 0x8208E8C4; return 0x820629B8;
		/* 8208E8C0h case   40:*/		return 0x8208E8C4;
		  /* 8208E8C4h */ case   41:  		/* li R4, 0 */
		/* 8208E8C4h case   41:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208E8C4h case   41:*/		return 0x8208E8C8;
		  /* 8208E8C8h */ case   42:  		/* mr R3, R31 */
		/* 8208E8C8h case   42:*/		regs.R3 = regs.R31;
		/* 8208E8C8h case   42:*/		return 0x8208E8CC;
		  /* 8208E8CCh */ case   43:  		/* bl -179820 */
		/* 8208E8CCh case   43:*/		regs.LR = 0x8208E8D0; return 0x82062A60;
		/* 8208E8CCh case   43:*/		return 0x8208E8D0;
		  /* 8208E8D0h */ case   44:  		/* li R4, 0 */
		/* 8208E8D0h case   44:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208E8D0h case   44:*/		return 0x8208E8D4;
		  /* 8208E8D4h */ case   45:  		/* mr R3, R31 */
		/* 8208E8D4h case   45:*/		regs.R3 = regs.R31;
		/* 8208E8D4h case   45:*/		return 0x8208E8D8;
		  /* 8208E8D8h */ case   46:  		/* bl -177176 */
		/* 8208E8D8h case   46:*/		regs.LR = 0x8208E8DC; return 0x820634C0;
		/* 8208E8D8h case   46:*/		return 0x8208E8DC;
		  /* 8208E8DCh */ case   47:  		/* li R5, 1 */
		/* 8208E8DCh case   47:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8208E8DCh case   47:*/		return 0x8208E8E0;
		  /* 8208E8E0h */ case   48:  		/* li R4, 0 */
		/* 8208E8E0h case   48:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208E8E0h case   48:*/		return 0x8208E8E4;
		  /* 8208E8E4h */ case   49:  		/* mr R3, R31 */
		/* 8208E8E4h case   49:*/		regs.R3 = regs.R31;
		/* 8208E8E4h case   49:*/		return 0x8208E8E8;
		  /* 8208E8E8h */ case   50:  		/* bl -175544 */
		/* 8208E8E8h case   50:*/		regs.LR = 0x8208E8EC; return 0x82063B30;
		/* 8208E8E8h case   50:*/		return 0x8208E8EC;
		  /* 8208E8ECh */ case   51:  		/* li R5, 1 */
		/* 8208E8ECh case   51:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8208E8ECh case   51:*/		return 0x8208E8F0;
		  /* 8208E8F0h */ case   52:  		/* li R4, 0 */
		/* 8208E8F0h case   52:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208E8F0h case   52:*/		return 0x8208E8F4;
		  /* 8208E8F4h */ case   53:  		/* mr R3, R31 */
		/* 8208E8F4h case   53:*/		regs.R3 = regs.R31;
		/* 8208E8F4h case   53:*/		return 0x8208E8F8;
		  /* 8208E8F8h */ case   54:  		/* bl -175136 */
		/* 8208E8F8h case   54:*/		regs.LR = 0x8208E8FC; return 0x82063CD8;
		/* 8208E8F8h case   54:*/		return 0x8208E8FC;
		  /* 8208E8FCh */ case   55:  		/* lwz R10, <#[R31 + 1152]> */
		/* 8208E8FCh case   55:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000480) );
		/* 8208E8FCh case   55:*/		return 0x8208E900;
		  /* 8208E900h */ case   56:  		/* li R11, 1 */
		/* 8208E900h case   56:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8208E900h case   56:*/		return 0x8208E904;
		  /* 8208E904h */ case   57:  		/* rlwimi R10, R11, 11, 19, 21 */
		/* 8208E904h case   57:*/		cpu::op::rlwimi<0,11,19,21>(regs,&regs.R10,regs.R11);
		/* 8208E904h case   57:*/		return 0x8208E908;
		  /* 8208E908h */ case   58:  		/* stw R10, <#[R31 + 1152]> */
		/* 8208E908h case   58:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000480) );
		/* 8208E908h case   58:*/		return 0x8208E90C;
		  /* 8208E90Ch */ case   59:  		/* ld R10, <#[R31 + 24]> */
		/* 8208E90Ch case   59:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 8208E90Ch case   59:*/		return 0x8208E910;
		  /* 8208E910h */ case   60:  		/* oris R10, R10, 32768 */
		/* 8208E910h case   60:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x8000);
		/* 8208E910h case   60:*/		return 0x8208E914;
		  /* 8208E914h */ case   61:  		/* std R10, <#[R31 + 24]> */
		/* 8208E914h case   61:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 8208E914h case   61:*/		return 0x8208E918;
		  /* 8208E918h */ case   62:  		/* lwz R10, <#[R31 + 1152]> */
		/* 8208E918h case   62:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000480) );
		/* 8208E918h case   62:*/		return 0x8208E91C;
		  /* 8208E91Ch */ case   63:  		/* rlwimi R10, R11, 14, 16, 18 */
		/* 8208E91Ch case   63:*/		cpu::op::rlwimi<0,14,16,18>(regs,&regs.R10,regs.R11);
		/* 8208E91Ch case   63:*/		return 0x8208E920;
		  /* 8208E920h */ case   64:  		/* stw R10, <#[R31 + 1152]> */
		/* 8208E920h case   64:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000480) );
		/* 8208E920h case   64:*/		return 0x8208E924;
		  /* 8208E924h */ case   65:  		/* lis R11, -32215 */
		/* 8208E924h case   65:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8208E924h case   65:*/		return 0x8208E928;
		  /* 8208E928h */ case   66:  		/* ld R10, <#[R31 + 24]> */
		/* 8208E928h case   66:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 8208E928h case   66:*/		return 0x8208E92C;
		  /* 8208E92Ch */ case   67:  		/* mr R3, R31 */
		/* 8208E92Ch case   67:*/		regs.R3 = regs.R31;
		/* 8208E92Ch case   67:*/		return 0x8208E930;
		  /* 8208E930h */ case   68:  		/* addi R29, R11, -31256 */
		/* 8208E930h case   68:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFF85E8);
		/* 8208E930h case   68:*/		return 0x8208E934;
		  /* 8208E934h */ case   69:  		/* oris R10, R10, 32768 */
		/* 8208E934h case   69:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x8000);
		/* 8208E934h case   69:*/		return 0x8208E938;
		  /* 8208E938h */ case   70:  		/* std R10, <#[R31 + 24]> */
		/* 8208E938h case   70:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 8208E938h case   70:*/		return 0x8208E93C;
		  /* 8208E93Ch */ case   71:  		/* lwz R4, <#[R11 - 31256]> */
		/* 8208E93Ch case   71:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0xFFFF85E8) );
		/* 8208E93Ch case   71:*/		return 0x8208E940;
	}
	return 0x8208E940;
} // Block from 8208E820h-8208E940h (72 instructions)

//////////////////////////////////////////////////////
// Block at 8208E940h
// Function 'RtlpFindAndCommitPages'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E940);
		  /* 8208E940h */ case    0:  		/* bl 5072 */
		/* 8208E940h case    0:*/		regs.LR = 0x8208E944; return 0x8208FD10;
		/* 8208E940h case    0:*/		return 0x8208E944;
		  /* 8208E944h */ case    1:  		/* mr R3, R31 */
		/* 8208E944h case    1:*/		regs.R3 = regs.R31;
		/* 8208E944h case    1:*/		return 0x8208E948;
		  /* 8208E948h */ case    2:  		/* lwz R4, <#[R29 + 4]> */
		/* 8208E948h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000004) );
		/* 8208E948h case    2:*/		return 0x8208E94C;
		  /* 8208E94Ch */ case    3:  		/* bl 5148 */
		/* 8208E94Ch case    3:*/		regs.LR = 0x8208E950; return 0x8208FD68;
		/* 8208E94Ch case    3:*/		return 0x8208E950;
		  /* 8208E950h */ case    4:  		/* mr R3, R31 */
		/* 8208E950h case    4:*/		regs.R3 = regs.R31;
		/* 8208E950h case    4:*/		return 0x8208E954;
		  /* 8208E954h */ case    5:  		/* lwz R4, <#[R29 + 8]> */
		/* 8208E954h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000008) );
		/* 8208E954h case    5:*/		return 0x8208E958;
		  /* 8208E958h */ case    6:  		/* bl 5240 */
		/* 8208E958h case    6:*/		regs.LR = 0x8208E95C; return 0x8208FDD0;
		/* 8208E958h case    6:*/		return 0x8208E95C;
		  /* 8208E95Ch */ case    7:  		/* stfs FR30, <#[R31 + 1952]> */
		/* 8208E95Ch case    7:*/		cpu::mem::store32f( regs, regs.FR30, (uint32)(regs.R31 + 0x000007A0) );
		/* 8208E95Ch case    7:*/		return 0x8208E960;
		  /* 8208E960h */ case    8:  		/* li R12, 1 */
		/* 8208E960h case    8:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 8208E960h case    8:*/		return 0x8208E964;
		  /* 8208E964h */ case    9:  		/* stfs FR29, <#[R31 + 1956]> */
		/* 8208E964h case    9:*/		cpu::mem::store32f( regs, regs.FR29, (uint32)(regs.R31 + 0x000007A4) );
		/* 8208E964h case    9:*/		return 0x8208E968;
		  /* 8208E968h */ case   10:  		/* stfs FR31, <#[R31 + 1960]> */
		/* 8208E968h case   10:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R31 + 0x000007A8) );
		/* 8208E968h case   10:*/		return 0x8208E96C;
		  /* 8208E96Ch */ case   11:  		/* rldicr R12, R12, 63, 63 */
		/* 8208E96Ch case   11:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R12,regs.R12);
		/* 8208E96Ch case   11:*/		return 0x8208E970;
		  /* 8208E970h */ case   12:  		/* stfs FR31, <#[R31 + 1964]> */
		/* 8208E970h case   12:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R31 + 0x000007AC) );
		/* 8208E970h case   12:*/		return 0x8208E974;
		  /* 8208E974h */ case   13:  		/* ld R11, <#[R31]> */
		/* 8208E974h case   13:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8208E974h case   13:*/		return 0x8208E978;
		  /* 8208E978h */ case   14:  		/* or R11, R11, R12 */
		/* 8208E978h case   14:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8208E978h case   14:*/		return 0x8208E97C;
		  /* 8208E97Ch */ case   15:  		/* std R11, <#[R31]> */
		/* 8208E97Ch case   15:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8208E97Ch case   15:*/		return 0x8208E980;
	}
	return 0x8208E980;
} // Block from 8208E940h-8208E980h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8208E980h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E980);
		  /* 8208E980h */ case    0:  		/* lwz R11, <#[R30 + 180]> */
		/* 8208E980h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000B4) );
		/* 8208E980h case    0:*/		return 0x8208E984;
		  /* 8208E984h */ case    1:  		/* addi R11, R11, 1 */
		/* 8208E984h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8208E984h case    1:*/		return 0x8208E988;
		  /* 8208E988h */ case    2:  		/* stw R11, <#[R30 + 180]> */
		/* 8208E988h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x000000B4) );
		/* 8208E988h case    2:*/		return 0x8208E98C;
		  /* 8208E98Ch */ case    3:  		/* addi R1, R1, 192 */
		/* 8208E98Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 8208E98Ch case    3:*/		return 0x8208E990;
		  /* 8208E990h */ case    4:  		/* lfd FR29, <#[R1 - 56]> */
		/* 8208E990h case    4:*/		cpu::mem::load64f( regs, &regs.FR29, (uint32)(regs.R1 + 0xFFFFFFC8) );
		/* 8208E990h case    4:*/		return 0x8208E994;
		  /* 8208E994h */ case    5:  		/* lfd FR30, <#[R1 - 48]> */
		/* 8208E994h case    5:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFFD0) );
		/* 8208E994h case    5:*/		return 0x8208E998;
		  /* 8208E998h */ case    6:  		/* lfd FR31, <#[R1 - 40]> */
		/* 8208E998h case    6:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFD8) );
		/* 8208E998h case    6:*/		return 0x8208E99C;
		  /* 8208E99Ch */ case    7:  		/* b 10512 */
		/* 8208E99Ch case    7:*/		return 0x820912AC;
		/* 8208E99Ch case    7:*/		return 0x8208E9A0;
	}
	return 0x8208E9A0;
} // Block from 8208E980h-8208E9A0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8208E9A0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208E9A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208E9A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208E9A0);
		  /* 8208E9A0h */ case    0:  		/* mfspr R12, LR */
		/* 8208E9A0h case    0:*/		regs.R12 = regs.LR;
		/* 8208E9A0h case    0:*/		return 0x8208E9A4;
		  /* 8208E9A4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8208E9A4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208E9A4h case    1:*/		return 0x8208E9A8;
		  /* 8208E9A8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8208E9A8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208E9A8h case    2:*/		return 0x8208E9AC;
		  /* 8208E9ACh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8208E9ACh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208E9ACh case    3:*/		return 0x8208E9B0;
		  /* 8208E9B0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8208E9B0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8208E9B0h case    4:*/		return 0x8208E9B4;
		  /* 8208E9B4h */ case    5:  		/* lwz R11, <#[R3 + 180]> */
		/* 8208E9B4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000B4) );
		/* 8208E9B4h case    5:*/		return 0x8208E9B8;
		  /* 8208E9B8h */ case    6:  		/* mr R31, R3 */
		/* 8208E9B8h case    6:*/		regs.R31 = regs.R3;
		/* 8208E9B8h case    6:*/		return 0x8208E9BC;
		  /* 8208E9BCh */ case    7:  		/* addic. R11, R11, -1 */
		/* 8208E9BCh case    7:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8208E9BCh case    7:*/		return 0x8208E9C0;
		  /* 8208E9C0h */ case    8:  		/* stw R11, <#[R3 + 180]> */
		/* 8208E9C0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000B4) );
		/* 8208E9C0h case    8:*/		return 0x8208E9C4;
		  /* 8208E9C4h */ case    9:  		/* bc 4, CR0_EQ, 316 */
		/* 8208E9C4h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8208EB00;  }
		/* 8208E9C4h case    9:*/		return 0x8208E9C8;
		  /* 8208E9C8h */ case   10:  		/* lwz R11, <#[R3 + 184]> */
		/* 8208E9C8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000B8) );
		/* 8208E9C8h case   10:*/		return 0x8208E9CC;
		  /* 8208E9CCh */ case   11:  		/* cmpwi CR6, R11, 0 */
		/* 8208E9CCh case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8208E9CCh case   11:*/		return 0x8208E9D0;
		  /* 8208E9D0h */ case   12:  		/* bc 12, CR6_EQ, 304 */
		/* 8208E9D0h case   12:*/		if ( regs.CR[6].eq ) { return 0x8208EB00;  }
		/* 8208E9D0h case   12:*/		return 0x8208E9D4;
		  /* 8208E9D4h */ case   13:  		/* lis R11, -32215 */
		/* 8208E9D4h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8208E9D4h case   13:*/		return 0x8208E9D8;
		  /* 8208E9D8h */ case   14:  		/* li R6, 0 */
		/* 8208E9D8h case   14:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8208E9D8h case   14:*/		return 0x8208E9DC;
		  /* 8208E9DCh */ case   15:  		/* li R5, 0 */
		/* 8208E9DCh case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8208E9DCh case   15:*/		return 0x8208E9E0;
		  /* 8208E9E0h */ case   16:  		/* oris R6, R6, 32768 */
		/* 8208E9E0h case   16:*/		cpu::op::oris<0>(regs,&regs.R6,regs.R6,0x8000);
		/* 8208E9E0h case   16:*/		return 0x8208E9E4;
		  /* 8208E9E4h */ case   17:  		/* li R4, 0 */
		/* 8208E9E4h case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208E9E4h case   17:*/		return 0x8208E9E8;
		  /* 8208E9E8h */ case   18:  		/* lwz R3, <#[R11 - 31244]> */
		/* 8208E9E8h case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFF85F4) );
		/* 8208E9E8h case   18:*/		return 0x8208E9EC;
		  /* 8208E9ECh */ case   19:  		/* mr R30, R3 */
		/* 8208E9ECh case   19:*/		regs.R30 = regs.R3;
		/* 8208E9ECh case   19:*/		return 0x8208E9F0;
		  /* 8208E9F0h */ case   20:  		/* bl -162432 */
		/* 8208E9F0h case   20:*/		regs.LR = 0x8208E9F4; return 0x82066F70;
		/* 8208E9F0h case   20:*/		return 0x8208E9F4;
		  /* 8208E9F4h */ case   21:  		/* li R4, 0 */
		/* 8208E9F4h case   21:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208E9F4h case   21:*/		return 0x8208E9F8;
		  /* 8208E9F8h */ case   22:  		/* mr R3, R30 */
		/* 8208E9F8h case   22:*/		regs.R3 = regs.R30;
		/* 8208E9F8h case   22:*/		return 0x8208E9FC;
		  /* 8208E9FCh */ case   23:  		/* bl 4884 */
		/* 8208E9FCh case   23:*/		regs.LR = 0x8208EA00; return 0x8208FD10;
		/* 8208E9FCh case   23:*/		return 0x8208EA00;
		  /* 8208EA00h */ case   24:  		/* li R4, 0 */
		/* 8208EA00h case   24:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208EA00h case   24:*/		return 0x8208EA04;
		  /* 8208EA04h */ case   25:  		/* mr R3, R30 */
		/* 8208EA04h case   25:*/		regs.R3 = regs.R30;
		/* 8208EA04h case   25:*/		return 0x8208EA08;
		  /* 8208EA08h */ case   26:  		/* bl 4960 */
		/* 8208EA08h case   26:*/		regs.LR = 0x8208EA0C; return 0x8208FD68;
		/* 8208EA08h case   26:*/		return 0x8208EA0C;
		  /* 8208EA0Ch */ case   27:  		/* li R4, 0 */
		/* 8208EA0Ch case   27:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208EA0Ch case   27:*/		return 0x8208EA10;
		  /* 8208EA10h */ case   28:  		/* mr R3, R30 */
		/* 8208EA10h case   28:*/		regs.R3 = regs.R30;
		/* 8208EA10h case   28:*/		return 0x8208EA14;
		  /* 8208EA14h */ case   29:  		/* bl 5052 */
		/* 8208EA14h case   29:*/		regs.LR = 0x8208EA18; return 0x8208FDD0;
		/* 8208EA14h case   29:*/		return 0x8208EA18;
		  /* 8208EA18h */ case   30:  		/* mr R3, R30 */
		/* 8208EA18h case   30:*/		regs.R3 = regs.R30;
		/* 8208EA18h case   30:*/		return 0x8208EA1C;
		  /* 8208EA1Ch */ case   31:  		/* lwz R4, <#[R31 + 116]> */
		/* 8208EA1Ch case   31:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000074) );
		/* 8208EA1Ch case   31:*/		return 0x8208EA20;
		  /* 8208EA20h */ case   32:  		/* bl -182008 */
		/* 8208EA20h case   32:*/		regs.LR = 0x8208EA24; return 0x82062328;
		/* 8208EA20h case   32:*/		return 0x8208EA24;
		  /* 8208EA24h */ case   33:  		/* mr R3, R30 */
		/* 8208EA24h case   33:*/		regs.R3 = regs.R30;
		/* 8208EA24h case   33:*/		return 0x8208EA28;
		  /* 8208EA28h */ case   34:  		/* lwz R4, <#[R31 + 120]> */
		/* 8208EA28h case   34:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000078) );
		/* 8208EA28h case   34:*/		return 0x8208EA2C;
		  /* 8208EA2Ch */ case   35:  		/* bl -181732 */
		/* 8208EA2Ch case   35:*/		regs.LR = 0x8208EA30; return 0x82062448;
		/* 8208EA2Ch case   35:*/		return 0x8208EA30;
		  /* 8208EA30h */ case   36:  		/* mr R3, R30 */
		/* 8208EA30h case   36:*/		regs.R3 = regs.R30;
		/* 8208EA30h case   36:*/		return 0x8208EA34;
		  /* 8208EA34h */ case   37:  		/* lwz R4, <#[R31 + 124]> */
		/* 8208EA34h case   37:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000007C) );
		/* 8208EA34h case   37:*/		return 0x8208EA38;
		  /* 8208EA38h */ case   38:  		/* bl -181600 */
		/* 8208EA38h case   38:*/		regs.LR = 0x8208EA3C; return 0x820624D8;
		/* 8208EA38h case   38:*/		return 0x8208EA3C;
		  /* 8208EA3Ch */ case   39:  		/* mr R3, R30 */
		/* 8208EA3Ch case   39:*/		regs.R3 = regs.R30;
		/* 8208EA3Ch case   39:*/		return 0x8208EA40;
		  /* 8208EA40h */ case   40:  		/* lwz R4, <#[R31 + 128]> */
		/* 8208EA40h case   40:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000080) );
		/* 8208EA40h case   40:*/		return 0x8208EA44;
		  /* 8208EA44h */ case   41:  		/* bl -181900 */
		/* 8208EA44h case   41:*/		regs.LR = 0x8208EA48; return 0x820623B8;
		/* 8208EA44h case   41:*/		return 0x8208EA48;
		  /* 8208EA48h */ case   42:  		/* mr R3, R30 */
		/* 8208EA48h case   42:*/		regs.R3 = regs.R30;
		/* 8208EA48h case   42:*/		return 0x8208EA4C;
		  /* 8208EA4Ch */ case   43:  		/* lwz R4, <#[R31 + 132]> */
		/* 8208EA4Ch case   43:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000084) );
		/* 8208EA4Ch case   43:*/		return 0x8208EA50;
		  /* 8208EA50h */ case   44:  		/* bl -182112 */
		/* 8208EA50h case   44:*/		regs.LR = 0x8208EA54; return 0x820622F0;
		/* 8208EA50h case   44:*/		return 0x8208EA54;
		  /* 8208EA54h */ case   45:  		/* mr R3, R30 */
		/* 8208EA54h case   45:*/		regs.R3 = regs.R30;
		/* 8208EA54h case   45:*/		return 0x8208EA58;
		  /* 8208EA58h */ case   46:  		/* lwz R4, <#[R31 + 136]> */
		/* 8208EA58h case   46:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000088) );
		/* 8208EA58h case   46:*/		return 0x8208EA5C;
		  /* 8208EA5Ch */ case   47:  		/* bl -181004 */
		/* 8208EA5Ch case   47:*/		regs.LR = 0x8208EA60; return 0x82062750;
		/* 8208EA5Ch case   47:*/		return 0x8208EA60;
		  /* 8208EA60h */ case   48:  		/* mr R3, R30 */
		/* 8208EA60h case   48:*/		regs.R3 = regs.R30;
		/* 8208EA60h case   48:*/		return 0x8208EA64;
		  /* 8208EA64h */ case   49:  		/* lwz R4, <#[R31 + 140]> */
		/* 8208EA64h case   49:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000008C) );
		/* 8208EA64h case   49:*/		return 0x8208EA68;
		  /* 8208EA68h */ case   50:  		/* bl -180920 */
		/* 8208EA68h case   50:*/		regs.LR = 0x8208EA6C; return 0x820627B0;
		/* 8208EA68h case   50:*/		return 0x8208EA6C;
		  /* 8208EA6Ch */ case   51:  		/* mr R3, R30 */
		/* 8208EA6Ch case   51:*/		regs.R3 = regs.R30;
		/* 8208EA6Ch case   51:*/		return 0x8208EA70;
		  /* 8208EA70h */ case   52:  		/* lwz R4, <#[R31 + 144]> */
		/* 8208EA70h case   52:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000090) );
		/* 8208EA70h case   52:*/		return 0x8208EA74;
		  /* 8208EA74h */ case   53:  		/* bl -182196 */
		/* 8208EA74h case   53:*/		regs.LR = 0x8208EA78; return 0x820622C0;
		/* 8208EA74h case   53:*/		return 0x8208EA78;
		  /* 8208EA78h */ case   54:  		/* mr R3, R30 */
		/* 8208EA78h case   54:*/		regs.R3 = regs.R30;
		/* 8208EA78h case   54:*/		return 0x8208EA7C;
		  /* 8208EA7Ch */ case   55:  		/* lwz R4, <#[R31 + 148]> */
		/* 8208EA7Ch case   55:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000094) );
		/* 8208EA7Ch case   55:*/		return 0x8208EA80;
		  /* 8208EA80h */ case   56:  		/* bl -182256 */
		/* 8208EA80h case   56:*/		regs.LR = 0x8208EA84; return 0x82062290;
		/* 8208EA80h case   56:*/		return 0x8208EA84;
		  /* 8208EA84h */ case   57:  		/* mr R3, R30 */
		/* 8208EA84h case   57:*/		regs.R3 = regs.R30;
		/* 8208EA84h case   57:*/		return 0x8208EA88;
		  /* 8208EA88h */ case   58:  		/* lwz R4, <#[R31 + 152]> */
		/* 8208EA88h case   58:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000098) );
		/* 8208EA88h case   58:*/		return 0x8208EA8C;
		  /* 8208EA8Ch */ case   59:  		/* bl -180436 */
		/* 8208EA8Ch case   59:*/		regs.LR = 0x8208EA90; return 0x820629B8;
		/* 8208EA8Ch case   59:*/		return 0x8208EA90;
		  /* 8208EA90h */ case   60:  		/* mr R3, R30 */
		/* 8208EA90h case   60:*/		regs.R3 = regs.R30;
		/* 8208EA90h case   60:*/		return 0x8208EA94;
		  /* 8208EA94h */ case   61:  		/* lwz R4, <#[R31 + 156]> */
		/* 8208EA94h case   61:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000009C) );
		/* 8208EA94h case   61:*/		return 0x8208EA98;
		  /* 8208EA98h */ case   62:  		/* bl -180280 */
		/* 8208EA98h case   62:*/		regs.LR = 0x8208EA9C; return 0x82062A60;
		/* 8208EA98h case   62:*/		return 0x8208EA9C;
		  /* 8208EA9Ch */ case   63:  		/* mr R3, R30 */
		/* 8208EA9Ch case   63:*/		regs.R3 = regs.R30;
		/* 8208EA9Ch case   63:*/		return 0x8208EAA0;
		  /* 8208EAA0h */ case   64:  		/* lwz R4, <#[R31 + 160]> */
		/* 8208EAA0h case   64:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x000000A0) );
		/* 8208EAA0h case   64:*/		return 0x8208EAA4;
		  /* 8208EAA4h */ case   65:  		/* bl -177636 */
		/* 8208EAA4h case   65:*/		regs.LR = 0x8208EAA8; return 0x820634C0;
		/* 8208EAA4h case   65:*/		return 0x8208EAA8;
		  /* 8208EAA8h */ case   66:  		/* li R4, 0 */
		/* 8208EAA8h case   66:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208EAA8h case   66:*/		return 0x8208EAAC;
		  /* 8208EAACh */ case   67:  		/* mr R3, R30 */
		/* 8208EAACh case   67:*/		regs.R3 = regs.R30;
		/* 8208EAACh case   67:*/		return 0x8208EAB0;
		  /* 8208EAB0h */ case   68:  		/* lwz R5, <#[R31 + 164]> */
		/* 8208EAB0h case   68:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x000000A4) );
		/* 8208EAB0h case   68:*/		return 0x8208EAB4;
		  /* 8208EAB4h */ case   69:  		/* bl -176004 */
		/* 8208EAB4h case   69:*/		regs.LR = 0x8208EAB8; return 0x82063B30;
		/* 8208EAB4h case   69:*/		return 0x8208EAB8;
		  /* 8208EAB8h */ case   70:  		/* li R4, 0 */
		/* 8208EAB8h case   70:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208EAB8h case   70:*/		return 0x8208EABC;
		  /* 8208EABCh */ case   71:  		/* mr R3, R30 */
		/* 8208EABCh case   71:*/		regs.R3 = regs.R30;
		/* 8208EABCh case   71:*/		return 0x8208EAC0;
		  /* 8208EAC0h */ case   72:  		/* lwz R5, <#[R31 + 168]> */
		/* 8208EAC0h case   72:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x000000A8) );
		/* 8208EAC0h case   72:*/		return 0x8208EAC4;
		  /* 8208EAC4h */ case   73:  		/* bl -175596 */
		/* 8208EAC4h case   73:*/		regs.LR = 0x8208EAC8; return 0x82063CD8;
		/* 8208EAC4h case   73:*/		return 0x8208EAC8;
		  /* 8208EAC8h */ case   74:  		/* lwz R11, <#[R31 + 172]> */
		/* 8208EAC8h case   74:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000AC) );
		/* 8208EAC8h case   74:*/		return 0x8208EACC;
		  /* 8208EACCh */ case   75:  		/* lwz R10, <#[R30 + 1152]> */
		/* 8208EACCh case   75:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000480) );
		/* 8208EACCh case   75:*/		return 0x8208EAD0;
		  /* 8208EAD0h */ case   76:  		/* rlwimi R10, R11, 10, 19, 21 */
		/* 8208EAD0h case   76:*/		cpu::op::rlwimi<0,10,19,21>(regs,&regs.R10,regs.R11);
		/* 8208EAD0h case   76:*/		return 0x8208EAD4;
		  /* 8208EAD4h */ case   77:  		/* stw R10, <#[R30 + 1152]> */
		/* 8208EAD4h case   77:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000480) );
		/* 8208EAD4h case   77:*/		return 0x8208EAD8;
		  /* 8208EAD8h */ case   78:  		/* ld R11, <#[R30 + 24]> */
		/* 8208EAD8h case   78:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 8208EAD8h case   78:*/		return 0x8208EADC;
		  /* 8208EADCh */ case   79:  		/* oris R11, R11, 32768 */
		/* 8208EADCh case   79:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 8208EADCh case   79:*/		return 0x8208EAE0;
		  /* 8208EAE0h */ case   80:  		/* std R11, <#[R30 + 24]> */
		/* 8208EAE0h case   80:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 8208EAE0h case   80:*/		return 0x8208EAE4;
		  /* 8208EAE4h */ case   81:  		/* lwz R11, <#[R31 + 176]> */
		/* 8208EAE4h case   81:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000B0) );
		/* 8208EAE4h case   81:*/		return 0x8208EAE8;
		  /* 8208EAE8h */ case   82:  		/* lwz R10, <#[R30 + 1152]> */
		/* 8208EAE8h case   82:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000480) );
		/* 8208EAE8h case   82:*/		return 0x8208EAEC;
		  /* 8208EAECh */ case   83:  		/* rlwimi R10, R11, 13, 16, 18 */
		/* 8208EAECh case   83:*/		cpu::op::rlwimi<0,13,16,18>(regs,&regs.R10,regs.R11);
		/* 8208EAECh case   83:*/		return 0x8208EAF0;
		  /* 8208EAF0h */ case   84:  		/* stw R10, <#[R30 + 1152]> */
		/* 8208EAF0h case   84:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000480) );
		/* 8208EAF0h case   84:*/		return 0x8208EAF4;
		  /* 8208EAF4h */ case   85:  		/* ld R11, <#[R30 + 24]> */
		/* 8208EAF4h case   85:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 8208EAF4h case   85:*/		return 0x8208EAF8;
		  /* 8208EAF8h */ case   86:  		/* oris R11, R11, 32768 */
		/* 8208EAF8h case   86:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 8208EAF8h case   86:*/		return 0x8208EAFC;
		  /* 8208EAFCh */ case   87:  		/* std R11, <#[R30 + 24]> */
		/* 8208EAFCh case   87:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 8208EAFCh case   87:*/		return 0x8208EB00;
	}
	return 0x8208EB00;
} // Block from 8208E9A0h-8208EB00h (88 instructions)

//////////////////////////////////////////////////////
// Block at 8208EB00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208EB00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208EB00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208EB00);
		  /* 8208EB00h */ case    0:  		/* addi R1, R1, 112 */
		/* 8208EB00h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8208EB00h case    0:*/		return 0x8208EB04;
		  /* 8208EB04h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8208EB04h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208EB04h case    1:*/		return 0x8208EB08;
		  /* 8208EB08h */ case    2:  		/* mtspr LR, R12 */
		/* 8208EB08h case    2:*/		regs.LR = regs.R12;
		/* 8208EB08h case    2:*/		return 0x8208EB0C;
		  /* 8208EB0Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 8208EB0Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208EB0Ch case    3:*/		return 0x8208EB10;
		  /* 8208EB10h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8208EB10h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208EB10h case    4:*/		return 0x8208EB14;
		  /* 8208EB14h */ case    5:  		/* bclr 20, CR0_LT */
		/* 8208EB14h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208EB14h case    5:*/		return 0x8208EB18;
	}
	return 0x8208EB18;
} // Block from 8208EB00h-8208EB18h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208EB18h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208EB18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208EB18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208EB18);
		  /* 8208EB18h */ case    0:  		/* mfspr R12, LR */
		/* 8208EB18h case    0:*/		regs.R12 = regs.LR;
		/* 8208EB18h case    0:*/		return 0x8208EB1C;
		  /* 8208EB1Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8208EB1Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208EB1Ch case    1:*/		return 0x8208EB20;
		  /* 8208EB20h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8208EB20h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208EB20h case    2:*/		return 0x8208EB24;
		  /* 8208EB24h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8208EB24h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8208EB24h case    3:*/		return 0x8208EB28;
		  /* 8208EB28h */ case    4:  		/* mr R31, R3 */
		/* 8208EB28h case    4:*/		regs.R31 = regs.R3;
		/* 8208EB28h case    4:*/		return 0x8208EB2C;
		  /* 8208EB2Ch */ case    5:  		/* bl -1204 */
		/* 8208EB2Ch case    5:*/		regs.LR = 0x8208EB30; return 0x8208E678;
		/* 8208EB2Ch case    5:*/		return 0x8208EB30;
		  /* 8208EB30h */ case    6:  		/* mr R3, R31 */
		/* 8208EB30h case    6:*/		regs.R3 = regs.R31;
		/* 8208EB30h case    6:*/		return 0x8208EB34;
		  /* 8208EB34h */ case    7:  		/* bl -3260 */
		/* 8208EB34h case    7:*/		regs.LR = 0x8208EB38; return 0x8208DE78;
		/* 8208EB34h case    7:*/		return 0x8208EB38;
		  /* 8208EB38h */ case    8:  		/* addi R1, R1, 96 */
		/* 8208EB38h case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8208EB38h case    8:*/		return 0x8208EB3C;
		  /* 8208EB3Ch */ case    9:  		/* lwz R12, <#[R1 - 8]> */
		/* 8208EB3Ch case    9:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208EB3Ch case    9:*/		return 0x8208EB40;
		  /* 8208EB40h */ case   10:  		/* mtspr LR, R12 */
		/* 8208EB40h case   10:*/		regs.LR = regs.R12;
		/* 8208EB40h case   10:*/		return 0x8208EB44;
		  /* 8208EB44h */ case   11:  		/* ld R31, <#[R1 - 16]> */
		/* 8208EB44h case   11:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208EB44h case   11:*/		return 0x8208EB48;
		  /* 8208EB48h */ case   12:  		/* bclr 20, CR0_LT */
		/* 8208EB48h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208EB48h case   12:*/		return 0x8208EB4C;
	}
	return 0x8208EB4C;
} // Block from 8208EB18h-8208EB4Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8208EB4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208EB4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208EB4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208EB4C);
		  /* 8208EB4Ch */ case    0:  		/* nop */
		/* 8208EB4Ch case    0:*/		cpu::op::nop();
		/* 8208EB4Ch case    0:*/		return 0x8208EB50;
	}
	return 0x8208EB50;
} // Block from 8208EB4Ch-8208EB50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208EB50h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208EB50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208EB50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208EB50);
		  /* 8208EB50h */ case    0:  		/* mfspr R12, LR */
		/* 8208EB50h case    0:*/		regs.R12 = regs.LR;
		/* 8208EB50h case    0:*/		return 0x8208EB54;
		  /* 8208EB54h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8208EB54h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208EB54h case    1:*/		return 0x8208EB58;
		  /* 8208EB58h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8208EB58h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208EB58h case    2:*/		return 0x8208EB5C;
		  /* 8208EB5Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8208EB5Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208EB5Ch case    3:*/		return 0x8208EB60;
		  /* 8208EB60h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8208EB60h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8208EB60h case    4:*/		return 0x8208EB64;
		  /* 8208EB64h */ case    5:  		/* mr R31, R3 */
		/* 8208EB64h case    5:*/		regs.R31 = regs.R3;
		/* 8208EB64h case    5:*/		return 0x8208EB68;
		  /* 8208EB68h */ case    6:  		/* bl -3304 */
		/* 8208EB68h case    6:*/		regs.LR = 0x8208EB6C; return 0x8208DE80;
		/* 8208EB68h case    6:*/		return 0x8208EB6C;
		  /* 8208EB6Ch */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 8208EB6Ch case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208EB6Ch case    7:*/		return 0x8208EB70;
		  /* 8208EB70h */ case    8:  		/* bc 4, CR0_LT, 16 */
		/* 8208EB70h case    8:*/		if ( !regs.CR[0].lt ) { return 0x8208EB80;  }
		/* 8208EB70h case    8:*/		return 0x8208EB74;
		  /* 8208EB74h */ case    9:  		/* lis R3, -32768 */
		/* 8208EB74h case    9:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8208EB74h case    9:*/		return 0x8208EB78;
		  /* 8208EB78h */ case   10:  		/* ori R3, R3, 16389 */
		/* 8208EB78h case   10:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8208EB78h case   10:*/		return 0x8208EB7C;
		  /* 8208EB7Ch */ case   11:  		/* b 56 */
		/* 8208EB7Ch case   11:*/		return 0x8208EBB4;
		/* 8208EB7Ch case   11:*/		return 0x8208EB80;
	}
	return 0x8208EB80;
} // Block from 8208EB50h-8208EB80h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8208EB80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208EB80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208EB80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208EB80);
		  /* 8208EB80h */ case    0:  		/* lis R11, -32255 */
		/* 8208EB80h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208EB80h case    0:*/		return 0x8208EB84;
		  /* 8208EB84h */ case    1:  		/* mr R3, R31 */
		/* 8208EB84h case    1:*/		regs.R3 = regs.R31;
		/* 8208EB84h case    1:*/		return 0x8208EB88;
		  /* 8208EB88h */ case    2:  		/* addi R4, R11, -26956 */
		/* 8208EB88h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFF96B4);
		/* 8208EB88h case    2:*/		return 0x8208EB8C;
		  /* 8208EB8Ch */ case    3:  		/* bl -3620 */
		/* 8208EB8Ch case    3:*/		regs.LR = 0x8208EB90; return 0x8208DD68;
		/* 8208EB8Ch case    3:*/		return 0x8208EB90;
		  /* 8208EB90h */ case    4:  		/* lis R11, -32255 */
		/* 8208EB90h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208EB90h case    4:*/		return 0x8208EB94;
		  /* 8208EB94h */ case    5:  		/* mr R30, R3 */
		/* 8208EB94h case    5:*/		regs.R30 = regs.R3;
		/* 8208EB94h case    5:*/		return 0x8208EB98;
		  /* 8208EB98h */ case    6:  		/* addi R4, R11, -26968 */
		/* 8208EB98h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFF96A8);
		/* 8208EB98h case    6:*/		return 0x8208EB9C;
		  /* 8208EB9Ch */ case    7:  		/* mr R3, R31 */
		/* 8208EB9Ch case    7:*/		regs.R3 = regs.R31;
		/* 8208EB9Ch case    7:*/		return 0x8208EBA0;
		  /* 8208EBA0h */ case    8:  		/* bl -3640 */
		/* 8208EBA0h case    8:*/		regs.LR = 0x8208EBA4; return 0x8208DD68;
		/* 8208EBA0h case    8:*/		return 0x8208EBA4;
		  /* 8208EBA4h */ case    9:  		/* mr R5, R3 */
		/* 8208EBA4h case    9:*/		regs.R5 = regs.R3;
		/* 8208EBA4h case    9:*/		return 0x8208EBA8;
		  /* 8208EBA8h */ case   10:  		/* mr R4, R30 */
		/* 8208EBA8h case   10:*/		regs.R4 = regs.R30;
		/* 8208EBA8h case   10:*/		return 0x8208EBAC;
		  /* 8208EBACh */ case   11:  		/* mr R3, R31 */
		/* 8208EBACh case   11:*/		regs.R3 = regs.R31;
		/* 8208EBACh case   11:*/		return 0x8208EBB0;
		  /* 8208EBB0h */ case   12:  		/* bl -1632 */
		/* 8208EBB0h case   12:*/		regs.LR = 0x8208EBB4; return 0x8208E550;
		/* 8208EBB0h case   12:*/		return 0x8208EBB4;
	}
	return 0x8208EBB4;
} // Block from 8208EB80h-8208EBB4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8208EBB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208EBB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208EBB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208EBB4);
		  /* 8208EBB4h */ case    0:  		/* addi R1, R1, 112 */
		/* 8208EBB4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8208EBB4h case    0:*/		return 0x8208EBB8;
		  /* 8208EBB8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8208EBB8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208EBB8h case    1:*/		return 0x8208EBBC;
		  /* 8208EBBCh */ case    2:  		/* mtspr LR, R12 */
		/* 8208EBBCh case    2:*/		regs.LR = regs.R12;
		/* 8208EBBCh case    2:*/		return 0x8208EBC0;
		  /* 8208EBC0h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 8208EBC0h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208EBC0h case    3:*/		return 0x8208EBC4;
		  /* 8208EBC4h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8208EBC4h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208EBC4h case    4:*/		return 0x8208EBC8;
		  /* 8208EBC8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 8208EBC8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208EBC8h case    5:*/		return 0x8208EBCC;
	}
	return 0x8208EBCC;
} // Block from 8208EBB4h-8208EBCCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208EBCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208EBCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208EBCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208EBCC);
		  /* 8208EBCCh */ case    0:  		/* nop */
		/* 8208EBCCh case    0:*/		cpu::op::nop();
		/* 8208EBCCh case    0:*/		return 0x8208EBD0;
	}
	return 0x8208EBD0;
} // Block from 8208EBCCh-8208EBD0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208EBD0h
// Function 'RtlpCoalesceFreeBlocks'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208EBD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208EBD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208EBD0);
		  /* 8208EBD0h */ case    0:  		/* mfspr R12, LR */
		/* 8208EBD0h case    0:*/		regs.R12 = regs.LR;
		/* 8208EBD0h case    0:*/		return 0x8208EBD4;
		  /* 8208EBD4h */ case    1:  		/* bl 9844 */
		/* 8208EBD4h case    1:*/		regs.LR = 0x8208EBD8; return 0x82091248;
		/* 8208EBD4h case    1:*/		return 0x8208EBD8;
		  /* 8208EBD8h */ case    2:  		/* addi R12, R1, -72 */
		/* 8208EBD8h case    2:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFFB8);
		/* 8208EBD8h case    2:*/		return 0x8208EBDC;
		  /* 8208EBDCh */ case    3:  		/* bl 10244 */
		/* 8208EBDCh case    3:*/		regs.LR = 0x8208EBE0; return 0x820913E0;
		/* 8208EBDCh case    3:*/		return 0x8208EBE0;
		  /* 8208EBE0h */ case    4:  		/* stwu R1, <#[R1 - 336]> */
		/* 8208EBE0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEB0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEB0);
		/* 8208EBE0h case    4:*/		return 0x8208EBE4;
		  /* 8208EBE4h */ case    5:  		/* stfs FR3, <#[R1 + 404]> */
		/* 8208EBE4h case    5:*/		cpu::mem::store32f( regs, regs.FR3, (uint32)(regs.R1 + 0x00000194) );
		/* 8208EBE4h case    5:*/		return 0x8208EBE8;
		  /* 8208EBE8h */ case    6:  		/* mr R31, R3 */
		/* 8208EBE8h case    6:*/		regs.R31 = regs.R3;
		/* 8208EBE8h case    6:*/		return 0x8208EBEC;
		  /* 8208EBECh */ case    7:  		/* fmr FR30, FR1 */
		/* 8208EBECh case    7:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR1);
		/* 8208EBECh case    7:*/		return 0x8208EBF0;
		  /* 8208EBF0h */ case    8:  		/* mr R26, R7 */
		/* 8208EBF0h case    8:*/		regs.R26 = regs.R7;
		/* 8208EBF0h case    8:*/		return 0x8208EBF4;
		  /* 8208EBF4h */ case    9:  		/* fmr FR31, FR2 */
		/* 8208EBF4h case    9:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR2);
		/* 8208EBF4h case    9:*/		return 0x8208EBF8;
		  /* 8208EBF8h */ case   10:  		/* mr R24, R8 */
		/* 8208EBF8h case   10:*/		regs.R24 = regs.R8;
		/* 8208EBF8h case   10:*/		return 0x8208EBFC;
		  /* 8208EBFCh */ case   11:  		/* fmr FR23, FR3 */
		/* 8208EBFCh case   11:*/		cpu::op::fmr<0>(regs,&regs.FR23,regs.FR3);
		/* 8208EBFCh case   11:*/		return 0x8208EC00;
		  /* 8208EC00h */ case   12:  		/* cmplwi CR6, R7, 0 */
		/* 8208EC00h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8208EC00h case   12:*/		return 0x8208EC04;
		  /* 8208EC04h */ case   13:  		/* bc 12, CR6_EQ, 1640 */
		/* 8208EC04h case   13:*/		if ( regs.CR[6].eq ) { return 0x8208F26C;  }
		/* 8208EC04h case   13:*/		return 0x8208EC08;
		  /* 8208EC08h */ case   14:  		/* lhz R11, <#[R7]> */
		/* 8208EC08h case   14:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 8208EC08h case   14:*/		return 0x8208EC0C;
		  /* 8208EC0Ch */ case   15:  		/* cmplwi CR0, R11, 0 */
		/* 8208EC0Ch case   15:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8208EC0Ch case   15:*/		return 0x8208EC10;
		  /* 8208EC10h */ case   16:  		/* bc 12, CR0_EQ, 1628 */
		/* 8208EC10h case   16:*/		if ( regs.CR[0].eq ) { return 0x8208F26C;  }
		/* 8208EC10h case   16:*/		return 0x8208EC14;
		  /* 8208EC14h */ case   17:  		/* rlwinm R11, R6, 8, 24, 31 */
		/* 8208EC14h case   17:*/		cpu::op::rlwinm<0,8,24,31>(regs,&regs.R11,regs.R6);
		/* 8208EC14h case   17:*/		return 0x8208EC18;
		  /* 8208EC18h */ case   18:  		/* rlwinm R9, R6, 24, 24, 31 */
		/* 8208EC18h case   18:*/		cpu::op::rlwinm<0,24,24,31>(regs,&regs.R9,regs.R6);
		/* 8208EC18h case   18:*/		return 0x8208EC1C;
		  /* 8208EC1Ch */ case   19:  		/* std R11, <#[R1 + 88]> */
		/* 8208EC1Ch case   19:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8208EC1Ch case   19:*/		return 0x8208EC20;
		  /* 8208EC20h */ case   20:  		/* lfd FR13, <#[R1 + 88]> */
		/* 8208EC20h case   20:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 8208EC20h case   20:*/		return 0x8208EC24;
		  /* 8208EC24h */ case   21:  		/* rlwinm R10, R6, 16, 24, 31 */
		/* 8208EC24h case   21:*/		cpu::op::rlwinm<0,16,24,31>(regs,&regs.R10,regs.R6);
		/* 8208EC24h case   21:*/		return 0x8208EC28;
		  /* 8208EC28h */ case   22:  		/* std R9, <#[R1 + 88]> */
		/* 8208EC28h case   22:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 8208EC28h case   22:*/		return 0x8208EC2C;
		  /* 8208EC2Ch */ case   23:  		/* rlwinm R11, R6, 0, 24, 31 */
		/* 8208EC2Ch case   23:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R6);
		/* 8208EC2Ch case   23:*/		return 0x8208EC30;
		  /* 8208EC30h */ case   24:  		/* lfd FR0, <#[R1 + 88]> */
		/* 8208EC30h case   24:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 8208EC30h case   24:*/		return 0x8208EC34;
		  /* 8208EC34h */ case   25:  		/* std R10, <#[R1 + 80]> */
		/* 8208EC34h case   25:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8208EC34h case   25:*/		return 0x8208EC38;
		  /* 8208EC38h */ case   26:  		/* lfd FR12, <#[R1 + 80]> */
		/* 8208EC38h case   26:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R1 + 0x00000050) );
		/* 8208EC38h case   26:*/		return 0x8208EC3C;
		  /* 8208EC3Ch */ case   27:  		/* std R11, <#[R1 + 88]> */
		/* 8208EC3Ch case   27:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8208EC3Ch case   27:*/		return 0x8208EC40;
		  /* 8208EC40h */ case   28:  		/* lfd FR11, <#[R1 + 88]> */
		/* 8208EC40h case   28:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R1 + 0x00000058) );
		/* 8208EC40h case   28:*/		return 0x8208EC44;
		  /* 8208EC44h */ case   29:  		/* fcfid FR13, FR13 */
		/* 8208EC44h case   29:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 8208EC44h case   29:*/		return 0x8208EC48;
		  /* 8208EC48h */ case   30:  		/* lis R10, -32256 */
		/* 8208EC48h case   30:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8208EC48h case   30:*/		return 0x8208EC4C;
		  /* 8208EC4Ch */ case   31:  		/* frsp FR13, FR13 */
		/* 8208EC4Ch case   31:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 8208EC4Ch case   31:*/		return 0x8208EC50;
		  /* 8208EC50h */ case   32:  		/* fcfid FR10, FR0 */
		/* 8208EC50h case   32:*/		cpu::op::fcfid<0>(regs,&regs.FR10,regs.FR0);
		/* 8208EC50h case   32:*/		return 0x8208EC54;
		  /* 8208EC54h */ case   33:  		/* lfs FR0, <#[R10 + 2968]> */
		/* 8208EC54h case   33:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000B98) );
		/* 8208EC54h case   33:*/		return 0x8208EC58;
		  /* 8208EC58h */ case   34:  		/* fcfid FR12, FR12 */
		/* 8208EC58h case   34:*/		cpu::op::fcfid<0>(regs,&regs.FR12,regs.FR12);
		/* 8208EC58h case   34:*/		return 0x8208EC5C;
		  /* 8208EC5Ch */ case   35:  		/* fcfid FR11, FR11 */
		/* 8208EC5Ch case   35:*/		cpu::op::fcfid<0>(regs,&regs.FR11,regs.FR11);
		/* 8208EC5Ch case   35:*/		return 0x8208EC60;
		  /* 8208EC60h */ case   36:  		/* fmuls FR25, FR13, FR0 */
		/* 8208EC60h case   36:*/		cpu::op::fmuls<0>(regs,&regs.FR25,regs.FR13,regs.FR0);
		/* 8208EC60h case   36:*/		return 0x8208EC64;
		  /* 8208EC64h */ case   37:  		/* frsp FR10, FR10 */
		/* 8208EC64h case   37:*/		cpu::op::frsp<0>(regs,&regs.FR10,regs.FR10);
		/* 8208EC64h case   37:*/		return 0x8208EC68;
		  /* 8208EC68h */ case   38:  		/* frsp FR12, FR12 */
		/* 8208EC68h case   38:*/		cpu::op::frsp<0>(regs,&regs.FR12,regs.FR12);
		/* 8208EC68h case   38:*/		return 0x8208EC6C;
		  /* 8208EC6Ch */ case   39:  		/* frsp FR11, FR11 */
		/* 8208EC6Ch case   39:*/		cpu::op::frsp<0>(regs,&regs.FR11,regs.FR11);
		/* 8208EC6Ch case   39:*/		return 0x8208EC70;
		  /* 8208EC70h */ case   40:  		/* fmuls FR28, FR10, FR0 */
		/* 8208EC70h case   40:*/		cpu::op::fmuls<0>(regs,&regs.FR28,regs.FR10,regs.FR0);
		/* 8208EC70h case   40:*/		return 0x8208EC74;
		  /* 8208EC74h */ case   41:  		/* fmuls FR27, FR12, FR0 */
		/* 8208EC74h case   41:*/		cpu::op::fmuls<0>(regs,&regs.FR27,regs.FR12,regs.FR0);
		/* 8208EC74h case   41:*/		return 0x8208EC78;
		  /* 8208EC78h */ case   42:  		/* fmuls FR29, FR11, FR0 */
		/* 8208EC78h case   42:*/		cpu::op::fmuls<0>(regs,&regs.FR29,regs.FR11,regs.FR0);
		/* 8208EC78h case   42:*/		return 0x8208EC7C;
		  /* 8208EC7Ch */ case   43:  		/* bl -1444 */
		/* 8208EC7Ch case   43:*/		regs.LR = 0x8208EC80; return 0x8208E6D8;
		/* 8208EC7Ch case   43:*/		return 0x8208EC80;
		  /* 8208EC80h */ case   44:  		/* lis R28, -32215 */
		/* 8208EC80h case   44:*/		cpu::op::lis<0>(regs,&regs.R28,0xFFFF8229);
		/* 8208EC80h case   44:*/		return 0x8208EC84;
		  /* 8208EC84h */ case   45:  		/* lis R10, -32256 */
		/* 8208EC84h case   45:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8208EC84h case   45:*/		return 0x8208EC88;
		  /* 8208EC88h */ case   46:  		/* li R12, 1 */
		/* 8208EC88h case   46:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 8208EC88h case   46:*/		return 0x8208EC8C;
		  /* 8208EC8Ch */ case   47:  		/* rldicr R12, R12, 63, 63 */
		/* 8208EC8Ch case   47:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R12,regs.R12);
		/* 8208EC8Ch case   47:*/		return 0x8208EC90;
		  /* 8208EC90h */ case   48:  		/* lwz R11, <#[R28 - 31244]> */
		/* 8208EC90h case   48:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0xFFFF85F4) );
		/* 8208EC90h case   48:*/		return 0x8208EC94;
		  /* 8208EC94h */ case   49:  		/* lfs FR26, <#[R10 + 1816]> */
		/* 8208EC94h case   49:*/		cpu::mem::load32f( regs, &regs.FR26, (uint32)(regs.R10 + 0x00000718) );
		/* 8208EC94h case   49:*/		return 0x8208EC98;
		  /* 8208EC98h */ case   50:  		/* fcmpu CR6, FR30, FR26 */
		/* 8208EC98h case   50:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR26);
		/* 8208EC98h case   50:*/		return 0x8208EC9C;
		  /* 8208EC9Ch */ case   51:  		/* stfs FR27, <#[R11 + 1936]> */
		/* 8208EC9Ch case   51:*/		cpu::mem::store32f( regs, regs.FR27, (uint32)(regs.R11 + 0x00000790) );
		/* 8208EC9Ch case   51:*/		return 0x8208ECA0;
		  /* 8208ECA0h */ case   52:  		/* stfs FR28, <#[R11 + 1940]> */
		/* 8208ECA0h case   52:*/		cpu::mem::store32f( regs, regs.FR28, (uint32)(regs.R11 + 0x00000794) );
		/* 8208ECA0h case   52:*/		return 0x8208ECA4;
		  /* 8208ECA4h */ case   53:  		/* stfs FR29, <#[R11 + 1944]> */
		/* 8208ECA4h case   53:*/		cpu::mem::store32f( regs, regs.FR29, (uint32)(regs.R11 + 0x00000798) );
		/* 8208ECA4h case   53:*/		return 0x8208ECA8;
		  /* 8208ECA8h */ case   54:  		/* stfs FR25, <#[R11 + 1948]> */
		/* 8208ECA8h case   54:*/		cpu::mem::store32f( regs, regs.FR25, (uint32)(regs.R11 + 0x0000079C) );
		/* 8208ECA8h case   54:*/		return 0x8208ECAC;
		  /* 8208ECACh */ case   55:  		/* ld R10, <#[R11]> */
		/* 8208ECACh case   55:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208ECACh case   55:*/		return 0x8208ECB0;
		  /* 8208ECB0h */ case   56:  		/* or R10, R10, R12 */
		/* 8208ECB0h case   56:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 8208ECB0h case   56:*/		return 0x8208ECB4;
		  /* 8208ECB4h */ case   57:  		/* std R10, <#[R11]> */
		/* 8208ECB4h case   57:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208ECB4h case   57:*/		return 0x8208ECB8;
		  /* 8208ECB8h */ case   58:  		/* bc 12, CR6_LT, 20 */
		/* 8208ECB8h case   58:*/		if ( regs.CR[6].lt ) { return 0x8208ECCC;  }
		/* 8208ECB8h case   58:*/		return 0x8208ECBC;
		  /* 8208ECBCh */ case   59:  		/* rlwinm. R11, R24, 0, 31, 31 */
		/* 8208ECBCh case   59:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R24);
		/* 8208ECBCh case   59:*/		return 0x8208ECC0;
		  /* 8208ECC0h */ case   60:  		/* bc 12, CR0_EQ, 48 */
		/* 8208ECC0h case   60:*/		if ( regs.CR[0].eq ) { return 0x8208ECF0;  }
		/* 8208ECC0h case   60:*/		return 0x8208ECC4;
		  /* 8208ECC4h */ case   61:  		/* fcmpu CR6, FR30, FR26 */
		/* 8208ECC4h case   61:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR26);
		/* 8208ECC4h case   61:*/		return 0x8208ECC8;
		  /* 8208ECC8h */ case   62:  		/* bc 12, CR6_GT, 40 */
		/* 8208ECC8h case   62:*/		if ( regs.CR[6].gt ) { return 0x8208ECF0;  }
		/* 8208ECC8h case   62:*/		return 0x8208ECCC;
	}
	return 0x8208ECCC;
} // Block from 8208EBD0h-8208ECCCh (63 instructions)

//////////////////////////////////////////////////////
// Block at 8208ECCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208ECCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208ECCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208ECCC);
		  /* 8208ECCCh */ case    0:  		/* lwz R11, <#[R31 + 80]> */
		/* 8208ECCCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8208ECCCh case    0:*/		return 0x8208ECD0;
		  /* 8208ECD0h */ case    1:  		/* lwz R10, <#[R31 + 72]> */
		/* 8208ECD0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000048) );
		/* 8208ECD0h case    1:*/		return 0x8208ECD4;
		  /* 8208ECD4h */ case    2:  		/* subf R11, R10, R11 */
		/* 8208ECD4h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208ECD4h case    2:*/		return 0x8208ECD8;
		  /* 8208ECD8h */ case    3:  		/* extsw R11, R11 */
		/* 8208ECD8h case    3:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 8208ECD8h case    3:*/		return 0x8208ECDC;
		  /* 8208ECDCh */ case    4:  		/* std R11, <#[R1 + 88]> */
		/* 8208ECDCh case    4:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8208ECDCh case    4:*/		return 0x8208ECE0;
		  /* 8208ECE0h */ case    5:  		/* lfd FR0, <#[R1 + 88]> */
		/* 8208ECE0h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 8208ECE0h case    5:*/		return 0x8208ECE4;
		  /* 8208ECE4h */ case    6:  		/* fcfid FR0, FR0 */
		/* 8208ECE4h case    6:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 8208ECE4h case    6:*/		return 0x8208ECE8;
		  /* 8208ECE8h */ case    7:  		/* frsp FR0, FR0 */
		/* 8208ECE8h case    7:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 8208ECE8h case    7:*/		return 0x8208ECEC;
		  /* 8208ECECh */ case    8:  		/* fadds FR30, FR0, FR30 */
		/* 8208ECECh case    8:*/		cpu::op::fadds<0>(regs,&regs.FR30,regs.FR0,regs.FR30);
		/* 8208ECECh case    8:*/		return 0x8208ECF0;
	}
	return 0x8208ECF0;
} // Block from 8208ECCCh-8208ECF0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8208ECF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208ECF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208ECF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208ECF0);
		  /* 8208ECF0h */ case    0:  		/* fcmpu CR6, FR31, FR26 */
		/* 8208ECF0h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR26);
		/* 8208ECF0h case    0:*/		return 0x8208ECF4;
		  /* 8208ECF4h */ case    1:  		/* bc 4, CR6_LT, 40 */
		/* 8208ECF4h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8208ED1C;  }
		/* 8208ECF4h case    1:*/		return 0x8208ECF8;
		  /* 8208ECF8h */ case    2:  		/* lwz R11, <#[R31 + 84]> */
		/* 8208ECF8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 8208ECF8h case    2:*/		return 0x8208ECFC;
		  /* 8208ECFCh */ case    3:  		/* lwz R10, <#[R31 + 76]> */
		/* 8208ECFCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000004C) );
		/* 8208ECFCh case    3:*/		return 0x8208ED00;
		  /* 8208ED00h */ case    4:  		/* subf R11, R10, R11 */
		/* 8208ED00h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208ED00h case    4:*/		return 0x8208ED04;
		  /* 8208ED04h */ case    5:  		/* extsw R11, R11 */
		/* 8208ED04h case    5:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 8208ED04h case    5:*/		return 0x8208ED08;
		  /* 8208ED08h */ case    6:  		/* std R11, <#[R1 + 88]> */
		/* 8208ED08h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8208ED08h case    6:*/		return 0x8208ED0C;
		  /* 8208ED0Ch */ case    7:  		/* lfd FR0, <#[R1 + 88]> */
		/* 8208ED0Ch case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 8208ED0Ch case    7:*/		return 0x8208ED10;
		  /* 8208ED10h */ case    8:  		/* fcfid FR0, FR0 */
		/* 8208ED10h case    8:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 8208ED10h case    8:*/		return 0x8208ED14;
		  /* 8208ED14h */ case    9:  		/* frsp FR0, FR0 */
		/* 8208ED14h case    9:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 8208ED14h case    9:*/		return 0x8208ED18;
		  /* 8208ED18h */ case   10:  		/* fadds FR31, FR0, FR31 */
		/* 8208ED18h case   10:*/		cpu::op::fadds<0>(regs,&regs.FR31,regs.FR0,regs.FR31);
		/* 8208ED18h case   10:*/		return 0x8208ED1C;
	}
	return 0x8208ED1C;
} // Block from 8208ECF0h-8208ED1Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8208ED1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208ED1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208ED1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208ED1C);
		  /* 8208ED1Ch */ case    0:  		/* fmr FR1, FR30 */
		/* 8208ED1Ch case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 8208ED1Ch case    0:*/		return 0x8208ED20;
		  /* 8208ED20h */ case    1:  		/* bl 12736 */
		/* 8208ED20h case    1:*/		regs.LR = 0x8208ED24; return 0x82091EE0;
		/* 8208ED20h case    1:*/		return 0x8208ED24;
		  /* 8208ED24h */ case    2:  		/* frsp FR0, FR1 */
		/* 8208ED24h case    2:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR1);
		/* 8208ED24h case    2:*/		return 0x8208ED28;
		  /* 8208ED28h */ case    3:  		/* stfs FR0, <#[R31 + 88]> */
		/* 8208ED28h case    3:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000058) );
		/* 8208ED28h case    3:*/		return 0x8208ED2C;
		  /* 8208ED2Ch */ case    4:  		/* fmr FR1, FR31 */
		/* 8208ED2Ch case    4:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8208ED2Ch case    4:*/		return 0x8208ED30;
		  /* 8208ED30h */ case    5:  		/* bl 12720 */
		/* 8208ED30h case    5:*/		regs.LR = 0x8208ED34; return 0x82091EE0;
		/* 8208ED30h case    5:*/		return 0x8208ED34;
		  /* 8208ED34h */ case    6:  		/* frsp FR11, FR1 */
		/* 8208ED34h case    6:*/		cpu::op::frsp<0>(regs,&regs.FR11,regs.FR1);
		/* 8208ED34h case    6:*/		return 0x8208ED38;
		  /* 8208ED38h */ case    7:  		/* stfs FR11, <#[R31 + 92]> */
		/* 8208ED38h case    7:*/		cpu::mem::store32f( regs, regs.FR11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208ED38h case    7:*/		return 0x8208ED3C;
		  /* 8208ED3Ch */ case    8:  		/* lwz R10, <#[R31 + 100]> */
		/* 8208ED3Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000064) );
		/* 8208ED3Ch case    8:*/		return 0x8208ED40;
		  /* 8208ED40h */ case    9:  		/* lwz R11, <#[R31 + 108]> */
		/* 8208ED40h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 8208ED40h case    9:*/		return 0x8208ED44;
		  /* 8208ED44h */ case   10:  		/* lis R9, -32256 */
		/* 8208ED44h case   10:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 8208ED44h case   10:*/		return 0x8208ED48;
		  /* 8208ED48h */ case   11:  		/* lfs FR0, <#[R31 + 32]> */
		/* 8208ED48h case   11:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000020) );
		/* 8208ED48h case   11:*/		return 0x8208ED4C;
		  /* 8208ED4Ch */ case   12:  		/* rlwinm. R8, R24, 0, 28, 28 */
		/* 8208ED4Ch case   12:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R8,regs.R24);
		/* 8208ED4Ch case   12:*/		return 0x8208ED50;
		  /* 8208ED50h */ case   13:  		/* fsubs FR31, FR31, FR0 */
		/* 8208ED50h case   13:*/		cpu::op::fsubs<0>(regs,&regs.FR31,regs.FR31,regs.FR0);
		/* 8208ED50h case   13:*/		return 0x8208ED54;
		  /* 8208ED54h */ case   14:  		/* lfs FR0, <#[R9 + 8532]> */
		/* 8208ED54h case   14:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00002154) );
		/* 8208ED54h case   14:*/		return 0x8208ED58;
		  /* 8208ED58h */ case   15:  		/* lfs FR13, <#[R31 + 44]> */
		/* 8208ED58h case   15:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R31 + 0x0000002C) );
		/* 8208ED58h case   15:*/		return 0x8208ED5C;
		  /* 8208ED5Ch */ case   16:  		/* lhz R10, <#[R10 + 92]> */
		/* 8208ED5Ch case   16:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000005C) );
		/* 8208ED5Ch case   16:*/		return 0x8208ED60;
		  /* 8208ED60h */ case   17:  		/* rlwinm R10, R10, 4, 0, 31 */
		/* 8208ED60h case   17:*/		cpu::op::rlwinm<0,4,0,31>(regs,&regs.R10,regs.R10);
		/* 8208ED60h case   17:*/		return 0x8208ED64;
		  /* 8208ED64h */ case   18:  		/* add R11, R10, R11 */
		/* 8208ED64h case   18:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208ED64h case   18:*/		return 0x8208ED68;
		  /* 8208ED68h */ case   19:  		/* lha R9, <#[R11 + 8]> */
		/* 8208ED68h case   19:*/		cpu::mem::load16a( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8208ED68h case   19:*/		return 0x8208ED6C;
		  /* 8208ED6Ch */ case   20:  		/* lha R10, <#[R11 + 12]> */
		/* 8208ED6Ch case   20:*/		cpu::mem::load16a( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8208ED6Ch case   20:*/		return 0x8208ED70;
		  /* 8208ED70h */ case   21:  		/* add R11, R10, R9 */
		/* 8208ED70h case   21:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R9);
		/* 8208ED70h case   21:*/		return 0x8208ED74;
		  /* 8208ED74h */ case   22:  		/* extsw R11, R11 */
		/* 8208ED74h case   22:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 8208ED74h case   22:*/		return 0x8208ED78;
		  /* 8208ED78h */ case   23:  		/* std R11, <#[R1 + 88]> */
		/* 8208ED78h case   23:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8208ED78h case   23:*/		return 0x8208ED7C;
		  /* 8208ED7Ch */ case   24:  		/* lfd FR12, <#[R1 + 88]> */
		/* 8208ED7Ch case   24:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R1 + 0x00000058) );
		/* 8208ED7Ch case   24:*/		return 0x8208ED80;
		  /* 8208ED80h */ case   25:  		/* fcfid FR12, FR12 */
		/* 8208ED80h case   25:*/		cpu::op::fcfid<0>(regs,&regs.FR12,regs.FR12);
		/* 8208ED80h case   25:*/		return 0x8208ED84;
		  /* 8208ED84h */ case   26:  		/* frsp FR12, FR12 */
		/* 8208ED84h case   26:*/		cpu::op::frsp<0>(regs,&regs.FR12,regs.FR12);
		/* 8208ED84h case   26:*/		return 0x8208ED88;
		  /* 8208ED88h */ case   27:  		/* fmuls FR13, FR12, FR13 */
		/* 8208ED88h case   27:*/		cpu::op::fmuls<0>(regs,&regs.FR13,regs.FR12,regs.FR13);
		/* 8208ED88h case   27:*/		return 0x8208ED8C;
		  /* 8208ED8Ch */ case   28:  		/* fmuls FR25, FR13, FR0 */
		/* 8208ED8Ch case   28:*/		cpu::op::fmuls<0>(regs,&regs.FR25,regs.FR13,regs.FR0);
		/* 8208ED8Ch case   28:*/		return 0x8208ED90;
		  /* 8208ED90h */ case   29:  		/* bc 12, CR0_EQ, 52 */
		/* 8208ED90h case   29:*/		if ( regs.CR[0].eq ) { return 0x8208EDC4;  }
		/* 8208ED90h case   29:*/		return 0x8208ED94;
		  /* 8208ED94h */ case   30:  		/* fcmpu CR6, FR23, FR26 */
		/* 8208ED94h case   30:*/		cpu::op::fcmpu<6>(regs,regs.FR23,regs.FR26);
		/* 8208ED94h case   30:*/		return 0x8208ED98;
		  /* 8208ED98h */ case   31:  		/* bc 4, CR6_GT, 40 */
		/* 8208ED98h case   31:*/		if ( !regs.CR[6].gt ) { return 0x8208EDC0;  }
		/* 8208ED98h case   31:*/		return 0x8208ED9C;
		  /* 8208ED9Ch */ case   32:  		/* li R7, 1 */
		/* 8208ED9Ch case   32:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8208ED9Ch case   32:*/		return 0x8208EDA0;
		  /* 8208EDA0h */ case   33:  		/* addi R6, R1, 88 */
		/* 8208EDA0h case   33:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x58);
		/* 8208EDA0h case   33:*/		return 0x8208EDA4;
		  /* 8208EDA4h */ case   34:  		/* addi R5, R1, 80 */
		/* 8208EDA4h case   34:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8208EDA4h case   34:*/		return 0x8208EDA8;
		  /* 8208EDA8h */ case   35:  		/* mr R4, R26 */
		/* 8208EDA8h case   35:*/		regs.R4 = regs.R26;
		/* 8208EDA8h case   35:*/		return 0x8208EDAC;
		  /* 8208EDACh */ case   36:  		/* mr R3, R31 */
		/* 8208EDACh case   36:*/		regs.R3 = regs.R31;
		/* 8208EDACh case   36:*/		return 0x8208EDB0;
		  /* 8208EDB0h */ case   37:  		/* bl -2960 */
		/* 8208EDB0h case   37:*/		regs.LR = 0x8208EDB4; return 0x8208E220;
		/* 8208EDB0h case   37:*/		return 0x8208EDB4;
		  /* 8208EDB4h */ case   38:  		/* lfs FR0, <#[R1 + 80]> */
		/* 8208EDB4h case   38:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 8208EDB4h case   38:*/		return 0x8208EDB8;
		  /* 8208EDB8h */ case   39:  		/* fcmpu CR6, FR0, FR23 */
		/* 8208EDB8h case   39:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR23);
		/* 8208EDB8h case   39:*/		return 0x8208EDBC;
		  /* 8208EDBCh */ case   40:  		/* bc 12, CR6_GT, 8 */
		/* 8208EDBCh case   40:*/		if ( regs.CR[6].gt ) { return 0x8208EDC4;  }
		/* 8208EDBCh case   40:*/		return 0x8208EDC0;
	}
	return 0x8208EDC0;
} // Block from 8208ED1Ch-8208EDC0h (41 instructions)

//////////////////////////////////////////////////////
// Block at 8208EDC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208EDC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208EDC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208EDC0);
		  /* 8208EDC0h */ case    0:  		/* rlwinm R24, R24, 0, 29, 27 */
		/* 8208EDC0h case    0:*/		cpu::op::rlwinm<0,0,29,27>(regs,&regs.R24,regs.R24);
		/* 8208EDC0h case    0:*/		return 0x8208EDC4;
	}
	return 0x8208EDC4;
} // Block from 8208EDC0h-8208EDC4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208EDC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208EDC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208EDC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208EDC4);
		  /* 8208EDC4h */ case    0:  		/* lis R11, -32256 */
		/* 8208EDC4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8208EDC4h case    0:*/		return 0x8208EDC8;
		  /* 8208EDC8h */ case    1:  		/* rlwinm. R10, R24, 0, 29, 29 */
		/* 8208EDC8h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R24);
		/* 8208EDC8h case    1:*/		return 0x8208EDCC;
		  /* 8208EDCCh */ case    2:  		/* lfs FR24, <#[R11 + 1820]> */
		/* 8208EDCCh case    2:*/		cpu::mem::load32f( regs, &regs.FR24, (uint32)(regs.R11 + 0x0000071C) );
		/* 8208EDCCh case    2:*/		return 0x8208EDD0;
		  /* 8208EDD0h */ case    3:  		/* bc 12, CR0_EQ, 48 */
		/* 8208EDD0h case    3:*/		if ( regs.CR[0].eq ) { return 0x8208EE00;  }
		/* 8208EDD0h case    3:*/		return 0x8208EDD4;
		  /* 8208EDD4h */ case    4:  		/* li R7, 0 */
		/* 8208EDD4h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8208EDD4h case    4:*/		return 0x8208EDD8;
		  /* 8208EDD8h */ case    5:  		/* addi R6, R1, 80 */
		/* 8208EDD8h case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 8208EDD8h case    5:*/		return 0x8208EDDC;
		  /* 8208EDDCh */ case    6:  		/* addi R5, R1, 88 */
		/* 8208EDDCh case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 8208EDDCh case    6:*/		return 0x8208EDE0;
		  /* 8208EDE0h */ case    7:  		/* mr R4, R26 */
		/* 8208EDE0h case    7:*/		regs.R4 = regs.R26;
		/* 8208EDE0h case    7:*/		return 0x8208EDE4;
		  /* 8208EDE4h */ case    8:  		/* mr R3, R31 */
		/* 8208EDE4h case    8:*/		regs.R3 = regs.R31;
		/* 8208EDE4h case    8:*/		return 0x8208EDE8;
		  /* 8208EDE8h */ case    9:  		/* bl -3016 */
		/* 8208EDE8h case    9:*/		regs.LR = 0x8208EDEC; return 0x8208E220;
		/* 8208EDE8h case    9:*/		return 0x8208EDEC;
		  /* 8208EDECh */ case   10:  		/* lfs FR0, <#[R1 + 80]> */
		/* 8208EDECh case   10:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 8208EDECh case   10:*/		return 0x8208EDF0;
		  /* 8208EDF0h */ case   11:  		/* fnmsubs FR1, FR0, FR24, FR11 */
		/* 8208EDF0h case   11:*/		cpu::op::fnmsubs<0>(regs,&regs.FR1,regs.FR0,regs.FR24,regs.FR11);
		/* 8208EDF0h case   11:*/		return 0x8208EDF4;
		  /* 8208EDF4h */ case   12:  		/* bl 12524 */
		/* 8208EDF4h case   12:*/		regs.LR = 0x8208EDF8; return 0x82091EE0;
		/* 8208EDF4h case   12:*/		return 0x8208EDF8;
		  /* 8208EDF8h */ case   13:  		/* frsp FR0, FR1 */
		/* 8208EDF8h case   13:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR1);
		/* 8208EDF8h case   13:*/		return 0x8208EDFC;
		  /* 8208EDFCh */ case   14:  		/* stfs FR0, <#[R31 + 92]> */
		/* 8208EDFCh case   14:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208EDFCh case   14:*/		return 0x8208EE00;
	}
	return 0x8208EE00;
} // Block from 8208EDC4h-8208EE00h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8208EE00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208EE00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208EE00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208EE00);
		  /* 8208EE00h */ case    0:  		/* lwa R11, <#[R31 + 76]> */
		/* 8208EE00h case    0:*/		cpu::mem::load32a( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 8208EE00h case    0:*/		return 0x8208EE04;
		  /* 8208EE04h */ case    1:  		/* lfs FR0, <#[R31 + 88]> */
		/* 8208EE04h case    1:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000058) );
		/* 8208EE04h case    1:*/		return 0x8208EE08;
		  /* 8208EE08h */ case    2:  		/* std R11, <#[R1 + 88]> */
		/* 8208EE08h case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8208EE08h case    2:*/		return 0x8208EE0C;
		  /* 8208EE0Ch */ case    3:  		/* lfs FR13, <#[R31 + 92]> */
		/* 8208EE0Ch case    3:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208EE0Ch case    3:*/		return 0x8208EE10;
		  /* 8208EE10h */ case    4:  		/* lwa R10, <#[R31 + 72]> */
		/* 8208EE10h case    4:*/		cpu::mem::load32a( regs, &regs.R10, (uint32)(regs.R31 + 0x00000048) );
		/* 8208EE10h case    4:*/		return 0x8208EE14;
		  /* 8208EE14h */ case    5:  		/* mr R3, R26 */
		/* 8208EE14h case    5:*/		regs.R3 = regs.R26;
		/* 8208EE14h case    5:*/		return 0x8208EE18;
		  /* 8208EE18h */ case    6:  		/* li R29, 0 */
		/* 8208EE18h case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8208EE18h case    6:*/		return 0x8208EE1C;
		  /* 8208EE1Ch */ case    7:  		/* rlwinm R25, R24, 0, 28, 28 */
		/* 8208EE1Ch case    7:*/		cpu::op::rlwinm<0,0,28,28>(regs,&regs.R25,regs.R24);
		/* 8208EE1Ch case    7:*/		return 0x8208EE20;
		  /* 8208EE20h */ case    8:  		/* lfd FR12, <#[R1 + 88]> */
		/* 8208EE20h case    8:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R1 + 0x00000058) );
		/* 8208EE20h case    8:*/		return 0x8208EE24;
		  /* 8208EE24h */ case    9:  		/* std R10, <#[R1 + 88]> */
		/* 8208EE24h case    9:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 8208EE24h case    9:*/		return 0x8208EE28;
		  /* 8208EE28h */ case   10:  		/* lfd FR11, <#[R1 + 88]> */
		/* 8208EE28h case   10:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R1 + 0x00000058) );
		/* 8208EE28h case   10:*/		return 0x8208EE2C;
		  /* 8208EE2Ch */ case   11:  		/* fcfid FR11, FR11 */
		/* 8208EE2Ch case   11:*/		cpu::op::fcfid<0>(regs,&regs.FR11,regs.FR11);
		/* 8208EE2Ch case   11:*/		return 0x8208EE30;
		  /* 8208EE30h */ case   12:  		/* fcfid FR12, FR12 */
		/* 8208EE30h case   12:*/		cpu::op::fcfid<0>(regs,&regs.FR12,regs.FR12);
		/* 8208EE30h case   12:*/		return 0x8208EE34;
		  /* 8208EE34h */ case   13:  		/* frsp FR28, FR11 */
		/* 8208EE34h case   13:*/		cpu::op::frsp<0>(regs,&regs.FR28,regs.FR11);
		/* 8208EE34h case   13:*/		return 0x8208EE38;
		  /* 8208EE38h */ case   14:  		/* frsp FR27, FR12 */
		/* 8208EE38h case   14:*/		cpu::op::frsp<0>(regs,&regs.FR27,regs.FR12);
		/* 8208EE38h case   14:*/		return 0x8208EE3C;
		  /* 8208EE3Ch */ case   15:  		/* fadds FR0, FR0, FR28 */
		/* 8208EE3Ch case   15:*/		cpu::op::fadds<0>(regs,&regs.FR0,regs.FR0,regs.FR28);
		/* 8208EE3Ch case   15:*/		return 0x8208EE40;
		  /* 8208EE40h */ case   16:  		/* stfs FR0, <#[R31 + 88]> */
		/* 8208EE40h case   16:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000058) );
		/* 8208EE40h case   16:*/		return 0x8208EE44;
		  /* 8208EE44h */ case   17:  		/* fadds FR0, FR27, FR13 */
		/* 8208EE44h case   17:*/		cpu::op::fadds<0>(regs,&regs.FR0,regs.FR27,regs.FR13);
		/* 8208EE44h case   17:*/		return 0x8208EE48;
		  /* 8208EE48h */ case   18:  		/* stfs FR0, <#[R31 + 92]> */
		/* 8208EE48h case   18:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208EE48h case   18:*/		return 0x8208EE4C;
		  /* 8208EE4Ch */ case   19:  		/* fadds FR29, FR27, FR31 */
		/* 8208EE4Ch case   19:*/		cpu::op::fadds<0>(regs,&regs.FR29,regs.FR27,regs.FR31);
		/* 8208EE4Ch case   19:*/		return 0x8208EE50;
		  /* 8208EE50h */ case   20:  		/* fadds FR31, FR28, FR30 */
		/* 8208EE50h case   20:*/		cpu::op::fadds<0>(regs,&regs.FR31,regs.FR28,regs.FR30);
		/* 8208EE50h case   20:*/		return 0x8208EE54;
		  /* 8208EE54h */ case   21:  		/* bl 18860 */
		/* 8208EE54h case   21:*/		regs.LR = 0x8208EE58; return 0x82093800;
		/* 8208EE54h case   21:*/		return 0x8208EE58;
		  /* 8208EE58h */ case   22:  		/* subfic R11, R25, 0 */
		/* 8208EE58h case   22:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R25,0x0);
		/* 8208EE58h case   22:*/		return 0x8208EE5C;
		  /* 8208EE5Ch */ case   23:  		/* li R9, 3 */
		/* 8208EE5Ch case   23:*/		cpu::op::li<0>(regs,&regs.R9,0x3);
		/* 8208EE5Ch case   23:*/		return 0x8208EE60;
		  /* 8208EE60h */ case   24:  		/* lwz R11, <#[R28 - 31244]> */
		/* 8208EE60h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0xFFFF85F4) );
		/* 8208EE60h case   24:*/		return 0x8208EE64;
		  /* 8208EE64h */ case   25:  		/* subfe R10, R10, R10 */
		/* 8208EE64h case   25:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8208EE64h case   25:*/		return 0x8208EE68;
		  /* 8208EE68h */ case   26:  		/* li R6, 16 */
		/* 8208EE68h case   26:*/		cpu::op::li<0>(regs,&regs.R6,0x10);
		/* 8208EE68h case   26:*/		return 0x8208EE6C;
		  /* 8208EE6Ch */ case   27:  		/* and R10, R10, R9 */
		/* 8208EE6Ch case   27:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8208EE6Ch case   27:*/		return 0x8208EE70;
		  /* 8208EE70h */ case   28:  		/* li R4, 13 */
		/* 8208EE70h case   28:*/		cpu::op::li<0>(regs,&regs.R4,0xD);
		/* 8208EE70h case   28:*/		return 0x8208EE74;
		  /* 8208EE74h */ case   29:  		/* add R27, R3, R10 */
		/* 8208EE74h case   29:*/		cpu::op::add<0>(regs,&regs.R27,regs.R3,regs.R10);
		/* 8208EE74h case   29:*/		return 0x8208EE78;
		  /* 8208EE78h */ case   30:  		/* mr R3, R11 */
		/* 8208EE78h case   30:*/		regs.R3 = regs.R11;
		/* 8208EE78h case   30:*/		return 0x8208EE7C;
		  /* 8208EE7Ch */ case   31:  		/* rlwinm R5, R27, 2, 0, 29 */
		/* 8208EE7Ch case   31:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R27);
		/* 8208EE7Ch case   31:*/		return 0x8208EE80;
		  /* 8208EE80h */ case   32:  		/* bl -124120 */
		/* 8208EE80h case   32:*/		regs.LR = 0x8208EE84; return 0x820709A8;
		/* 8208EE80h case   32:*/		return 0x8208EE84;
		  /* 8208EE84h */ case   33:  		/* lis R11, -32761 */
		/* 8208EE84h case   33:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8007);
		/* 8208EE84h case   33:*/		return 0x8208EE88;
		  /* 8208EE88h */ case   34:  		/* addic R10, R3, -1 */
		/* 8208EE88h case   34:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R3,0xFFFFFFFF);
		/* 8208EE88h case   34:*/		return 0x8208EE8C;
		  /* 8208EE8Ch */ case   35:  		/* ori R11, R11, 14 */
		/* 8208EE8Ch case   35:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xE);
		/* 8208EE8Ch case   35:*/		return 0x8208EE90;
		  /* 8208EE90h */ case   36:  		/* subfe R10, R10, R10 */
		/* 8208EE90h case   36:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8208EE90h case   36:*/		return 0x8208EE94;
		  /* 8208EE94h */ case   37:  		/* mr R30, R3 */
		/* 8208EE94h case   37:*/		regs.R30 = regs.R3;
		/* 8208EE94h case   37:*/		return 0x8208EE98;
		  /* 8208EE98h */ case   38:  		/* and. R11, R10, R11 */
		/* 8208EE98h case   38:*/		cpu::op::and<1>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208EE98h case   38:*/		return 0x8208EE9C;
		  /* 8208EE9Ch */ case   39:  		/* bc 4, CR0_LT, 16 */
		/* 8208EE9Ch case   39:*/		if ( !regs.CR[0].lt ) { return 0x8208EEAC;  }
		/* 8208EE9Ch case   39:*/		return 0x8208EEA0;
		  /* 8208EEA0h */ case   40:  		/* lis R11, -32255 */
		/* 8208EEA0h case   40:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208EEA0h case   40:*/		return 0x8208EEA4;
		  /* 8208EEA4h */ case   41:  		/* addi R3, R11, -26944 */
		/* 8208EEA4h case   41:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF96C0);
		/* 8208EEA4h case   41:*/		return 0x8208EEA8;
		  /* 8208EEA8h */ case   42:  		/* bl 2808 */
		/* 8208EEA8h case   42:*/		regs.LR = 0x8208EEAC; return 0x8208F9A0;
		/* 8208EEA8h case   42:*/		return 0x8208EEAC;
	}
	return 0x8208EEAC;
} // Block from 8208EE00h-8208EEACh (43 instructions)

//////////////////////////////////////////////////////
// Block at 8208EEACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208EEAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208EEAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208EEAC);
		  /* 8208EEACh */ case    0:  		/* li R9, 1 */
		/* 8208EEACh case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8208EEACh case    0:*/		return 0x8208EEB0;
		  /* 8208EEB0h */ case    1:  		/* b 820 */
		/* 8208EEB0h case    1:*/		return 0x8208F1E4;
		/* 8208EEB0h case    1:*/		return 0x8208EEB4;
		  /* 8208EEB4h */ case    2:  		/* cmplwi CR6, R29, 0 */
		/* 8208EEB4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8208EEB4h case    2:*/		return 0x8208EEB8;
		  /* 8208EEB8h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 8208EEB8h case    3:*/		if ( regs.CR[6].eq ) { return 0x8208EEC4;  }
		/* 8208EEB8h case    3:*/		return 0x8208EEBC;
		  /* 8208EEBCh */ case    4:  		/* li R11, 46 */
		/* 8208EEBCh case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x2E);
		/* 8208EEBCh case    4:*/		return 0x8208EEC0;
		  /* 8208EEC0h */ case    5:  		/* b 160 */
		/* 8208EEC0h case    5:*/		return 0x8208EF60;
		/* 8208EEC0h case    5:*/		return 0x8208EEC4;
	}
	return 0x8208EEC4;
} // Block from 8208EEACh-8208EEC4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208EEC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208EEC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208EEC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208EEC4);
		  /* 8208EEC4h */ case    0:  		/* cmpwi CR6, R9, 0 */
		/* 8208EEC4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 8208EEC4h case    0:*/		return 0x8208EEC8;
		  /* 8208EEC8h */ case    1:  		/* bc 12, CR6_EQ, 92 */
		/* 8208EEC8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8208EF24;  }
		/* 8208EEC8h case    1:*/		return 0x8208EECC;
		  /* 8208EECCh */ case    2:  		/* rlwinm. R11, R24, 0, 30, 31 */
		/* 8208EECCh case    2:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R11,regs.R24);
		/* 8208EECCh case    2:*/		return 0x8208EED0;
		  /* 8208EED0h */ case    3:  		/* bc 12, CR0_EQ, 80 */
		/* 8208EED0h case    3:*/		if ( regs.CR[0].eq ) { return 0x8208EF20;  }
		/* 8208EED0h case    3:*/		return 0x8208EED4;
		  /* 8208EED4h */ case    4:  		/* li R7, 1 */
		/* 8208EED4h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8208EED4h case    4:*/		return 0x8208EED8;
		  /* 8208EED8h */ case    5:  		/* addi R6, R1, 88 */
		/* 8208EED8h case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x58);
		/* 8208EED8h case    5:*/		return 0x8208EEDC;
		  /* 8208EEDCh */ case    6:  		/* addi R5, R1, 80 */
		/* 8208EEDCh case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8208EEDCh case    6:*/		return 0x8208EEE0;
		  /* 8208EEE0h */ case    7:  		/* mr R4, R26 */
		/* 8208EEE0h case    7:*/		regs.R4 = regs.R26;
		/* 8208EEE0h case    7:*/		return 0x8208EEE4;
		  /* 8208EEE4h */ case    8:  		/* mr R3, R31 */
		/* 8208EEE4h case    8:*/		regs.R3 = regs.R31;
		/* 8208EEE4h case    8:*/		return 0x8208EEE8;
		  /* 8208EEE8h */ case    9:  		/* bl -3272 */
		/* 8208EEE8h case    9:*/		regs.LR = 0x8208EEEC; return 0x8208E220;
		/* 8208EEE8h case    9:*/		return 0x8208EEEC;
		  /* 8208EEECh */ case   10:  		/* rlwinm. R11, R24, 0, 31, 31 */
		/* 8208EEECh case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R24);
		/* 8208EEECh case   10:*/		return 0x8208EEF0;
		  /* 8208EEF0h */ case   11:  		/* lfs FR30, <#[R1 + 80]> */
		/* 8208EEF0h case   11:*/		cpu::mem::load32f( regs, &regs.FR30, (uint32)(regs.R1 + 0x00000050) );
		/* 8208EEF0h case   11:*/		return 0x8208EEF4;
		  /* 8208EEF4h */ case   12:  		/* bc 12, CR0_EQ, 20 */
		/* 8208EEF4h case   12:*/		if ( regs.CR[0].eq ) { return 0x8208EF08;  }
		/* 8208EEF4h case   12:*/		return 0x8208EEF8;
		  /* 8208EEF8h */ case   13:  		/* fsubs FR1, FR31, FR30 */
		/* 8208EEF8h case   13:*/		cpu::op::fsubs<0>(regs,&regs.FR1,regs.FR31,regs.FR30);
		/* 8208EEF8h case   13:*/		return 0x8208EEFC;
		  /* 8208EEFCh */ case   14:  		/* bl 12260 */
		/* 8208EEFCh case   14:*/		regs.LR = 0x8208EF00; return 0x82091EE0;
		/* 8208EEFCh case   14:*/		return 0x8208EF00;
		  /* 8208EF00h */ case   15:  		/* frsp FR0, FR1 */
		/* 8208EF00h case   15:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR1);
		/* 8208EF00h case   15:*/		return 0x8208EF04;
		  /* 8208EF04h */ case   16:  		/* stfs FR0, <#[R31 + 88]> */
		/* 8208EF04h case   16:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000058) );
		/* 8208EF04h case   16:*/		return 0x8208EF08;
	}
	return 0x8208EF08;
} // Block from 8208EEC4h-8208EF08h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8208EF08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208EF08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208EF08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208EF08);
		  /* 8208EF08h */ case    0:  		/* rlwinm. R11, R24, 0, 30, 30 */
		/* 8208EF08h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R24);
		/* 8208EF08h case    0:*/		return 0x8208EF0C;
		  /* 8208EF0Ch */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 8208EF0Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8208EF20;  }
		/* 8208EF0Ch case    1:*/		return 0x8208EF10;
		  /* 8208EF10h */ case    2:  		/* fnmsubs FR1, FR30, FR24, FR31 */
		/* 8208EF10h case    2:*/		cpu::op::fnmsubs<0>(regs,&regs.FR1,regs.FR30,regs.FR24,regs.FR31);
		/* 8208EF10h case    2:*/		return 0x8208EF14;
		  /* 8208EF14h */ case    3:  		/* bl 12236 */
		/* 8208EF14h case    3:*/		regs.LR = 0x8208EF18; return 0x82091EE0;
		/* 8208EF14h case    3:*/		return 0x8208EF18;
		  /* 8208EF18h */ case    4:  		/* frsp FR0, FR1 */
		/* 8208EF18h case    4:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR1);
		/* 8208EF18h case    4:*/		return 0x8208EF1C;
		  /* 8208EF1Ch */ case    5:  		/* stfs FR0, <#[R31 + 88]> */
		/* 8208EF1Ch case    5:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000058) );
		/* 8208EF1Ch case    5:*/		return 0x8208EF20;
	}
	return 0x8208EF20;
} // Block from 8208EF08h-8208EF20h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208EF20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208EF20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208EF20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208EF20);
		  /* 8208EF20h */ case    0:  		/* li R9, 0 */
		/* 8208EF20h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8208EF20h case    0:*/		return 0x8208EF24;
	}
	return 0x8208EF24;
} // Block from 8208EF20h-8208EF24h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208EF24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208EF24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208EF24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208EF24);
		  /* 8208EF24h */ case    0:  		/* lhz R11, <#[R26]> */
		/* 8208EF24h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8208EF24h case    0:*/		return 0x8208EF28;
		  /* 8208EF28h */ case    1:  		/* addi R26, R26, 2 */
		/* 8208EF28h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x2);
		/* 8208EF28h case    1:*/		return 0x8208EF2C;
		  /* 8208EF2Ch */ case    2:  		/* mr R10, R11 */
		/* 8208EF2Ch case    2:*/		regs.R10 = regs.R11;
		/* 8208EF2Ch case    2:*/		return 0x8208EF30;
		  /* 8208EF30h */ case    3:  		/* cmplwi CR6, R11, 10 */
		/* 8208EF30h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000A);
		/* 8208EF30h case    3:*/		return 0x8208EF34;
		  /* 8208EF34h */ case    4:  		/* bc 4, CR6_EQ, 36 */
		/* 8208EF34h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8208EF58;  }
		/* 8208EF34h case    4:*/		return 0x8208EF38;
		  /* 8208EF38h */ case    5:  		/* lfs FR0, <#[R31 + 92]> */
		/* 8208EF38h case    5:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208EF38h case    5:*/		return 0x8208EF3C;
		  /* 8208EF3Ch */ case    6:  		/* li R9, 1 */
		/* 8208EF3Ch case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8208EF3Ch case    6:*/		return 0x8208EF40;
		  /* 8208EF40h */ case    7:  		/* lfs FR13, <#[R31 + 48]> */
		/* 8208EF40h case    7:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R31 + 0x00000030) );
		/* 8208EF40h case    7:*/		return 0x8208EF44;
		  /* 8208EF44h */ case    8:  		/* lfs FR12, <#[R31 + 40]> */
		/* 8208EF44h case    8:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R31 + 0x00000028) );
		/* 8208EF44h case    8:*/		return 0x8208EF48;
		  /* 8208EF48h */ case    9:  		/* fmadds FR0, FR13, FR12, FR0 */
		/* 8208EF48h case    9:*/		cpu::op::fmadds<0>(regs,&regs.FR0,regs.FR13,regs.FR12,regs.FR0);
		/* 8208EF48h case    9:*/		return 0x8208EF4C;
		  /* 8208EF4Ch */ case   10:  		/* stfs FR31, <#[R31 + 88]> */
		/* 8208EF4Ch case   10:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R31 + 0x00000058) );
		/* 8208EF4Ch case   10:*/		return 0x8208EF50;
		  /* 8208EF50h */ case   11:  		/* stfs FR0, <#[R31 + 92]> */
		/* 8208EF50h case   11:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208EF50h case   11:*/		return 0x8208EF54;
		  /* 8208EF54h */ case   12:  		/* b 656 */
		/* 8208EF54h case   12:*/		return 0x8208F1E4;
		/* 8208EF54h case   12:*/		return 0x8208EF58;
	}
	return 0x8208EF58;
} // Block from 8208EF24h-8208EF58h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8208EF58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208EF58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208EF58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208EF58);
		  /* 8208EF58h */ case    0:  		/* cmplwi CR6, R10, 13 */
		/* 8208EF58h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000000D);
		/* 8208EF58h case    0:*/		return 0x8208EF5C;
		  /* 8208EF5Ch */ case    1:  		/* bc 12, CR6_EQ, 648 */
		/* 8208EF5Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8208F1E4;  }
		/* 8208EF5Ch case    1:*/		return 0x8208EF60;
	}
	return 0x8208EF60;
} // Block from 8208EF58h-8208EF60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208EF60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208EF60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208EF60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208EF60);
		  /* 8208EF60h */ case    0:  		/* lwz R10, <#[R31 + 96]> */
		/* 8208EF60h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000060) );
		/* 8208EF60h case    0:*/		return 0x8208EF64;
		  /* 8208EF64h */ case    1:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8208EF64h case    1:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8208EF64h case    1:*/		return 0x8208EF68;
		  /* 8208EF68h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 8208EF68h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8208EF68h case    2:*/		return 0x8208EF6C;
		  /* 8208EF6Ch */ case    3:  		/* bc 12, CR6_GT, 20 */
		/* 8208EF6Ch case    3:*/		if ( regs.CR[6].gt ) { return 0x8208EF80;  }
		/* 8208EF6Ch case    3:*/		return 0x8208EF70;
		  /* 8208EF70h */ case    4:  		/* lwz R10, <#[R31 + 100]> */
		/* 8208EF70h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000064) );
		/* 8208EF70h case    4:*/		return 0x8208EF74;
		  /* 8208EF74h */ case    5:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 8208EF74h case    5:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 8208EF74h case    5:*/		return 0x8208EF78;
		  /* 8208EF78h */ case    6:  		/* lhzx R10, <#[R11 + R10]> */
		/* 8208EF78h case    6:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8208EF78h case    6:*/		return 0x8208EF7C;
		  /* 8208EF7Ch */ case    7:  		/* b 8 */
		/* 8208EF7Ch case    7:*/		return 0x8208EF84;
		/* 8208EF7Ch case    7:*/		return 0x8208EF80;
	}
	return 0x8208EF80;
} // Block from 8208EF60h-8208EF80h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8208EF80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208EF80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208EF80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208EF80);
		  /* 8208EF80h */ case    0:  		/* li R10, 0 */
		/* 8208EF80h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8208EF80h case    0:*/		return 0x8208EF84;
	}
	return 0x8208EF84;
} // Block from 8208EF80h-8208EF84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208EF84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208EF84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208EF84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208EF84);
		  /* 8208EF84h */ case    0:  		/* lwz R11, <#[R31 + 108]> */
		/* 8208EF84h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 8208EF84h case    0:*/		return 0x8208EF88;
		  /* 8208EF88h */ case    1:  		/* rlwinm R10, R10, 4, 0, 27 */
		/* 8208EF88h case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R10);
		/* 8208EF88h case    1:*/		return 0x8208EF8C;
		  /* 8208EF8Ch */ case    2:  		/* lfs FR0, <#[R31 + 48]> */
		/* 8208EF8Ch case    2:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000030) );
		/* 8208EF8Ch case    2:*/		return 0x8208EF90;
		  /* 8208EF90h */ case    3:  		/* cmplwi CR6, R29, 0 */
		/* 8208EF90h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8208EF90h case    3:*/		return 0x8208EF94;
		  /* 8208EF94h */ case    4:  		/* add R11, R10, R11 */
		/* 8208EF94h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208EF94h case    4:*/		return 0x8208EF98;
		  /* 8208EF98h */ case    5:  		/* lfs FR12, <#[R31 + 28]> */
		/* 8208EF98h case    5:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R31 + 0x0000001C) );
		/* 8208EF98h case    5:*/		return 0x8208EF9C;
		  /* 8208EF9Ch */ case    6:  		/* fmuls FR12, FR0, FR12 */
		/* 8208EF9Ch case    6:*/		cpu::op::fmuls<0>(regs,&regs.FR12,regs.FR0,regs.FR12);
		/* 8208EF9Ch case    6:*/		return 0x8208EFA0;
		  /* 8208EFA0h */ case    7:  		/* lfs FR13, <#[R31 + 44]> */
		/* 8208EFA0h case    7:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R31 + 0x0000002C) );
		/* 8208EFA0h case    7:*/		return 0x8208EFA4;
		  /* 8208EFA4h */ case    8:  		/* lha R7, <#[R11 + 8]> */
		/* 8208EFA4h case    8:*/		cpu::mem::load16a( regs, &regs.R7, (uint32)(regs.R11 + 0x00000008) );
		/* 8208EFA4h case    8:*/		return 0x8208EFA8;
		  /* 8208EFA8h */ case    9:  		/* lha R8, <#[R11 + 10]> */
		/* 8208EFA8h case    9:*/		cpu::mem::load16a( regs, &regs.R8, (uint32)(regs.R11 + 0x0000000A) );
		/* 8208EFA8h case    9:*/		return 0x8208EFAC;
		  /* 8208EFACh */ case   10:  		/* std R8, <#[R1 + 104]> */
		/* 8208EFACh case   10:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000068) );
		/* 8208EFACh case   10:*/		return 0x8208EFB0;
		  /* 8208EFB0h */ case   11:  		/* lfd FR11, <#[R1 + 104]> */
		/* 8208EFB0h case   11:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R1 + 0x00000068) );
		/* 8208EFB0h case   11:*/		return 0x8208EFB4;
		  /* 8208EFB4h */ case   12:  		/* std R7, <#[R1 + 112]> */
		/* 8208EFB4h case   12:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000070) );
		/* 8208EFB4h case   12:*/		return 0x8208EFB8;
		  /* 8208EFB8h */ case   13:  		/* lfd FR10, <#[R1 + 112]> */
		/* 8208EFB8h case   13:*/		cpu::mem::load64f( regs, &regs.FR10, (uint32)(regs.R1 + 0x00000070) );
		/* 8208EFB8h case   13:*/		return 0x8208EFBC;
		  /* 8208EFBCh */ case   14:  		/* lha R10, <#[R11 + 12]> */
		/* 8208EFBCh case   14:*/		cpu::mem::load16a( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8208EFBCh case   14:*/		return 0x8208EFC0;
		  /* 8208EFC0h */ case   15:  		/* std R10, <#[R1 + 96]> */
		/* 8208EFC0h case   15:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 8208EFC0h case   15:*/		return 0x8208EFC4;
		  /* 8208EFC4h */ case   16:  		/* lfd FR0, <#[R1 + 96]> */
		/* 8208EFC4h case   16:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000060) );
		/* 8208EFC4h case   16:*/		return 0x8208EFC8;
		  /* 8208EFC8h */ case   17:  		/* fcfid FR0, FR0 */
		/* 8208EFC8h case   17:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 8208EFC8h case   17:*/		return 0x8208EFCC;
		  /* 8208EFCCh */ case   18:  		/* mr R10, R7 */
		/* 8208EFCCh case   18:*/		regs.R10 = regs.R7;
		/* 8208EFCCh case   18:*/		return 0x8208EFD0;
		  /* 8208EFD0h */ case   19:  		/* fcfid FR10, FR10 */
		/* 8208EFD0h case   19:*/		cpu::op::fcfid<0>(regs,&regs.FR10,regs.FR10);
		/* 8208EFD0h case   19:*/		return 0x8208EFD4;
		  /* 8208EFD4h */ case   20:  		/* fcfid FR11, FR11 */
		/* 8208EFD4h case   20:*/		cpu::op::fcfid<0>(regs,&regs.FR11,regs.FR11);
		/* 8208EFD4h case   20:*/		return 0x8208EFD8;
	}
	return 0x8208EFD8;
} // Block from 8208EF84h-8208EFD8h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8208EFD8h
// Function 'RtlpInsertFreeBlock'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208EFD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208EFD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208EFD8);
		  /* 8208EFD8h */ case    0:  		/* frsp FR8, FR0 */
		/* 8208EFD8h case    0:*/		cpu::op::frsp<0>(regs,&regs.FR8,regs.FR0);
		/* 8208EFD8h case    0:*/		return 0x8208EFDC;
		  /* 8208EFDCh */ case    1:  		/* frsp FR10, FR10 */
		/* 8208EFDCh case    1:*/		cpu::op::frsp<0>(regs,&regs.FR10,regs.FR10);
		/* 8208EFDCh case    1:*/		return 0x8208EFE0;
		  /* 8208EFE0h */ case    2:  		/* frsp FR11, FR11 */
		/* 8208EFE0h case    2:*/		cpu::op::frsp<0>(regs,&regs.FR11,regs.FR11);
		/* 8208EFE0h case    2:*/		return 0x8208EFE4;
		  /* 8208EFE4h */ case    3:  		/* fmuls FR5, FR8, FR13 */
		/* 8208EFE4h case    3:*/		cpu::op::fmuls<0>(regs,&regs.FR5,regs.FR8,regs.FR13);
		/* 8208EFE4h case    3:*/		return 0x8208EFE8;
		  /* 8208EFE8h */ case    4:  		/* fmuls FR0, FR10, FR13 */
		/* 8208EFE8h case    4:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR10,regs.FR13);
		/* 8208EFE8h case    4:*/		return 0x8208EFEC;
		  /* 8208EFECh */ case    5:  		/* fmuls FR9, FR11, FR13 */
		/* 8208EFECh case    5:*/		cpu::op::fmuls<0>(regs,&regs.FR9,regs.FR11,regs.FR13);
		/* 8208EFECh case    5:*/		return 0x8208EFF0;
		  /* 8208EFF0h */ case    6:  		/* bc 4, CR6_EQ, 56 */
		/* 8208EFF0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8208F028;  }
		/* 8208EFF0h case    6:*/		return 0x8208EFF4;
		  /* 8208EFF4h */ case    7:  		/* cmplwi CR6, R25, 0 */
		/* 8208EFF4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 8208EFF4h case    7:*/		return 0x8208EFF8;
		  /* 8208EFF8h */ case    8:  		/* bc 12, CR6_EQ, 48 */
		/* 8208EFF8h case    8:*/		if ( regs.CR[6].eq ) { return 0x8208F028;  }
		/* 8208EFF8h case    8:*/		return 0x8208EFFC;
		  /* 8208EFFCh */ case    9:  		/* lfs FR13, <#[R31 + 52]> */
		/* 8208EFFCh case    9:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R31 + 0x00000034) );
		/* 8208EFFCh case    9:*/		return 0x8208F000;
		  /* 8208F000h */ case   10:  		/* fadds FR11, FR31, FR23 */
		/* 8208F000h case   10:*/		cpu::op::fadds<0>(regs,&regs.FR11,regs.FR31,regs.FR23);
		/* 8208F000h case   10:*/		return 0x8208F004;
		  /* 8208F004h */ case   11:  		/* lfs FR10, <#[R31 + 88]> */
		/* 8208F004h case   11:*/		cpu::mem::load32f( regs, &regs.FR10, (uint32)(regs.R31 + 0x00000058) );
		/* 8208F004h case   11:*/		return 0x8208F008;
		  /* 8208F008h */ case   12:  		/* fadds FR13, FR13, FR10 */
		/* 8208F008h case   12:*/		cpu::op::fadds<0>(regs,&regs.FR13,regs.FR13,regs.FR10);
		/* 8208F008h case   12:*/		return 0x8208F00C;
		  /* 8208F00Ch */ case   13:  		/* fadds FR13, FR13, FR9 */
		/* 8208F00Ch case   13:*/		cpu::op::fadds<0>(regs,&regs.FR13,regs.FR13,regs.FR9);
		/* 8208F00Ch case   13:*/		return 0x8208F010;
		  /* 8208F010h */ case   14:  		/* fadds FR13, FR13, FR0 */
		/* 8208F010h case   14:*/		cpu::op::fadds<0>(regs,&regs.FR13,regs.FR13,regs.FR0);
		/* 8208F010h case   14:*/		return 0x8208F014;
		  /* 8208F014h */ case   15:  		/* fadds FR13, FR13, FR25 */
		/* 8208F014h case   15:*/		cpu::op::fadds<0>(regs,&regs.FR13,regs.FR13,regs.FR25);
		/* 8208F014h case   15:*/		return 0x8208F018;
		  /* 8208F018h */ case   16:  		/* fcmpu CR6, FR13, FR11 */
		/* 8208F018h case   16:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR11);
		/* 8208F018h case   16:*/		return 0x8208F01C;
		  /* 8208F01Ch */ case   17:  		/* bc 4, CR6_GT, 12 */
		/* 8208F01Ch case   17:*/		if ( !regs.CR[6].gt ) { return 0x8208F028;  }
		/* 8208F01Ch case   17:*/		return 0x8208F020;
		  /* 8208F020h */ case   18:  		/* li R29, 3 */
		/* 8208F020h case   18:*/		cpu::op::li<0>(regs,&regs.R29,0x3);
		/* 8208F020h case   18:*/		return 0x8208F024;
		  /* 8208F024h */ case   19:  		/* b 448 */
		/* 8208F024h case   19:*/		return 0x8208F1E4;
		/* 8208F024h case   19:*/		return 0x8208F028;
	}
	return 0x8208F028;
} // Block from 8208EFD8h-8208F028h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8208F028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F028);
		  /* 8208F028h */ case    0:  		/* lfs FR13, <#[R31 + 88]> */
		/* 8208F028h case    0:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R31 + 0x00000058) );
		/* 8208F028h case    0:*/		return 0x8208F02C;
		  /* 8208F02Ch */ case    1:  		/* lwz R10, <#[R31 + 188]> */
		/* 8208F02Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000BC) );
		/* 8208F02Ch case    1:*/		return 0x8208F030;
		  /* 8208F030h */ case    2:  		/* fadds FR13, FR13, FR0 */
		/* 8208F030h case    2:*/		cpu::op::fadds<0>(regs,&regs.FR13,regs.FR13,regs.FR0);
		/* 8208F030h case    2:*/		return 0x8208F034;
		  /* 8208F034h */ case    3:  		/* lfs FR0, <#[R31 + 92]> */
		/* 8208F034h case    3:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208F034h case    3:*/		return 0x8208F038;
		  /* 8208F038h */ case    4:  		/* lfs FR8, <#[R31 + 52]> */
		/* 8208F038h case    4:*/		cpu::mem::load32f( regs, &regs.FR8, (uint32)(regs.R31 + 0x00000034) );
		/* 8208F038h case    4:*/		return 0x8208F03C;
		  /* 8208F03Ch */ case    5:  		/* fadds FR11, FR0, FR12 */
		/* 8208F03Ch case    5:*/		cpu::op::fadds<0>(regs,&regs.FR11,regs.FR0,regs.FR12);
		/* 8208F03Ch case    5:*/		return 0x8208F040;
		  /* 8208F040h */ case    6:  		/* stfs FR13, <#[R31 + 88]> */
		/* 8208F040h case    6:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R31 + 0x00000058) );
		/* 8208F040h case    6:*/		return 0x8208F044;
		  /* 8208F044h */ case    7:  		/* fmr FR10, FR0 */
		/* 8208F044h case    7:*/		cpu::op::fmr<0>(regs,&regs.FR10,regs.FR0);
		/* 8208F044h case    7:*/		return 0x8208F048;
		  /* 8208F048h */ case    8:  		/* cmpwi CR6, R10, 0 */
		/* 8208F048h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8208F048h case    8:*/		return 0x8208F04C;
		  /* 8208F04Ch */ case    9:  		/* fadds FR12, FR8, FR13 */
		/* 8208F04Ch case    9:*/		cpu::op::fadds<0>(regs,&regs.FR12,regs.FR8,regs.FR13);
		/* 8208F04Ch case    9:*/		return 0x8208F050;
		  /* 8208F050h */ case   10:  		/* fadds FR8, FR13, FR9 */
		/* 8208F050h case   10:*/		cpu::op::fadds<0>(regs,&regs.FR8,regs.FR13,regs.FR9);
		/* 8208F050h case   10:*/		return 0x8208F054;
		  /* 8208F054h */ case   11:  		/* fmr FR7, FR13 */
		/* 8208F054h case   11:*/		cpu::op::fmr<0>(regs,&regs.FR7,regs.FR13);
		/* 8208F054h case   11:*/		return 0x8208F058;
		  /* 8208F058h */ case   12:  		/* fmr FR6, FR11 */
		/* 8208F058h case   12:*/		cpu::op::fmr<0>(regs,&regs.FR6,regs.FR11);
		/* 8208F058h case   12:*/		return 0x8208F05C;
		  /* 8208F05Ch */ case   13:  		/* fadds FR9, FR12, FR9 */
		/* 8208F05Ch case   13:*/		cpu::op::fadds<0>(regs,&regs.FR9,regs.FR12,regs.FR9);
		/* 8208F05Ch case   13:*/		return 0x8208F060;
		  /* 8208F060h */ case   14:  		/* bc 12, CR6_EQ, 216 */
		/* 8208F060h case   14:*/		if ( regs.CR[6].eq ) { return 0x8208F138;  }
		/* 8208F060h case   14:*/		return 0x8208F064;
		  /* 8208F064h */ case   15:  		/* fsub FR12, FR12, FR31 */
		/* 8208F064h case   15:*/		cpu::op::fsub<0>(regs,&regs.FR12,regs.FR12,regs.FR31);
		/* 8208F064h case   15:*/		return 0x8208F068;
		  /* 8208F068h */ case   16:  		/* lfd FR3, <#[R31 + 64]> */
		/* 8208F068h case   16:*/		cpu::mem::load64f( regs, &regs.FR3, (uint32)(regs.R31 + 0x00000040) );
		/* 8208F068h case   16:*/		return 0x8208F06C;
		  /* 8208F06Ch */ case   17:  		/* fsub FR10, FR10, FR29 */
		/* 8208F06Ch case   17:*/		cpu::op::fsub<0>(regs,&regs.FR10,regs.FR10,regs.FR29);
		/* 8208F06Ch case   17:*/		return 0x8208F070;
		  /* 8208F070h */ case   18:  		/* lfd FR1, <#[R31 + 56]> */
		/* 8208F070h case   18:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R31 + 0x00000038) );
		/* 8208F070h case   18:*/		return 0x8208F074;
		  /* 8208F074h */ case   19:  		/* fsub FR11, FR11, FR29 */
		/* 8208F074h case   19:*/		cpu::op::fsub<0>(regs,&regs.FR11,regs.FR11,regs.FR29);
		/* 8208F074h case   19:*/		return 0x8208F078;
		  /* 8208F078h */ case   20:  		/* stfd FR13, <#[R1 + 88]> */
		/* 8208F078h case   20:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 8208F078h case   20:*/		return 0x8208F07C;
		  /* 8208F07Ch */ case   21:  		/* fsub FR6, FR6, FR29 */
		/* 8208F07Ch case   21:*/		cpu::op::fsub<0>(regs,&regs.FR6,regs.FR6,regs.FR29);
		/* 8208F07Ch case   21:*/		return 0x8208F080;
		  /* 8208F080h */ case   22:  		/* lfs FR23, <#[R1 + 404]> */
		/* 8208F080h case   22:*/		cpu::mem::load32f( regs, &regs.FR23, (uint32)(regs.R1 + 0x00000194) );
		/* 8208F080h case   22:*/		return 0x8208F084;
		  /* 8208F084h */ case   23:  		/* fsub FR0, FR0, FR29 */
		/* 8208F084h case   23:*/		cpu::op::fsub<0>(regs,&regs.FR0,regs.FR0,regs.FR29);
		/* 8208F084h case   23:*/		return 0x8208F088;
		  /* 8208F088h */ case   24:  		/* fsub FR9, FR9, FR31 */
		/* 8208F088h case   24:*/		cpu::op::fsub<0>(regs,&regs.FR9,regs.FR9,regs.FR31);
		/* 8208F088h case   24:*/		return 0x8208F08C;
		  /* 8208F08Ch */ case   25:  		/* fsub FR8, FR8, FR31 */
		/* 8208F08Ch case   25:*/		cpu::op::fsub<0>(regs,&regs.FR8,regs.FR8,regs.FR31);
		/* 8208F08Ch case   25:*/		return 0x8208F090;
		  /* 8208F090h */ case   26:  		/* fsub FR7, FR7, FR31 */
		/* 8208F090h case   26:*/		cpu::op::fsub<0>(regs,&regs.FR7,regs.FR7,regs.FR31);
		/* 8208F090h case   26:*/		return 0x8208F094;
		  /* 8208F094h */ case   27:  		/* fmr FR4, FR31 */
		/* 8208F094h case   27:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR31);
		/* 8208F094h case   27:*/		return 0x8208F098;
		  /* 8208F098h */ case   28:  		/* fmr FR2, FR29 */
		/* 8208F098h case   28:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR29);
		/* 8208F098h case   28:*/		return 0x8208F09C;
		  /* 8208F09Ch */ case   29:  		/* fmul FR17, FR3, FR12 */
		/* 8208F09Ch case   29:*/		cpu::op::fmul<0>(regs,&regs.FR17,regs.FR3,regs.FR12);
		/* 8208F09Ch case   29:*/		return 0x8208F0A0;
		  /* 8208F0A0h */ case   30:  		/* fmul FR15, FR1, FR10 */
		/* 8208F0A0h case   30:*/		cpu::op::fmul<0>(regs,&regs.FR15,regs.FR1,regs.FR10);
		/* 8208F0A0h case   30:*/		return 0x8208F0A4;
		  /* 8208F0A4h */ case   31:  		/* fmul FR14, FR1, FR11 */
		/* 8208F0A4h case   31:*/		cpu::op::fmul<0>(regs,&regs.FR14,regs.FR1,regs.FR11);
		/* 8208F0A4h case   31:*/		return 0x8208F0A8;
		  /* 8208F0A8h */ case   32:  		/* fmul FR10, FR3, FR10 */
		/* 8208F0A8h case   32:*/		cpu::op::fmul<0>(regs,&regs.FR10,regs.FR3,regs.FR10);
		/* 8208F0A8h case   32:*/		return 0x8208F0AC;
		  /* 8208F0ACh */ case   33:  		/* fmul FR11, FR3, FR11 */
		/* 8208F0ACh case   33:*/		cpu::op::fmul<0>(regs,&regs.FR11,regs.FR3,regs.FR11);
		/* 8208F0ACh case   33:*/		return 0x8208F0B0;
		  /* 8208F0B0h */ case   34:  		/* fmul FR13, FR3, FR6 */
		/* 8208F0B0h case   34:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR3,regs.FR6);
		/* 8208F0B0h case   34:*/		return 0x8208F0B4;
		  /* 8208F0B4h */ case   35:  		/* fmul FR16, FR3, FR0 */
		/* 8208F0B4h case   35:*/		cpu::op::fmul<0>(regs,&regs.FR16,regs.FR3,regs.FR0);
		/* 8208F0B4h case   35:*/		return 0x8208F0B8;
		  /* 8208F0B8h */ case   36:  		/* fmul FR6, FR1, FR6 */
		/* 8208F0B8h case   36:*/		cpu::op::fmul<0>(regs,&regs.FR6,regs.FR1,regs.FR6);
		/* 8208F0B8h case   36:*/		return 0x8208F0BC;
		  /* 8208F0BCh */ case   37:  		/* fmr FR30, FR29 */
		/* 8208F0BCh case   37:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR29);
		/* 8208F0BCh case   37:*/		return 0x8208F0C0;
		  /* 8208F0C0h */ case   38:  		/* fmr FR22, FR29 */
		/* 8208F0C0h case   38:*/		cpu::op::fmr<0>(regs,&regs.FR22,regs.FR29);
		/* 8208F0C0h case   38:*/		return 0x8208F0C4;
		  /* 8208F0C4h */ case   39:  		/* fmadd FR0, FR1, FR0, FR17 */
		/* 8208F0C4h case   39:*/		cpu::op::fmadd<0>(regs,&regs.FR0,regs.FR1,regs.FR0,regs.FR17);
		/* 8208F0C4h case   39:*/		return 0x8208F0C8;
		  /* 8208F0C8h */ case   40:  		/* fmadd FR17, FR3, FR9, FR15 */
		/* 8208F0C8h case   40:*/		cpu::op::fmadd<0>(regs,&regs.FR17,regs.FR3,regs.FR9,regs.FR15);
		/* 8208F0C8h case   40:*/		return 0x8208F0CC;
		  /* 8208F0CCh */ case   41:  		/* fmr FR21, FR29 */
		/* 8208F0CCh case   41:*/		cpu::op::fmr<0>(regs,&regs.FR21,regs.FR29);
		/* 8208F0CCh case   41:*/		return 0x8208F0D0;
		  /* 8208F0D0h */ case   42:  		/* fmsub FR10, FR1, FR9, FR10 */
		/* 8208F0D0h case   42:*/		cpu::op::fmsub<0>(regs,&regs.FR10,regs.FR1,regs.FR9,regs.FR10);
		/* 8208F0D0h case   42:*/		return 0x8208F0D4;
		  /* 8208F0D4h */ case   43:  		/* fmsub FR11, FR1, FR8, FR11 */
		/* 8208F0D4h case   43:*/		cpu::op::fmsub<0>(regs,&regs.FR11,regs.FR1,regs.FR8,regs.FR11);
		/* 8208F0D4h case   43:*/		return 0x8208F0D8;
		  /* 8208F0D8h */ case   44:  		/* fmadd FR9, FR3, FR8, FR14 */
		/* 8208F0D8h case   44:*/		cpu::op::fmadd<0>(regs,&regs.FR9,regs.FR3,regs.FR8,regs.FR14);
		/* 8208F0D8h case   44:*/		return 0x8208F0DC;
		  /* 8208F0DCh */ case   45:  		/* fmsub FR8, FR1, FR7, FR13 */
		/* 8208F0DCh case   45:*/		cpu::op::fmsub<0>(regs,&regs.FR8,regs.FR1,regs.FR7,regs.FR13);
		/* 8208F0DCh case   45:*/		return 0x8208F0E0;
		  /* 8208F0E0h */ case   46:  		/* lfd FR13, <#[R1 + 88]> */
		/* 8208F0E0h case   46:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 8208F0E0h case   46:*/		return 0x8208F0E4;
		  /* 8208F0E4h */ case   47:  		/* fmadd FR7, FR3, FR7, FR6 */
		/* 8208F0E4h case   47:*/		cpu::op::fmadd<0>(regs,&regs.FR7,regs.FR3,regs.FR7,regs.FR6);
		/* 8208F0E4h case   47:*/		return 0x8208F0E8;
		  /* 8208F0E8h */ case   48:  		/* fmsub FR12, FR1, FR12, FR16 */
		/* 8208F0E8h case   48:*/		cpu::op::fmsub<0>(regs,&regs.FR12,regs.FR1,regs.FR12,regs.FR16);
		/* 8208F0E8h case   48:*/		return 0x8208F0EC;
		  /* 8208F0ECh */ case   49:  		/* fmr FR20, FR31 */
		/* 8208F0ECh case   49:*/		cpu::op::fmr<0>(regs,&regs.FR20,regs.FR31);
		/* 8208F0ECh case   49:*/		return 0x8208F0F0;
		  /* 8208F0F0h */ case   50:  		/* fadd FR0, FR0, FR29 */
		/* 8208F0F0h case   50:*/		cpu::op::fadd<0>(regs,&regs.FR0,regs.FR0,regs.FR29);
		/* 8208F0F0h case   50:*/		return 0x8208F0F4;
		  /* 8208F0F4h */ case   51:  		/* fadd FR6, FR17, FR29 */
		/* 8208F0F4h case   51:*/		cpu::op::fadd<0>(regs,&regs.FR6,regs.FR17,regs.FR29);
		/* 8208F0F4h case   51:*/		return 0x8208F0F8;
		  /* 8208F0F8h */ case   52:  		/* fmr FR19, FR31 */
		/* 8208F0F8h case   52:*/		cpu::op::fmr<0>(regs,&regs.FR19,regs.FR31);
		/* 8208F0F8h case   52:*/		return 0x8208F0FC;
		  /* 8208F0FCh */ case   53:  		/* fadd FR4, FR10, FR31 */
		/* 8208F0FCh case   53:*/		cpu::op::fadd<0>(regs,&regs.FR4,regs.FR10,regs.FR31);
		/* 8208F0FCh case   53:*/		return 0x8208F100;
		  /* 8208F100h */ case   54:  		/* fadd FR2, FR11, FR31 */
		/* 8208F100h case   54:*/		cpu::op::fadd<0>(regs,&regs.FR2,regs.FR11,regs.FR31);
		/* 8208F100h case   54:*/		return 0x8208F104;
		  /* 8208F104h */ case   55:  		/* fadd FR3, FR9, FR29 */
		/* 8208F104h case   55:*/		cpu::op::fadd<0>(regs,&regs.FR3,regs.FR9,regs.FR29);
		/* 8208F104h case   55:*/		return 0x8208F108;
		  /* 8208F108h */ case   56:  		/* fadd FR1, FR8, FR31 */
		/* 8208F108h case   56:*/		cpu::op::fadd<0>(regs,&regs.FR1,regs.FR8,regs.FR31);
		/* 8208F108h case   56:*/		return 0x8208F10C;
		  /* 8208F10Ch */ case   57:  		/* fadd FR30, FR7, FR29 */
		/* 8208F10Ch case   57:*/		cpu::op::fadd<0>(regs,&regs.FR30,regs.FR7,regs.FR29);
		/* 8208F10Ch case   57:*/		return 0x8208F110;
	}
	return 0x8208F110;
} // Block from 8208F028h-8208F110h (58 instructions)

//////////////////////////////////////////////////////
// Block at 8208F110h
// Function 'RtlpGrowBlockInPlace'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F110);
		  /* 8208F110h */ case    0:  		/* fadd FR12, FR12, FR31 */
		/* 8208F110h case    0:*/		cpu::op::fadd<0>(regs,&regs.FR12,regs.FR12,regs.FR31);
		/* 8208F110h case    0:*/		return 0x8208F114;
		  /* 8208F114h */ case    1:  		/* fmr FR18, FR31 */
		/* 8208F114h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR18,regs.FR31);
		/* 8208F114h case    1:*/		return 0x8208F118;
		  /* 8208F118h */ case    2:  		/* frsp FR0, FR0 */
		/* 8208F118h case    2:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 8208F118h case    2:*/		return 0x8208F11C;
		  /* 8208F11Ch */ case    3:  		/* frsp FR10, FR6 */
		/* 8208F11Ch case    3:*/		cpu::op::frsp<0>(regs,&regs.FR10,regs.FR6);
		/* 8208F11Ch case    3:*/		return 0x8208F120;
		  /* 8208F120h */ case    4:  		/* frsp FR9, FR4 */
		/* 8208F120h case    4:*/		cpu::op::frsp<0>(regs,&regs.FR9,regs.FR4);
		/* 8208F120h case    4:*/		return 0x8208F124;
		  /* 8208F124h */ case    5:  		/* frsp FR8, FR2 */
		/* 8208F124h case    5:*/		cpu::op::frsp<0>(regs,&regs.FR8,regs.FR2);
		/* 8208F124h case    5:*/		return 0x8208F128;
		  /* 8208F128h */ case    6:  		/* frsp FR11, FR3 */
		/* 8208F128h case    6:*/		cpu::op::frsp<0>(regs,&regs.FR11,regs.FR3);
		/* 8208F128h case    6:*/		return 0x8208F12C;
		  /* 8208F12Ch */ case    7:  		/* frsp FR7, FR1 */
		/* 8208F12Ch case    7:*/		cpu::op::frsp<0>(regs,&regs.FR7,regs.FR1);
		/* 8208F12Ch case    7:*/		return 0x8208F130;
		  /* 8208F130h */ case    8:  		/* frsp FR6, FR30 */
		/* 8208F130h case    8:*/		cpu::op::frsp<0>(regs,&regs.FR6,regs.FR30);
		/* 8208F130h case    8:*/		return 0x8208F134;
		  /* 8208F134h */ case    9:  		/* frsp FR12, FR12 */
		/* 8208F134h case    9:*/		cpu::op::frsp<0>(regs,&regs.FR12,regs.FR12);
		/* 8208F134h case    9:*/		return 0x8208F138;
	}
	return 0x8208F138;
} // Block from 8208F110h-8208F138h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8208F138h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F138);
		  /* 8208F138h */ case    0:  		/* fadds FR13, FR13, FR5 */
		/* 8208F138h case    0:*/		cpu::op::fadds<0>(regs,&regs.FR13,regs.FR13,regs.FR5);
		/* 8208F138h case    0:*/		return 0x8208F13C;
		  /* 8208F13Ch */ case    1:  		/* stfs FR13, <#[R31 + 88]> */
		/* 8208F13Ch case    1:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R31 + 0x00000058) );
		/* 8208F13Ch case    1:*/		return 0x8208F140;
		  /* 8208F140h */ case    2:  		/* lhz R8, <#[R11 + 14]> */
		/* 8208F140h case    2:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000000E) );
		/* 8208F140h case    2:*/		return 0x8208F144;
		  /* 8208F144h */ case    3:  		/* rlwinm R4, R8, 0, 20, 23 */
		/* 8208F144h case    3:*/		cpu::op::rlwinm<0,0,20,23>(regs,&regs.R4,regs.R8);
		/* 8208F144h case    3:*/		return 0x8208F148;
		  /* 8208F148h */ case    4:  		/* rlwinm R6, R8, 4, 12, 15 */
		/* 8208F148h case    4:*/		cpu::op::rlwinm<0,4,12,15>(regs,&regs.R6,regs.R8);
		/* 8208F148h case    4:*/		return 0x8208F14C;
		  /* 8208F14Ch */ case    5:  		/* lhz R7, <#[R11]> */
		/* 8208F14Ch case    5:*/		cpu::mem::load16z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8208F14Ch case    5:*/		return 0x8208F150;
		  /* 8208F150h */ case    6:  		/* rlwinm R3, R8, 0, 24, 27 */
		/* 8208F150h case    6:*/		cpu::op::rlwinm<0,0,24,27>(regs,&regs.R3,regs.R8);
		/* 8208F150h case    6:*/		return 0x8208F154;
		  /* 8208F154h */ case    7:  		/* lhz R5, <#[R11 + 2]> */
		/* 8208F154h case    7:*/		cpu::mem::load16z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000002) );
		/* 8208F154h case    7:*/		return 0x8208F158;
		  /* 8208F158h */ case    8:  		/* or R6, R6, R4 */
		/* 8208F158h case    8:*/		cpu::op::or<0>(regs,&regs.R6,regs.R6,regs.R4);
		/* 8208F158h case    8:*/		return 0x8208F15C;
		  /* 8208F15Ch */ case    9:  		/* lhz R10, <#[R11 + 6]> */
		/* 8208F15Ch case    9:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000006) );
		/* 8208F15Ch case    9:*/		return 0x8208F160;
		  /* 8208F160h */ case   10:  		/* rlwinm R7, R7, 16, 0, 31 */
		/* 8208F160h case   10:*/		cpu::op::rlwinm<0,16,0,31>(regs,&regs.R7,regs.R7);
		/* 8208F160h case   10:*/		return 0x8208F164;
		  /* 8208F164h */ case   11:  		/* lhz R11, <#[R11 + 4]> */
		/* 8208F164h case   11:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8208F164h case   11:*/		return 0x8208F168;
		  /* 8208F168h */ case   12:  		/* rlwinm R6, R6, 4, 0, 27 */
		/* 8208F168h case   12:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R6,regs.R6);
		/* 8208F168h case   12:*/		return 0x8208F16C;
		  /* 8208F16Ch */ case   13:  		/* stfs FR12, <#[R30]> */
		/* 8208F16Ch case   13:*/		cpu::mem::store32f( regs, regs.FR12, (uint32)(regs.R30 + 0x00000000) );
		/* 8208F16Ch case   13:*/		return 0x8208F170;
		  /* 8208F170h */ case   14:  		/* or R4, R5, R7 */
		/* 8208F170h case   14:*/		cpu::op::or<0>(regs,&regs.R4,regs.R5,regs.R7);
		/* 8208F170h case   14:*/		return 0x8208F174;
		  /* 8208F174h */ case   15:  		/* stfs FR0, <#[R30 + 4]> */
		/* 8208F174h case   15:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R30 + 0x00000004) );
		/* 8208F174h case   15:*/		return 0x8208F178;
		  /* 8208F178h */ case   16:  		/* or R6, R6, R3 */
		/* 8208F178h case   16:*/		cpu::op::or<0>(regs,&regs.R6,regs.R6,regs.R3);
		/* 8208F178h case   16:*/		return 0x8208F17C;
		  /* 8208F17Ch */ case   17:  		/* rlwinm R11, R11, 16, 0, 31 */
		/* 8208F17Ch case   17:*/		cpu::op::rlwinm<0,16,0,31>(regs,&regs.R11,regs.R11);
		/* 8208F17Ch case   17:*/		return 0x8208F180;
		  /* 8208F180h */ case   18:  		/* stw R4, <#[R30 + 8]> */
		/* 8208F180h case   18:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R30 + 0x00000008) );
		/* 8208F180h case   18:*/		return 0x8208F184;
		  /* 8208F184h */ case   19:  		/* rlwimi R8, R6, 4, 0, 27 */
		/* 8208F184h case   19:*/		cpu::op::rlwimi<0,4,0,27>(regs,&regs.R8,regs.R6);
		/* 8208F184h case   19:*/		return 0x8208F188;
		  /* 8208F188h */ case   20:  		/* or R6, R5, R11 */
		/* 8208F188h case   20:*/		cpu::op::or<0>(regs,&regs.R6,regs.R5,regs.R11);
		/* 8208F188h case   20:*/		return 0x8208F18C;
		  /* 8208F18Ch */ case   21:  		/* mulli R8, R8, 17 */
		/* 8208F18Ch case   21:*/		cpu::op::mulli<0>(regs,&regs.R8,regs.R8,0x11);
		/* 8208F18Ch case   21:*/		return 0x8208F190;
		  /* 8208F190h */ case   22:  		/* stw R8, <#[R30 + 12]> */
		/* 8208F190h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x0000000C) );
		/* 8208F190h case   22:*/		return 0x8208F194;
		  /* 8208F194h */ case   23:  		/* stfs FR9, <#[R30 + 16]> */
		/* 8208F194h case   23:*/		cpu::mem::store32f( regs, regs.FR9, (uint32)(regs.R30 + 0x00000010) );
		/* 8208F194h case   23:*/		return 0x8208F198;
		  /* 8208F198h */ case   24:  		/* stfs FR10, <#[R30 + 20]> */
		/* 8208F198h case   24:*/		cpu::mem::store32f( regs, regs.FR10, (uint32)(regs.R30 + 0x00000014) );
		/* 8208F198h case   24:*/		return 0x8208F19C;
		  /* 8208F19Ch */ case   25:  		/* stw R6, <#[R30 + 24]> */
		/* 8208F19Ch case   25:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R30 + 0x00000018) );
		/* 8208F19Ch case   25:*/		return 0x8208F1A0;
		  /* 8208F1A0h */ case   26:  		/* stw R8, <#[R30 + 28]> */
		/* 8208F1A0h case   26:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x0000001C) );
		/* 8208F1A0h case   26:*/		return 0x8208F1A4;
		  /* 8208F1A4h */ case   27:  		/* stfs FR8, <#[R30 + 32]> */
		/* 8208F1A4h case   27:*/		cpu::mem::store32f( regs, regs.FR8, (uint32)(regs.R30 + 0x00000020) );
		/* 8208F1A4h case   27:*/		return 0x8208F1A8;
		  /* 8208F1A8h */ case   28:  		/* stfs FR11, <#[R30 + 36]> */
		/* 8208F1A8h case   28:*/		cpu::mem::store32f( regs, regs.FR11, (uint32)(regs.R30 + 0x00000024) );
		/* 8208F1A8h case   28:*/		return 0x8208F1AC;
		  /* 8208F1ACh */ case   29:  		/* or R11, R10, R11 */
		/* 8208F1ACh case   29:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208F1ACh case   29:*/		return 0x8208F1B0;
		  /* 8208F1B0h */ case   30:  		/* or R10, R10, R7 */
		/* 8208F1B0h case   30:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 8208F1B0h case   30:*/		return 0x8208F1B4;
		  /* 8208F1B4h */ case   31:  		/* stw R11, <#[R30 + 40]> */
		/* 8208F1B4h case   31:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 8208F1B4h case   31:*/		return 0x8208F1B8;
		  /* 8208F1B8h */ case   32:  		/* cmplwi CR6, R29, 0 */
		/* 8208F1B8h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8208F1B8h case   32:*/		return 0x8208F1BC;
		  /* 8208F1BCh */ case   33:  		/* stw R8, <#[R30 + 44]> */
		/* 8208F1BCh case   33:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x0000002C) );
		/* 8208F1BCh case   33:*/		return 0x8208F1C0;
		  /* 8208F1C0h */ case   34:  		/* stfs FR7, <#[R30 + 48]> */
		/* 8208F1C0h case   34:*/		cpu::mem::store32f( regs, regs.FR7, (uint32)(regs.R30 + 0x00000030) );
		/* 8208F1C0h case   34:*/		return 0x8208F1C4;
		  /* 8208F1C4h */ case   35:  		/* stfs FR6, <#[R30 + 52]> */
		/* 8208F1C4h case   35:*/		cpu::mem::store32f( regs, regs.FR6, (uint32)(regs.R30 + 0x00000034) );
		/* 8208F1C4h case   35:*/		return 0x8208F1C8;
		  /* 8208F1C8h */ case   36:  		/* stw R10, <#[R30 + 56]> */
		/* 8208F1C8h case   36:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000038) );
		/* 8208F1C8h case   36:*/		return 0x8208F1CC;
		  /* 8208F1CCh */ case   37:  		/* stw R8, <#[R30 + 60]> */
		/* 8208F1CCh case   37:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x0000003C) );
		/* 8208F1CCh case   37:*/		return 0x8208F1D0;
		  /* 8208F1D0h */ case   38:  		/* addi R30, R30, 64 */
		/* 8208F1D0h case   38:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x40);
		/* 8208F1D0h case   38:*/		return 0x8208F1D4;
		  /* 8208F1D4h */ case   39:  		/* bc 12, CR6_EQ, 12 */
		/* 8208F1D4h case   39:*/		if ( regs.CR[6].eq ) { return 0x8208F1E0;  }
		/* 8208F1D4h case   39:*/		return 0x8208F1D8;
		  /* 8208F1D8h */ case   40:  		/* addic. R29, R29, -1 */
		/* 8208F1D8h case   40:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 8208F1D8h case   40:*/		return 0x8208F1DC;
		  /* 8208F1DCh */ case   41:  		/* bc 12, CR0_EQ, 20 */
		/* 8208F1DCh case   41:*/		if ( regs.CR[0].eq ) { return 0x8208F1F0;  }
		/* 8208F1DCh case   41:*/		return 0x8208F1E0;
	}
	return 0x8208F1E0;
} // Block from 8208F138h-8208F1E0h (42 instructions)

//////////////////////////////////////////////////////
// Block at 8208F1E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F1E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F1E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F1E0);
		  /* 8208F1E0h */ case    0:  		/* addi R27, R27, -1 */
		/* 8208F1E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0xFFFFFFFF);
		/* 8208F1E0h case    0:*/		return 0x8208F1E4;
	}
	return 0x8208F1E4;
} // Block from 8208F1E0h-8208F1E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208F1E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F1E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F1E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F1E4);
		  /* 8208F1E4h */ case    0:  		/* lhz R11, <#[R26]> */
		/* 8208F1E4h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8208F1E4h case    0:*/		return 0x8208F1E8;
		  /* 8208F1E8h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 8208F1E8h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8208F1E8h case    1:*/		return 0x8208F1EC;
		  /* 8208F1ECh */ case    2:  		/* bc 4, CR0_EQ, -824 */
		/* 8208F1ECh case    2:*/		if ( !regs.CR[0].eq ) { return 0x8208EEB4;  }
		/* 8208F1ECh case    2:*/		return 0x8208F1F0;
	}
	return 0x8208F1F0;
} // Block from 8208F1E4h-8208F1F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208F1F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F1F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F1F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F1F0);
		  /* 8208F1F0h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 8208F1F0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8208F1F0h case    0:*/		return 0x8208F1F4;
		  /* 8208F1F4h */ case    1:  		/* bc 12, CR6_EQ, 80 */
		/* 8208F1F4h case    1:*/		if ( regs.CR[6].eq ) { return 0x8208F244;  }
		/* 8208F1F4h case    1:*/		return 0x8208F1F8;
		  /* 8208F1F8h */ case    2:  		/* addi R11, R30, -4 */
		/* 8208F1F8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFFC);
		/* 8208F1F8h case    2:*/		return 0x8208F1FC;
		  /* 8208F1FCh */ case    3:  		/* mtspr CTR, R27 */
		/* 8208F1FCh case    3:*/		regs.CTR = regs.R27;
		/* 8208F1FCh case    3:*/		return 0x8208F200;
		  /* 8208F200h */ case    4:  		/* stfs FR26, <#[R11 + 4]> */
		/* 8208F200h case    4:*/		cpu::mem::store32f( regs, regs.FR26, (uint32)(regs.R11 + 0x00000004) );
		/* 8208F200h case    4:*/		return 0x8208F204;
		  /* 8208F204h */ case    5:  		/* stfs FR26, <#[R11 + 8]> */
		/* 8208F204h case    5:*/		cpu::mem::store32f( regs, regs.FR26, (uint32)(regs.R11 + 0x00000008) );
		/* 8208F204h case    5:*/		return 0x8208F208;
		  /* 8208F208h */ case    6:  		/* stfs FR26, <#[R11 + 12]> */
		/* 8208F208h case    6:*/		cpu::mem::store32f( regs, regs.FR26, (uint32)(regs.R11 + 0x0000000C) );
		/* 8208F208h case    6:*/		return 0x8208F20C;
		  /* 8208F20Ch */ case    7:  		/* stfs FR26, <#[R11 + 16]> */
		/* 8208F20Ch case    7:*/		cpu::mem::store32f( regs, regs.FR26, (uint32)(regs.R11 + 0x00000010) );
		/* 8208F20Ch case    7:*/		return 0x8208F210;
		  /* 8208F210h */ case    8:  		/* stfs FR26, <#[R11 + 20]> */
		/* 8208F210h case    8:*/		cpu::mem::store32f( regs, regs.FR26, (uint32)(regs.R11 + 0x00000014) );
		/* 8208F210h case    8:*/		return 0x8208F214;
		  /* 8208F214h */ case    9:  		/* stfs FR26, <#[R11 + 24]> */
		/* 8208F214h case    9:*/		cpu::mem::store32f( regs, regs.FR26, (uint32)(regs.R11 + 0x00000018) );
		/* 8208F214h case    9:*/		return 0x8208F218;
		  /* 8208F218h */ case   10:  		/* stfs FR26, <#[R11 + 28]> */
		/* 8208F218h case   10:*/		cpu::mem::store32f( regs, regs.FR26, (uint32)(regs.R11 + 0x0000001C) );
		/* 8208F218h case   10:*/		return 0x8208F21C;
		  /* 8208F21Ch */ case   11:  		/* stfs FR26, <#[R11 + 32]> */
		/* 8208F21Ch case   11:*/		cpu::mem::store32f( regs, regs.FR26, (uint32)(regs.R11 + 0x00000020) );
		/* 8208F21Ch case   11:*/		return 0x8208F220;
		  /* 8208F220h */ case   12:  		/* stfs FR26, <#[R11 + 36]> */
		/* 8208F220h case   12:*/		cpu::mem::store32f( regs, regs.FR26, (uint32)(regs.R11 + 0x00000024) );
		/* 8208F220h case   12:*/		return 0x8208F224;
		  /* 8208F224h */ case   13:  		/* stfs FR26, <#[R11 + 40]> */
		/* 8208F224h case   13:*/		cpu::mem::store32f( regs, regs.FR26, (uint32)(regs.R11 + 0x00000028) );
		/* 8208F224h case   13:*/		return 0x8208F228;
		  /* 8208F228h */ case   14:  		/* stfs FR26, <#[R11 + 44]> */
		/* 8208F228h case   14:*/		cpu::mem::store32f( regs, regs.FR26, (uint32)(regs.R11 + 0x0000002C) );
		/* 8208F228h case   14:*/		return 0x8208F22C;
		  /* 8208F22Ch */ case   15:  		/* stfs FR26, <#[R11 + 48]> */
		/* 8208F22Ch case   15:*/		cpu::mem::store32f( regs, regs.FR26, (uint32)(regs.R11 + 0x00000030) );
		/* 8208F22Ch case   15:*/		return 0x8208F230;
		  /* 8208F230h */ case   16:  		/* stfs FR26, <#[R11 + 52]> */
		/* 8208F230h case   16:*/		cpu::mem::store32f( regs, regs.FR26, (uint32)(regs.R11 + 0x00000034) );
		/* 8208F230h case   16:*/		return 0x8208F234;
		  /* 8208F234h */ case   17:  		/* stfs FR26, <#[R11 + 56]> */
		/* 8208F234h case   17:*/		cpu::mem::store32f( regs, regs.FR26, (uint32)(regs.R11 + 0x00000038) );
		/* 8208F234h case   17:*/		return 0x8208F238;
		  /* 8208F238h */ case   18:  		/* stfs FR26, <#[R11 + 60]> */
		/* 8208F238h case   18:*/		cpu::mem::store32f( regs, regs.FR26, (uint32)(regs.R11 + 0x0000003C) );
		/* 8208F238h case   18:*/		return 0x8208F23C;
		  /* 8208F23Ch */ case   19:  		/* stfsu FR26, <#[R11 + 64]> */
		/* 8208F23Ch case   19:*/		cpu::mem::store32f( regs, regs.FR26, (uint32)(regs.R11 + 0x00000040) );
		regs.R11 = (uint32)(regs.R11 + 0x00000040);
		/* 8208F23Ch case   19:*/		return 0x8208F240;
		  /* 8208F240h */ case   20:  		/* bc 16, CR0_LT, -64 */
		/* 8208F240h case   20:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8208F200;  }
		/* 8208F240h case   20:*/		return 0x8208F244;
	}
	return 0x8208F244;
} // Block from 8208F1F0h-8208F244h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8208F244h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F244( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F244) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F244);
		  /* 8208F244h */ case    0:  		/* lwz R3, <#[R28 - 31244]> */
		/* 8208F244h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0xFFFF85F4) );
		/* 8208F244h case    0:*/		return 0x8208F248;
		  /* 8208F248h */ case    1:  		/* bl -125104 */
		/* 8208F248h case    1:*/		regs.LR = 0x8208F24C; return 0x82070998;
		/* 8208F248h case    1:*/		return 0x8208F24C;
		  /* 8208F24Ch */ case    2:  		/* lfs FR0, <#[R31 + 88]> */
		/* 8208F24Ch case    2:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000058) );
		/* 8208F24Ch case    2:*/		return 0x8208F250;
		  /* 8208F250h */ case    3:  		/* mr R3, R31 */
		/* 8208F250h case    3:*/		regs.R3 = regs.R31;
		/* 8208F250h case    3:*/		return 0x8208F254;
		  /* 8208F254h */ case    4:  		/* lfs FR13, <#[R31 + 92]> */
		/* 8208F254h case    4:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208F254h case    4:*/		return 0x8208F258;
		  /* 8208F258h */ case    5:  		/* fsubs FR0, FR0, FR28 */
		/* 8208F258h case    5:*/		cpu::op::fsubs<0>(regs,&regs.FR0,regs.FR0,regs.FR28);
		/* 8208F258h case    5:*/		return 0x8208F25C;
		  /* 8208F25Ch */ case    6:  		/* fsubs FR13, FR13, FR27 */
		/* 8208F25Ch case    6:*/		cpu::op::fsubs<0>(regs,&regs.FR13,regs.FR13,regs.FR27);
		/* 8208F25Ch case    6:*/		return 0x8208F260;
		  /* 8208F260h */ case    7:  		/* stfs FR0, <#[R31 + 88]> */
		/* 8208F260h case    7:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000058) );
		/* 8208F260h case    7:*/		return 0x8208F264;
		  /* 8208F264h */ case    8:  		/* stfs FR13, <#[R31 + 92]> */
		/* 8208F264h case    8:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R31 + 0x0000005C) );
		/* 8208F264h case    8:*/		return 0x8208F268;
		  /* 8208F268h */ case    9:  		/* bl -2248 */
		/* 8208F268h case    9:*/		regs.LR = 0x8208F26C; return 0x8208E9A0;
		/* 8208F268h case    9:*/		return 0x8208F26C;
	}
	return 0x8208F26C;
} // Block from 8208F244h-8208F26Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8208F26Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F26C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F26C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F26C);
		  /* 8208F26Ch */ case    0:  		/* addi R1, R1, 336 */
		/* 8208F26Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x150);
		/* 8208F26Ch case    0:*/		return 0x8208F270;
		  /* 8208F270h */ case    1:  		/* addi R12, R1, -72 */
		/* 8208F270h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFFB8);
		/* 8208F270h case    1:*/		return 0x8208F274;
		  /* 8208F274h */ case    2:  		/* bl 8632 */
		/* 8208F274h case    2:*/		regs.LR = 0x8208F278; return 0x8209142C;
		/* 8208F274h case    2:*/		return 0x8208F278;
		  /* 8208F278h */ case    3:  		/* b 8224 */
		/* 8208F278h case    3:*/		return 0x82091298;
		/* 8208F278h case    3:*/		return 0x8208F27C;
		  /* 8208F27Ch */ case    4:  		/* nop */
		/* 8208F27Ch case    4:*/		cpu::op::nop();
		/* 8208F27Ch case    4:*/		return 0x8208F280;
	}
	return 0x8208F280;
} // Block from 8208F26Ch-8208F280h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208F280h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F280);
		  /* 8208F280h */ case    0:  		/* lis R10, -32255 */
		/* 8208F280h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8208F280h case    0:*/		return 0x8208F284;
		  /* 8208F284h */ case    1:  		/* li R11, 0 */
		/* 8208F284h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8208F284h case    1:*/		return 0x8208F288;
		  /* 8208F288h */ case    2:  		/* addi R10, R10, -26916 */
		/* 8208F288h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFF96DC);
		/* 8208F288h case    2:*/		return 0x8208F28C;
		  /* 8208F28Ch */ case    3:  		/* stw R11, <#[R3 + 4]> */
		/* 8208F28Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8208F28Ch case    3:*/		return 0x8208F290;
		  /* 8208F290h */ case    4:  		/* stw R10, <#[R3]> */
		/* 8208F290h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8208F290h case    4:*/		return 0x8208F294;
		  /* 8208F294h */ case    5:  		/* stw R11, <#[R3 + 8]> */
		/* 8208F294h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8208F294h case    5:*/		return 0x8208F298;
		  /* 8208F298h */ case    6:  		/* stw R11, <#[R3 + 12]> */
		/* 8208F298h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8208F298h case    6:*/		return 0x8208F29C;
		  /* 8208F29Ch */ case    7:  		/* bclr 20, CR0_LT */
		/* 8208F29Ch case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208F29Ch case    7:*/		return 0x8208F2A0;
	}
	return 0x8208F2A0;
} // Block from 8208F280h-8208F2A0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8208F2A0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F2A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F2A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F2A0);
		  /* 8208F2A0h */ case    0:  		/* mfspr R12, LR */
		/* 8208F2A0h case    0:*/		regs.R12 = regs.LR;
		/* 8208F2A0h case    0:*/		return 0x8208F2A4;
		  /* 8208F2A4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8208F2A4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208F2A4h case    1:*/		return 0x8208F2A8;
		  /* 8208F2A8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8208F2A8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208F2A8h case    2:*/		return 0x8208F2AC;
		  /* 8208F2ACh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8208F2ACh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8208F2ACh case    3:*/		return 0x8208F2B0;
		  /* 8208F2B0h */ case    4:  		/* mr R31, R3 */
		/* 8208F2B0h case    4:*/		regs.R31 = regs.R3;
		/* 8208F2B0h case    4:*/		return 0x8208F2B4;
		  /* 8208F2B4h */ case    5:  		/* lwz R3, <#[R3 + 4]> */
		/* 8208F2B4h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000004) );
		/* 8208F2B4h case    5:*/		return 0x8208F2B8;
		  /* 8208F2B8h */ case    6:  		/* lis R11, -32255 */
		/* 8208F2B8h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208F2B8h case    6:*/		return 0x8208F2BC;
		  /* 8208F2BCh */ case    7:  		/* addi R11, R11, -26916 */
		/* 8208F2BCh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF96DC);
		/* 8208F2BCh case    7:*/		return 0x8208F2C0;
		  /* 8208F2C0h */ case    8:  		/* stw R11, <#[R31]> */
		/* 8208F2C0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8208F2C0h case    8:*/		return 0x8208F2C4;
		  /* 8208F2C4h */ case    9:  		/* bl 12452 */
		/* 8208F2C4h case    9:*/		regs.LR = 0x8208F2C8; return 0x82092368;
		/* 8208F2C4h case    9:*/		return 0x8208F2C8;
		  /* 8208F2C8h */ case   10:  		/* lwz R3, <#[R31 + 8]> */
		/* 8208F2C8h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 8208F2C8h case   10:*/		return 0x8208F2CC;
		  /* 8208F2CCh */ case   11:  		/* cmplwi CR6, R3, 0 */
		/* 8208F2CCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8208F2CCh case   11:*/		return 0x8208F2D0;
		  /* 8208F2D0h */ case   12:  		/* bc 12, CR6_EQ, 8 */
		/* 8208F2D0h case   12:*/		if ( regs.CR[6].eq ) { return 0x8208F2D8;  }
		/* 8208F2D0h case   12:*/		return 0x8208F2D4;
		  /* 8208F2D4h */ case   13:  		/* bl -19460 */
		/* 8208F2D4h case   13:*/		regs.LR = 0x8208F2D8; return 0x8208A6D0;
		/* 8208F2D4h case   13:*/		return 0x8208F2D8;
	}
	return 0x8208F2D8;
} // Block from 8208F2A0h-8208F2D8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8208F2D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F2D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F2D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F2D8);
		  /* 8208F2D8h */ case    0:  		/* addi R1, R1, 96 */
		/* 8208F2D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8208F2D8h case    0:*/		return 0x8208F2DC;
		  /* 8208F2DCh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8208F2DCh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208F2DCh case    1:*/		return 0x8208F2E0;
		  /* 8208F2E0h */ case    2:  		/* mtspr LR, R12 */
		/* 8208F2E0h case    2:*/		regs.LR = regs.R12;
		/* 8208F2E0h case    2:*/		return 0x8208F2E4;
		  /* 8208F2E4h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8208F2E4h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208F2E4h case    3:*/		return 0x8208F2E8;
		  /* 8208F2E8h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8208F2E8h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208F2E8h case    4:*/		return 0x8208F2EC;
	}
	return 0x8208F2EC;
} // Block from 8208F2D8h-8208F2ECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8208F2ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F2EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F2EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F2EC);
		  /* 8208F2ECh */ case    0:  		/* nop */
		/* 8208F2ECh case    0:*/		cpu::op::nop();
		/* 8208F2ECh case    0:*/		return 0x8208F2F0;
	}
	return 0x8208F2F0;
} // Block from 8208F2ECh-8208F2F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208F2F0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F2F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F2F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F2F0);
		  /* 8208F2F0h */ case    0:  		/* mfspr R12, LR */
		/* 8208F2F0h case    0:*/		regs.R12 = regs.LR;
		/* 8208F2F0h case    0:*/		return 0x8208F2F4;
		  /* 8208F2F4h */ case    1:  		/* bl 8036 */
		/* 8208F2F4h case    1:*/		regs.LR = 0x8208F2F8; return 0x82091258;
		/* 8208F2F4h case    1:*/		return 0x8208F2F8;
		  /* 8208F2F8h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 8208F2F8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 8208F2F8h case    2:*/		return 0x8208F2FC;
		  /* 8208F2FCh */ case    3:  		/* mr R31, R3 */
		/* 8208F2FCh case    3:*/		regs.R31 = regs.R3;
		/* 8208F2FCh case    3:*/		return 0x8208F300;
		  /* 8208F300h */ case    4:  		/* mr R3, R4 */
		/* 8208F300h case    4:*/		regs.R3 = regs.R4;
		/* 8208F300h case    4:*/		return 0x8208F304;
		  /* 8208F304h */ case    5:  		/* mr R28, R5 */
		/* 8208F304h case    5:*/		regs.R28 = regs.R5;
		/* 8208F304h case    5:*/		return 0x8208F308;
		  /* 8208F308h */ case    6:  		/* li R9, 0 */
		/* 8208F308h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8208F308h case    6:*/		return 0x8208F30C;
		  /* 8208F30Ch */ case    7:  		/* li R8, 1 */
		/* 8208F30Ch case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8208F30Ch case    7:*/		return 0x8208F310;
		  /* 8208F310h */ case    8:  		/* li R7, 3 */
		/* 8208F310h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 8208F310h case    8:*/		return 0x8208F314;
		  /* 8208F314h */ case    9:  		/* li R6, 0 */
		/* 8208F314h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8208F314h case    9:*/		return 0x8208F318;
		  /* 8208F318h */ case   10:  		/* li R5, 1 */
		/* 8208F318h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8208F318h case   10:*/		return 0x8208F31C;
		  /* 8208F31Ch */ case   11:  		/* lis R4, -32768 */
		/* 8208F31Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8000);
		/* 8208F31Ch case   11:*/		return 0x8208F320;
		  /* 8208F320h */ case   12:  		/* bl -26160 */
		/* 8208F320h case   12:*/		regs.LR = 0x8208F324; return 0x82088CF0;
		/* 8208F320h case   12:*/		return 0x8208F324;
		  /* 8208F324h */ case   13:  		/* mr R30, R3 */
		/* 8208F324h case   13:*/		regs.R30 = regs.R3;
		/* 8208F324h case   13:*/		return 0x8208F328;
		  /* 8208F328h */ case   14:  		/* cmpwi CR6, R3, -1 */
		/* 8208F328h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8208F328h case   14:*/		return 0x8208F32C;
		  /* 8208F32Ch */ case   15:  		/* bc 4, CR6_EQ, 52 */
		/* 8208F32Ch case   15:*/		if ( !regs.CR[6].eq ) { return 0x8208F360;  }
		/* 8208F32Ch case   15:*/		return 0x8208F330;
		  /* 8208F330h */ case   16:  		/* lis R11, -32255 */
		/* 8208F330h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208F330h case   16:*/		return 0x8208F334;
		  /* 8208F334h */ case   17:  		/* lis R10, -32256 */
		/* 8208F334h case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8208F334h case   17:*/		return 0x8208F338;
		  /* 8208F338h */ case   18:  		/* addi R4, R11, -26756 */
		/* 8208F338h case   18:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFF977C);
		/* 8208F338h case   18:*/		return 0x8208F33C;
		  /* 8208F33Ch */ case   19:  		/* addi R3, R10, 2596 */
		/* 8208F33Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 8208F33Ch case   19:*/		return 0x8208F340;
		  /* 8208F340h */ case   20:  		/* li R5, 57 */
		/* 8208F340h case   20:*/		cpu::op::li<0>(regs,&regs.R5,0x39);
		/* 8208F340h case   20:*/		return 0x8208F344;
		  /* 8208F344h */ case   21:  		/* bl 1524 */
		/* 8208F344h case   21:*/		regs.LR = 0x8208F348; return 0x8208F938;
		/* 8208F344h case   21:*/		return 0x8208F348;
		  /* 8208F348h */ case   22:  		/* lis R11, -32255 */
		/* 8208F348h case   22:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208F348h case   22:*/		return 0x8208F34C;
		  /* 8208F34Ch */ case   23:  		/* addi R3, R11, -26776 */
		/* 8208F34Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF9768);
		/* 8208F34Ch case   23:*/		return 0x8208F350;
		  /* 8208F350h */ case   24:  		/* bl 1512 */
		/* 8208F350h case   24:*/		regs.LR = 0x8208F354; return 0x8208F938;
		/* 8208F350h case   24:*/		return 0x8208F354;
		  /* 8208F354h */ case   25:  		/* lis R3, -32768 */
		/* 8208F354h case   25:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8208F354h case   25:*/		return 0x8208F358;
		  /* 8208F358h */ case   26:  		/* ori R3, R3, 16389 */
		/* 8208F358h case   26:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8208F358h case   26:*/		return 0x8208F35C;
		  /* 8208F35Ch */ case   27:  		/* b 508 */
		/* 8208F35Ch case   27:*/		return 0x8208F558;
		/* 8208F35Ch case   27:*/		return 0x8208F360;
	}
	return 0x8208F360;
} // Block from 8208F2F0h-8208F360h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8208F360h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F360);
		  /* 8208F360h */ case    0:  		/* li R7, 0 */
		/* 8208F360h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8208F360h case    0:*/		return 0x8208F364;
		  /* 8208F364h */ case    1:  		/* addi R6, R1, 80 */
		/* 8208F364h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 8208F364h case    1:*/		return 0x8208F368;
		  /* 8208F368h */ case    2:  		/* li R5, 16 */
		/* 8208F368h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 8208F368h case    2:*/		return 0x8208F36C;
		  /* 8208F36Ch */ case    3:  		/* addi R4, R1, 96 */
		/* 8208F36Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 8208F36Ch case    3:*/		return 0x8208F370;
		  /* 8208F370h */ case    4:  		/* mr R3, R30 */
		/* 8208F370h case    4:*/		regs.R3 = regs.R30;
		/* 8208F370h case    4:*/		return 0x8208F374;
		  /* 8208F374h */ case    5:  		/* bl 1932652 */
		/* 8208F374h case    5:*/		regs.LR = 0x8208F378; return 0x822670E0;
		/* 8208F374h case    5:*/		return 0x8208F378;
		  /* 8208F378h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 8208F378h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208F378h case    6:*/		return 0x8208F37C;
		  /* 8208F37Ch */ case    7:  		/* bc 4, CR0_EQ, 48 */
		/* 8208F37Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x8208F3AC;  }
		/* 8208F37Ch case    7:*/		return 0x8208F380;
		  /* 8208F380h */ case    8:  		/* mr R3, R30 */
		/* 8208F380h case    8:*/		regs.R3 = regs.R30;
		/* 8208F380h case    8:*/		return 0x8208F384;
		  /* 8208F384h */ case    9:  		/* bl -27516 */
		/* 8208F384h case    9:*/		regs.LR = 0x8208F388; return 0x82088808;
		/* 8208F384h case    9:*/		return 0x8208F388;
		  /* 8208F388h */ case   10:  		/* lis R11, -32255 */
		/* 8208F388h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208F388h case   10:*/		return 0x8208F38C;
		  /* 8208F38Ch */ case   11:  		/* lis R10, -32256 */
		/* 8208F38Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8208F38Ch case   11:*/		return 0x8208F390;
		  /* 8208F390h */ case   12:  		/* addi R4, R11, -26756 */
		/* 8208F390h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFF977C);
		/* 8208F390h case   12:*/		return 0x8208F394;
		  /* 8208F394h */ case   13:  		/* addi R3, R10, 2596 */
		/* 8208F394h case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 8208F394h case   13:*/		return 0x8208F398;
		  /* 8208F398h */ case   14:  		/* li R5, 66 */
		/* 8208F398h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x42);
		/* 8208F398h case   14:*/		return 0x8208F39C;
		  /* 8208F39Ch */ case   15:  		/* bl 1436 */
		/* 8208F39Ch case   15:*/		regs.LR = 0x8208F3A0; return 0x8208F938;
		/* 8208F39Ch case   15:*/		return 0x8208F3A0;
		  /* 8208F3A0h */ case   16:  		/* lis R11, -32255 */
		/* 8208F3A0h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208F3A0h case   16:*/		return 0x8208F3A4;
		  /* 8208F3A4h */ case   17:  		/* addi R3, R11, -26808 */
		/* 8208F3A4h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF9748);
		/* 8208F3A4h case   17:*/		return 0x8208F3A8;
		  /* 8208F3A8h */ case   18:  		/* b -88 */
		/* 8208F3A8h case   18:*/		return 0x8208F350;
		/* 8208F3A8h case   18:*/		return 0x8208F3AC;
	}
	return 0x8208F3AC;
} // Block from 8208F360h-8208F3ACh (19 instructions)

//////////////////////////////////////////////////////
// Block at 8208F3ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F3AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F3AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F3AC);
		  /* 8208F3ACh */ case    0:  		/* lis R11, 22594 */
		/* 8208F3ACh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x5842);
		/* 8208F3ACh case    0:*/		return 0x8208F3B0;
		  /* 8208F3B0h */ case    1:  		/* lwz R10, <#[R1 + 96]> */
		/* 8208F3B0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 8208F3B0h case    1:*/		return 0x8208F3B4;
		  /* 8208F3B4h */ case    2:  		/* ori R11, R11, 18183 */
		/* 8208F3B4h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4707);
		/* 8208F3B4h case    2:*/		return 0x8208F3B8;
		  /* 8208F3B8h */ case    3:  		/* cmplw CR6, R10, R11 */
		/* 8208F3B8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208F3B8h case    3:*/		return 0x8208F3BC;
		  /* 8208F3BCh */ case    4:  		/* bc 12, CR6_EQ, 48 */
		/* 8208F3BCh case    4:*/		if ( regs.CR[6].eq ) { return 0x8208F3EC;  }
		/* 8208F3BCh case    4:*/		return 0x8208F3C0;
		  /* 8208F3C0h */ case    5:  		/* mr R3, R30 */
		/* 8208F3C0h case    5:*/		regs.R3 = regs.R30;
		/* 8208F3C0h case    5:*/		return 0x8208F3C4;
		  /* 8208F3C4h */ case    6:  		/* bl -27580 */
		/* 8208F3C4h case    6:*/		regs.LR = 0x8208F3C8; return 0x82088808;
		/* 8208F3C4h case    6:*/		return 0x8208F3C8;
		  /* 8208F3C8h */ case    7:  		/* lis R11, -32255 */
		/* 8208F3C8h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208F3C8h case    7:*/		return 0x8208F3CC;
		  /* 8208F3CCh */ case    8:  		/* lis R10, -32256 */
		/* 8208F3CCh case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8208F3CCh case    8:*/		return 0x8208F3D0;
		  /* 8208F3D0h */ case    9:  		/* addi R4, R11, -26756 */
		/* 8208F3D0h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFF977C);
		/* 8208F3D0h case    9:*/		return 0x8208F3D4;
		  /* 8208F3D4h */ case   10:  		/* addi R3, R10, 2596 */
		/* 8208F3D4h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 8208F3D4h case   10:*/		return 0x8208F3D8;
		  /* 8208F3D8h */ case   11:  		/* li R5, 73 */
		/* 8208F3D8h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x49);
		/* 8208F3D8h case   11:*/		return 0x8208F3DC;
		  /* 8208F3DCh */ case   12:  		/* bl 1372 */
		/* 8208F3DCh case   12:*/		regs.LR = 0x8208F3E0; return 0x8208F938;
		/* 8208F3DCh case   12:*/		return 0x8208F3E0;
		  /* 8208F3E0h */ case   13:  		/* lis R11, -32255 */
		/* 8208F3E0h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208F3E0h case   13:*/		return 0x8208F3E4;
		  /* 8208F3E4h */ case   14:  		/* addi R3, R11, -26832 */
		/* 8208F3E4h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF9730);
		/* 8208F3E4h case   14:*/		return 0x8208F3E8;
		  /* 8208F3E8h */ case   15:  		/* b -152 */
		/* 8208F3E8h case   15:*/		return 0x8208F350;
		/* 8208F3E8h case   15:*/		return 0x8208F3EC;
	}
	return 0x8208F3EC;
} // Block from 8208F3ACh-8208F3ECh (16 instructions)

//////////////////////////////////////////////////////
// Block at 8208F3ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F3EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F3EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F3EC);
		  /* 8208F3ECh */ case    0:  		/* lwz R3, <#[R1 + 100]> */
		/* 8208F3ECh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000064) );
		/* 8208F3ECh case    0:*/		return 0x8208F3F0;
		  /* 8208F3F0h */ case    1:  		/* mr R29, R3 */
		/* 8208F3F0h case    1:*/		regs.R29 = regs.R3;
		/* 8208F3F0h case    1:*/		return 0x8208F3F4;
		  /* 8208F3F4h */ case    2:  		/* bl 17236 */
		/* 8208F3F4h case    2:*/		regs.LR = 0x8208F3F8; return 0x82093748;
		/* 8208F3F4h case    2:*/		return 0x8208F3F8;
		  /* 8208F3F8h */ case    3:  		/* stw R3, <#[R31 + 4]> */
		/* 8208F3F8h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 8208F3F8h case    3:*/		return 0x8208F3FC;
		  /* 8208F3FCh */ case    4:  		/* mr R4, R3 */
		/* 8208F3FCh case    4:*/		regs.R4 = regs.R3;
		/* 8208F3FCh case    4:*/		return 0x8208F400;
		  /* 8208F400h */ case    5:  		/* li R7, 0 */
		/* 8208F400h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8208F400h case    5:*/		return 0x8208F404;
		  /* 8208F404h */ case    6:  		/* addi R6, R1, 80 */
		/* 8208F404h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 8208F404h case    6:*/		return 0x8208F408;
		  /* 8208F408h */ case    7:  		/* mr R5, R29 */
		/* 8208F408h case    7:*/		regs.R5 = regs.R29;
		/* 8208F408h case    7:*/		return 0x8208F40C;
		  /* 8208F40Ch */ case    8:  		/* mr R3, R30 */
		/* 8208F40Ch case    8:*/		regs.R3 = regs.R30;
		/* 8208F40Ch case    8:*/		return 0x8208F410;
		  /* 8208F410h */ case    9:  		/* bl 1932496 */
		/* 8208F410h case    9:*/		regs.LR = 0x8208F414; return 0x822670E0;
		/* 8208F410h case    9:*/		return 0x8208F414;
		  /* 8208F414h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 8208F414h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208F414h case   10:*/		return 0x8208F418;
		  /* 8208F418h */ case   11:  		/* bc 4, CR0_EQ, 48 */
		/* 8208F418h case   11:*/		if ( !regs.CR[0].eq ) { return 0x8208F448;  }
		/* 8208F418h case   11:*/		return 0x8208F41C;
		  /* 8208F41Ch */ case   12:  		/* mr R3, R30 */
		/* 8208F41Ch case   12:*/		regs.R3 = regs.R30;
		/* 8208F41Ch case   12:*/		return 0x8208F420;
		  /* 8208F420h */ case   13:  		/* bl -27672 */
		/* 8208F420h case   13:*/		regs.LR = 0x8208F424; return 0x82088808;
		/* 8208F420h case   13:*/		return 0x8208F424;
		  /* 8208F424h */ case   14:  		/* lis R11, -32255 */
		/* 8208F424h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208F424h case   14:*/		return 0x8208F428;
		  /* 8208F428h */ case   15:  		/* lis R10, -32256 */
		/* 8208F428h case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8208F428h case   15:*/		return 0x8208F42C;
		  /* 8208F42Ch */ case   16:  		/* addi R4, R11, -26756 */
		/* 8208F42Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFF977C);
		/* 8208F42Ch case   16:*/		return 0x8208F430;
		  /* 8208F430h */ case   17:  		/* addi R3, R10, 2596 */
		/* 8208F430h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 8208F430h case   17:*/		return 0x8208F434;
		  /* 8208F434h */ case   18:  		/* li R5, 84 */
		/* 8208F434h case   18:*/		cpu::op::li<0>(regs,&regs.R5,0x54);
		/* 8208F434h case   18:*/		return 0x8208F438;
		  /* 8208F438h */ case   19:  		/* bl 1280 */
		/* 8208F438h case   19:*/		regs.LR = 0x8208F43C; return 0x8208F938;
		/* 8208F438h case   19:*/		return 0x8208F43C;
		  /* 8208F43Ch */ case   20:  		/* lis R11, -32255 */
		/* 8208F43Ch case   20:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208F43Ch case   20:*/		return 0x8208F440;
		  /* 8208F440h */ case   21:  		/* addi R3, R11, -26872 */
		/* 8208F440h case   21:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF9708);
		/* 8208F440h case   21:*/		return 0x8208F444;
		  /* 8208F444h */ case   22:  		/* b -244 */
		/* 8208F444h case   22:*/		return 0x8208F350;
		/* 8208F444h case   22:*/		return 0x8208F448;
	}
	return 0x8208F448;
} // Block from 8208F3ECh-8208F448h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8208F448h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F448);
		  /* 8208F448h */ case    0:  		/* lwz R3, <#[R1 + 104]> */
		/* 8208F448h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000068) );
		/* 8208F448h case    0:*/		return 0x8208F44C;
		  /* 8208F44Ch */ case    1:  		/* li R7, 1028 */
		/* 8208F44Ch case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x404);
		/* 8208F44Ch case    1:*/		return 0x8208F450;
		  /* 8208F450h */ case    2:  		/* li R6, 4 */
		/* 8208F450h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 8208F450h case    2:*/		return 0x8208F454;
		  /* 8208F454h */ case    3:  		/* li R5, -1 */
		/* 8208F454h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0xFFFFFFFF);
		/* 8208F454h case    3:*/		return 0x8208F458;
		  /* 8208F458h */ case    4:  		/* li R4, 0 */
		/* 8208F458h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208F458h case    4:*/		return 0x8208F45C;
		  /* 8208F45Ch */ case    5:  		/* mr R29, R3 */
		/* 8208F45Ch case    5:*/		regs.R29 = regs.R3;
		/* 8208F45Ch case    5:*/		return 0x8208F460;
		  /* 8208F460h */ case    6:  		/* bl -19968 */
		/* 8208F460h case    6:*/		regs.LR = 0x8208F464; return 0x8208A660;
		/* 8208F460h case    6:*/		return 0x8208F464;
		  /* 8208F464h */ case    7:  		/* stw R3, <#[R31 + 8]> */
		/* 8208F464h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 8208F464h case    7:*/		return 0x8208F468;
		  /* 8208F468h */ case    8:  		/* mr R4, R3 */
		/* 8208F468h case    8:*/		regs.R4 = regs.R3;
		/* 8208F468h case    8:*/		return 0x8208F46C;
		  /* 8208F46Ch */ case    9:  		/* li R7, 0 */
		/* 8208F46Ch case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8208F46Ch case    9:*/		return 0x8208F470;
		  /* 8208F470h */ case   10:  		/* addi R6, R1, 80 */
		/* 8208F470h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 8208F470h case   10:*/		return 0x8208F474;
		  /* 8208F474h */ case   11:  		/* mr R5, R29 */
		/* 8208F474h case   11:*/		regs.R5 = regs.R29;
		/* 8208F474h case   11:*/		return 0x8208F478;
		  /* 8208F478h */ case   12:  		/* mr R3, R30 */
		/* 8208F478h case   12:*/		regs.R3 = regs.R30;
		/* 8208F478h case   12:*/		return 0x8208F47C;
		  /* 8208F47Ch */ case   13:  		/* bl 1932388 */
		/* 8208F47Ch case   13:*/		regs.LR = 0x8208F480; return 0x822670E0;
		/* 8208F47Ch case   13:*/		return 0x8208F480;
		  /* 8208F480h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 8208F480h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208F480h case   14:*/		return 0x8208F484;
		  /* 8208F484h */ case   15:  		/* mr R3, R30 */
		/* 8208F484h case   15:*/		regs.R3 = regs.R30;
		/* 8208F484h case   15:*/		return 0x8208F488;
		  /* 8208F488h */ case   16:  		/* bc 4, CR0_EQ, 44 */
		/* 8208F488h case   16:*/		if ( !regs.CR[0].eq ) { return 0x8208F4B4;  }
		/* 8208F488h case   16:*/		return 0x8208F48C;
		  /* 8208F48Ch */ case   17:  		/* bl -27780 */
		/* 8208F48Ch case   17:*/		regs.LR = 0x8208F490; return 0x82088808;
		/* 8208F48Ch case   17:*/		return 0x8208F490;
		  /* 8208F490h */ case   18:  		/* lis R11, -32255 */
		/* 8208F490h case   18:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208F490h case   18:*/		return 0x8208F494;
		  /* 8208F494h */ case   19:  		/* lis R10, -32256 */
		/* 8208F494h case   19:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8208F494h case   19:*/		return 0x8208F498;
		  /* 8208F498h */ case   20:  		/* addi R4, R11, -26756 */
		/* 8208F498h case   20:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFF977C);
		/* 8208F498h case   20:*/		return 0x8208F49C;
		  /* 8208F49Ch */ case   21:  		/* addi R3, R10, 2596 */
		/* 8208F49Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 8208F49Ch case   21:*/		return 0x8208F4A0;
		  /* 8208F4A0h */ case   22:  		/* li R5, 97 */
		/* 8208F4A0h case   22:*/		cpu::op::li<0>(regs,&regs.R5,0x61);
		/* 8208F4A0h case   22:*/		return 0x8208F4A4;
		  /* 8208F4A4h */ case   23:  		/* bl 1172 */
		/* 8208F4A4h case   23:*/		regs.LR = 0x8208F4A8; return 0x8208F938;
		/* 8208F4A4h case   23:*/		return 0x8208F4A8;
		  /* 8208F4A8h */ case   24:  		/* lis R11, -32255 */
		/* 8208F4A8h case   24:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208F4A8h case   24:*/		return 0x8208F4AC;
		  /* 8208F4ACh */ case   25:  		/* addi R3, R11, -26912 */
		/* 8208F4ACh case   25:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF96E0);
		/* 8208F4ACh case   25:*/		return 0x8208F4B0;
		  /* 8208F4B0h */ case   26:  		/* b -352 */
		/* 8208F4B0h case   26:*/		return 0x8208F350;
		/* 8208F4B0h case   26:*/		return 0x8208F4B4;
	}
	return 0x8208F4B4;
} // Block from 8208F448h-8208F4B4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8208F4B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F4B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F4B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F4B4);
		  /* 8208F4B4h */ case    0:  		/* bl -27820 */
		/* 8208F4B4h case    0:*/		regs.LR = 0x8208F4B8; return 0x82088808;
		/* 8208F4B4h case    0:*/		return 0x8208F4B8;
		  /* 8208F4B8h */ case    1:  		/* lwz R11, <#[R31 + 4]> */
		/* 8208F4B8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8208F4B8h case    1:*/		return 0x8208F4BC;
		  /* 8208F4BCh */ case    2:  		/* lwz R4, <#[R31 + 8]> */
		/* 8208F4BCh case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 8208F4BCh case    2:*/		return 0x8208F4C0;
		  /* 8208F4C0h */ case    3:  		/* lwz R10, <#[R11 + 128]> */
		/* 8208F4C0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000080) );
		/* 8208F4C0h case    3:*/		return 0x8208F4C4;
		  /* 8208F4C4h */ case    4:  		/* add R11, R10, R11 */
		/* 8208F4C4h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8208F4C4h case    4:*/		return 0x8208F4C8;
		  /* 8208F4C8h */ case    5:  		/* addi R3, R11, -16 */
		/* 8208F4C8h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFF0);
		/* 8208F4C8h case    5:*/		return 0x8208F4CC;
		  /* 8208F4CCh */ case    6:  		/* stw R3, <#[R31 + 12]> */
		/* 8208F4CCh case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 8208F4CCh case    6:*/		return 0x8208F4D0;
		  /* 8208F4D0h */ case    7:  		/* bl 747784 */
		/* 8208F4D0h case    7:*/		regs.LR = 0x8208F4D4; return 0x82145DD8;
		/* 8208F4D0h case    7:*/		return 0x8208F4D4;
		  /* 8208F4D4h */ case    8:  		/* lwz R11, <#[R31 + 12]> */
		/* 8208F4D4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8208F4D4h case    8:*/		return 0x8208F4D8;
		  /* 8208F4D8h */ case    9:  		/* lwz R4, <#[R31 + 8]> */
		/* 8208F4D8h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 8208F4D8h case    9:*/		return 0x8208F4DC;
		  /* 8208F4DCh */ case   10:  		/* addi R3, R11, 36 */
		/* 8208F4DCh case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x24);
		/* 8208F4DCh case   10:*/		return 0x8208F4E0;
		  /* 8208F4E0h */ case   11:  		/* bl 747768 */
		/* 8208F4E0h case   11:*/		regs.LR = 0x8208F4E4; return 0x82145DD8;
		/* 8208F4E0h case   11:*/		return 0x8208F4E4;
		  /* 8208F4E4h */ case   12:  		/* lis R10, -32215 */
		/* 8208F4E4h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 8208F4E4h case   12:*/		return 0x8208F4E8;
		  /* 8208F4E8h */ case   13:  		/* lwz R11, <#[R31 + 12]> */
		/* 8208F4E8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8208F4E8h case   13:*/		return 0x8208F4EC;
		  /* 8208F4ECh */ case   14:  		/* addi R5, R11, 264 */
		/* 8208F4ECh case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x108);
		/* 8208F4ECh case   14:*/		return 0x8208F4F0;
		  /* 8208F4F0h */ case   15:  		/* addi R4, R11, 72 */
		/* 8208F4F0h case   15:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x48);
		/* 8208F4F0h case   15:*/		return 0x8208F4F4;
		  /* 8208F4F4h */ case   16:  		/* lwz R3, <#[R10 - 31244]> */
		/* 8208F4F4h case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0xFFFF85F4) );
		/* 8208F4F4h case   16:*/		return 0x8208F4F8;
		  /* 8208F4F8h */ case   17:  		/* bl 3400 */
		/* 8208F4F8h case   17:*/		regs.LR = 0x8208F4FC; return 0x82090240;
		/* 8208F4F8h case   17:*/		return 0x8208F4FC;
		  /* 8208F4FCh */ case   18:  		/* cmplwi CR6, R28, 0 */
		/* 8208F4FCh case   18:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8208F4FCh case   18:*/		return 0x8208F500;
		  /* 8208F500h */ case   19:  		/* bc 12, CR6_EQ, 84 */
		/* 8208F500h case   19:*/		if ( regs.CR[6].eq ) { return 0x8208F554;  }
		/* 8208F500h case   19:*/		return 0x8208F504;
		  /* 8208F504h */ case   20:  		/* lwz R11, <#[R31 + 12]> */
		/* 8208F504h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8208F504h case   20:*/		return 0x8208F508;
		  /* 8208F508h */ case   21:  		/* li R29, 0 */
		/* 8208F508h case   21:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8208F508h case   21:*/		return 0x8208F50C;
		  /* 8208F50Ch */ case   22:  		/* lwz R11, <#[R11 + 276]> */
		/* 8208F50Ch case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000114) );
		/* 8208F50Ch case   22:*/		return 0x8208F510;
		  /* 8208F510h */ case   23:  		/* cmplwi CR6, R11, 0 */
		/* 8208F510h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208F510h case   23:*/		return 0x8208F514;
		  /* 8208F514h */ case   24:  		/* bc 4, CR6_GT, 64 */
		/* 8208F514h case   24:*/		if ( !regs.CR[6].gt ) { return 0x8208F554;  }
		/* 8208F514h case   24:*/		return 0x8208F518;
		  /* 8208F518h */ case   25:  		/* li R30, 0 */
		/* 8208F518h case   25:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8208F518h case   25:*/		return 0x8208F51C;
		  /* 8208F51Ch */ case   26:  		/* lwz R11, <#[R31 + 12]> */
		/* 8208F51Ch case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8208F51Ch case   26:*/		return 0x8208F520;
		  /* 8208F520h */ case   27:  		/* mr R3, R28 */
		/* 8208F520h case   27:*/		regs.R3 = regs.R28;
		/* 8208F520h case   27:*/		return 0x8208F524;
		  /* 8208F524h */ case   28:  		/* add R11, R30, R11 */
		/* 8208F524h case   28:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 8208F524h case   28:*/		return 0x8208F528;
		  /* 8208F528h */ case   29:  		/* addi R4, R11, 352 */
		/* 8208F528h case   29:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x160);
		/* 8208F528h case   29:*/		return 0x8208F52C;
		  /* 8208F52Ch */ case   30:  		/* bl -6084 */
		/* 8208F52Ch case   30:*/		regs.LR = 0x8208F530; return 0x8208DD68;
		/* 8208F52Ch case   30:*/		return 0x8208F530;
		  /* 8208F530h */ case   31:  		/* lwz R11, <#[R31 + 12]> */
		/* 8208F530h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8208F530h case   31:*/		return 0x8208F534;
		  /* 8208F534h */ case   32:  		/* addi R29, R29, 1 */
		/* 8208F534h case   32:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8208F534h case   32:*/		return 0x8208F538;
		  /* 8208F538h */ case   33:  		/* add R11, R30, R11 */
		/* 8208F538h case   33:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 8208F538h case   33:*/		return 0x8208F53C;
		  /* 8208F53Ch */ case   34:  		/* addi R30, R30, 160 */
		/* 8208F53Ch case   34:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0xA0);
		/* 8208F53Ch case   34:*/		return 0x8208F540;
		  /* 8208F540h */ case   35:  		/* stw R3, <#[R11 + 348]> */
		/* 8208F540h case   35:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x0000015C) );
		/* 8208F540h case   35:*/		return 0x8208F544;
		  /* 8208F544h */ case   36:  		/* lwz R11, <#[R31 + 12]> */
		/* 8208F544h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8208F544h case   36:*/		return 0x8208F548;
		  /* 8208F548h */ case   37:  		/* lwz R11, <#[R11 + 276]> */
		/* 8208F548h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000114) );
		/* 8208F548h case   37:*/		return 0x8208F54C;
		  /* 8208F54Ch */ case   38:  		/* cmplw CR6, R29, R11 */
		/* 8208F54Ch case   38:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8208F54Ch case   38:*/		return 0x8208F550;
		  /* 8208F550h */ case   39:  		/* bc 12, CR6_LT, -52 */
		/* 8208F550h case   39:*/		if ( regs.CR[6].lt ) { return 0x8208F51C;  }
		/* 8208F550h case   39:*/		return 0x8208F554;
	}
	return 0x8208F554;
} // Block from 8208F4B4h-8208F554h (40 instructions)

//////////////////////////////////////////////////////
// Block at 8208F554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F554);
		  /* 8208F554h */ case    0:  		/* li R3, 0 */
		/* 8208F554h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208F554h case    0:*/		return 0x8208F558;
	}
	return 0x8208F558;
} // Block from 8208F554h-8208F558h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208F558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F558);
		  /* 8208F558h */ case    0:  		/* addi R1, R1, 160 */
		/* 8208F558h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 8208F558h case    0:*/		return 0x8208F55C;
		  /* 8208F55Ch */ case    1:  		/* b 7500 */
		/* 8208F55Ch case    1:*/		return 0x820912A8;
		/* 8208F55Ch case    1:*/		return 0x8208F560;
	}
	return 0x8208F560;
} // Block from 8208F558h-8208F560h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208F560h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F560);
		  /* 8208F560h */ case    0:  		/* mfspr R12, LR */
		/* 8208F560h case    0:*/		regs.R12 = regs.LR;
		/* 8208F560h case    0:*/		return 0x8208F564;
		  /* 8208F564h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8208F564h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208F564h case    1:*/		return 0x8208F568;
		  /* 8208F568h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8208F568h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208F568h case    2:*/		return 0x8208F56C;
		  /* 8208F56Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8208F56Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208F56Ch case    3:*/		return 0x8208F570;
		  /* 8208F570h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8208F570h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8208F570h case    4:*/		return 0x8208F574;
		  /* 8208F574h */ case    5:  		/* mr R31, R3 */
		/* 8208F574h case    5:*/		regs.R31 = regs.R3;
		/* 8208F574h case    5:*/		return 0x8208F578;
		  /* 8208F578h */ case    6:  		/* mr R30, R4 */
		/* 8208F578h case    6:*/		regs.R30 = regs.R4;
		/* 8208F578h case    6:*/		return 0x8208F57C;
		  /* 8208F57Ch */ case    7:  		/* bl -732 */
		/* 8208F57Ch case    7:*/		regs.LR = 0x8208F580; return 0x8208F2A0;
		/* 8208F57Ch case    7:*/		return 0x8208F580;
		  /* 8208F580h */ case    8:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 8208F580h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 8208F580h case    8:*/		return 0x8208F584;
		  /* 8208F584h */ case    9:  		/* bc 12, CR0_EQ, 12 */
		/* 8208F584h case    9:*/		if ( regs.CR[0].eq ) { return 0x8208F590;  }
		/* 8208F584h case    9:*/		return 0x8208F588;
		  /* 8208F588h */ case   10:  		/* mr R3, R31 */
		/* 8208F588h case   10:*/		regs.R3 = regs.R31;
		/* 8208F588h case   10:*/		return 0x8208F58C;
		  /* 8208F58Ch */ case   11:  		/* bl 11740 */
		/* 8208F58Ch case   11:*/		regs.LR = 0x8208F590; return 0x82092368;
		/* 8208F58Ch case   11:*/		return 0x8208F590;
	}
	return 0x8208F590;
} // Block from 8208F560h-8208F590h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8208F590h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F590( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F590) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F590);
		  /* 8208F590h */ case    0:  		/* mr R3, R31 */
		/* 8208F590h case    0:*/		regs.R3 = regs.R31;
		/* 8208F590h case    0:*/		return 0x8208F594;
		  /* 8208F594h */ case    1:  		/* addi R1, R1, 112 */
		/* 8208F594h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8208F594h case    1:*/		return 0x8208F598;
		  /* 8208F598h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 8208F598h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208F598h case    2:*/		return 0x8208F59C;
		  /* 8208F59Ch */ case    3:  		/* mtspr LR, R12 */
		/* 8208F59Ch case    3:*/		regs.LR = regs.R12;
		/* 8208F59Ch case    3:*/		return 0x8208F5A0;
		  /* 8208F5A0h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 8208F5A0h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8208F5A0h case    4:*/		return 0x8208F5A4;
		  /* 8208F5A4h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 8208F5A4h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208F5A4h case    5:*/		return 0x8208F5A8;
		  /* 8208F5A8h */ case    6:  		/* bclr 20, CR0_LT */
		/* 8208F5A8h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208F5A8h case    6:*/		return 0x8208F5AC;
	}
	return 0x8208F5AC;
} // Block from 8208F590h-8208F5ACh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208F5ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F5AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F5AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F5AC);
		  /* 8208F5ACh */ case    0:  		/* nop */
		/* 8208F5ACh case    0:*/		cpu::op::nop();
		/* 8208F5ACh case    0:*/		return 0x8208F5B0;
	}
	return 0x8208F5B0;
} // Block from 8208F5ACh-8208F5B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208F5B0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F5B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F5B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F5B0);
		  /* 8208F5B0h */ case    0:  		/* mfspr R12, LR */
		/* 8208F5B0h case    0:*/		regs.R12 = regs.LR;
		/* 8208F5B0h case    0:*/		return 0x8208F5B4;
		  /* 8208F5B4h */ case    1:  		/* bl 7332 */
		/* 8208F5B4h case    1:*/		regs.LR = 0x8208F5B8; return 0x82091258;
		/* 8208F5B4h case    1:*/		return 0x8208F5B8;
		  /* 8208F5B8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8208F5B8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8208F5B8h case    2:*/		return 0x8208F5BC;
		  /* 8208F5BCh */ case    3:  		/* lis R11, -32215 */
		/* 8208F5BCh case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8208F5BCh case    3:*/		return 0x8208F5C0;
		  /* 8208F5C0h */ case    4:  		/* lis R10, -32215 */
		/* 8208F5C0h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 8208F5C0h case    4:*/		return 0x8208F5C4;
		  /* 8208F5C4h */ case    5:  		/* lis R9, -32217 */
		/* 8208F5C4h case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8227);
		/* 8208F5C4h case    5:*/		return 0x8208F5C8;
		  /* 8208F5C8h */ case    6:  		/* addi R31, R11, -31240 */
		/* 8208F5C8h case    6:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFF85F8);
		/* 8208F5C8h case    6:*/		return 0x8208F5CC;
		  /* 8208F5CCh */ case    7:  		/* mr R30, R3 */
		/* 8208F5CCh case    7:*/		regs.R30 = regs.R3;
		/* 8208F5CCh case    7:*/		return 0x8208F5D0;
		  /* 8208F5D0h */ case    8:  		/* addi R7, R9, 6928 */
		/* 8208F5D0h case    8:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R9,0x1B10);
		/* 8208F5D0h case    8:*/		return 0x8208F5D4;
		  /* 8208F5D4h */ case    9:  		/* mr R8, R31 */
		/* 8208F5D4h case    9:*/		regs.R8 = regs.R31;
		/* 8208F5D4h case    9:*/		return 0x8208F5D8;
		  /* 8208F5D8h */ case   10:  		/* lwz R6, <#[R10 - 31236]> */
		/* 8208F5D8h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0xFFFF85FC) );
		/* 8208F5D8h case   10:*/		return 0x8208F5DC;
		  /* 8208F5DCh */ case   11:  		/* li R5, 0 */
		/* 8208F5DCh case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8208F5DCh case   11:*/		return 0x8208F5E0;
		  /* 8208F5E0h */ case   12:  		/* li R4, 1 */
		/* 8208F5E0h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8208F5E0h case   12:*/		return 0x8208F5E4;
		  /* 8208F5E4h */ case   13:  		/* li R3, 0 */
		/* 8208F5E4h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208F5E4h case   13:*/		return 0x8208F5E8;
		  /* 8208F5E8h */ case   14:  		/* bl -74360 */
		/* 8208F5E8h case   14:*/		regs.LR = 0x8208F5EC; return 0x8207D370;
		/* 8208F5E8h case   14:*/		return 0x8208F5EC;
		  /* 8208F5ECh */ case   15:  		/* lis R11, -32256 */
		/* 8208F5ECh case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8208F5ECh case   15:*/		return 0x8208F5F0;
		  /* 8208F5F0h */ case   16:  		/* lis R10, -32255 */
		/* 8208F5F0h case   16:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8208F5F0h case   16:*/		return 0x8208F5F4;
		  /* 8208F5F4h */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 8208F5F4h case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208F5F4h case   17:*/		return 0x8208F5F8;
		  /* 8208F5F8h */ case   18:  		/* addi R29, R11, 2596 */
		/* 8208F5F8h case   18:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xA24);
		/* 8208F5F8h case   18:*/		return 0x8208F5FC;
		  /* 8208F5FCh */ case   19:  		/* addi R28, R10, -26676 */
		/* 8208F5FCh case   19:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R10,0xFFFF97CC);
		/* 8208F5FCh case   19:*/		return 0x8208F600;
		  /* 8208F600h */ case   20:  		/* bc 4, CR0_LT, 36 */
		/* 8208F600h case   20:*/		if ( !regs.CR[0].lt ) { return 0x8208F624;  }
		/* 8208F600h case   20:*/		return 0x8208F604;
		  /* 8208F604h */ case   21:  		/* mr R4, R28 */
		/* 8208F604h case   21:*/		regs.R4 = regs.R28;
		/* 8208F604h case   21:*/		return 0x8208F608;
		  /* 8208F608h */ case   22:  		/* mr R3, R29 */
		/* 8208F608h case   22:*/		regs.R3 = regs.R29;
		/* 8208F608h case   22:*/		return 0x8208F60C;
		  /* 8208F60Ch */ case   23:  		/* li R5, 68 */
		/* 8208F60Ch case   23:*/		cpu::op::li<0>(regs,&regs.R5,0x44);
		/* 8208F60Ch case   23:*/		return 0x8208F610;
		  /* 8208F610h */ case   24:  		/* bl 808 */
		/* 8208F610h case   24:*/		regs.LR = 0x8208F614; return 0x8208F938;
		/* 8208F610h case   24:*/		return 0x8208F614;
		  /* 8208F614h */ case   25:  		/* lis R11, -32255 */
		/* 8208F614h case   25:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208F614h case   25:*/		return 0x8208F618;
		  /* 8208F618h */ case   26:  		/* addi R3, R11, -26708 */
		/* 8208F618h case   26:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF97AC);
		/* 8208F618h case   26:*/		return 0x8208F61C;
		  /* 8208F61Ch */ case   27:  		/* bl 796 */
		/* 8208F61Ch case   27:*/		regs.LR = 0x8208F620; return 0x8208F938;
		/* 8208F61Ch case   27:*/		return 0x8208F620;
		  /* 8208F620h */ case   28:  		/* bl 1932352 */
		/* 8208F620h case   28:*/		regs.LR = 0x8208F624; return 0x82267260;
		/* 8208F620h case   28:*/		return 0x8208F624;
	}
	return 0x8208F624;
} // Block from 8208F5B0h-8208F624h (29 instructions)

//////////////////////////////////////////////////////
// Block at 8208F624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F624);
		  /* 8208F624h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8208F624h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8208F624h case    0:*/		return 0x8208F628;
		  /* 8208F628h */ case    1:  		/* lis R10, -32215 */
		/* 8208F628h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 8208F628h case    1:*/		return 0x8208F62C;
		  /* 8208F62Ch */ case    2:  		/* mr R3, R30 */
		/* 8208F62Ch case    2:*/		regs.R3 = regs.R30;
		/* 8208F62Ch case    2:*/		return 0x8208F630;
		  /* 8208F630h */ case    3:  		/* stw R11, <#[R10 - 31244]> */
		/* 8208F630h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0xFFFF85F4) );
		/* 8208F630h case    3:*/		return 0x8208F634;
		  /* 8208F634h */ case    4:  		/* lwz R11, <#[R30]> */
		/* 8208F634h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8208F634h case    4:*/		return 0x8208F638;
		  /* 8208F638h */ case    5:  		/* lwz R11, <#[R11]> */
		/* 8208F638h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8208F638h case    5:*/		return 0x8208F63C;
		  /* 8208F63Ch */ case    6:  		/* mtspr CTR, R11 */
		/* 8208F63Ch case    6:*/		regs.CTR = regs.R11;
		/* 8208F63Ch case    6:*/		return 0x8208F640;
		  /* 8208F640h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 8208F640h case    7:*/		if ( 1 ) { regs.LR = 0x8208F644; return (uint32)regs.CTR; }
		/* 8208F640h case    7:*/		return 0x8208F644;
		  /* 8208F644h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 8208F644h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208F644h case    8:*/		return 0x8208F648;
		  /* 8208F648h */ case    9:  		/* bc 4, CR0_LT, 36 */
		/* 8208F648h case    9:*/		if ( !regs.CR[0].lt ) { return 0x8208F66C;  }
		/* 8208F648h case    9:*/		return 0x8208F64C;
		  /* 8208F64Ch */ case   10:  		/* mr R4, R28 */
		/* 8208F64Ch case   10:*/		regs.R4 = regs.R28;
		/* 8208F64Ch case   10:*/		return 0x8208F650;
		  /* 8208F650h */ case   11:  		/* mr R3, R29 */
		/* 8208F650h case   11:*/		regs.R3 = regs.R29;
		/* 8208F650h case   11:*/		return 0x8208F654;
		  /* 8208F654h */ case   12:  		/* li R5, 80 */
		/* 8208F654h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x50);
		/* 8208F654h case   12:*/		return 0x8208F658;
		  /* 8208F658h */ case   13:  		/* bl 736 */
		/* 8208F658h case   13:*/		regs.LR = 0x8208F65C; return 0x8208F938;
		/* 8208F658h case   13:*/		return 0x8208F65C;
		  /* 8208F65Ch */ case   14:  		/* lis R11, -32255 */
		/* 8208F65Ch case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208F65Ch case   14:*/		return 0x8208F660;
		  /* 8208F660h */ case   15:  		/* addi R3, R11, -26740 */
		/* 8208F660h case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF978C);
		/* 8208F660h case   15:*/		return 0x8208F664;
		  /* 8208F664h */ case   16:  		/* bl 724 */
		/* 8208F664h case   16:*/		regs.LR = 0x8208F668; return 0x8208F938;
		/* 8208F664h case   16:*/		return 0x8208F668;
		  /* 8208F668h */ case   17:  		/* bl 1932280 */
		/* 8208F668h case   17:*/		regs.LR = 0x8208F66C; return 0x82267260;
		/* 8208F668h case   17:*/		return 0x8208F66C;
	}
	return 0x8208F66C;
} // Block from 8208F624h-8208F66Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 8208F66Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F66C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F66C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F66C);
		  /* 8208F66Ch */ case    0:  		/* lwz R11, <#[R30]> */
		/* 8208F66Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8208F66Ch case    0:*/		return 0x8208F670;
		  /* 8208F670h */ case    1:  		/* mr R3, R30 */
		/* 8208F670h case    1:*/		regs.R3 = regs.R30;
		/* 8208F670h case    1:*/		return 0x8208F674;
		  /* 8208F674h */ case    2:  		/* lwz R11, <#[R11 + 4]> */
		/* 8208F674h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8208F674h case    2:*/		return 0x8208F678;
		  /* 8208F678h */ case    3:  		/* mtspr CTR, R11 */
		/* 8208F678h case    3:*/		regs.CTR = regs.R11;
		/* 8208F678h case    3:*/		return 0x8208F67C;
		  /* 8208F67Ch */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8208F67Ch case    4:*/		if ( 1 ) { regs.LR = 0x8208F680; return (uint32)regs.CTR; }
		/* 8208F67Ch case    4:*/		return 0x8208F680;
		  /* 8208F680h */ case    5:  		/* lwz R11, <#[R30]> */
		/* 8208F680h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8208F680h case    5:*/		return 0x8208F684;
		  /* 8208F684h */ case    6:  		/* mr R3, R30 */
		/* 8208F684h case    6:*/		regs.R3 = regs.R30;
		/* 8208F684h case    6:*/		return 0x8208F688;
		  /* 8208F688h */ case    7:  		/* lwz R11, <#[R11 + 8]> */
		/* 8208F688h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8208F688h case    7:*/		return 0x8208F68C;
		  /* 8208F68Ch */ case    8:  		/* mtspr CTR, R11 */
		/* 8208F68Ch case    8:*/		regs.CTR = regs.R11;
		/* 8208F68Ch case    8:*/		return 0x8208F690;
	}
	return 0x8208F690;
} // Block from 8208F66Ch-8208F690h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8208F690h
// Function 'RtlSizeHeap'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F690);
		  /* 8208F690h */ case    0:  		/* bcctrl 20, CR0_LT */
		/* 8208F690h case    0:*/		if ( 1 ) { regs.LR = 0x8208F694; return (uint32)regs.CTR; }
		/* 8208F690h case    0:*/		return 0x8208F694;
		  /* 8208F694h */ case    1:  		/* b -40 */
		/* 8208F694h case    1:*/		return 0x8208F66C;
		/* 8208F694h case    1:*/		return 0x8208F698;
	}
	return 0x8208F698;
} // Block from 8208F690h-8208F698h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208F698h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F698);
		  /* 8208F698h */ case    0:  		/* mfspr R12, LR */
		/* 8208F698h case    0:*/		regs.R12 = regs.LR;
		/* 8208F698h case    0:*/		return 0x8208F69C;
		  /* 8208F69Ch */ case    1:  		/* bl 7104 */
		/* 8208F69Ch case    1:*/		regs.LR = 0x8208F6A0; return 0x8209125C;
		/* 8208F69Ch case    1:*/		return 0x8208F6A0;
		  /* 8208F6A0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 8208F6A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 8208F6A0h case    2:*/		return 0x8208F6A4;
		  /* 8208F6A4h */ case    3:  		/* mr R30, R3 */
		/* 8208F6A4h case    3:*/		regs.R30 = regs.R3;
		/* 8208F6A4h case    3:*/		return 0x8208F6A8;
		  /* 8208F6A8h */ case    4:  		/* addi R3, R1, 80 */
		/* 8208F6A8h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8208F6A8h case    4:*/		return 0x8208F6AC;
		  /* 8208F6ACh */ case    5:  		/* mr R29, R4 */
		/* 8208F6ACh case    5:*/		regs.R29 = regs.R4;
		/* 8208F6ACh case    5:*/		return 0x8208F6B0;
		  /* 8208F6B0h */ case    6:  		/* mr R31, R5 */
		/* 8208F6B0h case    6:*/		regs.R31 = regs.R5;
		/* 8208F6B0h case    6:*/		return 0x8208F6B4;
		  /* 8208F6B4h */ case    7:  		/* bl 1957348 */
		/* 8208F6B4h case    7:*/		regs.LR = 0x8208F6B8; return 0x8226D498;
		/* 8208F6B4h case    7:*/		return 0x8208F6B8;
		  /* 8208F6B8h */ case    8:  		/* cmplwi CR6, R31, 0 */
		/* 8208F6B8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8208F6B8h case    8:*/		return 0x8208F6BC;
		  /* 8208F6BCh */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 8208F6BCh case    9:*/		if ( regs.CR[6].eq ) { return 0x8208F6C8;  }
		/* 8208F6BCh case    9:*/		return 0x8208F6C0;
		  /* 8208F6C0h */ case   10:  		/* lwz R11, <#[R1 + 92]> */
		/* 8208F6C0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8208F6C0h case   10:*/		return 0x8208F6C4;
		  /* 8208F6C4h */ case   11:  		/* stw R11, <#[R31]> */
		/* 8208F6C4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8208F6C4h case   11:*/		return 0x8208F6C8;
	}
	return 0x8208F6C8;
} // Block from 8208F698h-8208F6C8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8208F6C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F6C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F6C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F6C8);
		  /* 8208F6C8h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 8208F6C8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8208F6C8h case    0:*/		return 0x8208F6CC;
		  /* 8208F6CCh */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8208F6CCh case    1:*/		if ( regs.CR[6].eq ) { return 0x8208F6D8;  }
		/* 8208F6CCh case    1:*/		return 0x8208F6D0;
		  /* 8208F6D0h */ case    2:  		/* li R11, 1280 */
		/* 8208F6D0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x500);
		/* 8208F6D0h case    2:*/		return 0x8208F6D4;
		  /* 8208F6D4h */ case    3:  		/* stw R11, <#[R30]> */
		/* 8208F6D4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8208F6D4h case    3:*/		return 0x8208F6D8;
	}
	return 0x8208F6D8;
} // Block from 8208F6C8h-8208F6D8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208F6D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F6D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F6D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F6D8);
		  /* 8208F6D8h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 8208F6D8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8208F6D8h case    0:*/		return 0x8208F6DC;
		  /* 8208F6DCh */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8208F6DCh case    1:*/		if ( regs.CR[6].eq ) { return 0x8208F6E8;  }
		/* 8208F6DCh case    1:*/		return 0x8208F6E0;
		  /* 8208F6E0h */ case    2:  		/* li R11, 720 */
		/* 8208F6E0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x2D0);
		/* 8208F6E0h case    2:*/		return 0x8208F6E4;
		  /* 8208F6E4h */ case    3:  		/* stw R11, <#[R29]> */
		/* 8208F6E4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8208F6E4h case    3:*/		return 0x8208F6E8;
	}
	return 0x8208F6E8;
} // Block from 8208F6D8h-8208F6E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208F6E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F6E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F6E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F6E8);
		  /* 8208F6E8h */ case    0:  		/* addi R1, R1, 160 */
		/* 8208F6E8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 8208F6E8h case    0:*/		return 0x8208F6EC;
		  /* 8208F6ECh */ case    1:  		/* b 7104 */
		/* 8208F6ECh case    1:*/		return 0x820912AC;
		/* 8208F6ECh case    1:*/		return 0x8208F6F0;
	}
	return 0x8208F6F0;
} // Block from 8208F6E8h-8208F6F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208F6F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F6F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F6F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F6F0);
		  /* 8208F6F0h */ case    0:  		/* mfspr R12, LR */
		/* 8208F6F0h case    0:*/		regs.R12 = regs.LR;
		/* 8208F6F0h case    0:*/		return 0x8208F6F4;
		  /* 8208F6F4h */ case    1:  		/* bl 7008 */
		/* 8208F6F4h case    1:*/		regs.LR = 0x8208F6F8; return 0x82091254;
		/* 8208F6F4h case    1:*/		return 0x8208F6F8;
		  /* 8208F6F8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8208F6F8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8208F6F8h case    2:*/		return 0x8208F6FC;
		  /* 8208F6FCh */ case    3:  		/* mr R27, R4 */
		/* 8208F6FCh case    3:*/		regs.R27 = regs.R4;
		/* 8208F6FCh case    3:*/		return 0x8208F700;
		  /* 8208F700h */ case    4:  		/* mr R28, R5 */
		/* 8208F700h case    4:*/		regs.R28 = regs.R5;
		/* 8208F700h case    4:*/		return 0x8208F704;
		  /* 8208F704h */ case    5:  		/* cmplwi CR6, R5, 0 */
		/* 8208F704h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8208F704h case    5:*/		return 0x8208F708;
		  /* 8208F708h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 8208F708h case    6:*/		if ( regs.CR[6].eq ) { return 0x8208F714;  }
		/* 8208F708h case    6:*/		return 0x8208F70C;
		  /* 8208F70Ch */ case    7:  		/* li R11, 0 */
		/* 8208F70Ch case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8208F70Ch case    7:*/		return 0x8208F710;
		  /* 8208F710h */ case    8:  		/* stw R11, <#[R5]> */
		/* 8208F710h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8208F710h case    8:*/		return 0x8208F714;
	}
	return 0x8208F714;
} // Block from 8208F6F0h-8208F714h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8208F714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F714);
		  /* 8208F714h */ case    0:  		/* li R9, 0 */
		/* 8208F714h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8208F714h case    0:*/		return 0x8208F718;
		  /* 8208F718h */ case    1:  		/* li R8, 0 */
		/* 8208F718h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8208F718h case    1:*/		return 0x8208F71C;
		  /* 8208F71Ch */ case    2:  		/* li R7, 3 */
		/* 8208F71Ch case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 8208F71Ch case    2:*/		return 0x8208F720;
		  /* 8208F720h */ case    3:  		/* li R6, 0 */
		/* 8208F720h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8208F720h case    3:*/		return 0x8208F724;
		  /* 8208F724h */ case    4:  		/* li R5, 0 */
		/* 8208F724h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8208F724h case    4:*/		return 0x8208F728;
		  /* 8208F728h */ case    5:  		/* lis R4, -32768 */
		/* 8208F728h case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8000);
		/* 8208F728h case    5:*/		return 0x8208F72C;
		  /* 8208F72Ch */ case    6:  		/* bl -27196 */
		/* 8208F72Ch case    6:*/		regs.LR = 0x8208F730; return 0x82088CF0;
		/* 8208F72Ch case    6:*/		return 0x8208F730;
		  /* 8208F730h */ case    7:  		/* mr R31, R3 */
		/* 8208F730h case    7:*/		regs.R31 = regs.R3;
		/* 8208F730h case    7:*/		return 0x8208F734;
		  /* 8208F734h */ case    8:  		/* cmpwi CR6, R3, -1 */
		/* 8208F734h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8208F734h case    8:*/		return 0x8208F738;
	}
	return 0x8208F738;
} // Block from 8208F714h-8208F738h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8208F738h
// Function 'RtlpInitializeHeapSegment'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F738);
		  /* 8208F738h */ case    0:  		/* bc 4, CR6_EQ, 16 */
		/* 8208F738h case    0:*/		if ( !regs.CR[6].eq ) { return 0x8208F748;  }
		/* 8208F738h case    0:*/		return 0x8208F73C;
		  /* 8208F73Ch */ case    1:  		/* lis R3, -32761 */
		/* 8208F73Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 8208F73Ch case    1:*/		return 0x8208F740;
		  /* 8208F740h */ case    2:  		/* ori R3, R3, 6 */
		/* 8208F740h case    2:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x6);
		/* 8208F740h case    2:*/		return 0x8208F744;
		  /* 8208F744h */ case    3:  		/* b 144 */
		/* 8208F744h case    3:*/		return 0x8208F7D4;
		/* 8208F744h case    3:*/		return 0x8208F748;
	}
	return 0x8208F748;
} // Block from 8208F738h-8208F748h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208F748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F748);
		  /* 8208F748h */ case    0:  		/* li R4, 0 */
		/* 8208F748h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208F748h case    0:*/		return 0x8208F74C;
		  /* 8208F74Ch */ case    1:  		/* mr R3, R31 */
		/* 8208F74Ch case    1:*/		regs.R3 = regs.R31;
		/* 8208F74Ch case    1:*/		return 0x8208F750;
		  /* 8208F750h */ case    2:  		/* bl 1932056 */
		/* 8208F750h case    2:*/		regs.LR = 0x8208F754; return 0x82267268;
		/* 8208F750h case    2:*/		return 0x8208F754;
		  /* 8208F754h */ case    3:  		/* mr R30, R3 */
		/* 8208F754h case    3:*/		regs.R30 = regs.R3;
		/* 8208F754h case    3:*/		return 0x8208F758;
		  /* 8208F758h */ case    4:  		/* bl 16688 */
		/* 8208F758h case    4:*/		regs.LR = 0x8208F75C; return 0x82093888;
		/* 8208F758h case    4:*/		return 0x8208F75C;
		  /* 8208F75Ch */ case    5:  		/* or. R29, R3, R3 */
		/* 8208F75Ch case    5:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 8208F75Ch case    5:*/		return 0x8208F760;
		  /* 8208F760h */ case    6:  		/* mr R3, R31 */
		/* 8208F760h case    6:*/		regs.R3 = regs.R31;
		/* 8208F760h case    6:*/		return 0x8208F764;
		  /* 8208F764h */ case    7:  		/* bc 4, CR0_EQ, 20 */
		/* 8208F764h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8208F778;  }
		/* 8208F764h case    7:*/		return 0x8208F768;
		  /* 8208F768h */ case    8:  		/* bl -28512 */
		/* 8208F768h case    8:*/		regs.LR = 0x8208F76C; return 0x82088808;
		/* 8208F768h case    8:*/		return 0x8208F76C;
		  /* 8208F76Ch */ case    9:  		/* lis R3, -32761 */
		/* 8208F76Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 8208F76Ch case    9:*/		return 0x8208F770;
		  /* 8208F770h */ case   10:  		/* ori R3, R3, 14 */
		/* 8208F770h case   10:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 8208F770h case   10:*/		return 0x8208F774;
		  /* 8208F774h */ case   11:  		/* b 96 */
		/* 8208F774h case   11:*/		return 0x8208F7D4;
		/* 8208F774h case   11:*/		return 0x8208F778;
	}
	return 0x8208F778;
} // Block from 8208F748h-8208F778h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8208F778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F778);
		  /* 8208F778h */ case    0:  		/* li R7, 0 */
		/* 8208F778h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8208F778h case    0:*/		return 0x8208F77C;
		  /* 8208F77Ch */ case    1:  		/* addi R6, R1, 80 */
		/* 8208F77Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 8208F77Ch case    1:*/		return 0x8208F780;
		  /* 8208F780h */ case    2:  		/* mr R5, R30 */
		/* 8208F780h case    2:*/		regs.R5 = regs.R30;
		/* 8208F780h case    2:*/		return 0x8208F784;
		  /* 8208F784h */ case    3:  		/* mr R4, R29 */
		/* 8208F784h case    3:*/		regs.R4 = regs.R29;
		/* 8208F784h case    3:*/		return 0x8208F788;
		  /* 8208F788h */ case    4:  		/* bl 1931608 */
		/* 8208F788h case    4:*/		regs.LR = 0x8208F78C; return 0x822670E0;
		/* 8208F788h case    4:*/		return 0x8208F78C;
		  /* 8208F78Ch */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 8208F78Ch case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208F78Ch case    5:*/		return 0x8208F790;
		  /* 8208F790h */ case    6:  		/* mr R3, R31 */
		/* 8208F790h case    6:*/		regs.R3 = regs.R31;
		/* 8208F790h case    6:*/		return 0x8208F794;
		  /* 8208F794h */ case    7:  		/* bc 4, CR0_EQ, 28 */
		/* 8208F794h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8208F7B0;  }
		/* 8208F794h case    7:*/		return 0x8208F798;
		  /* 8208F798h */ case    8:  		/* bl -28560 */
		/* 8208F798h case    8:*/		regs.LR = 0x8208F79C; return 0x82088808;
		/* 8208F798h case    8:*/		return 0x8208F79C;
		  /* 8208F79Ch */ case    9:  		/* mr R3, R29 */
		/* 8208F79Ch case    9:*/		regs.R3 = regs.R29;
		/* 8208F79Ch case    9:*/		return 0x8208F7A0;
		  /* 8208F7A0h */ case   10:  		/* bl 16520 */
		/* 8208F7A0h case   10:*/		regs.LR = 0x8208F7A4; return 0x82093828;
		/* 8208F7A0h case   10:*/		return 0x8208F7A4;
		  /* 8208F7A4h */ case   11:  		/* lis R3, -32768 */
		/* 8208F7A4h case   11:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8208F7A4h case   11:*/		return 0x8208F7A8;
		  /* 8208F7A8h */ case   12:  		/* ori R3, R3, 16389 */
		/* 8208F7A8h case   12:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8208F7A8h case   12:*/		return 0x8208F7AC;
		  /* 8208F7ACh */ case   13:  		/* b 40 */
		/* 8208F7ACh case   13:*/		return 0x8208F7D4;
		/* 8208F7ACh case   13:*/		return 0x8208F7B0;
	}
	return 0x8208F7B0;
} // Block from 8208F778h-8208F7B0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8208F7B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F7B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F7B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F7B0);
		  /* 8208F7B0h */ case    0:  		/* bl -28584 */
		/* 8208F7B0h case    0:*/		regs.LR = 0x8208F7B4; return 0x82088808;
		/* 8208F7B0h case    0:*/		return 0x8208F7B4;
		  /* 8208F7B4h */ case    1:  		/* lwz R11, <#[R1 + 80]> */
		/* 8208F7B4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208F7B4h case    1:*/		return 0x8208F7B8;
		  /* 8208F7B8h */ case    2:  		/* cmplw CR6, R11, R30 */
		/* 8208F7B8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 8208F7B8h case    2:*/		return 0x8208F7BC;
		  /* 8208F7BCh */ case    3:  		/* bc 4, CR6_EQ, -32 */
		/* 8208F7BCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x8208F79C;  }
		/* 8208F7BCh case    3:*/		return 0x8208F7C0;
		  /* 8208F7C0h */ case    4:  		/* cmplwi CR6, R28, 0 */
		/* 8208F7C0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8208F7C0h case    4:*/		return 0x8208F7C4;
		  /* 8208F7C4h */ case    5:  		/* bc 12, CR6_EQ, 8 */
		/* 8208F7C4h case    5:*/		if ( regs.CR[6].eq ) { return 0x8208F7CC;  }
		/* 8208F7C4h case    5:*/		return 0x8208F7C8;
		  /* 8208F7C8h */ case    6:  		/* stw R30, <#[R28]> */
		/* 8208F7C8h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R28 + 0x00000000) );
		/* 8208F7C8h case    6:*/		return 0x8208F7CC;
	}
	return 0x8208F7CC;
} // Block from 8208F7B0h-8208F7CCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208F7CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F7CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F7CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F7CC);
		  /* 8208F7CCh */ case    0:  		/* stw R29, <#[R27]> */
		/* 8208F7CCh case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R27 + 0x00000000) );
		/* 8208F7CCh case    0:*/		return 0x8208F7D0;
		  /* 8208F7D0h */ case    1:  		/* li R3, 0 */
		/* 8208F7D0h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208F7D0h case    1:*/		return 0x8208F7D4;
	}
	return 0x8208F7D4;
} // Block from 8208F7CCh-8208F7D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208F7D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F7D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F7D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F7D4);
		  /* 8208F7D4h */ case    0:  		/* addi R1, R1, 144 */
		/* 8208F7D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8208F7D4h case    0:*/		return 0x8208F7D8;
		  /* 8208F7D8h */ case    1:  		/* b 6860 */
		/* 8208F7D8h case    1:*/		return 0x820912A4;
		/* 8208F7D8h case    1:*/		return 0x8208F7DC;
		  /* 8208F7DCh */ case    2:  		/* nop */
		/* 8208F7DCh case    2:*/		cpu::op::nop();
		/* 8208F7DCh case    2:*/		return 0x8208F7E0;
	}
	return 0x8208F7E0;
} // Block from 8208F7D4h-8208F7E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208F7E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F7E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F7E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F7E0);
		  /* 8208F7E0h */ case    0:  		/* mfspr R12, LR */
		/* 8208F7E0h case    0:*/		regs.R12 = regs.LR;
		/* 8208F7E0h case    0:*/		return 0x8208F7E4;
		  /* 8208F7E4h */ case    1:  		/* bl 6776 */
		/* 8208F7E4h case    1:*/		regs.LR = 0x8208F7E8; return 0x8209125C;
		/* 8208F7E4h case    1:*/		return 0x8208F7E8;
		  /* 8208F7E8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8208F7E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8208F7E8h case    2:*/		return 0x8208F7EC;
		  /* 8208F7ECh */ case    3:  		/* li R30, 0 */
		/* 8208F7ECh case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8208F7ECh case    3:*/		return 0x8208F7F0;
		  /* 8208F7F0h */ case    4:  		/* addi R5, R1, 80 */
		/* 8208F7F0h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8208F7F0h case    4:*/		return 0x8208F7F4;
		  /* 8208F7F4h */ case    5:  		/* stw R30, <#[R1 + 80]> */
		/* 8208F7F4h case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 8208F7F4h case    5:*/		return 0x8208F7F8;
		  /* 8208F7F8h */ case    6:  		/* addi R4, R1, 88 */
		/* 8208F7F8h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x58);
		/* 8208F7F8h case    6:*/		return 0x8208F7FC;
		  /* 8208F7FCh */ case    7:  		/* bl -152828 */
		/* 8208F7FCh case    7:*/		regs.LR = 0x8208F800; return 0x8206A300;
		/* 8208F7FCh case    7:*/		return 0x8208F800;
		  /* 8208F800h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 8208F800h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208F800h case    8:*/		return 0x8208F804;
		  /* 8208F804h */ case    9:  		/* bc 12, CR0_LT, 96 */
		/* 8208F804h case    9:*/		if ( regs.CR[0].lt ) { return 0x8208F864;  }
		/* 8208F804h case    9:*/		return 0x8208F808;
		  /* 8208F808h */ case   10:  		/* lwz R31, <#[R1 + 80]> */
		/* 8208F808h case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 8208F808h case   10:*/		return 0x8208F80C;
		  /* 8208F80Ch */ case   11:  		/* cmplwi CR6, R31, 0 */
		/* 8208F80Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8208F80Ch case   11:*/		return 0x8208F810;
		  /* 8208F810h */ case   12:  		/* bc 12, CR6_EQ, 84 */
		/* 8208F810h case   12:*/		if ( regs.CR[6].eq ) { return 0x8208F864;  }
		/* 8208F810h case   12:*/		return 0x8208F814;
		  /* 8208F814h */ case   13:  		/* mr R3, R31 */
		/* 8208F814h case   13:*/		regs.R3 = regs.R31;
		/* 8208F814h case   13:*/		return 0x8208F818;
		  /* 8208F818h */ case   14:  		/* bl 16496 */
		/* 8208F818h case   14:*/		regs.LR = 0x8208F81C; return 0x82093888;
		/* 8208F818h case   14:*/		return 0x8208F81C;
		  /* 8208F81Ch */ case   15:  		/* mr R29, R3 */
		/* 8208F81Ch case   15:*/		regs.R29 = regs.R3;
		/* 8208F81Ch case   15:*/		return 0x8208F820;
		  /* 8208F820h */ case   16:  		/* mr R5, R31 */
		/* 8208F820h case   16:*/		regs.R5 = regs.R31;
		/* 8208F820h case   16:*/		return 0x8208F824;
		  /* 8208F824h */ case   17:  		/* lwz R3, <#[R1 + 88]> */
		/* 8208F824h case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000058) );
		/* 8208F824h case   17:*/		return 0x8208F828;
		  /* 8208F828h */ case   18:  		/* mr R4, R29 */
		/* 8208F828h case   18:*/		regs.R4 = regs.R29;
		/* 8208F828h case   18:*/		return 0x8208F82C;
		  /* 8208F82Ch */ case   19:  		/* bl -152796 */
		/* 8208F82Ch case   19:*/		regs.LR = 0x8208F830; return 0x8206A350;
		/* 8208F82Ch case   19:*/		return 0x8208F830;
		  /* 8208F830h */ case   20:  		/* stw R30, <#[R1 + 84]> */
		/* 8208F830h case   20:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 8208F830h case   20:*/		return 0x8208F834;
		  /* 8208F834h */ case   21:  		/* mr R3, R29 */
		/* 8208F834h case   21:*/		regs.R3 = regs.R29;
		/* 8208F834h case   21:*/		return 0x8208F838;
		  /* 8208F838h */ case   22:  		/* lwz R4, <#[R1 + 80]> */
		/* 8208F838h case   22:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 8208F838h case   22:*/		return 0x8208F83C;
		  /* 8208F83Ch */ case   23:  		/* addi R5, R1, 84 */
		/* 8208F83Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 8208F83Ch case   23:*/		return 0x8208F840;
		  /* 8208F840h */ case   24:  		/* bl 66160 */
		/* 8208F840h case   24:*/		regs.LR = 0x8208F844; return 0x8209FAB0;
		/* 8208F840h case   24:*/		return 0x8208F844;
		  /* 8208F844h */ case   25:  		/* mr R31, R3 */
		/* 8208F844h case   25:*/		regs.R31 = regs.R3;
		/* 8208F844h case   25:*/		return 0x8208F848;
		  /* 8208F848h */ case   26:  		/* mr R3, R29 */
		/* 8208F848h case   26:*/		regs.R3 = regs.R29;
		/* 8208F848h case   26:*/		return 0x8208F84C;
		  /* 8208F84Ch */ case   27:  		/* bl 16348 */
		/* 8208F84Ch case   27:*/		regs.LR = 0x8208F850; return 0x82093828;
		/* 8208F84Ch case   27:*/		return 0x8208F850;
		  /* 8208F850h */ case   28:  		/* rlwinm R11, R31, 1, 31, 31 */
		/* 8208F850h case   28:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R31);
		/* 8208F850h case   28:*/		return 0x8208F854;
		  /* 8208F854h */ case   29:  		/* lwz R10, <#[R1 + 84]> */
		/* 8208F854h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 8208F854h case   29:*/		return 0x8208F858;
		  /* 8208F858h */ case   30:  		/* addi R11, R11, -1 */
		/* 8208F858h case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8208F858h case   30:*/		return 0x8208F85C;
		  /* 8208F85Ch */ case   31:  		/* and R3, R11, R10 */
		/* 8208F85Ch case   31:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 8208F85Ch case   31:*/		return 0x8208F860;
		  /* 8208F860h */ case   32:  		/* b 8 */
		/* 8208F860h case   32:*/		return 0x8208F868;
		/* 8208F860h case   32:*/		return 0x8208F864;
	}
	return 0x8208F864;
} // Block from 8208F7E0h-8208F864h (33 instructions)

//////////////////////////////////////////////////////
// Block at 8208F864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F864);
		  /* 8208F864h */ case    0:  		/* li R3, 0 */
		/* 8208F864h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208F864h case    0:*/		return 0x8208F868;
	}
	return 0x8208F868;
} // Block from 8208F864h-8208F868h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208F868h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F868);
		  /* 8208F868h */ case    0:  		/* addi R1, R1, 128 */
		/* 8208F868h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8208F868h case    0:*/		return 0x8208F86C;
		  /* 8208F86Ch */ case    1:  		/* b 6720 */
		/* 8208F86Ch case    1:*/		return 0x820912AC;
		/* 8208F86Ch case    1:*/		return 0x8208F870;
	}
	return 0x8208F870;
} // Block from 8208F868h-8208F870h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208F870h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F870);
		  /* 8208F870h */ case    0:  		/* lhz R11, <#[R3]> */
		/* 8208F870h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8208F870h case    0:*/		return 0x8208F874;
		  /* 8208F874h */ case    1:  		/* b 20 */
		/* 8208F874h case    1:*/		return 0x8208F888;
		/* 8208F874h case    1:*/		return 0x8208F878;
		  /* 8208F878h */ case    2:  		/* lwz R11, <#[R3 + 4]> */
		/* 8208F878h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8208F878h case    2:*/		return 0x8208F87C;
		  /* 8208F87Ch */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8208F87Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208F87Ch case    3:*/		return 0x8208F880;
		  /* 8208F880h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 8208F880h case    4:*/		if ( regs.CR[6].eq ) { return 0x8208F890;  }
		/* 8208F880h case    4:*/		return 0x8208F884;
		  /* 8208F884h */ case    5:  		/* lhzu R11, <#[R3 + 12]> */
		/* 8208F884h case    5:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		regs.R3 = (uint32)(regs.R3 + 0x0000000C);
		/* 8208F884h case    5:*/		return 0x8208F888;
	}
	return 0x8208F888;
} // Block from 8208F870h-8208F888h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208F888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F888);
		  /* 8208F888h */ case    0:  		/* cmplwi CR6, R11, 255 */
		/* 8208F888h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000000FF);
		/* 8208F888h case    0:*/		return 0x8208F88C;
		  /* 8208F88Ch */ case    1:  		/* bc 4, CR6_EQ, -20 */
		/* 8208F88Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8208F878;  }
		/* 8208F88Ch case    1:*/		return 0x8208F890;
	}
	return 0x8208F890;
} // Block from 8208F888h-8208F890h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208F890h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F890);
		  /* 8208F890h */ case    0:  		/* rlwinm R10, R4, 0, 16, 31 */
		/* 8208F890h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R4);
		/* 8208F890h case    0:*/		return 0x8208F894;
		  /* 8208F894h */ case    1:  		/* addi R11, R5, 4 */
		/* 8208F894h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0x4);
		/* 8208F894h case    1:*/		return 0x8208F898;
		  /* 8208F898h */ case    2:  		/* sth R10, <#[R3]> */
		/* 8208F898h case    2:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8208F898h case    2:*/		return 0x8208F89C;
		  /* 8208F89Ch */ case    3:  		/* lhz R9, <#[R5 + 2]> */
		/* 8208F89Ch case    3:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000002) );
		/* 8208F89Ch case    3:*/		return 0x8208F8A0;
	}
	return 0x8208F8A0;
} // Block from 8208F890h-8208F8A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208F8A0h
// Function 'RtlpExtendHeap'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F8A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F8A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F8A0);
		  /* 8208F8A0h */ case    0:  		/* add R8, R9, R7 */
		/* 8208F8A0h case    0:*/		cpu::op::add<0>(regs,&regs.R8,regs.R9,regs.R7);
		/* 8208F8A0h case    0:*/		return 0x8208F8A4;
		  /* 8208F8A4h */ case    1:  		/* sth R8, <#[R3 + 2]> */
		/* 8208F8A4h case    1:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R3 + 0x00000002) );
		/* 8208F8A4h case    1:*/		return 0x8208F8A8;
		  /* 8208F8A8h */ case    2:  		/* rlwinm R9, R6, 0, 24, 31 */
		/* 8208F8A8h case    2:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R9,regs.R6);
		/* 8208F8A8h case    2:*/		return 0x8208F8AC;
		  /* 8208F8ACh */ case    3:  		/* lwz R8, <#[R5 + 4]> */
		/* 8208F8ACh case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + 0x00000004) );
		/* 8208F8ACh case    3:*/		return 0x8208F8B0;
		  /* 8208F8B0h */ case    4:  		/* stw R8, <#[R3 + 4]> */
		/* 8208F8B0h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		/* 8208F8B0h case    4:*/		return 0x8208F8B4;
		  /* 8208F8B4h */ case    5:  		/* lbz R8, <#[R5 + 8]> */
		/* 8208F8B4h case    5:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R5 + 0x00000008) );
		/* 8208F8B4h case    5:*/		return 0x8208F8B8;
		  /* 8208F8B8h */ case    6:  		/* stb R8, <#[R3 + 8]> */
		/* 8208F8B8h case    6:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R3 + 0x00000008) );
		/* 8208F8B8h case    6:*/		return 0x8208F8BC;
		  /* 8208F8BCh */ case    7:  		/* lbz R8, <#[R5 + 9]> */
		/* 8208F8BCh case    7:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R5 + 0x00000009) );
		/* 8208F8BCh case    7:*/		return 0x8208F8C0;
		  /* 8208F8C0h */ case    8:  		/* stb R8, <#[R3 + 9]> */
		/* 8208F8C0h case    8:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R3 + 0x00000009) );
		/* 8208F8C0h case    8:*/		return 0x8208F8C4;
		  /* 8208F8C4h */ case    9:  		/* stb R9, <#[R3 + 10]> */
		/* 8208F8C4h case    9:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R3 + 0x0000000A) );
		/* 8208F8C4h case    9:*/		return 0x8208F8C8;
		  /* 8208F8C8h */ case   10:  		/* lhz R8, <#[R5]> */
		/* 8208F8C8h case   10:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R5 + 0x00000000) );
		/* 8208F8C8h case   10:*/		return 0x8208F8CC;
		  /* 8208F8CCh */ case   11:  		/* b 56 */
		/* 8208F8CCh case   11:*/		return 0x8208F904;
		/* 8208F8CCh case   11:*/		return 0x8208F8D0;
		  /* 8208F8D0h */ case   12:  		/* addi R11, R11, 12 */
		/* 8208F8D0h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8208F8D0h case   12:*/		return 0x8208F8D4;
		  /* 8208F8D4h */ case   13:  		/* sthu R10, <#[R3 + 12]> */
		/* 8208F8D4h case   13:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		regs.R3 = (uint32)(regs.R3 + 0x0000000C);
		/* 8208F8D4h case   13:*/		return 0x8208F8D8;
		  /* 8208F8D8h */ case   14:  		/* lhz R8, <#[R11 - 2]> */
		/* 8208F8D8h case   14:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R11 + 0xFFFFFFFE) );
		/* 8208F8D8h case   14:*/		return 0x8208F8DC;
		  /* 8208F8DCh */ case   15:  		/* add R8, R8, R7 */
		/* 8208F8DCh case   15:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8208F8DCh case   15:*/		return 0x8208F8E0;
		  /* 8208F8E0h */ case   16:  		/* sth R8, <#[R3 + 2]> */
		/* 8208F8E0h case   16:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R3 + 0x00000002) );
		/* 8208F8E0h case   16:*/		return 0x8208F8E4;
		  /* 8208F8E4h */ case   17:  		/* lwz R8, <#[R11]> */
		/* 8208F8E4h case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8208F8E4h case   17:*/		return 0x8208F8E8;
		  /* 8208F8E8h */ case   18:  		/* stw R8, <#[R3 + 4]> */
		/* 8208F8E8h case   18:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		/* 8208F8E8h case   18:*/		return 0x8208F8EC;
		  /* 8208F8ECh */ case   19:  		/* lbz R8, <#[R11 + 4]> */
		/* 8208F8ECh case   19:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8208F8ECh case   19:*/		return 0x8208F8F0;
		  /* 8208F8F0h */ case   20:  		/* stb R8, <#[R3 + 8]> */
		/* 8208F8F0h case   20:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R3 + 0x00000008) );
		/* 8208F8F0h case   20:*/		return 0x8208F8F4;
		  /* 8208F8F4h */ case   21:  		/* lbz R8, <#[R11 + 5]> */
		/* 8208F8F4h case   21:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000005) );
		/* 8208F8F4h case   21:*/		return 0x8208F8F8;
		  /* 8208F8F8h */ case   22:  		/* stb R8, <#[R3 + 9]> */
		/* 8208F8F8h case   22:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R3 + 0x00000009) );
		/* 8208F8F8h case   22:*/		return 0x8208F8FC;
		  /* 8208F8FCh */ case   23:  		/* stb R9, <#[R3 + 10]> */
		/* 8208F8FCh case   23:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R3 + 0x0000000A) );
		/* 8208F8FCh case   23:*/		return 0x8208F900;
		  /* 8208F900h */ case   24:  		/* lhz R8, <#[R11 - 4]> */
		/* 8208F900h case   24:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 8208F900h case   24:*/		return 0x8208F904;
	}
	return 0x8208F904;
} // Block from 8208F8A0h-8208F904h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8208F904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F904);
		  /* 8208F904h */ case    0:  		/* cmplwi CR6, R8, 255 */
		/* 8208F904h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x000000FF);
		/* 8208F904h case    0:*/		return 0x8208F908;
		  /* 8208F908h */ case    1:  		/* bc 4, CR6_EQ, -56 */
		/* 8208F908h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8208F8D0;  }
		/* 8208F908h case    1:*/		return 0x8208F90C;
		  /* 8208F90Ch */ case    2:  		/* li R11, 0 */
		/* 8208F90Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8208F90Ch case    2:*/		return 0x8208F910;
		  /* 8208F910h */ case    3:  		/* li R10, 255 */
		/* 8208F910h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0xFF);
		/* 8208F910h case    3:*/		return 0x8208F914;
		  /* 8208F914h */ case    4:  		/* li R9, -1 */
		/* 8208F914h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 8208F914h case    4:*/		return 0x8208F918;
		  /* 8208F918h */ case    5:  		/* sth R11, <#[R3 + 2]> */
		/* 8208F918h case    5:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R3 + 0x00000002) );
		/* 8208F918h case    5:*/		return 0x8208F91C;
		  /* 8208F91Ch */ case    6:  		/* sth R10, <#[R3]> */
		/* 8208F91Ch case    6:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8208F91Ch case    6:*/		return 0x8208F920;
		  /* 8208F920h */ case    7:  		/* stw R9, <#[R3 + 4]> */
		/* 8208F920h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 8208F920h case    7:*/		return 0x8208F924;
		  /* 8208F924h */ case    8:  		/* stb R11, <#[R3 + 8]> */
		/* 8208F924h case    8:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8208F924h case    8:*/		return 0x8208F928;
		  /* 8208F928h */ case    9:  		/* stb R11, <#[R3 + 9]> */
		/* 8208F928h case    9:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000009) );
		/* 8208F928h case    9:*/		return 0x8208F92C;
		  /* 8208F92Ch */ case   10:  		/* stb R11, <#[R3 + 10]> */
		/* 8208F92Ch case   10:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x0000000A) );
		/* 8208F92Ch case   10:*/		return 0x8208F930;
		  /* 8208F930h */ case   11:  		/* bclr 20, CR0_LT */
		/* 8208F930h case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208F930h case   11:*/		return 0x8208F934;
	}
	return 0x8208F934;
} // Block from 8208F904h-8208F934h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8208F934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F934);
		  /* 8208F934h */ case    0:  		/* nop */
		/* 8208F934h case    0:*/		cpu::op::nop();
		/* 8208F934h case    0:*/		return 0x8208F938;
	}
	return 0x8208F938;
} // Block from 8208F934h-8208F938h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208F938h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F938);
		  /* 8208F938h */ case    0:  		/* mfspr R12, LR */
		/* 8208F938h case    0:*/		regs.R12 = regs.LR;
		/* 8208F938h case    0:*/		return 0x8208F93C;
		  /* 8208F93Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8208F93Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208F93Ch case    1:*/		return 0x8208F940;
		  /* 8208F940h */ case    2:  		/* std R4, <#[R1 + 24]> */
		/* 8208F940h case    2:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000018) );
		/* 8208F940h case    2:*/		return 0x8208F944;
		  /* 8208F944h */ case    3:  		/* std R5, <#[R1 + 32]> */
		/* 8208F944h case    3:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 8208F944h case    3:*/		return 0x8208F948;
		  /* 8208F948h */ case    4:  		/* std R6, <#[R1 + 40]> */
		/* 8208F948h case    4:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 8208F948h case    4:*/		return 0x8208F94C;
		  /* 8208F94Ch */ case    5:  		/* std R7, <#[R1 + 48]> */
		/* 8208F94Ch case    5:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 8208F94Ch case    5:*/		return 0x8208F950;
		  /* 8208F950h */ case    6:  		/* std R8, <#[R1 + 56]> */
		/* 8208F950h case    6:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 8208F950h case    6:*/		return 0x8208F954;
		  /* 8208F954h */ case    7:  		/* std R9, <#[R1 + 64]> */
		/* 8208F954h case    7:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 8208F954h case    7:*/		return 0x8208F958;
		  /* 8208F958h */ case    8:  		/* std R10, <#[R1 + 72]> */
		/* 8208F958h case    8:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 8208F958h case    8:*/		return 0x8208F95C;
		  /* 8208F95Ch */ case    9:  		/* stwu R1, <#[R1 - 2160]> */
		/* 8208F95Ch case    9:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFF790) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFF790);
		/* 8208F95Ch case    9:*/		return 0x8208F960;
		  /* 8208F960h */ case   10:  		/* stw R3, <#[R1 + 2180]> */
		/* 8208F960h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000884) );
		/* 8208F960h case   10:*/		return 0x8208F964;
		  /* 8208F964h */ case   11:  		/* addi R11, R1, 80 */
		/* 8208F964h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8208F964h case   11:*/		return 0x8208F968;
		  /* 8208F968h */ case   12:  		/* addi R10, R1, 2184 */
		/* 8208F968h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x888);
		/* 8208F968h case   12:*/		return 0x8208F96C;
		  /* 8208F96Ch */ case   13:  		/* mr R6, R3 */
		/* 8208F96Ch case   13:*/		regs.R6 = regs.R3;
		/* 8208F96Ch case   13:*/		return 0x8208F970;
		  /* 8208F970h */ case   14:  		/* li R5, -1 */
		/* 8208F970h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0xFFFFFFFF);
		/* 8208F970h case   14:*/		return 0x8208F974;
		  /* 8208F974h */ case   15:  		/* li R4, 2048 */
		/* 8208F974h case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x800);
		/* 8208F974h case   15:*/		return 0x8208F978;
		  /* 8208F978h */ case   16:  		/* addi R3, R1, 96 */
		/* 8208F978h case   16:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8208F978h case   16:*/		return 0x8208F97C;
		  /* 8208F97Ch */ case   17:  		/* stw R10, <#[R11]> */
		/* 8208F97Ch case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208F97Ch case   17:*/		return 0x8208F980;
		  /* 8208F980h */ case   18:  		/* lwz R7, <#[R1 + 80]> */
		/* 8208F980h case   18:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 8208F980h case   18:*/		return 0x8208F984;
		  /* 8208F984h */ case   19:  		/* bl 6276 */
		/* 8208F984h case   19:*/		regs.LR = 0x8208F988; return 0x82091208;
		/* 8208F984h case   19:*/		return 0x8208F988;
		  /* 8208F988h */ case   20:  		/* addi R3, R1, 96 */
		/* 8208F988h case   20:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8208F988h case   20:*/		return 0x8208F98C;
		  /* 8208F98Ch */ case   21:  		/* bl -30260 */
		/* 8208F98Ch case   21:*/		regs.LR = 0x8208F990; return 0x82088358;
		/* 8208F98Ch case   21:*/		return 0x8208F990;
		  /* 8208F990h */ case   22:  		/* addi R1, R1, 2160 */
		/* 8208F990h case   22:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x870);
		/* 8208F990h case   22:*/		return 0x8208F994;
		  /* 8208F994h */ case   23:  		/* lwz R12, <#[R1 - 8]> */
		/* 8208F994h case   23:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208F994h case   23:*/		return 0x8208F998;
		  /* 8208F998h */ case   24:  		/* mtspr LR, R12 */
		/* 8208F998h case   24:*/		regs.LR = regs.R12;
		/* 8208F998h case   24:*/		return 0x8208F99C;
		  /* 8208F99Ch */ case   25:  		/* bclr 20, CR0_LT */
		/* 8208F99Ch case   25:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208F99Ch case   25:*/		return 0x8208F9A0;
	}
	return 0x8208F9A0;
} // Block from 8208F938h-8208F9A0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8208F9A0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208F9A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208F9A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208F9A0);
		  /* 8208F9A0h */ case    0:  		/* mfspr R12, LR */
		/* 8208F9A0h case    0:*/		regs.R12 = regs.LR;
		/* 8208F9A0h case    0:*/		return 0x8208F9A4;
		  /* 8208F9A4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8208F9A4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208F9A4h case    1:*/		return 0x8208F9A8;
		  /* 8208F9A8h */ case    2:  		/* std R4, <#[R1 + 24]> */
		/* 8208F9A8h case    2:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000018) );
		/* 8208F9A8h case    2:*/		return 0x8208F9AC;
		  /* 8208F9ACh */ case    3:  		/* std R5, <#[R1 + 32]> */
		/* 8208F9ACh case    3:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 8208F9ACh case    3:*/		return 0x8208F9B0;
		  /* 8208F9B0h */ case    4:  		/* std R6, <#[R1 + 40]> */
		/* 8208F9B0h case    4:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 8208F9B0h case    4:*/		return 0x8208F9B4;
		  /* 8208F9B4h */ case    5:  		/* std R7, <#[R1 + 48]> */
		/* 8208F9B4h case    5:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 8208F9B4h case    5:*/		return 0x8208F9B8;
		  /* 8208F9B8h */ case    6:  		/* std R8, <#[R1 + 56]> */
		/* 8208F9B8h case    6:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 8208F9B8h case    6:*/		return 0x8208F9BC;
		  /* 8208F9BCh */ case    7:  		/* std R9, <#[R1 + 64]> */
		/* 8208F9BCh case    7:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 8208F9BCh case    7:*/		return 0x8208F9C0;
		  /* 8208F9C0h */ case    8:  		/* std R10, <#[R1 + 72]> */
		/* 8208F9C0h case    8:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 8208F9C0h case    8:*/		return 0x8208F9C4;
		  /* 8208F9C4h */ case    9:  		/* stwu R1, <#[R1 - 2160]> */
		/* 8208F9C4h case    9:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFF790) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFF790);
		/* 8208F9C4h case    9:*/		return 0x8208F9C8;
		  /* 8208F9C8h */ case   10:  		/* stw R3, <#[R1 + 2180]> */
		/* 8208F9C8h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000884) );
		/* 8208F9C8h case   10:*/		return 0x8208F9CC;
		  /* 8208F9CCh */ case   11:  		/* addi R11, R1, 80 */
		/* 8208F9CCh case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8208F9CCh case   11:*/		return 0x8208F9D0;
		  /* 8208F9D0h */ case   12:  		/* addi R10, R1, 2184 */
		/* 8208F9D0h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x888);
		/* 8208F9D0h case   12:*/		return 0x8208F9D4;
		  /* 8208F9D4h */ case   13:  		/* mr R6, R3 */
		/* 8208F9D4h case   13:*/		regs.R6 = regs.R3;
		/* 8208F9D4h case   13:*/		return 0x8208F9D8;
		  /* 8208F9D8h */ case   14:  		/* li R5, -1 */
		/* 8208F9D8h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0xFFFFFFFF);
		/* 8208F9D8h case   14:*/		return 0x8208F9DC;
		  /* 8208F9DCh */ case   15:  		/* li R4, 2048 */
		/* 8208F9DCh case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x800);
		/* 8208F9DCh case   15:*/		return 0x8208F9E0;
		  /* 8208F9E0h */ case   16:  		/* addi R3, R1, 96 */
		/* 8208F9E0h case   16:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8208F9E0h case   16:*/		return 0x8208F9E4;
		  /* 8208F9E4h */ case   17:  		/* stw R10, <#[R11]> */
		/* 8208F9E4h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8208F9E4h case   17:*/		return 0x8208F9E8;
		  /* 8208F9E8h */ case   18:  		/* lwz R7, <#[R1 + 80]> */
		/* 8208F9E8h case   18:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 8208F9E8h case   18:*/		return 0x8208F9EC;
		  /* 8208F9ECh */ case   19:  		/* bl 6172 */
		/* 8208F9ECh case   19:*/		regs.LR = 0x8208F9F0; return 0x82091208;
		/* 8208F9ECh case   19:*/		return 0x8208F9F0;
		  /* 8208F9F0h */ case   20:  		/* addi R3, R1, 96 */
		/* 8208F9F0h case   20:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8208F9F0h case   20:*/		return 0x8208F9F4;
		  /* 8208F9F4h */ case   21:  		/* bl -30364 */
		/* 8208F9F4h case   21:*/		regs.LR = 0x8208F9F8; return 0x82088358;
		/* 8208F9F4h case   21:*/		return 0x8208F9F8;
		  /* 8208F9F8h */ case   22:  		/* bl 1931368 */
		/* 8208F9F8h case   22:*/		regs.LR = 0x8208F9FC; return 0x82267260;
		/* 8208F9F8h case   22:*/		return 0x8208F9FC;
		  /* 8208F9FCh */ case   23:  		/* li R3, 0 */
		/* 8208F9FCh case   23:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208F9FCh case   23:*/		return 0x8208FA00;
		  /* 8208FA00h */ case   24:  		/* bl 13776 */
		/* 8208FA00h case   24:*/		regs.LR = 0x8208FA04; return 0x82092FD0;
		/* 8208FA00h case   24:*/		return 0x8208FA04;
		  /* 8208FA04h */ case   25:  		/* nop */
		/* 8208FA04h case   25:*/		cpu::op::nop();
		/* 8208FA04h case   25:*/		return 0x8208FA08;
	}
	return 0x8208FA08;
} // Block from 8208F9A0h-8208FA08h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8208FA08h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FA08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FA08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FA08);
		  /* 8208FA08h */ case    0:  		/* mfspr R12, LR */
		/* 8208FA08h case    0:*/		regs.R12 = regs.LR;
		/* 8208FA08h case    0:*/		return 0x8208FA0C;
		  /* 8208FA0Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8208FA0Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208FA0Ch case    1:*/		return 0x8208FA10;
		  /* 8208FA10h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8208FA10h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208FA10h case    2:*/		return 0x8208FA14;
		  /* 8208FA14h */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 8208FA14h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8208FA14h case    3:*/		return 0x8208FA18;
		  /* 8208FA18h */ case    4:  		/* lis R11, -32215 */
		/* 8208FA18h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8208FA18h case    4:*/		return 0x8208FA1C;
		  /* 8208FA1Ch */ case    5:  		/* addi R5, R1, 80 */
		/* 8208FA1Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8208FA1Ch case    5:*/		return 0x8208FA20;
		  /* 8208FA20h */ case    6:  		/* li R4, 0 */
		/* 8208FA20h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208FA20h case    6:*/		return 0x8208FA24;
		  /* 8208FA24h */ case    7:  		/* mr R31, R3 */
		/* 8208FA24h case    7:*/		regs.R31 = regs.R3;
		/* 8208FA24h case    7:*/		return 0x8208FA28;
		  /* 8208FA28h */ case    8:  		/* lwz R3, <#[R11 - 31244]> */
		/* 8208FA28h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFF85F4) );
		/* 8208FA28h case    8:*/		return 0x8208FA2C;
		  /* 8208FA2Ch */ case    9:  		/* bl -108260 */
		/* 8208FA2Ch case    9:*/		regs.LR = 0x8208FA30; return 0x82075348;
		/* 8208FA2Ch case    9:*/		return 0x8208FA30;
		  /* 8208FA30h */ case   10:  		/* lis R11, -32256 */
		/* 8208FA30h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8208FA30h case   10:*/		return 0x8208FA34;
		  /* 8208FA34h */ case   11:  		/* lis R10, -32255 */
		/* 8208FA34h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8208FA34h case   11:*/		return 0x8208FA38;
		  /* 8208FA38h */ case   12:  		/* li R9, 4 */
		/* 8208FA38h case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 8208FA38h case   12:*/		return 0x8208FA3C;
		  /* 8208FA3Ch */ case   13:  		/* li R8, 8 */
		/* 8208FA3Ch case   13:*/		cpu::op::li<0>(regs,&regs.R8,0x8);
		/* 8208FA3Ch case   13:*/		return 0x8208FA40;
		  /* 8208FA40h */ case   14:  		/* li R7, 12 */
		/* 8208FA40h case   14:*/		cpu::op::li<0>(regs,&regs.R7,0xC);
		/* 8208FA40h case   14:*/		return 0x8208FA44;
		  /* 8208FA44h */ case   15:  		/* lfs FR0, <#[R11 + 2664]> */
		/* 8208FA44h case   15:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000A68) );
		/* 8208FA44h case   15:*/		return 0x8208FA48;
		  /* 8208FA48h */ case   16:  		/* mr R3, R31 */
		/* 8208FA48h case   16:*/		regs.R3 = regs.R31;
		/* 8208FA48h case   16:*/		return 0x8208FA4C;
		  /* 8208FA4Ch */ case   17:  		/* lfs FR13, <#[R10 - 24928]> */
		/* 8208FA4Ch case   17:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R10 + 0xFFFF9EA0) );
		/* 8208FA4Ch case   17:*/		return 0x8208FA50;
		  /* 8208FA50h */ case   18:  		/* lwz R11, <#[R1 + 84]> */
		/* 8208FA50h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8208FA50h case   18:*/		return 0x8208FA54;
		  /* 8208FA54h */ case   19:  		/* lwz R10, <#[R1 + 80]> */
		/* 8208FA54h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8208FA54h case   19:*/		return 0x8208FA58;
		  /* 8208FA58h */ case   20:  		/* std R11, <#[R1 + 80]> */
		/* 8208FA58h case   20:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208FA58h case   20:*/		return 0x8208FA5C;
		  /* 8208FA5Ch */ case   21:  		/* lfd FR12, <#[R1 + 80]> */
		/* 8208FA5Ch case   21:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R1 + 0x00000050) );
		/* 8208FA5Ch case   21:*/		return 0x8208FA60;
		  /* 8208FA60h */ case   22:  		/* std R10, <#[R1 + 80]> */
		/* 8208FA60h case   22:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8208FA60h case   22:*/		return 0x8208FA64;
		  /* 8208FA64h */ case   23:  		/* lfd FR11, <#[R1 + 80]> */
		/* 8208FA64h case   23:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208FA64h case   23:*/		return 0x8208FA68;
		  /* 8208FA68h */ case   24:  		/* fcfid FR11, FR11 */
		/* 8208FA68h case   24:*/		cpu::op::fcfid<0>(regs,&regs.FR11,regs.FR11);
		/* 8208FA68h case   24:*/		return 0x8208FA6C;
		  /* 8208FA6Ch */ case   25:  		/* fcfid FR12, FR12 */
		/* 8208FA6Ch case   25:*/		cpu::op::fcfid<0>(regs,&regs.FR12,regs.FR12);
		/* 8208FA6Ch case   25:*/		return 0x8208FA70;
		  /* 8208FA70h */ case   26:  		/* frsp FR11, FR11 */
		/* 8208FA70h case   26:*/		cpu::op::frsp<0>(regs,&regs.FR11,regs.FR11);
		/* 8208FA70h case   26:*/		return 0x8208FA74;
		  /* 8208FA74h */ case   27:  		/* frsp FR12, FR12 */
		/* 8208FA74h case   27:*/		cpu::op::frsp<0>(regs,&regs.FR12,regs.FR12);
		/* 8208FA74h case   27:*/		return 0x8208FA78;
		  /* 8208FA78h */ case   28:  		/* fmuls FR10, FR11, FR0 */
		/* 8208FA78h case   28:*/		cpu::op::fmuls<0>(regs,&regs.FR10,regs.FR11,regs.FR0);
		/* 8208FA78h case   28:*/		return 0x8208FA7C;
		  /* 8208FA7Ch */ case   29:  		/* fmuls FR0, FR12, FR0 */
		/* 8208FA7Ch case   29:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR12,regs.FR0);
		/* 8208FA7Ch case   29:*/		return 0x8208FA80;
		  /* 8208FA80h */ case   30:  		/* fmuls FR11, FR11, FR13 */
		/* 8208FA80h case   30:*/		cpu::op::fmuls<0>(regs,&regs.FR11,regs.FR11,regs.FR13);
		/* 8208FA80h case   30:*/		return 0x8208FA84;
		  /* 8208FA84h */ case   31:  		/* fmuls FR13, FR12, FR13 */
		/* 8208FA84h case   31:*/		cpu::op::fmuls<0>(regs,&regs.FR13,regs.FR12,regs.FR13);
		/* 8208FA84h case   31:*/		return 0x8208FA88;
		  /* 8208FA88h */ case   32:  		/* fctiwz FR12, FR10 */
		/* 8208FA88h case   32:*/		cpu::op::fctiwz<0>(regs,&regs.FR12,regs.FR10);
		/* 8208FA88h case   32:*/		return 0x8208FA8C;
		  /* 8208FA8Ch */ case   33:  		/* stfiwx FR12, <#[R31]> */
		/* 8208FA8Ch case   33:*/		cpu::mem::store32( regs, regs.FR12, (uint32)(regs.R31 + 0x00000000) );
		/* 8208FA8Ch case   33:*/		return 0x8208FA90;
		  /* 8208FA90h */ case   34:  		/* fctiwz FR0, FR0 */
		/* 8208FA90h case   34:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 8208FA90h case   34:*/		return 0x8208FA94;
		  /* 8208FA94h */ case   35:  		/* stfiwx FR0, <#[R31 + R9]> */
		/* 8208FA94h case   35:*/		cpu::mem::store32( regs, regs.FR0, (uint32)(regs.R31 + regs.R9 + 0x00000000) );
		/* 8208FA94h case   35:*/		return 0x8208FA98;
		  /* 8208FA98h */ case   36:  		/* fctiwz FR12, FR11 */
		/* 8208FA98h case   36:*/		cpu::op::fctiwz<0>(regs,&regs.FR12,regs.FR11);
		/* 8208FA98h case   36:*/		return 0x8208FA9C;
		  /* 8208FA9Ch */ case   37:  		/* stfiwx FR12, <#[R31 + R8]> */
		/* 8208FA9Ch case   37:*/		cpu::mem::store32( regs, regs.FR12, (uint32)(regs.R31 + regs.R8 + 0x00000000) );
		/* 8208FA9Ch case   37:*/		return 0x8208FAA0;
		  /* 8208FAA0h */ case   38:  		/* fctiwz FR0, FR13 */
		/* 8208FAA0h case   38:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR13);
		/* 8208FAA0h case   38:*/		return 0x8208FAA4;
		  /* 8208FAA4h */ case   39:  		/* stfiwx FR0, <#[R31 + R7]> */
		/* 8208FAA4h case   39:*/		cpu::mem::store32( regs, regs.FR0, (uint32)(regs.R31 + regs.R7 + 0x00000000) );
		/* 8208FAA4h case   39:*/		return 0x8208FAA8;
		  /* 8208FAA8h */ case   40:  		/* addi R1, R1, 112 */
		/* 8208FAA8h case   40:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8208FAA8h case   40:*/		return 0x8208FAAC;
		  /* 8208FAACh */ case   41:  		/* lwz R12, <#[R1 - 8]> */
		/* 8208FAACh case   41:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208FAACh case   41:*/		return 0x8208FAB0;
		  /* 8208FAB0h */ case   42:  		/* mtspr LR, R12 */
		/* 8208FAB0h case   42:*/		regs.LR = regs.R12;
		/* 8208FAB0h case   42:*/		return 0x8208FAB4;
		  /* 8208FAB4h */ case   43:  		/* ld R31, <#[R1 - 16]> */
		/* 8208FAB4h case   43:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208FAB4h case   43:*/		return 0x8208FAB8;
		  /* 8208FAB8h */ case   44:  		/* bclr 20, CR0_LT */
		/* 8208FAB8h case   44:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208FAB8h case   44:*/		return 0x8208FABC;
	}
	return 0x8208FABC;
} // Block from 8208FA08h-8208FABCh (45 instructions)

//////////////////////////////////////////////////////
// Block at 8208FABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FABC);
		  /* 8208FABCh */ case    0:  		/* nop */
		/* 8208FABCh case    0:*/		cpu::op::nop();
		/* 8208FABCh case    0:*/		return 0x8208FAC0;
	}
	return 0x8208FAC0;
} // Block from 8208FABCh-8208FAC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208FAC0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FAC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FAC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FAC0);
		  /* 8208FAC0h */ case    0:  		/* mfspr R12, LR */
		/* 8208FAC0h case    0:*/		regs.R12 = regs.LR;
		/* 8208FAC0h case    0:*/		return 0x8208FAC4;
		  /* 8208FAC4h */ case    1:  		/* bl 6040 */
		/* 8208FAC4h case    1:*/		regs.LR = 0x8208FAC8; return 0x8209125C;
		/* 8208FAC4h case    1:*/		return 0x8208FAC8;
		  /* 8208FAC8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8208FAC8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8208FAC8h case    2:*/		return 0x8208FACC;
		  /* 8208FACCh */ case    3:  		/* li R11, 0 */
		/* 8208FACCh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8208FACCh case    3:*/		return 0x8208FAD0;
		  /* 8208FAD0h */ case    4:  		/* mr R31, R4 */
		/* 8208FAD0h case    4:*/		regs.R31 = regs.R4;
		/* 8208FAD0h case    4:*/		return 0x8208FAD4;
		  /* 8208FAD4h */ case    5:  		/* stw R11, <#[R4]> */
		/* 8208FAD4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8208FAD4h case    5:*/		return 0x8208FAD8;
		  /* 8208FAD8h */ case    6:  		/* mr R29, R5 */
		/* 8208FAD8h case    6:*/		regs.R29 = regs.R5;
		/* 8208FAD8h case    6:*/		return 0x8208FADC;
		  /* 8208FADCh */ case    7:  		/* li R5, 0 */
		/* 8208FADCh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8208FADCh case    7:*/		return 0x8208FAE0;
	}
	return 0x8208FAE0;
} // Block from 8208FAC0h-8208FAE0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8208FAE0h
// Function 'RtlpDeCommitFreeBlock'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FAE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FAE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FAE0);
		  /* 8208FAE0h */ case    0:  		/* stw R11, <#[R1 + 80]> */
		/* 8208FAE0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208FAE0h case    0:*/		return 0x8208FAE4;
		  /* 8208FAE4h */ case    1:  		/* addi R4, R1, 80 */
		/* 8208FAE4h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8208FAE4h case    1:*/		return 0x8208FAE8;
		  /* 8208FAE8h */ case    2:  		/* bl -1016 */
		/* 8208FAE8h case    2:*/		regs.LR = 0x8208FAEC; return 0x8208F6F0;
		/* 8208FAE8h case    2:*/		return 0x8208FAEC;
		  /* 8208FAECh */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 8208FAECh case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208FAECh case    3:*/		return 0x8208FAF0;
		  /* 8208FAF0h */ case    4:  		/* bc 12, CR0_LT, 76 */
		/* 8208FAF0h case    4:*/		if ( regs.CR[0].lt ) { return 0x8208FB3C;  }
		/* 8208FAF0h case    4:*/		return 0x8208FAF4;
		  /* 8208FAF4h */ case    5:  		/* lwz R30, <#[R1 + 80]> */
		/* 8208FAF4h case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 8208FAF4h case    5:*/		return 0x8208FAF8;
		  /* 8208FAF8h */ case    6:  		/* mr R3, R30 */
		/* 8208FAF8h case    6:*/		regs.R3 = regs.R30;
		/* 8208FAF8h case    6:*/		return 0x8208FAFC;
		  /* 8208FAFCh */ case    7:  		/* bl -151604 */
		/* 8208FAFCh case    7:*/		regs.LR = 0x8208FB00; return 0x8206AAC8;
		/* 8208FAFCh case    7:*/		return 0x8208FB00;
		  /* 8208FB00h */ case    8:  		/* lis R11, -32761 */
		/* 8208FB00h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8007);
		/* 8208FB00h case    8:*/		return 0x8208FB04;
		  /* 8208FB04h */ case    9:  		/* addic R10, R3, -1 */
		/* 8208FB04h case    9:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R3,0xFFFFFFFF);
		/* 8208FB04h case    9:*/		return 0x8208FB08;
		  /* 8208FB08h */ case   10:  		/* stw R3, <#[R31]> */
		/* 8208FB08h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8208FB08h case   10:*/		return 0x8208FB0C;
		  /* 8208FB0Ch */ case   11:  		/* ori R11, R11, 14 */
		/* 8208FB0Ch case   11:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xE);
		/* 8208FB0Ch case   11:*/		return 0x8208FB10;
		  /* 8208FB10h */ case   12:  		/* subfe R10, R10, R10 */
		/* 8208FB10h case   12:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8208FB10h case   12:*/		return 0x8208FB14;
		  /* 8208FB14h */ case   13:  		/* and. R31, R10, R11 */
		/* 8208FB14h case   13:*/		cpu::op::and<1>(regs,&regs.R31,regs.R10,regs.R11);
		/* 8208FB14h case   13:*/		return 0x8208FB18;
		  /* 8208FB18h */ case   14:  		/* bc 12, CR0_LT, 24 */
		/* 8208FB18h case   14:*/		if ( regs.CR[0].lt ) { return 0x8208FB30;  }
		/* 8208FB18h case   14:*/		return 0x8208FB1C;
		  /* 8208FB1Ch */ case   15:  		/* cmplwi CR6, R29, 0 */
		/* 8208FB1Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8208FB1Ch case   15:*/		return 0x8208FB20;
		  /* 8208FB20h */ case   16:  		/* bc 12, CR6_EQ, 16 */
		/* 8208FB20h case   16:*/		if ( regs.CR[6].eq ) { return 0x8208FB30;  }
		/* 8208FB20h case   16:*/		return 0x8208FB24;
		  /* 8208FB24h */ case   17:  		/* mr R3, R30 */
		/* 8208FB24h case   17:*/		regs.R3 = regs.R30;
		/* 8208FB24h case   17:*/		return 0x8208FB28;
		  /* 8208FB28h */ case   18:  		/* bl -840 */
		/* 8208FB28h case   18:*/		regs.LR = 0x8208FB2C; return 0x8208F7E0;
		/* 8208FB28h case   18:*/		return 0x8208FB2C;
		  /* 8208FB2Ch */ case   19:  		/* stw R3, <#[R29]> */
		/* 8208FB2Ch case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 8208FB2Ch case   19:*/		return 0x8208FB30;
	}
	return 0x8208FB30;
} // Block from 8208FAE0h-8208FB30h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8208FB30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FB30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FB30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FB30);
		  /* 8208FB30h */ case    0:  		/* mr R3, R30 */
		/* 8208FB30h case    0:*/		regs.R3 = regs.R30;
		/* 8208FB30h case    0:*/		return 0x8208FB34;
		  /* 8208FB34h */ case    1:  		/* bl 15604 */
		/* 8208FB34h case    1:*/		regs.LR = 0x8208FB38; return 0x82093828;
		/* 8208FB34h case    1:*/		return 0x8208FB38;
		  /* 8208FB38h */ case    2:  		/* mr R3, R31 */
		/* 8208FB38h case    2:*/		regs.R3 = regs.R31;
		/* 8208FB38h case    2:*/		return 0x8208FB3C;
	}
	return 0x8208FB3C;
} // Block from 8208FB30h-8208FB3Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208FB3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FB3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FB3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FB3C);
		  /* 8208FB3Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 8208FB3Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8208FB3Ch case    0:*/		return 0x8208FB40;
		  /* 8208FB40h */ case    1:  		/* b 5996 */
		/* 8208FB40h case    1:*/		return 0x820912AC;
		/* 8208FB40h case    1:*/		return 0x8208FB44;
		  /* 8208FB44h */ case    2:  		/* nop */
		/* 8208FB44h case    2:*/		cpu::op::nop();
		/* 8208FB44h case    2:*/		return 0x8208FB48;
	}
	return 0x8208FB48;
} // Block from 8208FB3Ch-8208FB48h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208FB48h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FB48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FB48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FB48);
		  /* 8208FB48h */ case    0:  		/* mfspr R12, LR */
		/* 8208FB48h case    0:*/		regs.R12 = regs.LR;
		/* 8208FB48h case    0:*/		return 0x8208FB4C;
		  /* 8208FB4Ch */ case    1:  		/* bl 5904 */
		/* 8208FB4Ch case    1:*/		regs.LR = 0x8208FB50; return 0x8209125C;
		/* 8208FB4Ch case    1:*/		return 0x8208FB50;
		  /* 8208FB50h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8208FB50h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8208FB50h case    2:*/		return 0x8208FB54;
		  /* 8208FB54h */ case    3:  		/* li R11, 0 */
		/* 8208FB54h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8208FB54h case    3:*/		return 0x8208FB58;
		  /* 8208FB58h */ case    4:  		/* mr R31, R4 */
		/* 8208FB58h case    4:*/		regs.R31 = regs.R4;
		/* 8208FB58h case    4:*/		return 0x8208FB5C;
		  /* 8208FB5Ch */ case    5:  		/* stw R11, <#[R4]> */
		/* 8208FB5Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8208FB5Ch case    5:*/		return 0x8208FB60;
		  /* 8208FB60h */ case    6:  		/* mr R29, R5 */
		/* 8208FB60h case    6:*/		regs.R29 = regs.R5;
		/* 8208FB60h case    6:*/		return 0x8208FB64;
		  /* 8208FB64h */ case    7:  		/* li R5, 0 */
		/* 8208FB64h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8208FB64h case    7:*/		return 0x8208FB68;
		  /* 8208FB68h */ case    8:  		/* stw R11, <#[R1 + 80]> */
		/* 8208FB68h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208FB68h case    8:*/		return 0x8208FB6C;
		  /* 8208FB6Ch */ case    9:  		/* addi R4, R1, 80 */
		/* 8208FB6Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8208FB6Ch case    9:*/		return 0x8208FB70;
		  /* 8208FB70h */ case   10:  		/* bl -1152 */
		/* 8208FB70h case   10:*/		regs.LR = 0x8208FB74; return 0x8208F6F0;
		/* 8208FB70h case   10:*/		return 0x8208FB74;
		  /* 8208FB74h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 8208FB74h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8208FB74h case   11:*/		return 0x8208FB78;
		  /* 8208FB78h */ case   12:  		/* bc 12, CR0_LT, 76 */
		/* 8208FB78h case   12:*/		if ( regs.CR[0].lt ) { return 0x8208FBC4;  }
		/* 8208FB78h case   12:*/		return 0x8208FB7C;
		  /* 8208FB7Ch */ case   13:  		/* lwz R30, <#[R1 + 80]> */
		/* 8208FB7Ch case   13:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 8208FB7Ch case   13:*/		return 0x8208FB80;
		  /* 8208FB80h */ case   14:  		/* mr R3, R30 */
		/* 8208FB80h case   14:*/		regs.R3 = regs.R30;
		/* 8208FB80h case   14:*/		return 0x8208FB84;
		  /* 8208FB84h */ case   15:  		/* bl -152228 */
		/* 8208FB84h case   15:*/		regs.LR = 0x8208FB88; return 0x8206A8E0;
		/* 8208FB84h case   15:*/		return 0x8208FB88;
		  /* 8208FB88h */ case   16:  		/* lis R11, -32761 */
		/* 8208FB88h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8007);
		/* 8208FB88h case   16:*/		return 0x8208FB8C;
		  /* 8208FB8Ch */ case   17:  		/* addic R10, R3, -1 */
		/* 8208FB8Ch case   17:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R3,0xFFFFFFFF);
		/* 8208FB8Ch case   17:*/		return 0x8208FB90;
		  /* 8208FB90h */ case   18:  		/* stw R3, <#[R31]> */
		/* 8208FB90h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8208FB90h case   18:*/		return 0x8208FB94;
		  /* 8208FB94h */ case   19:  		/* ori R11, R11, 14 */
		/* 8208FB94h case   19:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xE);
		/* 8208FB94h case   19:*/		return 0x8208FB98;
		  /* 8208FB98h */ case   20:  		/* subfe R10, R10, R10 */
		/* 8208FB98h case   20:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8208FB98h case   20:*/		return 0x8208FB9C;
		  /* 8208FB9Ch */ case   21:  		/* and. R31, R10, R11 */
		/* 8208FB9Ch case   21:*/		cpu::op::and<1>(regs,&regs.R31,regs.R10,regs.R11);
		/* 8208FB9Ch case   21:*/		return 0x8208FBA0;
		  /* 8208FBA0h */ case   22:  		/* bc 12, CR0_LT, 24 */
		/* 8208FBA0h case   22:*/		if ( regs.CR[0].lt ) { return 0x8208FBB8;  }
		/* 8208FBA0h case   22:*/		return 0x8208FBA4;
		  /* 8208FBA4h */ case   23:  		/* cmplwi CR6, R29, 0 */
		/* 8208FBA4h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8208FBA4h case   23:*/		return 0x8208FBA8;
		  /* 8208FBA8h */ case   24:  		/* bc 12, CR6_EQ, 16 */
		/* 8208FBA8h case   24:*/		if ( regs.CR[6].eq ) { return 0x8208FBB8;  }
		/* 8208FBA8h case   24:*/		return 0x8208FBAC;
		  /* 8208FBACh */ case   25:  		/* mr R3, R30 */
		/* 8208FBACh case   25:*/		regs.R3 = regs.R30;
		/* 8208FBACh case   25:*/		return 0x8208FBB0;
		  /* 8208FBB0h */ case   26:  		/* bl -976 */
		/* 8208FBB0h case   26:*/		regs.LR = 0x8208FBB4; return 0x8208F7E0;
		/* 8208FBB0h case   26:*/		return 0x8208FBB4;
		  /* 8208FBB4h */ case   27:  		/* stw R3, <#[R29]> */
		/* 8208FBB4h case   27:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 8208FBB4h case   27:*/		return 0x8208FBB8;
	}
	return 0x8208FBB8;
} // Block from 8208FB48h-8208FBB8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8208FBB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FBB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FBB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FBB8);
		  /* 8208FBB8h */ case    0:  		/* mr R3, R30 */
		/* 8208FBB8h case    0:*/		regs.R3 = regs.R30;
		/* 8208FBB8h case    0:*/		return 0x8208FBBC;
		  /* 8208FBBCh */ case    1:  		/* bl 15468 */
		/* 8208FBBCh case    1:*/		regs.LR = 0x8208FBC0; return 0x82093828;
		/* 8208FBBCh case    1:*/		return 0x8208FBC0;
		  /* 8208FBC0h */ case    2:  		/* mr R3, R31 */
		/* 8208FBC0h case    2:*/		regs.R3 = regs.R31;
		/* 8208FBC0h case    2:*/		return 0x8208FBC4;
	}
	return 0x8208FBC4;
} // Block from 8208FBB8h-8208FBC4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208FBC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FBC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FBC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FBC4);
		  /* 8208FBC4h */ case    0:  		/* addi R1, R1, 128 */
		/* 8208FBC4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8208FBC4h case    0:*/		return 0x8208FBC8;
		  /* 8208FBC8h */ case    1:  		/* b 5860 */
		/* 8208FBC8h case    1:*/		return 0x820912AC;
		/* 8208FBC8h case    1:*/		return 0x8208FBCC;
		  /* 8208FBCCh */ case    2:  		/* nop */
		/* 8208FBCCh case    2:*/		cpu::op::nop();
		/* 8208FBCCh case    2:*/		return 0x8208FBD0;
	}
	return 0x8208FBD0;
} // Block from 8208FBC4h-8208FBD0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208FBD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FBD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FBD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FBD0);
		  /* 8208FBD0h */ case    0:  		/* lwz R3, <#[R3 + 4]> */
		/* 8208FBD0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000004) );
		/* 8208FBD0h case    0:*/		return 0x8208FBD4;
		  /* 8208FBD4h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8208FBD4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8208FBD4h case    1:*/		return 0x8208FBD8;
		  /* 8208FBD8h */ case    2:  		/* bclr 4, CR6_EQ */
		/* 8208FBD8h case    2:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 8208FBD8h case    2:*/		return 0x8208FBDC;
	}
	return 0x8208FBDC;
} // Block from 8208FBD0h-8208FBDCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208FBDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FBDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FBDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FBDC);
		  /* 8208FBDCh */ case    0:  		/* lis R11, -32255 */
		/* 8208FBDCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208FBDCh case    0:*/		return 0x8208FBE0;
		  /* 8208FBE0h */ case    1:  		/* addi R3, R11, -24912 */
		/* 8208FBE0h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF9EB0);
		/* 8208FBE0h case    1:*/		return 0x8208FBE4;
		  /* 8208FBE4h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8208FBE4h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208FBE4h case    2:*/		return 0x8208FBE8;
	}
	return 0x8208FBE8;
} // Block from 8208FBDCh-8208FBE8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208FBE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FBE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FBE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FBE8);
		  /* 8208FBE8h */ case    0:  		/* mfspr R12, LR */
		/* 8208FBE8h case    0:*/		regs.R12 = regs.LR;
		/* 8208FBE8h case    0:*/		return 0x8208FBEC;
		  /* 8208FBECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8208FBECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208FBECh case    1:*/		return 0x8208FBF0;
		  /* 8208FBF0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8208FBF0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208FBF0h case    2:*/		return 0x8208FBF4;
		  /* 8208FBF4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8208FBF4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8208FBF4h case    3:*/		return 0x8208FBF8;
		  /* 8208FBF8h */ case    4:  		/* lis R11, -32215 */
		/* 8208FBF8h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8208FBF8h case    4:*/		return 0x8208FBFC;
		  /* 8208FBFCh */ case    5:  		/* mr R31, R3 */
		/* 8208FBFCh case    5:*/		regs.R31 = regs.R3;
		/* 8208FBFCh case    5:*/		return 0x8208FC00;
		  /* 8208FC00h */ case    6:  		/* lwz R10, <#[R11 - 30136]> */
		/* 8208FC00h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0xFFFF8A48) );
		/* 8208FC00h case    6:*/		return 0x8208FC04;
		  /* 8208FC04h */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 8208FC04h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8208FC04h case    7:*/		return 0x8208FC08;
		  /* 8208FC08h */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 8208FC08h case    8:*/		if ( regs.CR[6].eq ) { return 0x8208FC18;  }
		/* 8208FC08h case    8:*/		return 0x8208FC0C;
		  /* 8208FC0Ch */ case    9:  		/* rlwinm R11, R10, 0, 0, 31 */
		/* 8208FC0Ch case    9:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R10);
		/* 8208FC0Ch case    9:*/		return 0x8208FC10;
		  /* 8208FC10h */ case   10:  		/* mtspr CTR, R11 */
		/* 8208FC10h case   10:*/		regs.CTR = regs.R11;
		/* 8208FC10h case   10:*/		return 0x8208FC14;
		  /* 8208FC14h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 8208FC14h case   11:*/		if ( 1 ) { regs.LR = 0x8208FC18; return (uint32)regs.CTR; }
		/* 8208FC14h case   11:*/		return 0x8208FC18;
	}
	return 0x8208FC18;
} // Block from 8208FBE8h-8208FC18h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8208FC18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FC18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FC18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FC18);
		  /* 8208FC18h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8208FC18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8208FC18h case    0:*/		return 0x8208FC1C;
		  /* 8208FC1Ch */ case    1:  		/* mr R3, R31 */
		/* 8208FC1Ch case    1:*/		regs.R3 = regs.R31;
		/* 8208FC1Ch case    1:*/		return 0x8208FC20;
		  /* 8208FC20h */ case    2:  		/* lwz R11, <#[R11 + 8]> */
		/* 8208FC20h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8208FC20h case    2:*/		return 0x8208FC24;
		  /* 8208FC24h */ case    3:  		/* mtspr CTR, R11 */
		/* 8208FC24h case    3:*/		regs.CTR = regs.R11;
		/* 8208FC24h case    3:*/		return 0x8208FC28;
		  /* 8208FC28h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8208FC28h case    4:*/		if ( 1 ) { regs.LR = 0x8208FC2C; return (uint32)regs.CTR; }
		/* 8208FC28h case    4:*/		return 0x8208FC2C;
		  /* 8208FC2Ch */ case    5:  		/* li R7, 0 */
		/* 8208FC2Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8208FC2Ch case    5:*/		return 0x8208FC30;
		  /* 8208FC30h */ case    6:  		/* li R6, 0 */
		/* 8208FC30h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8208FC30h case    6:*/		return 0x8208FC34;
		  /* 8208FC34h */ case    7:  		/* li R5, 0 */
		/* 8208FC34h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8208FC34h case    7:*/		return 0x8208FC38;
		  /* 8208FC38h */ case    8:  		/* li R4, 0 */
		/* 8208FC38h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208FC38h case    8:*/		return 0x8208FC3C;
		  /* 8208FC3Ch */ case    9:  		/* li R3, 0 */
		/* 8208FC3Ch case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208FC3Ch case    9:*/		return 0x8208FC40;
		  /* 8208FC40h */ case   10:  		/* bl 15864 */
		/* 8208FC40h case   10:*/		regs.LR = 0x8208FC44; return 0x82093A38;
		/* 8208FC40h case   10:*/		return 0x8208FC44;
		  /* 8208FC44h */ case   11:  		/* nop */
		/* 8208FC44h case   11:*/		cpu::op::nop();
		/* 8208FC44h case   11:*/		return 0x8208FC48;
	}
	return 0x8208FC48;
} // Block from 8208FC18h-8208FC48h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8208FC48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FC48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FC48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FC48);
		  /* 8208FC48h */ case    0:  		/* li R7, 0 */
		/* 8208FC48h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8208FC48h case    0:*/		return 0x8208FC4C;
		  /* 8208FC4Ch */ case    1:  		/* li R6, 0 */
		/* 8208FC4Ch case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8208FC4Ch case    1:*/		return 0x8208FC50;
		  /* 8208FC50h */ case    2:  		/* li R5, 0 */
		/* 8208FC50h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8208FC50h case    2:*/		return 0x8208FC54;
		  /* 8208FC54h */ case    3:  		/* li R4, 0 */
		/* 8208FC54h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208FC54h case    3:*/		return 0x8208FC58;
		  /* 8208FC58h */ case    4:  		/* li R3, 0 */
		/* 8208FC58h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208FC58h case    4:*/		return 0x8208FC5C;
		  /* 8208FC5Ch */ case    5:  		/* b 15836 */
		/* 8208FC5Ch case    5:*/		return 0x82093A38;
		/* 8208FC5Ch case    5:*/		return 0x8208FC60;
	}
	return 0x8208FC60;
} // Block from 8208FC48h-8208FC60h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208FC60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FC60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FC60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FC60);
		  /* 8208FC60h */ case    0:  		/* mfspr R12, LR */
		/* 8208FC60h case    0:*/		regs.R12 = regs.LR;
		/* 8208FC60h case    0:*/		return 0x8208FC64;
		  /* 8208FC64h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8208FC64h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208FC64h case    1:*/		return 0x8208FC68;
		  /* 8208FC68h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8208FC68h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208FC68h case    2:*/		return 0x8208FC6C;
		  /* 8208FC6Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8208FC6Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8208FC6Ch case    3:*/		return 0x8208FC70;
		  /* 8208FC70h */ case    4:  		/* lis R11, -32255 */
		/* 8208FC70h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208FC70h case    4:*/		return 0x8208FC74;
		  /* 8208FC74h */ case    5:  		/* mr R31, R3 */
		/* 8208FC74h case    5:*/		regs.R31 = regs.R3;
		/* 8208FC74h case    5:*/		return 0x8208FC78;
		  /* 8208FC78h */ case    6:  		/* addi R11, R11, -24924 */
		/* 8208FC78h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF9EA4);
		/* 8208FC78h case    6:*/		return 0x8208FC7C;
		  /* 8208FC7Ch */ case    7:  		/* rlwinm. R10, R4, 0, 31, 31 */
		/* 8208FC7Ch case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R4);
		/* 8208FC7Ch case    7:*/		return 0x8208FC80;
		  /* 8208FC80h */ case    8:  		/* stw R11, <#[R3]> */
		/* 8208FC80h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8208FC80h case    8:*/		return 0x8208FC84;
		  /* 8208FC84h */ case    9:  		/* bc 12, CR0_EQ, 8 */
		/* 8208FC84h case    9:*/		if ( regs.CR[0].eq ) { return 0x8208FC8C;  }
		/* 8208FC84h case    9:*/		return 0x8208FC88;
		  /* 8208FC88h */ case   10:  		/* bl 9952 */
		/* 8208FC88h case   10:*/		regs.LR = 0x8208FC8C; return 0x82092368;
		/* 8208FC88h case   10:*/		return 0x8208FC8C;
	}
	return 0x8208FC8C;
} // Block from 8208FC60h-8208FC8Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8208FC8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FC8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FC8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FC8C);
		  /* 8208FC8Ch */ case    0:  		/* mr R3, R31 */
		/* 8208FC8Ch case    0:*/		regs.R3 = regs.R31;
		/* 8208FC8Ch case    0:*/		return 0x8208FC90;
		  /* 8208FC90h */ case    1:  		/* addi R1, R1, 96 */
		/* 8208FC90h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8208FC90h case    1:*/		return 0x8208FC94;
		  /* 8208FC94h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 8208FC94h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208FC94h case    2:*/		return 0x8208FC98;
		  /* 8208FC98h */ case    3:  		/* mtspr LR, R12 */
		/* 8208FC98h case    3:*/		regs.LR = regs.R12;
		/* 8208FC98h case    3:*/		return 0x8208FC9C;
		  /* 8208FC9Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8208FC9Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208FC9Ch case    4:*/		return 0x8208FCA0;
		  /* 8208FCA0h */ case    5:  		/* bclr 20, CR0_LT */
		/* 8208FCA0h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208FCA0h case    5:*/		return 0x8208FCA4;
	}
	return 0x8208FCA4;
} // Block from 8208FC8Ch-8208FCA4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208FCA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FCA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FCA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FCA4);
		  /* 8208FCA4h */ case    0:  		/* nop */
		/* 8208FCA4h case    0:*/		cpu::op::nop();
		/* 8208FCA4h case    0:*/		return 0x8208FCA8;
	}
	return 0x8208FCA8;
} // Block from 8208FCA4h-8208FCA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208FCA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FCA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FCA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FCA8);
		  /* 8208FCA8h */ case    0:  		/* mfspr R12, LR */
		/* 8208FCA8h case    0:*/		regs.R12 = regs.LR;
		/* 8208FCA8h case    0:*/		return 0x8208FCAC;
		  /* 8208FCACh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8208FCACh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208FCACh case    1:*/		return 0x8208FCB0;
		  /* 8208FCB0h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8208FCB0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8208FCB0h case    2:*/		return 0x8208FCB4;
		  /* 8208FCB4h */ case    3:  		/* mr R11, R3 */
		/* 8208FCB4h case    3:*/		regs.R11 = regs.R3;
		/* 8208FCB4h case    3:*/		return 0x8208FCB8;
		  /* 8208FCB8h */ case    4:  		/* li R3, 0 */
		/* 8208FCB8h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208FCB8h case    4:*/		return 0x8208FCBC;
		  /* 8208FCBCh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8208FCBCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208FCBCh case    5:*/		return 0x8208FCC0;
		  /* 8208FCC0h */ case    6:  		/* bc 12, CR6_EQ, 64 */
		/* 8208FCC0h case    6:*/		if ( regs.CR[6].eq ) { return 0x8208FD00;  }
		/* 8208FCC0h case    6:*/		return 0x8208FCC4;
		  /* 8208FCC4h */ case    7:  		/* lis R10, 84 */
		/* 8208FCC4h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0x54);
		/* 8208FCC4h case    7:*/		return 0x8208FCC8;
		  /* 8208FCC8h */ case    8:  		/* ori R10, R10, 29727 */
		/* 8208FCC8h case    8:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x741F);
		/* 8208FCC8h case    8:*/		return 0x8208FCCC;
		  /* 8208FCCCh */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 8208FCCCh case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8208FCCCh case    9:*/		return 0x8208FCD0;
		  /* 8208FCD0h */ case   10:  		/* bc 12, CR6_GT, 20 */
		/* 8208FCD0h case   10:*/		if ( regs.CR[6].gt ) { return 0x8208FCE4;  }
		/* 8208FCD0h case   10:*/		return 0x8208FCD4;
		  /* 8208FCD4h */ case   11:  		/* mulli R3, R11, 776 */
		/* 8208FCD4h case   11:*/		cpu::op::mulli<0>(regs,&regs.R3,regs.R11,0x308);
		/* 8208FCD4h case   11:*/		return 0x8208FCD8;
		  /* 8208FCD8h */ case   12:  		/* bl 14960 */
		/* 8208FCD8h case   12:*/		regs.LR = 0x8208FCDC; return 0x82093748;
		/* 8208FCD8h case   12:*/		return 0x8208FCDC;
		  /* 8208FCDCh */ case   13:  		/* cmplwi CR0, R3, 0 */
		/* 8208FCDCh case   13:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8208FCDCh case   13:*/		return 0x8208FCE0;
		  /* 8208FCE0h */ case   14:  		/* bc 4, CR0_EQ, 32 */
		/* 8208FCE0h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8208FD00;  }
		/* 8208FCE0h case   14:*/		return 0x8208FCE4;
	}
	return 0x8208FCE4;
} // Block from 8208FCA8h-8208FCE4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8208FCE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FCE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FCE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FCE4);
		  /* 8208FCE4h */ case    0:  		/* lis R11, -32255 */
		/* 8208FCE4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208FCE4h case    0:*/		return 0x8208FCE8;
		  /* 8208FCE8h */ case    1:  		/* li R10, 0 */
		/* 8208FCE8h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8208FCE8h case    1:*/		return 0x8208FCEC;
		  /* 8208FCECh */ case    2:  		/* addi R11, R11, -24892 */
		/* 8208FCECh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF9EC4);
		/* 8208FCECh case    2:*/		return 0x8208FCF0;
		  /* 8208FCF0h */ case    3:  		/* stw R10, <#[R1 + 84]> */
		/* 8208FCF0h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 8208FCF0h case    3:*/		return 0x8208FCF4;
		  /* 8208FCF4h */ case    4:  		/* addi R3, R1, 80 */
		/* 8208FCF4h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8208FCF4h case    4:*/		return 0x8208FCF8;
		  /* 8208FCF8h */ case    5:  		/* stw R11, <#[R1 + 80]> */
		/* 8208FCF8h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208FCF8h case    5:*/		return 0x8208FCFC;
		  /* 8208FCFCh */ case    6:  		/* bl -276 */
		/* 8208FCFCh case    6:*/		regs.LR = 0x8208FD00; return 0x8208FBE8;
		/* 8208FCFCh case    6:*/		return 0x8208FD00;
	}
	return 0x8208FD00;
} // Block from 8208FCE4h-8208FD00h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208FD00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FD00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FD00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FD00);
		  /* 8208FD00h */ case    0:  		/* addi R1, R1, 96 */
		/* 8208FD00h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8208FD00h case    0:*/		return 0x8208FD04;
		  /* 8208FD04h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8208FD04h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208FD04h case    1:*/		return 0x8208FD08;
		  /* 8208FD08h */ case    2:  		/* mtspr LR, R12 */
		/* 8208FD08h case    2:*/		regs.LR = regs.R12;
		/* 8208FD08h case    2:*/		return 0x8208FD0C;
		  /* 8208FD0Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 8208FD0Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208FD0Ch case    3:*/		return 0x8208FD10;
	}
	return 0x8208FD10;
} // Block from 8208FD00h-8208FD10h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208FD10h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FD10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FD10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FD10);
		  /* 8208FD10h */ case    0:  		/* mfspr R12, LR */
		/* 8208FD10h case    0:*/		regs.R12 = regs.LR;
		/* 8208FD10h case    0:*/		return 0x8208FD14;
		  /* 8208FD14h */ case    1:  		/* bl 5448 */
		/* 8208FD14h case    1:*/		regs.LR = 0x8208FD18; return 0x8209125C;
		/* 8208FD14h case    1:*/		return 0x8208FD18;
		  /* 8208FD18h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8208FD18h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8208FD18h case    2:*/		return 0x8208FD1C;
		  /* 8208FD1Ch */ case    3:  		/* mr R29, R3 */
		/* 8208FD1Ch case    3:*/		regs.R29 = regs.R3;
		/* 8208FD1Ch case    3:*/		return 0x8208FD20;
		  /* 8208FD20h */ case    4:  		/* mr R30, R4 */
		/* 8208FD20h case    4:*/		regs.R30 = regs.R4;
		/* 8208FD20h case    4:*/		return 0x8208FD24;
		  /* 8208FD24h */ case    5:  		/* bl -158476 */
		/* 8208FD24h case    5:*/		regs.LR = 0x8208FD28; return 0x82069218;
		/* 8208FD24h case    5:*/		return 0x8208FD28;
		  /* 8208FD28h */ case    6:  		/* lis R31, -32215 */
		/* 8208FD28h case    6:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8229);
		/* 8208FD28h case    6:*/		return 0x8208FD2C;
		  /* 8208FD2Ch */ case    7:  		/* mr R11, R3 */
		/* 8208FD2Ch case    7:*/		regs.R11 = regs.R3;
		/* 8208FD2Ch case    7:*/		return 0x8208FD30;
		  /* 8208FD30h */ case    8:  		/* cmplwi CR0, R3, 0 */
		/* 8208FD30h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8208FD30h case    8:*/		return 0x8208FD34;
		  /* 8208FD34h */ case    9:  		/* stw R3, <#[R31 - 31220]> */
		/* 8208FD34h case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0xFFFF860C) );
		/* 8208FD34h case    9:*/		return 0x8208FD38;
		  /* 8208FD38h */ case   10:  		/* bc 12, CR0_EQ, 12 */
		/* 8208FD38h case   10:*/		if ( regs.CR[0].eq ) { return 0x8208FD44;  }
		/* 8208FD38h case   10:*/		return 0x8208FD3C;
		  /* 8208FD3Ch */ case   11:  		/* bl -121844 */
		/* 8208FD3Ch case   11:*/		regs.LR = 0x8208FD40; return 0x82072148;
		/* 8208FD3Ch case   11:*/		return 0x8208FD40;
		  /* 8208FD40h */ case   12:  		/* lwz R11, <#[R31 - 31220]> */
		/* 8208FD40h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0xFFFF860C) );
		/* 8208FD40h case   12:*/		return 0x8208FD44;
	}
	return 0x8208FD44;
} // Block from 8208FD10h-8208FD44h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8208FD44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FD44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FD44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FD44);
		  /* 8208FD44h */ case    0:  		/* cmplw CR6, R11, R30 */
		/* 8208FD44h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 8208FD44h case    0:*/		return 0x8208FD48;
		  /* 8208FD48h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 8208FD48h case    1:*/		if ( regs.CR[6].eq ) { return 0x8208FD5C;  }
		/* 8208FD48h case    1:*/		return 0x8208FD4C;
		  /* 8208FD4Ch */ case    2:  		/* mr R4, R30 */
		/* 8208FD4Ch case    2:*/		regs.R4 = regs.R30;
		/* 8208FD4Ch case    2:*/		return 0x8208FD50;
		  /* 8208FD50h */ case    3:  		/* mr R3, R29 */
		/* 8208FD50h case    3:*/		regs.R3 = regs.R29;
		/* 8208FD50h case    3:*/		return 0x8208FD54;
		  /* 8208FD54h */ case    4:  		/* bl -158548 */
		/* 8208FD54h case    4:*/		regs.LR = 0x8208FD58; return 0x82069200;
		/* 8208FD54h case    4:*/		return 0x8208FD58;
		  /* 8208FD58h */ case    5:  		/* stw R30, <#[R31 - 31220]> */
		/* 8208FD58h case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0xFFFF860C) );
		/* 8208FD58h case    5:*/		return 0x8208FD5C;
	}
	return 0x8208FD5C;
} // Block from 8208FD44h-8208FD5Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208FD5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FD5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FD5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FD5C);
		  /* 8208FD5Ch */ case    0:  		/* li R3, 0 */
		/* 8208FD5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208FD5Ch case    0:*/		return 0x8208FD60;
		  /* 8208FD60h */ case    1:  		/* addi R1, R1, 112 */
		/* 8208FD60h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8208FD60h case    1:*/		return 0x8208FD64;
		  /* 8208FD64h */ case    2:  		/* b 5448 */
		/* 8208FD64h case    2:*/		return 0x820912AC;
		/* 8208FD64h case    2:*/		return 0x8208FD68;
	}
	return 0x8208FD68;
} // Block from 8208FD5Ch-8208FD68h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208FD68h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FD68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FD68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FD68);
		  /* 8208FD68h */ case    0:  		/* mfspr R12, LR */
		/* 8208FD68h case    0:*/		regs.R12 = regs.LR;
		/* 8208FD68h case    0:*/		return 0x8208FD6C;
		  /* 8208FD6Ch */ case    1:  		/* bl 5360 */
		/* 8208FD6Ch case    1:*/		regs.LR = 0x8208FD70; return 0x8209125C;
		/* 8208FD6Ch case    1:*/		return 0x8208FD70;
		  /* 8208FD70h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8208FD70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8208FD70h case    2:*/		return 0x8208FD74;
		  /* 8208FD74h */ case    3:  		/* li R11, 0 */
		/* 8208FD74h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8208FD74h case    3:*/		return 0x8208FD78;
		  /* 8208FD78h */ case    4:  		/* mr R30, R4 */
		/* 8208FD78h case    4:*/		regs.R30 = regs.R4;
		/* 8208FD78h case    4:*/		return 0x8208FD7C;
		  /* 8208FD7Ch */ case    5:  		/* stw R11, <#[R1 + 80]> */
		/* 8208FD7Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208FD7Ch case    5:*/		return 0x8208FD80;
		  /* 8208FD80h */ case    6:  		/* addi R4, R1, 80 */
		/* 8208FD80h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8208FD80h case    6:*/		return 0x8208FD84;
		  /* 8208FD84h */ case    7:  		/* mr R29, R3 */
		/* 8208FD84h case    7:*/		regs.R29 = regs.R3;
		/* 8208FD84h case    7:*/		return 0x8208FD88;
		  /* 8208FD88h */ case    8:  		/* bl -158672 */
		/* 8208FD88h case    8:*/		regs.LR = 0x8208FD8C; return 0x820691B8;
		/* 8208FD88h case    8:*/		return 0x8208FD8C;
		  /* 8208FD8Ch */ case    9:  		/* lwz R11, <#[R1 + 80]> */
		/* 8208FD8Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208FD8Ch case    9:*/		return 0x8208FD90;
		  /* 8208FD90h */ case   10:  		/* lis R31, -32215 */
		/* 8208FD90h case   10:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8229);
		/* 8208FD90h case   10:*/		return 0x8208FD94;
		  /* 8208FD94h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 8208FD94h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208FD94h case   11:*/		return 0x8208FD98;
		  /* 8208FD98h */ case   12:  		/* stw R11, <#[R31 - 31216]> */
		/* 8208FD98h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0xFFFF8610) );
		/* 8208FD98h case   12:*/		return 0x8208FD9C;
		  /* 8208FD9Ch */ case   13:  		/* bc 12, CR6_EQ, 16 */
		/* 8208FD9Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x8208FDAC;  }
		/* 8208FD9Ch case   13:*/		return 0x8208FDA0;
		  /* 8208FDA0h */ case   14:  		/* mr R3, R11 */
		/* 8208FDA0h case   14:*/		regs.R3 = regs.R11;
		/* 8208FDA0h case   14:*/		return 0x8208FDA4;
		  /* 8208FDA4h */ case   15:  		/* bl -121948 */
		/* 8208FDA4h case   15:*/		regs.LR = 0x8208FDA8; return 0x82072148;
		/* 8208FDA4h case   15:*/		return 0x8208FDA8;
		  /* 8208FDA8h */ case   16:  		/* lwz R11, <#[R31 - 31216]> */
		/* 8208FDA8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0xFFFF8610) );
		/* 8208FDA8h case   16:*/		return 0x8208FDAC;
	}
	return 0x8208FDAC;
} // Block from 8208FD68h-8208FDACh (17 instructions)

//////////////////////////////////////////////////////
// Block at 8208FDACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FDAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FDAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FDAC);
		  /* 8208FDACh */ case    0:  		/* cmplw CR6, R11, R30 */
		/* 8208FDACh case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 8208FDACh case    0:*/		return 0x8208FDB0;
		  /* 8208FDB0h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 8208FDB0h case    1:*/		if ( regs.CR[6].eq ) { return 0x8208FDC4;  }
		/* 8208FDB0h case    1:*/		return 0x8208FDB4;
		  /* 8208FDB4h */ case    2:  		/* mr R4, R30 */
		/* 8208FDB4h case    2:*/		regs.R4 = regs.R30;
		/* 8208FDB4h case    2:*/		return 0x8208FDB8;
		  /* 8208FDB8h */ case    3:  		/* mr R3, R29 */
		/* 8208FDB8h case    3:*/		regs.R3 = regs.R29;
		/* 8208FDB8h case    3:*/		return 0x8208FDBC;
		  /* 8208FDBCh */ case    4:  		/* bl -159188 */
		/* 8208FDBCh case    4:*/		regs.LR = 0x8208FDC0; return 0x82068FE8;
		/* 8208FDBCh case    4:*/		return 0x8208FDC0;
		  /* 8208FDC0h */ case    5:  		/* stw R30, <#[R31 - 31216]> */
		/* 8208FDC0h case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0xFFFF8610) );
		/* 8208FDC0h case    5:*/		return 0x8208FDC4;
	}
	return 0x8208FDC4;
} // Block from 8208FDACh-8208FDC4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208FDC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FDC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FDC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FDC4);
		  /* 8208FDC4h */ case    0:  		/* li R3, 0 */
		/* 8208FDC4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208FDC4h case    0:*/		return 0x8208FDC8;
		  /* 8208FDC8h */ case    1:  		/* addi R1, R1, 128 */
		/* 8208FDC8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8208FDC8h case    1:*/		return 0x8208FDCC;
		  /* 8208FDCCh */ case    2:  		/* b 5344 */
		/* 8208FDCCh case    2:*/		return 0x820912AC;
		/* 8208FDCCh case    2:*/		return 0x8208FDD0;
	}
	return 0x8208FDD0;
} // Block from 8208FDC4h-8208FDD0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208FDD0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FDD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FDD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FDD0);
		  /* 8208FDD0h */ case    0:  		/* mfspr R12, LR */
		/* 8208FDD0h case    0:*/		regs.R12 = regs.LR;
		/* 8208FDD0h case    0:*/		return 0x8208FDD4;
		  /* 8208FDD4h */ case    1:  		/* bl 5256 */
		/* 8208FDD4h case    1:*/		regs.LR = 0x8208FDD8; return 0x8209125C;
		/* 8208FDD4h case    1:*/		return 0x8208FDD8;
		  /* 8208FDD8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8208FDD8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8208FDD8h case    2:*/		return 0x8208FDDC;
		  /* 8208FDDCh */ case    3:  		/* li R11, 0 */
		/* 8208FDDCh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8208FDDCh case    3:*/		return 0x8208FDE0;
		  /* 8208FDE0h */ case    4:  		/* mr R30, R4 */
		/* 8208FDE0h case    4:*/		regs.R30 = regs.R4;
		/* 8208FDE0h case    4:*/		return 0x8208FDE4;
		  /* 8208FDE4h */ case    5:  		/* stw R11, <#[R1 + 80]> */
		/* 8208FDE4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208FDE4h case    5:*/		return 0x8208FDE8;
		  /* 8208FDE8h */ case    6:  		/* addi R4, R1, 80 */
		/* 8208FDE8h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8208FDE8h case    6:*/		return 0x8208FDEC;
		  /* 8208FDECh */ case    7:  		/* mr R29, R3 */
		/* 8208FDECh case    7:*/		regs.R29 = regs.R3;
		/* 8208FDECh case    7:*/		return 0x8208FDF0;
		  /* 8208FDF0h */ case    8:  		/* bl -159312 */
		/* 8208FDF0h case    8:*/		regs.LR = 0x8208FDF4; return 0x82068FA0;
		/* 8208FDF0h case    8:*/		return 0x8208FDF4;
		  /* 8208FDF4h */ case    9:  		/* lwz R11, <#[R1 + 80]> */
		/* 8208FDF4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8208FDF4h case    9:*/		return 0x8208FDF8;
		  /* 8208FDF8h */ case   10:  		/* lis R31, -32215 */
		/* 8208FDF8h case   10:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8229);
		/* 8208FDF8h case   10:*/		return 0x8208FDFC;
		  /* 8208FDFCh */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 8208FDFCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8208FDFCh case   11:*/		return 0x8208FE00;
		  /* 8208FE00h */ case   12:  		/* stw R11, <#[R31 - 31212]> */
		/* 8208FE00h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0xFFFF8614) );
		/* 8208FE00h case   12:*/		return 0x8208FE04;
		  /* 8208FE04h */ case   13:  		/* bc 12, CR6_EQ, 16 */
		/* 8208FE04h case   13:*/		if ( regs.CR[6].eq ) { return 0x8208FE14;  }
		/* 8208FE04h case   13:*/		return 0x8208FE08;
		  /* 8208FE08h */ case   14:  		/* mr R3, R11 */
		/* 8208FE08h case   14:*/		regs.R3 = regs.R11;
		/* 8208FE08h case   14:*/		return 0x8208FE0C;
		  /* 8208FE0Ch */ case   15:  		/* bl -122052 */
		/* 8208FE0Ch case   15:*/		regs.LR = 0x8208FE10; return 0x82072148;
		/* 8208FE0Ch case   15:*/		return 0x8208FE10;
		  /* 8208FE10h */ case   16:  		/* lwz R11, <#[R31 - 31212]> */
		/* 8208FE10h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0xFFFF8614) );
		/* 8208FE10h case   16:*/		return 0x8208FE14;
	}
	return 0x8208FE14;
} // Block from 8208FDD0h-8208FE14h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8208FE14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FE14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FE14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FE14);
		  /* 8208FE14h */ case    0:  		/* cmplw CR6, R11, R30 */
		/* 8208FE14h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 8208FE14h case    0:*/		return 0x8208FE18;
		  /* 8208FE18h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 8208FE18h case    1:*/		if ( regs.CR[6].eq ) { return 0x8208FE2C;  }
		/* 8208FE18h case    1:*/		return 0x8208FE1C;
		  /* 8208FE1Ch */ case    2:  		/* mr R4, R30 */
		/* 8208FE1Ch case    2:*/		regs.R4 = regs.R30;
		/* 8208FE1Ch case    2:*/		return 0x8208FE20;
		  /* 8208FE20h */ case    3:  		/* mr R3, R29 */
		/* 8208FE20h case    3:*/		regs.R3 = regs.R29;
		/* 8208FE20h case    3:*/		return 0x8208FE24;
		  /* 8208FE24h */ case    4:  		/* bl -159812 */
		/* 8208FE24h case    4:*/		regs.LR = 0x8208FE28; return 0x82068DE0;
		/* 8208FE24h case    4:*/		return 0x8208FE28;
		  /* 8208FE28h */ case    5:  		/* stw R30, <#[R31 - 31212]> */
		/* 8208FE28h case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0xFFFF8614) );
		/* 8208FE28h case    5:*/		return 0x8208FE2C;
	}
	return 0x8208FE2C;
} // Block from 8208FE14h-8208FE2Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208FE2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FE2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FE2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FE2C);
		  /* 8208FE2Ch */ case    0:  		/* li R3, 0 */
		/* 8208FE2Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8208FE2Ch case    0:*/		return 0x8208FE30;
		  /* 8208FE30h */ case    1:  		/* addi R1, R1, 128 */
		/* 8208FE30h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8208FE30h case    1:*/		return 0x8208FE34;
		  /* 8208FE34h */ case    2:  		/* b 5240 */
		/* 8208FE34h case    2:*/		return 0x820912AC;
		/* 8208FE34h case    2:*/		return 0x8208FE38;
	}
	return 0x8208FE38;
} // Block from 8208FE2Ch-8208FE38h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8208FE38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FE38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FE38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FE38);
		  /* 8208FE38h */ case    0:  		/* mfspr R12, LR */
		/* 8208FE38h case    0:*/		regs.R12 = regs.LR;
		/* 8208FE38h case    0:*/		return 0x8208FE3C;
		  /* 8208FE3Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8208FE3Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208FE3Ch case    1:*/		return 0x8208FE40;
		  /* 8208FE40h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8208FE40h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208FE40h case    2:*/		return 0x8208FE44;
		  /* 8208FE44h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8208FE44h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8208FE44h case    3:*/		return 0x8208FE48;
	}
	return 0x8208FE48;
} // Block from 8208FE38h-8208FE48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8208FE48h
// Function 'RtlCreateHeap'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FE48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FE48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FE48);
		  /* 8208FE48h */ case    0:  		/* mr R31, R3 */
		/* 8208FE48h case    0:*/		regs.R31 = regs.R3;
		/* 8208FE48h case    0:*/		return 0x8208FE4C;
		  /* 8208FE4Ch */ case    1:  		/* lwz R3, <#[R3]> */
		/* 8208FE4Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 8208FE4Ch case    1:*/		return 0x8208FE50;
		  /* 8208FE50h */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 8208FE50h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8208FE50h case    2:*/		return 0x8208FE54;
		  /* 8208FE54h */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 8208FE54h case    3:*/		if ( regs.CR[6].eq ) { return 0x8208FE7C;  }
		/* 8208FE54h case    3:*/		return 0x8208FE58;
		  /* 8208FE58h */ case    4:  		/* lwz R10, <#[R31 + 4]> */
		/* 8208FE58h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8208FE58h case    4:*/		return 0x8208FE5C;
		  /* 8208FE5Ch */ case    5:  		/* mr R11, R3 */
		/* 8208FE5Ch case    5:*/		regs.R11 = regs.R3;
		/* 8208FE5Ch case    5:*/		return 0x8208FE60;
		  /* 8208FE60h */ case    6:  		/* cmplw CR6, R3, R10 */
		/* 8208FE60h case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 8208FE60h case    6:*/		return 0x8208FE64;
		  /* 8208FE64h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 8208FE64h case    7:*/		if ( regs.CR[6].eq ) { return 0x8208FE78;  }
		/* 8208FE64h case    7:*/		return 0x8208FE68;
		  /* 8208FE68h */ case    8:  		/* rlwinm R10, R10, 0, 0, 31 */
		/* 8208FE68h case    8:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R10);
		/* 8208FE68h case    8:*/		return 0x8208FE6C;
		  /* 8208FE6Ch */ case    9:  		/* addi R11, R11, 776 */
		/* 8208FE6Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x308);
		/* 8208FE6Ch case    9:*/		return 0x8208FE70;
		  /* 8208FE70h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 8208FE70h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8208FE70h case   10:*/		return 0x8208FE74;
		  /* 8208FE74h */ case   11:  		/* bc 4, CR6_EQ, -8 */
		/* 8208FE74h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8208FE6C;  }
		/* 8208FE74h case   11:*/		return 0x8208FE78;
	}
	return 0x8208FE78;
} // Block from 8208FE48h-8208FE78h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8208FE78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FE78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FE78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FE78);
		  /* 8208FE78h */ case    0:  		/* bl 9456 */
		/* 8208FE78h case    0:*/		regs.LR = 0x8208FE7C; return 0x82092368;
		/* 8208FE78h case    0:*/		return 0x8208FE7C;
	}
	return 0x8208FE7C;
} // Block from 8208FE78h-8208FE7Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208FE7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FE7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FE7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FE7C);
		  /* 8208FE7Ch */ case    0:  		/* li R11, 0 */
		/* 8208FE7Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8208FE7Ch case    0:*/		return 0x8208FE80;
		  /* 8208FE80h */ case    1:  		/* stw R11, <#[R31]> */
		/* 8208FE80h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8208FE80h case    1:*/		return 0x8208FE84;
		  /* 8208FE84h */ case    2:  		/* stw R11, <#[R31 + 4]> */
		/* 8208FE84h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8208FE84h case    2:*/		return 0x8208FE88;
		  /* 8208FE88h */ case    3:  		/* stw R11, <#[R31 + 8]> */
		/* 8208FE88h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8208FE88h case    3:*/		return 0x8208FE8C;
		  /* 8208FE8Ch */ case    4:  		/* addi R1, R1, 96 */
		/* 8208FE8Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8208FE8Ch case    4:*/		return 0x8208FE90;
		  /* 8208FE90h */ case    5:  		/* lwz R12, <#[R1 - 8]> */
		/* 8208FE90h case    5:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8208FE90h case    5:*/		return 0x8208FE94;
		  /* 8208FE94h */ case    6:  		/* mtspr LR, R12 */
		/* 8208FE94h case    6:*/		regs.LR = regs.R12;
		/* 8208FE94h case    6:*/		return 0x8208FE98;
		  /* 8208FE98h */ case    7:  		/* ld R31, <#[R1 - 16]> */
		/* 8208FE98h case    7:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8208FE98h case    7:*/		return 0x8208FE9C;
		  /* 8208FE9Ch */ case    8:  		/* bclr 20, CR0_LT */
		/* 8208FE9Ch case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8208FE9Ch case    8:*/		return 0x8208FEA0;
	}
	return 0x8208FEA0;
} // Block from 8208FE7Ch-8208FEA0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8208FEA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FEA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FEA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FEA0);
		  /* 8208FEA0h */ case    0:  		/* mfspr R12, LR */
		/* 8208FEA0h case    0:*/		regs.R12 = regs.LR;
		/* 8208FEA0h case    0:*/		return 0x8208FEA4;
		  /* 8208FEA4h */ case    1:  		/* bl 5032 */
		/* 8208FEA4h case    1:*/		regs.LR = 0x8208FEA8; return 0x8209124C;
		/* 8208FEA4h case    1:*/		return 0x8208FEA8;
		  /* 8208FEA8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8208FEA8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8208FEA8h case    2:*/		return 0x8208FEAC;
		  /* 8208FEACh */ case    3:  		/* lis R11, 84 */
		/* 8208FEACh case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0x54);
		/* 8208FEACh case    3:*/		return 0x8208FEB0;
		  /* 8208FEB0h */ case    4:  		/* mr R31, R3 */
		/* 8208FEB0h case    4:*/		regs.R31 = regs.R3;
		/* 8208FEB0h case    4:*/		return 0x8208FEB4;
		  /* 8208FEB4h */ case    5:  		/* ori R11, R11, 29727 */
		/* 8208FEB4h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x741F);
		/* 8208FEB4h case    5:*/		return 0x8208FEB8;
		  /* 8208FEB8h */ case    6:  		/* mr R26, R4 */
		/* 8208FEB8h case    6:*/		regs.R26 = regs.R4;
		/* 8208FEB8h case    6:*/		return 0x8208FEBC;
		  /* 8208FEBCh */ case    7:  		/* cmplw CR6, R4, R11 */
		/* 8208FEBCh case    7:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 8208FEBCh case    7:*/		return 0x8208FEC0;
		  /* 8208FEC0h */ case    8:  		/* bc 4, CR6_GT, 16 */
		/* 8208FEC0h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8208FED0;  }
		/* 8208FEC0h case    8:*/		return 0x8208FEC4;
		  /* 8208FEC4h */ case    9:  		/* lis R11, -32255 */
		/* 8208FEC4h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208FEC4h case    9:*/		return 0x8208FEC8;
		  /* 8208FEC8h */ case   10:  		/* addi R3, R11, -24880 */
		/* 8208FEC8h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF9ED0);
		/* 8208FEC8h case   10:*/		return 0x8208FECC;
		  /* 8208FECCh */ case   11:  		/* bl 60516 */
		/* 8208FECCh case   11:*/		regs.LR = 0x8208FED0; return 0x8209EB30;
		/* 8208FECCh case   11:*/		return 0x8208FED0;
	}
	return 0x8208FED0;
} // Block from 8208FEA0h-8208FED0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8208FED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FED0);
		  /* 8208FED0h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8208FED0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8208FED0h case    0:*/		return 0x8208FED4;
		  /* 8208FED4h */ case    1:  		/* li R25, 776 */
		/* 8208FED4h case    1:*/		cpu::op::li<0>(regs,&regs.R25,0x308);
		/* 8208FED4h case    1:*/		return 0x8208FED8;
		  /* 8208FED8h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 8208FED8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8208FED8h case    2:*/		return 0x8208FEDC;
		  /* 8208FEDCh */ case    3:  		/* subf R11, R11, R10 */
		/* 8208FEDCh case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8208FEDCh case    3:*/		return 0x8208FEE0;
		  /* 8208FEE0h */ case    4:  		/* divw R11, R11, R25 */
		/* 8208FEE0h case    4:*/		cpu::op::divw<0>(regs,&regs.R11,regs.R11,regs.R25);
		/* 8208FEE0h case    4:*/		return 0x8208FEE4;
		  /* 8208FEE4h */ case    5:  		/* cmplw CR6, R11, R26 */
		/* 8208FEE4h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 8208FEE4h case    5:*/		return 0x8208FEE8;
		  /* 8208FEE8h */ case    6:  		/* bc 4, CR6_LT, 160 */
		/* 8208FEE8h case    6:*/		if ( !regs.CR[6].lt ) { return 0x8208FF88;  }
		/* 8208FEE8h case    6:*/		return 0x8208FEEC;
		  /* 8208FEECh */ case    7:  		/* li R4, 0 */
		/* 8208FEECh case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208FEECh case    7:*/		return 0x8208FEF0;
		  /* 8208FEF0h */ case    8:  		/* mr R3, R26 */
		/* 8208FEF0h case    8:*/		regs.R3 = regs.R26;
		/* 8208FEF0h case    8:*/		return 0x8208FEF4;
		  /* 8208FEF4h */ case    9:  		/* bl -588 */
		/* 8208FEF4h case    9:*/		regs.LR = 0x8208FEF8; return 0x8208FCA8;
		/* 8208FEF4h case    9:*/		return 0x8208FEF8;
		  /* 8208FEF8h */ case   10:  		/* lwz R30, <#[R31]> */
		/* 8208FEF8h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000000) );
		/* 8208FEF8h case   10:*/		return 0x8208FEFC;
		  /* 8208FEFCh */ case   11:  		/* lwz R28, <#[R31 + 4]> */
		/* 8208FEFCh case   11:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000004) );
		/* 8208FEFCh case   11:*/		return 0x8208FF00;
		  /* 8208FF00h */ case   12:  		/* mr R27, R3 */
		/* 8208FF00h case   12:*/		regs.R27 = regs.R3;
		/* 8208FF00h case   12:*/		return 0x8208FF04;
		  /* 8208FF04h */ case   13:  		/* mr R29, R3 */
		/* 8208FF04h case   13:*/		regs.R29 = regs.R3;
		/* 8208FF04h case   13:*/		return 0x8208FF08;
		  /* 8208FF08h */ case   14:  		/* b 36 */
		/* 8208FF08h case   14:*/		return 0x8208FF2C;
		/* 8208FF08h case   14:*/		return 0x8208FF0C;
		  /* 8208FF0Ch */ case   15:  		/* cmplwi CR6, R29, 0 */
		/* 8208FF0Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8208FF0Ch case   15:*/		return 0x8208FF10;
		  /* 8208FF10h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 8208FF10h case   16:*/		if ( regs.CR[6].eq ) { return 0x8208FF24;  }
		/* 8208FF10h case   16:*/		return 0x8208FF14;
		  /* 8208FF14h */ case   17:  		/* li R5, 776 */
		/* 8208FF14h case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x308);
		/* 8208FF14h case   17:*/		return 0x8208FF18;
		  /* 8208FF18h */ case   18:  		/* mr R4, R30 */
		/* 8208FF18h case   18:*/		regs.R4 = regs.R30;
		/* 8208FF18h case   18:*/		return 0x8208FF1C;
		  /* 8208FF1Ch */ case   19:  		/* mr R3, R29 */
		/* 8208FF1Ch case   19:*/		regs.R3 = regs.R29;
		/* 8208FF1Ch case   19:*/		return 0x8208FF20;
		  /* 8208FF20h */ case   20:  		/* bl 6800 */
		/* 8208FF20h case   20:*/		regs.LR = 0x8208FF24; return 0x820919B0;
		/* 8208FF20h case   20:*/		return 0x8208FF24;
	}
	return 0x8208FF24;
} // Block from 8208FED0h-8208FF24h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8208FF24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FF24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FF24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FF24);
		  /* 8208FF24h */ case    0:  		/* addi R30, R30, 776 */
		/* 8208FF24h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x308);
		/* 8208FF24h case    0:*/		return 0x8208FF28;
		  /* 8208FF28h */ case    1:  		/* addi R29, R29, 776 */
		/* 8208FF28h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x308);
		/* 8208FF28h case    1:*/		return 0x8208FF2C;
	}
	return 0x8208FF2C;
} // Block from 8208FF24h-8208FF2Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8208FF2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FF2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FF2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FF2C);
		  /* 8208FF2Ch */ case    0:  		/* cmplw CR6, R30, R28 */
		/* 8208FF2Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R28);
		/* 8208FF2Ch case    0:*/		return 0x8208FF30;
		  /* 8208FF30h */ case    1:  		/* bc 4, CR6_EQ, -36 */
		/* 8208FF30h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8208FF0C;  }
		/* 8208FF30h case    1:*/		return 0x8208FF34;
		  /* 8208FF34h */ case    2:  		/* lwz R3, <#[R31]> */
		/* 8208FF34h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8208FF34h case    2:*/		return 0x8208FF38;
		  /* 8208FF38h */ case    3:  		/* lwz R11, <#[R31 + 4]> */
		/* 8208FF38h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8208FF38h case    3:*/		return 0x8208FF3C;
		  /* 8208FF3Ch */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 8208FF3Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8208FF3Ch case    4:*/		return 0x8208FF40;
		  /* 8208FF40h */ case    5:  		/* subf R10, R3, R11 */
		/* 8208FF40h case    5:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R3,regs.R11);
		/* 8208FF40h case    5:*/		return 0x8208FF44;
		  /* 8208FF44h */ case    6:  		/* divw R30, R10, R25 */
		/* 8208FF44h case    6:*/		cpu::op::divw<0>(regs,&regs.R30,regs.R10,regs.R25);
		/* 8208FF44h case    6:*/		return 0x8208FF48;
		  /* 8208FF48h */ case    7:  		/* bc 12, CR6_EQ, 36 */
		/* 8208FF48h case    7:*/		if ( regs.CR[6].eq ) { return 0x8208FF6C;  }
		/* 8208FF48h case    7:*/		return 0x8208FF4C;
		  /* 8208FF4Ch */ case    8:  		/* mr R10, R3 */
		/* 8208FF4Ch case    8:*/		regs.R10 = regs.R3;
		/* 8208FF4Ch case    8:*/		return 0x8208FF50;
		  /* 8208FF50h */ case    9:  		/* cmplw CR6, R3, R11 */
		/* 8208FF50h case    9:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8208FF50h case    9:*/		return 0x8208FF54;
		  /* 8208FF54h */ case   10:  		/* bc 12, CR6_EQ, 20 */
		/* 8208FF54h case   10:*/		if ( regs.CR[6].eq ) { return 0x8208FF68;  }
		/* 8208FF54h case   10:*/		return 0x8208FF58;
		  /* 8208FF58h */ case   11:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 8208FF58h case   11:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 8208FF58h case   11:*/		return 0x8208FF5C;
		  /* 8208FF5Ch */ case   12:  		/* addi R10, R10, 776 */
		/* 8208FF5Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x308);
		/* 8208FF5Ch case   12:*/		return 0x8208FF60;
		  /* 8208FF60h */ case   13:  		/* cmplw CR6, R10, R11 */
		/* 8208FF60h case   13:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208FF60h case   13:*/		return 0x8208FF64;
		  /* 8208FF64h */ case   14:  		/* bc 4, CR6_EQ, -8 */
		/* 8208FF64h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8208FF5C;  }
		/* 8208FF64h case   14:*/		return 0x8208FF68;
	}
	return 0x8208FF68;
} // Block from 8208FF2Ch-8208FF68h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8208FF68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FF68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FF68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FF68);
		  /* 8208FF68h */ case    0:  		/* bl 9216 */
		/* 8208FF68h case    0:*/		regs.LR = 0x8208FF6C; return 0x82092368;
		/* 8208FF68h case    0:*/		return 0x8208FF6C;
	}
	return 0x8208FF6C;
} // Block from 8208FF68h-8208FF6Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8208FF6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FF6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FF6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FF6C);
		  /* 8208FF6Ch */ case    0:  		/* mulli R10, R26, 776 */
		/* 8208FF6Ch case    0:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R26,0x308);
		/* 8208FF6Ch case    0:*/		return 0x8208FF70;
		  /* 8208FF70h */ case    1:  		/* stw R27, <#[R31]> */
		/* 8208FF70h case    1:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000000) );
		/* 8208FF70h case    1:*/		return 0x8208FF74;
		  /* 8208FF74h */ case    2:  		/* mulli R11, R30, 776 */
		/* 8208FF74h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R30,0x308);
		/* 8208FF74h case    2:*/		return 0x8208FF78;
		  /* 8208FF78h */ case    3:  		/* add R10, R10, R27 */
		/* 8208FF78h case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R27);
		/* 8208FF78h case    3:*/		return 0x8208FF7C;
		  /* 8208FF7Ch */ case    4:  		/* add R11, R11, R27 */
		/* 8208FF7Ch case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 8208FF7Ch case    4:*/		return 0x8208FF80;
		  /* 8208FF80h */ case    5:  		/* stw R10, <#[R31 + 8]> */
		/* 8208FF80h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8208FF80h case    5:*/		return 0x8208FF84;
		  /* 8208FF84h */ case    6:  		/* stw R11, <#[R31 + 4]> */
		/* 8208FF84h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8208FF84h case    6:*/		return 0x8208FF88;
	}
	return 0x8208FF88;
} // Block from 8208FF6Ch-8208FF88h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8208FF88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FF88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FF88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FF88);
		  /* 8208FF88h */ case    0:  		/* addi R1, R1, 144 */
		/* 8208FF88h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8208FF88h case    0:*/		return 0x8208FF8C;
		  /* 8208FF8Ch */ case    1:  		/* b 4880 */
		/* 8208FF8Ch case    1:*/		return 0x8209129C;
		/* 8208FF8Ch case    1:*/		return 0x8208FF90;
		  /* 8208FF90h */ case    2:  		/* lis R10, 84 */
		/* 8208FF90h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0x54);
		/* 8208FF90h case    2:*/		return 0x8208FF94;
		  /* 8208FF94h */ case    3:  		/* lwz R7, <#[R3 + 4]> */
		/* 8208FF94h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000004) );
		/* 8208FF94h case    3:*/		return 0x8208FF98;
		  /* 8208FF98h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 8208FF98h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8208FF98h case    4:*/		return 0x8208FF9C;
		  /* 8208FF9Ch */ case    5:  		/* li R9, 776 */
		/* 8208FF9Ch case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x308);
		/* 8208FF9Ch case    5:*/		return 0x8208FFA0;
		  /* 8208FFA0h */ case    6:  		/* ori R8, R10, 29727 */
		/* 8208FFA0h case    6:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x741F);
		/* 8208FFA0h case    6:*/		return 0x8208FFA4;
		  /* 8208FFA4h */ case    7:  		/* subf R10, R11, R7 */
		/* 8208FFA4h case    7:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R7);
		/* 8208FFA4h case    7:*/		return 0x8208FFA8;
		  /* 8208FFA8h */ case    8:  		/* subf R7, R4, R8 */
		/* 8208FFA8h case    8:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R4,regs.R8);
		/* 8208FFA8h case    8:*/		return 0x8208FFAC;
		  /* 8208FFACh */ case    9:  		/* divw R10, R10, R9 */
		/* 8208FFACh case    9:*/		cpu::op::divw<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8208FFACh case    9:*/		return 0x8208FFB0;
		  /* 8208FFB0h */ case   10:  		/* cmplw CR6, R7, R10 */
		/* 8208FFB0h case   10:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 8208FFB0h case   10:*/		return 0x8208FFB4;
		  /* 8208FFB4h */ case   11:  		/* bc 4, CR6_LT, 16 */
		/* 8208FFB4h case   11:*/		if ( !regs.CR[6].lt ) { return 0x8208FFC4;  }
		/* 8208FFB4h case   11:*/		return 0x8208FFB8;
		  /* 8208FFB8h */ case   12:  		/* lis R11, -32255 */
		/* 8208FFB8h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8208FFB8h case   12:*/		return 0x8208FFBC;
		  /* 8208FFBCh */ case   13:  		/* addi R3, R11, -24880 */
		/* 8208FFBCh case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF9ED0);
		/* 8208FFBCh case   13:*/		return 0x8208FFC0;
		  /* 8208FFC0h */ case   14:  		/* b 60272 */
		/* 8208FFC0h case   14:*/		return 0x8209EB30;
		/* 8208FFC0h case   14:*/		return 0x8208FFC4;
	}
	return 0x8208FFC4;
} // Block from 8208FF88h-8208FFC4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8208FFC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FFC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FFC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FFC4);
		  /* 8208FFC4h */ case    0:  		/* lwz R7, <#[R3 + 8]> */
		/* 8208FFC4h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000008) );
		/* 8208FFC4h case    0:*/		return 0x8208FFC8;
		  /* 8208FFC8h */ case    1:  		/* add R10, R10, R4 */
		/* 8208FFC8h case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R4);
		/* 8208FFC8h case    1:*/		return 0x8208FFCC;
		  /* 8208FFCCh */ case    2:  		/* subf R11, R11, R7 */
		/* 8208FFCCh case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 8208FFCCh case    2:*/		return 0x8208FFD0;
		  /* 8208FFD0h */ case    3:  		/* divw R11, R11, R9 */
		/* 8208FFD0h case    3:*/		cpu::op::divw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8208FFD0h case    3:*/		return 0x8208FFD4;
		  /* 8208FFD4h */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 8208FFD4h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8208FFD4h case    4:*/		return 0x8208FFD8;
		  /* 8208FFD8h */ case    5:  		/* bclr 4, CR6_GT */
		/* 8208FFD8h case    5:*/		if ( !regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 8208FFD8h case    5:*/		return 0x8208FFDC;
	}
	return 0x8208FFDC;
} // Block from 8208FFC4h-8208FFDCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208FFDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FFDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FFDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FFDC);
		  /* 8208FFDCh */ case    0:  		/* rlwinm R9, R11, 31, 1, 31 */
		/* 8208FFDCh case    0:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R9,regs.R11);
		/* 8208FFDCh case    0:*/		return 0x8208FFE0;
		  /* 8208FFE0h */ case    1:  		/* li R4, 0 */
		/* 8208FFE0h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8208FFE0h case    1:*/		return 0x8208FFE4;
		  /* 8208FFE4h */ case    2:  		/* subf R8, R9, R8 */
		/* 8208FFE4h case    2:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R9,regs.R8);
		/* 8208FFE4h case    2:*/		return 0x8208FFE8;
		  /* 8208FFE8h */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 8208FFE8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8208FFE8h case    3:*/		return 0x8208FFEC;
		  /* 8208FFECh */ case    4:  		/* bc 12, CR6_LT, 8 */
		/* 8208FFECh case    4:*/		if ( regs.CR[6].lt ) { return 0x8208FFF4;  }
		/* 8208FFECh case    4:*/		return 0x8208FFF0;
		  /* 8208FFF0h */ case    5:  		/* add R4, R9, R11 */
		/* 8208FFF0h case    5:*/		cpu::op::add<0>(regs,&regs.R4,regs.R9,regs.R11);
		/* 8208FFF0h case    5:*/		return 0x8208FFF4;
	}
	return 0x8208FFF4;
} // Block from 8208FFDCh-8208FFF4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8208FFF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8208FFF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8208FFF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8208FFF4);
		  /* 8208FFF4h */ case    0:  		/* cmplw CR6, R4, R10 */
		/* 8208FFF4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 8208FFF4h case    0:*/		return 0x8208FFF8;
		  /* 8208FFF8h */ case    1:  		/* bc 4, CR6_LT, 8 */
		/* 8208FFF8h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82090000;  }
		/* 8208FFF8h case    1:*/		return 0x8208FFFC;
		  /* 8208FFFCh */ case    2:  		/* mr R4, R10 */
		/* 8208FFFCh case    2:*/		regs.R4 = regs.R10;
		/* 8208FFFCh case    2:*/		return 0x82090000;
	}
	return 0x82090000;
} // Block from 8208FFF4h-82090000h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82090000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090000);
		  /* 82090000h */ case    0:  		/* b -352 */
		/* 82090000h case    0:*/		return 0x8208FEA0;
		/* 82090000h case    0:*/		return 0x82090004;
		  /* 82090004h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82090004h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82090004h case    1:*/		return 0x82090008;
	}
	return 0x82090008;
} // Block from 82090000h-82090008h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82090008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090008);
		  /* 82090008h */ case    0:  		/* mfspr R12, LR */
		/* 82090008h case    0:*/		regs.R12 = regs.LR;
		/* 82090008h case    0:*/		return 0x8209000C;
		  /* 8209000Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209000Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209000Ch case    1:*/		return 0x82090010;
		  /* 82090010h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82090010h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82090010h case    2:*/		return 0x82090014;
		  /* 82090014h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82090014h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82090014h case    3:*/		return 0x82090018;
		  /* 82090018h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82090018h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82090018h case    4:*/		return 0x8209001C;
		  /* 8209001Ch */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 8209001Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8209001Ch case    5:*/		return 0x82090020;
		  /* 82090020h */ case    6:  		/* mr R31, R3 */
		/* 82090020h case    6:*/		regs.R31 = regs.R3;
		/* 82090020h case    6:*/		return 0x82090024;
		  /* 82090024h */ case    7:  		/* mr R30, R4 */
		/* 82090024h case    7:*/		regs.R30 = regs.R4;
		/* 82090024h case    7:*/		return 0x82090028;
		  /* 82090028h */ case    8:  		/* cmplw CR6, R4, R11 */
		/* 82090028h case    8:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 82090028h case    8:*/		return 0x8209002C;
		  /* 8209002Ch */ case    9:  		/* bc 4, CR6_LT, 20 */
		/* 8209002Ch case    9:*/		if ( !regs.CR[6].lt ) { return 0x82090040;  }
		/* 8209002Ch case    9:*/		return 0x82090030;
		  /* 82090030h */ case   10:  		/* lwz R10, <#[R3]> */
		/* 82090030h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82090030h case   10:*/		return 0x82090034;
		  /* 82090034h */ case   11:  		/* cmplw CR6, R10, R4 */
		/* 82090034h case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R4);
		/* 82090034h case   11:*/		return 0x82090038;
		  /* 82090038h */ case   12:  		/* li R10, 1 */
		/* 82090038h case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82090038h case   12:*/		return 0x8209003C;
		  /* 8209003Ch */ case   13:  		/* bc 4, CR6_GT, 8 */
		/* 8209003Ch case   13:*/		if ( !regs.CR[6].gt ) { return 0x82090044;  }
		/* 8209003Ch case   13:*/		return 0x82090040;
	}
	return 0x82090040;
} // Block from 82090008h-82090040h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82090040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090040);
		  /* 82090040h */ case    0:  		/* li R10, 0 */
		/* 82090040h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82090040h case    0:*/		return 0x82090044;
	}
	return 0x82090044;
} // Block from 82090040h-82090044h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82090044h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090044( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090044) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090044);
		  /* 82090044h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82090044h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82090044h case    0:*/		return 0x82090048;
		  /* 82090048h */ case    1:  		/* bc 12, CR0_EQ, 72 */
		/* 82090048h case    1:*/		if ( regs.CR[0].eq ) { return 0x82090090;  }
		/* 82090048h case    1:*/		return 0x8209004C;
		  /* 8209004Ch */ case    2:  		/* lwz R10, <#[R31]> */
		/* 8209004Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8209004Ch case    2:*/		return 0x82090050;
		  /* 82090050h */ case    3:  		/* li R9, 776 */
		/* 82090050h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x308);
		/* 82090050h case    3:*/		return 0x82090054;
		  /* 82090054h */ case    4:  		/* lwz R8, <#[R31 + 8]> */
		/* 82090054h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 82090054h case    4:*/		return 0x82090058;
		  /* 82090058h */ case    5:  		/* subf R10, R10, R30 */
		/* 82090058h case    5:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R30);
		/* 82090058h case    5:*/		return 0x8209005C;
		  /* 8209005Ch */ case    6:  		/* cmplw CR6, R11, R8 */
		/* 8209005Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8209005Ch case    6:*/		return 0x82090060;
		  /* 82090060h */ case    7:  		/* divw R30, R10, R9 */
		/* 82090060h case    7:*/		cpu::op::divw<0>(regs,&regs.R30,regs.R10,regs.R9);
		/* 82090060h case    7:*/		return 0x82090064;
		  /* 82090064h */ case    8:  		/* bc 4, CR6_EQ, 16 */
		/* 82090064h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82090074;  }
		/* 82090064h case    8:*/		return 0x82090068;
		  /* 82090068h */ case    9:  		/* li R4, 1 */
		/* 82090068h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82090068h case    9:*/		return 0x8209006C;
		  /* 8209006Ch */ case   10:  		/* mr R3, R31 */
		/* 8209006Ch case   10:*/		regs.R3 = regs.R31;
		/* 8209006Ch case   10:*/		return 0x82090070;
		  /* 82090070h */ case   11:  		/* bl -224 */
		/* 82090070h case   11:*/		regs.LR = 0x82090074; return 0x8208FF90;
		/* 82090070h case   11:*/		return 0x82090074;
	}
	return 0x82090074;
} // Block from 82090044h-82090074h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82090074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090074);
		  /* 82090074h */ case    0:  		/* lwz R10, <#[R31]> */
		/* 82090074h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82090074h case    0:*/		return 0x82090078;
		  /* 82090078h */ case    1:  		/* mulli R11, R30, 776 */
		/* 82090078h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R30,0x308);
		/* 82090078h case    1:*/		return 0x8209007C;
		  /* 8209007Ch */ case    2:  		/* lwz R3, <#[R31 + 4]> */
		/* 8209007Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 8209007Ch case    2:*/		return 0x82090080;
		  /* 82090080h */ case    3:  		/* add R4, R11, R10 */
		/* 82090080h case    3:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R10);
		/* 82090080h case    3:*/		return 0x82090084;
		  /* 82090084h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 82090084h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82090084h case    4:*/		return 0x82090088;
		  /* 82090088h */ case    5:  		/* bc 12, CR6_EQ, 56 */
		/* 82090088h case    5:*/		if ( regs.CR[6].eq ) { return 0x820900C0;  }
		/* 82090088h case    5:*/		return 0x8209008C;
		  /* 8209008Ch */ case    6:  		/* b 44 */
		/* 8209008Ch case    6:*/		return 0x820900B8;
		/* 8209008Ch case    6:*/		return 0x82090090;
	}
	return 0x82090090;
} // Block from 82090074h-82090090h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82090090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090090);
		  /* 82090090h */ case    0:  		/* lwz R10, <#[R31 + 8]> */
		/* 82090090h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82090090h case    0:*/		return 0x82090094;
		  /* 82090094h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 82090094h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82090094h case    1:*/		return 0x82090098;
		  /* 82090098h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 82090098h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820900A8;  }
		/* 82090098h case    2:*/		return 0x8209009C;
		  /* 8209009Ch */ case    3:  		/* li R4, 1 */
		/* 8209009Ch case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8209009Ch case    3:*/		return 0x820900A0;
		  /* 820900A0h */ case    4:  		/* mr R3, R31 */
		/* 820900A0h case    4:*/		regs.R3 = regs.R31;
		/* 820900A0h case    4:*/		return 0x820900A4;
		  /* 820900A4h */ case    5:  		/* bl -276 */
		/* 820900A4h case    5:*/		regs.LR = 0x820900A8; return 0x8208FF90;
		/* 820900A4h case    5:*/		return 0x820900A8;
	}
	return 0x820900A8;
} // Block from 82090090h-820900A8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820900A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820900A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820900A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820900A8);
		  /* 820900A8h */ case    0:  		/* lwz R3, <#[R31 + 4]> */
		/* 820900A8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820900A8h case    0:*/		return 0x820900AC;
		  /* 820900ACh */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820900ACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820900ACh case    1:*/		return 0x820900B0;
		  /* 820900B0h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 820900B0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820900C0;  }
		/* 820900B0h case    2:*/		return 0x820900B4;
		  /* 820900B4h */ case    3:  		/* mr R4, R30 */
		/* 820900B4h case    3:*/		regs.R4 = regs.R30;
		/* 820900B4h case    3:*/		return 0x820900B8;
	}
	return 0x820900B8;
} // Block from 820900A8h-820900B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820900B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820900B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820900B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820900B8);
		  /* 820900B8h */ case    0:  		/* li R5, 776 */
		/* 820900B8h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x308);
		/* 820900B8h case    0:*/		return 0x820900BC;
		  /* 820900BCh */ case    1:  		/* bl 6388 */
		/* 820900BCh case    1:*/		regs.LR = 0x820900C0; return 0x820919B0;
		/* 820900BCh case    1:*/		return 0x820900C0;
	}
	return 0x820900C0;
} // Block from 820900B8h-820900C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820900C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820900C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820900C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820900C0);
		  /* 820900C0h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 820900C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820900C0h case    0:*/		return 0x820900C4;
		  /* 820900C4h */ case    1:  		/* addi R11, R11, 776 */
		/* 820900C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x308);
		/* 820900C4h case    1:*/		return 0x820900C8;
		  /* 820900C8h */ case    2:  		/* stw R11, <#[R31 + 4]> */
		/* 820900C8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820900C8h case    2:*/		return 0x820900CC;
		  /* 820900CCh */ case    3:  		/* addi R1, R1, 112 */
		/* 820900CCh case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820900CCh case    3:*/		return 0x820900D0;
		  /* 820900D0h */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 820900D0h case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820900D0h case    4:*/		return 0x820900D4;
		  /* 820900D4h */ case    5:  		/* mtspr LR, R12 */
		/* 820900D4h case    5:*/		regs.LR = regs.R12;
		/* 820900D4h case    5:*/		return 0x820900D8;
		  /* 820900D8h */ case    6:  		/* ld R30, <#[R1 - 24]> */
		/* 820900D8h case    6:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820900D8h case    6:*/		return 0x820900DC;
		  /* 820900DCh */ case    7:  		/* ld R31, <#[R1 - 16]> */
		/* 820900DCh case    7:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820900DCh case    7:*/		return 0x820900E0;
		  /* 820900E0h */ case    8:  		/* bclr 20, CR0_LT */
		/* 820900E0h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820900E0h case    8:*/		return 0x820900E4;
	}
	return 0x820900E4;
} // Block from 820900C0h-820900E4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820900E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820900E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820900E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820900E4);
		  /* 820900E4h */ case    0:  		/* nop */
		/* 820900E4h case    0:*/		cpu::op::nop();
		/* 820900E4h case    0:*/		return 0x820900E8;
	}
	return 0x820900E8;
} // Block from 820900E4h-820900E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820900E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820900E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820900E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820900E8);
		  /* 820900E8h */ case    0:  		/* mfspr R12, LR */
		/* 820900E8h case    0:*/		regs.R12 = regs.LR;
		/* 820900E8h case    0:*/		return 0x820900EC;
		  /* 820900ECh */ case    1:  		/* bl 4460 */
		/* 820900ECh case    1:*/		regs.LR = 0x820900F0; return 0x82091258;
		/* 820900ECh case    1:*/		return 0x820900F0;
		  /* 820900F0h */ case    2:  		/* stwu R1, <#[R1 - 896]> */
		/* 820900F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFC80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFC80);
		/* 820900F0h case    2:*/		return 0x820900F4;
		  /* 820900F4h */ case    3:  		/* lis R10, -32215 */
		/* 820900F4h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 820900F4h case    3:*/		return 0x820900F8;
		  /* 820900F8h */ case    4:  		/* lis R11, -32215 */
		/* 820900F8h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 820900F8h case    4:*/		return 0x820900FC;
		  /* 820900FCh */ case    5:  		/* mr R29, R3 */
		/* 820900FCh case    5:*/		regs.R29 = regs.R3;
		/* 820900FCh case    5:*/		return 0x82090100;
		  /* 82090100h */ case    6:  		/* addi R31, R11, -31208 */
		/* 82090100h case    6:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFF8618);
		/* 82090100h case    6:*/		return 0x82090104;
		  /* 82090104h */ case    7:  		/* mr R28, R4 */
		/* 82090104h case    7:*/		regs.R28 = regs.R4;
		/* 82090104h case    7:*/		return 0x82090108;
		  /* 82090108h */ case    8:  		/* lwz R11, <#[R10 - 31192]> */
		/* 82090108h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0xFFFF8628) );
		/* 82090108h case    8:*/		return 0x8209010C;
		  /* 8209010Ch */ case    9:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 8209010Ch case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 8209010Ch case    9:*/		return 0x82090110;
		  /* 82090110h */ case   10:  		/* bc 4, CR0_EQ, 48 */
		/* 82090110h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82090140;  }
		/* 82090110h case   10:*/		return 0x82090114;
		  /* 82090114h */ case   11:  		/* ori R11, R11, 1 */
		/* 82090114h case   11:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82090114h case   11:*/		return 0x82090118;
		  /* 82090118h */ case   12:  		/* li R9, 0 */
		/* 82090118h case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82090118h case   12:*/		return 0x8209011C;
		  /* 8209011Ch */ case   13:  		/* stw R11, <#[R10 - 31192]> */
		/* 8209011Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0xFFFF8628) );
		/* 8209011Ch case   13:*/		return 0x82090120;
		  /* 82090120h */ case   14:  		/* li R8, 0 */
		/* 82090120h case   14:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82090120h case   14:*/		return 0x82090124;
		  /* 82090124h */ case   15:  		/* li R11, 0 */
		/* 82090124h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82090124h case   15:*/		return 0x82090128;
		  /* 82090128h */ case   16:  		/* stw R9, <#[R31]> */
		/* 82090128h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82090128h case   16:*/		return 0x8209012C;
		  /* 8209012Ch */ case   17:  		/* stw R8, <#[R31 + 4]> */
		/* 8209012Ch case   17:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 8209012Ch case   17:*/		return 0x82090130;
		  /* 82090130h */ case   18:  		/* lis R10, -32217 */
		/* 82090130h case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 82090130h case   18:*/		return 0x82090134;
		  /* 82090134h */ case   19:  		/* stw R11, <#[R31 + 8]> */
		/* 82090134h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82090134h case   19:*/		return 0x82090138;
		  /* 82090138h */ case   20:  		/* addi R3, R10, -12656 */
		/* 82090138h case   20:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xFFFFCE90);
		/* 82090138h case   20:*/		return 0x8209013C;
		  /* 8209013Ch */ case   21:  		/* bl 14988 */
		/* 8209013Ch case   21:*/		regs.LR = 0x82090140; return 0x82093BC8;
		/* 8209013Ch case   21:*/		return 0x82090140;
	}
	return 0x82090140;
} // Block from 820900E8h-82090140h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82090140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090140);
		  /* 82090140h */ case    0:  		/* lhz R11, <#[R29]> */
		/* 82090140h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82090140h case    0:*/		return 0x82090144;
		  /* 82090144h */ case    1:  		/* li R30, 0 */
		/* 82090144h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82090144h case    1:*/		return 0x82090148;
		  /* 82090148h */ case    2:  		/* cmplwi CR6, R11, 16 */
		/* 82090148h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 82090148h case    2:*/		return 0x8209014C;
		  /* 8209014Ch */ case    3:  		/* bc 4, CR6_LT, 24 */
		/* 8209014Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x82090164;  }
		/* 8209014Ch case    3:*/		return 0x82090150;
		  /* 82090150h */ case    4:  		/* mr R11, R29 */
		/* 82090150h case    4:*/		regs.R11 = regs.R29;
		/* 82090150h case    4:*/		return 0x82090154;
		  /* 82090154h */ case    5:  		/* lhzu R10, <#[R11 + 12]> */
		/* 82090154h case    5:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		regs.R11 = (uint32)(regs.R11 + 0x0000000C);
		/* 82090154h case    5:*/		return 0x82090158;
		  /* 82090158h */ case    6:  		/* addi R30, R30, 1 */
		/* 82090158h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82090158h case    6:*/		return 0x8209015C;
		  /* 8209015Ch */ case    7:  		/* cmplwi CR6, R10, 16 */
		/* 8209015Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000010);
		/* 8209015Ch case    7:*/		return 0x82090160;
		  /* 82090160h */ case    8:  		/* bc 12, CR6_LT, -12 */
		/* 82090160h case    8:*/		if ( regs.CR[6].lt ) { return 0x82090154;  }
		/* 82090160h case    8:*/		return 0x82090164;
	}
	return 0x82090164;
} // Block from 82090140h-82090164h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82090164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090164);
		  /* 82090164h */ case    0:  		/* lwz R5, <#[R31]> */
		/* 82090164h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000000) );
		/* 82090164h case    0:*/		return 0x82090168;
		  /* 82090168h */ case    1:  		/* li R10, 776 */
		/* 82090168h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x308);
		/* 82090168h case    1:*/		return 0x8209016C;
		  /* 8209016Ch */ case    2:  		/* lwz R11, <#[R31 + 4]> */
		/* 8209016Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8209016Ch case    2:*/		return 0x82090170;
		  /* 82090170h */ case    3:  		/* li R6, 0 */
		/* 82090170h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82090170h case    3:*/		return 0x82090174;
		  /* 82090174h */ case    4:  		/* subf R11, R5, R11 */
		/* 82090174h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R5,regs.R11);
		/* 82090174h case    4:*/		return 0x82090178;
		  /* 82090178h */ case    5:  		/* divw. R4, R11, R10 */
		/* 82090178h case    5:*/		cpu::op::divw<1>(regs,&regs.R4,regs.R11,regs.R10);
		/* 82090178h case    5:*/		return 0x8209017C;
		  /* 8209017Ch */ case    6:  		/* bc 12, CR0_EQ, 104 */
		/* 8209017Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820901E4;  }
		/* 8209017Ch case    6:*/		return 0x82090180;
		  /* 82090180h */ case    7:  		/* mr R7, R5 */
		/* 82090180h case    7:*/		regs.R7 = regs.R5;
		/* 82090180h case    7:*/		return 0x82090184;
		  /* 82090184h */ case    8:  		/* lwz R11, <#[R7 + 768]> */
		/* 82090184h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000300) );
		/* 82090184h case    8:*/		return 0x82090188;
		  /* 82090188h */ case    9:  		/* cmplw CR6, R11, R30 */
		/* 82090188h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 82090188h case    9:*/		return 0x8209018C;
		  /* 8209018Ch */ case   10:  		/* bc 4, CR6_EQ, 72 */
		/* 8209018Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x820901D4;  }
		/* 8209018Ch case   10:*/		return 0x82090190;
		  /* 82090190h */ case   11:  		/* mulli R10, R30, 12 */
		/* 82090190h case   11:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R30,0xC);
		/* 82090190h case   11:*/		return 0x82090194;
		  /* 82090194h */ case   12:  		/* mr R9, R29 */
		/* 82090194h case   12:*/		regs.R9 = regs.R29;
		/* 82090194h case   12:*/		return 0x82090198;
		  /* 82090198h */ case   13:  		/* mr R11, R7 */
		/* 82090198h case   13:*/		regs.R11 = regs.R7;
		/* 82090198h case   13:*/		return 0x8209019C;
		  /* 8209019Ch */ case   14:  		/* li R8, 0 */
		/* 8209019Ch case   14:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8209019Ch case   14:*/		return 0x820901A0;
		  /* 820901A0h */ case   15:  		/* cmplwi CR6, R10, 0 */
		/* 820901A0h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820901A0h case   15:*/		return 0x820901A4;
		  /* 820901A4h */ case   16:  		/* bc 12, CR6_EQ, 40 */
		/* 820901A4h case   16:*/		if ( regs.CR[6].eq ) { return 0x820901CC;  }
		/* 820901A4h case   16:*/		return 0x820901A8;
		  /* 820901A8h */ case   17:  		/* add R10, R7, R10 */
		/* 820901A8h case   17:*/		cpu::op::add<0>(regs,&regs.R10,regs.R7,regs.R10);
		/* 820901A8h case   17:*/		return 0x820901AC;
		  /* 820901ACh */ case   18:  		/* lbz R8, <#[R11]> */
		/* 820901ACh case   18:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820901ACh case   18:*/		return 0x820901B0;
		  /* 820901B0h */ case   19:  		/* lbz R3, <#[R9]> */
		/* 820901B0h case   19:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R9 + 0x00000000) );
		/* 820901B0h case   19:*/		return 0x820901B4;
		  /* 820901B4h */ case   20:  		/* subf. R8, R3, R8 */
		/* 820901B4h case   20:*/		cpu::op::subf<1>(regs,&regs.R8,regs.R3,regs.R8);
		/* 820901B4h case   20:*/		return 0x820901B8;
		  /* 820901B8h */ case   21:  		/* bc 4, CR0_EQ, 20 */
		/* 820901B8h case   21:*/		if ( !regs.CR[0].eq ) { return 0x820901CC;  }
		/* 820901B8h case   21:*/		return 0x820901BC;
		  /* 820901BCh */ case   22:  		/* addi R11, R11, 1 */
		/* 820901BCh case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820901BCh case   22:*/		return 0x820901C0;
		  /* 820901C0h */ case   23:  		/* addi R9, R9, 1 */
		/* 820901C0h case   23:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820901C0h case   23:*/		return 0x820901C4;
		  /* 820901C4h */ case   24:  		/* cmpw CR6, R11, R10 */
		/* 820901C4h case   24:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820901C4h case   24:*/		return 0x820901C8;
		  /* 820901C8h */ case   25:  		/* bc 4, CR6_EQ, -28 */
		/* 820901C8h case   25:*/		if ( !regs.CR[6].eq ) { return 0x820901AC;  }
		/* 820901C8h case   25:*/		return 0x820901CC;
	}
	return 0x820901CC;
} // Block from 82090164h-820901CCh (26 instructions)

//////////////////////////////////////////////////////
// Block at 820901CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820901CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820901CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820901CC);
		  /* 820901CCh */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820901CCh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820901CCh case    0:*/		return 0x820901D0;
		  /* 820901D0h */ case    1:  		/* bc 12, CR0_EQ, 88 */
		/* 820901D0h case    1:*/		if ( regs.CR[0].eq ) { return 0x82090228;  }
		/* 820901D0h case    1:*/		return 0x820901D4;
	}
	return 0x820901D4;
} // Block from 820901CCh-820901D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820901D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820901D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820901D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820901D4);
		  /* 820901D4h */ case    0:  		/* addi R6, R6, 1 */
		/* 820901D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820901D4h case    0:*/		return 0x820901D8;
		  /* 820901D8h */ case    1:  		/* addi R7, R7, 776 */
		/* 820901D8h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x308);
		/* 820901D8h case    1:*/		return 0x820901DC;
		  /* 820901DCh */ case    2:  		/* cmplw CR6, R6, R4 */
		/* 820901DCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R4);
		/* 820901DCh case    2:*/		return 0x820901E0;
		  /* 820901E0h */ case    3:  		/* bc 12, CR6_LT, -92 */
		/* 820901E0h case    3:*/		if ( regs.CR[6].lt ) { return 0x82090184;  }
		/* 820901E0h case    3:*/		return 0x820901E4;
	}
	return 0x820901E4;
} // Block from 820901D4h-820901E4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820901E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820901E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820901E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820901E4);
		  /* 820901E4h */ case    0:  		/* mr R3, R29 */
		/* 820901E4h case    0:*/		regs.R3 = regs.R29;
		/* 820901E4h case    0:*/		return 0x820901E8;
		  /* 820901E8h */ case    1:  		/* bl -159392 */
		/* 820901E8h case    1:*/		regs.LR = 0x820901EC; return 0x82069348;
		/* 820901E8h case    1:*/		return 0x820901EC;
		  /* 820901ECh */ case    2:  		/* stw R3, <#[R28]> */
		/* 820901ECh case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x00000000) );
		/* 820901ECh case    2:*/		return 0x820901F0;
		  /* 820901F0h */ case    3:  		/* mulli R5, R30, 12 */
		/* 820901F0h case    3:*/		cpu::op::mulli<0>(regs,&regs.R5,regs.R30,0xC);
		/* 820901F0h case    3:*/		return 0x820901F4;
		  /* 820901F4h */ case    4:  		/* mr R4, R29 */
		/* 820901F4h case    4:*/		regs.R4 = regs.R29;
		/* 820901F4h case    4:*/		return 0x820901F8;
		  /* 820901F8h */ case    5:  		/* addi R3, R1, 80 */
		/* 820901F8h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820901F8h case    5:*/		return 0x820901FC;
		  /* 820901FCh */ case    6:  		/* bl -33524 */
		/* 820901FCh case    6:*/		regs.LR = 0x82090200; return 0x82087F08;
		/* 820901FCh case    6:*/		return 0x82090200;
		  /* 82090200h */ case    7:  		/* lwz R3, <#[R28]> */
		/* 82090200h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000000) );
		/* 82090200h case    7:*/		return 0x82090204;
		  /* 82090204h */ case    8:  		/* stw R30, <#[R1 + 848]> */
		/* 82090204h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000350) );
		/* 82090204h case    8:*/		return 0x82090208;
		  /* 82090208h */ case    9:  		/* stw R3, <#[R1 + 852]> */
		/* 82090208h case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000354) );
		/* 82090208h case    9:*/		return 0x8209020C;
		  /* 8209020Ch */ case   10:  		/* bl -126004 */
		/* 8209020Ch case   10:*/		regs.LR = 0x82090210; return 0x820715D8;
		/* 8209020Ch case   10:*/		return 0x82090210;
		  /* 82090210h */ case   11:  		/* mr R3, R31 */
		/* 82090210h case   11:*/		regs.R3 = regs.R31;
		/* 82090210h case   11:*/		return 0x82090214;
		  /* 82090214h */ case   12:  		/* addi R4, R1, 80 */
		/* 82090214h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82090214h case   12:*/		return 0x82090218;
		  /* 82090218h */ case   13:  		/* bl -528 */
		/* 82090218h case   13:*/		regs.LR = 0x8209021C; return 0x82090008;
		/* 82090218h case   13:*/		return 0x8209021C;
		  /* 8209021Ch */ case   14:  		/* li R3, 0 */
		/* 8209021Ch case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209021Ch case   14:*/		return 0x82090220;
		  /* 82090220h */ case   15:  		/* addi R1, R1, 896 */
		/* 82090220h case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x380);
		/* 82090220h case   15:*/		return 0x82090224;
		  /* 82090224h */ case   16:  		/* b 4228 */
		/* 82090224h case   16:*/		return 0x820912A8;
		/* 82090224h case   16:*/		return 0x82090228;
	}
	return 0x82090228;
} // Block from 820901E4h-82090228h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82090228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090228);
		  /* 82090228h */ case    0:  		/* mulli R11, R6, 776 */
		/* 82090228h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R6,0x308);
		/* 82090228h case    0:*/		return 0x8209022C;
		  /* 8209022Ch */ case    1:  		/* add R11, R11, R5 */
		/* 8209022Ch case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 8209022Ch case    1:*/		return 0x82090230;
		  /* 82090230h */ case    2:  		/* lwz R11, <#[R11 + 772]> */
		/* 82090230h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000304) );
		/* 82090230h case    2:*/		return 0x82090234;
		  /* 82090234h */ case    3:  		/* stw R11, <#[R28]> */
		/* 82090234h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82090234h case    3:*/		return 0x82090238;
		  /* 82090238h */ case    4:  		/* b -28 */
		/* 82090238h case    4:*/		return 0x8209021C;
		/* 82090238h case    4:*/		return 0x8209023C;
		  /* 8209023Ch */ case    5:  		/* nop */
		/* 8209023Ch case    5:*/		cpu::op::nop();
		/* 8209023Ch case    5:*/		return 0x82090240;
	}
	return 0x82090240;
} // Block from 82090228h-82090240h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82090240h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090240);
		  /* 82090240h */ case    0:  		/* mr R3, R4 */
		/* 82090240h case    0:*/		regs.R3 = regs.R4;
		/* 82090240h case    0:*/		return 0x82090244;
		  /* 82090244h */ case    1:  		/* mr R4, R5 */
		/* 82090244h case    1:*/		regs.R4 = regs.R5;
		/* 82090244h case    1:*/		return 0x82090248;
		  /* 82090248h */ case    2:  		/* b -352 */
		/* 82090248h case    2:*/		return 0x820900E8;
		/* 82090248h case    2:*/		return 0x8209024C;
		  /* 8209024Ch */ case    3:  		/* nop */
		/* 8209024Ch case    3:*/		cpu::op::nop();
		/* 8209024Ch case    3:*/		return 0x82090250;
		  /* 82090250h */ case    4:  		/* extsh R10, R3 */
		/* 82090250h case    4:*/		cpu::op::extsh<0>(regs,&regs.R10,regs.R3);
		/* 82090250h case    4:*/		return 0x82090254;
		  /* 82090254h */ case    5:  		/* extsh R11, R4 */
		/* 82090254h case    5:*/		cpu::op::extsh<0>(regs,&regs.R11,regs.R4);
		/* 82090254h case    5:*/		return 0x82090258;
		  /* 82090258h */ case    6:  		/* cmpw CR6, R10, R11 */
		/* 82090258h case    6:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 82090258h case    6:*/		return 0x8209025C;
		  /* 8209025Ch */ case    7:  		/* bc 4, CR6_GT, 68 */
		/* 8209025Ch case    7:*/		if ( !regs.CR[6].gt ) { return 0x820902A0;  }
		/* 8209025Ch case    7:*/		return 0x82090260;
		  /* 82090260h */ case    8:  		/* subf R10, R11, R10 */
		/* 82090260h case    8:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82090260h case    8:*/		return 0x82090264;
		  /* 82090264h */ case    9:  		/* extsw R11, R11 */
		/* 82090264h case    9:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 82090264h case    9:*/		return 0x82090268;
		  /* 82090268h */ case   10:  		/* extsw R10, R10 */
		/* 82090268h case   10:*/		cpu::op::extsw<0>(regs,&regs.R10,regs.R10);
		/* 82090268h case   10:*/		return 0x8209026C;
		  /* 8209026Ch */ case   11:  		/* std R11, <#[R1 - 16]> */
		/* 8209026Ch case   11:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209026Ch case   11:*/		return 0x82090270;
		  /* 82090270h */ case   12:  		/* lfd FR0, <#[R1 - 16]> */
		/* 82090270h case   12:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82090270h case   12:*/		return 0x82090274;
		  /* 82090274h */ case   13:  		/* std R10, <#[R1 - 16]> */
		/* 82090274h case   13:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82090274h case   13:*/		return 0x82090278;
		  /* 82090278h */ case   14:  		/* lfd FR13, <#[R1 - 16]> */
		/* 82090278h case   14:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82090278h case   14:*/		return 0x8209027C;
		  /* 8209027Ch */ case   15:  		/* fcfid FR12, FR0 */
		/* 8209027Ch case   15:*/		cpu::op::fcfid<0>(regs,&regs.FR12,regs.FR0);
		/* 8209027Ch case   15:*/		return 0x82090280;
		  /* 82090280h */ case   16:  		/* lis R11, -32255 */
		/* 82090280h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82090280h case   16:*/		return 0x82090284;
		  /* 82090284h */ case   17:  		/* fcfid FR13, FR13 */
		/* 82090284h case   17:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 82090284h case   17:*/		return 0x82090288;
		  /* 82090288h */ case   18:  		/* lfs FR0, <#[R11 - 24860]> */
		/* 82090288h case   18:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFF9EE4) );
		/* 82090288h case   18:*/		return 0x8209028C;
		  /* 8209028Ch */ case   19:  		/* frsp FR12, FR12 */
		/* 8209028Ch case   19:*/		cpu::op::frsp<0>(regs,&regs.FR12,regs.FR12);
		/* 8209028Ch case   19:*/		return 0x82090290;
		  /* 82090290h */ case   20:  		/* frsp FR13, FR13 */
		/* 82090290h case   20:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 82090290h case   20:*/		return 0x82090294;
		  /* 82090294h */ case   21:  		/* fsubs FR0, FR0, FR12 */
		/* 82090294h case   21:*/		cpu::op::fsubs<0>(regs,&regs.FR0,regs.FR0,regs.FR12);
		/* 82090294h case   21:*/		return 0x82090298;
		  /* 82090298h */ case   22:  		/* fdivs FR1, FR13, FR0 */
		/* 82090298h case   22:*/		cpu::op::fdivs<0>(regs,&regs.FR1,regs.FR13,regs.FR0);
		/* 82090298h case   22:*/		return 0x8209029C;
		  /* 8209029Ch */ case   23:  		/* bclr 20, CR0_LT */
		/* 8209029Ch case   23:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209029Ch case   23:*/		return 0x820902A0;
	}
	return 0x820902A0;
} // Block from 82090240h-820902A0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820902A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820902A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820902A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820902A0);
		  /* 820902A0h */ case    0:  		/* neg R9, R11 */
		/* 820902A0h case    0:*/		cpu::op::neg<0>(regs,&regs.R9,regs.R11);
		/* 820902A0h case    0:*/		return 0x820902A4;
		  /* 820902A4h */ case    1:  		/* cmpw CR6, R10, R9 */
		/* 820902A4h case    1:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R9);
		/* 820902A4h case    1:*/		return 0x820902A8;
		  /* 820902A8h */ case    2:  		/* bc 4, CR6_LT, 76 */
		/* 820902A8h case    2:*/		if ( !regs.CR[6].lt ) { return 0x820902F4;  }
		/* 820902A8h case    2:*/		return 0x820902AC;
		  /* 820902ACh */ case    3:  		/* add R10, R11, R10 */
		/* 820902ACh case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 820902ACh case    3:*/		return 0x820902B0;
		  /* 820902B0h */ case    4:  		/* extsw R11, R11 */
		/* 820902B0h case    4:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 820902B0h case    4:*/		return 0x820902B4;
		  /* 820902B4h */ case    5:  		/* extsw R10, R10 */
		/* 820902B4h case    5:*/		cpu::op::extsw<0>(regs,&regs.R10,regs.R10);
		/* 820902B4h case    5:*/		return 0x820902B8;
		  /* 820902B8h */ case    6:  		/* std R11, <#[R1 - 16]> */
		/* 820902B8h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820902B8h case    6:*/		return 0x820902BC;
		  /* 820902BCh */ case    7:  		/* lis R11, -32255 */
		/* 820902BCh case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820902BCh case    7:*/		return 0x820902C0;
		  /* 820902C0h */ case    8:  		/* lfd FR0, <#[R1 - 16]> */
		/* 820902C0h case    8:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820902C0h case    8:*/		return 0x820902C4;
		  /* 820902C4h */ case    9:  		/* std R10, <#[R1 - 16]> */
		/* 820902C4h case    9:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820902C4h case    9:*/		return 0x820902C8;
		  /* 820902C8h */ case   10:  		/* fcfid FR0, FR0 */
		/* 820902C8h case   10:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 820902C8h case   10:*/		return 0x820902CC;
		  /* 820902CCh */ case   11:  		/* lis R10, -32256 */
		/* 820902CCh case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 820902CCh case   11:*/		return 0x820902D0;
		  /* 820902D0h */ case   12:  		/* frsp FR11, FR0 */
		/* 820902D0h case   12:*/		cpu::op::frsp<0>(regs,&regs.FR11,regs.FR0);
		/* 820902D0h case   12:*/		return 0x820902D4;
		  /* 820902D4h */ case   13:  		/* lfs FR0, <#[R11 - 24860]> */
		/* 820902D4h case   13:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFF9EE4) );
		/* 820902D4h case   13:*/		return 0x820902D8;
		  /* 820902D8h */ case   14:  		/* lfd FR13, <#[R1 - 16]> */
		/* 820902D8h case   14:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820902D8h case   14:*/		return 0x820902DC;
		  /* 820902DCh */ case   15:  		/* fcfid FR12, FR13 */
		/* 820902DCh case   15:*/		cpu::op::fcfid<0>(regs,&regs.FR12,regs.FR13);
		/* 820902DCh case   15:*/		return 0x820902E0;
		  /* 820902E0h */ case   16:  		/* lfs FR13, <#[R10 + 1792]> */
		/* 820902E0h case   16:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000700) );
		/* 820902E0h case   16:*/		return 0x820902E4;
		  /* 820902E4h */ case   17:  		/* fsubs FR0, FR0, FR11 */
		/* 820902E4h case   17:*/		cpu::op::fsubs<0>(regs,&regs.FR0,regs.FR0,regs.FR11);
		/* 820902E4h case   17:*/		return 0x820902E8;
		  /* 820902E8h */ case   18:  		/* frsp FR12, FR12 */
		/* 820902E8h case   18:*/		cpu::op::frsp<0>(regs,&regs.FR12,regs.FR12);
		/* 820902E8h case   18:*/		return 0x820902EC;
		  /* 820902ECh */ case   19:  		/* fadds FR13, FR12, FR13 */
		/* 820902ECh case   19:*/		cpu::op::fadds<0>(regs,&regs.FR13,regs.FR12,regs.FR13);
		/* 820902ECh case   19:*/		return 0x820902F0;
		  /* 820902F0h */ case   20:  		/* b -88 */
		/* 820902F0h case   20:*/		return 0x82090298;
		/* 820902F0h case   20:*/		return 0x820902F4;
	}
	return 0x820902F4;
} // Block from 820902A0h-820902F4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820902F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820902F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820902F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820902F4);
		  /* 820902F4h */ case    0:  		/* lis R11, -32256 */
		/* 820902F4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820902F4h case    0:*/		return 0x820902F8;
		  /* 820902F8h */ case    1:  		/* lfs FR1, <#[R11 + 1816]> */
		/* 820902F8h case    1:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000718) );
		/* 820902F8h case    1:*/		return 0x820902FC;
		  /* 820902FCh */ case    2:  		/* bclr 20, CR0_LT */
		/* 820902FCh case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820902FCh case    2:*/		return 0x82090300;
	}
	return 0x82090300;
} // Block from 820902F4h-82090300h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82090300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090300);
		  /* 82090300h */ case    0:  		/* mfspr R12, LR */
		/* 82090300h case    0:*/		regs.R12 = regs.LR;
		/* 82090300h case    0:*/		return 0x82090304;
		  /* 82090304h */ case    1:  		/* bl 3912 */
		/* 82090304h case    1:*/		regs.LR = 0x82090308; return 0x8209124C;
		/* 82090304h case    1:*/		return 0x82090308;
		  /* 82090308h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82090308h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82090308h case    2:*/		return 0x8209030C;
		  /* 8209030Ch */ case    3:  		/* lis R31, -32215 */
		/* 8209030Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8229);
		/* 8209030Ch case    3:*/		return 0x82090310;
		  /* 82090310h */ case    4:  		/* lis R11, -32215 */
		/* 82090310h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82090310h case    4:*/		return 0x82090314;
		  /* 82090314h */ case    5:  		/* mr R29, R3 */
		/* 82090314h case    5:*/		regs.R29 = regs.R3;
		/* 82090314h case    5:*/		return 0x82090318;
		  /* 82090318h */ case    6:  		/* addi R30, R11, -31096 */
		/* 82090318h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFF8688);
		/* 82090318h case    6:*/		return 0x8209031C;
		  /* 8209031Ch */ case    7:  		/* li R25, 1 */
		/* 8209031Ch case    7:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 8209031Ch case    7:*/		return 0x82090320;
		  /* 82090320h */ case    8:  		/* lwz R11, <#[R31 - 30744]> */
		/* 82090320h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0xFFFF87E8) );
		/* 82090320h case    8:*/		return 0x82090324;
		  /* 82090324h */ case    9:  		/* cmpwi CR6, R11, 0 */
		/* 82090324h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82090324h case    9:*/		return 0x82090328;
		  /* 82090328h */ case   10:  		/* bc 4, CR6_EQ, 48 */
		/* 82090328h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82090358;  }
		/* 82090328h case   10:*/		return 0x8209032C;
		  /* 8209032Ch */ case   11:  		/* mr R3, R30 */
		/* 8209032Ch case   11:*/		regs.R3 = regs.R30;
		/* 8209032Ch case   11:*/		return 0x82090330;
		  /* 82090330h */ case   12:  		/* li R5, 352 */
		/* 82090330h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x160);
		/* 82090330h case   12:*/		return 0x82090334;
		  /* 82090334h */ case   13:  		/* li R4, 0 */
		/* 82090334h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82090334h case   13:*/		return 0x82090338;
		  /* 82090338h */ case   14:  		/* bl 4104 */
		/* 82090338h case   14:*/		regs.LR = 0x8209033C; return 0x82091340;
		/* 82090338h case   14:*/		return 0x8209033C;
		  /* 8209033Ch */ case   15:  		/* lis R11, -32215 */
		/* 8209033Ch case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8209033Ch case   15:*/		return 0x82090340;
		  /* 82090340h */ case   16:  		/* li R5, 88 */
		/* 82090340h case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x58);
		/* 82090340h case   16:*/		return 0x82090344;
		  /* 82090344h */ case   17:  		/* addi R3, R11, -31184 */
		/* 82090344h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF8630);
		/* 82090344h case   17:*/		return 0x82090348;
		  /* 82090348h */ case   18:  		/* li R4, 0 */
		/* 82090348h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82090348h case   18:*/		return 0x8209034C;
		  /* 8209034Ch */ case   19:  		/* bl 4084 */
		/* 8209034Ch case   19:*/		regs.LR = 0x82090350; return 0x82091340;
		/* 8209034Ch case   19:*/		return 0x82090350;
		  /* 82090350h */ case   20:  		/* mr R11, R25 */
		/* 82090350h case   20:*/		regs.R11 = regs.R25;
		/* 82090350h case   20:*/		return 0x82090354;
		  /* 82090354h */ case   21:  		/* stw R25, <#[R31 - 30744]> */
		/* 82090354h case   21:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0xFFFF87E8) );
		/* 82090354h case   21:*/		return 0x82090358;
	}
	return 0x82090358;
} // Block from 82090300h-82090358h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82090358h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090358);
		  /* 82090358h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 82090358h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82090358h case    0:*/		return 0x8209035C;
		  /* 8209035Ch */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 8209035Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82090364;  }
		/* 8209035Ch case    1:*/		return 0x82090360;
		  /* 82090360h */ case    2:  		/* mr R29, R30 */
		/* 82090360h case    2:*/		regs.R29 = regs.R30;
		/* 82090360h case    2:*/		return 0x82090364;
	}
	return 0x82090364;
} // Block from 82090358h-82090364h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82090364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090364);
		  /* 82090364h */ case    0:  		/* li R26, 0 */
		/* 82090364h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82090364h case    0:*/		return 0x82090368;
		  /* 82090368h */ case    1:  		/* addi R31, R29, 72 */
		/* 82090368h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R29,0x48);
		/* 82090368h case    1:*/		return 0x8209036C;
		  /* 8209036Ch */ case    2:  		/* mr R28, R26 */
		/* 8209036Ch case    2:*/		regs.R28 = regs.R26;
		/* 8209036Ch case    2:*/		return 0x82090370;
		  /* 82090370h */ case    3:  		/* lis R27, -32217 */
		/* 82090370h case    3:*/		cpu::op::lis<0>(regs,&regs.R27,0xFFFF8227);
		/* 82090370h case    3:*/		return 0x82090374;
		  /* 82090374h */ case    4:  		/* lis R29, -32217 */
		/* 82090374h case    4:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8227);
		/* 82090374h case    4:*/		return 0x82090378;
		  /* 82090378h */ case    5:  		/* addi R4, R1, 80 */
		/* 82090378h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82090378h case    5:*/		return 0x8209037C;
		  /* 8209037Ch */ case    6:  		/* lwz R30, <#[R31]> */
		/* 8209037Ch case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000000) );
		/* 8209037Ch case    6:*/		return 0x82090380;
		  /* 82090380h */ case    7:  		/* mr R3, R28 */
		/* 82090380h case    7:*/		regs.R3 = regs.R28;
		/* 82090380h case    7:*/		return 0x82090384;
		  /* 82090384h */ case    8:  		/* bl 1929172 */
		/* 82090384h case    8:*/		regs.LR = 0x82090388; return 0x82267358;
		/* 82090384h case    8:*/		return 0x82090388;
		  /* 82090388h */ case    9:  		/* cntlzw R11, R3 */
		/* 82090388h case    9:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R3);
		/* 82090388h case    9:*/		return 0x8209038C;
		  /* 8209038Ch */ case   10:  		/* cmpwi CR6, R30, 0 */
		/* 8209038Ch case   10:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 8209038Ch case   10:*/		return 0x82090390;
		  /* 82090390h */ case   11:  		/* rlwinm R10, R11, 27, 31, 31 */
		/* 82090390h case   11:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R11);
		/* 82090390h case   11:*/		return 0x82090394;
		  /* 82090394h */ case   12:  		/* stw R10, <#[R31]> */
		/* 82090394h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82090394h case   12:*/		return 0x82090398;
		  /* 82090398h */ case   13:  		/* bc 12, CR6_EQ, 16 */
		/* 82090398h case   13:*/		if ( regs.CR[6].eq ) { return 0x820903A8;  }
		/* 82090398h case   13:*/		return 0x8209039C;
		  /* 8209039Ch */ case   14:  		/* cmpwi CR6, R10, 0 */
		/* 8209039Ch case   14:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8209039Ch case   14:*/		return 0x820903A0;
		  /* 820903A0h */ case   15:  		/* mr R11, R25 */
		/* 820903A0h case   15:*/		regs.R11 = regs.R25;
		/* 820903A0h case   15:*/		return 0x820903A4;
		  /* 820903A4h */ case   16:  		/* bc 12, CR6_EQ, 8 */
		/* 820903A4h case   16:*/		if ( regs.CR[6].eq ) { return 0x820903AC;  }
		/* 820903A4h case   16:*/		return 0x820903A8;
	}
	return 0x820903A8;
} // Block from 82090364h-820903A8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820903A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820903A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820903A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820903A8);
		  /* 820903A8h */ case    0:  		/* mr R11, R26 */
		/* 820903A8h case    0:*/		regs.R11 = regs.R26;
		/* 820903A8h case    0:*/		return 0x820903AC;
	}
	return 0x820903AC;
} // Block from 820903A8h-820903ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820903ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820903AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820903AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820903AC);
		  /* 820903ACh */ case    0:  		/* stw R11, <#[R31 + 8]> */
		/* 820903ACh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820903ACh case    0:*/		return 0x820903B0;
		  /* 820903B0h */ case    1:  		/* cmpwi CR6, R30, 0 */
		/* 820903B0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820903B0h case    1:*/		return 0x820903B4;
		  /* 820903B4h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820903B4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820903C4;  }
		/* 820903B4h case    2:*/		return 0x820903B8;
		  /* 820903B8h */ case    3:  		/* cmpwi CR6, R10, 0 */
		/* 820903B8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820903B8h case    3:*/		return 0x820903BC;
		  /* 820903BCh */ case    4:  		/* mr R11, R25 */
		/* 820903BCh case    4:*/		regs.R11 = regs.R25;
		/* 820903BCh case    4:*/		return 0x820903C0;
		  /* 820903C0h */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 820903C0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820903C8;  }
		/* 820903C0h case    5:*/		return 0x820903C4;
	}
	return 0x820903C4;
} // Block from 820903ACh-820903C4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820903C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820903C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820903C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820903C4);
		  /* 820903C4h */ case    0:  		/* mr R11, R26 */
		/* 820903C4h case    0:*/		regs.R11 = regs.R26;
		/* 820903C4h case    0:*/		return 0x820903C8;
	}
	return 0x820903C8;
} // Block from 820903C4h-820903C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820903C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820903C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820903C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820903C8);
		  /* 820903C8h */ case    0:  		/* stw R11, <#[R31 + 4]> */
		/* 820903C8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820903C8h case    0:*/		return 0x820903CC;
		  /* 820903CCh */ case    1:  		/* cmpwi CR6, R10, 0 */
		/* 820903CCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820903CCh case    1:*/		return 0x820903D0;
		  /* 820903D0h */ case    2:  		/* bc 12, CR6_EQ, 268 */
		/* 820903D0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820904DC;  }
		/* 820903D0h case    2:*/		return 0x820903D4;
		  /* 820903D4h */ case    3:  		/* cmpwi CR6, R11, 1 */
		/* 820903D4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820903D4h case    3:*/		return 0x820903D8;
		  /* 820903D8h */ case    4:  		/* bc 4, CR6_EQ, 44 */
		/* 820903D8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82090404;  }
		/* 820903D8h case    4:*/		return 0x820903DC;
		  /* 820903DCh */ case    5:  		/* li R5, 88 */
		/* 820903DCh case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x58);
		/* 820903DCh case    5:*/		return 0x820903E0;
		  /* 820903E0h */ case    6:  		/* li R4, 0 */
		/* 820903E0h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820903E0h case    6:*/		return 0x820903E4;
		  /* 820903E4h */ case    7:  		/* addi R3, R31, -72 */
		/* 820903E4h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xFFFFFFB8);
		/* 820903E4h case    7:*/		return 0x820903E8;
		  /* 820903E8h */ case    8:  		/* bl 3928 */
		/* 820903E8h case    8:*/		regs.LR = 0x820903EC; return 0x82091340;
		/* 820903E8h case    8:*/		return 0x820903EC;
		  /* 820903ECh */ case    9:  		/* stw R25, <#[R31]> */
		/* 820903ECh case    9:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x00000000) );
		/* 820903ECh case    9:*/		return 0x820903F0;
		  /* 820903F0h */ case   10:  		/* stw R25, <#[R31 + 4]> */
		/* 820903F0h case   10:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x00000004) );
		/* 820903F0h case   10:*/		return 0x820903F4;
		  /* 820903F4h */ case   11:  		/* addi R5, R31, -20 */
		/* 820903F4h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0xFFFFFFEC);
		/* 820903F4h case   11:*/		return 0x820903F8;
		  /* 820903F8h */ case   12:  		/* li R4, 1 */
		/* 820903F8h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820903F8h case   12:*/		return 0x820903FC;
		  /* 820903FCh */ case   13:  		/* mr R3, R28 */
		/* 820903FCh case   13:*/		regs.R3 = regs.R28;
		/* 820903FCh case   13:*/		return 0x82090400;
		  /* 82090400h */ case   14:  		/* bl 1929040 */
		/* 82090400h case   14:*/		regs.LR = 0x82090404; return 0x82267350;
		/* 82090400h case   14:*/		return 0x82090404;
	}
	return 0x82090404;
} // Block from 820903C8h-82090404h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82090404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090404);
		  /* 82090404h */ case    0:  		/* lwz R11, <#[R1 + 84]> */
		/* 82090404h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82090404h case    0:*/		return 0x82090408;
		  /* 82090408h */ case    1:  		/* lwz R10, <#[R1 + 88]> */
		/* 82090408h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82090408h case    1:*/		return 0x8209040C;
		  /* 8209040Ch */ case    2:  		/* lwz R9, <#[R1 + 92]> */
		/* 8209040Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000005C) );
		/* 8209040Ch case    2:*/		return 0x82090410;
		  /* 82090410h */ case    3:  		/* stw R11, <#[R31 - 72]> */
		/* 82090410h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0xFFFFFFB8) );
		/* 82090410h case    3:*/		return 0x82090414;
		  /* 82090414h */ case    4:  		/* stw R10, <#[R31 - 68]> */
		/* 82090414h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0xFFFFFFBC) );
		/* 82090414h case    4:*/		return 0x82090418;
	}
	return 0x82090418;
} // Block from 82090404h-82090418h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82090418h
// Function 'RtlAllocateHeap'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090418);
		  /* 82090418h */ case    0:  		/* stw R9, <#[R31 - 64]> */
		/* 82090418h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0xFFFFFFC0) );
		/* 82090418h case    0:*/		return 0x8209041C;
		  /* 8209041Ch */ case    1:  		/* lhz R3, <#[R31 - 68]> */
		/* 8209041Ch case    1:*/		cpu::mem::load16z( regs, &regs.R3, (uint32)(regs.R31 + 0xFFFFFFBC) );
		/* 8209041Ch case    1:*/		return 0x82090420;
		  /* 82090420h */ case    2:  		/* lhz R4, <#[R29 + 7056]> */
		/* 82090420h case    2:*/		cpu::mem::load16z( regs, &regs.R4, (uint32)(regs.R29 + 0x00001B90) );
		/* 82090420h case    2:*/		return 0x82090424;
		  /* 82090424h */ case    3:  		/* bl -468 */
		/* 82090424h case    3:*/		regs.LR = 0x82090428; return 0x82090250;
		/* 82090424h case    3:*/		return 0x82090428;
		  /* 82090428h */ case    4:  		/* stfs FR1, <#[R31 - 60]> */
		/* 82090428h case    4:*/		cpu::mem::store32f( regs, regs.FR1, (uint32)(regs.R31 + 0xFFFFFFC4) );
		/* 82090428h case    4:*/		return 0x8209042C;
		  /* 8209042Ch */ case    5:  		/* lhz R4, <#[R29 + 7056]> */
		/* 8209042Ch case    5:*/		cpu::mem::load16z( regs, &regs.R4, (uint32)(regs.R29 + 0x00001B90) );
		/* 8209042Ch case    5:*/		return 0x82090430;
		  /* 82090430h */ case    6:  		/* lhz R3, <#[R31 - 66]> */
		/* 82090430h case    6:*/		cpu::mem::load16z( regs, &regs.R3, (uint32)(regs.R31 + 0xFFFFFFBE) );
		/* 82090430h case    6:*/		return 0x82090434;
		  /* 82090434h */ case    7:  		/* bl -484 */
		/* 82090434h case    7:*/		regs.LR = 0x82090438; return 0x82090250;
		/* 82090434h case    7:*/		return 0x82090438;
		  /* 82090438h */ case    8:  		/* stfs FR1, <#[R31 - 56]> */
		/* 82090438h case    8:*/		cpu::mem::store32f( regs, regs.FR1, (uint32)(regs.R31 + 0xFFFFFFC8) );
		/* 82090438h case    8:*/		return 0x8209043C;
		  /* 8209043Ch */ case    9:  		/* lhz R4, <#[R27 + 7060]> */
		/* 8209043Ch case    9:*/		cpu::mem::load16z( regs, &regs.R4, (uint32)(regs.R27 + 0x00001B94) );
		/* 8209043Ch case    9:*/		return 0x82090440;
		  /* 82090440h */ case   10:  		/* lhz R3, <#[R31 - 64]> */
		/* 82090440h case   10:*/		cpu::mem::load16z( regs, &regs.R3, (uint32)(regs.R31 + 0xFFFFFFC0) );
		/* 82090440h case   10:*/		return 0x82090444;
		  /* 82090444h */ case   11:  		/* bl -500 */
		/* 82090444h case   11:*/		regs.LR = 0x82090448; return 0x82090250;
		/* 82090444h case   11:*/		return 0x82090448;
		  /* 82090448h */ case   12:  		/* stfs FR1, <#[R31 - 52]> */
		/* 82090448h case   12:*/		cpu::mem::store32f( regs, regs.FR1, (uint32)(regs.R31 + 0xFFFFFFCC) );
		/* 82090448h case   12:*/		return 0x8209044C;
		  /* 8209044Ch */ case   13:  		/* lhz R4, <#[R27 + 7060]> */
		/* 8209044Ch case   13:*/		cpu::mem::load16z( regs, &regs.R4, (uint32)(regs.R27 + 0x00001B94) );
		/* 8209044Ch case   13:*/		return 0x82090450;
		  /* 82090450h */ case   14:  		/* lhz R3, <#[R31 - 62]> */
		/* 82090450h case   14:*/		cpu::mem::load16z( regs, &regs.R3, (uint32)(regs.R31 + 0xFFFFFFC2) );
		/* 82090450h case   14:*/		return 0x82090454;
		  /* 82090454h */ case   15:  		/* bl -516 */
		/* 82090454h case   15:*/		regs.LR = 0x82090458; return 0x82090250;
		/* 82090454h case   15:*/		return 0x82090458;
		  /* 82090458h */ case   16:  		/* lhz R11, <#[R31 - 72]> */
		/* 82090458h case   16:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0xFFFFFFB8) );
		/* 82090458h case   16:*/		return 0x8209045C;
		  /* 8209045Ch */ case   17:  		/* stfs FR1, <#[R31 - 48]> */
		/* 8209045Ch case   17:*/		cpu::mem::store32f( regs, regs.FR1, (uint32)(regs.R31 + 0xFFFFFFD0) );
		/* 8209045Ch case   17:*/		return 0x82090460;
		  /* 82090460h */ case   18:  		/* lhz R10, <#[R31 - 44]> */
		/* 82090460h case   18:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0xFFFFFFD4) );
		/* 82090460h case   18:*/		return 0x82090464;
		  /* 82090464h */ case   19:  		/* mr R9, R11 */
		/* 82090464h case   19:*/		regs.R9 = regs.R11;
		/* 82090464h case   19:*/		return 0x82090468;
		  /* 82090468h */ case   20:  		/* lbz R8, <#[R31 - 70]> */
		/* 82090468h case   20:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R31 + 0xFFFFFFBA) );
		/* 82090468h case   20:*/		return 0x8209046C;
		  /* 8209046Ch */ case   21:  		/* xor R10, R10, R11 */
		/* 8209046Ch case   21:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8209046Ch case   21:*/		return 0x82090470;
		  /* 82090470h */ case   22:  		/* cmplwi CR6, R8, 30 */
		/* 82090470h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000001E);
		/* 82090470h case   22:*/		return 0x82090474;
		  /* 82090474h */ case   23:  		/* sth R11, <#[R31 - 44]> */
		/* 82090474h case   23:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0xFFFFFFD4) );
		/* 82090474h case   23:*/		return 0x82090478;
		  /* 82090478h */ case   24:  		/* and R11, R10, R11 */
		/* 82090478h case   24:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82090478h case   24:*/		return 0x8209047C;
		  /* 8209047Ch */ case   25:  		/* sth R11, <#[R31 - 32]> */
		/* 8209047Ch case   25:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0xFFFFFFE0) );
		/* 8209047Ch case   25:*/		return 0x82090480;
		  /* 82090480h */ case   26:  		/* bc 4, CR6_GT, 28 */
		/* 82090480h case   26:*/		if ( !regs.CR[6].gt ) { return 0x8209049C;  }
		/* 82090480h case   26:*/		return 0x82090484;
		  /* 82090484h */ case   27:  		/* lwz R10, <#[R31 - 40]> */
		/* 82090484h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0xFFFFFFD8) );
		/* 82090484h case   27:*/		return 0x82090488;
		  /* 82090488h */ case   28:  		/* mr R11, R25 */
		/* 82090488h case   28:*/		regs.R11 = regs.R25;
		/* 82090488h case   28:*/		return 0x8209048C;
		  /* 8209048Ch */ case   29:  		/* cntlzw R10, R10 */
		/* 8209048Ch case   29:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 8209048Ch case   29:*/		return 0x82090490;
		  /* 82090490h */ case   30:  		/* rlwinm R10, R10, 27, 31, 31 */
		/* 82090490h case   30:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R10);
		/* 82090490h case   30:*/		return 0x82090494;
		  /* 82090494h */ case   31:  		/* stw R10, <#[R31 - 28]> */
		/* 82090494h case   31:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0xFFFFFFE4) );
		/* 82090494h case   31:*/		return 0x82090498;
		  /* 82090498h */ case   32:  		/* b 12 */
		/* 82090498h case   32:*/		return 0x820904A4;
		/* 82090498h case   32:*/		return 0x8209049C;
	}
	return 0x8209049C;
} // Block from 82090418h-8209049Ch (33 instructions)

//////////////////////////////////////////////////////
// Block at 8209049Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209049C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209049C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209049C);
		  /* 8209049Ch */ case    0:  		/* mr R11, R26 */
		/* 8209049Ch case    0:*/		regs.R11 = regs.R26;
		/* 8209049Ch case    0:*/		return 0x820904A0;
		  /* 820904A0h */ case    1:  		/* stw R26, <#[R31 - 28]> */
		/* 820904A0h case    1:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0xFFFFFFE4) );
		/* 820904A0h case    1:*/		return 0x820904A4;
	}
	return 0x820904A4;
} // Block from 8209049Ch-820904A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820904A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820904A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820904A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820904A4);
		  /* 820904A4h */ case    0:  		/* lbz R10, <#[R31 - 69]> */
		/* 820904A4h case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0xFFFFFFBB) );
		/* 820904A4h case    0:*/		return 0x820904A8;
		  /* 820904A8h */ case    1:  		/* stw R11, <#[R31 - 40]> */
		/* 820904A8h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0xFFFFFFD8) );
		/* 820904A8h case    1:*/		return 0x820904AC;
		  /* 820904ACh */ case    2:  		/* cmplwi CR6, R10, 30 */
		/* 820904ACh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000001E);
		/* 820904ACh case    2:*/		return 0x820904B0;
		  /* 820904B0h */ case    3:  		/* bc 4, CR6_GT, 28 */
		/* 820904B0h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820904CC;  }
		/* 820904B0h case    3:*/		return 0x820904B4;
		  /* 820904B4h */ case    4:  		/* lwz R10, <#[R31 - 36]> */
		/* 820904B4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0xFFFFFFDC) );
		/* 820904B4h case    4:*/		return 0x820904B8;
		  /* 820904B8h */ case    5:  		/* mr R11, R25 */
		/* 820904B8h case    5:*/		regs.R11 = regs.R25;
		/* 820904B8h case    5:*/		return 0x820904BC;
		  /* 820904BCh */ case    6:  		/* cntlzw R10, R10 */
		/* 820904BCh case    6:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 820904BCh case    6:*/		return 0x820904C0;
		  /* 820904C0h */ case    7:  		/* rlwinm R10, R10, 27, 31, 31 */
		/* 820904C0h case    7:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R10);
		/* 820904C0h case    7:*/		return 0x820904C4;
		  /* 820904C4h */ case    8:  		/* stw R10, <#[R31 - 24]> */
		/* 820904C4h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0xFFFFFFE8) );
		/* 820904C4h case    8:*/		return 0x820904C8;
		  /* 820904C8h */ case    9:  		/* b 12 */
		/* 820904C8h case    9:*/		return 0x820904D4;
		/* 820904C8h case    9:*/		return 0x820904CC;
	}
	return 0x820904CC;
} // Block from 820904A4h-820904CCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 820904CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820904CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820904CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820904CC);
		  /* 820904CCh */ case    0:  		/* mr R11, R26 */
		/* 820904CCh case    0:*/		regs.R11 = regs.R26;
		/* 820904CCh case    0:*/		return 0x820904D0;
		  /* 820904D0h */ case    1:  		/* stw R26, <#[R31 - 24]> */
		/* 820904D0h case    1:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0xFFFFFFE8) );
		/* 820904D0h case    1:*/		return 0x820904D4;
	}
	return 0x820904D4;
} // Block from 820904CCh-820904D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820904D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820904D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820904D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820904D4);
		  /* 820904D4h */ case    0:  		/* stw R11, <#[R31 - 36]> */
		/* 820904D4h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0xFFFFFFDC) );
		/* 820904D4h case    0:*/		return 0x820904D8;
		  /* 820904D8h */ case    1:  		/* stw R28, <#[R31 + 12]> */
		/* 820904D8h case    1:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x0000000C) );
		/* 820904D8h case    1:*/		return 0x820904DC;
	}
	return 0x820904DC;
} // Block from 820904D4h-820904DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820904DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820904DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820904DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820904DC);
		  /* 820904DCh */ case    0:  		/* addi R28, R28, 1 */
		/* 820904DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820904DCh case    0:*/		return 0x820904E0;
		  /* 820904E0h */ case    1:  		/* addi R31, R31, 88 */
		/* 820904E0h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x58);
		/* 820904E0h case    1:*/		return 0x820904E4;
		  /* 820904E4h */ case    2:  		/* cmplwi CR6, R28, 4 */
		/* 820904E4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000004);
		/* 820904E4h case    2:*/		return 0x820904E8;
		  /* 820904E8h */ case    3:  		/* bc 12, CR6_LT, -368 */
		/* 820904E8h case    3:*/		if ( regs.CR[6].lt ) { return 0x82090378;  }
		/* 820904E8h case    3:*/		return 0x820904EC;
		  /* 820904ECh */ case    4:  		/* addi R1, R1, 160 */
		/* 820904ECh case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820904ECh case    4:*/		return 0x820904F0;
		  /* 820904F0h */ case    5:  		/* b 3500 */
		/* 820904F0h case    5:*/		return 0x8209129C;
		/* 820904F0h case    5:*/		return 0x820904F4;
		  /* 820904F4h */ case    6:  		/* nop */
		/* 820904F4h case    6:*/		cpu::op::nop();
		/* 820904F4h case    6:*/		return 0x820904F8;
	}
	return 0x820904F8;
} // Block from 820904DCh-820904F8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820904F8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820904F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820904F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820904F8);
		  /* 820904F8h */ case    0:  		/* mfspr R12, LR */
		/* 820904F8h case    0:*/		regs.R12 = regs.LR;
		/* 820904F8h case    0:*/		return 0x820904FC;
		  /* 820904FCh */ case    1:  		/* bl 3364 */
		/* 820904FCh case    1:*/		regs.LR = 0x82090500; return 0x82091220;
		/* 820904FCh case    1:*/		return 0x82090500;
		  /* 82090500h */ case    2:  		/* stwu R1, <#[R1 - 304]> */
		/* 82090500h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFED0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFED0);
		/* 82090500h case    2:*/		return 0x82090504;
		  /* 82090504h */ case    3:  		/* mr R30, R3 */
		/* 82090504h case    3:*/		regs.R30 = regs.R3;
		/* 82090504h case    3:*/		return 0x82090508;
		  /* 82090508h */ case    4:  		/* stw R3, <#[R1 + 324]> */
		/* 82090508h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000144) );
		/* 82090508h case    4:*/		return 0x8209050C;
		  /* 8209050Ch */ case    5:  		/* li R3, 0 */
		/* 8209050Ch case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209050Ch case    5:*/		return 0x82090510;
		  /* 82090510h */ case    6:  		/* stw R4, <#[R1 + 332]> */
		/* 82090510h case    6:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000014C) );
		/* 82090510h case    6:*/		return 0x82090514;
		  /* 82090514h */ case    7:  		/* mr R29, R4 */
		/* 82090514h case    7:*/		regs.R29 = regs.R4;
		/* 82090514h case    7:*/		return 0x82090518;
		  /* 82090518h */ case    8:  		/* bl -536 */
		/* 82090518h case    8:*/		regs.LR = 0x8209051C; return 0x82090300;
		/* 82090518h case    8:*/		return 0x8209051C;
		  /* 8209051Ch */ case    9:  		/* lis R11, -32215 */
		/* 8209051Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8209051Ch case    9:*/		return 0x82090520;
		  /* 82090520h */ case   10:  		/* li R5, 88 */
		/* 82090520h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x58);
		/* 82090520h case   10:*/		return 0x82090524;
		  /* 82090524h */ case   11:  		/* addi R31, R11, -31184 */
		/* 82090524h case   11:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFF8630);
		/* 82090524h case   11:*/		return 0x82090528;
		  /* 82090528h */ case   12:  		/* li R4, 0 */
		/* 82090528h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82090528h case   12:*/		return 0x8209052C;
		  /* 8209052Ch */ case   13:  		/* mr R3, R31 */
		/* 8209052Ch case   13:*/		regs.R3 = regs.R31;
		/* 8209052Ch case   13:*/		return 0x82090530;
		  /* 82090530h */ case   14:  		/* bl 3600 */
		/* 82090530h case   14:*/		regs.LR = 0x82090534; return 0x82091340;
		/* 82090530h case   14:*/		return 0x82090534;
		  /* 82090534h */ case   15:  		/* addi R10, R1, 116 */
		/* 82090534h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x74);
		/* 82090534h case   15:*/		return 0x82090538;
		  /* 82090538h */ case   16:  		/* li R18, 0 */
		/* 82090538h case   16:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 82090538h case   16:*/		return 0x8209053C;
		  /* 8209053Ch */ case   17:  		/* lbz R6, <#[R31 + 3]> */
		/* 8209053Ch case   17:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000003) );
		/* 8209053Ch case   17:*/		return 0x82090540;
		  /* 82090540h */ case   18:  		/* addi R11, R1, 132 */
		/* 82090540h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x84);
		/* 82090540h case   18:*/		return 0x82090544;
		  /* 82090544h */ case   19:  		/* lhz R4, <#[R31]> */
		/* 82090544h case   19:*/		cpu::mem::load16z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 82090544h case   19:*/		return 0x82090548;
		  /* 82090548h */ case   20:  		/* stw R18, <#[R1 + 112]> */
		/* 82090548h case   20:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000070) );
		/* 82090548h case   20:*/		return 0x8209054C;
		  /* 8209054Ch */ case   21:  		/* lis R5, -32217 */
		/* 8209054Ch case   21:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8227);
		/* 8209054Ch case   21:*/		return 0x82090550;
		  /* 82090550h */ case   22:  		/* stw R18, <#[R1 + 128]> */
		/* 82090550h case   22:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000080) );
		/* 82090550h case   22:*/		return 0x82090554;
		  /* 82090554h */ case   23:  		/* lfs FR11, <#[R31 + 24]> */
		/* 82090554h case   23:*/		cpu::mem::load32f( regs, &regs.FR11, (uint32)(regs.R31 + 0x00000018) );
		/* 82090554h case   23:*/		return 0x82090558;
		  /* 82090558h */ case   24:  		/* stw R18, <#[R10]> */
		/* 82090558h case   24:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R10 + 0x00000000) );
		/* 82090558h case   24:*/		return 0x8209055C;
		  /* 8209055Ch */ case   25:  		/* lfs FR12, <#[R31 + 20]> */
		/* 8209055Ch case   25:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R31 + 0x00000014) );
		/* 8209055Ch case   25:*/		return 0x82090560;
		  /* 82090560h */ case   26:  		/* stw R18, <#[R10 + 4]> */
		/* 82090560h case   26:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R10 + 0x00000004) );
		/* 82090560h case   26:*/		return 0x82090564;
		  /* 82090564h */ case   27:  		/* lfs FR13, <#[R31 + 16]> */
		/* 82090564h case   27:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R31 + 0x00000010) );
		/* 82090564h case   27:*/		return 0x82090568;
		  /* 82090568h */ case   28:  		/* stw R18, <#[R10 + 8]> */
		/* 82090568h case   28:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R10 + 0x00000008) );
		/* 82090568h case   28:*/		return 0x8209056C;
		  /* 8209056Ch */ case   29:  		/* lis R10, -32217 */
		/* 8209056Ch case   29:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 8209056Ch case   29:*/		return 0x82090570;
		  /* 82090570h */ case   30:  		/* stw R18, <#[R11]> */
		/* 82090570h case   30:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R11 + 0x00000000) );
		/* 82090570h case   30:*/		return 0x82090574;
		  /* 82090574h */ case   31:  		/* lfs FR0, <#[R31 + 12]> */
		/* 82090574h case   31:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R31 + 0x0000000C) );
		/* 82090574h case   31:*/		return 0x82090578;
		  /* 82090578h */ case   32:  		/* stw R18, <#[R11 + 4]> */
		/* 82090578h case   32:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R11 + 0x00000004) );
		/* 82090578h case   32:*/		return 0x8209057C;
		  /* 8209057Ch */ case   33:  		/* mr R9, R18 */
		/* 8209057Ch case   33:*/		regs.R9 = regs.R18;
		/* 8209057Ch case   33:*/		return 0x82090580;
		  /* 82090580h */ case   34:  		/* stw R18, <#[R11 + 8]> */
		/* 82090580h case   34:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R11 + 0x00000008) );
		/* 82090580h case   34:*/		return 0x82090584;
		  /* 82090584h */ case   35:  		/* lis R11, -32215 */
		/* 82090584h case   35:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82090584h case   35:*/		return 0x82090588;
		  /* 82090588h */ case   36:  		/* lhz R20, <#[R5 + 7056]> */
		/* 82090588h case   36:*/		cpu::mem::load16z( regs, &regs.R20, (uint32)(regs.R5 + 0x00001B90) );
		/* 82090588h case   36:*/		return 0x8209058C;
		  /* 8209058Ch */ case   37:  		/* mr R8, R18 */
		/* 8209058Ch case   37:*/		regs.R8 = regs.R18;
		/* 8209058Ch case   37:*/		return 0x82090590;
		  /* 82090590h */ case   38:  		/* lhz R17, <#[R10 + 7060]> */
		/* 82090590h case   38:*/		cpu::mem::load16z( regs, &regs.R17, (uint32)(regs.R10 + 0x00001B94) );
		/* 82090590h case   38:*/		return 0x82090594;
		  /* 82090594h */ case   39:  		/* mr R7, R18 */
		/* 82090594h case   39:*/		regs.R7 = regs.R18;
		/* 82090594h case   39:*/		return 0x82090598;
		  /* 82090598h */ case   40:  		/* mr R15, R18 */
		/* 82090598h case   40:*/		regs.R15 = regs.R18;
		/* 82090598h case   40:*/		return 0x8209059C;
		  /* 8209059Ch */ case   41:  		/* mr R3, R18 */
		/* 8209059Ch case   41:*/		regs.R3 = regs.R18;
		/* 8209059Ch case   41:*/		return 0x820905A0;
		  /* 820905A0h */ case   42:  		/* stw R18, <#[R1 + 96]> */
		/* 820905A0h case   42:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000060) );
		/* 820905A0h case   42:*/		return 0x820905A4;
		  /* 820905A4h */ case   43:  		/* mr R16, R18 */
		/* 820905A4h case   43:*/		regs.R16 = regs.R18;
		/* 820905A4h case   43:*/		return 0x820905A8;
		  /* 820905A8h */ case   44:  		/* stw R18, <#[R1 + 84]> */
		/* 820905A8h case   44:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000054) );
		/* 820905A8h case   44:*/		return 0x820905AC;
		  /* 820905ACh */ case   45:  		/* addi R22, R11, -31096 */
		/* 820905ACh case   45:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R11,0xFFFF8688);
		/* 820905ACh case   45:*/		return 0x820905B0;
		  /* 820905B0h */ case   46:  		/* stw R18, <#[R1 + 88]> */
		/* 820905B0h case   46:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000058) );
		/* 820905B0h case   46:*/		return 0x820905B4;
		  /* 820905B4h */ case   47:  		/* stw R18, <#[R1 + 92]> */
		/* 820905B4h case   47:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x0000005C) );
		/* 820905B4h case   47:*/		return 0x820905B8;
		  /* 820905B8h */ case   48:  		/* stb R6, <#[R1 + 80]> */
		/* 820905B8h case   48:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 820905B8h case   48:*/		return 0x820905BC;
		  /* 820905BCh */ case   49:  		/* lbz R14, <#[R31 + 2]> */
		/* 820905BCh case   49:*/		cpu::mem::load8z( regs, &regs.R14, (uint32)(regs.R31 + 0x00000002) );
		/* 820905BCh case   49:*/		return 0x820905C0;
		  /* 820905C0h */ case   50:  		/* lwz R24, <#[R31 + 48]> */
		/* 820905C0h case   50:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R31 + 0x00000030) );
		/* 820905C0h case   50:*/		return 0x820905C4;
		  /* 820905C4h */ case   51:  		/* lwz R26, <#[R31 + 44]> */
		/* 820905C4h case   51:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R31 + 0x0000002C) );
		/* 820905C4h case   51:*/		return 0x820905C8;
		  /* 820905C8h */ case   52:  		/* lhz R21, <#[R31 + 40]> */
		/* 820905C8h case   52:*/		cpu::mem::load16z( regs, &regs.R21, (uint32)(regs.R31 + 0x00000028) );
		/* 820905C8h case   52:*/		return 0x820905CC;
		  /* 820905CCh */ case   53:  		/* lwz R23, <#[R31 + 36]> */
		/* 820905CCh case   53:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R31 + 0x00000024) );
		/* 820905CCh case   53:*/		return 0x820905D0;
		  /* 820905D0h */ case   54:  		/* lwz R25, <#[R31 + 32]> */
		/* 820905D0h case   54:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R31 + 0x00000020) );
		/* 820905D0h case   54:*/		return 0x820905D4;
		  /* 820905D4h */ case   55:  		/* lhz R19, <#[R31 + 28]> */
		/* 820905D4h case   55:*/		cpu::mem::load16z( regs, &regs.R19, (uint32)(regs.R31 + 0x0000001C) );
		/* 820905D4h case   55:*/		return 0x820905D8;
		  /* 820905D8h */ case   56:  		/* stb R14, <#[R1 + 81]> */
		/* 820905D8h case   56:*/		cpu::mem::store8( regs, regs.R14, (uint32)(regs.R1 + 0x00000051) );
		/* 820905D8h case   56:*/		return 0x820905DC;
		  /* 820905DCh */ case   57:  		/* sth R4, <#[R1 + 82]> */
		/* 820905DCh case   57:*/		cpu::mem::store16( regs, regs.R4, (uint32)(regs.R1 + 0x00000052) );
		/* 820905DCh case   57:*/		return 0x820905E0;
		  /* 820905E0h */ case   58:  		/* addi R11, R22, 8 */
		/* 820905E0h case   58:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R22,0x8);
		/* 820905E0h case   58:*/		return 0x820905E4;
		  /* 820905E4h */ case   59:  		/* add R10, R3, R11 */
		/* 820905E4h case   59:*/		cpu::op::add<0>(regs,&regs.R10,regs.R3,regs.R11);
		/* 820905E4h case   59:*/		return 0x820905E8;
		  /* 820905E8h */ case   60:  		/* lwz R11, <#[R10 + 64]> */
		/* 820905E8h case   60:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000040) );
		/* 820905E8h case   60:*/		return 0x820905EC;
		  /* 820905ECh */ case   61:  		/* cmpwi CR6, R11, 0 */
		/* 820905ECh case   61:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820905ECh case   61:*/		return 0x820905F0;
		  /* 820905F0h */ case   62:  		/* bc 12, CR6_EQ, 652 */
		/* 820905F0h case   62:*/		if ( regs.CR[6].eq ) { return 0x8209087C;  }
		/* 820905F0h case   62:*/		return 0x820905F4;
		  /* 820905F4h */ case   63:  		/* cmplwi CR6, R30, 0 */
		/* 820905F4h case   63:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820905F4h case   63:*/		return 0x820905F8;
		  /* 820905F8h */ case   64:  		/* bc 12, CR6_EQ, 24 */
		/* 820905F8h case   64:*/		if ( regs.CR[6].eq ) { return 0x82090610;  }
		/* 820905F8h case   64:*/		return 0x820905FC;
		  /* 820905FCh */ case   65:  		/* lwz R11, <#[R1 + 96]> */
		/* 820905FCh case   65:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820905FCh case   65:*/		return 0x82090600;
		  /* 82090600h */ case   66:  		/* li R6, 1 */
		/* 82090600h case   66:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82090600h case   66:*/		return 0x82090604;
		  /* 82090604h */ case   67:  		/* slw R11, R6, R11 */
		/* 82090604h case   67:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R6,regs.R11);
		/* 82090604h case   67:*/		return 0x82090608;
		  /* 82090608h */ case   68:  		/* and. R11, R11, R30 */
		/* 82090608h case   68:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R30);
		/* 82090608h case   68:*/		return 0x8209060C;
		  /* 8209060Ch */ case   69:  		/* bc 12, CR0_EQ, 624 */
		/* 8209060Ch case   69:*/		if ( regs.CR[0].eq ) { return 0x8209087C;  }
		/* 8209060Ch case   69:*/		return 0x82090610;
	}
	return 0x82090610;
} // Block from 820904F8h-82090610h (70 instructions)

//////////////////////////////////////////////////////
// Block at 82090610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090610);
		  /* 82090610h */ case    0:  		/* lhz R11, <#[R10 - 4]> */
		/* 82090610h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 82090610h case    0:*/		return 0x82090614;
		  /* 82090614h */ case    1:  		/* extsh R6, R20 */
		/* 82090614h case    1:*/		cpu::op::extsh<0>(regs,&regs.R6,regs.R20);
		/* 82090614h case    1:*/		return 0x82090618;
		  /* 82090618h */ case    2:  		/* mr R30, R18 */
		/* 82090618h case    2:*/		regs.R30 = regs.R18;
		/* 82090618h case    2:*/		return 0x8209061C;
		  /* 8209061Ch */ case    3:  		/* extsh R5, R11 */
		/* 8209061Ch case    3:*/		cpu::op::extsh<0>(regs,&regs.R5,regs.R11);
		/* 8209061Ch case    3:*/		return 0x82090620;
		  /* 82090620h */ case    4:  		/* mr R29, R18 */
		/* 82090620h case    4:*/		regs.R29 = regs.R18;
		/* 82090620h case    4:*/		return 0x82090624;
		  /* 82090624h */ case    5:  		/* mr R28, R18 */
		/* 82090624h case    5:*/		regs.R28 = regs.R18;
		/* 82090624h case    5:*/		return 0x82090628;
		  /* 82090628h */ case    6:  		/* mr R27, R18 */
		/* 82090628h case    6:*/		regs.R27 = regs.R18;
		/* 82090628h case    6:*/		return 0x8209062C;
		  /* 8209062Ch */ case    7:  		/* cmpw CR6, R5, R6 */
		/* 8209062Ch case    7:*/		cpu::op::cmpw<6>(regs,regs.R5,regs.R6);
		/* 8209062Ch case    7:*/		return 0x82090630;
		  /* 82090630h */ case    8:  		/* bc 12, CR6_GT, 16 */
		/* 82090630h case    8:*/		if ( regs.CR[6].gt ) { return 0x82090640;  }
		/* 82090630h case    8:*/		return 0x82090634;
		  /* 82090634h */ case    9:  		/* neg R9, R6 */
		/* 82090634h case    9:*/		cpu::op::neg<0>(regs,&regs.R9,regs.R6);
		/* 82090634h case    9:*/		return 0x82090638;
		  /* 82090638h */ case   10:  		/* cmpw CR6, R5, R9 */
		/* 82090638h case   10:*/		cpu::op::cmpw<6>(regs,regs.R5,regs.R9);
		/* 82090638h case   10:*/		return 0x8209063C;
		  /* 8209063Ch */ case   11:  		/* bc 4, CR6_LT, 8 */
		/* 8209063Ch case   11:*/		if ( !regs.CR[6].lt ) { return 0x82090644;  }
		/* 8209063Ch case   11:*/		return 0x82090640;
	}
	return 0x82090640;
} // Block from 82090610h-82090640h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82090640h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090640);
		  /* 82090640h */ case    0:  		/* mr R30, R11 */
		/* 82090640h case    0:*/		regs.R30 = regs.R11;
		/* 82090640h case    0:*/		return 0x82090644;
	}
	return 0x82090644;
} // Block from 82090640h-82090644h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82090644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090644);
		  /* 82090644h */ case    0:  		/* lhz R11, <#[R10 - 2]> */
		/* 82090644h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R10 + 0xFFFFFFFE) );
		/* 82090644h case    0:*/		return 0x82090648;
		  /* 82090648h */ case    1:  		/* extsh R4, R11 */
		/* 82090648h case    1:*/		cpu::op::extsh<0>(regs,&regs.R4,regs.R11);
		/* 82090648h case    1:*/		return 0x8209064C;
		  /* 8209064Ch */ case    2:  		/* cmpw CR6, R4, R6 */
		/* 8209064Ch case    2:*/		cpu::op::cmpw<6>(regs,regs.R4,regs.R6);
		/* 8209064Ch case    2:*/		return 0x82090650;
		  /* 82090650h */ case    3:  		/* bc 12, CR6_GT, 16 */
		/* 82090650h case    3:*/		if ( regs.CR[6].gt ) { return 0x82090660;  }
		/* 82090650h case    3:*/		return 0x82090654;
		  /* 82090654h */ case    4:  		/* neg R9, R6 */
		/* 82090654h case    4:*/		cpu::op::neg<0>(regs,&regs.R9,regs.R6);
		/* 82090654h case    4:*/		return 0x82090658;
		  /* 82090658h */ case    5:  		/* cmpw CR6, R4, R9 */
		/* 82090658h case    5:*/		cpu::op::cmpw<6>(regs,regs.R4,regs.R9);
		/* 82090658h case    5:*/		return 0x8209065C;
		  /* 8209065Ch */ case    6:  		/* bc 4, CR6_LT, 8 */
		/* 8209065Ch case    6:*/		if ( !regs.CR[6].lt ) { return 0x82090664;  }
		/* 8209065Ch case    6:*/		return 0x82090660;
	}
	return 0x82090660;
} // Block from 82090644h-82090660h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82090660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090660);
		  /* 82090660h */ case    0:  		/* mr R29, R11 */
		/* 82090660h case    0:*/		regs.R29 = regs.R11;
		/* 82090660h case    0:*/		return 0x82090664;
	}
	return 0x82090664;
} // Block from 82090660h-82090664h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82090664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090664);
		  /* 82090664h */ case    0:  		/* lhz R9, <#[R10]> */
		/* 82090664h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82090664h case    0:*/		return 0x82090668;
		  /* 82090668h */ case    1:  		/* extsh R11, R17 */
		/* 82090668h case    1:*/		cpu::op::extsh<0>(regs,&regs.R11,regs.R17);
		/* 82090668h case    1:*/		return 0x8209066C;
		  /* 8209066Ch */ case    2:  		/* extsh R7, R9 */
		/* 8209066Ch case    2:*/		cpu::op::extsh<0>(regs,&regs.R7,regs.R9);
		/* 8209066Ch case    2:*/		return 0x82090670;
		  /* 82090670h */ case    3:  		/* cmpw CR6, R7, R11 */
		/* 82090670h case    3:*/		cpu::op::cmpw<6>(regs,regs.R7,regs.R11);
		/* 82090670h case    3:*/		return 0x82090674;
		  /* 82090674h */ case    4:  		/* bc 12, CR6_GT, 16 */
		/* 82090674h case    4:*/		if ( regs.CR[6].gt ) { return 0x82090684;  }
		/* 82090674h case    4:*/		return 0x82090678;
		  /* 82090678h */ case    5:  		/* neg R8, R11 */
		/* 82090678h case    5:*/		cpu::op::neg<0>(regs,&regs.R8,regs.R11);
		/* 82090678h case    5:*/		return 0x8209067C;
		  /* 8209067Ch */ case    6:  		/* cmpw CR6, R7, R8 */
		/* 8209067Ch case    6:*/		cpu::op::cmpw<6>(regs,regs.R7,regs.R8);
		/* 8209067Ch case    6:*/		return 0x82090680;
		  /* 82090680h */ case    7:  		/* bc 4, CR6_LT, 8 */
		/* 82090680h case    7:*/		if ( !regs.CR[6].lt ) { return 0x82090688;  }
		/* 82090680h case    7:*/		return 0x82090684;
	}
	return 0x82090684;
} // Block from 82090664h-82090684h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82090684h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090684( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090684) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090684);
		  /* 82090684h */ case    0:  		/* mr R28, R9 */
		/* 82090684h case    0:*/		regs.R28 = regs.R9;
		/* 82090684h case    0:*/		return 0x82090688;
	}
	return 0x82090688;
} // Block from 82090684h-82090688h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82090688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090688);
		  /* 82090688h */ case    0:  		/* lhz R8, <#[R10 + 2]> */
		/* 82090688h case    0:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000002) );
		/* 82090688h case    0:*/		return 0x8209068C;
		  /* 8209068Ch */ case    1:  		/* extsh R9, R8 */
		/* 8209068Ch case    1:*/		cpu::op::extsh<0>(regs,&regs.R9,regs.R8);
		/* 8209068Ch case    1:*/		return 0x82090690;
		  /* 82090690h */ case    2:  		/* cmpw CR6, R9, R11 */
		/* 82090690h case    2:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R11);
		/* 82090690h case    2:*/		return 0x82090694;
		  /* 82090694h */ case    3:  		/* bc 12, CR6_GT, 20 */
		/* 82090694h case    3:*/		if ( regs.CR[6].gt ) { return 0x820906A8;  }
		/* 82090694h case    3:*/		return 0x82090698;
		  /* 82090698h */ case    4:  		/* neg R14, R11 */
		/* 82090698h case    4:*/		cpu::op::neg<0>(regs,&regs.R14,regs.R11);
		/* 82090698h case    4:*/		return 0x8209069C;
		  /* 8209069Ch */ case    5:  		/* cmpw CR6, R9, R14 */
		/* 8209069Ch case    5:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R14);
		/* 8209069Ch case    5:*/		return 0x820906A0;
		  /* 820906A0h */ case    6:  		/* lbz R14, <#[R1 + 81]> */
		/* 820906A0h case    6:*/		cpu::mem::load8z( regs, &regs.R14, (uint32)(regs.R1 + 0x00000051) );
		/* 820906A0h case    6:*/		return 0x820906A4;
		  /* 820906A4h */ case    7:  		/* bc 4, CR6_LT, 8 */
		/* 820906A4h case    7:*/		if ( !regs.CR[6].lt ) { return 0x820906AC;  }
		/* 820906A4h case    7:*/		return 0x820906A8;
	}
	return 0x820906A8;
} // Block from 82090688h-820906A8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820906A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820906A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820906A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820906A8);
		  /* 820906A8h */ case    0:  		/* mr R27, R8 */
		/* 820906A8h case    0:*/		regs.R27 = regs.R8;
		/* 820906A8h case    0:*/		return 0x820906AC;
	}
	return 0x820906AC;
} // Block from 820906A8h-820906ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820906ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820906AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820906AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820906AC);
		  /* 820906ACh */ case    0:  		/* cmpw CR6, R7, R11 */
		/* 820906ACh case    0:*/		cpu::op::cmpw<6>(regs,regs.R7,regs.R11);
		/* 820906ACh case    0:*/		return 0x820906B0;
		  /* 820906B0h */ case    1:  		/* bc 12, CR6_GT, 32 */
		/* 820906B0h case    1:*/		if ( regs.CR[6].gt ) { return 0x820906D0;  }
		/* 820906B0h case    1:*/		return 0x820906B4;
		  /* 820906B4h */ case    2:  		/* neg R8, R11 */
		/* 820906B4h case    2:*/		cpu::op::neg<0>(regs,&regs.R8,regs.R11);
		/* 820906B4h case    2:*/		return 0x820906B8;
		  /* 820906B8h */ case    3:  		/* cmpw CR6, R7, R8 */
		/* 820906B8h case    3:*/		cpu::op::cmpw<6>(regs,regs.R7,regs.R8);
		/* 820906B8h case    3:*/		return 0x820906BC;
		  /* 820906BCh */ case    4:  		/* bc 12, CR6_LT, 20 */
		/* 820906BCh case    4:*/		if ( regs.CR[6].lt ) { return 0x820906D0;  }
		/* 820906BCh case    4:*/		return 0x820906C0;
		  /* 820906C0h */ case    5:  		/* cmpw CR6, R9, R11 */
		/* 820906C0h case    5:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R11);
		/* 820906C0h case    5:*/		return 0x820906C4;
		  /* 820906C4h */ case    6:  		/* bc 12, CR6_GT, 12 */
		/* 820906C4h case    6:*/		if ( regs.CR[6].gt ) { return 0x820906D0;  }
		/* 820906C4h case    6:*/		return 0x820906C8;
		  /* 820906C8h */ case    7:  		/* cmpw CR6, R9, R8 */
		/* 820906C8h case    7:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R8);
		/* 820906C8h case    7:*/		return 0x820906CC;
		  /* 820906CCh */ case    8:  		/* bc 4, CR6_LT, 28 */
		/* 820906CCh case    8:*/		if ( !regs.CR[6].lt ) { return 0x820906E8;  }
		/* 820906CCh case    8:*/		return 0x820906D0;
	}
	return 0x820906D0;
} // Block from 820906ACh-820906D0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820906D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820906D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820906D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820906D0);
		  /* 820906D0h */ case    0:  		/* lwz R11, <#[R1 + 88]> */
		/* 820906D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 820906D0h case    0:*/		return 0x820906D4;
		  /* 820906D4h */ case    1:  		/* lwz R8, <#[R1 + 92]> */
		/* 820906D4h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x0000005C) );
		/* 820906D4h case    1:*/		return 0x820906D8;
		  /* 820906D8h */ case    2:  		/* add R11, R7, R11 */
		/* 820906D8h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 820906D8h case    2:*/		return 0x820906DC;
		  /* 820906DCh */ case    3:  		/* add R9, R9, R8 */
		/* 820906DCh case    3:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820906DCh case    3:*/		return 0x820906E0;
		  /* 820906E0h */ case    4:  		/* stw R11, <#[R1 + 88]> */
		/* 820906E0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 820906E0h case    4:*/		return 0x820906E4;
		  /* 820906E4h */ case    5:  		/* stw R9, <#[R1 + 92]> */
		/* 820906E4h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000005C) );
		/* 820906E4h case    5:*/		return 0x820906E8;
	}
	return 0x820906E8;
} // Block from 820906D0h-820906E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820906E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820906E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820906E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820906E8);
		  /* 820906E8h */ case    0:  		/* cmpw CR6, R5, R6 */
		/* 820906E8h case    0:*/		cpu::op::cmpw<6>(regs,regs.R5,regs.R6);
		/* 820906E8h case    0:*/		return 0x820906EC;
		  /* 820906ECh */ case    1:  		/* bc 12, CR6_GT, 32 */
		/* 820906ECh case    1:*/		if ( regs.CR[6].gt ) { return 0x8209070C;  }
		/* 820906ECh case    1:*/		return 0x820906F0;
		  /* 820906F0h */ case    2:  		/* neg R11, R6 */
		/* 820906F0h case    2:*/		cpu::op::neg<0>(regs,&regs.R11,regs.R6);
		/* 820906F0h case    2:*/		return 0x820906F4;
		  /* 820906F4h */ case    3:  		/* cmpw CR6, R5, R11 */
		/* 820906F4h case    3:*/		cpu::op::cmpw<6>(regs,regs.R5,regs.R11);
		/* 820906F4h case    3:*/		return 0x820906F8;
		  /* 820906F8h */ case    4:  		/* bc 12, CR6_LT, 20 */
		/* 820906F8h case    4:*/		if ( regs.CR[6].lt ) { return 0x8209070C;  }
		/* 820906F8h case    4:*/		return 0x820906FC;
		  /* 820906FCh */ case    5:  		/* cmpw CR6, R4, R6 */
		/* 820906FCh case    5:*/		cpu::op::cmpw<6>(regs,regs.R4,regs.R6);
		/* 820906FCh case    5:*/		return 0x82090700;
		  /* 82090700h */ case    6:  		/* bc 12, CR6_GT, 12 */
		/* 82090700h case    6:*/		if ( regs.CR[6].gt ) { return 0x8209070C;  }
		/* 82090700h case    6:*/		return 0x82090704;
		  /* 82090704h */ case    7:  		/* cmpw CR6, R4, R11 */
		/* 82090704h case    7:*/		cpu::op::cmpw<6>(regs,regs.R4,regs.R11);
		/* 82090704h case    7:*/		return 0x82090708;
		  /* 82090708h */ case    8:  		/* bc 4, CR6_LT, 20 */
		/* 82090708h case    8:*/		if ( !regs.CR[6].lt ) { return 0x8209071C;  }
		/* 82090708h case    8:*/		return 0x8209070C;
	}
	return 0x8209070C;
} // Block from 820906E8h-8209070Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209070Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209070C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209070C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209070C);
		  /* 8209070Ch */ case    0:  		/* lwz R11, <#[R1 + 84]> */
		/* 8209070Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8209070Ch case    0:*/		return 0x82090710;
		  /* 82090710h */ case    1:  		/* add R15, R5, R15 */
		/* 82090710h case    1:*/		cpu::op::add<0>(regs,&regs.R15,regs.R5,regs.R15);
		/* 82090710h case    1:*/		return 0x82090714;
		  /* 82090714h */ case    2:  		/* add R11, R4, R11 */
		/* 82090714h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R4,regs.R11);
		/* 82090714h case    2:*/		return 0x82090718;
		  /* 82090718h */ case    3:  		/* stw R11, <#[R1 + 84]> */
		/* 82090718h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82090718h case    3:*/		return 0x8209071C;
	}
	return 0x8209071C;
} // Block from 8209070Ch-8209071Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209071Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209071C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209071C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209071C);
		  /* 8209071Ch */ case    0:  		/* extsh. R11, R30 */
		/* 8209071Ch case    0:*/		cpu::op::extsh<1>(regs,&regs.R11,regs.R30);
		/* 8209071Ch case    0:*/		return 0x82090720;
		  /* 82090720h */ case    1:  		/* bc 4, CR0_EQ, 28 */
		/* 82090720h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8209073C;  }
		/* 82090720h case    1:*/		return 0x82090724;
		  /* 82090724h */ case    2:  		/* extsh. R11, R29 */
		/* 82090724h case    2:*/		cpu::op::extsh<1>(regs,&regs.R11,regs.R29);
		/* 82090724h case    2:*/		return 0x82090728;
		  /* 82090728h */ case    3:  		/* bc 4, CR0_EQ, 20 */
		/* 82090728h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8209073C;  }
		/* 82090728h case    3:*/		return 0x8209072C;
		  /* 8209072Ch */ case    4:  		/* extsh. R11, R28 */
		/* 8209072Ch case    4:*/		cpu::op::extsh<1>(regs,&regs.R11,regs.R28);
		/* 8209072Ch case    4:*/		return 0x82090730;
		  /* 82090730h */ case    5:  		/* bc 4, CR0_EQ, 12 */
		/* 82090730h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8209073C;  }
		/* 82090730h case    5:*/		return 0x82090734;
		  /* 82090734h */ case    6:  		/* extsh. R11, R27 */
		/* 82090734h case    6:*/		cpu::op::extsh<1>(regs,&regs.R11,regs.R27);
		/* 82090734h case    6:*/		return 0x82090738;
		  /* 82090738h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 82090738h case    7:*/		if ( regs.CR[0].eq ) { return 0x8209074C;  }
		/* 82090738h case    7:*/		return 0x8209073C;
	}
	return 0x8209073C;
} // Block from 8209071Ch-8209073Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209073Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209073C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209073C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209073C);
		  /* 8209073Ch */ case    0:  		/* addi R11, R1, 128 */
		/* 8209073Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 8209073Ch case    0:*/		return 0x82090740;
		  /* 82090740h */ case    1:  		/* li R8, 1 */
		/* 82090740h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82090740h case    1:*/		return 0x82090744;
		  /* 82090744h */ case    2:  		/* stwx R8, <#[R16 + R11]> */
		/* 82090744h case    2:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R16 + regs.R11 + 0x00000000) );
		/* 82090744h case    2:*/		return 0x82090748;
		  /* 82090748h */ case    3:  		/* b 8 */
		/* 82090748h case    3:*/		return 0x82090750;
		/* 82090748h case    3:*/		return 0x8209074C;
	}
	return 0x8209074C;
} // Block from 8209073Ch-8209074Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209074Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209074C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209074C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209074C);
		  /* 8209074Ch */ case    0:  		/* li R8, 1 */
		/* 8209074Ch case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8209074Ch case    0:*/		return 0x82090750;
	}
	return 0x82090750;
} // Block from 8209074Ch-82090750h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82090750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090750);
		  /* 82090750h */ case    0:  		/* lhz R11, <#[R1 + 82]> */
		/* 82090750h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000052) );
		/* 82090750h case    0:*/		return 0x82090754;
		  /* 82090754h */ case    1:  		/* rlwinm R9, R19, 0, 16, 31 */
		/* 82090754h case    1:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R19);
		/* 82090754h case    1:*/		return 0x82090758;
		  /* 82090758h */ case    2:  		/* lhz R7, <#[R10 - 8]> */
		/* 82090758h case    2:*/		cpu::mem::load16z( regs, &regs.R7, (uint32)(regs.R10 + 0xFFFFFFF8) );
		/* 82090758h case    2:*/		return 0x8209075C;
		  /* 8209075Ch */ case    3:  		/* rlwinm R6, R21, 0, 16, 31 */
		/* 8209075Ch case    3:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R6,regs.R21);
		/* 8209075Ch case    3:*/		return 0x82090760;
		  /* 82090760h */ case    4:  		/* lhz R5, <#[R10 + 20]> */
		/* 82090760h case    4:*/		cpu::mem::load16z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000014) );
		/* 82090760h case    4:*/		return 0x82090764;
		  /* 82090764h */ case    5:  		/* lfs FR10, <#[R10 + 4]> */
		/* 82090764h case    5:*/		cpu::mem::load32f( regs, &regs.FR10, (uint32)(regs.R10 + 0x00000004) );
		/* 82090764h case    5:*/		return 0x82090768;
		  /* 82090768h */ case    6:  		/* lhz R4, <#[R10 + 32]> */
		/* 82090768h case    6:*/		cpu::mem::load16z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000020) );
		/* 82090768h case    6:*/		return 0x8209076C;
		  /* 8209076Ch */ case    7:  		/* or R11, R11, R7 */
		/* 8209076Ch case    7:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 8209076Ch case    7:*/		return 0x82090770;
		  /* 82090770h */ case    8:  		/* lfs FR9, <#[R10 + 8]> */
		/* 82090770h case    8:*/		cpu::mem::load32f( regs, &regs.FR9, (uint32)(regs.R10 + 0x00000008) );
		/* 82090770h case    8:*/		return 0x82090774;
		  /* 82090774h */ case    9:  		/* or R9, R9, R5 */
		/* 82090774h case    9:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R5);
		/* 82090774h case    9:*/		return 0x82090778;
		  /* 82090778h */ case   10:  		/* lfs FR8, <#[R10 + 12]> */
		/* 82090778h case   10:*/		cpu::mem::load32f( regs, &regs.FR8, (uint32)(regs.R10 + 0x0000000C) );
		/* 82090778h case   10:*/		return 0x8209077C;
		  /* 8209077Ch */ case   11:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209077Ch case   11:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209077Ch case   11:*/		return 0x82090780;
		  /* 82090780h */ case   12:  		/* lfs FR7, <#[R10 + 16]> */
		/* 82090780h case   12:*/		cpu::mem::load32f( regs, &regs.FR7, (uint32)(regs.R10 + 0x00000010) );
		/* 82090780h case   12:*/		return 0x82090784;
		  /* 82090784h */ case   13:  		/* or R21, R4, R6 */
		/* 82090784h case   13:*/		cpu::op::or<0>(regs,&regs.R21,regs.R4,regs.R6);
		/* 82090784h case   13:*/		return 0x82090788;
		  /* 82090788h */ case   14:  		/* fadds FR0, FR10, FR0 */
		/* 82090788h case   14:*/		cpu::op::fadds<0>(regs,&regs.FR0,regs.FR10,regs.FR0);
		/* 82090788h case   14:*/		return 0x8209078C;
		  /* 8209078Ch */ case   15:  		/* stfs FR0, <#[R31 + 12]> */
		/* 8209078Ch case   15:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209078Ch case   15:*/		return 0x82090790;
		  /* 82090790h */ case   16:  		/* fadds FR13, FR9, FR13 */
		/* 82090790h case   16:*/		cpu::op::fadds<0>(regs,&regs.FR13,regs.FR9,regs.FR13);
		/* 82090790h case   16:*/		return 0x82090794;
		  /* 82090794h */ case   17:  		/* stfs FR13, <#[R31 + 16]> */
		/* 82090794h case   17:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R31 + 0x00000010) );
		/* 82090794h case   17:*/		return 0x82090798;
		  /* 82090798h */ case   18:  		/* fadds FR12, FR8, FR12 */
		/* 82090798h case   18:*/		cpu::op::fadds<0>(regs,&regs.FR12,regs.FR8,regs.FR12);
		/* 82090798h case   18:*/		return 0x8209079C;
		  /* 8209079Ch */ case   19:  		/* stfs FR12, <#[R31 + 20]> */
		/* 8209079Ch case   19:*/		cpu::mem::store32f( regs, regs.FR12, (uint32)(regs.R31 + 0x00000014) );
		/* 8209079Ch case   19:*/		return 0x820907A0;
		  /* 820907A0h */ case   20:  		/* fadds FR11, FR7, FR11 */
		/* 820907A0h case   20:*/		cpu::op::fadds<0>(regs,&regs.FR11,regs.FR7,regs.FR11);
		/* 820907A0h case   20:*/		return 0x820907A4;
		  /* 820907A4h */ case   21:  		/* stfs FR11, <#[R31 + 24]> */
		/* 820907A4h case   21:*/		cpu::mem::store32f( regs, regs.FR11, (uint32)(regs.R31 + 0x00000018) );
		/* 820907A4h case   21:*/		return 0x820907A8;
		  /* 820907A8h */ case   22:  		/* sth R11, <#[R1 + 82]> */
		/* 820907A8h case   22:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000052) );
		/* 820907A8h case   22:*/		return 0x820907AC;
		  /* 820907ACh */ case   23:  		/* rlwinm R19, R9, 0, 16, 31 */
		/* 820907ACh case   23:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R19,regs.R9);
		/* 820907ACh case   23:*/		return 0x820907B0;
		  /* 820907B0h */ case   24:  		/* sth R11, <#[R31]> */
		/* 820907B0h case   24:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820907B0h case   24:*/		return 0x820907B4;
		  /* 820907B4h */ case   25:  		/* cmplw CR6, R7, R5 */
		/* 820907B4h case   25:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R5);
		/* 820907B4h case   25:*/		return 0x820907B8;
		  /* 820907B8h */ case   26:  		/* sth R21, <#[R31 + 40]> */
		/* 820907B8h case   26:*/		cpu::mem::store16( regs, regs.R21, (uint32)(regs.R31 + 0x00000028) );
		/* 820907B8h case   26:*/		return 0x820907BC;
		  /* 820907BCh */ case   27:  		/* bc 12, CR6_EQ, 12 */
		/* 820907BCh case   27:*/		if ( regs.CR[6].eq ) { return 0x820907C8;  }
		/* 820907BCh case   27:*/		return 0x820907C0;
		  /* 820907C0h */ case   28:  		/* addi R11, R1, 112 */
		/* 820907C0h case   28:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820907C0h case   28:*/		return 0x820907C4;
		  /* 820907C4h */ case   29:  		/* stwx R8, <#[R16 + R11]> */
		/* 820907C4h case   29:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R16 + regs.R11 + 0x00000000) );
		/* 820907C4h case   29:*/		return 0x820907C8;
	}
	return 0x820907C8;
} // Block from 82090750h-820907C8h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820907C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820907C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820907C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820907C8);
		  /* 820907C8h */ case    0:  		/* li R11, 8 */
		/* 820907C8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x8);
		/* 820907C8h case    0:*/		return 0x820907CC;
		  /* 820907CCh */ case    1:  		/* lwz R10, <#[R10 + 28]> */
		/* 820907CCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000001C) );
		/* 820907CCh case    1:*/		return 0x820907D0;
		  /* 820907D0h */ case    2:  		/* mtspr CTR, R11 */
		/* 820907D0h case    2:*/		regs.CTR = regs.R11;
		/* 820907D0h case    2:*/		return 0x820907D4;
		  /* 820907D4h */ case    3:  		/* addi R11, R22, 2 */
		/* 820907D4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R22,0x2);
		/* 820907D4h case    3:*/		return 0x820907D8;
		  /* 820907D8h */ case    4:  		/* lbz R9, <#[R1 + 80]> */
		/* 820907D8h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820907D8h case    4:*/		return 0x820907DC;
		  /* 820907DCh */ case    5:  		/* addi R7, R22, 3 */
		/* 820907DCh case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R22,0x3);
		/* 820907DCh case    5:*/		return 0x820907E0;
		  /* 820907E0h */ case    6:  		/* addi R6, R22, 44 */
		/* 820907E0h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R22,0x2C);
		/* 820907E0h case    6:*/		return 0x820907E4;
		  /* 820907E4h */ case    7:  		/* addi R5, R22, 32 */
		/* 820907E4h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R22,0x20);
		/* 820907E4h case    7:*/		return 0x820907E8;
		  /* 820907E8h */ case    8:  		/* addi R4, R22, 48 */
		/* 820907E8h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R22,0x30);
		/* 820907E8h case    8:*/		return 0x820907EC;
		  /* 820907ECh */ case    9:  		/* lbzx R30, <#[R3 + R11]> */
		/* 820907ECh case    9:*/		cpu::mem::load8z( regs, &regs.R30, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 820907ECh case    9:*/		return 0x820907F0;
		  /* 820907F0h */ case   10:  		/* rlwinm R29, R14, 0, 24, 31 */
		/* 820907F0h case   10:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R29,regs.R14);
		/* 820907F0h case   10:*/		return 0x820907F4;
		  /* 820907F4h */ case   11:  		/* lbzx R11, <#[R3 + R7]> */
		/* 820907F4h case   11:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 820907F4h case   11:*/		return 0x820907F8;
		  /* 820907F8h */ case   12:  		/* or R23, R10, R23 */
		/* 820907F8h case   12:*/		cpu::op::or<0>(regs,&regs.R23,regs.R10,regs.R23);
		/* 820907F8h case   12:*/		return 0x820907FC;
		  /* 820907FCh */ case   13:  		/* lwzx R7, <#[R3 + R6]> */
		/* 820907FCh case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + regs.R6 + 0x00000000) );
		/* 820907FCh case   13:*/		return 0x82090800;
		  /* 82090800h */ case   14:  		/* or R6, R29, R30 */
		/* 82090800h case   14:*/		cpu::op::or<0>(regs,&regs.R6,regs.R29,regs.R30);
		/* 82090800h case   14:*/		return 0x82090804;
		  /* 82090804h */ case   15:  		/* lwzx R5, <#[R3 + R5]> */
		/* 82090804h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + regs.R5 + 0x00000000) );
		/* 82090804h case   15:*/		return 0x82090808;
		  /* 82090808h */ case   16:  		/* or R9, R9, R11 */
		/* 82090808h case   16:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 82090808h case   16:*/		return 0x8209080C;
		  /* 8209080Ch */ case   17:  		/* lwzx R4, <#[R3 + R4]> */
		/* 8209080Ch case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + regs.R4 + 0x00000000) );
		/* 8209080Ch case   17:*/		return 0x82090810;
		  /* 82090810h */ case   18:  		/* rlwinm R14, R6, 0, 24, 31 */
		/* 82090810h case   18:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R14,regs.R6);
		/* 82090810h case   18:*/		return 0x82090814;
		  /* 82090814h */ case   19:  		/* rlwinm R9, R9, 0, 24, 31 */
		/* 82090814h case   19:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R9,regs.R9);
		/* 82090814h case   19:*/		return 0x82090818;
		  /* 82090818h */ case   20:  		/* stw R23, <#[R31 + 36]> */
		/* 82090818h case   20:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x00000024) );
		/* 82090818h case   20:*/		return 0x8209081C;
		  /* 8209081Ch */ case   21:  		/* or R26, R7, R26 */
		/* 8209081Ch case   21:*/		cpu::op::or<0>(regs,&regs.R26,regs.R7,regs.R26);
		/* 8209081Ch case   21:*/		return 0x82090820;
		  /* 82090820h */ case   22:  		/* stb R14, <#[R31 + 2]> */
		/* 82090820h case   22:*/		cpu::mem::store8( regs, regs.R14, (uint32)(regs.R31 + 0x00000002) );
		/* 82090820h case   22:*/		return 0x82090824;
		  /* 82090824h */ case   23:  		/* or R25, R5, R25 */
		/* 82090824h case   23:*/		cpu::op::or<0>(regs,&regs.R25,regs.R5,regs.R25);
		/* 82090824h case   23:*/		return 0x82090828;
		  /* 82090828h */ case   24:  		/* stb R9, <#[R1 + 80]> */
		/* 82090828h case   24:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 82090828h case   24:*/		return 0x8209082C;
		  /* 8209082Ch */ case   25:  		/* or R24, R4, R24 */
		/* 8209082Ch case   25:*/		cpu::op::or<0>(regs,&regs.R24,regs.R4,regs.R24);
		/* 8209082Ch case   25:*/		return 0x82090830;
		  /* 82090830h */ case   26:  		/* stw R26, <#[R31 + 44]> */
		/* 82090830h case   26:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x0000002C) );
		/* 82090830h case   26:*/		return 0x82090834;
		  /* 82090834h */ case   27:  		/* stw R25, <#[R31 + 32]> */
		/* 82090834h case   27:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x00000020) );
		/* 82090834h case   27:*/		return 0x82090838;
		  /* 82090838h */ case   28:  		/* cmpw CR6, R30, R5 */
		/* 82090838h case   28:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R5);
		/* 82090838h case   28:*/		return 0x8209083C;
		  /* 8209083Ch */ case   29:  		/* stb R9, <#[R31 + 3]> */
		/* 8209083Ch case   29:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R31 + 0x00000003) );
		/* 8209083Ch case   29:*/		return 0x82090840;
		  /* 82090840h */ case   30:  		/* stw R24, <#[R31 + 48]> */
		/* 82090840h case   30:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000030) );
		/* 82090840h case   30:*/		return 0x82090844;
		  /* 82090844h */ case   31:  		/* bc 12, CR6_EQ, 12 */
		/* 82090844h case   31:*/		if ( regs.CR[6].eq ) { return 0x82090850;  }
		/* 82090844h case   31:*/		return 0x82090848;
		  /* 82090848h */ case   32:  		/* addi R9, R1, 112 */
		/* 82090848h case   32:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 82090848h case   32:*/		return 0x8209084C;
		  /* 8209084Ch */ case   33:  		/* stwx R8, <#[R16 + R9]> */
		/* 8209084Ch case   33:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R16 + regs.R9 + 0x00000000) );
		/* 8209084Ch case   33:*/		return 0x82090850;
	}
	return 0x82090850;
} // Block from 820907C8h-82090850h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82090850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090850);
		  /* 82090850h */ case    0:  		/* cmpw CR6, R11, R10 */
		/* 82090850h case    0:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82090850h case    0:*/		return 0x82090854;
		  /* 82090854h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82090854h case    1:*/		if ( regs.CR[6].eq ) { return 0x82090860;  }
		/* 82090854h case    1:*/		return 0x82090858;
		  /* 82090858h */ case    2:  		/* addi R11, R1, 112 */
		/* 82090858h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 82090858h case    2:*/		return 0x8209085C;
		  /* 8209085Ch */ case    3:  		/* stwx R8, <#[R16 + R11]> */
		/* 8209085Ch case    3:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R16 + regs.R11 + 0x00000000) );
		/* 8209085Ch case    3:*/		return 0x82090860;
	}
	return 0x82090860;
} // Block from 82090850h-82090860h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82090860h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090860);
		  /* 82090860h */ case    0:  		/* bc 16, CR0_LT, -140 */
		/* 82090860h case    0:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820907D4;  }
		/* 82090860h case    0:*/		return 0x82090864;
		  /* 82090864h */ case    1:  		/* lwz R30, <#[R1 + 324]> */
		/* 82090864h case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000144) );
		/* 82090864h case    1:*/		return 0x82090868;
		  /* 82090868h */ case    2:  		/* lwz R9, <#[R1 + 84]> */
		/* 82090868h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 82090868h case    2:*/		return 0x8209086C;
		  /* 8209086Ch */ case    3:  		/* lwz R8, <#[R1 + 88]> */
		/* 8209086Ch case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000058) );
		/* 8209086Ch case    3:*/		return 0x82090870;
		  /* 82090870h */ case    4:  		/* lwz R7, <#[R1 + 92]> */
		/* 82090870h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x0000005C) );
		/* 82090870h case    4:*/		return 0x82090874;
		  /* 82090874h */ case    5:  		/* lwz R29, <#[R1 + 332]> */
		/* 82090874h case    5:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x0000014C) );
		/* 82090874h case    5:*/		return 0x82090878;
		  /* 82090878h */ case    6:  		/* stb R14, <#[R1 + 81]> */
		/* 82090878h case    6:*/		cpu::mem::store8( regs, regs.R14, (uint32)(regs.R1 + 0x00000051) );
		/* 82090878h case    6:*/		return 0x8209087C;
	}
	return 0x8209087C;
} // Block from 82090860h-8209087Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209087Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209087C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209087C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209087C);
		  /* 8209087Ch */ case    0:  		/* lwz R11, <#[R1 + 96]> */
		/* 8209087Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 8209087Ch case    0:*/		return 0x82090880;
		  /* 82090880h */ case    1:  		/* addi R3, R3, 88 */
		/* 82090880h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x58);
		/* 82090880h case    1:*/		return 0x82090884;
		  /* 82090884h */ case    2:  		/* addi R16, R16, 4 */
		/* 82090884h case    2:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R16,0x4);
		/* 82090884h case    2:*/		return 0x82090888;
		  /* 82090888h */ case    3:  		/* addi R11, R11, 1 */
		/* 82090888h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82090888h case    3:*/		return 0x8209088C;
		  /* 8209088Ch */ case    4:  		/* cmplwi CR6, R3, 352 */
		/* 8209088Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000160);
		/* 8209088Ch case    4:*/		return 0x82090890;
		  /* 82090890h */ case    5:  		/* stw R11, <#[R1 + 96]> */
		/* 82090890h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82090890h case    5:*/		return 0x82090894;
		  /* 82090894h */ case    6:  		/* bc 12, CR6_LT, -692 */
		/* 82090894h case    6:*/		if ( regs.CR[6].lt ) { return 0x820905E0;  }
		/* 82090894h case    6:*/		return 0x82090898;
		  /* 82090898h */ case    7:  		/* sth R19, <#[R31 + 28]> */
		/* 82090898h case    7:*/		cpu::mem::store16( regs, regs.R19, (uint32)(regs.R31 + 0x0000001C) );
		/* 82090898h case    7:*/		return 0x8209089C;
		  /* 8209089Ch */ case    8:  		/* mr R11, R15 */
		/* 8209089Ch case    8:*/		regs.R11 = regs.R15;
		/* 8209089Ch case    8:*/		return 0x820908A0;
		  /* 820908A0h */ case    9:  		/* cmpwi CR6, R15, 32767 */
		/* 820908A0h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R15,0x00007FFF);
		/* 820908A0h case    9:*/		return 0x820908A4;
		  /* 820908A4h */ case   10:  		/* bc 12, CR6_LT, 8 */
		/* 820908A4h case   10:*/		if ( regs.CR[6].lt ) { return 0x820908AC;  }
		/* 820908A4h case   10:*/		return 0x820908A8;
		  /* 820908A8h */ case   11:  		/* li R11, 32767 */
		/* 820908A8h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x7FFF);
		/* 820908A8h case   11:*/		return 0x820908AC;
	}
	return 0x820908AC;
} // Block from 8209087Ch-820908ACh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820908ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820908AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820908AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820908AC);
		  /* 820908ACh */ case    0:  		/* cmpwi CR6, R11, -32768 */
		/* 820908ACh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFF8000);
		/* 820908ACh case    0:*/		return 0x820908B0;
		  /* 820908B0h */ case    1:  		/* bc 12, CR6_GT, 8 */
		/* 820908B0h case    1:*/		if ( regs.CR[6].gt ) { return 0x820908B8;  }
		/* 820908B0h case    1:*/		return 0x820908B4;
		  /* 820908B4h */ case    2:  		/* li R11, -32768 */
		/* 820908B4h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFF8000);
		/* 820908B4h case    2:*/		return 0x820908B8;
	}
	return 0x820908B8;
} // Block from 820908ACh-820908B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820908B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820908B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820908B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820908B8);
		  /* 820908B8h */ case    0:  		/* mr R10, R11 */
		/* 820908B8h case    0:*/		regs.R10 = regs.R11;
		/* 820908B8h case    0:*/		return 0x820908BC;
		  /* 820908BCh */ case    1:  		/* mr R11, R9 */
		/* 820908BCh case    1:*/		regs.R11 = regs.R9;
		/* 820908BCh case    1:*/		return 0x820908C0;
		  /* 820908C0h */ case    2:  		/* sth R10, <#[R31 + 4]> */
		/* 820908C0h case    2:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820908C0h case    2:*/		return 0x820908C4;
		  /* 820908C4h */ case    3:  		/* cmpwi CR6, R9, 32767 */
		/* 820908C4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00007FFF);
		/* 820908C4h case    3:*/		return 0x820908C8;
		  /* 820908C8h */ case    4:  		/* bc 12, CR6_LT, 8 */
		/* 820908C8h case    4:*/		if ( regs.CR[6].lt ) { return 0x820908D0;  }
		/* 820908C8h case    4:*/		return 0x820908CC;
		  /* 820908CCh */ case    5:  		/* li R11, 32767 */
		/* 820908CCh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x7FFF);
		/* 820908CCh case    5:*/		return 0x820908D0;
	}
	return 0x820908D0;
} // Block from 820908B8h-820908D0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820908D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820908D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820908D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820908D0);
		  /* 820908D0h */ case    0:  		/* cmpwi CR6, R11, -32768 */
		/* 820908D0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFF8000);
		/* 820908D0h case    0:*/		return 0x820908D4;
		  /* 820908D4h */ case    1:  		/* bc 12, CR6_GT, 8 */
		/* 820908D4h case    1:*/		if ( regs.CR[6].gt ) { return 0x820908DC;  }
		/* 820908D4h case    1:*/		return 0x820908D8;
		  /* 820908D8h */ case    2:  		/* li R11, -32768 */
		/* 820908D8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFF8000);
		/* 820908D8h case    2:*/		return 0x820908DC;
	}
	return 0x820908DC;
} // Block from 820908D0h-820908DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820908DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820908DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820908DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820908DC);
		  /* 820908DCh */ case    0:  		/* mr R10, R11 */
		/* 820908DCh case    0:*/		regs.R10 = regs.R11;
		/* 820908DCh case    0:*/		return 0x820908E0;
		  /* 820908E0h */ case    1:  		/* mr R11, R8 */
		/* 820908E0h case    1:*/		regs.R11 = regs.R8;
		/* 820908E0h case    1:*/		return 0x820908E4;
		  /* 820908E4h */ case    2:  		/* sth R10, <#[R31 + 6]> */
		/* 820908E4h case    2:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R31 + 0x00000006) );
		/* 820908E4h case    2:*/		return 0x820908E8;
		  /* 820908E8h */ case    3:  		/* cmpwi CR6, R8, 32767 */
		/* 820908E8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00007FFF);
		/* 820908E8h case    3:*/		return 0x820908EC;
		  /* 820908ECh */ case    4:  		/* bc 12, CR6_LT, 8 */
		/* 820908ECh case    4:*/		if ( regs.CR[6].lt ) { return 0x820908F4;  }
		/* 820908ECh case    4:*/		return 0x820908F0;
		  /* 820908F0h */ case    5:  		/* li R11, 32767 */
		/* 820908F0h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x7FFF);
		/* 820908F0h case    5:*/		return 0x820908F4;
	}
	return 0x820908F4;
} // Block from 820908DCh-820908F4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820908F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820908F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820908F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820908F4);
		  /* 820908F4h */ case    0:  		/* cmpwi CR6, R11, -32768 */
		/* 820908F4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFF8000);
		/* 820908F4h case    0:*/		return 0x820908F8;
		  /* 820908F8h */ case    1:  		/* bc 12, CR6_GT, 8 */
		/* 820908F8h case    1:*/		if ( regs.CR[6].gt ) { return 0x82090900;  }
		/* 820908F8h case    1:*/		return 0x820908FC;
		  /* 820908FCh */ case    2:  		/* li R11, -32768 */
		/* 820908FCh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFF8000);
		/* 820908FCh case    2:*/		return 0x82090900;
	}
	return 0x82090900;
} // Block from 820908F4h-82090900h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82090900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090900);
		  /* 82090900h */ case    0:  		/* mr R10, R11 */
		/* 82090900h case    0:*/		regs.R10 = regs.R11;
		/* 82090900h case    0:*/		return 0x82090904;
		  /* 82090904h */ case    1:  		/* mr R11, R7 */
		/* 82090904h case    1:*/		regs.R11 = regs.R7;
		/* 82090904h case    1:*/		return 0x82090908;
		  /* 82090908h */ case    2:  		/* sth R10, <#[R31 + 8]> */
		/* 82090908h case    2:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82090908h case    2:*/		return 0x8209090C;
		  /* 8209090Ch */ case    3:  		/* cmpwi CR6, R7, 32767 */
		/* 8209090Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00007FFF);
		/* 8209090Ch case    3:*/		return 0x82090910;
		  /* 82090910h */ case    4:  		/* bc 12, CR6_LT, 8 */
		/* 82090910h case    4:*/		if ( regs.CR[6].lt ) { return 0x82090918;  }
		/* 82090910h case    4:*/		return 0x82090914;
		  /* 82090914h */ case    5:  		/* li R11, 32767 */
		/* 82090914h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x7FFF);
		/* 82090914h case    5:*/		return 0x82090918;
	}
	return 0x82090918;
} // Block from 82090900h-82090918h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82090918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090918);
		  /* 82090918h */ case    0:  		/* cmpwi CR6, R11, -32768 */
		/* 82090918h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFF8000);
		/* 82090918h case    0:*/		return 0x8209091C;
		  /* 8209091Ch */ case    1:  		/* bc 12, CR6_GT, 8 */
		/* 8209091Ch case    1:*/		if ( regs.CR[6].gt ) { return 0x82090924;  }
		/* 8209091Ch case    1:*/		return 0x82090920;
		  /* 82090920h */ case    2:  		/* li R11, -32768 */
		/* 82090920h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFF8000);
		/* 82090920h case    2:*/		return 0x82090924;
	}
	return 0x82090924;
} // Block from 82090918h-82090924h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82090924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090924);
		  /* 82090924h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 82090924h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82090924h case    0:*/		return 0x82090928;
		  /* 82090928h */ case    1:  		/* sth R11, <#[R31 + 10]> */
		/* 82090928h case    1:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0x0000000A) );
		/* 82090928h case    1:*/		return 0x8209092C;
		  /* 8209092Ch */ case    2:  		/* bc 12, CR6_EQ, 124 */
		/* 8209092Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820909A8;  }
		/* 8209092Ch case    2:*/		return 0x82090930;
		  /* 82090930h */ case    3:  		/* li R11, 4 */
		/* 82090930h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 82090930h case    3:*/		return 0x82090934;
		  /* 82090934h */ case    4:  		/* mr R9, R18 */
		/* 82090934h case    4:*/		regs.R9 = regs.R18;
		/* 82090934h case    4:*/		return 0x82090938;
		  /* 82090938h */ case    5:  		/* mr R10, R18 */
		/* 82090938h case    5:*/		regs.R10 = regs.R18;
		/* 82090938h case    5:*/		return 0x8209093C;
		  /* 8209093Ch */ case    6:  		/* addi R7, R22, 40 */
		/* 8209093Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R22,0x28);
		/* 8209093Ch case    6:*/		return 0x82090940;
		  /* 82090940h */ case    7:  		/* mr R8, R18 */
		/* 82090940h case    7:*/		regs.R8 = regs.R18;
		/* 82090940h case    7:*/		return 0x82090944;
		  /* 82090944h */ case    8:  		/* mtspr CTR, R11 */
		/* 82090944h case    8:*/		regs.CTR = regs.R11;
		/* 82090944h case    8:*/		return 0x82090948;
		  /* 82090948h */ case    9:  		/* addi R11, R1, 112 */
		/* 82090948h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 82090948h case    9:*/		return 0x8209094C;
		  /* 8209094Ch */ case   10:  		/* lwzx R11, <#[R8 + R11]> */
		/* 8209094Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8209094Ch case   10:*/		return 0x82090950;
		  /* 82090950h */ case   11:  		/* cmpwi CR6, R11, 0 */
		/* 82090950h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82090950h case   11:*/		return 0x82090954;
		  /* 82090954h */ case   12:  		/* bc 4, CR6_EQ, 32 */
		/* 82090954h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82090974;  }
		/* 82090954h case   12:*/		return 0x82090958;
		  /* 82090958h */ case   13:  		/* addi R11, R1, 128 */
		/* 82090958h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 82090958h case   13:*/		return 0x8209095C;
		  /* 8209095Ch */ case   14:  		/* lwzx R11, <#[R8 + R11]> */
		/* 8209095Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8209095Ch case   14:*/		return 0x82090960;
		  /* 82090960h */ case   15:  		/* cmpwi CR6, R11, 0 */
		/* 82090960h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82090960h case   15:*/		return 0x82090964;
		  /* 82090964h */ case   16:  		/* bc 4, CR6_EQ, 16 */
		/* 82090964h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82090974;  }
		/* 82090964h case   16:*/		return 0x82090968;
		  /* 82090968h */ case   17:  		/* lhz R11, <#[R7]> */
		/* 82090968h case   17:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 82090968h case   17:*/		return 0x8209096C;
		  /* 8209096Ch */ case   18:  		/* cmplwi CR0, R11, 0 */
		/* 8209096Ch case   18:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8209096Ch case   18:*/		return 0x82090970;
		  /* 82090970h */ case   19:  		/* bc 12, CR0_EQ, 16 */
		/* 82090970h case   19:*/		if ( regs.CR[0].eq ) { return 0x82090980;  }
		/* 82090970h case   19:*/		return 0x82090974;
	}
	return 0x82090974;
} // Block from 82090924h-82090974h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82090974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090974);
		  /* 82090974h */ case    0:  		/* li R11, 1 */
		/* 82090974h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82090974h case    0:*/		return 0x82090978;
		  /* 82090978h */ case    1:  		/* slw R11, R11, R10 */
		/* 82090978h case    1:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82090978h case    1:*/		return 0x8209097C;
		  /* 8209097Ch */ case    2:  		/* or R9, R11, R9 */
		/* 8209097Ch case    2:*/		cpu::op::or<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 8209097Ch case    2:*/		return 0x82090980;
	}
	return 0x82090980;
} // Block from 82090974h-82090980h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82090980h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090980);
		  /* 82090980h */ case    0:  		/* addi R10, R10, 1 */
		/* 82090980h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82090980h case    0:*/		return 0x82090984;
		  /* 82090984h */ case    1:  		/* addi R8, R8, 4 */
		/* 82090984h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82090984h case    1:*/		return 0x82090988;
		  /* 82090988h */ case    2:  		/* addi R7, R7, 88 */
		/* 82090988h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x58);
		/* 82090988h case    2:*/		return 0x8209098C;
		  /* 8209098Ch */ case    3:  		/* bc 16, CR0_LT, -68 */
		/* 8209098Ch case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82090948;  }
		/* 8209098Ch case    3:*/		return 0x82090990;
		  /* 82090990h */ case    4:  		/* stw R9, <#[R29]> */
		/* 82090990h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R29 + 0x00000000) );
		/* 82090990h case    4:*/		return 0x82090994;
		  /* 82090994h */ case    5:  		/* lbz R10, <#[R31 + 3]> */
		/* 82090994h case    5:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000003) );
		/* 82090994h case    5:*/		return 0x82090998;
		  /* 82090998h */ case    6:  		/* lhz R11, <#[R31]> */
		/* 82090998h case    6:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82090998h case    6:*/		return 0x8209099C;
		  /* 8209099Ch */ case    7:  		/* lbz R14, <#[R31 + 2]> */
		/* 8209099Ch case    7:*/		cpu::mem::load8z( regs, &regs.R14, (uint32)(regs.R31 + 0x00000002) );
		/* 8209099Ch case    7:*/		return 0x820909A0;
		  /* 820909A0h */ case    8:  		/* sth R11, <#[R1 + 82]> */
		/* 820909A0h case    8:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000052) );
		/* 820909A0h case    8:*/		return 0x820909A4;
		  /* 820909A4h */ case    9:  		/* stb R10, <#[R1 + 80]> */
		/* 820909A4h case    9:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820909A4h case    9:*/		return 0x820909A8;
	}
	return 0x820909A8;
} // Block from 82090980h-820909A8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820909A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820909A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820909A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820909A8);
		  /* 820909A8h */ case    0:  		/* mr R10, R18 */
		/* 820909A8h case    0:*/		regs.R10 = regs.R18;
		/* 820909A8h case    0:*/		return 0x820909AC;
		  /* 820909ACh */ case    1:  		/* mr R11, R18 */
		/* 820909ACh case    1:*/		regs.R11 = regs.R18;
		/* 820909ACh case    1:*/		return 0x820909B0;
		  /* 820909B0h */ case    2:  		/* addi R9, R1, 112 */
		/* 820909B0h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 820909B0h case    2:*/		return 0x820909B4;
		  /* 820909B4h */ case    3:  		/* lwzx R9, <#[R11 + R9]> */
		/* 820909B4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820909B4h case    3:*/		return 0x820909B8;
		  /* 820909B8h */ case    4:  		/* cmpwi CR6, R9, 0 */
		/* 820909B8h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820909B8h case    4:*/		return 0x820909BC;
		  /* 820909BCh */ case    5:  		/* bc 4, CR6_EQ, 40 */
		/* 820909BCh case    5:*/		if ( !regs.CR[6].eq ) { return 0x820909E4;  }
		/* 820909BCh case    5:*/		return 0x820909C0;
		  /* 820909C0h */ case    6:  		/* addi R9, R1, 128 */
		/* 820909C0h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x80);
		/* 820909C0h case    6:*/		return 0x820909C4;
		  /* 820909C4h */ case    7:  		/* lwzx R9, <#[R11 + R9]> */
		/* 820909C4h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820909C4h case    7:*/		return 0x820909C8;
		  /* 820909C8h */ case    8:  		/* cmpwi CR6, R9, 0 */
		/* 820909C8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820909C8h case    8:*/		return 0x820909CC;
		  /* 820909CCh */ case    9:  		/* bc 4, CR6_EQ, 24 */
		/* 820909CCh case    9:*/		if ( !regs.CR[6].eq ) { return 0x820909E4;  }
		/* 820909CCh case    9:*/		return 0x820909D0;
		  /* 820909D0h */ case   10:  		/* addi R11, R11, 4 */
		/* 820909D0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820909D0h case   10:*/		return 0x820909D4;
		  /* 820909D4h */ case   11:  		/* addi R10, R10, 1 */
		/* 820909D4h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820909D4h case   11:*/		return 0x820909D8;
		  /* 820909D8h */ case   12:  		/* cmplwi CR6, R11, 16 */
		/* 820909D8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 820909D8h case   12:*/		return 0x820909DC;
		  /* 820909DCh */ case   13:  		/* bc 12, CR6_LT, -44 */
		/* 820909DCh case   13:*/		if ( regs.CR[6].lt ) { return 0x820909B0;  }
		/* 820909DCh case   13:*/		return 0x820909E0;
		  /* 820909E0h */ case   14:  		/* b 8 */
		/* 820909E0h case   14:*/		return 0x820909E8;
		/* 820909E0h case   14:*/		return 0x820909E4;
	}
	return 0x820909E4;
} // Block from 820909A8h-820909E4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820909E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820909E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820909E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820909E4);
		  /* 820909E4h */ case    0:  		/* stw R10, <#[R31 + 84]> */
		/* 820909E4h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000054) );
		/* 820909E4h case    0:*/		return 0x820909E8;
	}
	return 0x820909E8;
} // Block from 820909E4h-820909E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820909E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820909E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820909E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820909E8);
		  /* 820909E8h */ case    0:  		/* rlwinm R11, R14, 0, 24, 31 */
		/* 820909E8h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R14);
		/* 820909E8h case    0:*/		return 0x820909EC;
		  /* 820909ECh */ case    1:  		/* cmplwi CR6, R11, 128 */
		/* 820909ECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 820909ECh case    1:*/		return 0x820909F0;
		  /* 820909F0h */ case    2:  		/* bc 4, CR6_GT, 44 */
		/* 820909F0h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82090A1C;  }
		/* 820909F0h case    2:*/		return 0x820909F4;
		  /* 820909F4h */ case    3:  		/* lbz R11, <#[R1 + 80]> */
		/* 820909F4h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820909F4h case    3:*/		return 0x820909F8;
		  /* 820909F8h */ case    4:  		/* cmplwi CR6, R11, 128 */
		/* 820909F8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 820909F8h case    4:*/		return 0x820909FC;
		  /* 820909FCh */ case    5:  		/* bc 4, CR6_GT, 32 */
		/* 820909FCh case    5:*/		if ( !regs.CR[6].gt ) { return 0x82090A1C;  }
		/* 820909FCh case    5:*/		return 0x82090A00;
		  /* 82090A00h */ case    6:  		/* lhz R11, <#[R1 + 82]> */
		/* 82090A00h case    6:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000052) );
		/* 82090A00h case    6:*/		return 0x82090A04;
		  /* 82090A04h */ case    7:  		/* rlwinm. R11, R11, 0, 22, 22 */
		/* 82090A04h case    7:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R11,regs.R11);
		/* 82090A04h case    7:*/		return 0x82090A08;
		  /* 82090A08h */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 82090A08h case    8:*/		if ( regs.CR[0].eq ) { return 0x82090A1C;  }
		/* 82090A08h case    8:*/		return 0x82090A0C;
		  /* 82090A0Ch */ case    9:  		/* lis R11, -32256 */
		/* 82090A0Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82090A0Ch case    9:*/		return 0x82090A10;
		  /* 82090A10h */ case   10:  		/* li R4, 0 */
		/* 82090A10h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82090A10h case   10:*/		return 0x82090A14;
		  /* 82090A14h */ case   11:  		/* addi R3, R11, 4485 */
		/* 82090A14h case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1185);
		/* 82090A14h case   11:*/		return 0x82090A18;
		  /* 82090A18h */ case   12:  		/* bl 1927504 */
		/* 82090A18h case   12:*/		regs.LR = 0x82090A1C; return 0x82267368;
		/* 82090A18h case   12:*/		return 0x82090A1C;
	}
	return 0x82090A1C;
} // Block from 820909E8h-82090A1Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 82090A1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090A1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090A1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090A1C);
		  /* 82090A1Ch */ case    0:  		/* mr R3, R31 */
		/* 82090A1Ch case    0:*/		regs.R3 = regs.R31;
		/* 82090A1Ch case    0:*/		return 0x82090A20;
		  /* 82090A20h */ case    1:  		/* addi R1, R1, 304 */
		/* 82090A20h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x130);
		/* 82090A20h case    1:*/		return 0x82090A24;
		  /* 82090A24h */ case    2:  		/* b 2124 */
		/* 82090A24h case    2:*/		return 0x82091270;
		/* 82090A24h case    2:*/		return 0x82090A28;
	}
	return 0x82090A28;
} // Block from 82090A1Ch-82090A28h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82090A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090A28);
		  /* 82090A28h */ case    0:  		/* std R30, <#[R1 - 16]> */
		/* 82090A28h case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82090A28h case    0:*/		return 0x82090A2C;
		  /* 82090A2Ch */ case    1:  		/* std R31, <#[R1 - 8]> */
		/* 82090A2Ch case    1:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82090A2Ch case    1:*/		return 0x82090A30;
		  /* 82090A30h */ case    2:  		/* lis R8, -32217 */
		/* 82090A30h case    2:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8227);
		/* 82090A30h case    2:*/		return 0x82090A34;
		  /* 82090A34h */ case    3:  		/* lis R11, -32247 */
		/* 82090A34h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8209);
		/* 82090A34h case    3:*/		return 0x82090A38;
		  /* 82090A38h */ case    4:  		/* addi R30, R8, 7288 */
		/* 82090A38h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R8,0x1C78);
		/* 82090A38h case    4:*/		return 0x82090A3C;
		  /* 82090A3Ch */ case    5:  		/* addi R11, R11, 18736 */
		/* 82090A3Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4930);
		/* 82090A3Ch case    5:*/		return 0x82090A40;
		  /* 82090A40h */ case    6:  		/* lis R10, -32247 */
		/* 82090A40h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8209);
		/* 82090A40h case    6:*/		return 0x82090A44;
		  /* 82090A44h */ case    7:  		/* lis R9, -32247 */
		/* 82090A44h case    7:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8209);
		/* 82090A44h case    7:*/		return 0x82090A48;
		  /* 82090A48h */ case    8:  		/* stw R11, <#[R8 + 7288]> */
		/* 82090A48h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00001C78) );
		/* 82090A48h case    8:*/		return 0x82090A4C;
		  /* 82090A4Ch */ case    9:  		/* lis R31, -32247 */
		/* 82090A4Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8209);
		/* 82090A4Ch case    9:*/		return 0x82090A50;
		  /* 82090A50h */ case   10:  		/* addi R10, R10, 15824 */
		/* 82090A50h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x3DD0);
		/* 82090A50h case   10:*/		return 0x82090A54;
		  /* 82090A54h */ case   11:  		/* addi R9, R9, 15808 */
		/* 82090A54h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x3DC0);
		/* 82090A54h case   11:*/		return 0x82090A58;
		  /* 82090A58h */ case   12:  		/* addi R11, R31, 15816 */
		/* 82090A58h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x3DC8);
		/* 82090A58h case   12:*/		return 0x82090A5C;
		  /* 82090A5Ch */ case   13:  		/* stw R10, <#[R30 + 4]> */
		/* 82090A5Ch case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 82090A5Ch case   13:*/		return 0x82090A60;
		  /* 82090A60h */ case   14:  		/* lis R3, -32247 */
		/* 82090A60h case   14:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8209);
		/* 82090A60h case   14:*/		return 0x82090A64;
		  /* 82090A64h */ case   15:  		/* stw R9, <#[R30 + 8]> */
		/* 82090A64h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 82090A64h case   15:*/		return 0x82090A68;
		  /* 82090A68h */ case   16:  		/* lis R4, -32247 */
		/* 82090A68h case   16:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8209);
		/* 82090A68h case   16:*/		return 0x82090A6C;
		  /* 82090A6Ch */ case   17:  		/* stw R11, <#[R30 + 12]> */
		/* 82090A6Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82090A6Ch case   17:*/		return 0x82090A70;
		  /* 82090A70h */ case   18:  		/* lis R5, -32247 */
		/* 82090A70h case   18:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8209);
		/* 82090A70h case   18:*/		return 0x82090A74;
		  /* 82090A74h */ case   19:  		/* addi R10, R3, 15680 */
		/* 82090A74h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0x3D40);
		/* 82090A74h case   19:*/		return 0x82090A78;
		  /* 82090A78h */ case   20:  		/* addi R9, R4, 18736 */
		/* 82090A78h case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R4,0x4930);
		/* 82090A78h case   20:*/		return 0x82090A7C;
		  /* 82090A7Ch */ case   21:  		/* addi R11, R5, 18656 */
		/* 82090A7Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0x48E0);
		/* 82090A7Ch case   21:*/		return 0x82090A80;
		  /* 82090A80h */ case   22:  		/* stw R10, <#[R30 + 16]> */
		/* 82090A80h case   22:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 82090A80h case   22:*/		return 0x82090A84;
		  /* 82090A84h */ case   23:  		/* lis R6, -32247 */
		/* 82090A84h case   23:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8209);
		/* 82090A84h case   23:*/		return 0x82090A88;
		  /* 82090A88h */ case   24:  		/* stw R9, <#[R30 + 20]> */
		/* 82090A88h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000014) );
		/* 82090A88h case   24:*/		return 0x82090A8C;
		  /* 82090A8Ch */ case   25:  		/* lis R7, -32247 */
		/* 82090A8Ch case   25:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8209);
		/* 82090A8Ch case   25:*/		return 0x82090A90;
		  /* 82090A90h */ case   26:  		/* stw R11, <#[R30 + 24]> */
		/* 82090A90h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 82090A90h case   26:*/		return 0x82090A94;
		  /* 82090A94h */ case   27:  		/* lis R8, -32247 */
		/* 82090A94h case   27:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8209);
		/* 82090A94h case   27:*/		return 0x82090A98;
		  /* 82090A98h */ case   28:  		/* addi R10, R6, 15712 */
		/* 82090A98h case   28:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0x3D60);
		/* 82090A98h case   28:*/		return 0x82090A9C;
		  /* 82090A9Ch */ case   29:  		/* addi R9, R7, 15504 */
		/* 82090A9Ch case   29:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R7,0x3C90);
		/* 82090A9Ch case   29:*/		return 0x82090AA0;
		  /* 82090AA0h */ case   30:  		/* addi R11, R8, 15344 */
		/* 82090AA0h case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0x3BF0);
		/* 82090AA0h case   30:*/		return 0x82090AA4;
		  /* 82090AA4h */ case   31:  		/* stw R10, <#[R30 + 28]> */
		/* 82090AA4h case   31:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x0000001C) );
		/* 82090AA4h case   31:*/		return 0x82090AA8;
		  /* 82090AA8h */ case   32:  		/* stw R9, <#[R30 + 32]> */
		/* 82090AA8h case   32:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000020) );
		/* 82090AA8h case   32:*/		return 0x82090AAC;
		  /* 82090AACh */ case   33:  		/* stw R11, <#[R30 + 36]> */
		/* 82090AACh case   33:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 82090AACh case   33:*/		return 0x82090AB0;
		  /* 82090AB0h */ case   34:  		/* ld R30, <#[R1 - 16]> */
		/* 82090AB0h case   34:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82090AB0h case   34:*/		return 0x82090AB4;
		  /* 82090AB4h */ case   35:  		/* ld R31, <#[R1 - 8]> */
		/* 82090AB4h case   35:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82090AB4h case   35:*/		return 0x82090AB8;
		  /* 82090AB8h */ case   36:  		/* bclr 20, CR0_LT */
		/* 82090AB8h case   36:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82090AB8h case   36:*/		return 0x82090ABC;
	}
	return 0x82090ABC;
} // Block from 82090A28h-82090ABCh (37 instructions)

//////////////////////////////////////////////////////
// Block at 82090ABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090ABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090ABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090ABC);
		  /* 82090ABCh */ case    0:  		/* nop */
		/* 82090ABCh case    0:*/		cpu::op::nop();
		/* 82090ABCh case    0:*/		return 0x82090AC0;
	}
	return 0x82090AC0;
} // Block from 82090ABCh-82090AC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82090AC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090AC0);
		  /* 82090AC0h */ case    0:  		/* b -152 */
		/* 82090AC0h case    0:*/		return 0x82090A28;
		/* 82090AC0h case    0:*/		return 0x82090AC4;
		  /* 82090AC4h */ case    1:  		/* nop */
		/* 82090AC4h case    1:*/		cpu::op::nop();
		/* 82090AC4h case    1:*/		return 0x82090AC8;
	}
	return 0x82090AC8;
} // Block from 82090AC0h-82090AC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82090AC8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090AC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090AC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090AC8);
		  /* 82090AC8h */ case    0:  		/* stfd FR30, <#[R1 - 16]> */
		/* 82090AC8h case    0:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82090AC8h case    0:*/		return 0x82090ACC;
		  /* 82090ACCh */ case    1:  		/* stfd FR31, <#[R1 - 8]> */
		/* 82090ACCh case    1:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82090ACCh case    1:*/		return 0x82090AD0;
		  /* 82090AD0h */ case    2:  		/* fabs FR0, FR1 */
		/* 82090AD0h case    2:*/		cpu::op::fabs<0>(regs,&regs.FR0,regs.FR1);
		/* 82090AD0h case    2:*/		return 0x82090AD4;
		  /* 82090AD4h */ case    3:  		/* lis R11, -32217 */
		/* 82090AD4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82090AD4h case    3:*/		return 0x82090AD8;
		  /* 82090AD8h */ case    4:  		/* lis R10, -32256 */
		/* 82090AD8h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82090AD8h case    4:*/		return 0x82090ADC;
		  /* 82090ADCh */ case    5:  		/* stfd FR0, <#[R1 - 24]> */
		/* 82090ADCh case    5:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82090ADCh case    5:*/		return 0x82090AE0;
		  /* 82090AE0h */ case    6:  		/* addi R11, R11, 7072 */
		/* 82090AE0h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1BA0);
		/* 82090AE0h case    6:*/		return 0x82090AE4;
		  /* 82090AE4h */ case    7:  		/* lfd FR30, <#[R10 + 1848]> */
		/* 82090AE4h case    7:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R10 + 0x00000738) );
		/* 82090AE4h case    7:*/		return 0x82090AE8;
		  /* 82090AE8h */ case    8:  		/* lfd FR11, <#[R11 + 8]> */
		/* 82090AE8h case    8:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R11 + 0x00000008) );
		/* 82090AE8h case    8:*/		return 0x82090AEC;
		  /* 82090AECh */ case    9:  		/* lfs FR12, <#[R11 + 32]> */
		/* 82090AECh case    9:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000020) );
		/* 82090AECh case    9:*/		return 0x82090AF0;
		  /* 82090AF0h */ case   10:  		/* lfd FR10, <#[R11 + 40]> */
		/* 82090AF0h case   10:*/		cpu::mem::load64f( regs, &regs.FR10, (uint32)(regs.R11 + 0x00000028) );
		/* 82090AF0h case   10:*/		return 0x82090AF4;
		  /* 82090AF4h */ case   11:  		/* fmul FR13, FR11, FR0 */
		/* 82090AF4h case   11:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR11,regs.FR0);
		/* 82090AF4h case   11:*/		return 0x82090AF8;
		  /* 82090AF8h */ case   12:  		/* lfd FR9, <#[R11 + 48]> */
		/* 82090AF8h case   12:*/		cpu::mem::load64f( regs, &regs.FR9, (uint32)(regs.R11 + 0x00000030) );
		/* 82090AF8h case   12:*/		return 0x82090AFC;
		  /* 82090AFCh */ case   13:  		/* lfd FR8, <#[R11 + 112]> */
		/* 82090AFCh case   13:*/		cpu::mem::load64f( regs, &regs.FR8, (uint32)(regs.R11 + 0x00000070) );
		/* 82090AFCh case   13:*/		return 0x82090B00;
		  /* 82090B00h */ case   14:  		/* lfd FR7, <#[R11 + 104]> */
		/* 82090B00h case   14:*/		cpu::mem::load64f( regs, &regs.FR7, (uint32)(regs.R11 + 0x00000068) );
		/* 82090B00h case   14:*/		return 0x82090B04;
		  /* 82090B04h */ case   15:  		/* lfd FR6, <#[R11 + 96]> */
		/* 82090B04h case   15:*/		cpu::mem::load64f( regs, &regs.FR6, (uint32)(regs.R11 + 0x00000060) );
		/* 82090B04h case   15:*/		return 0x82090B08;
		  /* 82090B08h */ case   16:  		/* lfd FR5, <#[R11 + 88]> */
		/* 82090B08h case   16:*/		cpu::mem::load64f( regs, &regs.FR5, (uint32)(regs.R11 + 0x00000058) );
		/* 82090B08h case   16:*/		return 0x82090B0C;
		  /* 82090B0Ch */ case   17:  		/* lfd FR4, <#[R11 + 80]> */
		/* 82090B0Ch case   17:*/		cpu::mem::load64f( regs, &regs.FR4, (uint32)(regs.R11 + 0x00000050) );
		/* 82090B0Ch case   17:*/		return 0x82090B10;
		  /* 82090B10h */ case   18:  		/* lfd FR3, <#[R11 + 72]> */
		/* 82090B10h case   18:*/		cpu::mem::load64f( regs, &regs.FR3, (uint32)(regs.R11 + 0x00000048) );
		/* 82090B10h case   18:*/		return 0x82090B14;
		  /* 82090B14h */ case   19:  		/* lfd FR2, <#[R11 + 64]> */
		/* 82090B14h case   19:*/		cpu::mem::load64f( regs, &regs.FR2, (uint32)(regs.R11 + 0x00000040) );
		/* 82090B14h case   19:*/		return 0x82090B18;
		  /* 82090B18h */ case   20:  		/* lfd FR31, <#[R11 + 56]> */
		/* 82090B18h case   20:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000038) );
		/* 82090B18h case   20:*/		return 0x82090B1C;
		  /* 82090B1Ch */ case   21:  		/* fctid FR11, FR13 */
		/* 82090B1Ch case   21:*/		cpu::op::fctid<0>(regs,&regs.FR11,regs.FR13);
		/* 82090B1Ch case   21:*/		return 0x82090B20;
		  /* 82090B20h */ case   22:  		/* lfs FR13, <#[R11 + 28]> */
		/* 82090B20h case   22:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R11 + 0x0000001C) );
		/* 82090B20h case   22:*/		return 0x82090B24;
		  /* 82090B24h */ case   23:  		/* fsel FR12, FR1, FR13, FR12 */
		/* 82090B24h case   23:*/		cpu::op::fsel<0>(regs,&regs.FR12,regs.FR1,regs.FR13,regs.FR12);
		/* 82090B24h case   23:*/		return 0x82090B28;
		  /* 82090B28h */ case   24:  		/* fcfid FR13, FR11 */
		/* 82090B28h case   24:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR11);
		/* 82090B28h case   24:*/		return 0x82090B2C;
		  /* 82090B2Ch */ case   25:  		/* fnmsub FR11, FR10, FR13, FR0 */
		/* 82090B2Ch case   25:*/		cpu::op::fnmsub<0>(regs,&regs.FR11,regs.FR10,regs.FR13,regs.FR0);
		/* 82090B2Ch case   25:*/		return 0x82090B30;
		  /* 82090B30h */ case   26:  		/* fctidz FR10, FR13 */
		/* 82090B30h case   26:*/		cpu::op::fctidz<0>(regs,&regs.FR10,regs.FR13);
		/* 82090B30h case   26:*/		return 0x82090B34;
		  /* 82090B34h */ case   27:  		/* stfd FR10, <#[R1 - 32]> */
		/* 82090B34h case   27:*/		cpu::mem::store64f( regs, regs.FR10, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 82090B34h case   27:*/		return 0x82090B38;
		  /* 82090B38h */ case   28:  		/* ld R9, <#[R1 - 32]> */
		/* 82090B38h case   28:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 82090B38h case   28:*/		return 0x82090B3C;
		  /* 82090B3Ch */ case   29:  		/* rldicl R8, R9, 0, 63 */
		/* 82090B3Ch case   29:*/		cpu::op::rldicl<0,0,63>(regs,&regs.R8,regs.R9);
		/* 82090B3Ch case   29:*/		return 0x82090B40;
		  /* 82090B40h */ case   30:  		/* fnmsub FR9, FR9, FR13, FR11 */
		/* 82090B40h case   30:*/		cpu::op::fnmsub<0>(regs,&regs.FR9,regs.FR9,regs.FR13,regs.FR11);
		/* 82090B40h case   30:*/		return 0x82090B44;
		  /* 82090B44h */ case   31:  		/* cmpdi CR6, R8, 0 */
		/* 82090B44h case   31:*/		cpu::op::cmpdi<6>(regs,regs.R8,0x00000000);
		/* 82090B44h case   31:*/		return 0x82090B48;
		  /* 82090B48h */ case   32:  		/* fmul FR13, FR9, FR9 */
		/* 82090B48h case   32:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR9,regs.FR9);
		/* 82090B48h case   32:*/		return 0x82090B4C;
		  /* 82090B4Ch */ case   33:  		/* fmadd FR11, FR8, FR13, FR7 */
		/* 82090B4Ch case   33:*/		cpu::op::fmadd<0>(regs,&regs.FR11,regs.FR8,regs.FR13,regs.FR7);
		/* 82090B4Ch case   33:*/		return 0x82090B50;
		  /* 82090B50h */ case   34:  		/* fmadd FR10, FR11, FR13, FR6 */
		/* 82090B50h case   34:*/		cpu::op::fmadd<0>(regs,&regs.FR10,regs.FR11,regs.FR13,regs.FR6);
		/* 82090B50h case   34:*/		return 0x82090B54;
		  /* 82090B54h */ case   35:  		/* fmadd FR8, FR10, FR13, FR5 */
		/* 82090B54h case   35:*/		cpu::op::fmadd<0>(regs,&regs.FR8,regs.FR10,regs.FR13,regs.FR5);
		/* 82090B54h case   35:*/		return 0x82090B58;
		  /* 82090B58h */ case   36:  		/* fmadd FR7, FR8, FR13, FR4 */
		/* 82090B58h case   36:*/		cpu::op::fmadd<0>(regs,&regs.FR7,regs.FR8,regs.FR13,regs.FR4);
		/* 82090B58h case   36:*/		return 0x82090B5C;
		  /* 82090B5Ch */ case   37:  		/* fmadd FR6, FR7, FR13, FR3 */
		/* 82090B5Ch case   37:*/		cpu::op::fmadd<0>(regs,&regs.FR6,regs.FR7,regs.FR13,regs.FR3);
		/* 82090B5Ch case   37:*/		return 0x82090B60;
		  /* 82090B60h */ case   38:  		/* fmadd FR5, FR6, FR13, FR2 */
		/* 82090B60h case   38:*/		cpu::op::fmadd<0>(regs,&regs.FR5,regs.FR6,regs.FR13,regs.FR2);
		/* 82090B60h case   38:*/		return 0x82090B64;
		  /* 82090B64h */ case   39:  		/* fmadd FR4, FR5, FR13, FR31 */
		/* 82090B64h case   39:*/		cpu::op::fmadd<0>(regs,&regs.FR4,regs.FR5,regs.FR13,regs.FR31);
		/* 82090B64h case   39:*/		return 0x82090B68;
		  /* 82090B68h */ case   40:  		/* fmadd FR3, FR4, FR13, FR30 */
		/* 82090B68h case   40:*/		cpu::op::fmadd<0>(regs,&regs.FR3,regs.FR4,regs.FR13,regs.FR30);
		/* 82090B68h case   40:*/		return 0x82090B6C;
		  /* 82090B6Ch */ case   41:  		/* fmul FR13, FR3, FR9 */
		/* 82090B6Ch case   41:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR3,regs.FR9);
		/* 82090B6Ch case   41:*/		return 0x82090B70;
		  /* 82090B70h */ case   42:  		/* bc 12, CR6_EQ, 8 */
		/* 82090B70h case   42:*/		if ( regs.CR[6].eq ) { return 0x82090B78;  }
		/* 82090B70h case   42:*/		return 0x82090B74;
		  /* 82090B74h */ case   43:  		/* fneg FR13, FR13 */
		/* 82090B74h case   43:*/		cpu::op::fneg<0>(regs,&regs.FR13,regs.FR13);
		/* 82090B74h case   43:*/		return 0x82090B78;
	}
	return 0x82090B78;
} // Block from 82090AC8h-82090B78h (44 instructions)

//////////////////////////////////////////////////////
// Block at 82090B78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090B78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090B78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090B78);
		  /* 82090B78h */ case    0:  		/* ld R10, <#[R1 - 24]> */
		/* 82090B78h case    0:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82090B78h case    0:*/		return 0x82090B7C;
		  /* 82090B7Ch */ case    1:  		/* fmul FR12, FR13, FR12 */
		/* 82090B7Ch case    1:*/		cpu::op::fmul<0>(regs,&regs.FR12,regs.FR13,regs.FR12);
		/* 82090B7Ch case    1:*/		return 0x82090B80;
		  /* 82090B80h */ case    2:  		/* cmpdi CR6, R10, 0 */
		/* 82090B80h case    2:*/		cpu::op::cmpdi<6>(regs,regs.R10,0x00000000);
		/* 82090B80h case    2:*/		return 0x82090B84;
		  /* 82090B84h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 82090B84h case    3:*/		if ( regs.CR[6].eq ) { return 0x82090B9C;  }
		/* 82090B84h case    3:*/		return 0x82090B88;
		  /* 82090B88h */ case    4:  		/* lfd FR13, <#[R11 + 16]> */
		/* 82090B88h case    4:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000010) );
		/* 82090B88h case    4:*/		return 0x82090B8C;
		  /* 82090B8Ch */ case    5:  		/* lis R11, -32217 */
		/* 82090B8Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82090B8Ch case    5:*/		return 0x82090B90;
		  /* 82090B90h */ case    6:  		/* fsub FR13, FR0, FR13 */
		/* 82090B90h case    6:*/		cpu::op::fsub<0>(regs,&regs.FR13,regs.FR0,regs.FR13);
		/* 82090B90h case    6:*/		return 0x82090B94;
		  /* 82090B94h */ case    7:  		/* lfd FR0, <#[R11 + 7336]> */
		/* 82090B94h case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001CA8) );
		/* 82090B94h case    7:*/		return 0x82090B98;
		  /* 82090B98h */ case    8:  		/* fsel FR1, FR13, FR0, FR12 */
		/* 82090B98h case    8:*/		cpu::op::fsel<0>(regs,&regs.FR1,regs.FR13,regs.FR0,regs.FR12);
		/* 82090B98h case    8:*/		return 0x82090B9C;
	}
	return 0x82090B9C;
} // Block from 82090B78h-82090B9Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82090B9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090B9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090B9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090B9C);
		  /* 82090B9Ch */ case    0:  		/* lfd FR30, <#[R1 - 16]> */
		/* 82090B9Ch case    0:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82090B9Ch case    0:*/		return 0x82090BA0;
		  /* 82090BA0h */ case    1:  		/* lfd FR31, <#[R1 - 8]> */
		/* 82090BA0h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82090BA0h case    1:*/		return 0x82090BA4;
		  /* 82090BA4h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82090BA4h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82090BA4h case    2:*/		return 0x82090BA8;
	}
	return 0x82090BA8;
} // Block from 82090B9Ch-82090BA8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82090BA8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090BA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090BA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090BA8);
		  /* 82090BA8h */ case    0:  		/* stfd FR31, <#[R1 - 8]> */
		/* 82090BA8h case    0:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82090BA8h case    0:*/		return 0x82090BAC;
		  /* 82090BACh */ case    1:  		/* fabs FR0, FR1 */
		/* 82090BACh case    1:*/		cpu::op::fabs<0>(regs,&regs.FR0,regs.FR1);
		/* 82090BACh case    1:*/		return 0x82090BB0;
		  /* 82090BB0h */ case    2:  		/* lis R11, -32217 */
		/* 82090BB0h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82090BB0h case    2:*/		return 0x82090BB4;
		  /* 82090BB4h */ case    3:  		/* lis R10, -32256 */
		/* 82090BB4h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82090BB4h case    3:*/		return 0x82090BB8;
		  /* 82090BB8h */ case    4:  		/* addi R11, R11, 7072 */
		/* 82090BB8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1BA0);
		/* 82090BB8h case    4:*/		return 0x82090BBC;
		  /* 82090BBCh */ case    5:  		/* lfd FR31, <#[R10 + 1848]> */
		/* 82090BBCh case    5:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R10 + 0x00000738) );
		/* 82090BBCh case    5:*/		return 0x82090BC0;
		  /* 82090BC0h */ case    6:  		/* lfd FR13, <#[R11]> */
		/* 82090BC0h case    6:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000000) );
		/* 82090BC0h case    6:*/		return 0x82090BC4;
		  /* 82090BC4h */ case    7:  		/* lfs FR11, <#[R11 + 36]> */
		/* 82090BC4h case    7:*/		cpu::mem::load32f( regs, &regs.FR11, (uint32)(regs.R11 + 0x00000024) );
		/* 82090BC4h case    7:*/		return 0x82090BC8;
		  /* 82090BC8h */ case    8:  		/* lfd FR10, <#[R11 + 40]> */
		/* 82090BC8h case    8:*/		cpu::mem::load64f( regs, &regs.FR10, (uint32)(regs.R11 + 0x00000028) );
		/* 82090BC8h case    8:*/		return 0x82090BCC;
		  /* 82090BCCh */ case    9:  		/* fadd FR12, FR13, FR0 */
		/* 82090BCCh case    9:*/		cpu::op::fadd<0>(regs,&regs.FR12,regs.FR13,regs.FR0);
		/* 82090BCCh case    9:*/		return 0x82090BD0;
		  /* 82090BD0h */ case   10:  		/* lfd FR13, <#[R11 + 8]> */
		/* 82090BD0h case   10:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000008) );
		/* 82090BD0h case   10:*/		return 0x82090BD4;
		  /* 82090BD4h */ case   11:  		/* lfd FR9, <#[R11 + 48]> */
		/* 82090BD4h case   11:*/		cpu::mem::load64f( regs, &regs.FR9, (uint32)(regs.R11 + 0x00000030) );
		/* 82090BD4h case   11:*/		return 0x82090BD8;
		  /* 82090BD8h */ case   12:  		/* lfd FR8, <#[R11 + 112]> */
		/* 82090BD8h case   12:*/		cpu::mem::load64f( regs, &regs.FR8, (uint32)(regs.R11 + 0x00000070) );
		/* 82090BD8h case   12:*/		return 0x82090BDC;
		  /* 82090BDCh */ case   13:  		/* lfd FR7, <#[R11 + 104]> */
		/* 82090BDCh case   13:*/		cpu::mem::load64f( regs, &regs.FR7, (uint32)(regs.R11 + 0x00000068) );
		/* 82090BDCh case   13:*/		return 0x82090BE0;
		  /* 82090BE0h */ case   14:  		/* lfd FR6, <#[R11 + 96]> */
		/* 82090BE0h case   14:*/		cpu::mem::load64f( regs, &regs.FR6, (uint32)(regs.R11 + 0x00000060) );
		/* 82090BE0h case   14:*/		return 0x82090BE4;
		  /* 82090BE4h */ case   15:  		/* lfd FR5, <#[R11 + 88]> */
		/* 82090BE4h case   15:*/		cpu::mem::load64f( regs, &regs.FR5, (uint32)(regs.R11 + 0x00000058) );
		/* 82090BE4h case   15:*/		return 0x82090BE8;
		  /* 82090BE8h */ case   16:  		/* lfd FR4, <#[R11 + 80]> */
		/* 82090BE8h case   16:*/		cpu::mem::load64f( regs, &regs.FR4, (uint32)(regs.R11 + 0x00000050) );
		/* 82090BE8h case   16:*/		return 0x82090BEC;
		  /* 82090BECh */ case   17:  		/* lfd FR3, <#[R11 + 72]> */
		/* 82090BECh case   17:*/		cpu::mem::load64f( regs, &regs.FR3, (uint32)(regs.R11 + 0x00000048) );
		/* 82090BECh case   17:*/		return 0x82090BF0;
		  /* 82090BF0h */ case   18:  		/* lfd FR2, <#[R11 + 64]> */
		/* 82090BF0h case   18:*/		cpu::mem::load64f( regs, &regs.FR2, (uint32)(regs.R11 + 0x00000040) );
		/* 82090BF0h case   18:*/		return 0x82090BF4;
		  /* 82090BF4h */ case   19:  		/* lfd FR1, <#[R11 + 56]> */
		/* 82090BF4h case   19:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000038) );
		/* 82090BF4h case   19:*/		return 0x82090BF8;
		  /* 82090BF8h */ case   20:  		/* fmul FR13, FR13, FR12 */
		/* 82090BF8h case   20:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR13,regs.FR12);
		/* 82090BF8h case   20:*/		return 0x82090BFC;
		  /* 82090BFCh */ case   21:  		/* fctid FR13, FR13 */
		/* 82090BFCh case   21:*/		cpu::op::fctid<0>(regs,&regs.FR13,regs.FR13);
		/* 82090BFCh case   21:*/		return 0x82090C00;
		  /* 82090C00h */ case   22:  		/* fcfid FR13, FR13 */
		/* 82090C00h case   22:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 82090C00h case   22:*/		return 0x82090C04;
		  /* 82090C04h */ case   23:  		/* fsub FR11, FR13, FR11 */
		/* 82090C04h case   23:*/		cpu::op::fsub<0>(regs,&regs.FR11,regs.FR13,regs.FR11);
		/* 82090C04h case   23:*/		return 0x82090C08;
		  /* 82090C08h */ case   24:  		/* fctidz FR13, FR13 */
		/* 82090C08h case   24:*/		cpu::op::fctidz<0>(regs,&regs.FR13,regs.FR13);
		/* 82090C08h case   24:*/		return 0x82090C0C;
		  /* 82090C0Ch */ case   25:  		/* stfd FR13, <#[R1 - 16]> */
		/* 82090C0Ch case   25:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82090C0Ch case   25:*/		return 0x82090C10;
		  /* 82090C10h */ case   26:  		/* ld R9, <#[R1 - 16]> */
		/* 82090C10h case   26:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82090C10h case   26:*/		return 0x82090C14;
		  /* 82090C14h */ case   27:  		/* rldicl R8, R9, 0, 63 */
		/* 82090C14h case   27:*/		cpu::op::rldicl<0,0,63>(regs,&regs.R8,regs.R9);
		/* 82090C14h case   27:*/		return 0x82090C18;
		  /* 82090C18h */ case   28:  		/* fnmsub FR10, FR10, FR11, FR0 */
		/* 82090C18h case   28:*/		cpu::op::fnmsub<0>(regs,&regs.FR10,regs.FR10,regs.FR11,regs.FR0);
		/* 82090C18h case   28:*/		return 0x82090C1C;
		  /* 82090C1Ch */ case   29:  		/* cmpdi CR6, R8, 0 */
		/* 82090C1Ch case   29:*/		cpu::op::cmpdi<6>(regs,regs.R8,0x00000000);
		/* 82090C1Ch case   29:*/		return 0x82090C20;
		  /* 82090C20h */ case   30:  		/* fnmsub FR9, FR9, FR11, FR10 */
		/* 82090C20h case   30:*/		cpu::op::fnmsub<0>(regs,&regs.FR9,regs.FR9,regs.FR11,regs.FR10);
		/* 82090C20h case   30:*/		return 0x82090C24;
		  /* 82090C24h */ case   31:  		/* fmul FR13, FR9, FR9 */
		/* 82090C24h case   31:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR9,regs.FR9);
		/* 82090C24h case   31:*/		return 0x82090C28;
		  /* 82090C28h */ case   32:  		/* fmadd FR11, FR8, FR13, FR7 */
		/* 82090C28h case   32:*/		cpu::op::fmadd<0>(regs,&regs.FR11,regs.FR8,regs.FR13,regs.FR7);
		/* 82090C28h case   32:*/		return 0x82090C2C;
		  /* 82090C2Ch */ case   33:  		/* fmadd FR10, FR11, FR13, FR6 */
		/* 82090C2Ch case   33:*/		cpu::op::fmadd<0>(regs,&regs.FR10,regs.FR11,regs.FR13,regs.FR6);
		/* 82090C2Ch case   33:*/		return 0x82090C30;
		  /* 82090C30h */ case   34:  		/* fmadd FR8, FR10, FR13, FR5 */
		/* 82090C30h case   34:*/		cpu::op::fmadd<0>(regs,&regs.FR8,regs.FR10,regs.FR13,regs.FR5);
		/* 82090C30h case   34:*/		return 0x82090C34;
		  /* 82090C34h */ case   35:  		/* fmadd FR7, FR8, FR13, FR4 */
		/* 82090C34h case   35:*/		cpu::op::fmadd<0>(regs,&regs.FR7,regs.FR8,regs.FR13,regs.FR4);
		/* 82090C34h case   35:*/		return 0x82090C38;
		  /* 82090C38h */ case   36:  		/* fmadd FR6, FR7, FR13, FR3 */
		/* 82090C38h case   36:*/		cpu::op::fmadd<0>(regs,&regs.FR6,regs.FR7,regs.FR13,regs.FR3);
		/* 82090C38h case   36:*/		return 0x82090C3C;
		  /* 82090C3Ch */ case   37:  		/* fmadd FR5, FR6, FR13, FR2 */
		/* 82090C3Ch case   37:*/		cpu::op::fmadd<0>(regs,&regs.FR5,regs.FR6,regs.FR13,regs.FR2);
		/* 82090C3Ch case   37:*/		return 0x82090C40;
		  /* 82090C40h */ case   38:  		/* fmadd FR4, FR5, FR13, FR1 */
		/* 82090C40h case   38:*/		cpu::op::fmadd<0>(regs,&regs.FR4,regs.FR5,regs.FR13,regs.FR1);
		/* 82090C40h case   38:*/		return 0x82090C44;
		  /* 82090C44h */ case   39:  		/* fmadd FR3, FR4, FR13, FR31 */
		/* 82090C44h case   39:*/		cpu::op::fmadd<0>(regs,&regs.FR3,regs.FR4,regs.FR13,regs.FR31);
		/* 82090C44h case   39:*/		return 0x82090C48;
		  /* 82090C48h */ case   40:  		/* fmul FR13, FR3, FR9 */
		/* 82090C48h case   40:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR3,regs.FR9);
		/* 82090C48h case   40:*/		return 0x82090C4C;
		  /* 82090C4Ch */ case   41:  		/* bc 12, CR6_EQ, 8 */
		/* 82090C4Ch case   41:*/		if ( regs.CR[6].eq ) { return 0x82090C54;  }
		/* 82090C4Ch case   41:*/		return 0x82090C50;
		  /* 82090C50h */ case   42:  		/* fneg FR13, FR13 */
		/* 82090C50h case   42:*/		cpu::op::fneg<0>(regs,&regs.FR13,regs.FR13);
		/* 82090C50h case   42:*/		return 0x82090C54;
	}
	return 0x82090C54;
} // Block from 82090BA8h-82090C54h (43 instructions)

//////////////////////////////////////////////////////
// Block at 82090C54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090C54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090C54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090C54);
		  /* 82090C54h */ case    0:  		/* lfs FR11, <#[R11 + 24]> */
		/* 82090C54h case    0:*/		cpu::mem::load32f( regs, &regs.FR11, (uint32)(regs.R11 + 0x00000018) );
		/* 82090C54h case    0:*/		return 0x82090C58;
		  /* 82090C58h */ case    1:  		/* fcmpu CR6, FR0, FR11 */
		/* 82090C58h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR11);
		/* 82090C58h case    1:*/		return 0x82090C5C;
		  /* 82090C5Ch */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 82090C5Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82090C6C;  }
		/* 82090C5Ch case    2:*/		return 0x82090C60;
		  /* 82090C60h */ case    3:  		/* lfs FR1, <#[R11 + 28]> */
		/* 82090C60h case    3:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R11 + 0x0000001C) );
		/* 82090C60h case    3:*/		return 0x82090C64;
		  /* 82090C64h */ case    4:  		/* lfd FR31, <#[R1 - 8]> */
		/* 82090C64h case    4:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82090C64h case    4:*/		return 0x82090C68;
		  /* 82090C68h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82090C68h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82090C68h case    5:*/		return 0x82090C6C;
	}
	return 0x82090C6C;
} // Block from 82090C54h-82090C6Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82090C6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090C6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090C6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090C6C);
		  /* 82090C6Ch */ case    0:  		/* lfd FR0, <#[R11 + 16]> */
		/* 82090C6Ch case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000010) );
		/* 82090C6Ch case    0:*/		return 0x82090C70;
		  /* 82090C70h */ case    1:  		/* lis R11, -32217 */
		/* 82090C70h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82090C70h case    1:*/		return 0x82090C74;
		  /* 82090C74h */ case    2:  		/* fsub FR12, FR12, FR0 */
		/* 82090C74h case    2:*/		cpu::op::fsub<0>(regs,&regs.FR12,regs.FR12,regs.FR0);
		/* 82090C74h case    2:*/		return 0x82090C78;
		  /* 82090C78h */ case    3:  		/* lfd FR0, <#[R11 + 7336]> */
		/* 82090C78h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001CA8) );
		/* 82090C78h case    3:*/		return 0x82090C7C;
		  /* 82090C7Ch */ case    4:  		/* fsel FR1, FR12, FR0, FR13 */
		/* 82090C7Ch case    4:*/		cpu::op::fsel<0>(regs,&regs.FR1,regs.FR12,regs.FR0,regs.FR13);
		/* 82090C7Ch case    4:*/		return 0x82090C80;
		  /* 82090C80h */ case    5:  		/* lfd FR31, <#[R1 - 8]> */
		/* 82090C80h case    5:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82090C80h case    5:*/		return 0x82090C84;
		  /* 82090C84h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82090C84h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82090C84h case    6:*/		return 0x82090C88;
	}
	return 0x82090C88;
} // Block from 82090C6Ch-82090C88h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82090C88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090C88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090C88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090C88);
		  /* 82090C88h */ case    0:  		/* mfspr R12, LR */
		/* 82090C88h case    0:*/		regs.R12 = regs.LR;
		/* 82090C88h case    0:*/		return 0x82090C8C;
		  /* 82090C8Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82090C8Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82090C8Ch case    1:*/		return 0x82090C90;
		  /* 82090C90h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82090C90h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82090C90h case    2:*/		return 0x82090C94;
		  /* 82090C94h */ case    3:  		/* lis R11, -32215 */
		/* 82090C94h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82090C94h case    3:*/		return 0x82090C98;
		  /* 82090C98h */ case    4:  		/* lwz R11, <#[R11 - 30688]> */
		/* 82090C98h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFF8820) );
		/* 82090C98h case    4:*/		return 0x82090C9C;
		  /* 82090C9Ch */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 82090C9Ch case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82090C9Ch case    5:*/		return 0x82090CA0;
		  /* 82090CA0h */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 82090CA0h case    6:*/		if ( regs.CR[0].eq ) { return 0x82090CAC;  }
		/* 82090CA0h case    6:*/		return 0x82090CA4;
		  /* 82090CA4h */ case    7:  		/* mtspr CTR, R11 */
		/* 82090CA4h case    7:*/		regs.CTR = regs.R11;
		/* 82090CA4h case    7:*/		return 0x82090CA8;
		  /* 82090CA8h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 82090CA8h case    8:*/		if ( 1 ) { regs.LR = 0x82090CAC; return (uint32)regs.CTR; }
		/* 82090CA8h case    8:*/		return 0x82090CAC;
	}
	return 0x82090CAC;
} // Block from 82090C88h-82090CACh (9 instructions)

//////////////////////////////////////////////////////
// Block at 82090CACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090CAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090CAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090CAC);
		  /* 82090CACh */ case    0:  		/* li R3, 25 */
		/* 82090CACh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x19);
		/* 82090CACh case    0:*/		return 0x82090CB0;
		  /* 82090CB0h */ case    1:  		/* bl 16264 */
		/* 82090CB0h case    1:*/		regs.LR = 0x82090CB4; return 0x82094C38;
		/* 82090CB0h case    1:*/		return 0x82090CB4;
		  /* 82090CB4h */ case    2:  		/* li R4, 1 */
		/* 82090CB4h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82090CB4h case    2:*/		return 0x82090CB8;
		  /* 82090CB8h */ case    3:  		/* li R3, 0 */
		/* 82090CB8h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82090CB8h case    3:*/		return 0x82090CBC;
		  /* 82090CBCh */ case    4:  		/* bl 16148 */
		/* 82090CBCh case    4:*/		regs.LR = 0x82090CC0; return 0x82094BD0;
		/* 82090CBCh case    4:*/		return 0x82090CC0;
		  /* 82090CC0h */ case    5:  		/* bl 16064 */
		/* 82090CC0h case    5:*/		regs.LR = 0x82090CC4; return 0x82094B80;
		/* 82090CC0h case    5:*/		return 0x82090CC4;
		  /* 82090CC4h */ case    6:  		/* addi R1, R1, 96 */
		/* 82090CC4h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82090CC4h case    6:*/		return 0x82090CC8;
		  /* 82090CC8h */ case    7:  		/* lwz R12, <#[R1 - 8]> */
		/* 82090CC8h case    7:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82090CC8h case    7:*/		return 0x82090CCC;
		  /* 82090CCCh */ case    8:  		/* mtspr LR, R12 */
		/* 82090CCCh case    8:*/		regs.LR = regs.R12;
		/* 82090CCCh case    8:*/		return 0x82090CD0;
		  /* 82090CD0h */ case    9:  		/* bclr 20, CR0_LT */
		/* 82090CD0h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82090CD0h case    9:*/		return 0x82090CD4;
	}
	return 0x82090CD4;
} // Block from 82090CACh-82090CD4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82090CD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090CD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090CD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090CD4);
		  /* 82090CD4h */ case    0:  		/* nop */
		/* 82090CD4h case    0:*/		cpu::op::nop();
		/* 82090CD4h case    0:*/		return 0x82090CD8;
	}
	return 0x82090CD8;
} // Block from 82090CD4h-82090CD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82090CD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090CD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090CD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090CD8);
		  /* 82090CD8h */ case    0:  		/* mfspr R12, LR */
		/* 82090CD8h case    0:*/		regs.R12 = regs.LR;
		/* 82090CD8h case    0:*/		return 0x82090CDC;
		  /* 82090CDCh */ case    1:  		/* bl 1392 */
		/* 82090CDCh case    1:*/		regs.LR = 0x82090CE0; return 0x8209124C;
		/* 82090CDCh case    1:*/		return 0x82090CE0;
		  /* 82090CE0h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 82090CE0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82090CE0h case    2:*/		return 0x82090CE4;
		  /* 82090CE4h */ case    3:  		/* mr R29, R3 */
		/* 82090CE4h case    3:*/		regs.R29 = regs.R3;
		/* 82090CE4h case    3:*/		return 0x82090CE8;
		  /* 82090CE8h */ case    4:  		/* mr R30, R4 */
		/* 82090CE8h case    4:*/		regs.R30 = regs.R4;
		/* 82090CE8h case    4:*/		return 0x82090CEC;
		  /* 82090CECh */ case    5:  		/* mr R26, R5 */
		/* 82090CECh case    5:*/		regs.R26 = regs.R5;
		/* 82090CECh case    5:*/		return 0x82090CF0;
		  /* 82090CF0h */ case    6:  		/* li R25, 0 */
		/* 82090CF0h case    6:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82090CF0h case    6:*/		return 0x82090CF4;
		  /* 82090CF4h */ case    7:  		/* li R5, 28 */
		/* 82090CF4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x1C);
		/* 82090CF4h case    7:*/		return 0x82090CF8;
		  /* 82090CF8h */ case    8:  		/* li R4, 0 */
		/* 82090CF8h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82090CF8h case    8:*/		return 0x82090CFC;
		  /* 82090CFCh */ case    9:  		/* stw R25, <#[R1 + 80]> */
		/* 82090CFCh case    9:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000050) );
		/* 82090CFCh case    9:*/		return 0x82090D00;
		  /* 82090D00h */ case   10:  		/* addi R3, R1, 84 */
		/* 82090D00h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x54);
		/* 82090D00h case   10:*/		return 0x82090D04;
		  /* 82090D04h */ case   11:  		/* mr R31, R6 */
		/* 82090D04h case   11:*/		regs.R31 = regs.R6;
		/* 82090D04h case   11:*/		return 0x82090D08;
		  /* 82090D08h */ case   12:  		/* mr R28, R7 */
		/* 82090D08h case   12:*/		regs.R28 = regs.R7;
		/* 82090D08h case   12:*/		return 0x82090D0C;
		  /* 82090D0Ch */ case   13:  		/* mr R27, R8 */
		/* 82090D0Ch case   13:*/		regs.R27 = regs.R8;
		/* 82090D0Ch case   13:*/		return 0x82090D10;
	}
	return 0x82090D10;
} // Block from 82090CD8h-82090D10h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82090D10h
// Function 'RtlFreeHeap'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090D10);
		  /* 82090D10h */ case    0:  		/* bl 1584 */
		/* 82090D10h case    0:*/		regs.LR = 0x82090D14; return 0x82091340;
		/* 82090D10h case    0:*/		return 0x82090D14;
		  /* 82090D14h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 82090D14h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82090D14h case    1:*/		return 0x82090D18;
		  /* 82090D18h */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 82090D18h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82090D34;  }
		/* 82090D18h case    2:*/		return 0x82090D1C;
		  /* 82090D1Ch */ case    3:  		/* bl 16876 */
		/* 82090D1Ch case    3:*/		regs.LR = 0x82090D20; return 0x82094F08;
		/* 82090D1Ch case    3:*/		return 0x82090D20;
		  /* 82090D20h */ case    4:  		/* li R11, 22 */
		/* 82090D20h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 82090D20h case    4:*/		return 0x82090D24;
		  /* 82090D24h */ case    5:  		/* stw R11, <#[R3]> */
		/* 82090D24h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82090D24h case    5:*/		return 0x82090D28;
		  /* 82090D28h */ case    6:  		/* bl 11320 */
		/* 82090D28h case    6:*/		regs.LR = 0x82090D2C; return 0x82093960;
		/* 82090D28h case    6:*/		return 0x82090D2C;
		  /* 82090D2Ch */ case    7:  		/* li R3, -1 */
		/* 82090D2Ch case    7:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82090D2Ch case    7:*/		return 0x82090D30;
		  /* 82090D30h */ case    8:  		/* b 268 */
		/* 82090D30h case    8:*/		return 0x82090E3C;
		/* 82090D30h case    8:*/		return 0x82090D34;
	}
	return 0x82090D34;
} // Block from 82090D10h-82090D34h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82090D34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090D34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090D34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090D34);
		  /* 82090D34h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 82090D34h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82090D34h case    0:*/		return 0x82090D38;
		  /* 82090D38h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82090D38h case    1:*/		if ( regs.CR[6].eq ) { return 0x82090D44;  }
		/* 82090D38h case    1:*/		return 0x82090D3C;
		  /* 82090D3Ch */ case    2:  		/* cmplwi CR6, R30, 0 */
		/* 82090D3Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82090D3Ch case    2:*/		return 0x82090D40;
		  /* 82090D40h */ case    3:  		/* bc 12, CR6_EQ, -36 */
		/* 82090D40h case    3:*/		if ( regs.CR[6].eq ) { return 0x82090D1C;  }
		/* 82090D40h case    3:*/		return 0x82090D44;
	}
	return 0x82090D44;
} // Block from 82090D34h-82090D44h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82090D44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090D44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090D44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090D44);
		  /* 82090D44h */ case    0:  		/* lis R11, 16383 */
		/* 82090D44h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x3FFF);
		/* 82090D44h case    0:*/		return 0x82090D48;
		  /* 82090D48h */ case    1:  		/* stw R30, <#[R1 + 88]> */
		/* 82090D48h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000058) );
		/* 82090D48h case    1:*/		return 0x82090D4C;
		  /* 82090D4Ch */ case    2:  		/* li R10, 66 */
		/* 82090D4Ch case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x42);
		/* 82090D4Ch case    2:*/		return 0x82090D50;
		  /* 82090D50h */ case    3:  		/* stw R30, <#[R1 + 80]> */
		/* 82090D50h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 82090D50h case    3:*/		return 0x82090D54;
		  /* 82090D54h */ case    4:  		/* ori R11, R11, 65535 */
		/* 82090D54h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFFF);
		/* 82090D54h case    4:*/		return 0x82090D58;
		  /* 82090D58h */ case    5:  		/* stw R10, <#[R1 + 92]> */
		/* 82090D58h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 82090D58h case    5:*/		return 0x82090D5C;
		  /* 82090D5Ch */ case    6:  		/* cmplw CR6, R26, R11 */
		/* 82090D5Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 82090D5Ch case    6:*/		return 0x82090D60;
		  /* 82090D60h */ case    7:  		/* bc 4, CR6_GT, 16 */
		/* 82090D60h case    7:*/		if ( !regs.CR[6].gt ) { return 0x82090D70;  }
		/* 82090D60h case    7:*/		return 0x82090D64;
		  /* 82090D64h */ case    8:  		/* lis R11, 32767 */
		/* 82090D64h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FFF);
		/* 82090D64h case    8:*/		return 0x82090D68;
		  /* 82090D68h */ case    9:  		/* ori R11, R11, 65535 */
		/* 82090D68h case    9:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFFF);
		/* 82090D68h case    9:*/		return 0x82090D6C;
		  /* 82090D6Ch */ case   10:  		/* b 8 */
		/* 82090D6Ch case   10:*/		return 0x82090D74;
		/* 82090D6Ch case   10:*/		return 0x82090D70;
	}
	return 0x82090D70;
} // Block from 82090D44h-82090D70h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82090D70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090D70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090D70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090D70);
		  /* 82090D70h */ case    0:  		/* rlwinm R11, R26, 1, 0, 30 */
		/* 82090D70h case    0:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R26);
		/* 82090D70h case    0:*/		return 0x82090D74;
	}
	return 0x82090D74;
} // Block from 82090D70h-82090D74h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82090D74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090D74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090D74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090D74);
		  /* 82090D74h */ case    0:  		/* stw R11, <#[R1 + 84]> */
		/* 82090D74h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82090D74h case    0:*/		return 0x82090D78;
		  /* 82090D78h */ case    1:  		/* mr R6, R27 */
		/* 82090D78h case    1:*/		regs.R6 = regs.R27;
		/* 82090D78h case    1:*/		return 0x82090D7C;
		  /* 82090D7Ch */ case    2:  		/* mr R5, R28 */
		/* 82090D7Ch case    2:*/		regs.R5 = regs.R28;
		/* 82090D7Ch case    2:*/		return 0x82090D80;
		  /* 82090D80h */ case    3:  		/* mtspr CTR, R29 */
		/* 82090D80h case    3:*/		regs.CTR = regs.R29;
		/* 82090D80h case    3:*/		return 0x82090D84;
		  /* 82090D84h */ case    4:  		/* mr R4, R31 */
		/* 82090D84h case    4:*/		regs.R4 = regs.R31;
		/* 82090D84h case    4:*/		return 0x82090D88;
		  /* 82090D88h */ case    5:  		/* addi R3, R1, 80 */
		/* 82090D88h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82090D88h case    5:*/		return 0x82090D8C;
		  /* 82090D8Ch */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 82090D8Ch case    6:*/		if ( 1 ) { regs.LR = 0x82090D90; return (uint32)regs.CTR; }
		/* 82090D8Ch case    6:*/		return 0x82090D90;
		  /* 82090D90h */ case    7:  		/* mr R31, R3 */
		/* 82090D90h case    7:*/		regs.R31 = regs.R3;
		/* 82090D90h case    7:*/		return 0x82090D94;
		  /* 82090D94h */ case    8:  		/* cmplwi CR6, R30, 0 */
		/* 82090D94h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82090D94h case    8:*/		return 0x82090D98;
		  /* 82090D98h */ case    9:  		/* bc 4, CR6_EQ, 12 */
		/* 82090D98h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82090DA4;  }
		/* 82090D98h case    9:*/		return 0x82090D9C;
		  /* 82090D9Ch */ case   10:  		/* mr R3, R31 */
		/* 82090D9Ch case   10:*/		regs.R3 = regs.R31;
		/* 82090D9Ch case   10:*/		return 0x82090DA0;
		  /* 82090DA0h */ case   11:  		/* b 156 */
		/* 82090DA0h case   11:*/		return 0x82090E3C;
		/* 82090DA0h case   11:*/		return 0x82090DA4;
	}
	return 0x82090DA4;
} // Block from 82090D74h-82090DA4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82090DA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090DA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090DA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090DA4);
		  /* 82090DA4h */ case    0:  		/* cmpwi CR6, R31, 0 */
		/* 82090DA4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82090DA4h case    0:*/		return 0x82090DA8;
		  /* 82090DA8h */ case    1:  		/* bc 12, CR6_LT, 112 */
		/* 82090DA8h case    1:*/		if ( regs.CR[6].lt ) { return 0x82090E18;  }
		/* 82090DA8h case    1:*/		return 0x82090DAC;
		  /* 82090DACh */ case    2:  		/* lwz R11, <#[R1 + 84]> */
		/* 82090DACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82090DACh case    2:*/		return 0x82090DB0;
		  /* 82090DB0h */ case    3:  		/* addic. R11, R11, -1 */
		/* 82090DB0h case    3:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82090DB0h case    3:*/		return 0x82090DB4;
		  /* 82090DB4h */ case    4:  		/* stw R11, <#[R1 + 84]> */
		/* 82090DB4h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82090DB4h case    4:*/		return 0x82090DB8;
		  /* 82090DB8h */ case    5:  		/* bc 12, CR0_LT, 28 */
		/* 82090DB8h case    5:*/		if ( regs.CR[0].lt ) { return 0x82090DD4;  }
		/* 82090DB8h case    5:*/		return 0x82090DBC;
		  /* 82090DBCh */ case    6:  		/* lwz R11, <#[R1 + 80]> */
		/* 82090DBCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82090DBCh case    6:*/		return 0x82090DC0;
		  /* 82090DC0h */ case    7:  		/* stb R25, <#[R11]> */
		/* 82090DC0h case    7:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R11 + 0x00000000) );
		/* 82090DC0h case    7:*/		return 0x82090DC4;
		  /* 82090DC4h */ case    8:  		/* lwz R11, <#[R1 + 80]> */
		/* 82090DC4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82090DC4h case    8:*/		return 0x82090DC8;
		  /* 82090DC8h */ case    9:  		/* addi R11, R11, 1 */
		/* 82090DC8h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82090DC8h case    9:*/		return 0x82090DCC;
		  /* 82090DCCh */ case   10:  		/* stw R11, <#[R1 + 80]> */
		/* 82090DCCh case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82090DCCh case   10:*/		return 0x82090DD0;
		  /* 82090DD0h */ case   11:  		/* b 28 */
		/* 82090DD0h case   11:*/		return 0x82090DEC;
		/* 82090DD0h case   11:*/		return 0x82090DD4;
	}
	return 0x82090DD4;
} // Block from 82090DA4h-82090DD4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82090DD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090DD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090DD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090DD4);
		  /* 82090DD4h */ case    0:  		/* addi R4, R1, 80 */
		/* 82090DD4h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82090DD4h case    0:*/		return 0x82090DD8;
		  /* 82090DD8h */ case    1:  		/* li R3, 0 */
		/* 82090DD8h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82090DD8h case    1:*/		return 0x82090DDC;
		  /* 82090DDCh */ case    2:  		/* bl 16100 */
		/* 82090DDCh case    2:*/		regs.LR = 0x82090DE0; return 0x82094CC0;
		/* 82090DDCh case    2:*/		return 0x82090DE0;
		  /* 82090DE0h */ case    3:  		/* cmpwi CR6, R3, -1 */
		/* 82090DE0h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82090DE0h case    3:*/		return 0x82090DE4;
		  /* 82090DE4h */ case    4:  		/* bc 12, CR6_EQ, 52 */
		/* 82090DE4h case    4:*/		if ( regs.CR[6].eq ) { return 0x82090E18;  }
		/* 82090DE4h case    4:*/		return 0x82090DE8;
		  /* 82090DE8h */ case    5:  		/* lwz R11, <#[R1 + 80]> */
		/* 82090DE8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82090DE8h case    5:*/		return 0x82090DEC;
	}
	return 0x82090DEC;
} // Block from 82090DD4h-82090DECh (6 instructions)

//////////////////////////////////////////////////////
// Block at 82090DECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090DEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090DEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090DEC);
		  /* 82090DECh */ case    0:  		/* lwz R10, <#[R1 + 84]> */
		/* 82090DECh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82090DECh case    0:*/		return 0x82090DF0;
		  /* 82090DF0h */ case    1:  		/* addic. R10, R10, -1 */
		/* 82090DF0h case    1:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82090DF0h case    1:*/		return 0x82090DF4;
		  /* 82090DF4h */ case    2:  		/* stw R10, <#[R1 + 84]> */
		/* 82090DF4h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82090DF4h case    2:*/		return 0x82090DF8;
		  /* 82090DF8h */ case    3:  		/* bc 12, CR0_LT, 12 */
		/* 82090DF8h case    3:*/		if ( regs.CR[0].lt ) { return 0x82090E04;  }
		/* 82090DF8h case    3:*/		return 0x82090DFC;
		  /* 82090DFCh */ case    4:  		/* stb R25, <#[R11]> */
		/* 82090DFCh case    4:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R11 + 0x00000000) );
		/* 82090DFCh case    4:*/		return 0x82090E00;
		  /* 82090E00h */ case    5:  		/* b -100 */
		/* 82090E00h case    5:*/		return 0x82090D9C;
		/* 82090E00h case    5:*/		return 0x82090E04;
	}
	return 0x82090E04;
} // Block from 82090DECh-82090E04h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82090E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090E04);
		  /* 82090E04h */ case    0:  		/* addi R4, R1, 80 */
		/* 82090E04h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82090E04h case    0:*/		return 0x82090E08;
		  /* 82090E08h */ case    1:  		/* li R3, 0 */
		/* 82090E08h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82090E08h case    1:*/		return 0x82090E0C;
		  /* 82090E0Ch */ case    2:  		/* bl 16052 */
		/* 82090E0Ch case    2:*/		regs.LR = 0x82090E10; return 0x82094CC0;
		/* 82090E0Ch case    2:*/		return 0x82090E10;
		  /* 82090E10h */ case    3:  		/* cmpwi CR6, R3, -1 */
		/* 82090E10h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82090E10h case    3:*/		return 0x82090E14;
		  /* 82090E14h */ case    4:  		/* bc 4, CR6_EQ, -120 */
		/* 82090E14h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82090D9C;  }
		/* 82090E14h case    4:*/		return 0x82090E18;
	}
	return 0x82090E18;
} // Block from 82090E04h-82090E18h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82090E18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090E18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090E18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090E18);
		  /* 82090E18h */ case    0:  		/* lwz R10, <#[R1 + 84]> */
		/* 82090E18h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82090E18h case    0:*/		return 0x82090E1C;
		  /* 82090E1Ch */ case    1:  		/* rlwinm R11, R26, 1, 0, 30 */
		/* 82090E1Ch case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R26);
		/* 82090E1Ch case    1:*/		return 0x82090E20;
		  /* 82090E20h */ case    2:  		/* cntlzw R10, R10 */
		/* 82090E20h case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 82090E20h case    2:*/		return 0x82090E24;
		  /* 82090E24h */ case    3:  		/* add R9, R11, R30 */
		/* 82090E24h case    3:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R30);
		/* 82090E24h case    3:*/		return 0x82090E28;
		  /* 82090E28h */ case    4:  		/* cntlzw R11, R10 */
		/* 82090E28h case    4:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R10);
		/* 82090E28h case    4:*/		return 0x82090E2C;
		  /* 82090E2Ch */ case    5:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 82090E2Ch case    5:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82090E2Ch case    5:*/		return 0x82090E30;
		  /* 82090E30h */ case    6:  		/* xori R11, R11, 1 */
		/* 82090E30h case    6:*/		cpu::op::xori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82090E30h case    6:*/		return 0x82090E34;
		  /* 82090E34h */ case    7:  		/* sth R25, <#[R9 - 2]> */
		/* 82090E34h case    7:*/		cpu::mem::store16( regs, regs.R25, (uint32)(regs.R9 + 0xFFFFFFFE) );
		/* 82090E34h case    7:*/		return 0x82090E38;
		  /* 82090E38h */ case    8:  		/* addi R3, R11, -2 */
		/* 82090E38h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFFE);
		/* 82090E38h case    8:*/		return 0x82090E3C;
	}
	return 0x82090E3C;
} // Block from 82090E18h-82090E3Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82090E3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090E3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090E3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090E3C);
		  /* 82090E3Ch */ case    0:  		/* addi R1, R1, 176 */
		/* 82090E3Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82090E3Ch case    0:*/		return 0x82090E40;
		  /* 82090E40h */ case    1:  		/* b 1116 */
		/* 82090E40h case    1:*/		return 0x8209129C;
		/* 82090E40h case    1:*/		return 0x82090E44;
		  /* 82090E44h */ case    2:  		/* nop */
		/* 82090E44h case    2:*/		cpu::op::nop();
		/* 82090E44h case    2:*/		return 0x82090E48;
	}
	return 0x82090E48;
} // Block from 82090E3Ch-82090E48h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82090E48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090E48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090E48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090E48);
		  /* 82090E48h */ case    0:  		/* mfspr R12, LR */
		/* 82090E48h case    0:*/		regs.R12 = regs.LR;
		/* 82090E48h case    0:*/		return 0x82090E4C;
		  /* 82090E4Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82090E4Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82090E4Ch case    1:*/		return 0x82090E50;
		  /* 82090E50h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82090E50h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82090E50h case    2:*/		return 0x82090E54;
		  /* 82090E54h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82090E54h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82090E54h case    3:*/		return 0x82090E58;
		  /* 82090E58h */ case    4:  		/* mr R31, R3 */
		/* 82090E58h case    4:*/		regs.R31 = regs.R3;
		/* 82090E58h case    4:*/		return 0x82090E5C;
		  /* 82090E5Ch */ case    5:  		/* mr R8, R7 */
		/* 82090E5Ch case    5:*/		regs.R8 = regs.R7;
		/* 82090E5Ch case    5:*/		return 0x82090E60;
		  /* 82090E60h */ case    6:  		/* cmplwi CR6, R5, 0 */
		/* 82090E60h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82090E60h case    6:*/		return 0x82090E64;
		  /* 82090E64h */ case    7:  		/* bc 4, CR6_EQ, 16 */
		/* 82090E64h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82090E74;  }
		/* 82090E64h case    7:*/		return 0x82090E68;
		  /* 82090E68h */ case    8:  		/* bl 16544 */
		/* 82090E68h case    8:*/		regs.LR = 0x82090E6C; return 0x82094F08;
		/* 82090E68h case    8:*/		return 0x82090E6C;
		  /* 82090E6Ch */ case    9:  		/* li R11, 22 */
		/* 82090E6Ch case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 82090E6Ch case    9:*/		return 0x82090E70;
		  /* 82090E70h */ case   10:  		/* b 80 */
		/* 82090E70h case   10:*/		return 0x82090EC0;
		/* 82090E70h case   10:*/		return 0x82090E74;
	}
	return 0x82090E74;
} // Block from 82090E48h-82090E74h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82090E74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090E74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090E74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090E74);
		  /* 82090E74h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82090E74h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82090E74h case    0:*/		return 0x82090E78;
		  /* 82090E78h */ case    1:  		/* bc 12, CR6_EQ, -16 */
		/* 82090E78h case    1:*/		if ( regs.CR[6].eq ) { return 0x82090E68;  }
		/* 82090E78h case    1:*/		return 0x82090E7C;
		  /* 82090E7Ch */ case    2:  		/* cmplwi CR6, R4, 0 */
		/* 82090E7Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82090E7Ch case    2:*/		return 0x82090E80;
		  /* 82090E80h */ case    3:  		/* bc 12, CR6_EQ, -24 */
		/* 82090E80h case    3:*/		if ( regs.CR[6].eq ) { return 0x82090E68;  }
		/* 82090E80h case    3:*/		return 0x82090E84;
		  /* 82090E84h */ case    4:  		/* mr R7, R6 */
		/* 82090E84h case    4:*/		regs.R7 = regs.R6;
		/* 82090E84h case    4:*/		return 0x82090E88;
		  /* 82090E88h */ case    5:  		/* lis R11, -32247 */
		/* 82090E88h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8209);
		/* 82090E88h case    5:*/		return 0x82090E8C;
		  /* 82090E8Ch */ case    6:  		/* mr R6, R5 */
		/* 82090E8Ch case    6:*/		regs.R6 = regs.R5;
		/* 82090E8Ch case    6:*/		return 0x82090E90;
		  /* 82090E90h */ case    7:  		/* mr R5, R4 */
		/* 82090E90h case    7:*/		regs.R5 = regs.R4;
		/* 82090E90h case    7:*/		return 0x82090E94;
		  /* 82090E94h */ case    8:  		/* mr R4, R31 */
		/* 82090E94h case    8:*/		regs.R4 = regs.R31;
		/* 82090E94h case    8:*/		return 0x82090E98;
		  /* 82090E98h */ case    9:  		/* addi R3, R11, 23424 */
		/* 82090E98h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x5B80);
		/* 82090E98h case    9:*/		return 0x82090E9C;
		  /* 82090E9Ch */ case   10:  		/* bl -452 */
		/* 82090E9Ch case   10:*/		regs.LR = 0x82090EA0; return 0x82090CD8;
		/* 82090E9Ch case   10:*/		return 0x82090EA0;
		  /* 82090EA0h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 82090EA0h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82090EA0h case   11:*/		return 0x82090EA4;
		  /* 82090EA4h */ case   12:  		/* bc 4, CR0_LT, 12 */
		/* 82090EA4h case   12:*/		if ( !regs.CR[0].lt ) { return 0x82090EB0;  }
		/* 82090EA4h case   12:*/		return 0x82090EA8;
		  /* 82090EA8h */ case   13:  		/* li R11, 0 */
		/* 82090EA8h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82090EA8h case   13:*/		return 0x82090EAC;
		  /* 82090EACh */ case   14:  		/* sth R11, <#[R31]> */
		/* 82090EACh case   14:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82090EACh case   14:*/		return 0x82090EB0;
	}
	return 0x82090EB0;
} // Block from 82090E74h-82090EB0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82090EB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090EB0);
		  /* 82090EB0h */ case    0:  		/* cmpwi CR6, R3, -2 */
		/* 82090EB0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFE);
		/* 82090EB0h case    0:*/		return 0x82090EB4;
		  /* 82090EB4h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 82090EB4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82090ECC;  }
		/* 82090EB4h case    1:*/		return 0x82090EB8;
		  /* 82090EB8h */ case    2:  		/* bl 16464 */
		/* 82090EB8h case    2:*/		regs.LR = 0x82090EBC; return 0x82094F08;
		/* 82090EB8h case    2:*/		return 0x82090EBC;
		  /* 82090EBCh */ case    3:  		/* li R11, 34 */
		/* 82090EBCh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x22);
		/* 82090EBCh case    3:*/		return 0x82090EC0;
	}
	return 0x82090EC0;
} // Block from 82090EB0h-82090EC0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82090EC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090EC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090EC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090EC0);
		  /* 82090EC0h */ case    0:  		/* stw R11, <#[R3]> */
		/* 82090EC0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82090EC0h case    0:*/		return 0x82090EC4;
		  /* 82090EC4h */ case    1:  		/* bl 10908 */
		/* 82090EC4h case    1:*/		regs.LR = 0x82090EC8; return 0x82093960;
		/* 82090EC4h case    1:*/		return 0x82090EC8;
		  /* 82090EC8h */ case    2:  		/* li R3, -1 */
		/* 82090EC8h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82090EC8h case    2:*/		return 0x82090ECC;
	}
	return 0x82090ECC;
} // Block from 82090EC0h-82090ECCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82090ECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090ECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090ECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090ECC);
		  /* 82090ECCh */ case    0:  		/* addi R1, R1, 96 */
		/* 82090ECCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82090ECCh case    0:*/		return 0x82090ED0;
		  /* 82090ED0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82090ED0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82090ED0h case    1:*/		return 0x82090ED4;
		  /* 82090ED4h */ case    2:  		/* mtspr LR, R12 */
		/* 82090ED4h case    2:*/		regs.LR = regs.R12;
		/* 82090ED4h case    2:*/		return 0x82090ED8;
		  /* 82090ED8h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82090ED8h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82090ED8h case    3:*/		return 0x82090EDC;
		  /* 82090EDCh */ case    4:  		/* bclr 20, CR0_LT */
		/* 82090EDCh case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82090EDCh case    4:*/		return 0x82090EE0;
	}
	return 0x82090EE0;
} // Block from 82090ECCh-82090EE0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82090EE0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090EE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090EE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090EE0);
		  /* 82090EE0h */ case    0:  		/* mr R7, R6 */
		/* 82090EE0h case    0:*/		regs.R7 = regs.R6;
		/* 82090EE0h case    0:*/		return 0x82090EE4;
		  /* 82090EE4h */ case    1:  		/* li R6, 0 */
		/* 82090EE4h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82090EE4h case    1:*/		return 0x82090EE8;
		  /* 82090EE8h */ case    2:  		/* b -160 */
		/* 82090EE8h case    2:*/		return 0x82090E48;
		/* 82090EE8h case    2:*/		return 0x82090EEC;
		  /* 82090EECh */ case    3:  		/* nop */
		/* 82090EECh case    3:*/		cpu::op::nop();
		/* 82090EECh case    3:*/		return 0x82090EF0;
	}
	return 0x82090EF0;
} // Block from 82090EE0h-82090EF0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82090EF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090EF0);
		  /* 82090EF0h */ case    0:  		/* mfspr R12, LR */
		/* 82090EF0h case    0:*/		regs.R12 = regs.LR;
		/* 82090EF0h case    0:*/		return 0x82090EF4;
		  /* 82090EF4h */ case    1:  		/* bl 856 */
		/* 82090EF4h case    1:*/		regs.LR = 0x82090EF8; return 0x8209124C;
		/* 82090EF4h case    1:*/		return 0x82090EF8;
		  /* 82090EF8h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 82090EF8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82090EF8h case    2:*/		return 0x82090EFC;
		  /* 82090EFCh */ case    3:  		/* mr R29, R3 */
		/* 82090EFCh case    3:*/		regs.R29 = regs.R3;
		/* 82090EFCh case    3:*/		return 0x82090F00;
		  /* 82090F00h */ case    4:  		/* mr R31, R4 */
		/* 82090F00h case    4:*/		regs.R31 = regs.R4;
		/* 82090F00h case    4:*/		return 0x82090F04;
		  /* 82090F04h */ case    5:  		/* mr R26, R5 */
		/* 82090F04h case    5:*/		regs.R26 = regs.R5;
		/* 82090F04h case    5:*/		return 0x82090F08;
		  /* 82090F08h */ case    6:  		/* li R25, 0 */
		/* 82090F08h case    6:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82090F08h case    6:*/		return 0x82090F0C;
		  /* 82090F0Ch */ case    7:  		/* li R5, 28 */
		/* 82090F0Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x1C);
		/* 82090F0Ch case    7:*/		return 0x82090F10;
		  /* 82090F10h */ case    8:  		/* li R4, 0 */
		/* 82090F10h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82090F10h case    8:*/		return 0x82090F14;
		  /* 82090F14h */ case    9:  		/* stw R25, <#[R1 + 80]> */
		/* 82090F14h case    9:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000050) );
		/* 82090F14h case    9:*/		return 0x82090F18;
		  /* 82090F18h */ case   10:  		/* addi R3, R1, 84 */
		/* 82090F18h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x54);
		/* 82090F18h case   10:*/		return 0x82090F1C;
		  /* 82090F1Ch */ case   11:  		/* mr R30, R6 */
		/* 82090F1Ch case   11:*/		regs.R30 = regs.R6;
		/* 82090F1Ch case   11:*/		return 0x82090F20;
		  /* 82090F20h */ case   12:  		/* mr R28, R7 */
		/* 82090F20h case   12:*/		regs.R28 = regs.R7;
		/* 82090F20h case   12:*/		return 0x82090F24;
		  /* 82090F24h */ case   13:  		/* mr R27, R8 */
		/* 82090F24h case   13:*/		regs.R27 = regs.R8;
		/* 82090F24h case   13:*/		return 0x82090F28;
		  /* 82090F28h */ case   14:  		/* bl 1048 */
		/* 82090F28h case   14:*/		regs.LR = 0x82090F2C; return 0x82091340;
		/* 82090F28h case   14:*/		return 0x82090F2C;
		  /* 82090F2Ch */ case   15:  		/* cmplwi CR6, R30, 0 */
		/* 82090F2Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82090F2Ch case   15:*/		return 0x82090F30;
		  /* 82090F30h */ case   16:  		/* bc 4, CR6_EQ, 28 */
		/* 82090F30h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82090F4C;  }
		/* 82090F30h case   16:*/		return 0x82090F34;
		  /* 82090F34h */ case   17:  		/* bl 16340 */
		/* 82090F34h case   17:*/		regs.LR = 0x82090F38; return 0x82094F08;
		/* 82090F34h case   17:*/		return 0x82090F38;
		  /* 82090F38h */ case   18:  		/* li R11, 22 */
		/* 82090F38h case   18:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 82090F38h case   18:*/		return 0x82090F3C;
		  /* 82090F3Ch */ case   19:  		/* stw R11, <#[R3]> */
		/* 82090F3Ch case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82090F3Ch case   19:*/		return 0x82090F40;
		  /* 82090F40h */ case   20:  		/* bl 10784 */
		/* 82090F40h case   20:*/		regs.LR = 0x82090F44; return 0x82093960;
		/* 82090F40h case   20:*/		return 0x82090F44;
		  /* 82090F44h */ case   21:  		/* li R3, -1 */
		/* 82090F44h case   21:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82090F44h case   21:*/		return 0x82090F48;
		  /* 82090F48h */ case   22:  		/* b 192 */
		/* 82090F48h case   22:*/		return 0x82091008;
		/* 82090F48h case   22:*/		return 0x82090F4C;
	}
	return 0x82090F4C;
} // Block from 82090EF0h-82090F4Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 82090F4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090F4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090F4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090F4C);
		  /* 82090F4Ch */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 82090F4Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82090F4Ch case    0:*/		return 0x82090F50;
		  /* 82090F50h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82090F50h case    1:*/		if ( regs.CR[6].eq ) { return 0x82090F5C;  }
		/* 82090F50h case    1:*/		return 0x82090F54;
		  /* 82090F54h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 82090F54h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82090F54h case    2:*/		return 0x82090F58;
		  /* 82090F58h */ case    3:  		/* bc 12, CR6_EQ, -36 */
		/* 82090F58h case    3:*/		if ( regs.CR[6].eq ) { return 0x82090F34;  }
		/* 82090F58h case    3:*/		return 0x82090F5C;
	}
	return 0x82090F5C;
} // Block from 82090F4Ch-82090F5Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82090F5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090F5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090F5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090F5C);
		  /* 82090F5Ch */ case    0:  		/* lis R11, 32767 */
		/* 82090F5Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FFF);
		/* 82090F5Ch case    0:*/		return 0x82090F60;
		  /* 82090F60h */ case    1:  		/* ori R11, R11, 65535 */
		/* 82090F60h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFFF);
		/* 82090F60h case    1:*/		return 0x82090F64;
		  /* 82090F64h */ case    2:  		/* cmplw CR6, R26, R11 */
		/* 82090F64h case    2:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 82090F64h case    2:*/		return 0x82090F68;
		  /* 82090F68h */ case    3:  		/* stw R11, <#[R1 + 84]> */
		/* 82090F68h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82090F68h case    3:*/		return 0x82090F6C;
		  /* 82090F6Ch */ case    4:  		/* bc 12, CR6_GT, 8 */
		/* 82090F6Ch case    4:*/		if ( regs.CR[6].gt ) { return 0x82090F74;  }
		/* 82090F6Ch case    4:*/		return 0x82090F70;
		  /* 82090F70h */ case    5:  		/* stw R26, <#[R1 + 84]> */
		/* 82090F70h case    5:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000054) );
		/* 82090F70h case    5:*/		return 0x82090F74;
	}
	return 0x82090F74;
} // Block from 82090F5Ch-82090F74h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82090F74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090F74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090F74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090F74);
		  /* 82090F74h */ case    0:  		/* li R11, 66 */
		/* 82090F74h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x42);
		/* 82090F74h case    0:*/		return 0x82090F78;
		  /* 82090F78h */ case    1:  		/* stw R31, <#[R1 + 88]> */
		/* 82090F78h case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000058) );
		/* 82090F78h case    1:*/		return 0x82090F7C;
		  /* 82090F7Ch */ case    2:  		/* stw R31, <#[R1 + 80]> */
		/* 82090F7Ch case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 82090F7Ch case    2:*/		return 0x82090F80;
		  /* 82090F80h */ case    3:  		/* mr R6, R27 */
		/* 82090F80h case    3:*/		regs.R6 = regs.R27;
		/* 82090F80h case    3:*/		return 0x82090F84;
		  /* 82090F84h */ case    4:  		/* stw R11, <#[R1 + 92]> */
		/* 82090F84h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 82090F84h case    4:*/		return 0x82090F88;
		  /* 82090F88h */ case    5:  		/* mr R5, R28 */
		/* 82090F88h case    5:*/		regs.R5 = regs.R28;
		/* 82090F88h case    5:*/		return 0x82090F8C;
		  /* 82090F8Ch */ case    6:  		/* mr R4, R30 */
		/* 82090F8Ch case    6:*/		regs.R4 = regs.R30;
		/* 82090F8Ch case    6:*/		return 0x82090F90;
		  /* 82090F90h */ case    7:  		/* mtspr CTR, R29 */
		/* 82090F90h case    7:*/		regs.CTR = regs.R29;
		/* 82090F90h case    7:*/		return 0x82090F94;
		  /* 82090F94h */ case    8:  		/* addi R3, R1, 80 */
		/* 82090F94h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82090F94h case    8:*/		return 0x82090F98;
		  /* 82090F98h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 82090F98h case    9:*/		if ( 1 ) { regs.LR = 0x82090F9C; return (uint32)regs.CTR; }
		/* 82090F98h case    9:*/		return 0x82090F9C;
		  /* 82090F9Ch */ case   10:  		/* mr R30, R3 */
		/* 82090F9Ch case   10:*/		regs.R30 = regs.R3;
		/* 82090F9Ch case   10:*/		return 0x82090FA0;
		  /* 82090FA0h */ case   11:  		/* cmplwi CR6, R31, 0 */
		/* 82090FA0h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82090FA0h case   11:*/		return 0x82090FA4;
		  /* 82090FA4h */ case   12:  		/* bc 4, CR6_EQ, 12 */
		/* 82090FA4h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82090FB0;  }
		/* 82090FA4h case   12:*/		return 0x82090FA8;
		  /* 82090FA8h */ case   13:  		/* mr R3, R30 */
		/* 82090FA8h case   13:*/		regs.R3 = regs.R30;
		/* 82090FA8h case   13:*/		return 0x82090FAC;
		  /* 82090FACh */ case   14:  		/* b 92 */
		/* 82090FACh case   14:*/		return 0x82091008;
		/* 82090FACh case   14:*/		return 0x82090FB0;
	}
	return 0x82090FB0;
} // Block from 82090F74h-82090FB0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82090FB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090FB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090FB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090FB0);
		  /* 82090FB0h */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 82090FB0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82090FB0h case    0:*/		return 0x82090FB4;
		  /* 82090FB4h */ case    1:  		/* bc 12, CR6_LT, 52 */
		/* 82090FB4h case    1:*/		if ( regs.CR[6].lt ) { return 0x82090FE8;  }
		/* 82090FB4h case    1:*/		return 0x82090FB8;
		  /* 82090FB8h */ case    2:  		/* lwz R11, <#[R1 + 84]> */
		/* 82090FB8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82090FB8h case    2:*/		return 0x82090FBC;
		  /* 82090FBCh */ case    3:  		/* addic. R11, R11, -1 */
		/* 82090FBCh case    3:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82090FBCh case    3:*/		return 0x82090FC0;
		  /* 82090FC0h */ case    4:  		/* stw R11, <#[R1 + 84]> */
		/* 82090FC0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82090FC0h case    4:*/		return 0x82090FC4;
		  /* 82090FC4h */ case    5:  		/* bc 12, CR0_LT, 16 */
		/* 82090FC4h case    5:*/		if ( regs.CR[0].lt ) { return 0x82090FD4;  }
		/* 82090FC4h case    5:*/		return 0x82090FC8;
		  /* 82090FC8h */ case    6:  		/* lwz R11, <#[R1 + 80]> */
		/* 82090FC8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82090FC8h case    6:*/		return 0x82090FCC;
		  /* 82090FCCh */ case    7:  		/* stb R25, <#[R11]> */
		/* 82090FCCh case    7:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R11 + 0x00000000) );
		/* 82090FCCh case    7:*/		return 0x82090FD0;
		  /* 82090FD0h */ case    8:  		/* b -40 */
		/* 82090FD0h case    8:*/		return 0x82090FA8;
		/* 82090FD0h case    8:*/		return 0x82090FD4;
	}
	return 0x82090FD4;
} // Block from 82090FB0h-82090FD4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82090FD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090FD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090FD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090FD4);
		  /* 82090FD4h */ case    0:  		/* addi R4, R1, 80 */
		/* 82090FD4h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82090FD4h case    0:*/		return 0x82090FD8;
		  /* 82090FD8h */ case    1:  		/* li R3, 0 */
		/* 82090FD8h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82090FD8h case    1:*/		return 0x82090FDC;
		  /* 82090FDCh */ case    2:  		/* bl 15588 */
		/* 82090FDCh case    2:*/		regs.LR = 0x82090FE0; return 0x82094CC0;
		/* 82090FDCh case    2:*/		return 0x82090FE0;
		  /* 82090FE0h */ case    3:  		/* cmpwi CR6, R3, -1 */
		/* 82090FE0h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82090FE0h case    3:*/		return 0x82090FE4;
		  /* 82090FE4h */ case    4:  		/* bc 4, CR6_EQ, -60 */
		/* 82090FE4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82090FA8;  }
		/* 82090FE4h case    4:*/		return 0x82090FE8;
	}
	return 0x82090FE8;
} // Block from 82090FD4h-82090FE8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82090FE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82090FE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82090FE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82090FE8);
		  /* 82090FE8h */ case    0:  		/* lwz R11, <#[R1 + 84]> */
		/* 82090FE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82090FE8h case    0:*/		return 0x82090FEC;
		  /* 82090FECh */ case    1:  		/* add R10, R31, R26 */
		/* 82090FECh case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R31,regs.R26);
		/* 82090FECh case    1:*/		return 0x82090FF0;
		  /* 82090FF0h */ case    2:  		/* cntlzw R11, R11 */
		/* 82090FF0h case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82090FF0h case    2:*/		return 0x82090FF4;
		  /* 82090FF4h */ case    3:  		/* cntlzw R11, R11 */
		/* 82090FF4h case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82090FF4h case    3:*/		return 0x82090FF8;
		  /* 82090FF8h */ case    4:  		/* stb R25, <#[R10 - 1]> */
		/* 82090FF8h case    4:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R10 + 0xFFFFFFFF) );
		/* 82090FF8h case    4:*/		return 0x82090FFC;
		  /* 82090FFCh */ case    5:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 82090FFCh case    5:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82090FFCh case    5:*/		return 0x82091000;
		  /* 82091000h */ case    6:  		/* xori R11, R11, 1 */
		/* 82091000h case    6:*/		cpu::op::xori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82091000h case    6:*/		return 0x82091004;
		  /* 82091004h */ case    7:  		/* addi R3, R11, -2 */
		/* 82091004h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFFE);
		/* 82091004h case    7:*/		return 0x82091008;
	}
	return 0x82091008;
} // Block from 82090FE8h-82091008h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82091008h
// Function 'RtlReAllocateHeap'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091008);
		  /* 82091008h */ case    0:  		/* addi R1, R1, 176 */
		/* 82091008h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82091008h case    0:*/		return 0x8209100C;
		  /* 8209100Ch */ case    1:  		/* b 656 */
		/* 8209100Ch case    1:*/		return 0x8209129C;
		/* 8209100Ch case    1:*/		return 0x82091010;
	}
	return 0x82091010;
} // Block from 82091008h-82091010h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82091010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091010);
		  /* 82091010h */ case    0:  		/* mfspr R12, LR */
		/* 82091010h case    0:*/		regs.R12 = regs.LR;
		/* 82091010h case    0:*/		return 0x82091014;
		  /* 82091014h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82091014h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82091014h case    1:*/		return 0x82091018;
		  /* 82091018h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82091018h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82091018h case    2:*/		return 0x8209101C;
		  /* 8209101Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209101Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209101Ch case    3:*/		return 0x82091020;
		  /* 82091020h */ case    4:  		/* mr R31, R3 */
		/* 82091020h case    4:*/		regs.R31 = regs.R3;
		/* 82091020h case    4:*/		return 0x82091024;
		  /* 82091024h */ case    5:  		/* mr R8, R7 */
		/* 82091024h case    5:*/		regs.R8 = regs.R7;
		/* 82091024h case    5:*/		return 0x82091028;
		  /* 82091028h */ case    6:  		/* cmplwi CR6, R5, 0 */
		/* 82091028h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82091028h case    6:*/		return 0x8209102C;
		  /* 8209102Ch */ case    7:  		/* bc 4, CR6_EQ, 16 */
		/* 8209102Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x8209103C;  }
		/* 8209102Ch case    7:*/		return 0x82091030;
		  /* 82091030h */ case    8:  		/* bl 16088 */
		/* 82091030h case    8:*/		regs.LR = 0x82091034; return 0x82094F08;
		/* 82091030h case    8:*/		return 0x82091034;
		  /* 82091034h */ case    9:  		/* li R11, 22 */
		/* 82091034h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 82091034h case    9:*/		return 0x82091038;
		  /* 82091038h */ case   10:  		/* b 80 */
		/* 82091038h case   10:*/		return 0x82091088;
		/* 82091038h case   10:*/		return 0x8209103C;
	}
	return 0x8209103C;
} // Block from 82091010h-8209103Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209103Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209103C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209103C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209103C);
		  /* 8209103Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 8209103Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8209103Ch case    0:*/		return 0x82091040;
		  /* 82091040h */ case    1:  		/* bc 12, CR6_EQ, -16 */
		/* 82091040h case    1:*/		if ( regs.CR[6].eq ) { return 0x82091030;  }
		/* 82091040h case    1:*/		return 0x82091044;
		  /* 82091044h */ case    2:  		/* cmplwi CR6, R4, 0 */
		/* 82091044h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82091044h case    2:*/		return 0x82091048;
		  /* 82091048h */ case    3:  		/* bc 12, CR6_EQ, -24 */
		/* 82091048h case    3:*/		if ( regs.CR[6].eq ) { return 0x82091030;  }
		/* 82091048h case    3:*/		return 0x8209104C;
		  /* 8209104Ch */ case    4:  		/* mr R7, R6 */
		/* 8209104Ch case    4:*/		regs.R7 = regs.R6;
		/* 8209104Ch case    4:*/		return 0x82091050;
		  /* 82091050h */ case    5:  		/* lis R11, -32247 */
		/* 82091050h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8209);
		/* 82091050h case    5:*/		return 0x82091054;
		  /* 82091054h */ case    6:  		/* mr R6, R5 */
		/* 82091054h case    6:*/		regs.R6 = regs.R5;
		/* 82091054h case    6:*/		return 0x82091058;
		  /* 82091058h */ case    7:  		/* mr R5, R4 */
		/* 82091058h case    7:*/		regs.R5 = regs.R4;
		/* 82091058h case    7:*/		return 0x8209105C;
		  /* 8209105Ch */ case    8:  		/* mr R4, R31 */
		/* 8209105Ch case    8:*/		regs.R4 = regs.R31;
		/* 8209105Ch case    8:*/		return 0x82091060;
		  /* 82091060h */ case    9:  		/* addi R3, R11, 29328 */
		/* 82091060h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7290);
		/* 82091060h case    9:*/		return 0x82091064;
		  /* 82091064h */ case   10:  		/* bl -372 */
		/* 82091064h case   10:*/		regs.LR = 0x82091068; return 0x82090EF0;
		/* 82091064h case   10:*/		return 0x82091068;
		  /* 82091068h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 82091068h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82091068h case   11:*/		return 0x8209106C;
		  /* 8209106Ch */ case   12:  		/* bc 4, CR0_LT, 12 */
		/* 8209106Ch case   12:*/		if ( !regs.CR[0].lt ) { return 0x82091078;  }
		/* 8209106Ch case   12:*/		return 0x82091070;
		  /* 82091070h */ case   13:  		/* li R11, 0 */
		/* 82091070h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82091070h case   13:*/		return 0x82091074;
		  /* 82091074h */ case   14:  		/* stb R11, <#[R31]> */
		/* 82091074h case   14:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82091074h case   14:*/		return 0x82091078;
	}
	return 0x82091078;
} // Block from 8209103Ch-82091078h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82091078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091078);
		  /* 82091078h */ case    0:  		/* cmpwi CR6, R3, -2 */
		/* 82091078h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFE);
		/* 82091078h case    0:*/		return 0x8209107C;
		  /* 8209107Ch */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 8209107Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82091094;  }
		/* 8209107Ch case    1:*/		return 0x82091080;
		  /* 82091080h */ case    2:  		/* bl 16008 */
		/* 82091080h case    2:*/		regs.LR = 0x82091084; return 0x82094F08;
		/* 82091080h case    2:*/		return 0x82091084;
		  /* 82091084h */ case    3:  		/* li R11, 34 */
		/* 82091084h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x22);
		/* 82091084h case    3:*/		return 0x82091088;
	}
	return 0x82091088;
} // Block from 82091078h-82091088h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82091088h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091088);
		  /* 82091088h */ case    0:  		/* stw R11, <#[R3]> */
		/* 82091088h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82091088h case    0:*/		return 0x8209108C;
		  /* 8209108Ch */ case    1:  		/* bl 10452 */
		/* 8209108Ch case    1:*/		regs.LR = 0x82091090; return 0x82093960;
		/* 8209108Ch case    1:*/		return 0x82091090;
		  /* 82091090h */ case    2:  		/* li R3, -1 */
		/* 82091090h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82091090h case    2:*/		return 0x82091094;
	}
	return 0x82091094;
} // Block from 82091088h-82091094h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82091094h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091094( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091094) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091094);
		  /* 82091094h */ case    0:  		/* addi R1, R1, 96 */
		/* 82091094h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82091094h case    0:*/		return 0x82091098;
		  /* 82091098h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82091098h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82091098h case    1:*/		return 0x8209109C;
		  /* 8209109Ch */ case    2:  		/* mtspr LR, R12 */
		/* 8209109Ch case    2:*/		regs.LR = regs.R12;
		/* 8209109Ch case    2:*/		return 0x820910A0;
		  /* 820910A0h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820910A0h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820910A0h case    3:*/		return 0x820910A4;
		  /* 820910A4h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820910A4h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820910A4h case    4:*/		return 0x820910A8;
	}
	return 0x820910A8;
} // Block from 82091094h-820910A8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820910A8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820910A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820910A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820910A8);
		  /* 820910A8h */ case    0:  		/* mr R7, R6 */
		/* 820910A8h case    0:*/		regs.R7 = regs.R6;
		/* 820910A8h case    0:*/		return 0x820910AC;
		  /* 820910ACh */ case    1:  		/* li R6, 0 */
		/* 820910ACh case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820910ACh case    1:*/		return 0x820910B0;
		  /* 820910B0h */ case    2:  		/* b -160 */
		/* 820910B0h case    2:*/		return 0x82091010;
		/* 820910B0h case    2:*/		return 0x820910B4;
		  /* 820910B4h */ case    3:  		/* nop */
		/* 820910B4h case    3:*/		cpu::op::nop();
		/* 820910B4h case    3:*/		return 0x820910B8;
	}
	return 0x820910B8;
} // Block from 820910A8h-820910B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820910B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820910B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820910B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820910B8);
		  /* 820910B8h */ case    0:  		/* mfspr R12, LR */
		/* 820910B8h case    0:*/		regs.R12 = regs.LR;
		/* 820910B8h case    0:*/		return 0x820910BC;
		  /* 820910BCh */ case    1:  		/* bl 396 */
		/* 820910BCh case    1:*/		regs.LR = 0x820910C0; return 0x82091248;
		/* 820910BCh case    1:*/		return 0x820910C0;
		  /* 820910C0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820910C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820910C0h case    2:*/		return 0x820910C4;
		  /* 820910C4h */ case    3:  		/* mr R31, R3 */
		/* 820910C4h case    3:*/		regs.R31 = regs.R3;
		/* 820910C4h case    3:*/		return 0x820910C8;
		  /* 820910C8h */ case    4:  		/* mr R30, R4 */
		/* 820910C8h case    4:*/		regs.R30 = regs.R4;
		/* 820910C8h case    4:*/		return 0x820910CC;
		  /* 820910CCh */ case    5:  		/* mr R25, R5 */
		/* 820910CCh case    5:*/		regs.R25 = regs.R5;
		/* 820910CCh case    5:*/		return 0x820910D0;
		  /* 820910D0h */ case    6:  		/* mr R29, R6 */
		/* 820910D0h case    6:*/		regs.R29 = regs.R6;
		/* 820910D0h case    6:*/		return 0x820910D4;
		  /* 820910D4h */ case    7:  		/* mr R28, R7 */
		/* 820910D4h case    7:*/		regs.R28 = regs.R7;
		/* 820910D4h case    7:*/		return 0x820910D8;
		  /* 820910D8h */ case    8:  		/* mr R27, R8 */
		/* 820910D8h case    8:*/		regs.R27 = regs.R8;
		/* 820910D8h case    8:*/		return 0x820910DC;
		  /* 820910DCh */ case    9:  		/* cmplwi CR6, R6, 0 */
		/* 820910DCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820910DCh case    9:*/		return 0x820910E0;
		  /* 820910E0h */ case   10:  		/* bc 4, CR6_EQ, 32 */
		/* 820910E0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82091100;  }
		/* 820910E0h case   10:*/		return 0x820910E4;
		  /* 820910E4h */ case   11:  		/* bl 15908 */
		/* 820910E4h case   11:*/		regs.LR = 0x820910E8; return 0x82094F08;
		/* 820910E4h case   11:*/		return 0x820910E8;
		  /* 820910E8h */ case   12:  		/* li R11, 22 */
		/* 820910E8h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 820910E8h case   12:*/		return 0x820910EC;
		  /* 820910ECh */ case   13:  		/* stw R11, <#[R3]> */
		/* 820910ECh case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820910ECh case   13:*/		return 0x820910F0;
		  /* 820910F0h */ case   14:  		/* bl 10352 */
		/* 820910F0h case   14:*/		regs.LR = 0x820910F4; return 0x82093960;
		/* 820910F0h case   14:*/		return 0x820910F4;
		  /* 820910F4h */ case   15:  		/* li R3, -1 */
		/* 820910F4h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820910F4h case   15:*/		return 0x820910F8;
		  /* 820910F8h */ case   16:  		/* addi R1, R1, 160 */
		/* 820910F8h case   16:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820910F8h case   16:*/		return 0x820910FC;
		  /* 820910FCh */ case   17:  		/* b 412 */
		/* 820910FCh case   17:*/		return 0x82091298;
		/* 820910FCh case   17:*/		return 0x82091100;
	}
	return 0x82091100;
} // Block from 820910B8h-82091100h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82091100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091100);
		  /* 82091100h */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 82091100h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82091100h case    0:*/		return 0x82091104;
		  /* 82091104h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 82091104h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82091120;  }
		/* 82091104h case    1:*/		return 0x82091108;
		  /* 82091108h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 82091108h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82091108h case    2:*/		return 0x8209110C;
		  /* 8209110Ch */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 8209110Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82091128;  }
		/* 8209110Ch case    3:*/		return 0x82091110;
		  /* 82091110h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 82091110h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82091110h case    4:*/		return 0x82091114;
		  /* 82091114h */ case    5:  		/* bc 4, CR6_EQ, -48 */
		/* 82091114h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820910E4;  }
		/* 82091114h case    5:*/		return 0x82091118;
		  /* 82091118h */ case    6:  		/* li R3, 0 */
		/* 82091118h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82091118h case    6:*/		return 0x8209111C;
		  /* 8209111Ch */ case    7:  		/* b -36 */
		/* 8209111Ch case    7:*/		return 0x820910F8;
		/* 8209111Ch case    7:*/		return 0x82091120;
	}
	return 0x82091120;
} // Block from 82091100h-82091120h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82091120h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091120);
		  /* 82091120h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82091120h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82091120h case    0:*/		return 0x82091124;
		  /* 82091124h */ case    1:  		/* bc 12, CR6_EQ, -64 */
		/* 82091124h case    1:*/		if ( regs.CR[6].eq ) { return 0x820910E4;  }
		/* 82091124h case    1:*/		return 0x82091128;
	}
	return 0x82091128;
} // Block from 82091120h-82091128h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82091128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091128);
		  /* 82091128h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 82091128h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82091128h case    0:*/		return 0x8209112C;
		  /* 8209112Ch */ case    1:  		/* bc 12, CR6_EQ, -72 */
		/* 8209112Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820910E4;  }
		/* 8209112Ch case    1:*/		return 0x82091130;
		  /* 82091130h */ case    2:  		/* li R24, 0 */
		/* 82091130h case    2:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 82091130h case    2:*/		return 0x82091134;
		  /* 82091134h */ case    3:  		/* cmplw CR6, R30, R25 */
		/* 82091134h case    3:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R25);
		/* 82091134h case    3:*/		return 0x82091138;
		  /* 82091138h */ case    4:  		/* bc 4, CR6_GT, 80 */
		/* 82091138h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82091188;  }
		/* 82091138h case    4:*/		return 0x8209113C;
		  /* 8209113Ch */ case    5:  		/* bl 15820 */
		/* 8209113Ch case    5:*/		regs.LR = 0x82091140; return 0x82094F08;
		/* 8209113Ch case    5:*/		return 0x82091140;
		  /* 82091140h */ case    6:  		/* lis R11, -32247 */
		/* 82091140h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8209);
		/* 82091140h case    6:*/		return 0x82091144;
		  /* 82091144h */ case    7:  		/* lwz R30, <#[R3]> */
		/* 82091144h case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82091144h case    7:*/		return 0x82091148;
		  /* 82091148h */ case    8:  		/* mr R8, R27 */
		/* 82091148h case    8:*/		regs.R8 = regs.R27;
		/* 82091148h case    8:*/		return 0x8209114C;
		  /* 8209114Ch */ case    9:  		/* mr R7, R28 */
		/* 8209114Ch case    9:*/		regs.R7 = regs.R28;
		/* 8209114Ch case    9:*/		return 0x82091150;
		  /* 82091150h */ case   10:  		/* mr R6, R29 */
		/* 82091150h case   10:*/		regs.R6 = regs.R29;
		/* 82091150h case   10:*/		return 0x82091154;
		  /* 82091154h */ case   11:  		/* addi R5, R25, 1 */
		/* 82091154h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R25,0x1);
		/* 82091154h case   11:*/		return 0x82091158;
		  /* 82091158h */ case   12:  		/* mr R4, R31 */
		/* 82091158h case   12:*/		regs.R4 = regs.R31;
		/* 82091158h case   12:*/		return 0x8209115C;
		  /* 8209115Ch */ case   13:  		/* addi R3, R11, 29328 */
		/* 8209115Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7290);
		/* 8209115Ch case   13:*/		return 0x82091160;
		  /* 82091160h */ case   14:  		/* bl -624 */
		/* 82091160h case   14:*/		regs.LR = 0x82091164; return 0x82090EF0;
		/* 82091160h case   14:*/		return 0x82091164;
		  /* 82091164h */ case   15:  		/* cmpwi CR6, R3, -2 */
		/* 82091164h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFE);
		/* 82091164h case   15:*/		return 0x82091168;
		  /* 82091168h */ case   16:  		/* bc 4, CR6_EQ, 124 */
		/* 82091168h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820911E4;  }
		/* 82091168h case   16:*/		return 0x8209116C;
		  /* 8209116Ch */ case   17:  		/* bl 15772 */
		/* 8209116Ch case   17:*/		regs.LR = 0x82091170; return 0x82094F08;
		/* 8209116Ch case   17:*/		return 0x82091170;
		  /* 82091170h */ case   18:  		/* lwz R11, <#[R3]> */
		/* 82091170h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82091170h case   18:*/		return 0x82091174;
		  /* 82091174h */ case   19:  		/* cmpwi CR6, R11, 34 */
		/* 82091174h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000022);
		/* 82091174h case   19:*/		return 0x82091178;
		  /* 82091178h */ case   20:  		/* bc 4, CR6_EQ, -132 */
		/* 82091178h case   20:*/		if ( !regs.CR[6].eq ) { return 0x820910F4;  }
		/* 82091178h case   20:*/		return 0x8209117C;
		  /* 8209117Ch */ case   21:  		/* bl 15756 */
		/* 8209117Ch case   21:*/		regs.LR = 0x82091180; return 0x82094F08;
		/* 8209117Ch case   21:*/		return 0x82091180;
		  /* 82091180h */ case   22:  		/* stw R30, <#[R3]> */
		/* 82091180h case   22:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82091180h case   22:*/		return 0x82091184;
		  /* 82091184h */ case   23:  		/* b -144 */
		/* 82091184h case   23:*/		return 0x820910F4;
		/* 82091184h case   23:*/		return 0x82091188;
	}
	return 0x82091188;
} // Block from 82091128h-82091188h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82091188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091188);
		  /* 82091188h */ case    0:  		/* bl 15744 */
		/* 82091188h case    0:*/		regs.LR = 0x8209118C; return 0x82094F08;
		/* 82091188h case    0:*/		return 0x8209118C;
		  /* 8209118Ch */ case    1:  		/* lis R11, -32247 */
		/* 8209118Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8209);
		/* 8209118Ch case    1:*/		return 0x82091190;
		  /* 82091190h */ case    2:  		/* lwz R26, <#[R3]> */
		/* 82091190h case    2:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R3 + 0x00000000) );
		/* 82091190h case    2:*/		return 0x82091194;
		  /* 82091194h */ case    3:  		/* mr R8, R27 */
		/* 82091194h case    3:*/		regs.R8 = regs.R27;
		/* 82091194h case    3:*/		return 0x82091198;
		  /* 82091198h */ case    4:  		/* mr R7, R28 */
		/* 82091198h case    4:*/		regs.R7 = regs.R28;
		/* 82091198h case    4:*/		return 0x8209119C;
		  /* 8209119Ch */ case    5:  		/* mr R6, R29 */
		/* 8209119Ch case    5:*/		regs.R6 = regs.R29;
		/* 8209119Ch case    5:*/		return 0x820911A0;
		  /* 820911A0h */ case    6:  		/* mr R5, R30 */
		/* 820911A0h case    6:*/		regs.R5 = regs.R30;
		/* 820911A0h case    6:*/		return 0x820911A4;
		  /* 820911A4h */ case    7:  		/* mr R4, R31 */
		/* 820911A4h case    7:*/		regs.R4 = regs.R31;
		/* 820911A4h case    7:*/		return 0x820911A8;
		  /* 820911A8h */ case    8:  		/* addi R3, R11, 29328 */
		/* 820911A8h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7290);
		/* 820911A8h case    8:*/		return 0x820911AC;
		  /* 820911ACh */ case    9:  		/* bl -700 */
		/* 820911ACh case    9:*/		regs.LR = 0x820911B0; return 0x82090EF0;
		/* 820911ACh case    9:*/		return 0x820911B0;
		  /* 820911B0h */ case   10:  		/* add R11, R31, R30 */
		/* 820911B0h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R30);
		/* 820911B0h case   10:*/		return 0x820911B4;
		  /* 820911B4h */ case   11:  		/* cmpwi CR6, R3, -2 */
		/* 820911B4h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFE);
		/* 820911B4h case   11:*/		return 0x820911B8;
		  /* 820911B8h */ case   12:  		/* stb R24, <#[R11 - 1]> */
		/* 820911B8h case   12:*/		cpu::mem::store8( regs, regs.R24, (uint32)(regs.R11 + 0xFFFFFFFF) );
		/* 820911B8h case   12:*/		return 0x820911BC;
		  /* 820911BCh */ case   13:  		/* bc 4, CR6_EQ, 40 */
		/* 820911BCh case   13:*/		if ( !regs.CR[6].eq ) { return 0x820911E4;  }
		/* 820911BCh case   13:*/		return 0x820911C0;
		  /* 820911C0h */ case   14:  		/* cmpwi CR6, R25, -1 */
		/* 820911C0h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R25,0xFFFFFFFF);
		/* 820911C0h case   14:*/		return 0x820911C4;
		  /* 820911C4h */ case   15:  		/* bc 4, CR6_EQ, 40 */
		/* 820911C4h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820911EC;  }
		/* 820911C4h case   15:*/		return 0x820911C8;
		  /* 820911C8h */ case   16:  		/* bl 15680 */
		/* 820911C8h case   16:*/		regs.LR = 0x820911CC; return 0x82094F08;
		/* 820911C8h case   16:*/		return 0x820911CC;
		  /* 820911CCh */ case   17:  		/* lwz R11, <#[R3]> */
		/* 820911CCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820911CCh case   17:*/		return 0x820911D0;
		  /* 820911D0h */ case   18:  		/* cmpwi CR6, R11, 34 */
		/* 820911D0h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000022);
		/* 820911D0h case   18:*/		return 0x820911D4;
		  /* 820911D4h */ case   19:  		/* bc 4, CR6_EQ, -224 */
		/* 820911D4h case   19:*/		if ( !regs.CR[6].eq ) { return 0x820910F4;  }
		/* 820911D4h case   19:*/		return 0x820911D8;
		  /* 820911D8h */ case   20:  		/* bl 15664 */
		/* 820911D8h case   20:*/		regs.LR = 0x820911DC; return 0x82094F08;
		/* 820911D8h case   20:*/		return 0x820911DC;
		  /* 820911DCh */ case   21:  		/* stw R26, <#[R3]> */
		/* 820911DCh case   21:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x00000000) );
		/* 820911DCh case   21:*/		return 0x820911E0;
		  /* 820911E0h */ case   22:  		/* b -236 */
		/* 820911E0h case   22:*/		return 0x820910F4;
		/* 820911E0h case   22:*/		return 0x820911E4;
	}
	return 0x820911E4;
} // Block from 82091188h-820911E4h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820911E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820911E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820911E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820911E4);
		  /* 820911E4h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820911E4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820911E4h case    0:*/		return 0x820911E8;
		  /* 820911E8h */ case    1:  		/* bc 4, CR6_LT, -240 */
		/* 820911E8h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820910F8;  }
		/* 820911E8h case    1:*/		return 0x820911EC;
	}
	return 0x820911EC;
} // Block from 820911E4h-820911ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820911ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820911EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820911EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820911EC);
		  /* 820911ECh */ case    0:  		/* cmpwi CR6, R3, -2 */
		/* 820911ECh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFE);
		/* 820911ECh case    0:*/		return 0x820911F0;
		  /* 820911F0h */ case    1:  		/* stb R24, <#[R31]> */
		/* 820911F0h case    1:*/		cpu::mem::store8( regs, regs.R24, (uint32)(regs.R31 + 0x00000000) );
		/* 820911F0h case    1:*/		return 0x820911F4;
		  /* 820911F4h */ case    2:  		/* bc 4, CR6_EQ, -256 */
		/* 820911F4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820910F4;  }
		/* 820911F4h case    2:*/		return 0x820911F8;
		  /* 820911F8h */ case    3:  		/* bl 15632 */
		/* 820911F8h case    3:*/		regs.LR = 0x820911FC; return 0x82094F08;
		/* 820911F8h case    3:*/		return 0x820911FC;
		  /* 820911FCh */ case    4:  		/* li R11, 34 */
		/* 820911FCh case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x22);
		/* 820911FCh case    4:*/		return 0x82091200;
		  /* 82091200h */ case    5:  		/* b -276 */
		/* 82091200h case    5:*/		return 0x820910EC;
		/* 82091200h case    5:*/		return 0x82091204;
		  /* 82091204h */ case    6:  		/* nop */
		/* 82091204h case    6:*/		cpu::op::nop();
		/* 82091204h case    6:*/		return 0x82091208;
	}
	return 0x82091208;
} // Block from 820911ECh-82091208h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82091208h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091208);
		  /* 82091208h */ case    0:  		/* mr R8, R7 */
		/* 82091208h case    0:*/		regs.R8 = regs.R7;
		/* 82091208h case    0:*/		return 0x8209120C;
		  /* 8209120Ch */ case    1:  		/* li R7, 0 */
		/* 8209120Ch case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8209120Ch case    1:*/		return 0x82091210;
		  /* 82091210h */ case    2:  		/* b -344 */
		/* 82091210h case    2:*/		return 0x820910B8;
		/* 82091210h case    2:*/		return 0x82091214;
		  /* 82091214h */ case    3:  		/* nop */
		/* 82091214h case    3:*/		cpu::op::nop();
		/* 82091214h case    3:*/		return 0x82091218;
		  /* 82091218h */ case    4:  		/* nop */
		/* 82091218h case    4:*/		cpu::op::nop();
		/* 82091218h case    4:*/		return 0x8209121C;
		  /* 8209121Ch */ case    5:  		/* nop */
		/* 8209121Ch case    5:*/		cpu::op::nop();
		/* 8209121Ch case    5:*/		return 0x82091220;
	}
	return 0x82091220;
} // Block from 82091208h-82091220h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82091220h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091220);
		  /* 82091220h */ case    0:  		/* std R14, <#[R1 - 152]> */
		/* 82091220h case    0:*/		cpu::mem::store64( regs, regs.R14, (uint32)(regs.R1 + 0xFFFFFF68) );
		/* 82091220h case    0:*/		return 0x82091224;
	}
	return 0x82091224;
} // Block from 82091220h-82091224h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091224h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091224);
		  /* 82091224h */ case    0:  		/* std R15, <#[R1 - 144]> */
		/* 82091224h case    0:*/		cpu::mem::store64( regs, regs.R15, (uint32)(regs.R1 + 0xFFFFFF70) );
		/* 82091224h case    0:*/		return 0x82091228;
	}
	return 0x82091228;
} // Block from 82091224h-82091228h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091228h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091228);
		  /* 82091228h */ case    0:  		/* std R16, <#[R1 - 136]> */
		/* 82091228h case    0:*/		cpu::mem::store64( regs, regs.R16, (uint32)(regs.R1 + 0xFFFFFF78) );
		/* 82091228h case    0:*/		return 0x8209122C;
	}
	return 0x8209122C;
} // Block from 82091228h-8209122Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209122Ch
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209122C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209122C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209122C);
		  /* 8209122Ch */ case    0:  		/* std R17, <#[R1 - 128]> */
		/* 8209122Ch case    0:*/		cpu::mem::store64( regs, regs.R17, (uint32)(regs.R1 + 0xFFFFFF80) );
		/* 8209122Ch case    0:*/		return 0x82091230;
	}
	return 0x82091230;
} // Block from 8209122Ch-82091230h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091230h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091230);
		  /* 82091230h */ case    0:  		/* std R18, <#[R1 - 120]> */
		/* 82091230h case    0:*/		cpu::mem::store64( regs, regs.R18, (uint32)(regs.R1 + 0xFFFFFF88) );
		/* 82091230h case    0:*/		return 0x82091234;
	}
	return 0x82091234;
} // Block from 82091230h-82091234h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091234h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091234( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091234) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091234);
		  /* 82091234h */ case    0:  		/* std R19, <#[R1 - 112]> */
		/* 82091234h case    0:*/		cpu::mem::store64( regs, regs.R19, (uint32)(regs.R1 + 0xFFFFFF90) );
		/* 82091234h case    0:*/		return 0x82091238;
	}
	return 0x82091238;
} // Block from 82091234h-82091238h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091238h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091238);
		  /* 82091238h */ case    0:  		/* std R20, <#[R1 - 104]> */
		/* 82091238h case    0:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R1 + 0xFFFFFF98) );
		/* 82091238h case    0:*/		return 0x8209123C;
	}
	return 0x8209123C;
} // Block from 82091238h-8209123Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209123Ch
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209123C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209123C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209123C);
		  /* 8209123Ch */ case    0:  		/* std R21, <#[R1 - 96]> */
		/* 8209123Ch case    0:*/		cpu::mem::store64( regs, regs.R21, (uint32)(regs.R1 + 0xFFFFFFA0) );
		/* 8209123Ch case    0:*/		return 0x82091240;
	}
	return 0x82091240;
} // Block from 8209123Ch-82091240h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091240h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091240);
		  /* 82091240h */ case    0:  		/* std R22, <#[R1 - 88]> */
		/* 82091240h case    0:*/		cpu::mem::store64( regs, regs.R22, (uint32)(regs.R1 + 0xFFFFFFA8) );
		/* 82091240h case    0:*/		return 0x82091244;
	}
	return 0x82091244;
} // Block from 82091240h-82091244h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091244h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091244( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091244) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091244);
		  /* 82091244h */ case    0:  		/* std R23, <#[R1 - 80]> */
		/* 82091244h case    0:*/		cpu::mem::store64( regs, regs.R23, (uint32)(regs.R1 + 0xFFFFFFB0) );
		/* 82091244h case    0:*/		return 0x82091248;
	}
	return 0x82091248;
} // Block from 82091244h-82091248h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091248h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091248);
		  /* 82091248h */ case    0:  		/* std R24, <#[R1 - 72]> */
		/* 82091248h case    0:*/		cpu::mem::store64( regs, regs.R24, (uint32)(regs.R1 + 0xFFFFFFB8) );
		/* 82091248h case    0:*/		return 0x8209124C;
	}
	return 0x8209124C;
} // Block from 82091248h-8209124Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209124Ch
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209124C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209124C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209124C);
		  /* 8209124Ch */ case    0:  		/* std R25, <#[R1 - 64]> */
		/* 8209124Ch case    0:*/		cpu::mem::store64( regs, regs.R25, (uint32)(regs.R1 + 0xFFFFFFC0) );
		/* 8209124Ch case    0:*/		return 0x82091250;
	}
	return 0x82091250;
} // Block from 8209124Ch-82091250h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091250h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091250);
		  /* 82091250h */ case    0:  		/* std R26, <#[R1 - 56]> */
		/* 82091250h case    0:*/		cpu::mem::store64( regs, regs.R26, (uint32)(regs.R1 + 0xFFFFFFC8) );
		/* 82091250h case    0:*/		return 0x82091254;
	}
	return 0x82091254;
} // Block from 82091250h-82091254h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091254h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091254);
		  /* 82091254h */ case    0:  		/* std R27, <#[R1 - 48]> */
		/* 82091254h case    0:*/		cpu::mem::store64( regs, regs.R27, (uint32)(regs.R1 + 0xFFFFFFD0) );
		/* 82091254h case    0:*/		return 0x82091258;
	}
	return 0x82091258;
} // Block from 82091254h-82091258h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091258h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091258);
		  /* 82091258h */ case    0:  		/* std R28, <#[R1 - 40]> */
		/* 82091258h case    0:*/		cpu::mem::store64( regs, regs.R28, (uint32)(regs.R1 + 0xFFFFFFD8) );
		/* 82091258h case    0:*/		return 0x8209125C;
	}
	return 0x8209125C;
} // Block from 82091258h-8209125Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209125Ch
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209125C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209125C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209125C);
		  /* 8209125Ch */ case    0:  		/* std R29, <#[R1 - 32]> */
		/* 8209125Ch case    0:*/		cpu::mem::store64( regs, regs.R29, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 8209125Ch case    0:*/		return 0x82091260;
		  /* 82091260h */ case    1:  		/* std R30, <#[R1 - 24]> */
		/* 82091260h case    1:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82091260h case    1:*/		return 0x82091264;
		  /* 82091264h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82091264h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82091264h case    2:*/		return 0x82091268;
		  /* 82091268h */ case    3:  		/* stw R12, <#[R1 - 8]> */
		/* 82091268h case    3:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82091268h case    3:*/		return 0x8209126C;
		  /* 8209126Ch */ case    4:  		/* bclr 20, CR0_LT */
		/* 8209126Ch case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209126Ch case    4:*/		return 0x82091270;
	}
	return 0x82091270;
} // Block from 8209125Ch-82091270h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82091270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091270);
		  /* 82091270h */ case    0:  		/* ld R14, <#[R1 - 152]> */
		/* 82091270h case    0:*/		cpu::mem::load64( regs, &regs.R14, (uint32)(regs.R1 + 0xFFFFFF68) );
		/* 82091270h case    0:*/		return 0x82091274;
	}
	return 0x82091274;
} // Block from 82091270h-82091274h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091274h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091274( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091274) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091274);
		  /* 82091274h */ case    0:  		/* ld R15, <#[R1 - 144]> */
		/* 82091274h case    0:*/		cpu::mem::load64( regs, &regs.R15, (uint32)(regs.R1 + 0xFFFFFF70) );
		/* 82091274h case    0:*/		return 0x82091278;
	}
	return 0x82091278;
} // Block from 82091274h-82091278h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091278);
		  /* 82091278h */ case    0:  		/* ld R16, <#[R1 - 136]> */
		/* 82091278h case    0:*/		cpu::mem::load64( regs, &regs.R16, (uint32)(regs.R1 + 0xFFFFFF78) );
		/* 82091278h case    0:*/		return 0x8209127C;
	}
	return 0x8209127C;
} // Block from 82091278h-8209127Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209127Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209127C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209127C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209127C);
		  /* 8209127Ch */ case    0:  		/* ld R17, <#[R1 - 128]> */
		/* 8209127Ch case    0:*/		cpu::mem::load64( regs, &regs.R17, (uint32)(regs.R1 + 0xFFFFFF80) );
		/* 8209127Ch case    0:*/		return 0x82091280;
	}
	return 0x82091280;
} // Block from 8209127Ch-82091280h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091280);
		  /* 82091280h */ case    0:  		/* ld R18, <#[R1 - 120]> */
		/* 82091280h case    0:*/		cpu::mem::load64( regs, &regs.R18, (uint32)(regs.R1 + 0xFFFFFF88) );
		/* 82091280h case    0:*/		return 0x82091284;
	}
	return 0x82091284;
} // Block from 82091280h-82091284h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091284);
		  /* 82091284h */ case    0:  		/* ld R19, <#[R1 - 112]> */
		/* 82091284h case    0:*/		cpu::mem::load64( regs, &regs.R19, (uint32)(regs.R1 + 0xFFFFFF90) );
		/* 82091284h case    0:*/		return 0x82091288;
	}
	return 0x82091288;
} // Block from 82091284h-82091288h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091288);
		  /* 82091288h */ case    0:  		/* ld R20, <#[R1 - 104]> */
		/* 82091288h case    0:*/		cpu::mem::load64( regs, &regs.R20, (uint32)(regs.R1 + 0xFFFFFF98) );
		/* 82091288h case    0:*/		return 0x8209128C;
	}
	return 0x8209128C;
} // Block from 82091288h-8209128Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209128Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209128C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209128C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209128C);
		  /* 8209128Ch */ case    0:  		/* ld R21, <#[R1 - 96]> */
		/* 8209128Ch case    0:*/		cpu::mem::load64( regs, &regs.R21, (uint32)(regs.R1 + 0xFFFFFFA0) );
		/* 8209128Ch case    0:*/		return 0x82091290;
	}
	return 0x82091290;
} // Block from 8209128Ch-82091290h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091290);
		  /* 82091290h */ case    0:  		/* ld R22, <#[R1 - 88]> */
		/* 82091290h case    0:*/		cpu::mem::load64( regs, &regs.R22, (uint32)(regs.R1 + 0xFFFFFFA8) );
		/* 82091290h case    0:*/		return 0x82091294;
	}
	return 0x82091294;
} // Block from 82091290h-82091294h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091294h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091294( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091294) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091294);
		  /* 82091294h */ case    0:  		/* ld R23, <#[R1 - 80]> */
		/* 82091294h case    0:*/		cpu::mem::load64( regs, &regs.R23, (uint32)(regs.R1 + 0xFFFFFFB0) );
		/* 82091294h case    0:*/		return 0x82091298;
	}
	return 0x82091298;
} // Block from 82091294h-82091298h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091298);
		  /* 82091298h */ case    0:  		/* ld R24, <#[R1 - 72]> */
		/* 82091298h case    0:*/		cpu::mem::load64( regs, &regs.R24, (uint32)(regs.R1 + 0xFFFFFFB8) );
		/* 82091298h case    0:*/		return 0x8209129C;
	}
	return 0x8209129C;
} // Block from 82091298h-8209129Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209129Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209129C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209129C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209129C);
		  /* 8209129Ch */ case    0:  		/* ld R25, <#[R1 - 64]> */
		/* 8209129Ch case    0:*/		cpu::mem::load64( regs, &regs.R25, (uint32)(regs.R1 + 0xFFFFFFC0) );
		/* 8209129Ch case    0:*/		return 0x820912A0;
	}
	return 0x820912A0;
} // Block from 8209129Ch-820912A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820912A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820912A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820912A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820912A0);
		  /* 820912A0h */ case    0:  		/* ld R26, <#[R1 - 56]> */
		/* 820912A0h case    0:*/		cpu::mem::load64( regs, &regs.R26, (uint32)(regs.R1 + 0xFFFFFFC8) );
		/* 820912A0h case    0:*/		return 0x820912A4;
	}
	return 0x820912A4;
} // Block from 820912A0h-820912A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820912A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820912A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820912A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820912A4);
		  /* 820912A4h */ case    0:  		/* ld R27, <#[R1 - 48]> */
		/* 820912A4h case    0:*/		cpu::mem::load64( regs, &regs.R27, (uint32)(regs.R1 + 0xFFFFFFD0) );
		/* 820912A4h case    0:*/		return 0x820912A8;
	}
	return 0x820912A8;
} // Block from 820912A4h-820912A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820912A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820912A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820912A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820912A8);
		  /* 820912A8h */ case    0:  		/* ld R28, <#[R1 - 40]> */
		/* 820912A8h case    0:*/		cpu::mem::load64( regs, &regs.R28, (uint32)(regs.R1 + 0xFFFFFFD8) );
		/* 820912A8h case    0:*/		return 0x820912AC;
	}
	return 0x820912AC;
} // Block from 820912A8h-820912ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820912ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820912AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820912AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820912AC);
		  /* 820912ACh */ case    0:  		/* ld R29, <#[R1 - 32]> */
		/* 820912ACh case    0:*/		cpu::mem::load64( regs, &regs.R29, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 820912ACh case    0:*/		return 0x820912B0;
		  /* 820912B0h */ case    1:  		/* ld R30, <#[R1 - 24]> */
		/* 820912B0h case    1:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820912B0h case    1:*/		return 0x820912B4;
		  /* 820912B4h */ case    2:  		/* ld R31, <#[R1 - 16]> */
		/* 820912B4h case    2:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820912B4h case    2:*/		return 0x820912B8;
		  /* 820912B8h */ case    3:  		/* lwz R12, <#[R1 - 8]> */
		/* 820912B8h case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820912B8h case    3:*/		return 0x820912BC;
		  /* 820912BCh */ case    4:  		/* mtspr LR, R12 */
		/* 820912BCh case    4:*/		regs.LR = regs.R12;
		/* 820912BCh case    4:*/		return 0x820912C0;
		  /* 820912C0h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820912C0h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820912C0h case    5:*/		return 0x820912C4;
	}
	return 0x820912C4;
} // Block from 820912ACh-820912C4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820912C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820912C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820912C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820912C4);
		  /* 820912C4h */ case    0:  		/* mtspr CTR, R4 */
		/* 820912C4h case    0:*/		regs.CTR = regs.R4;
		/* 820912C4h case    0:*/		return 0x820912C8;
		  /* 820912C8h */ case    1:  		/* mr R12, R5 */
		/* 820912C8h case    1:*/		regs.R12 = regs.R5;
		/* 820912C8h case    1:*/		return 0x820912CC;
		  /* 820912CCh */ case    2:  		/* bcctr 20, CR0_LT */
		/* 820912CCh case    2:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820912CCh case    2:*/		return 0x820912D0;
	}
	return 0x820912D0;
} // Block from 820912C4h-820912D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820912D0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820912D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820912D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820912D0);
		  /* 820912D0h */ case    0:  		/* mfspr R12, LR */
		/* 820912D0h case    0:*/		regs.R12 = regs.LR;
		/* 820912D0h case    0:*/		return 0x820912D4;
		  /* 820912D4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820912D4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820912D4h case    1:*/		return 0x820912D8;
		  /* 820912D8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820912D8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820912D8h case    2:*/		return 0x820912DC;
		  /* 820912DCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820912DCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820912DCh case    3:*/		return 0x820912E0;
		  /* 820912E0h */ case    4:  		/* mr R31, R3 */
		/* 820912E0h case    4:*/		regs.R31 = regs.R3;
		/* 820912E0h case    4:*/		return 0x820912E4;
		  /* 820912E4h */ case    5:  		/* bl 7788 */
		/* 820912E4h case    5:*/		regs.LR = 0x820912E8; return 0x82093150;
		/* 820912E4h case    5:*/		return 0x820912E8;
		  /* 820912E8h */ case    6:  		/* stw R31, <#[R3 + 20]> */
		/* 820912E8h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000014) );
		/* 820912E8h case    6:*/		return 0x820912EC;
		  /* 820912ECh */ case    7:  		/* addi R1, R1, 96 */
		/* 820912ECh case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820912ECh case    7:*/		return 0x820912F0;
		  /* 820912F0h */ case    8:  		/* lwz R12, <#[R1 - 8]> */
		/* 820912F0h case    8:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820912F0h case    8:*/		return 0x820912F4;
		  /* 820912F4h */ case    9:  		/* mtspr LR, R12 */
		/* 820912F4h case    9:*/		regs.LR = regs.R12;
		/* 820912F4h case    9:*/		return 0x820912F8;
		  /* 820912F8h */ case   10:  		/* ld R31, <#[R1 - 16]> */
		/* 820912F8h case   10:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820912F8h case   10:*/		return 0x820912FC;
		  /* 820912FCh */ case   11:  		/* bclr 20, CR0_LT */
		/* 820912FCh case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820912FCh case   11:*/		return 0x82091300;
	}
	return 0x82091300;
} // Block from 820912D0h-82091300h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82091300h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091300);
		  /* 82091300h */ case    0:  		/* mfspr R12, LR */
		/* 82091300h case    0:*/		regs.R12 = regs.LR;
		/* 82091300h case    0:*/		return 0x82091304;
		  /* 82091304h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82091304h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82091304h case    1:*/		return 0x82091308;
		  /* 82091308h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82091308h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82091308h case    2:*/		return 0x8209130C;
		  /* 8209130Ch */ case    3:  		/* bl 7748 */
		/* 8209130Ch case    3:*/		regs.LR = 0x82091310; return 0x82093150;
		/* 8209130Ch case    3:*/		return 0x82091310;
		  /* 82091310h */ case    4:  		/* lis R11, 3 */
		/* 82091310h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0x3);
		/* 82091310h case    4:*/		return 0x82091314;
		  /* 82091314h */ case    5:  		/* lwz R9, <#[R3 + 20]> */
		/* 82091314h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 82091314h case    5:*/		return 0x82091318;
		  /* 82091318h */ case    6:  		/* ori R11, R11, 17405 */
		/* 82091318h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x43FD);
		/* 82091318h case    6:*/		return 0x8209131C;
		  /* 8209131Ch */ case    7:  		/* mullw R11, R9, R11 */
		/* 8209131Ch case    7:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8209131Ch case    7:*/		return 0x82091320;
		  /* 82091320h */ case    8:  		/* addis R11, R11, 39 */
		/* 82091320h case    8:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R11,0x27);
		/* 82091320h case    8:*/		return 0x82091324;
		  /* 82091324h */ case    9:  		/* addi R11, R11, -24893 */
		/* 82091324h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF9EC3);
		/* 82091324h case    9:*/		return 0x82091328;
		  /* 82091328h */ case   10:  		/* stw R11, <#[R3 + 20]> */
		/* 82091328h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82091328h case   10:*/		return 0x8209132C;
		  /* 8209132Ch */ case   11:  		/* rlwinm R3, R11, 16, 17, 31 */
		/* 8209132Ch case   11:*/		cpu::op::rlwinm<0,16,17,31>(regs,&regs.R3,regs.R11);
		/* 8209132Ch case   11:*/		return 0x82091330;
		  /* 82091330h */ case   12:  		/* addi R1, R1, 96 */
		/* 82091330h case   12:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82091330h case   12:*/		return 0x82091334;
		  /* 82091334h */ case   13:  		/* lwz R12, <#[R1 - 8]> */
		/* 82091334h case   13:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82091334h case   13:*/		return 0x82091338;
		  /* 82091338h */ case   14:  		/* mtspr LR, R12 */
		/* 82091338h case   14:*/		regs.LR = regs.R12;
		/* 82091338h case   14:*/		return 0x8209133C;
		  /* 8209133Ch */ case   15:  		/* bclr 20, CR0_LT */
		/* 8209133Ch case   15:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209133Ch case   15:*/		return 0x82091340;
	}
	return 0x82091340;
} // Block from 82091300h-82091340h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82091340h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091340);
		  /* 82091340h */ case    0:  		/* addi R0, R5, 1 */
		/* 82091340h case    0:*/		cpu::op::addi<0>(regs,&regs.R0,regs.R5,0x1);
		/* 82091340h case    0:*/		return 0x82091344;
		  /* 82091344h */ case    1:  		/* mtspr CTR, R0 */
		/* 82091344h case    1:*/		regs.CTR = regs.R0;
		/* 82091344h case    1:*/		return 0x82091348;
		  /* 82091348h */ case    2:  		/* ori R6, R3, 0 */
		/* 82091348h case    2:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R3,0x0);
		/* 82091348h case    2:*/		return 0x8209134C;
		  /* 8209134Ch */ case    3:  		/* b 16 */
		/* 8209134Ch case    3:*/		return 0x8209135C;
		/* 8209134Ch case    3:*/		return 0x82091350;
		  /* 82091350h */ case    4:  		/* addi R5, R5, -1 */
		/* 82091350h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0xFFFFFFFF);
		/* 82091350h case    4:*/		return 0x82091354;
		  /* 82091354h */ case    5:  		/* stb R4, <#[R6]> */
		/* 82091354h case    5:*/		cpu::mem::store8( regs, regs.R4, (uint32)(regs.R6 + 0x00000000) );
		/* 82091354h case    5:*/		return 0x82091358;
		  /* 82091358h */ case    6:  		/* addi R6, R6, 1 */
		/* 82091358h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82091358h case    6:*/		return 0x8209135C;
	}
	return 0x8209135C;
} // Block from 82091340h-8209135Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209135Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209135C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209135C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209135C);
		  /* 8209135Ch */ case    0:  		/* andi. R0, R6, 3 */
		/* 8209135Ch case    0:*/		cpu::op::andi<1>(regs,&regs.R0,regs.R6,0x3);
		/* 8209135Ch case    0:*/		return 0x82091360;
		  /* 82091360h */ case    1:  		/* bc 0, CR0_EQ, -16 */
		/* 82091360h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 && !regs.CR[0].eq ) { return 0x82091350;  }
		/* 82091360h case    1:*/		return 0x82091364;
		  /* 82091364h */ case    2:  		/* rlwimi R4, R4, 8, 16, 23 */
		/* 82091364h case    2:*/		cpu::op::rlwimi<0,8,16,23>(regs,&regs.R4,regs.R4);
		/* 82091364h case    2:*/		return 0x82091368;
		  /* 82091368h */ case    3:  		/* rlwinm. R0, R5, 28, 4, 31 */
		/* 82091368h case    3:*/		cpu::op::rlwinm<1,28,4,31>(regs,&regs.R0,regs.R5);
		/* 82091368h case    3:*/		return 0x8209136C;
		  /* 8209136Ch */ case    4:  		/* rlwimi R4, R4, 16, 0, 15 */
		/* 8209136Ch case    4:*/		cpu::op::rlwimi<0,16,0,15>(regs,&regs.R4,regs.R4);
		/* 8209136Ch case    4:*/		return 0x82091370;
		  /* 82091370h */ case    5:  		/* bc 15, CR0_EQ, 32 */
		/* 82091370h case    5:*/		if ( regs.CR[0].eq ) { return 0x82091390;  }
		/* 82091370h case    5:*/		return 0x82091374;
		  /* 82091374h */ case    6:  		/* mtspr CTR, R0 */
		/* 82091374h case    6:*/		regs.CTR = regs.R0;
		/* 82091374h case    6:*/		return 0x82091378;
		  /* 82091378h */ case    7:  		/* stw R4, <#[R6]> */
		/* 82091378h case    7:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R6 + 0x00000000) );
		/* 82091378h case    7:*/		return 0x8209137C;
		  /* 8209137Ch */ case    8:  		/* stw R4, <#[R6 + 4]> */
		/* 8209137Ch case    8:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R6 + 0x00000004) );
		/* 8209137Ch case    8:*/		return 0x82091380;
		  /* 82091380h */ case    9:  		/* stw R4, <#[R6 + 8]> */
		/* 82091380h case    9:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R6 + 0x00000008) );
		/* 82091380h case    9:*/		return 0x82091384;
		  /* 82091384h */ case   10:  		/* stw R4, <#[R6 + 12]> */
		/* 82091384h case   10:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R6 + 0x0000000C) );
		/* 82091384h case   10:*/		return 0x82091388;
		  /* 82091388h */ case   11:  		/* addi R6, R6, 16 */
		/* 82091388h case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x10);
		/* 82091388h case   11:*/		return 0x8209138C;
		  /* 8209138Ch */ case   12:  		/* bc 25, CR0_LT, -20 */
		/* 8209138Ch case   12:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091378;  }
		/* 8209138Ch case   12:*/		return 0x82091390;
	}
	return 0x82091390;
} // Block from 8209135Ch-82091390h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82091390h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091390);
		  /* 82091390h */ case    0:  		/* rlwinm. R0, R5, 30, 30, 31 */
		/* 82091390h case    0:*/		cpu::op::rlwinm<1,30,30,31>(regs,&regs.R0,regs.R5);
		/* 82091390h case    0:*/		return 0x82091394;
		  /* 82091394h */ case    1:  		/* bc 14, CR0_EQ, 40 */
		/* 82091394h case    1:*/		if ( regs.CR[0].eq ) { return 0x820913BC;  }
		/* 82091394h case    1:*/		return 0x82091398;
		  /* 82091398h */ case    2:  		/* mtspr CTR, R0 */
		/* 82091398h case    2:*/		regs.CTR = regs.R0;
		/* 82091398h case    2:*/		return 0x8209139C;
		  /* 8209139Ch */ case    3:  		/* stw R4, <#[R6]> */
		/* 8209139Ch case    3:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R6 + 0x00000000) );
		/* 8209139Ch case    3:*/		return 0x820913A0;
		  /* 820913A0h */ case    4:  		/* addi R6, R6, 4 */
		/* 820913A0h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x4);
		/* 820913A0h case    4:*/		return 0x820913A4;
		  /* 820913A4h */ case    5:  		/* bc 26, CR0_LT, 24 */
		/* 820913A4h case    5:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x820913BC;  }
		/* 820913A4h case    5:*/		return 0x820913A8;
		  /* 820913A8h */ case    6:  		/* stw R4, <#[R6]> */
		/* 820913A8h case    6:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R6 + 0x00000000) );
		/* 820913A8h case    6:*/		return 0x820913AC;
		  /* 820913ACh */ case    7:  		/* addi R6, R6, 4 */
		/* 820913ACh case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x4);
		/* 820913ACh case    7:*/		return 0x820913B0;
		  /* 820913B0h */ case    8:  		/* bc 26, CR0_LT, 12 */
		/* 820913B0h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x820913BC;  }
		/* 820913B0h case    8:*/		return 0x820913B4;
		  /* 820913B4h */ case    9:  		/* stw R4, <#[R6]> */
		/* 820913B4h case    9:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R6 + 0x00000000) );
		/* 820913B4h case    9:*/		return 0x820913B8;
		  /* 820913B8h */ case   10:  		/* addi R6, R6, 4 */
		/* 820913B8h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x4);
		/* 820913B8h case   10:*/		return 0x820913BC;
	}
	return 0x820913BC;
} // Block from 82091390h-820913BCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820913BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820913BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820913BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820913BC);
		  /* 820913BCh */ case    0:  		/* andi. R0, R5, 3 */
		/* 820913BCh case    0:*/		cpu::op::andi<1>(regs,&regs.R0,regs.R5,0x3);
		/* 820913BCh case    0:*/		return 0x820913C0;
		  /* 820913C0h */ case    1:  		/* mtspr CTR, R0 */
		/* 820913C0h case    1:*/		regs.CTR = regs.R0;
		/* 820913C0h case    1:*/		return 0x820913C4;
		  /* 820913C4h */ case    2:  		/* bclr 15, CR0_EQ */
		/* 820913C4h case    2:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 820913C4h case    2:*/		return 0x820913C8;
	}
	return 0x820913C8;
} // Block from 820913BCh-820913C8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820913C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820913C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820913C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820913C8);
		  /* 820913C8h */ case    0:  		/* stb R4, <#[R6]> */
		/* 820913C8h case    0:*/		cpu::mem::store8( regs, regs.R4, (uint32)(regs.R6 + 0x00000000) );
		/* 820913C8h case    0:*/		return 0x820913CC;
		  /* 820913CCh */ case    1:  		/* bclr 26, CR0_LT */
		/* 820913CCh case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return (uint32)regs.LR; }
		/* 820913CCh case    1:*/		return 0x820913D0;
	}
	return 0x820913D0;
} // Block from 820913C8h-820913D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820913D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820913D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820913D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820913D0);
		  /* 820913D0h */ case    0:  		/* stb R4, <#[R6 + 1]> */
		/* 820913D0h case    0:*/		cpu::mem::store8( regs, regs.R4, (uint32)(regs.R6 + 0x00000001) );
		/* 820913D0h case    0:*/		return 0x820913D4;
		  /* 820913D4h */ case    1:  		/* bclr 26, CR0_LT */
		/* 820913D4h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return (uint32)regs.LR; }
		/* 820913D4h case    1:*/		return 0x820913D8;
	}
	return 0x820913D8;
} // Block from 820913D0h-820913D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820913D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820913D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820913D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820913D8);
		  /* 820913D8h */ case    0:  		/* stb R4, <#[R6 + 2]> */
		/* 820913D8h case    0:*/		cpu::mem::store8( regs, regs.R4, (uint32)(regs.R6 + 0x00000002) );
		/* 820913D8h case    0:*/		return 0x820913DC;
		  /* 820913DCh */ case    1:  		/* bclr 20, CR0_LT */
		/* 820913DCh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820913DCh case    1:*/		return 0x820913E0;
	}
	return 0x820913E0;
} // Block from 820913D8h-820913E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820913E0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820913E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820913E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820913E0);
		  /* 820913E0h */ case    0:  		/* stfd FR14, <#[R12 - 144]> */
		/* 820913E0h case    0:*/		cpu::mem::store64f( regs, regs.FR14, (uint32)(regs.R12 + 0xFFFFFF70) );
		/* 820913E0h case    0:*/		return 0x820913E4;
		  /* 820913E4h */ case    1:  		/* stfd FR15, <#[R12 - 136]> */
		/* 820913E4h case    1:*/		cpu::mem::store64f( regs, regs.FR15, (uint32)(regs.R12 + 0xFFFFFF78) );
		/* 820913E4h case    1:*/		return 0x820913E8;
		  /* 820913E8h */ case    2:  		/* stfd FR16, <#[R12 - 128]> */
		/* 820913E8h case    2:*/		cpu::mem::store64f( regs, regs.FR16, (uint32)(regs.R12 + 0xFFFFFF80) );
		/* 820913E8h case    2:*/		return 0x820913EC;
		  /* 820913ECh */ case    3:  		/* stfd FR17, <#[R12 - 120]> */
		/* 820913ECh case    3:*/		cpu::mem::store64f( regs, regs.FR17, (uint32)(regs.R12 + 0xFFFFFF88) );
		/* 820913ECh case    3:*/		return 0x820913F0;
		  /* 820913F0h */ case    4:  		/* stfd FR18, <#[R12 - 112]> */
		/* 820913F0h case    4:*/		cpu::mem::store64f( regs, regs.FR18, (uint32)(regs.R12 + 0xFFFFFF90) );
		/* 820913F0h case    4:*/		return 0x820913F4;
		  /* 820913F4h */ case    5:  		/* stfd FR19, <#[R12 - 104]> */
		/* 820913F4h case    5:*/		cpu::mem::store64f( regs, regs.FR19, (uint32)(regs.R12 + 0xFFFFFF98) );
		/* 820913F4h case    5:*/		return 0x820913F8;
		  /* 820913F8h */ case    6:  		/* stfd FR20, <#[R12 - 96]> */
		/* 820913F8h case    6:*/		cpu::mem::store64f( regs, regs.FR20, (uint32)(regs.R12 + 0xFFFFFFA0) );
		/* 820913F8h case    6:*/		return 0x820913FC;
		  /* 820913FCh */ case    7:  		/* stfd FR21, <#[R12 - 88]> */
		/* 820913FCh case    7:*/		cpu::mem::store64f( regs, regs.FR21, (uint32)(regs.R12 + 0xFFFFFFA8) );
		/* 820913FCh case    7:*/		return 0x82091400;
		  /* 82091400h */ case    8:  		/* stfd FR22, <#[R12 - 80]> */
		/* 82091400h case    8:*/		cpu::mem::store64f( regs, regs.FR22, (uint32)(regs.R12 + 0xFFFFFFB0) );
		/* 82091400h case    8:*/		return 0x82091404;
	}
	return 0x82091404;
} // Block from 820913E0h-82091404h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82091404h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091404);
		  /* 82091404h */ case    0:  		/* stfd FR23, <#[R12 - 72]> */
		/* 82091404h case    0:*/		cpu::mem::store64f( regs, regs.FR23, (uint32)(regs.R12 + 0xFFFFFFB8) );
		/* 82091404h case    0:*/		return 0x82091408;
		  /* 82091408h */ case    1:  		/* stfd FR24, <#[R12 - 64]> */
		/* 82091408h case    1:*/		cpu::mem::store64f( regs, regs.FR24, (uint32)(regs.R12 + 0xFFFFFFC0) );
		/* 82091408h case    1:*/		return 0x8209140C;
		  /* 8209140Ch */ case    2:  		/* stfd FR25, <#[R12 - 56]> */
		/* 8209140Ch case    2:*/		cpu::mem::store64f( regs, regs.FR25, (uint32)(regs.R12 + 0xFFFFFFC8) );
		/* 8209140Ch case    2:*/		return 0x82091410;
	}
	return 0x82091410;
} // Block from 82091404h-82091410h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82091410h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091410);
		  /* 82091410h */ case    0:  		/* stfd FR26, <#[R12 - 48]> */
		/* 82091410h case    0:*/		cpu::mem::store64f( regs, regs.FR26, (uint32)(regs.R12 + 0xFFFFFFD0) );
		/* 82091410h case    0:*/		return 0x82091414;
	}
	return 0x82091414;
} // Block from 82091410h-82091414h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091414h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091414( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091414) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091414);
		  /* 82091414h */ case    0:  		/* stfd FR27, <#[R12 - 40]> */
		/* 82091414h case    0:*/		cpu::mem::store64f( regs, regs.FR27, (uint32)(regs.R12 + 0xFFFFFFD8) );
		/* 82091414h case    0:*/		return 0x82091418;
	}
	return 0x82091418;
} // Block from 82091414h-82091418h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091418h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091418);
		  /* 82091418h */ case    0:  		/* stfd FR28, <#[R12 - 32]> */
		/* 82091418h case    0:*/		cpu::mem::store64f( regs, regs.FR28, (uint32)(regs.R12 + 0xFFFFFFE0) );
		/* 82091418h case    0:*/		return 0x8209141C;
		  /* 8209141Ch */ case    1:  		/* stfd FR29, <#[R12 - 24]> */
		/* 8209141Ch case    1:*/		cpu::mem::store64f( regs, regs.FR29, (uint32)(regs.R12 + 0xFFFFFFE8) );
		/* 8209141Ch case    1:*/		return 0x82091420;
		  /* 82091420h */ case    2:  		/* stfd FR30, <#[R12 - 16]> */
		/* 82091420h case    2:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R12 + 0xFFFFFFF0) );
		/* 82091420h case    2:*/		return 0x82091424;
		  /* 82091424h */ case    3:  		/* stfd FR31, <#[R12 - 8]> */
		/* 82091424h case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R12 + 0xFFFFFFF8) );
		/* 82091424h case    3:*/		return 0x82091428;
		  /* 82091428h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82091428h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82091428h case    4:*/		return 0x8209142C;
	}
	return 0x8209142C;
} // Block from 82091418h-8209142Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209142Ch
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209142C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209142C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209142C);
		  /* 8209142Ch */ case    0:  		/* lfd FR14, <#[R12 - 144]> */
		/* 8209142Ch case    0:*/		cpu::mem::load64f( regs, &regs.FR14, (uint32)(regs.R12 + 0xFFFFFF70) );
		/* 8209142Ch case    0:*/		return 0x82091430;
		  /* 82091430h */ case    1:  		/* lfd FR15, <#[R12 - 136]> */
		/* 82091430h case    1:*/		cpu::mem::load64f( regs, &regs.FR15, (uint32)(regs.R12 + 0xFFFFFF78) );
		/* 82091430h case    1:*/		return 0x82091434;
		  /* 82091434h */ case    2:  		/* lfd FR16, <#[R12 - 128]> */
		/* 82091434h case    2:*/		cpu::mem::load64f( regs, &regs.FR16, (uint32)(regs.R12 + 0xFFFFFF80) );
		/* 82091434h case    2:*/		return 0x82091438;
		  /* 82091438h */ case    3:  		/* lfd FR17, <#[R12 - 120]> */
		/* 82091438h case    3:*/		cpu::mem::load64f( regs, &regs.FR17, (uint32)(regs.R12 + 0xFFFFFF88) );
		/* 82091438h case    3:*/		return 0x8209143C;
		  /* 8209143Ch */ case    4:  		/* lfd FR18, <#[R12 - 112]> */
		/* 8209143Ch case    4:*/		cpu::mem::load64f( regs, &regs.FR18, (uint32)(regs.R12 + 0xFFFFFF90) );
		/* 8209143Ch case    4:*/		return 0x82091440;
		  /* 82091440h */ case    5:  		/* lfd FR19, <#[R12 - 104]> */
		/* 82091440h case    5:*/		cpu::mem::load64f( regs, &regs.FR19, (uint32)(regs.R12 + 0xFFFFFF98) );
		/* 82091440h case    5:*/		return 0x82091444;
		  /* 82091444h */ case    6:  		/* lfd FR20, <#[R12 - 96]> */
		/* 82091444h case    6:*/		cpu::mem::load64f( regs, &regs.FR20, (uint32)(regs.R12 + 0xFFFFFFA0) );
		/* 82091444h case    6:*/		return 0x82091448;
		  /* 82091448h */ case    7:  		/* lfd FR21, <#[R12 - 88]> */
		/* 82091448h case    7:*/		cpu::mem::load64f( regs, &regs.FR21, (uint32)(regs.R12 + 0xFFFFFFA8) );
		/* 82091448h case    7:*/		return 0x8209144C;
		  /* 8209144Ch */ case    8:  		/* lfd FR22, <#[R12 - 80]> */
		/* 8209144Ch case    8:*/		cpu::mem::load64f( regs, &regs.FR22, (uint32)(regs.R12 + 0xFFFFFFB0) );
		/* 8209144Ch case    8:*/		return 0x82091450;
	}
	return 0x82091450;
} // Block from 8209142Ch-82091450h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82091450h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091450);
		  /* 82091450h */ case    0:  		/* lfd FR23, <#[R12 - 72]> */
		/* 82091450h case    0:*/		cpu::mem::load64f( regs, &regs.FR23, (uint32)(regs.R12 + 0xFFFFFFB8) );
		/* 82091450h case    0:*/		return 0x82091454;
		  /* 82091454h */ case    1:  		/* lfd FR24, <#[R12 - 64]> */
		/* 82091454h case    1:*/		cpu::mem::load64f( regs, &regs.FR24, (uint32)(regs.R12 + 0xFFFFFFC0) );
		/* 82091454h case    1:*/		return 0x82091458;
		  /* 82091458h */ case    2:  		/* lfd FR25, <#[R12 - 56]> */
		/* 82091458h case    2:*/		cpu::mem::load64f( regs, &regs.FR25, (uint32)(regs.R12 + 0xFFFFFFC8) );
		/* 82091458h case    2:*/		return 0x8209145C;
	}
	return 0x8209145C;
} // Block from 82091450h-8209145Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209145Ch
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209145C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209145C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209145C);
		  /* 8209145Ch */ case    0:  		/* lfd FR26, <#[R12 - 48]> */
		/* 8209145Ch case    0:*/		cpu::mem::load64f( regs, &regs.FR26, (uint32)(regs.R12 + 0xFFFFFFD0) );
		/* 8209145Ch case    0:*/		return 0x82091460;
	}
	return 0x82091460;
} // Block from 8209145Ch-82091460h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091460h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091460);
		  /* 82091460h */ case    0:  		/* lfd FR27, <#[R12 - 40]> */
		/* 82091460h case    0:*/		cpu::mem::load64f( regs, &regs.FR27, (uint32)(regs.R12 + 0xFFFFFFD8) );
		/* 82091460h case    0:*/		return 0x82091464;
	}
	return 0x82091464;
} // Block from 82091460h-82091464h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091464h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091464( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091464) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091464);
		  /* 82091464h */ case    0:  		/* lfd FR28, <#[R12 - 32]> */
		/* 82091464h case    0:*/		cpu::mem::load64f( regs, &regs.FR28, (uint32)(regs.R12 + 0xFFFFFFE0) );
		/* 82091464h case    0:*/		return 0x82091468;
		  /* 82091468h */ case    1:  		/* lfd FR29, <#[R12 - 24]> */
		/* 82091468h case    1:*/		cpu::mem::load64f( regs, &regs.FR29, (uint32)(regs.R12 + 0xFFFFFFE8) );
		/* 82091468h case    1:*/		return 0x8209146C;
		  /* 8209146Ch */ case    2:  		/* lfd FR30, <#[R12 - 16]> */
		/* 8209146Ch case    2:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R12 + 0xFFFFFFF0) );
		/* 8209146Ch case    2:*/		return 0x82091470;
		  /* 82091470h */ case    3:  		/* lfd FR31, <#[R12 - 8]> */
		/* 82091470h case    3:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R12 + 0xFFFFFFF8) );
		/* 82091470h case    3:*/		return 0x82091474;
		  /* 82091474h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82091474h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82091474h case    4:*/		return 0x82091478;
	}
	return 0x82091478;
} // Block from 82091464h-82091478h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82091478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091478);
		  /* 82091478h */ case    0:  		/* nop */
		/* 82091478h case    0:*/		cpu::op::nop();
		/* 82091478h case    0:*/		return 0x8209147C;
		  /* 8209147Ch */ case    1:  		/* nop */
		/* 8209147Ch case    1:*/		cpu::op::nop();
		/* 8209147Ch case    1:*/		return 0x82091480;
	}
	return 0x82091480;
} // Block from 82091478h-82091480h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82091480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091480);
		  /* 82091480h */ case    0:  		/* li R11, -288 */
		/* 82091480h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFEE0);
		/* 82091480h case    0:*/		return 0x82091484;
		  /* 82091484h */ case    1:  		/* stvx VR14, <#[R11 + R12]> */
		/* 82091484h case    1:*/		cpu::mem::stvx( regs, regs.VR14, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091484h case    1:*/		return 0x82091488;
		  /* 82091488h */ case    2:  		/* li R11, -272 */
		/* 82091488h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFEF0);
		/* 82091488h case    2:*/		return 0x8209148C;
		  /* 8209148Ch */ case    3:  		/* stvx VR15, <#[R11 + R12]> */
		/* 8209148Ch case    3:*/		cpu::mem::stvx( regs, regs.VR15, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 8209148Ch case    3:*/		return 0x82091490;
		  /* 82091490h */ case    4:  		/* li R11, -256 */
		/* 82091490h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF00);
		/* 82091490h case    4:*/		return 0x82091494;
		  /* 82091494h */ case    5:  		/* stvx VR16, <#[R11 + R12]> */
		/* 82091494h case    5:*/		cpu::mem::stvx( regs, regs.VR16, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091494h case    5:*/		return 0x82091498;
		  /* 82091498h */ case    6:  		/* li R11, -240 */
		/* 82091498h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF10);
		/* 82091498h case    6:*/		return 0x8209149C;
		  /* 8209149Ch */ case    7:  		/* stvx VR17, <#[R11 + R12]> */
		/* 8209149Ch case    7:*/		cpu::mem::stvx( regs, regs.VR17, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 8209149Ch case    7:*/		return 0x820914A0;
		  /* 820914A0h */ case    8:  		/* li R11, -224 */
		/* 820914A0h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF20);
		/* 820914A0h case    8:*/		return 0x820914A4;
		  /* 820914A4h */ case    9:  		/* stvx VR18, <#[R11 + R12]> */
		/* 820914A4h case    9:*/		cpu::mem::stvx( regs, regs.VR18, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820914A4h case    9:*/		return 0x820914A8;
		  /* 820914A8h */ case   10:  		/* li R11, -208 */
		/* 820914A8h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF30);
		/* 820914A8h case   10:*/		return 0x820914AC;
		  /* 820914ACh */ case   11:  		/* stvx VR19, <#[R11 + R12]> */
		/* 820914ACh case   11:*/		cpu::mem::stvx( regs, regs.VR19, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820914ACh case   11:*/		return 0x820914B0;
		  /* 820914B0h */ case   12:  		/* li R11, -192 */
		/* 820914B0h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF40);
		/* 820914B0h case   12:*/		return 0x820914B4;
		  /* 820914B4h */ case   13:  		/* stvx VR20, <#[R11 + R12]> */
		/* 820914B4h case   13:*/		cpu::mem::stvx( regs, regs.VR20, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820914B4h case   13:*/		return 0x820914B8;
		  /* 820914B8h */ case   14:  		/* li R11, -176 */
		/* 820914B8h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF50);
		/* 820914B8h case   14:*/		return 0x820914BC;
		  /* 820914BCh */ case   15:  		/* stvx VR21, <#[R11 + R12]> */
		/* 820914BCh case   15:*/		cpu::mem::stvx( regs, regs.VR21, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820914BCh case   15:*/		return 0x820914C0;
		  /* 820914C0h */ case   16:  		/* li R11, -160 */
		/* 820914C0h case   16:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF60);
		/* 820914C0h case   16:*/		return 0x820914C4;
		  /* 820914C4h */ case   17:  		/* stvx VR22, <#[R11 + R12]> */
		/* 820914C4h case   17:*/		cpu::mem::stvx( regs, regs.VR22, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820914C4h case   17:*/		return 0x820914C8;
		  /* 820914C8h */ case   18:  		/* li R11, -144 */
		/* 820914C8h case   18:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF70);
		/* 820914C8h case   18:*/		return 0x820914CC;
		  /* 820914CCh */ case   19:  		/* stvx VR23, <#[R11 + R12]> */
		/* 820914CCh case   19:*/		cpu::mem::stvx( regs, regs.VR23, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820914CCh case   19:*/		return 0x820914D0;
		  /* 820914D0h */ case   20:  		/* li R11, -128 */
		/* 820914D0h case   20:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF80);
		/* 820914D0h case   20:*/		return 0x820914D4;
		  /* 820914D4h */ case   21:  		/* stvx VR24, <#[R11 + R12]> */
		/* 820914D4h case   21:*/		cpu::mem::stvx( regs, regs.VR24, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820914D4h case   21:*/		return 0x820914D8;
		  /* 820914D8h */ case   22:  		/* li R11, -112 */
		/* 820914D8h case   22:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF90);
		/* 820914D8h case   22:*/		return 0x820914DC;
		  /* 820914DCh */ case   23:  		/* stvx VR25, <#[R11 + R12]> */
		/* 820914DCh case   23:*/		cpu::mem::stvx( regs, regs.VR25, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820914DCh case   23:*/		return 0x820914E0;
		  /* 820914E0h */ case   24:  		/* li R11, -96 */
		/* 820914E0h case   24:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFA0);
		/* 820914E0h case   24:*/		return 0x820914E4;
		  /* 820914E4h */ case   25:  		/* stvx VR26, <#[R11 + R12]> */
		/* 820914E4h case   25:*/		cpu::mem::stvx( regs, regs.VR26, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820914E4h case   25:*/		return 0x820914E8;
		  /* 820914E8h */ case   26:  		/* li R11, -80 */
		/* 820914E8h case   26:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFB0);
		/* 820914E8h case   26:*/		return 0x820914EC;
		  /* 820914ECh */ case   27:  		/* stvx VR27, <#[R11 + R12]> */
		/* 820914ECh case   27:*/		cpu::mem::stvx( regs, regs.VR27, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820914ECh case   27:*/		return 0x820914F0;
		  /* 820914F0h */ case   28:  		/* li R11, -64 */
		/* 820914F0h case   28:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFC0);
		/* 820914F0h case   28:*/		return 0x820914F4;
		  /* 820914F4h */ case   29:  		/* stvx VR28, <#[R11 + R12]> */
		/* 820914F4h case   29:*/		cpu::mem::stvx( regs, regs.VR28, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820914F4h case   29:*/		return 0x820914F8;
		  /* 820914F8h */ case   30:  		/* li R11, -48 */
		/* 820914F8h case   30:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFD0);
		/* 820914F8h case   30:*/		return 0x820914FC;
		  /* 820914FCh */ case   31:  		/* stvx VR29, <#[R11 + R12]> */
		/* 820914FCh case   31:*/		cpu::mem::stvx( regs, regs.VR29, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820914FCh case   31:*/		return 0x82091500;
		  /* 82091500h */ case   32:  		/* li R11, -32 */
		/* 82091500h case   32:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFE0);
		/* 82091500h case   32:*/		return 0x82091504;
		  /* 82091504h */ case   33:  		/* stvx VR30, <#[R11 + R12]> */
		/* 82091504h case   33:*/		cpu::mem::stvx( regs, regs.VR30, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091504h case   33:*/		return 0x82091508;
		  /* 82091508h */ case   34:  		/* li R11, -16 */
		/* 82091508h case   34:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFF0);
		/* 82091508h case   34:*/		return 0x8209150C;
		  /* 8209150Ch */ case   35:  		/* stvx VR31, <#[R11 + R12]> */
		/* 8209150Ch case   35:*/		cpu::mem::stvx( regs, regs.VR31, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 8209150Ch case   35:*/		return 0x82091510;
		  /* 82091510h */ case   36:  		/* bclr 20, CR0_LT */
		/* 82091510h case   36:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82091510h case   36:*/		return 0x82091514;
	}
	return 0x82091514;
} // Block from 82091480h-82091514h (37 instructions)

//////////////////////////////////////////////////////
// Block at 82091514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091514);
		  /* 82091514h */ case    0:  		/* li R11, -1024 */
		/* 82091514h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFC00);
		/* 82091514h case    0:*/		return 0x82091518;
		  /* 82091518h */ case    1:  		/* stvx VR64, <#[R11 + R12]> */
		/* 82091518h case    1:*/		cpu::mem::stvx( regs, regs.VR64, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091518h case    1:*/		return 0x8209151C;
		  /* 8209151Ch */ case    2:  		/* li R11, -1008 */
		/* 8209151Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFC10);
		/* 8209151Ch case    2:*/		return 0x82091520;
		  /* 82091520h */ case    3:  		/* stvx VR65, <#[R11 + R12]> */
		/* 82091520h case    3:*/		cpu::mem::stvx( regs, regs.VR65, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091520h case    3:*/		return 0x82091524;
		  /* 82091524h */ case    4:  		/* li R11, -992 */
		/* 82091524h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFC20);
		/* 82091524h case    4:*/		return 0x82091528;
		  /* 82091528h */ case    5:  		/* stvx VR66, <#[R11 + R12]> */
		/* 82091528h case    5:*/		cpu::mem::stvx( regs, regs.VR66, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091528h case    5:*/		return 0x8209152C;
		  /* 8209152Ch */ case    6:  		/* li R11, -976 */
		/* 8209152Ch case    6:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFC30);
		/* 8209152Ch case    6:*/		return 0x82091530;
		  /* 82091530h */ case    7:  		/* stvx VR67, <#[R11 + R12]> */
		/* 82091530h case    7:*/		cpu::mem::stvx( regs, regs.VR67, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091530h case    7:*/		return 0x82091534;
		  /* 82091534h */ case    8:  		/* li R11, -960 */
		/* 82091534h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFC40);
		/* 82091534h case    8:*/		return 0x82091538;
		  /* 82091538h */ case    9:  		/* stvx VR68, <#[R11 + R12]> */
		/* 82091538h case    9:*/		cpu::mem::stvx( regs, regs.VR68, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091538h case    9:*/		return 0x8209153C;
		  /* 8209153Ch */ case   10:  		/* li R11, -944 */
		/* 8209153Ch case   10:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFC50);
		/* 8209153Ch case   10:*/		return 0x82091540;
		  /* 82091540h */ case   11:  		/* stvx VR69, <#[R11 + R12]> */
		/* 82091540h case   11:*/		cpu::mem::stvx( regs, regs.VR69, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091540h case   11:*/		return 0x82091544;
		  /* 82091544h */ case   12:  		/* li R11, -928 */
		/* 82091544h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFC60);
		/* 82091544h case   12:*/		return 0x82091548;
		  /* 82091548h */ case   13:  		/* stvx VR70, <#[R11 + R12]> */
		/* 82091548h case   13:*/		cpu::mem::stvx( regs, regs.VR70, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091548h case   13:*/		return 0x8209154C;
		  /* 8209154Ch */ case   14:  		/* li R11, -912 */
		/* 8209154Ch case   14:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFC70);
		/* 8209154Ch case   14:*/		return 0x82091550;
		  /* 82091550h */ case   15:  		/* stvx VR71, <#[R11 + R12]> */
		/* 82091550h case   15:*/		cpu::mem::stvx( regs, regs.VR71, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091550h case   15:*/		return 0x82091554;
		  /* 82091554h */ case   16:  		/* li R11, -896 */
		/* 82091554h case   16:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFC80);
		/* 82091554h case   16:*/		return 0x82091558;
		  /* 82091558h */ case   17:  		/* stvx VR72, <#[R11 + R12]> */
		/* 82091558h case   17:*/		cpu::mem::stvx( regs, regs.VR72, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091558h case   17:*/		return 0x8209155C;
		  /* 8209155Ch */ case   18:  		/* li R11, -880 */
		/* 8209155Ch case   18:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFC90);
		/* 8209155Ch case   18:*/		return 0x82091560;
		  /* 82091560h */ case   19:  		/* stvx VR73, <#[R11 + R12]> */
		/* 82091560h case   19:*/		cpu::mem::stvx( regs, regs.VR73, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091560h case   19:*/		return 0x82091564;
		  /* 82091564h */ case   20:  		/* li R11, -864 */
		/* 82091564h case   20:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFCA0);
		/* 82091564h case   20:*/		return 0x82091568;
		  /* 82091568h */ case   21:  		/* stvx VR74, <#[R11 + R12]> */
		/* 82091568h case   21:*/		cpu::mem::stvx( regs, regs.VR74, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091568h case   21:*/		return 0x8209156C;
		  /* 8209156Ch */ case   22:  		/* li R11, -848 */
		/* 8209156Ch case   22:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFCB0);
		/* 8209156Ch case   22:*/		return 0x82091570;
		  /* 82091570h */ case   23:  		/* stvx VR75, <#[R11 + R12]> */
		/* 82091570h case   23:*/		cpu::mem::stvx( regs, regs.VR75, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091570h case   23:*/		return 0x82091574;
		  /* 82091574h */ case   24:  		/* li R11, -832 */
		/* 82091574h case   24:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFCC0);
		/* 82091574h case   24:*/		return 0x82091578;
		  /* 82091578h */ case   25:  		/* stvx VR76, <#[R11 + R12]> */
		/* 82091578h case   25:*/		cpu::mem::stvx( regs, regs.VR76, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091578h case   25:*/		return 0x8209157C;
		  /* 8209157Ch */ case   26:  		/* li R11, -816 */
		/* 8209157Ch case   26:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFCD0);
		/* 8209157Ch case   26:*/		return 0x82091580;
		  /* 82091580h */ case   27:  		/* stvx VR77, <#[R11 + R12]> */
		/* 82091580h case   27:*/		cpu::mem::stvx( regs, regs.VR77, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091580h case   27:*/		return 0x82091584;
		  /* 82091584h */ case   28:  		/* li R11, -800 */
		/* 82091584h case   28:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFCE0);
		/* 82091584h case   28:*/		return 0x82091588;
		  /* 82091588h */ case   29:  		/* stvx VR78, <#[R11 + R12]> */
		/* 82091588h case   29:*/		cpu::mem::stvx( regs, regs.VR78, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091588h case   29:*/		return 0x8209158C;
		  /* 8209158Ch */ case   30:  		/* li R11, -784 */
		/* 8209158Ch case   30:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFCF0);
		/* 8209158Ch case   30:*/		return 0x82091590;
		  /* 82091590h */ case   31:  		/* stvx VR79, <#[R11 + R12]> */
		/* 82091590h case   31:*/		cpu::mem::stvx( regs, regs.VR79, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091590h case   31:*/		return 0x82091594;
		  /* 82091594h */ case   32:  		/* li R11, -768 */
		/* 82091594h case   32:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFD00);
		/* 82091594h case   32:*/		return 0x82091598;
		  /* 82091598h */ case   33:  		/* stvx VR80, <#[R11 + R12]> */
		/* 82091598h case   33:*/		cpu::mem::stvx( regs, regs.VR80, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091598h case   33:*/		return 0x8209159C;
		  /* 8209159Ch */ case   34:  		/* li R11, -752 */
		/* 8209159Ch case   34:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFD10);
		/* 8209159Ch case   34:*/		return 0x820915A0;
		  /* 820915A0h */ case   35:  		/* stvx VR81, <#[R11 + R12]> */
		/* 820915A0h case   35:*/		cpu::mem::stvx( regs, regs.VR81, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820915A0h case   35:*/		return 0x820915A4;
		  /* 820915A4h */ case   36:  		/* li R11, -736 */
		/* 820915A4h case   36:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFD20);
		/* 820915A4h case   36:*/		return 0x820915A8;
		  /* 820915A8h */ case   37:  		/* stvx VR82, <#[R11 + R12]> */
		/* 820915A8h case   37:*/		cpu::mem::stvx( regs, regs.VR82, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820915A8h case   37:*/		return 0x820915AC;
		  /* 820915ACh */ case   38:  		/* li R11, -720 */
		/* 820915ACh case   38:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFD30);
		/* 820915ACh case   38:*/		return 0x820915B0;
		  /* 820915B0h */ case   39:  		/* stvx VR83, <#[R11 + R12]> */
		/* 820915B0h case   39:*/		cpu::mem::stvx( regs, regs.VR83, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820915B0h case   39:*/		return 0x820915B4;
		  /* 820915B4h */ case   40:  		/* li R11, -704 */
		/* 820915B4h case   40:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFD40);
		/* 820915B4h case   40:*/		return 0x820915B8;
		  /* 820915B8h */ case   41:  		/* stvx VR84, <#[R11 + R12]> */
		/* 820915B8h case   41:*/		cpu::mem::stvx( regs, regs.VR84, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820915B8h case   41:*/		return 0x820915BC;
		  /* 820915BCh */ case   42:  		/* li R11, -688 */
		/* 820915BCh case   42:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFD50);
		/* 820915BCh case   42:*/		return 0x820915C0;
		  /* 820915C0h */ case   43:  		/* stvx VR85, <#[R11 + R12]> */
		/* 820915C0h case   43:*/		cpu::mem::stvx( regs, regs.VR85, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820915C0h case   43:*/		return 0x820915C4;
		  /* 820915C4h */ case   44:  		/* li R11, -672 */
		/* 820915C4h case   44:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFD60);
		/* 820915C4h case   44:*/		return 0x820915C8;
		  /* 820915C8h */ case   45:  		/* stvx VR86, <#[R11 + R12]> */
		/* 820915C8h case   45:*/		cpu::mem::stvx( regs, regs.VR86, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820915C8h case   45:*/		return 0x820915CC;
		  /* 820915CCh */ case   46:  		/* li R11, -656 */
		/* 820915CCh case   46:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFD70);
		/* 820915CCh case   46:*/		return 0x820915D0;
		  /* 820915D0h */ case   47:  		/* stvx VR87, <#[R11 + R12]> */
		/* 820915D0h case   47:*/		cpu::mem::stvx( regs, regs.VR87, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820915D0h case   47:*/		return 0x820915D4;
		  /* 820915D4h */ case   48:  		/* li R11, -640 */
		/* 820915D4h case   48:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFD80);
		/* 820915D4h case   48:*/		return 0x820915D8;
		  /* 820915D8h */ case   49:  		/* stvx VR88, <#[R11 + R12]> */
		/* 820915D8h case   49:*/		cpu::mem::stvx( regs, regs.VR88, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820915D8h case   49:*/		return 0x820915DC;
		  /* 820915DCh */ case   50:  		/* li R11, -624 */
		/* 820915DCh case   50:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFD90);
		/* 820915DCh case   50:*/		return 0x820915E0;
		  /* 820915E0h */ case   51:  		/* stvx VR89, <#[R11 + R12]> */
		/* 820915E0h case   51:*/		cpu::mem::stvx( regs, regs.VR89, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820915E0h case   51:*/		return 0x820915E4;
		  /* 820915E4h */ case   52:  		/* li R11, -608 */
		/* 820915E4h case   52:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFDA0);
		/* 820915E4h case   52:*/		return 0x820915E8;
		  /* 820915E8h */ case   53:  		/* stvx VR90, <#[R11 + R12]> */
		/* 820915E8h case   53:*/		cpu::mem::stvx( regs, regs.VR90, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820915E8h case   53:*/		return 0x820915EC;
		  /* 820915ECh */ case   54:  		/* li R11, -592 */
		/* 820915ECh case   54:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFDB0);
		/* 820915ECh case   54:*/		return 0x820915F0;
		  /* 820915F0h */ case   55:  		/* stvx VR91, <#[R11 + R12]> */
		/* 820915F0h case   55:*/		cpu::mem::stvx( regs, regs.VR91, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820915F0h case   55:*/		return 0x820915F4;
		  /* 820915F4h */ case   56:  		/* li R11, -576 */
		/* 820915F4h case   56:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFDC0);
		/* 820915F4h case   56:*/		return 0x820915F8;
		  /* 820915F8h */ case   57:  		/* stvx VR92, <#[R11 + R12]> */
		/* 820915F8h case   57:*/		cpu::mem::stvx( regs, regs.VR92, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820915F8h case   57:*/		return 0x820915FC;
		  /* 820915FCh */ case   58:  		/* li R11, -560 */
		/* 820915FCh case   58:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFDD0);
		/* 820915FCh case   58:*/		return 0x82091600;
		  /* 82091600h */ case   59:  		/* stvx VR93, <#[R11 + R12]> */
		/* 82091600h case   59:*/		cpu::mem::stvx( regs, regs.VR93, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091600h case   59:*/		return 0x82091604;
		  /* 82091604h */ case   60:  		/* li R11, -544 */
		/* 82091604h case   60:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFDE0);
		/* 82091604h case   60:*/		return 0x82091608;
		  /* 82091608h */ case   61:  		/* stvx VR94, <#[R11 + R12]> */
		/* 82091608h case   61:*/		cpu::mem::stvx( regs, regs.VR94, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091608h case   61:*/		return 0x8209160C;
		  /* 8209160Ch */ case   62:  		/* li R11, -528 */
		/* 8209160Ch case   62:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFDF0);
		/* 8209160Ch case   62:*/		return 0x82091610;
		  /* 82091610h */ case   63:  		/* stvx VR95, <#[R11 + R12]> */
		/* 82091610h case   63:*/		cpu::mem::stvx( regs, regs.VR95, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091610h case   63:*/		return 0x82091614;
		  /* 82091614h */ case   64:  		/* li R11, -512 */
		/* 82091614h case   64:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFE00);
		/* 82091614h case   64:*/		return 0x82091618;
		  /* 82091618h */ case   65:  		/* stvx VR96, <#[R11 + R12]> */
		/* 82091618h case   65:*/		cpu::mem::stvx( regs, regs.VR96, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091618h case   65:*/		return 0x8209161C;
		  /* 8209161Ch */ case   66:  		/* li R11, -496 */
		/* 8209161Ch case   66:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFE10);
		/* 8209161Ch case   66:*/		return 0x82091620;
		  /* 82091620h */ case   67:  		/* stvx VR97, <#[R11 + R12]> */
		/* 82091620h case   67:*/		cpu::mem::stvx( regs, regs.VR97, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091620h case   67:*/		return 0x82091624;
		  /* 82091624h */ case   68:  		/* li R11, -480 */
		/* 82091624h case   68:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFE20);
		/* 82091624h case   68:*/		return 0x82091628;
		  /* 82091628h */ case   69:  		/* stvx VR98, <#[R11 + R12]> */
		/* 82091628h case   69:*/		cpu::mem::stvx( regs, regs.VR98, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091628h case   69:*/		return 0x8209162C;
		  /* 8209162Ch */ case   70:  		/* li R11, -464 */
		/* 8209162Ch case   70:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFE30);
		/* 8209162Ch case   70:*/		return 0x82091630;
		  /* 82091630h */ case   71:  		/* stvx VR99, <#[R11 + R12]> */
		/* 82091630h case   71:*/		cpu::mem::stvx( regs, regs.VR99, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091630h case   71:*/		return 0x82091634;
		  /* 82091634h */ case   72:  		/* li R11, -448 */
		/* 82091634h case   72:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFE40);
		/* 82091634h case   72:*/		return 0x82091638;
		  /* 82091638h */ case   73:  		/* stvx VR100, <#[R11 + R12]> */
		/* 82091638h case   73:*/		cpu::mem::stvx( regs, regs.VR100, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091638h case   73:*/		return 0x8209163C;
		  /* 8209163Ch */ case   74:  		/* li R11, -432 */
		/* 8209163Ch case   74:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFE50);
		/* 8209163Ch case   74:*/		return 0x82091640;
		  /* 82091640h */ case   75:  		/* stvx VR101, <#[R11 + R12]> */
		/* 82091640h case   75:*/		cpu::mem::stvx( regs, regs.VR101, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091640h case   75:*/		return 0x82091644;
		  /* 82091644h */ case   76:  		/* li R11, -416 */
		/* 82091644h case   76:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFE60);
		/* 82091644h case   76:*/		return 0x82091648;
		  /* 82091648h */ case   77:  		/* stvx VR102, <#[R11 + R12]> */
		/* 82091648h case   77:*/		cpu::mem::stvx( regs, regs.VR102, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091648h case   77:*/		return 0x8209164C;
		  /* 8209164Ch */ case   78:  		/* li R11, -400 */
		/* 8209164Ch case   78:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFE70);
		/* 8209164Ch case   78:*/		return 0x82091650;
		  /* 82091650h */ case   79:  		/* stvx VR103, <#[R11 + R12]> */
		/* 82091650h case   79:*/		cpu::mem::stvx( regs, regs.VR103, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091650h case   79:*/		return 0x82091654;
		  /* 82091654h */ case   80:  		/* li R11, -384 */
		/* 82091654h case   80:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFE80);
		/* 82091654h case   80:*/		return 0x82091658;
		  /* 82091658h */ case   81:  		/* stvx VR104, <#[R11 + R12]> */
		/* 82091658h case   81:*/		cpu::mem::stvx( regs, regs.VR104, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091658h case   81:*/		return 0x8209165C;
		  /* 8209165Ch */ case   82:  		/* li R11, -368 */
		/* 8209165Ch case   82:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFE90);
		/* 8209165Ch case   82:*/		return 0x82091660;
		  /* 82091660h */ case   83:  		/* stvx VR105, <#[R11 + R12]> */
		/* 82091660h case   83:*/		cpu::mem::stvx( regs, regs.VR105, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091660h case   83:*/		return 0x82091664;
		  /* 82091664h */ case   84:  		/* li R11, -352 */
		/* 82091664h case   84:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFEA0);
		/* 82091664h case   84:*/		return 0x82091668;
		  /* 82091668h */ case   85:  		/* stvx VR106, <#[R11 + R12]> */
		/* 82091668h case   85:*/		cpu::mem::stvx( regs, regs.VR106, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091668h case   85:*/		return 0x8209166C;
		  /* 8209166Ch */ case   86:  		/* li R11, -336 */
		/* 8209166Ch case   86:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFEB0);
		/* 8209166Ch case   86:*/		return 0x82091670;
		  /* 82091670h */ case   87:  		/* stvx VR107, <#[R11 + R12]> */
		/* 82091670h case   87:*/		cpu::mem::stvx( regs, regs.VR107, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091670h case   87:*/		return 0x82091674;
		  /* 82091674h */ case   88:  		/* li R11, -320 */
		/* 82091674h case   88:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFEC0);
		/* 82091674h case   88:*/		return 0x82091678;
		  /* 82091678h */ case   89:  		/* stvx VR108, <#[R11 + R12]> */
		/* 82091678h case   89:*/		cpu::mem::stvx( regs, regs.VR108, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091678h case   89:*/		return 0x8209167C;
		  /* 8209167Ch */ case   90:  		/* li R11, -304 */
		/* 8209167Ch case   90:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFED0);
		/* 8209167Ch case   90:*/		return 0x82091680;
		  /* 82091680h */ case   91:  		/* stvx VR109, <#[R11 + R12]> */
		/* 82091680h case   91:*/		cpu::mem::stvx( regs, regs.VR109, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091680h case   91:*/		return 0x82091684;
		  /* 82091684h */ case   92:  		/* li R11, -288 */
		/* 82091684h case   92:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFEE0);
		/* 82091684h case   92:*/		return 0x82091688;
		  /* 82091688h */ case   93:  		/* stvx VR110, <#[R11 + R12]> */
		/* 82091688h case   93:*/		cpu::mem::stvx( regs, regs.VR110, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091688h case   93:*/		return 0x8209168C;
		  /* 8209168Ch */ case   94:  		/* li R11, -272 */
		/* 8209168Ch case   94:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFEF0);
		/* 8209168Ch case   94:*/		return 0x82091690;
		  /* 82091690h */ case   95:  		/* stvx VR111, <#[R11 + R12]> */
		/* 82091690h case   95:*/		cpu::mem::stvx( regs, regs.VR111, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091690h case   95:*/		return 0x82091694;
		  /* 82091694h */ case   96:  		/* li R11, -256 */
		/* 82091694h case   96:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF00);
		/* 82091694h case   96:*/		return 0x82091698;
		  /* 82091698h */ case   97:  		/* stvx VR112, <#[R11 + R12]> */
		/* 82091698h case   97:*/		cpu::mem::stvx( regs, regs.VR112, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091698h case   97:*/		return 0x8209169C;
		  /* 8209169Ch */ case   98:  		/* li R11, -240 */
		/* 8209169Ch case   98:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF10);
		/* 8209169Ch case   98:*/		return 0x820916A0;
		  /* 820916A0h */ case   99:  		/* stvx VR113, <#[R11 + R12]> */
		/* 820916A0h case   99:*/		cpu::mem::stvx( regs, regs.VR113, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820916A0h case   99:*/		return 0x820916A4;
		  /* 820916A4h */ case  100:  		/* li R11, -224 */
		/* 820916A4h case  100:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF20);
		/* 820916A4h case  100:*/		return 0x820916A8;
		  /* 820916A8h */ case  101:  		/* stvx VR114, <#[R11 + R12]> */
		/* 820916A8h case  101:*/		cpu::mem::stvx( regs, regs.VR114, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820916A8h case  101:*/		return 0x820916AC;
		  /* 820916ACh */ case  102:  		/* li R11, -208 */
		/* 820916ACh case  102:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF30);
		/* 820916ACh case  102:*/		return 0x820916B0;
		  /* 820916B0h */ case  103:  		/* stvx VR115, <#[R11 + R12]> */
		/* 820916B0h case  103:*/		cpu::mem::stvx( regs, regs.VR115, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820916B0h case  103:*/		return 0x820916B4;
		  /* 820916B4h */ case  104:  		/* li R11, -192 */
		/* 820916B4h case  104:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF40);
		/* 820916B4h case  104:*/		return 0x820916B8;
		  /* 820916B8h */ case  105:  		/* stvx VR116, <#[R11 + R12]> */
		/* 820916B8h case  105:*/		cpu::mem::stvx( regs, regs.VR116, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820916B8h case  105:*/		return 0x820916BC;
		  /* 820916BCh */ case  106:  		/* li R11, -176 */
		/* 820916BCh case  106:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF50);
		/* 820916BCh case  106:*/		return 0x820916C0;
		  /* 820916C0h */ case  107:  		/* stvx VR117, <#[R11 + R12]> */
		/* 820916C0h case  107:*/		cpu::mem::stvx( regs, regs.VR117, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820916C0h case  107:*/		return 0x820916C4;
		  /* 820916C4h */ case  108:  		/* li R11, -160 */
		/* 820916C4h case  108:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF60);
		/* 820916C4h case  108:*/		return 0x820916C8;
		  /* 820916C8h */ case  109:  		/* stvx VR118, <#[R11 + R12]> */
		/* 820916C8h case  109:*/		cpu::mem::stvx( regs, regs.VR118, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820916C8h case  109:*/		return 0x820916CC;
		  /* 820916CCh */ case  110:  		/* li R11, -144 */
		/* 820916CCh case  110:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF70);
		/* 820916CCh case  110:*/		return 0x820916D0;
		  /* 820916D0h */ case  111:  		/* stvx VR119, <#[R11 + R12]> */
		/* 820916D0h case  111:*/		cpu::mem::stvx( regs, regs.VR119, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820916D0h case  111:*/		return 0x820916D4;
		  /* 820916D4h */ case  112:  		/* li R11, -128 */
		/* 820916D4h case  112:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF80);
		/* 820916D4h case  112:*/		return 0x820916D8;
		  /* 820916D8h */ case  113:  		/* stvx VR120, <#[R11 + R12]> */
		/* 820916D8h case  113:*/		cpu::mem::stvx( regs, regs.VR120, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820916D8h case  113:*/		return 0x820916DC;
		  /* 820916DCh */ case  114:  		/* li R11, -112 */
		/* 820916DCh case  114:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF90);
		/* 820916DCh case  114:*/		return 0x820916E0;
		  /* 820916E0h */ case  115:  		/* stvx VR121, <#[R11 + R12]> */
		/* 820916E0h case  115:*/		cpu::mem::stvx( regs, regs.VR121, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820916E0h case  115:*/		return 0x820916E4;
	}
	return 0x820916E4;
} // Block from 82091514h-820916E4h (116 instructions)

//////////////////////////////////////////////////////
// Block at 820916E4h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820916E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820916E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820916E4);
		  /* 820916E4h */ case    0:  		/* li R11, -96 */
		/* 820916E4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFA0);
		/* 820916E4h case    0:*/		return 0x820916E8;
		  /* 820916E8h */ case    1:  		/* stvx VR122, <#[R11 + R12]> */
		/* 820916E8h case    1:*/		cpu::mem::stvx( regs, regs.VR122, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820916E8h case    1:*/		return 0x820916EC;
		  /* 820916ECh */ case    2:  		/* li R11, -80 */
		/* 820916ECh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFB0);
		/* 820916ECh case    2:*/		return 0x820916F0;
		  /* 820916F0h */ case    3:  		/* stvx VR123, <#[R11 + R12]> */
		/* 820916F0h case    3:*/		cpu::mem::stvx( regs, regs.VR123, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820916F0h case    3:*/		return 0x820916F4;
		  /* 820916F4h */ case    4:  		/* li R11, -64 */
		/* 820916F4h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFC0);
		/* 820916F4h case    4:*/		return 0x820916F8;
		  /* 820916F8h */ case    5:  		/* stvx VR124, <#[R11 + R12]> */
		/* 820916F8h case    5:*/		cpu::mem::stvx( regs, regs.VR124, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820916F8h case    5:*/		return 0x820916FC;
		  /* 820916FCh */ case    6:  		/* li R11, -48 */
		/* 820916FCh case    6:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFD0);
		/* 820916FCh case    6:*/		return 0x82091700;
		  /* 82091700h */ case    7:  		/* stvx VR125, <#[R11 + R12]> */
		/* 82091700h case    7:*/		cpu::mem::stvx( regs, regs.VR125, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091700h case    7:*/		return 0x82091704;
		  /* 82091704h */ case    8:  		/* li R11, -32 */
		/* 82091704h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFE0);
		/* 82091704h case    8:*/		return 0x82091708;
		  /* 82091708h */ case    9:  		/* stvx VR126, <#[R11 + R12]> */
		/* 82091708h case    9:*/		cpu::mem::stvx( regs, regs.VR126, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091708h case    9:*/		return 0x8209170C;
		  /* 8209170Ch */ case   10:  		/* li R11, -16 */
		/* 8209170Ch case   10:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFF0);
		/* 8209170Ch case   10:*/		return 0x82091710;
		  /* 82091710h */ case   11:  		/* stvx VR127, <#[R11 + R12]> */
		/* 82091710h case   11:*/		cpu::mem::stvx( regs, regs.VR127, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091710h case   11:*/		return 0x82091714;
		  /* 82091714h */ case   12:  		/* bclr 20, CR0_LT */
		/* 82091714h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82091714h case   12:*/		return 0x82091718;
	}
	return 0x82091718;
} // Block from 820916E4h-82091718h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82091718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091718);
		  /* 82091718h */ case    0:  		/* li R11, -288 */
		/* 82091718h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFEE0);
		/* 82091718h case    0:*/		return 0x8209171C;
		  /* 8209171Ch */ case    1:  		/* lvx VR14, <#[R11 + R12]> */
		/* 8209171Ch case    1:*/		cpu::mem::lvx( regs, &regs.VR14, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 8209171Ch case    1:*/		return 0x82091720;
		  /* 82091720h */ case    2:  		/* li R11, -272 */
		/* 82091720h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFEF0);
		/* 82091720h case    2:*/		return 0x82091724;
		  /* 82091724h */ case    3:  		/* lvx VR15, <#[R11 + R12]> */
		/* 82091724h case    3:*/		cpu::mem::lvx( regs, &regs.VR15, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091724h case    3:*/		return 0x82091728;
		  /* 82091728h */ case    4:  		/* li R11, -256 */
		/* 82091728h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF00);
		/* 82091728h case    4:*/		return 0x8209172C;
		  /* 8209172Ch */ case    5:  		/* lvx VR16, <#[R11 + R12]> */
		/* 8209172Ch case    5:*/		cpu::mem::lvx( regs, &regs.VR16, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 8209172Ch case    5:*/		return 0x82091730;
		  /* 82091730h */ case    6:  		/* li R11, -240 */
		/* 82091730h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF10);
		/* 82091730h case    6:*/		return 0x82091734;
		  /* 82091734h */ case    7:  		/* lvx VR17, <#[R11 + R12]> */
		/* 82091734h case    7:*/		cpu::mem::lvx( regs, &regs.VR17, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091734h case    7:*/		return 0x82091738;
		  /* 82091738h */ case    8:  		/* li R11, -224 */
		/* 82091738h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF20);
		/* 82091738h case    8:*/		return 0x8209173C;
		  /* 8209173Ch */ case    9:  		/* lvx VR18, <#[R11 + R12]> */
		/* 8209173Ch case    9:*/		cpu::mem::lvx( regs, &regs.VR18, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 8209173Ch case    9:*/		return 0x82091740;
		  /* 82091740h */ case   10:  		/* li R11, -208 */
		/* 82091740h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF30);
		/* 82091740h case   10:*/		return 0x82091744;
		  /* 82091744h */ case   11:  		/* lvx VR19, <#[R11 + R12]> */
		/* 82091744h case   11:*/		cpu::mem::lvx( regs, &regs.VR19, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091744h case   11:*/		return 0x82091748;
		  /* 82091748h */ case   12:  		/* li R11, -192 */
		/* 82091748h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF40);
		/* 82091748h case   12:*/		return 0x8209174C;
		  /* 8209174Ch */ case   13:  		/* lvx VR20, <#[R11 + R12]> */
		/* 8209174Ch case   13:*/		cpu::mem::lvx( regs, &regs.VR20, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 8209174Ch case   13:*/		return 0x82091750;
		  /* 82091750h */ case   14:  		/* li R11, -176 */
		/* 82091750h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF50);
		/* 82091750h case   14:*/		return 0x82091754;
		  /* 82091754h */ case   15:  		/* lvx VR21, <#[R11 + R12]> */
		/* 82091754h case   15:*/		cpu::mem::lvx( regs, &regs.VR21, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091754h case   15:*/		return 0x82091758;
		  /* 82091758h */ case   16:  		/* li R11, -160 */
		/* 82091758h case   16:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF60);
		/* 82091758h case   16:*/		return 0x8209175C;
		  /* 8209175Ch */ case   17:  		/* lvx VR22, <#[R11 + R12]> */
		/* 8209175Ch case   17:*/		cpu::mem::lvx( regs, &regs.VR22, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 8209175Ch case   17:*/		return 0x82091760;
		  /* 82091760h */ case   18:  		/* li R11, -144 */
		/* 82091760h case   18:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF70);
		/* 82091760h case   18:*/		return 0x82091764;
		  /* 82091764h */ case   19:  		/* lvx VR23, <#[R11 + R12]> */
		/* 82091764h case   19:*/		cpu::mem::lvx( regs, &regs.VR23, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091764h case   19:*/		return 0x82091768;
		  /* 82091768h */ case   20:  		/* li R11, -128 */
		/* 82091768h case   20:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF80);
		/* 82091768h case   20:*/		return 0x8209176C;
		  /* 8209176Ch */ case   21:  		/* lvx VR24, <#[R11 + R12]> */
		/* 8209176Ch case   21:*/		cpu::mem::lvx( regs, &regs.VR24, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 8209176Ch case   21:*/		return 0x82091770;
		  /* 82091770h */ case   22:  		/* li R11, -112 */
		/* 82091770h case   22:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF90);
		/* 82091770h case   22:*/		return 0x82091774;
		  /* 82091774h */ case   23:  		/* lvx VR25, <#[R11 + R12]> */
		/* 82091774h case   23:*/		cpu::mem::lvx( regs, &regs.VR25, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091774h case   23:*/		return 0x82091778;
		  /* 82091778h */ case   24:  		/* li R11, -96 */
		/* 82091778h case   24:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFA0);
		/* 82091778h case   24:*/		return 0x8209177C;
		  /* 8209177Ch */ case   25:  		/* lvx VR26, <#[R11 + R12]> */
		/* 8209177Ch case   25:*/		cpu::mem::lvx( regs, &regs.VR26, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 8209177Ch case   25:*/		return 0x82091780;
		  /* 82091780h */ case   26:  		/* li R11, -80 */
		/* 82091780h case   26:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFB0);
		/* 82091780h case   26:*/		return 0x82091784;
		  /* 82091784h */ case   27:  		/* lvx VR27, <#[R11 + R12]> */
		/* 82091784h case   27:*/		cpu::mem::lvx( regs, &regs.VR27, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091784h case   27:*/		return 0x82091788;
		  /* 82091788h */ case   28:  		/* li R11, -64 */
		/* 82091788h case   28:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFC0);
		/* 82091788h case   28:*/		return 0x8209178C;
		  /* 8209178Ch */ case   29:  		/* lvx VR28, <#[R11 + R12]> */
		/* 8209178Ch case   29:*/		cpu::mem::lvx( regs, &regs.VR28, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 8209178Ch case   29:*/		return 0x82091790;
		  /* 82091790h */ case   30:  		/* li R11, -48 */
		/* 82091790h case   30:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFD0);
		/* 82091790h case   30:*/		return 0x82091794;
		  /* 82091794h */ case   31:  		/* lvx VR29, <#[R11 + R12]> */
		/* 82091794h case   31:*/		cpu::mem::lvx( regs, &regs.VR29, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091794h case   31:*/		return 0x82091798;
		  /* 82091798h */ case   32:  		/* li R11, -32 */
		/* 82091798h case   32:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFE0);
		/* 82091798h case   32:*/		return 0x8209179C;
		  /* 8209179Ch */ case   33:  		/* lvx VR30, <#[R11 + R12]> */
		/* 8209179Ch case   33:*/		cpu::mem::lvx( regs, &regs.VR30, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 8209179Ch case   33:*/		return 0x820917A0;
		  /* 820917A0h */ case   34:  		/* li R11, -16 */
		/* 820917A0h case   34:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFF0);
		/* 820917A0h case   34:*/		return 0x820917A4;
		  /* 820917A4h */ case   35:  		/* lvx VR31, <#[R11 + R12]> */
		/* 820917A4h case   35:*/		cpu::mem::lvx( regs, &regs.VR31, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820917A4h case   35:*/		return 0x820917A8;
		  /* 820917A8h */ case   36:  		/* bclr 20, CR0_LT */
		/* 820917A8h case   36:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820917A8h case   36:*/		return 0x820917AC;
	}
	return 0x820917AC;
} // Block from 82091718h-820917ACh (37 instructions)

//////////////////////////////////////////////////////
// Block at 820917ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820917AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820917AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820917AC);
		  /* 820917ACh */ case    0:  		/* li R11, -1024 */
		/* 820917ACh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFC00);
		/* 820917ACh case    0:*/		return 0x820917B0;
		  /* 820917B0h */ case    1:  		/* lvx VR64, <#[R11 + R12]> */
		/* 820917B0h case    1:*/		cpu::mem::lvx( regs, &regs.VR64, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820917B0h case    1:*/		return 0x820917B4;
		  /* 820917B4h */ case    2:  		/* li R11, -1008 */
		/* 820917B4h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFC10);
		/* 820917B4h case    2:*/		return 0x820917B8;
		  /* 820917B8h */ case    3:  		/* lvx VR65, <#[R11 + R12]> */
		/* 820917B8h case    3:*/		cpu::mem::lvx( regs, &regs.VR65, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820917B8h case    3:*/		return 0x820917BC;
		  /* 820917BCh */ case    4:  		/* li R11, -992 */
		/* 820917BCh case    4:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFC20);
		/* 820917BCh case    4:*/		return 0x820917C0;
		  /* 820917C0h */ case    5:  		/* lvx VR66, <#[R11 + R12]> */
		/* 820917C0h case    5:*/		cpu::mem::lvx( regs, &regs.VR66, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820917C0h case    5:*/		return 0x820917C4;
		  /* 820917C4h */ case    6:  		/* li R11, -976 */
		/* 820917C4h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFC30);
		/* 820917C4h case    6:*/		return 0x820917C8;
		  /* 820917C8h */ case    7:  		/* lvx VR67, <#[R11 + R12]> */
		/* 820917C8h case    7:*/		cpu::mem::lvx( regs, &regs.VR67, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820917C8h case    7:*/		return 0x820917CC;
		  /* 820917CCh */ case    8:  		/* li R11, -960 */
		/* 820917CCh case    8:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFC40);
		/* 820917CCh case    8:*/		return 0x820917D0;
		  /* 820917D0h */ case    9:  		/* lvx VR68, <#[R11 + R12]> */
		/* 820917D0h case    9:*/		cpu::mem::lvx( regs, &regs.VR68, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820917D0h case    9:*/		return 0x820917D4;
		  /* 820917D4h */ case   10:  		/* li R11, -944 */
		/* 820917D4h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFC50);
		/* 820917D4h case   10:*/		return 0x820917D8;
		  /* 820917D8h */ case   11:  		/* lvx VR69, <#[R11 + R12]> */
		/* 820917D8h case   11:*/		cpu::mem::lvx( regs, &regs.VR69, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820917D8h case   11:*/		return 0x820917DC;
		  /* 820917DCh */ case   12:  		/* li R11, -928 */
		/* 820917DCh case   12:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFC60);
		/* 820917DCh case   12:*/		return 0x820917E0;
		  /* 820917E0h */ case   13:  		/* lvx VR70, <#[R11 + R12]> */
		/* 820917E0h case   13:*/		cpu::mem::lvx( regs, &regs.VR70, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820917E0h case   13:*/		return 0x820917E4;
		  /* 820917E4h */ case   14:  		/* li R11, -912 */
		/* 820917E4h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFC70);
		/* 820917E4h case   14:*/		return 0x820917E8;
		  /* 820917E8h */ case   15:  		/* lvx VR71, <#[R11 + R12]> */
		/* 820917E8h case   15:*/		cpu::mem::lvx( regs, &regs.VR71, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820917E8h case   15:*/		return 0x820917EC;
		  /* 820917ECh */ case   16:  		/* li R11, -896 */
		/* 820917ECh case   16:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFC80);
		/* 820917ECh case   16:*/		return 0x820917F0;
		  /* 820917F0h */ case   17:  		/* lvx VR72, <#[R11 + R12]> */
		/* 820917F0h case   17:*/		cpu::mem::lvx( regs, &regs.VR72, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820917F0h case   17:*/		return 0x820917F4;
		  /* 820917F4h */ case   18:  		/* li R11, -880 */
		/* 820917F4h case   18:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFC90);
		/* 820917F4h case   18:*/		return 0x820917F8;
		  /* 820917F8h */ case   19:  		/* lvx VR73, <#[R11 + R12]> */
		/* 820917F8h case   19:*/		cpu::mem::lvx( regs, &regs.VR73, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820917F8h case   19:*/		return 0x820917FC;
		  /* 820917FCh */ case   20:  		/* li R11, -864 */
		/* 820917FCh case   20:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFCA0);
		/* 820917FCh case   20:*/		return 0x82091800;
		  /* 82091800h */ case   21:  		/* lvx VR74, <#[R11 + R12]> */
		/* 82091800h case   21:*/		cpu::mem::lvx( regs, &regs.VR74, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091800h case   21:*/		return 0x82091804;
		  /* 82091804h */ case   22:  		/* li R11, -848 */
		/* 82091804h case   22:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFCB0);
		/* 82091804h case   22:*/		return 0x82091808;
		  /* 82091808h */ case   23:  		/* lvx VR75, <#[R11 + R12]> */
		/* 82091808h case   23:*/		cpu::mem::lvx( regs, &regs.VR75, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091808h case   23:*/		return 0x8209180C;
		  /* 8209180Ch */ case   24:  		/* li R11, -832 */
		/* 8209180Ch case   24:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFCC0);
		/* 8209180Ch case   24:*/		return 0x82091810;
		  /* 82091810h */ case   25:  		/* lvx VR76, <#[R11 + R12]> */
		/* 82091810h case   25:*/		cpu::mem::lvx( regs, &regs.VR76, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091810h case   25:*/		return 0x82091814;
		  /* 82091814h */ case   26:  		/* li R11, -816 */
		/* 82091814h case   26:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFCD0);
		/* 82091814h case   26:*/		return 0x82091818;
		  /* 82091818h */ case   27:  		/* lvx VR77, <#[R11 + R12]> */
		/* 82091818h case   27:*/		cpu::mem::lvx( regs, &regs.VR77, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091818h case   27:*/		return 0x8209181C;
		  /* 8209181Ch */ case   28:  		/* li R11, -800 */
		/* 8209181Ch case   28:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFCE0);
		/* 8209181Ch case   28:*/		return 0x82091820;
		  /* 82091820h */ case   29:  		/* lvx VR78, <#[R11 + R12]> */
		/* 82091820h case   29:*/		cpu::mem::lvx( regs, &regs.VR78, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091820h case   29:*/		return 0x82091824;
		  /* 82091824h */ case   30:  		/* li R11, -784 */
		/* 82091824h case   30:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFCF0);
		/* 82091824h case   30:*/		return 0x82091828;
		  /* 82091828h */ case   31:  		/* lvx VR79, <#[R11 + R12]> */
		/* 82091828h case   31:*/		cpu::mem::lvx( regs, &regs.VR79, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091828h case   31:*/		return 0x8209182C;
		  /* 8209182Ch */ case   32:  		/* li R11, -768 */
		/* 8209182Ch case   32:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFD00);
		/* 8209182Ch case   32:*/		return 0x82091830;
		  /* 82091830h */ case   33:  		/* lvx VR80, <#[R11 + R12]> */
		/* 82091830h case   33:*/		cpu::mem::lvx( regs, &regs.VR80, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091830h case   33:*/		return 0x82091834;
		  /* 82091834h */ case   34:  		/* li R11, -752 */
		/* 82091834h case   34:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFD10);
		/* 82091834h case   34:*/		return 0x82091838;
		  /* 82091838h */ case   35:  		/* lvx VR81, <#[R11 + R12]> */
		/* 82091838h case   35:*/		cpu::mem::lvx( regs, &regs.VR81, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091838h case   35:*/		return 0x8209183C;
		  /* 8209183Ch */ case   36:  		/* li R11, -736 */
		/* 8209183Ch case   36:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFD20);
		/* 8209183Ch case   36:*/		return 0x82091840;
		  /* 82091840h */ case   37:  		/* lvx VR82, <#[R11 + R12]> */
		/* 82091840h case   37:*/		cpu::mem::lvx( regs, &regs.VR82, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091840h case   37:*/		return 0x82091844;
		  /* 82091844h */ case   38:  		/* li R11, -720 */
		/* 82091844h case   38:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFD30);
		/* 82091844h case   38:*/		return 0x82091848;
		  /* 82091848h */ case   39:  		/* lvx VR83, <#[R11 + R12]> */
		/* 82091848h case   39:*/		cpu::mem::lvx( regs, &regs.VR83, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091848h case   39:*/		return 0x8209184C;
		  /* 8209184Ch */ case   40:  		/* li R11, -704 */
		/* 8209184Ch case   40:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFD40);
		/* 8209184Ch case   40:*/		return 0x82091850;
		  /* 82091850h */ case   41:  		/* lvx VR84, <#[R11 + R12]> */
		/* 82091850h case   41:*/		cpu::mem::lvx( regs, &regs.VR84, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091850h case   41:*/		return 0x82091854;
		  /* 82091854h */ case   42:  		/* li R11, -688 */
		/* 82091854h case   42:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFD50);
		/* 82091854h case   42:*/		return 0x82091858;
		  /* 82091858h */ case   43:  		/* lvx VR85, <#[R11 + R12]> */
		/* 82091858h case   43:*/		cpu::mem::lvx( regs, &regs.VR85, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091858h case   43:*/		return 0x8209185C;
		  /* 8209185Ch */ case   44:  		/* li R11, -672 */
		/* 8209185Ch case   44:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFD60);
		/* 8209185Ch case   44:*/		return 0x82091860;
		  /* 82091860h */ case   45:  		/* lvx VR86, <#[R11 + R12]> */
		/* 82091860h case   45:*/		cpu::mem::lvx( regs, &regs.VR86, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091860h case   45:*/		return 0x82091864;
		  /* 82091864h */ case   46:  		/* li R11, -656 */
		/* 82091864h case   46:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFD70);
		/* 82091864h case   46:*/		return 0x82091868;
		  /* 82091868h */ case   47:  		/* lvx VR87, <#[R11 + R12]> */
		/* 82091868h case   47:*/		cpu::mem::lvx( regs, &regs.VR87, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091868h case   47:*/		return 0x8209186C;
		  /* 8209186Ch */ case   48:  		/* li R11, -640 */
		/* 8209186Ch case   48:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFD80);
		/* 8209186Ch case   48:*/		return 0x82091870;
		  /* 82091870h */ case   49:  		/* lvx VR88, <#[R11 + R12]> */
		/* 82091870h case   49:*/		cpu::mem::lvx( regs, &regs.VR88, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091870h case   49:*/		return 0x82091874;
		  /* 82091874h */ case   50:  		/* li R11, -624 */
		/* 82091874h case   50:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFD90);
		/* 82091874h case   50:*/		return 0x82091878;
		  /* 82091878h */ case   51:  		/* lvx VR89, <#[R11 + R12]> */
		/* 82091878h case   51:*/		cpu::mem::lvx( regs, &regs.VR89, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091878h case   51:*/		return 0x8209187C;
		  /* 8209187Ch */ case   52:  		/* li R11, -608 */
		/* 8209187Ch case   52:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFDA0);
		/* 8209187Ch case   52:*/		return 0x82091880;
		  /* 82091880h */ case   53:  		/* lvx VR90, <#[R11 + R12]> */
		/* 82091880h case   53:*/		cpu::mem::lvx( regs, &regs.VR90, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091880h case   53:*/		return 0x82091884;
		  /* 82091884h */ case   54:  		/* li R11, -592 */
		/* 82091884h case   54:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFDB0);
		/* 82091884h case   54:*/		return 0x82091888;
		  /* 82091888h */ case   55:  		/* lvx VR91, <#[R11 + R12]> */
		/* 82091888h case   55:*/		cpu::mem::lvx( regs, &regs.VR91, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091888h case   55:*/		return 0x8209188C;
		  /* 8209188Ch */ case   56:  		/* li R11, -576 */
		/* 8209188Ch case   56:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFDC0);
		/* 8209188Ch case   56:*/		return 0x82091890;
		  /* 82091890h */ case   57:  		/* lvx VR92, <#[R11 + R12]> */
		/* 82091890h case   57:*/		cpu::mem::lvx( regs, &regs.VR92, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091890h case   57:*/		return 0x82091894;
		  /* 82091894h */ case   58:  		/* li R11, -560 */
		/* 82091894h case   58:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFDD0);
		/* 82091894h case   58:*/		return 0x82091898;
		  /* 82091898h */ case   59:  		/* lvx VR93, <#[R11 + R12]> */
		/* 82091898h case   59:*/		cpu::mem::lvx( regs, &regs.VR93, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091898h case   59:*/		return 0x8209189C;
		  /* 8209189Ch */ case   60:  		/* li R11, -544 */
		/* 8209189Ch case   60:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFDE0);
		/* 8209189Ch case   60:*/		return 0x820918A0;
		  /* 820918A0h */ case   61:  		/* lvx VR94, <#[R11 + R12]> */
		/* 820918A0h case   61:*/		cpu::mem::lvx( regs, &regs.VR94, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820918A0h case   61:*/		return 0x820918A4;
		  /* 820918A4h */ case   62:  		/* li R11, -528 */
		/* 820918A4h case   62:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFDF0);
		/* 820918A4h case   62:*/		return 0x820918A8;
		  /* 820918A8h */ case   63:  		/* lvx VR95, <#[R11 + R12]> */
		/* 820918A8h case   63:*/		cpu::mem::lvx( regs, &regs.VR95, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820918A8h case   63:*/		return 0x820918AC;
		  /* 820918ACh */ case   64:  		/* li R11, -512 */
		/* 820918ACh case   64:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFE00);
		/* 820918ACh case   64:*/		return 0x820918B0;
		  /* 820918B0h */ case   65:  		/* lvx VR96, <#[R11 + R12]> */
		/* 820918B0h case   65:*/		cpu::mem::lvx( regs, &regs.VR96, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820918B0h case   65:*/		return 0x820918B4;
		  /* 820918B4h */ case   66:  		/* li R11, -496 */
		/* 820918B4h case   66:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFE10);
		/* 820918B4h case   66:*/		return 0x820918B8;
		  /* 820918B8h */ case   67:  		/* lvx VR97, <#[R11 + R12]> */
		/* 820918B8h case   67:*/		cpu::mem::lvx( regs, &regs.VR97, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820918B8h case   67:*/		return 0x820918BC;
		  /* 820918BCh */ case   68:  		/* li R11, -480 */
		/* 820918BCh case   68:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFE20);
		/* 820918BCh case   68:*/		return 0x820918C0;
		  /* 820918C0h */ case   69:  		/* lvx VR98, <#[R11 + R12]> */
		/* 820918C0h case   69:*/		cpu::mem::lvx( regs, &regs.VR98, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820918C0h case   69:*/		return 0x820918C4;
		  /* 820918C4h */ case   70:  		/* li R11, -464 */
		/* 820918C4h case   70:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFE30);
		/* 820918C4h case   70:*/		return 0x820918C8;
		  /* 820918C8h */ case   71:  		/* lvx VR99, <#[R11 + R12]> */
		/* 820918C8h case   71:*/		cpu::mem::lvx( regs, &regs.VR99, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820918C8h case   71:*/		return 0x820918CC;
		  /* 820918CCh */ case   72:  		/* li R11, -448 */
		/* 820918CCh case   72:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFE40);
		/* 820918CCh case   72:*/		return 0x820918D0;
		  /* 820918D0h */ case   73:  		/* lvx VR100, <#[R11 + R12]> */
		/* 820918D0h case   73:*/		cpu::mem::lvx( regs, &regs.VR100, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820918D0h case   73:*/		return 0x820918D4;
		  /* 820918D4h */ case   74:  		/* li R11, -432 */
		/* 820918D4h case   74:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFE50);
		/* 820918D4h case   74:*/		return 0x820918D8;
		  /* 820918D8h */ case   75:  		/* lvx VR101, <#[R11 + R12]> */
		/* 820918D8h case   75:*/		cpu::mem::lvx( regs, &regs.VR101, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820918D8h case   75:*/		return 0x820918DC;
		  /* 820918DCh */ case   76:  		/* li R11, -416 */
		/* 820918DCh case   76:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFE60);
		/* 820918DCh case   76:*/		return 0x820918E0;
		  /* 820918E0h */ case   77:  		/* lvx VR102, <#[R11 + R12]> */
		/* 820918E0h case   77:*/		cpu::mem::lvx( regs, &regs.VR102, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820918E0h case   77:*/		return 0x820918E4;
		  /* 820918E4h */ case   78:  		/* li R11, -400 */
		/* 820918E4h case   78:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFE70);
		/* 820918E4h case   78:*/		return 0x820918E8;
	}
	return 0x820918E8;
} // Block from 820917ACh-820918E8h (79 instructions)

//////////////////////////////////////////////////////
// Block at 820918E8h
// Function 'LocalAlloc'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820918E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820918E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820918E8);
		  /* 820918E8h */ case    0:  		/* lvx VR103, <#[R11 + R12]> */
		/* 820918E8h case    0:*/		cpu::mem::lvx( regs, &regs.VR103, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820918E8h case    0:*/		return 0x820918EC;
		  /* 820918ECh */ case    1:  		/* li R11, -384 */
		/* 820918ECh case    1:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFE80);
		/* 820918ECh case    1:*/		return 0x820918F0;
		  /* 820918F0h */ case    2:  		/* lvx VR104, <#[R11 + R12]> */
		/* 820918F0h case    2:*/		cpu::mem::lvx( regs, &regs.VR104, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820918F0h case    2:*/		return 0x820918F4;
		  /* 820918F4h */ case    3:  		/* li R11, -368 */
		/* 820918F4h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFE90);
		/* 820918F4h case    3:*/		return 0x820918F8;
		  /* 820918F8h */ case    4:  		/* lvx VR105, <#[R11 + R12]> */
		/* 820918F8h case    4:*/		cpu::mem::lvx( regs, &regs.VR105, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820918F8h case    4:*/		return 0x820918FC;
		  /* 820918FCh */ case    5:  		/* li R11, -352 */
		/* 820918FCh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFEA0);
		/* 820918FCh case    5:*/		return 0x82091900;
		  /* 82091900h */ case    6:  		/* lvx VR106, <#[R11 + R12]> */
		/* 82091900h case    6:*/		cpu::mem::lvx( regs, &regs.VR106, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091900h case    6:*/		return 0x82091904;
		  /* 82091904h */ case    7:  		/* li R11, -336 */
		/* 82091904h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFEB0);
		/* 82091904h case    7:*/		return 0x82091908;
		  /* 82091908h */ case    8:  		/* lvx VR107, <#[R11 + R12]> */
		/* 82091908h case    8:*/		cpu::mem::lvx( regs, &regs.VR107, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091908h case    8:*/		return 0x8209190C;
		  /* 8209190Ch */ case    9:  		/* li R11, -320 */
		/* 8209190Ch case    9:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFEC0);
		/* 8209190Ch case    9:*/		return 0x82091910;
		  /* 82091910h */ case   10:  		/* lvx VR108, <#[R11 + R12]> */
		/* 82091910h case   10:*/		cpu::mem::lvx( regs, &regs.VR108, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091910h case   10:*/		return 0x82091914;
		  /* 82091914h */ case   11:  		/* li R11, -304 */
		/* 82091914h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFED0);
		/* 82091914h case   11:*/		return 0x82091918;
		  /* 82091918h */ case   12:  		/* lvx VR109, <#[R11 + R12]> */
		/* 82091918h case   12:*/		cpu::mem::lvx( regs, &regs.VR109, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091918h case   12:*/		return 0x8209191C;
		  /* 8209191Ch */ case   13:  		/* li R11, -288 */
		/* 8209191Ch case   13:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFEE0);
		/* 8209191Ch case   13:*/		return 0x82091920;
		  /* 82091920h */ case   14:  		/* lvx VR110, <#[R11 + R12]> */
		/* 82091920h case   14:*/		cpu::mem::lvx( regs, &regs.VR110, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091920h case   14:*/		return 0x82091924;
		  /* 82091924h */ case   15:  		/* li R11, -272 */
		/* 82091924h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFEF0);
		/* 82091924h case   15:*/		return 0x82091928;
		  /* 82091928h */ case   16:  		/* lvx VR111, <#[R11 + R12]> */
		/* 82091928h case   16:*/		cpu::mem::lvx( regs, &regs.VR111, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091928h case   16:*/		return 0x8209192C;
		  /* 8209192Ch */ case   17:  		/* li R11, -256 */
		/* 8209192Ch case   17:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF00);
		/* 8209192Ch case   17:*/		return 0x82091930;
	}
	return 0x82091930;
} // Block from 820918E8h-82091930h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82091930h
// Function 'LocalFree'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091930);
		  /* 82091930h */ case    0:  		/* lvx VR112, <#[R11 + R12]> */
		/* 82091930h case    0:*/		cpu::mem::lvx( regs, &regs.VR112, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091930h case    0:*/		return 0x82091934;
		  /* 82091934h */ case    1:  		/* li R11, -240 */
		/* 82091934h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF10);
		/* 82091934h case    1:*/		return 0x82091938;
		  /* 82091938h */ case    2:  		/* lvx VR113, <#[R11 + R12]> */
		/* 82091938h case    2:*/		cpu::mem::lvx( regs, &regs.VR113, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091938h case    2:*/		return 0x8209193C;
		  /* 8209193Ch */ case    3:  		/* li R11, -224 */
		/* 8209193Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF20);
		/* 8209193Ch case    3:*/		return 0x82091940;
		  /* 82091940h */ case    4:  		/* lvx VR114, <#[R11 + R12]> */
		/* 82091940h case    4:*/		cpu::mem::lvx( regs, &regs.VR114, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091940h case    4:*/		return 0x82091944;
		  /* 82091944h */ case    5:  		/* li R11, -208 */
		/* 82091944h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF30);
		/* 82091944h case    5:*/		return 0x82091948;
		  /* 82091948h */ case    6:  		/* lvx VR115, <#[R11 + R12]> */
		/* 82091948h case    6:*/		cpu::mem::lvx( regs, &regs.VR115, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091948h case    6:*/		return 0x8209194C;
		  /* 8209194Ch */ case    7:  		/* li R11, -192 */
		/* 8209194Ch case    7:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF40);
		/* 8209194Ch case    7:*/		return 0x82091950;
		  /* 82091950h */ case    8:  		/* lvx VR116, <#[R11 + R12]> */
		/* 82091950h case    8:*/		cpu::mem::lvx( regs, &regs.VR116, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091950h case    8:*/		return 0x82091954;
		  /* 82091954h */ case    9:  		/* li R11, -176 */
		/* 82091954h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF50);
		/* 82091954h case    9:*/		return 0x82091958;
		  /* 82091958h */ case   10:  		/* lvx VR117, <#[R11 + R12]> */
		/* 82091958h case   10:*/		cpu::mem::lvx( regs, &regs.VR117, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091958h case   10:*/		return 0x8209195C;
		  /* 8209195Ch */ case   11:  		/* li R11, -160 */
		/* 8209195Ch case   11:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF60);
		/* 8209195Ch case   11:*/		return 0x82091960;
		  /* 82091960h */ case   12:  		/* lvx VR118, <#[R11 + R12]> */
		/* 82091960h case   12:*/		cpu::mem::lvx( regs, &regs.VR118, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091960h case   12:*/		return 0x82091964;
		  /* 82091964h */ case   13:  		/* li R11, -144 */
		/* 82091964h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF70);
		/* 82091964h case   13:*/		return 0x82091968;
		  /* 82091968h */ case   14:  		/* lvx VR119, <#[R11 + R12]> */
		/* 82091968h case   14:*/		cpu::mem::lvx( regs, &regs.VR119, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091968h case   14:*/		return 0x8209196C;
		  /* 8209196Ch */ case   15:  		/* li R11, -128 */
		/* 8209196Ch case   15:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF80);
		/* 8209196Ch case   15:*/		return 0x82091970;
		  /* 82091970h */ case   16:  		/* lvx VR120, <#[R11 + R12]> */
		/* 82091970h case   16:*/		cpu::mem::lvx( regs, &regs.VR120, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091970h case   16:*/		return 0x82091974;
		  /* 82091974h */ case   17:  		/* li R11, -112 */
		/* 82091974h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF90);
		/* 82091974h case   17:*/		return 0x82091978;
		  /* 82091978h */ case   18:  		/* lvx VR121, <#[R11 + R12]> */
		/* 82091978h case   18:*/		cpu::mem::lvx( regs, &regs.VR121, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091978h case   18:*/		return 0x8209197C;
	}
	return 0x8209197C;
} // Block from 82091930h-8209197Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8209197Ch
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209197C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209197C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209197C);
		  /* 8209197Ch */ case    0:  		/* li R11, -96 */
		/* 8209197Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFA0);
		/* 8209197Ch case    0:*/		return 0x82091980;
	}
	return 0x82091980;
} // Block from 8209197Ch-82091980h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091980h
// Function 'RtlDebugPrintHelper'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091980);
		  /* 82091980h */ case    0:  		/* lvx VR122, <#[R11 + R12]> */
		/* 82091980h case    0:*/		cpu::mem::lvx( regs, &regs.VR122, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091980h case    0:*/		return 0x82091984;
		  /* 82091984h */ case    1:  		/* li R11, -80 */
		/* 82091984h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFB0);
		/* 82091984h case    1:*/		return 0x82091988;
	}
	return 0x82091988;
} // Block from 82091980h-82091988h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82091988h
// Function 'XapiFormatTimeOut'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091988);
		  /* 82091988h */ case    0:  		/* lvx VR123, <#[R11 + R12]> */
		/* 82091988h case    0:*/		cpu::mem::lvx( regs, &regs.VR123, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091988h case    0:*/		return 0x8209198C;
		  /* 8209198Ch */ case    1:  		/* li R11, -64 */
		/* 8209198Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFC0);
		/* 8209198Ch case    1:*/		return 0x82091990;
		  /* 82091990h */ case    2:  		/* lvx VR124, <#[R11 + R12]> */
		/* 82091990h case    2:*/		cpu::mem::lvx( regs, &regs.VR124, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091990h case    2:*/		return 0x82091994;
		  /* 82091994h */ case    3:  		/* li R11, -48 */
		/* 82091994h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFD0);
		/* 82091994h case    3:*/		return 0x82091998;
		  /* 82091998h */ case    4:  		/* lvx VR125, <#[R11 + R12]> */
		/* 82091998h case    4:*/		cpu::mem::lvx( regs, &regs.VR125, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 82091998h case    4:*/		return 0x8209199C;
		  /* 8209199Ch */ case    5:  		/* li R11, -32 */
		/* 8209199Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFE0);
		/* 8209199Ch case    5:*/		return 0x820919A0;
		  /* 820919A0h */ case    6:  		/* lvx VR126, <#[R11 + R12]> */
		/* 820919A0h case    6:*/		cpu::mem::lvx( regs, &regs.VR126, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820919A0h case    6:*/		return 0x820919A4;
		  /* 820919A4h */ case    7:  		/* li R11, -16 */
		/* 820919A4h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFF0);
		/* 820919A4h case    7:*/		return 0x820919A8;
		  /* 820919A8h */ case    8:  		/* lvx VR127, <#[R11 + R12]> */
		/* 820919A8h case    8:*/		cpu::mem::lvx( regs, &regs.VR127, (uint32)(regs.R11 + regs.R12 + 0x00000000) );
		/* 820919A8h case    8:*/		return 0x820919AC;
		  /* 820919ACh */ case    9:  		/* bclr 20, CR0_LT */
		/* 820919ACh case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820919ACh case    9:*/		return 0x820919B0;
	}
	return 0x820919B0;
} // Block from 82091988h-820919B0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820919B0h
// Function 'XapiThreadStartup'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820919B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820919B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820919B0);
		  /* 820919B0h */ case    0:  		/* std R3, <#[R1 - 8]> */
		/* 820919B0h case    0:*/		cpu::mem::store64( regs, regs.R3, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820919B0h case    0:*/		return 0x820919B4;
		  /* 820919B4h */ case    1:  		/* rlwinm R6, R3, 0, 29, 31 */
		/* 820919B4h case    1:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R6,regs.R3);
		/* 820919B4h case    1:*/		return 0x820919B8;
		  /* 820919B8h */ case    2:  		/* dcbt R0, R4 */
		/* 820919B8h case    2:*/		cpu::op::dcbt<0>(regs,&regs.R0,regs.R4);
		/* 820919B8h case    2:*/		return 0x820919BC;
		  /* 820919BCh */ case    3:  		/* cmplwi CR0, R6, 0 */
		/* 820919BCh case    3:*/		cpu::op::cmplwi<0>(regs,regs.R6,0x00000000);
		/* 820919BCh case    3:*/		return 0x820919C0;
		  /* 820919C0h */ case    4:  		/* subfic R6, R6, 8 */
		/* 820919C0h case    4:*/		cpu::op::subfic<0>(regs,&regs.R6,regs.R6,0x8);
		/* 820919C0h case    4:*/		return 0x820919C4;
		  /* 820919C4h */ case    5:  		/* bc 12, CR0_EQ, 80 */
		/* 820919C4h case    5:*/		if ( regs.CR[0].eq ) { return 0x82091A14;  }
		/* 820919C4h case    5:*/		return 0x820919C8;
		  /* 820919C8h */ case    6:  		/* cmplw CR0, R5, R6 */
		/* 820919C8h case    6:*/		cpu::op::cmplw<0>(regs,regs.R5,regs.R6);
		/* 820919C8h case    6:*/		return 0x820919CC;
		  /* 820919CCh */ case    7:  		/* bc 4, CR0_GT, 100 */
		/* 820919CCh case    7:*/		if ( !regs.CR[0].gt ) { return 0x82091A30;  }
		/* 820919CCh case    7:*/		return 0x820919D0;
		  /* 820919D0h */ case    8:  		/* cmplwi CR0, R6, 4 */
		/* 820919D0h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R6,0x00000004);
		/* 820919D0h case    8:*/		return 0x820919D4;
		  /* 820919D4h */ case    9:  		/* bc 12, CR0_EQ, 44 */
		/* 820919D4h case    9:*/		if ( regs.CR[0].eq ) { return 0x82091A00;  }
		/* 820919D4h case    9:*/		return 0x820919D8;
		  /* 820919D8h */ case   10:  		/* addi R3, R3, -1 */
		/* 820919D8h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0xFFFFFFFF);
		/* 820919D8h case   10:*/		return 0x820919DC;
		  /* 820919DCh */ case   11:  		/* addi R4, R4, -1 */
		/* 820919DCh case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFFFF);
		/* 820919DCh case   11:*/		return 0x820919E0;
		  /* 820919E0h */ case   12:  		/* subf R5, R6, R5 */
		/* 820919E0h case   12:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R6,regs.R5);
		/* 820919E0h case   12:*/		return 0x820919E4;
		  /* 820919E4h */ case   13:  		/* mtspr CTR, R6 */
		/* 820919E4h case   13:*/		regs.CTR = regs.R6;
		/* 820919E4h case   13:*/		return 0x820919E8;
		  /* 820919E8h */ case   14:  		/* lbzu R6, <#[R4 + 1]> */
		/* 820919E8h case   14:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R4 + 0x00000001) );
		regs.R4 = (uint32)(regs.R4 + 0x00000001);
		/* 820919E8h case   14:*/		return 0x820919EC;
		  /* 820919ECh */ case   15:  		/* stbu R6, <#[R3 + 1]> */
		/* 820919ECh case   15:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R3 + 0x00000001) );
		regs.R3 = (uint32)(regs.R3 + 0x00000001);
		/* 820919ECh case   15:*/		return 0x820919F0;
		  /* 820919F0h */ case   16:  		/* bc 16, CR0_LT, -8 */
		/* 820919F0h case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820919E8;  }
		/* 820919F0h case   16:*/		return 0x820919F4;
		  /* 820919F4h */ case   17:  		/* addi R3, R3, 1 */
		/* 820919F4h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 820919F4h case   17:*/		return 0x820919F8;
		  /* 820919F8h */ case   18:  		/* addi R4, R4, 1 */
		/* 820919F8h case   18:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820919F8h case   18:*/		return 0x820919FC;
		  /* 820919FCh */ case   19:  		/* b 24 */
		/* 820919FCh case   19:*/		return 0x82091A14;
		/* 820919FCh case   19:*/		return 0x82091A00;
	}
	return 0x82091A00;
} // Block from 820919B0h-82091A00h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82091A00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091A00);
		  /* 82091A00h */ case    0:  		/* subf R5, R6, R5 */
		/* 82091A00h case    0:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R6,regs.R5);
		/* 82091A00h case    0:*/		return 0x82091A04;
		  /* 82091A04h */ case    1:  		/* lwz R6, <#[R4]> */
		/* 82091A04h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R4 + 0x00000000) );
		/* 82091A04h case    1:*/		return 0x82091A08;
		  /* 82091A08h */ case    2:  		/* addi R4, R4, 4 */
		/* 82091A08h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 82091A08h case    2:*/		return 0x82091A0C;
		  /* 82091A0Ch */ case    3:  		/* stw R6, <#[R3]> */
		/* 82091A0Ch case    3:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000000) );
		/* 82091A0Ch case    3:*/		return 0x82091A10;
		  /* 82091A10h */ case    4:  		/* addi R3, R3, 4 */
		/* 82091A10h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 82091A10h case    4:*/		return 0x82091A14;
	}
	return 0x82091A14;
} // Block from 82091A00h-82091A14h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82091A14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091A14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091A14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091A14);
		  /* 82091A14h */ case    0:  		/* rlwinm R6, R4, 0, 29, 31 */
		/* 82091A14h case    0:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R6,regs.R4);
		/* 82091A14h case    0:*/		return 0x82091A18;
		  /* 82091A18h */ case    1:  		/* cmplwi CR6, R6, 4 */
		/* 82091A18h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000004);
		/* 82091A18h case    1:*/		return 0x82091A1C;
		  /* 82091A1Ch */ case    2:  		/* cmplwi CR1, R6, 0 */
		/* 82091A1Ch case    2:*/		cpu::op::cmplwi<1>(regs,regs.R6,0x00000000);
		/* 82091A1Ch case    2:*/		return 0x82091A20;
		  /* 82091A20h */ case    3:  		/* cmplwi CR7, R5, 128 */
		/* 82091A20h case    3:*/		cpu::op::cmplwi<7>(regs,regs.R5,0x00000080);
		/* 82091A20h case    3:*/		return 0x82091A24;
		  /* 82091A24h */ case    4:  		/* bc 12, CR6_EQ, 468 */
		/* 82091A24h case    4:*/		if ( regs.CR[6].eq ) { return 0x82091BF8;  }
		/* 82091A24h case    4:*/		return 0x82091A28;
		  /* 82091A28h */ case    5:  		/* bc 4, CR1_EQ, 768 */
		/* 82091A28h case    5:*/		if ( !regs.CR[1].eq ) { return 0x82091D28;  }
		/* 82091A28h case    5:*/		return 0x82091A2C;
		  /* 82091A2Ch */ case    6:  		/* bc 4, CR7_LT, 160 */
		/* 82091A2Ch case    6:*/		if ( !regs.CR[7].lt ) { return 0x82091ACC;  }
		/* 82091A2Ch case    6:*/		return 0x82091A30;
	}
	return 0x82091A30;
} // Block from 82091A14h-82091A30h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82091A30h
// Function 'GetProcessHeap'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091A30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091A30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091A30);
		  /* 82091A30h */ case    0:  		/* dcbtst R0, R3 */
		/* 82091A30h case    0:*/		cpu::op::dcbtst<0>(regs,&regs.R0,regs.R3);
		/* 82091A30h case    0:*/		return 0x82091A34;
		  /* 82091A34h */ case    1:  		/* addi R4, R4, -8 */
		/* 82091A34h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFFF8);
		/* 82091A34h case    1:*/		return 0x82091A38;
		  /* 82091A38h */ case    2:  		/* addi R3, R3, -8 */
		/* 82091A38h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0xFFFFFFF8);
		/* 82091A38h case    2:*/		return 0x82091A3C;
		  /* 82091A3Ch */ case    3:  		/* rlwinm R7, R5, 29, 28, 31 */
		/* 82091A3Ch case    3:*/		cpu::op::rlwinm<0,29,28,31>(regs,&regs.R7,regs.R5);
		/* 82091A3Ch case    3:*/		return 0x82091A40;
	}
	return 0x82091A40;
} // Block from 82091A30h-82091A40h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82091A40h
// Function 'sin'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091A40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091A40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091A40);
		  /* 82091A40h */ case    0:  		/* rlwinm R6, R5, 0, 29, 31 */
		/* 82091A40h case    0:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R6,regs.R5);
		/* 82091A40h case    0:*/		return 0x82091A44;
		  /* 82091A44h */ case    1:  		/* cmplwi CR1, R7, 0 */
		/* 82091A44h case    1:*/		cpu::op::cmplwi<1>(regs,regs.R7,0x00000000);
		/* 82091A44h case    1:*/		return 0x82091A48;
		  /* 82091A48h */ case    2:  		/* cmplwi CR6, R6, 0 */
		/* 82091A48h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82091A48h case    2:*/		return 0x82091A4C;
		  /* 82091A4Ch */ case    3:  		/* bc 12, CR1_EQ, 20 */
		/* 82091A4Ch case    3:*/		if ( regs.CR[1].eq ) { return 0x82091A60;  }
		/* 82091A4Ch case    3:*/		return 0x82091A50;
		  /* 82091A50h */ case    4:  		/* mtspr CTR, R7 */
		/* 82091A50h case    4:*/		regs.CTR = regs.R7;
		/* 82091A50h case    4:*/		return 0x82091A54;
		  /* 82091A54h */ case    5:  		/* ldu R7, <#[R4 + 8]> */
		/* 82091A54h case    5:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R4 + 0x00000008) );
		regs.R4 = (uint32)(regs.R4 + 0x00000008);
		/* 82091A54h case    5:*/		return 0x82091A58;
		  /* 82091A58h */ case    6:  		/* stdu R7, <#[R3 + 8]> */
		/* 82091A58h case    6:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R3 + 0x00000008) );
		regs.R3 = (uint32)(regs.R3 + 0x00000008);
		/* 82091A58h case    6:*/		return 0x82091A5C;
		  /* 82091A5Ch */ case    7:  		/* bc 16, CR0_LT, -8 */
		/* 82091A5Ch case    7:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091A54;  }
		/* 82091A5Ch case    7:*/		return 0x82091A60;
	}
	return 0x82091A60;
} // Block from 82091A40h-82091A60h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82091A60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091A60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091A60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091A60);
		  /* 82091A60h */ case    0:  		/* cmplwi CR1, R6, 4 */
		/* 82091A60h case    0:*/		cpu::op::cmplwi<1>(regs,regs.R6,0x00000004);
		/* 82091A60h case    0:*/		return 0x82091A64;
		  /* 82091A64h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 82091A64h case    1:*/		if ( regs.CR[6].eq ) { return 0x82091A84;  }
		/* 82091A64h case    1:*/		return 0x82091A68;
		  /* 82091A68h */ case    2:  		/* bc 12, CR1_EQ, 36 */
		/* 82091A68h case    2:*/		if ( regs.CR[1].eq ) { return 0x82091A8C;  }
		/* 82091A68h case    2:*/		return 0x82091A6C;
		  /* 82091A6Ch */ case    3:  		/* addi R3, R3, 7 */
		/* 82091A6Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x7);
		/* 82091A6Ch case    3:*/		return 0x82091A70;
		  /* 82091A70h */ case    4:  		/* addi R4, R4, 7 */
		/* 82091A70h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x7);
		/* 82091A70h case    4:*/		return 0x82091A74;
		  /* 82091A74h */ case    5:  		/* mtspr CTR, R6 */
		/* 82091A74h case    5:*/		regs.CTR = regs.R6;
		/* 82091A74h case    5:*/		return 0x82091A78;
		  /* 82091A78h */ case    6:  		/* lbzu R7, <#[R4 + 1]> */
		/* 82091A78h case    6:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000001) );
		regs.R4 = (uint32)(regs.R4 + 0x00000001);
		/* 82091A78h case    6:*/		return 0x82091A7C;
		  /* 82091A7Ch */ case    7:  		/* stbu R7, <#[R3 + 1]> */
		/* 82091A7Ch case    7:*/		cpu::mem::store8( regs, regs.R7, (uint32)(regs.R3 + 0x00000001) );
		regs.R3 = (uint32)(regs.R3 + 0x00000001);
		/* 82091A7Ch case    7:*/		return 0x82091A80;
		  /* 82091A80h */ case    8:  		/* bc 16, CR0_LT, -8 */
		/* 82091A80h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091A78;  }
		/* 82091A80h case    8:*/		return 0x82091A84;
	}
	return 0x82091A84;
} // Block from 82091A60h-82091A84h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82091A84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091A84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091A84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091A84);
		  /* 82091A84h */ case    0:  		/* ld R3, <#[R1 - 8]> */
		/* 82091A84h case    0:*/		cpu::mem::load64( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82091A84h case    0:*/		return 0x82091A88;
		  /* 82091A88h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82091A88h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82091A88h case    1:*/		return 0x82091A8C;
	}
	return 0x82091A8C;
} // Block from 82091A84h-82091A8Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82091A8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091A8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091A8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091A8C);
		  /* 82091A8Ch */ case    0:  		/* rlwinm R6, R3, 0, 30, 31 */
		/* 82091A8Ch case    0:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R6,regs.R3);
		/* 82091A8Ch case    0:*/		return 0x82091A90;
		  /* 82091A90h */ case    1:  		/* lwz R5, <#[R4 + 8]> */
		/* 82091A90h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R4 + 0x00000008) );
		/* 82091A90h case    1:*/		return 0x82091A94;
		  /* 82091A94h */ case    2:  		/* cmplwi CR0, R6, 0 */
		/* 82091A94h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R6,0x00000000);
		/* 82091A94h case    2:*/		return 0x82091A98;
		  /* 82091A98h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82091A98h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82091AA8;  }
		/* 82091A98h case    3:*/		return 0x82091A9C;
		  /* 82091A9Ch */ case    4:  		/* stw R5, <#[R3 + 8]> */
		/* 82091A9Ch case    4:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000008) );
		/* 82091A9Ch case    4:*/		return 0x82091AA0;
		  /* 82091AA0h */ case    5:  		/* ld R3, <#[R1 - 8]> */
		/* 82091AA0h case    5:*/		cpu::mem::load64( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82091AA0h case    5:*/		return 0x82091AA4;
		  /* 82091AA4h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82091AA4h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82091AA4h case    6:*/		return 0x82091AA8;
	}
	return 0x82091AA8;
} // Block from 82091A8Ch-82091AA8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82091AA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091AA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091AA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091AA8);
		  /* 82091AA8h */ case    0:  		/* lbz R8, <#[R4 + 8]> */
		/* 82091AA8h case    0:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000008) );
		/* 82091AA8h case    0:*/		return 0x82091AAC;
		  /* 82091AACh */ case    1:  		/* lbz R7, <#[R4 + 9]> */
		/* 82091AACh case    1:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000009) );
		/* 82091AACh case    1:*/		return 0x82091AB0;
		  /* 82091AB0h */ case    2:  		/* lbz R6, <#[R4 + 10]> */
		/* 82091AB0h case    2:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R4 + 0x0000000A) );
		/* 82091AB0h case    2:*/		return 0x82091AB4;
		  /* 82091AB4h */ case    3:  		/* stb R8, <#[R3 + 8]> */
		/* 82091AB4h case    3:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R3 + 0x00000008) );
		/* 82091AB4h case    3:*/		return 0x82091AB8;
		  /* 82091AB8h */ case    4:  		/* stb R7, <#[R3 + 9]> */
		/* 82091AB8h case    4:*/		cpu::mem::store8( regs, regs.R7, (uint32)(regs.R3 + 0x00000009) );
		/* 82091AB8h case    4:*/		return 0x82091ABC;
		  /* 82091ABCh */ case    5:  		/* stb R6, <#[R3 + 10]> */
		/* 82091ABCh case    5:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R3 + 0x0000000A) );
		/* 82091ABCh case    5:*/		return 0x82091AC0;
		  /* 82091AC0h */ case    6:  		/* stb R5, <#[R3 + 11]> */
		/* 82091AC0h case    6:*/		cpu::mem::store8( regs, regs.R5, (uint32)(regs.R3 + 0x0000000B) );
		/* 82091AC0h case    6:*/		return 0x82091AC4;
		  /* 82091AC4h */ case    7:  		/* ld R3, <#[R1 - 8]> */
		/* 82091AC4h case    7:*/		cpu::mem::load64( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82091AC4h case    7:*/		return 0x82091AC8;
		  /* 82091AC8h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82091AC8h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82091AC8h case    8:*/		return 0x82091ACC;
	}
	return 0x82091ACC;
} // Block from 82091AA8h-82091ACCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 82091ACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091ACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091ACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091ACC);
		  /* 82091ACCh */ case    0:  		/* rlwinm R6, R3, 0, 25, 31 */
		/* 82091ACCh case    0:*/		cpu::op::rlwinm<0,0,25,31>(regs,&regs.R6,regs.R3);
		/* 82091ACCh case    0:*/		return 0x82091AD0;
		  /* 82091AD0h */ case    1:  		/* addi R3, R3, -8 */
		/* 82091AD0h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0xFFFFFFF8);
		/* 82091AD0h case    1:*/		return 0x82091AD4;
		  /* 82091AD4h */ case    2:  		/* addi R4, R4, -8 */
		/* 82091AD4h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFFF8);
		/* 82091AD4h case    2:*/		return 0x82091AD8;
		  /* 82091AD8h */ case    3:  		/* cmplwi CR0, R6, 0 */
		/* 82091AD8h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R6,0x00000000);
		/* 82091AD8h case    3:*/		return 0x82091ADC;
		  /* 82091ADCh */ case    4:  		/* subfic R6, R6, 128 */
		/* 82091ADCh case    4:*/		cpu::op::subfic<0>(regs,&regs.R6,regs.R6,0x80);
		/* 82091ADCh case    4:*/		return 0x82091AE0;
		  /* 82091AE0h */ case    5:  		/* bc 12, CR0_EQ, 28 */
		/* 82091AE0h case    5:*/		if ( regs.CR[0].eq ) { return 0x82091AFC;  }
		/* 82091AE0h case    5:*/		return 0x82091AE4;
		  /* 82091AE4h */ case    6:  		/* rlwinm R7, R6, 29, 3, 31 */
		/* 82091AE4h case    6:*/		cpu::op::rlwinm<0,29,3,31>(regs,&regs.R7,regs.R6);
		/* 82091AE4h case    6:*/		return 0x82091AE8;
		  /* 82091AE8h */ case    7:  		/* subf R5, R6, R5 */
		/* 82091AE8h case    7:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R6,regs.R5);
		/* 82091AE8h case    7:*/		return 0x82091AEC;
		  /* 82091AECh */ case    8:  		/* mtspr CTR, R7 */
		/* 82091AECh case    8:*/		regs.CTR = regs.R7;
		/* 82091AECh case    8:*/		return 0x82091AF0;
		  /* 82091AF0h */ case    9:  		/* ldu R7, <#[R4 + 8]> */
		/* 82091AF0h case    9:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R4 + 0x00000008) );
		regs.R4 = (uint32)(regs.R4 + 0x00000008);
		/* 82091AF0h case    9:*/		return 0x82091AF4;
		  /* 82091AF4h */ case   10:  		/* stdu R7, <#[R3 + 8]> */
		/* 82091AF4h case   10:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R3 + 0x00000008) );
		regs.R3 = (uint32)(regs.R3 + 0x00000008);
		/* 82091AF4h case   10:*/		return 0x82091AF8;
		  /* 82091AF8h */ case   11:  		/* bc 16, CR0_LT, -8 */
		/* 82091AF8h case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091AF0;  }
		/* 82091AF8h case   11:*/		return 0x82091AFC;
	}
	return 0x82091AFC;
} // Block from 82091ACCh-82091AFCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 82091AFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091AFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091AFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091AFC);
		  /* 82091AFCh */ case    0:  		/* rlwinm R6, R5, 25, 7, 31 */
		/* 82091AFCh case    0:*/		cpu::op::rlwinm<0,25,7,31>(regs,&regs.R6,regs.R5);
		/* 82091AFCh case    0:*/		return 0x82091B00;
		  /* 82091B00h */ case    1:  		/* cmplwi CR0, R6, 0 */
		/* 82091B00h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R6,0x00000000);
		/* 82091B00h case    1:*/		return 0x82091B04;
		  /* 82091B04h */ case    2:  		/* bc 12, CR0_EQ, -200 */
		/* 82091B04h case    2:*/		if ( regs.CR[0].eq ) { return 0x82091A3C;  }
		/* 82091B04h case    2:*/		return 0x82091B08;
		  /* 82091B08h */ case    3:  		/* addi R10, R5, 127 */
		/* 82091B08h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0x7F);
		/* 82091B08h case    3:*/		return 0x82091B0C;
		  /* 82091B0Ch */ case    4:  		/* rlwinm R8, R5, 0, 25, 31 */
		/* 82091B0Ch case    4:*/		cpu::op::rlwinm<0,0,25,31>(regs,&regs.R8,regs.R5);
		/* 82091B0Ch case    4:*/		return 0x82091B10;
		  /* 82091B10h */ case    5:  		/* rlwinm R10, R10, 25, 7, 31 */
		/* 82091B10h case    5:*/		cpu::op::rlwinm<0,25,7,31>(regs,&regs.R10,regs.R10);
		/* 82091B10h case    5:*/		return 0x82091B14;
		  /* 82091B14h */ case    6:  		/* cmplwi CR1, R8, 0 */
		/* 82091B14h case    6:*/		cpu::op::cmplwi<1>(regs,regs.R8,0x00000000);
		/* 82091B14h case    6:*/		return 0x82091B18;
		  /* 82091B18h */ case    7:  		/* addi R10, R10, -1 */
		/* 82091B18h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82091B18h case    7:*/		return 0x82091B1C;
		  /* 82091B1Ch */ case    8:  		/* rlwinm R10, R10, 0, 29, 31 */
		/* 82091B1Ch case    8:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R10);
		/* 82091B1Ch case    8:*/		return 0x82091B20;
	}
	return 0x82091B20;
} // Block from 82091AFCh-82091B20h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82091B20h
// Function 'cos'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091B20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091B20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091B20);
		  /* 82091B20h */ case    0:  		/* addi R10, R10, 1 */
		/* 82091B20h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82091B20h case    0:*/		return 0x82091B24;
		  /* 82091B24h */ case    1:  		/* li R9, 8 */
		/* 82091B24h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x8);
		/* 82091B24h case    1:*/		return 0x82091B28;
		  /* 82091B28h */ case    2:  		/* mtspr CTR, R10 */
		/* 82091B28h case    2:*/		regs.CTR = regs.R10;
		/* 82091B28h case    2:*/		return 0x82091B2C;
		  /* 82091B2Ch */ case    3:  		/* dcbt R9, R4 */
		/* 82091B2Ch case    3:*/		cpu::op::dcbt<0>(regs,&regs.R9,regs.R4);
		/* 82091B2Ch case    3:*/		return 0x82091B30;
		  /* 82091B30h */ case    4:  		/* addi R9, R9, 128 */
		/* 82091B30h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x80);
		/* 82091B30h case    4:*/		return 0x82091B34;
		  /* 82091B34h */ case    5:  		/* bc 16, CR0_LT, -8 */
		/* 82091B34h case    5:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091B2C;  }
		/* 82091B34h case    5:*/		return 0x82091B38;
		  /* 82091B38h */ case    6:  		/* add R12, R4, R5 */
		/* 82091B38h case    6:*/		cpu::op::add<0>(regs,&regs.R12,regs.R4,regs.R5);
		/* 82091B38h case    6:*/		return 0x82091B3C;
		  /* 82091B3Ch */ case    7:  		/* li R10, 8 */
		/* 82091B3Ch case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x8);
		/* 82091B3Ch case    7:*/		return 0x82091B40;
		  /* 82091B40h */ case    8:  		/* subf R11, R9, R12 */
		/* 82091B40h case    8:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R12);
		/* 82091B40h case    8:*/		return 0x82091B44;
		  /* 82091B44h */ case    9:  		/* add R12, R3, R5 */
		/* 82091B44h case    9:*/		cpu::op::add<0>(regs,&regs.R12,regs.R3,regs.R5);
		/* 82091B44h case    9:*/		return 0x82091B48;
		  /* 82091B48h */ case   10:  		/* mtspr CTR, R6 */
		/* 82091B48h case   10:*/		regs.CTR = regs.R6;
		/* 82091B48h case   10:*/		return 0x82091B4C;
		  /* 82091B4Ch */ case   11:  		/* ld R6, <#[R4 + 8]> */
		/* 82091B4Ch case   11:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R4 + 0x00000008) );
		/* 82091B4Ch case   11:*/		return 0x82091B50;
		  /* 82091B50h */ case   12:  		/* ld R7, <#[R4 + 16]> */
		/* 82091B50h case   12:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R4 + 0x00000010) );
		/* 82091B50h case   12:*/		return 0x82091B54;
		  /* 82091B54h */ case   13:  		/* ld R8, <#[R4 + 24]> */
		/* 82091B54h case   13:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R4 + 0x00000018) );
		/* 82091B54h case   13:*/		return 0x82091B58;
		  /* 82091B58h */ case   14:  		/* std R6, <#[R3 + 8]> */
		/* 82091B58h case   14:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R3 + 0x00000008) );
		/* 82091B58h case   14:*/		return 0x82091B5C;
		  /* 82091B5Ch */ case   15:  		/* ld R6, <#[R4 + 32]> */
		/* 82091B5Ch case   15:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R4 + 0x00000020) );
		/* 82091B5Ch case   15:*/		return 0x82091B60;
		  /* 82091B60h */ case   16:  		/* std R7, <#[R3 + 16]> */
		/* 82091B60h case   16:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R3 + 0x00000010) );
		/* 82091B60h case   16:*/		return 0x82091B64;
		  /* 82091B64h */ case   17:  		/* ld R7, <#[R4 + 40]> */
		/* 82091B64h case   17:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R4 + 0x00000028) );
		/* 82091B64h case   17:*/		return 0x82091B68;
		  /* 82091B68h */ case   18:  		/* std R8, <#[R3 + 24]> */
		/* 82091B68h case   18:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R3 + 0x00000018) );
		/* 82091B68h case   18:*/		return 0x82091B6C;
		  /* 82091B6Ch */ case   19:  		/* ld R8, <#[R4 + 48]> */
		/* 82091B6Ch case   19:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R4 + 0x00000030) );
		/* 82091B6Ch case   19:*/		return 0x82091B70;
		  /* 82091B70h */ case   20:  		/* std R6, <#[R3 + 32]> */
		/* 82091B70h case   20:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R3 + 0x00000020) );
		/* 82091B70h case   20:*/		return 0x82091B74;
		  /* 82091B74h */ case   21:  		/* ld R6, <#[R4 + 56]> */
		/* 82091B74h case   21:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R4 + 0x00000038) );
		/* 82091B74h case   21:*/		return 0x82091B78;
		  /* 82091B78h */ case   22:  		/* std R7, <#[R3 + 40]> */
		/* 82091B78h case   22:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R3 + 0x00000028) );
		/* 82091B78h case   22:*/		return 0x82091B7C;
		  /* 82091B7Ch */ case   23:  		/* ld R7, <#[R4 + 64]> */
		/* 82091B7Ch case   23:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R4 + 0x00000040) );
		/* 82091B7Ch case   23:*/		return 0x82091B80;
		  /* 82091B80h */ case   24:  		/* std R8, <#[R3 + 48]> */
		/* 82091B80h case   24:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R3 + 0x00000030) );
		/* 82091B80h case   24:*/		return 0x82091B84;
		  /* 82091B84h */ case   25:  		/* ld R8, <#[R4 + 72]> */
		/* 82091B84h case   25:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R4 + 0x00000048) );
		/* 82091B84h case   25:*/		return 0x82091B88;
		  /* 82091B88h */ case   26:  		/* std R6, <#[R3 + 56]> */
		/* 82091B88h case   26:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R3 + 0x00000038) );
		/* 82091B88h case   26:*/		return 0x82091B8C;
		  /* 82091B8Ch */ case   27:  		/* ld R6, <#[R4 + 80]> */
		/* 82091B8Ch case   27:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R4 + 0x00000050) );
		/* 82091B8Ch case   27:*/		return 0x82091B90;
		  /* 82091B90h */ case   28:  		/* std R7, <#[R3 + 64]> */
		/* 82091B90h case   28:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R3 + 0x00000040) );
		/* 82091B90h case   28:*/		return 0x82091B94;
		  /* 82091B94h */ case   29:  		/* ld R7, <#[R4 + 88]> */
		/* 82091B94h case   29:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R4 + 0x00000058) );
		/* 82091B94h case   29:*/		return 0x82091B98;
		  /* 82091B98h */ case   30:  		/* std R8, <#[R3 + 72]> */
		/* 82091B98h case   30:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R3 + 0x00000048) );
		/* 82091B98h case   30:*/		return 0x82091B9C;
		  /* 82091B9Ch */ case   31:  		/* ld R8, <#[R4 + 96]> */
		/* 82091B9Ch case   31:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R4 + 0x00000060) );
		/* 82091B9Ch case   31:*/		return 0x82091BA0;
		  /* 82091BA0h */ case   32:  		/* std R6, <#[R3 + 80]> */
		/* 82091BA0h case   32:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R3 + 0x00000050) );
		/* 82091BA0h case   32:*/		return 0x82091BA4;
		  /* 82091BA4h */ case   33:  		/* ld R6, <#[R4 + 104]> */
		/* 82091BA4h case   33:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R4 + 0x00000068) );
		/* 82091BA4h case   33:*/		return 0x82091BA8;
		  /* 82091BA8h */ case   34:  		/* std R7, <#[R3 + 88]> */
		/* 82091BA8h case   34:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R3 + 0x00000058) );
		/* 82091BA8h case   34:*/		return 0x82091BAC;
		  /* 82091BACh */ case   35:  		/* ld R7, <#[R4 + 112]> */
		/* 82091BACh case   35:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R4 + 0x00000070) );
		/* 82091BACh case   35:*/		return 0x82091BB0;
		  /* 82091BB0h */ case   36:  		/* std R8, <#[R3 + 96]> */
		/* 82091BB0h case   36:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R3 + 0x00000060) );
		/* 82091BB0h case   36:*/		return 0x82091BB4;
		  /* 82091BB4h */ case   37:  		/* ld R8, <#[R4 + 120]> */
		/* 82091BB4h case   37:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R4 + 0x00000078) );
		/* 82091BB4h case   37:*/		return 0x82091BB8;
		  /* 82091BB8h */ case   38:  		/* std R6, <#[R3 + 104]> */
		/* 82091BB8h case   38:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R3 + 0x00000068) );
		/* 82091BB8h case   38:*/		return 0x82091BBC;
		  /* 82091BBCh */ case   39:  		/* ldu R6, <#[R4 + 128]> */
		/* 82091BBCh case   39:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R4 + 0x00000080) );
		regs.R4 = (uint32)(regs.R4 + 0x00000080);
		/* 82091BBCh case   39:*/		return 0x82091BC0;
		  /* 82091BC0h */ case   40:  		/* std R7, <#[R3 + 112]> */
		/* 82091BC0h case   40:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R3 + 0x00000070) );
		/* 82091BC0h case   40:*/		return 0x82091BC4;
		  /* 82091BC4h */ case   41:  		/* std R8, <#[R3 + 120]> */
		/* 82091BC4h case   41:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R3 + 0x00000078) );
		/* 82091BC4h case   41:*/		return 0x82091BC8;
		  /* 82091BC8h */ case   42:  		/* stdu R6, <#[R3 + 128]> */
		/* 82091BC8h case   42:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R3 + 0x00000080) );
		regs.R3 = (uint32)(regs.R3 + 0x00000080);
		/* 82091BC8h case   42:*/		return 0x82091BCC;
		  /* 82091BCCh */ case   43:  		/* cmplw CR0, R4, R11 */
		/* 82091BCCh case   43:*/		cpu::op::cmplw<0>(regs,regs.R4,regs.R11);
		/* 82091BCCh case   43:*/		return 0x82091BD0;
		  /* 82091BD0h */ case   44:  		/* bc 4, CR0_LT, 16 */
		/* 82091BD0h case   44:*/		if ( !regs.CR[0].lt ) { return 0x82091BE0;  }
		/* 82091BD0h case   44:*/		return 0x82091BD4;
		  /* 82091BD4h */ case   45:  		/* dcbt R9, R4 */
		/* 82091BD4h case   45:*/		cpu::op::dcbt<0>(regs,&regs.R9,regs.R4);
		/* 82091BD4h case   45:*/		return 0x82091BD8;
		  /* 82091BD8h */ case   46:  		/* bc 16, CR0_LT, -140 */
		/* 82091BD8h case   46:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091B4C;  }
		/* 82091BD8h case   46:*/		return 0x82091BDC;
		  /* 82091BDCh */ case   47:  		/* b -416 */
		/* 82091BDCh case   47:*/		return 0x82091A3C;
		/* 82091BDCh case   47:*/		return 0x82091BE0;
	}
	return 0x82091BE0;
} // Block from 82091B20h-82091BE0h (48 instructions)

//////////////////////////////////////////////////////
// Block at 82091BE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091BE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091BE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091BE0);
		  /* 82091BE0h */ case    0:  		/* bc 12, CR1_EQ, 16 */
		/* 82091BE0h case    0:*/		if ( regs.CR[1].eq ) { return 0x82091BF0;  }
		/* 82091BE0h case    0:*/		return 0x82091BE4;
		  /* 82091BE4h */ case    1:  		/* li R8, -1 */
		/* 82091BE4h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 82091BE4h case    1:*/		return 0x82091BE8;
		  /* 82091BE8h */ case    2:  		/* dcbtst R8, R12 */
		/* 82091BE8h case    2:*/		cpu::op::dcbtst<0>(regs,&regs.R8,regs.R12);
		/* 82091BE8h case    2:*/		return 0x82091BEC;
		  /* 82091BECh */ case    3:  		/* cmplwi CR1, R8, 0 */
		/* 82091BECh case    3:*/		cpu::op::cmplwi<1>(regs,regs.R8,0x00000000);
		/* 82091BECh case    3:*/		return 0x82091BF0;
	}
	return 0x82091BF0;
} // Block from 82091BE0h-82091BF0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82091BF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091BF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091BF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091BF0);
		  /* 82091BF0h */ case    0:  		/* bc 16, CR0_LT, -164 */
		/* 82091BF0h case    0:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091B4C;  }
		/* 82091BF0h case    0:*/		return 0x82091BF4;
		  /* 82091BF4h */ case    1:  		/* b -440 */
		/* 82091BF4h case    1:*/		return 0x82091A3C;
		/* 82091BF4h case    1:*/		return 0x82091BF8;
	}
	return 0x82091BF8;
} // Block from 82091BF0h-82091BF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82091BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091BF8);
		  /* 82091BF8h */ case    0:  		/* addi R4, R4, -4 */
		/* 82091BF8h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFFFC);
		/* 82091BF8h case    0:*/		return 0x82091BFC;
		  /* 82091BFCh */ case    1:  		/* bc 4, CR7_LT, 84 */
		/* 82091BFCh case    1:*/		if ( !regs.CR[7].lt ) { return 0x82091C50;  }
		/* 82091BFCh case    1:*/		return 0x82091C00;
	}
	return 0x82091C00;
} // Block from 82091BF8h-82091C00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82091C00h
// Function '_vswprintf_helper'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091C00);
		  /* 82091C00h */ case    0:  		/* dcbtst R0, R3 */
		/* 82091C00h case    0:*/		cpu::op::dcbtst<0>(regs,&regs.R0,regs.R3);
		/* 82091C00h case    0:*/		return 0x82091C04;
		  /* 82091C04h */ case    1:  		/* addi R3, R3, -4 */
		/* 82091C04h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0xFFFFFFFC);
		/* 82091C04h case    1:*/		return 0x82091C08;
		  /* 82091C08h */ case    2:  		/* rlwinm R7, R5, 30, 27, 31 */
		/* 82091C08h case    2:*/		cpu::op::rlwinm<0,30,27,31>(regs,&regs.R7,regs.R5);
		/* 82091C08h case    2:*/		return 0x82091C0C;
		  /* 82091C0Ch */ case    3:  		/* rlwinm R6, R5, 0, 30, 31 */
		/* 82091C0Ch case    3:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R6,regs.R5);
		/* 82091C0Ch case    3:*/		return 0x82091C10;
		  /* 82091C10h */ case    4:  		/* cmplwi CR1, R7, 0 */
		/* 82091C10h case    4:*/		cpu::op::cmplwi<1>(regs,regs.R7,0x00000000);
		/* 82091C10h case    4:*/		return 0x82091C14;
		  /* 82091C14h */ case    5:  		/* cmplwi CR6, R6, 0 */
		/* 82091C14h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82091C14h case    5:*/		return 0x82091C18;
		  /* 82091C18h */ case    6:  		/* bc 12, CR1_EQ, 20 */
		/* 82091C18h case    6:*/		if ( regs.CR[1].eq ) { return 0x82091C2C;  }
		/* 82091C18h case    6:*/		return 0x82091C1C;
		  /* 82091C1Ch */ case    7:  		/* mtspr CTR, R7 */
		/* 82091C1Ch case    7:*/		regs.CTR = regs.R7;
		/* 82091C1Ch case    7:*/		return 0x82091C20;
		  /* 82091C20h */ case    8:  		/* lwzu R7, <#[R4 + 4]> */
		/* 82091C20h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000004) );
		regs.R4 = (uint32)(regs.R4 + 0x00000004);
		/* 82091C20h case    8:*/		return 0x82091C24;
		  /* 82091C24h */ case    9:  		/* stwu R7, <#[R3 + 4]> */
		/* 82091C24h case    9:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82091C24h case    9:*/		return 0x82091C28;
		  /* 82091C28h */ case   10:  		/* bc 16, CR0_LT, -8 */
		/* 82091C28h case   10:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091C20;  }
		/* 82091C28h case   10:*/		return 0x82091C2C;
	}
	return 0x82091C2C;
} // Block from 82091C00h-82091C2Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 82091C2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091C2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091C2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091C2C);
		  /* 82091C2Ch */ case    0:  		/* bc 12, CR6_EQ, 28 */
		/* 82091C2Ch case    0:*/		if ( regs.CR[6].eq ) { return 0x82091C48;  }
		/* 82091C2Ch case    0:*/		return 0x82091C30;
		  /* 82091C30h */ case    1:  		/* addi R3, R3, 3 */
		/* 82091C30h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x3);
		/* 82091C30h case    1:*/		return 0x82091C34;
		  /* 82091C34h */ case    2:  		/* addi R4, R4, 3 */
		/* 82091C34h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x3);
		/* 82091C34h case    2:*/		return 0x82091C38;
		  /* 82091C38h */ case    3:  		/* mtspr CTR, R6 */
		/* 82091C38h case    3:*/		regs.CTR = regs.R6;
		/* 82091C38h case    3:*/		return 0x82091C3C;
		  /* 82091C3Ch */ case    4:  		/* lbzu R7, <#[R4 + 1]> */
		/* 82091C3Ch case    4:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000001) );
		regs.R4 = (uint32)(regs.R4 + 0x00000001);
		/* 82091C3Ch case    4:*/		return 0x82091C40;
		  /* 82091C40h */ case    5:  		/* stbu R7, <#[R3 + 1]> */
		/* 82091C40h case    5:*/		cpu::mem::store8( regs, regs.R7, (uint32)(regs.R3 + 0x00000001) );
		regs.R3 = (uint32)(regs.R3 + 0x00000001);
		/* 82091C40h case    5:*/		return 0x82091C44;
		  /* 82091C44h */ case    6:  		/* bc 16, CR0_LT, -8 */
		/* 82091C44h case    6:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091C3C;  }
		/* 82091C44h case    6:*/		return 0x82091C48;
	}
	return 0x82091C48;
} // Block from 82091C2Ch-82091C48h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82091C48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091C48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091C48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091C48);
		  /* 82091C48h */ case    0:  		/* ld R3, <#[R1 - 8]> */
		/* 82091C48h case    0:*/		cpu::mem::load64( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82091C48h case    0:*/		return 0x82091C4C;
		  /* 82091C4Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 82091C4Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82091C4Ch case    1:*/		return 0x82091C50;
	}
	return 0x82091C50;
} // Block from 82091C48h-82091C50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82091C50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091C50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091C50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091C50);
		  /* 82091C50h */ case    0:  		/* rlwinm R6, R3, 0, 25, 31 */
		/* 82091C50h case    0:*/		cpu::op::rlwinm<0,0,25,31>(regs,&regs.R6,regs.R3);
		/* 82091C50h case    0:*/		return 0x82091C54;
		  /* 82091C54h */ case    1:  		/* addi R3, R3, -4 */
		/* 82091C54h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0xFFFFFFFC);
		/* 82091C54h case    1:*/		return 0x82091C58;
		  /* 82091C58h */ case    2:  		/* cmplwi CR0, R6, 0 */
		/* 82091C58h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R6,0x00000000);
		/* 82091C58h case    2:*/		return 0x82091C5C;
		  /* 82091C5Ch */ case    3:  		/* subfic R6, R6, 128 */
		/* 82091C5Ch case    3:*/		cpu::op::subfic<0>(regs,&regs.R6,regs.R6,0x80);
		/* 82091C5Ch case    3:*/		return 0x82091C60;
		  /* 82091C60h */ case    4:  		/* bc 12, CR0_EQ, 28 */
		/* 82091C60h case    4:*/		if ( regs.CR[0].eq ) { return 0x82091C7C;  }
		/* 82091C60h case    4:*/		return 0x82091C64;
		  /* 82091C64h */ case    5:  		/* rlwinm R7, R6, 30, 2, 31 */
		/* 82091C64h case    5:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R7,regs.R6);
		/* 82091C64h case    5:*/		return 0x82091C68;
		  /* 82091C68h */ case    6:  		/* subf R5, R6, R5 */
		/* 82091C68h case    6:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R6,regs.R5);
		/* 82091C68h case    6:*/		return 0x82091C6C;
		  /* 82091C6Ch */ case    7:  		/* mtspr CTR, R7 */
		/* 82091C6Ch case    7:*/		regs.CTR = regs.R7;
		/* 82091C6Ch case    7:*/		return 0x82091C70;
		  /* 82091C70h */ case    8:  		/* lwzu R7, <#[R4 + 4]> */
		/* 82091C70h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000004) );
		regs.R4 = (uint32)(regs.R4 + 0x00000004);
		/* 82091C70h case    8:*/		return 0x82091C74;
		  /* 82091C74h */ case    9:  		/* stwu R7, <#[R3 + 4]> */
		/* 82091C74h case    9:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82091C74h case    9:*/		return 0x82091C78;
		  /* 82091C78h */ case   10:  		/* bc 16, CR0_LT, -8 */
		/* 82091C78h case   10:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091C70;  }
		/* 82091C78h case   10:*/		return 0x82091C7C;
	}
	return 0x82091C7C;
} // Block from 82091C50h-82091C7Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 82091C7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091C7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091C7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091C7C);
		  /* 82091C7Ch */ case    0:  		/* rlwinm R6, R5, 25, 7, 31 */
		/* 82091C7Ch case    0:*/		cpu::op::rlwinm<0,25,7,31>(regs,&regs.R6,regs.R5);
		/* 82091C7Ch case    0:*/		return 0x82091C80;
		  /* 82091C80h */ case    1:  		/* cmplwi CR0, R6, 0 */
		/* 82091C80h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R6,0x00000000);
		/* 82091C80h case    1:*/		return 0x82091C84;
		  /* 82091C84h */ case    2:  		/* bc 12, CR0_EQ, -124 */
		/* 82091C84h case    2:*/		if ( regs.CR[0].eq ) { return 0x82091C08;  }
		/* 82091C84h case    2:*/		return 0x82091C88;
		  /* 82091C88h */ case    3:  		/* addi R10, R5, 127 */
		/* 82091C88h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0x7F);
		/* 82091C88h case    3:*/		return 0x82091C8C;
		  /* 82091C8Ch */ case    4:  		/* rlwinm R8, R5, 0, 25, 31 */
		/* 82091C8Ch case    4:*/		cpu::op::rlwinm<0,0,25,31>(regs,&regs.R8,regs.R5);
		/* 82091C8Ch case    4:*/		return 0x82091C90;
		  /* 82091C90h */ case    5:  		/* rlwinm R10, R10, 25, 7, 31 */
		/* 82091C90h case    5:*/		cpu::op::rlwinm<0,25,7,31>(regs,&regs.R10,regs.R10);
		/* 82091C90h case    5:*/		return 0x82091C94;
		  /* 82091C94h */ case    6:  		/* cmplwi CR1, R8, 0 */
		/* 82091C94h case    6:*/		cpu::op::cmplwi<1>(regs,regs.R8,0x00000000);
		/* 82091C94h case    6:*/		return 0x82091C98;
		  /* 82091C98h */ case    7:  		/* addi R10, R10, -1 */
		/* 82091C98h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82091C98h case    7:*/		return 0x82091C9C;
		  /* 82091C9Ch */ case    8:  		/* rlwinm R10, R10, 0, 29, 31 */
		/* 82091C9Ch case    8:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R10);
		/* 82091C9Ch case    8:*/		return 0x82091CA0;
		  /* 82091CA0h */ case    9:  		/* addi R10, R10, 1 */
		/* 82091CA0h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82091CA0h case    9:*/		return 0x82091CA4;
		  /* 82091CA4h */ case   10:  		/* li R9, 4 */
		/* 82091CA4h case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 82091CA4h case   10:*/		return 0x82091CA8;
		  /* 82091CA8h */ case   11:  		/* mtspr CTR, R10 */
		/* 82091CA8h case   11:*/		regs.CTR = regs.R10;
		/* 82091CA8h case   11:*/		return 0x82091CAC;
		  /* 82091CACh */ case   12:  		/* dcbt R9, R4 */
		/* 82091CACh case   12:*/		cpu::op::dcbt<0>(regs,&regs.R9,regs.R4);
		/* 82091CACh case   12:*/		return 0x82091CB0;
		  /* 82091CB0h */ case   13:  		/* addi R9, R9, 128 */
		/* 82091CB0h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x80);
		/* 82091CB0h case   13:*/		return 0x82091CB4;
		  /* 82091CB4h */ case   14:  		/* bc 16, CR0_LT, -8 */
		/* 82091CB4h case   14:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091CAC;  }
		/* 82091CB4h case   14:*/		return 0x82091CB8;
		  /* 82091CB8h */ case   15:  		/* add R12, R4, R5 */
		/* 82091CB8h case   15:*/		cpu::op::add<0>(regs,&regs.R12,regs.R4,regs.R5);
		/* 82091CB8h case   15:*/		return 0x82091CBC;
		  /* 82091CBCh */ case   16:  		/* li R10, 8 */
		/* 82091CBCh case   16:*/		cpu::op::li<0>(regs,&regs.R10,0x8);
		/* 82091CBCh case   16:*/		return 0x82091CC0;
		  /* 82091CC0h */ case   17:  		/* subf R11, R9, R12 */
		/* 82091CC0h case   17:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R12);
		/* 82091CC0h case   17:*/		return 0x82091CC4;
		  /* 82091CC4h */ case   18:  		/* add R12, R3, R5 */
		/* 82091CC4h case   18:*/		cpu::op::add<0>(regs,&regs.R12,regs.R3,regs.R5);
		/* 82091CC4h case   18:*/		return 0x82091CC8;
		  /* 82091CC8h */ case   19:  		/* mtspr CTR, R6 */
		/* 82091CC8h case   19:*/		regs.CTR = regs.R6;
		/* 82091CC8h case   19:*/		return 0x82091CCC;
		  /* 82091CCCh */ case   20:  		/* li R6, 8 */
		/* 82091CCCh case   20:*/		cpu::op::li<0>(regs,&regs.R6,0x8);
		/* 82091CCCh case   20:*/		return 0x82091CD0;
		  /* 82091CD0h */ case   21:  		/* addi R6, R6, -1 */
		/* 82091CD0h case   21:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0xFFFFFFFF);
		/* 82091CD0h case   21:*/		return 0x82091CD4;
		  /* 82091CD4h */ case   22:  		/* lwz R0, <#[R4 + 4]> */
		/* 82091CD4h case   22:*/		cpu::mem::load32z( regs, &regs.R0, (uint32)(regs.R4 + 0x00000004) );
		/* 82091CD4h case   22:*/		return 0x82091CD8;
		  /* 82091CD8h */ case   23:  		/* lwz R7, <#[R4 + 8]> */
		/* 82091CD8h case   23:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000008) );
		/* 82091CD8h case   23:*/		return 0x82091CDC;
		  /* 82091CDCh */ case   24:  		/* lwz R8, <#[R4 + 12]> */
		/* 82091CDCh case   24:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R4 + 0x0000000C) );
		/* 82091CDCh case   24:*/		return 0x82091CE0;
		  /* 82091CE0h */ case   25:  		/* cmplwi CR0, R6, 0 */
		/* 82091CE0h case   25:*/		cpu::op::cmplwi<0>(regs,regs.R6,0x00000000);
		/* 82091CE0h case   25:*/		return 0x82091CE4;
		  /* 82091CE4h */ case   26:  		/* stw R0, <#[R3 + 4]> */
		/* 82091CE4h case   26:*/		cpu::mem::store32( regs, regs.R0, (uint32)(regs.R3 + 0x00000004) );
		/* 82091CE4h case   26:*/		return 0x82091CE8;
		  /* 82091CE8h */ case   27:  		/* lwzu R0, <#[R4 + 16]> */
		/* 82091CE8h case   27:*/		cpu::mem::load32z( regs, &regs.R0, (uint32)(regs.R4 + 0x00000010) );
		regs.R4 = (uint32)(regs.R4 + 0x00000010);
		/* 82091CE8h case   27:*/		return 0x82091CEC;
		  /* 82091CECh */ case   28:  		/* stw R7, <#[R3 + 8]> */
		/* 82091CECh case   28:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000008) );
		/* 82091CECh case   28:*/		return 0x82091CF0;
		  /* 82091CF0h */ case   29:  		/* stw R8, <#[R3 + 12]> */
		/* 82091CF0h case   29:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x0000000C) );
		/* 82091CF0h case   29:*/		return 0x82091CF4;
		  /* 82091CF4h */ case   30:  		/* stwu R0, <#[R3 + 16]> */
		/* 82091CF4h case   30:*/		cpu::mem::store32( regs, regs.R0, (uint32)(regs.R3 + 0x00000010) );
		regs.R3 = (uint32)(regs.R3 + 0x00000010);
		/* 82091CF4h case   30:*/		return 0x82091CF8;
		  /* 82091CF8h */ case   31:  		/* bc 4, CR0_EQ, -40 */
		/* 82091CF8h case   31:*/		if ( !regs.CR[0].eq ) { return 0x82091CD0;  }
		/* 82091CF8h case   31:*/		return 0x82091CFC;
		  /* 82091CFCh */ case   32:  		/* cmplw CR0, R4, R11 */
		/* 82091CFCh case   32:*/		cpu::op::cmplw<0>(regs,regs.R4,regs.R11);
		/* 82091CFCh case   32:*/		return 0x82091D00;
		  /* 82091D00h */ case   33:  		/* bc 4, CR0_LT, 16 */
		/* 82091D00h case   33:*/		if ( !regs.CR[0].lt ) { return 0x82091D10;  }
		/* 82091D00h case   33:*/		return 0x82091D04;
		  /* 82091D04h */ case   34:  		/* dcbt R9, R4 */
		/* 82091D04h case   34:*/		cpu::op::dcbt<0>(regs,&regs.R9,regs.R4);
		/* 82091D04h case   34:*/		return 0x82091D08;
		  /* 82091D08h */ case   35:  		/* bc 16, CR0_LT, -60 */
		/* 82091D08h case   35:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091CCC;  }
		/* 82091D08h case   35:*/		return 0x82091D0C;
		  /* 82091D0Ch */ case   36:  		/* b -260 */
		/* 82091D0Ch case   36:*/		return 0x82091C08;
		/* 82091D0Ch case   36:*/		return 0x82091D10;
	}
	return 0x82091D10;
} // Block from 82091C7Ch-82091D10h (37 instructions)

//////////////////////////////////////////////////////
// Block at 82091D10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091D10);
		  /* 82091D10h */ case    0:  		/* bc 12, CR1_EQ, 16 */
		/* 82091D10h case    0:*/		if ( regs.CR[1].eq ) { return 0x82091D20;  }
		/* 82091D10h case    0:*/		return 0x82091D14;
		  /* 82091D14h */ case    1:  		/* li R8, -1 */
		/* 82091D14h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 82091D14h case    1:*/		return 0x82091D18;
		  /* 82091D18h */ case    2:  		/* dcbtst R8, R12 */
		/* 82091D18h case    2:*/		cpu::op::dcbtst<0>(regs,&regs.R8,regs.R12);
		/* 82091D18h case    2:*/		return 0x82091D1C;
		  /* 82091D1Ch */ case    3:  		/* cmplwi CR1, R8, 0 */
		/* 82091D1Ch case    3:*/		cpu::op::cmplwi<1>(regs,regs.R8,0x00000000);
		/* 82091D1Ch case    3:*/		return 0x82091D20;
	}
	return 0x82091D20;
} // Block from 82091D10h-82091D20h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82091D20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091D20);
		  /* 82091D20h */ case    0:  		/* bc 16, CR0_LT, -84 */
		/* 82091D20h case    0:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091CCC;  }
		/* 82091D20h case    0:*/		return 0x82091D24;
		  /* 82091D24h */ case    1:  		/* b -284 */
		/* 82091D24h case    1:*/		return 0x82091C08;
		/* 82091D24h case    1:*/		return 0x82091D28;
	}
	return 0x82091D28;
} // Block from 82091D20h-82091D28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82091D28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091D28);
		  /* 82091D28h */ case    0:  		/* addi R4, R4, -1 */
		/* 82091D28h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFFFF);
		/* 82091D28h case    0:*/		return 0x82091D2C;
		  /* 82091D2Ch */ case    1:  		/* bc 4, CR7_LT, 48 */
		/* 82091D2Ch case    1:*/		if ( !regs.CR[7].lt ) { return 0x82091D5C;  }
		/* 82091D2Ch case    1:*/		return 0x82091D30;
		  /* 82091D30h */ case    2:  		/* dcbtst R0, R3 */
		/* 82091D30h case    2:*/		cpu::op::dcbtst<0>(regs,&regs.R0,regs.R3);
		/* 82091D30h case    2:*/		return 0x82091D34;
		  /* 82091D34h */ case    3:  		/* addi R3, R3, -1 */
		/* 82091D34h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0xFFFFFFFF);
		/* 82091D34h case    3:*/		return 0x82091D38;
		  /* 82091D38h */ case    4:  		/* rlwinm R6, R5, 0, 25, 31 */
		/* 82091D38h case    4:*/		cpu::op::rlwinm<0,0,25,31>(regs,&regs.R6,regs.R5);
		/* 82091D38h case    4:*/		return 0x82091D3C;
		  /* 82091D3Ch */ case    5:  		/* cmplwi CR0, R6, 0 */
		/* 82091D3Ch case    5:*/		cpu::op::cmplwi<0>(regs,regs.R6,0x00000000);
		/* 82091D3Ch case    5:*/		return 0x82091D40;
		  /* 82091D40h */ case    6:  		/* mtspr CTR, R6 */
		/* 82091D40h case    6:*/		regs.CTR = regs.R6;
		/* 82091D40h case    6:*/		return 0x82091D44;
		  /* 82091D44h */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 82091D44h case    7:*/		if ( regs.CR[0].eq ) { return 0x82091D54;  }
		/* 82091D44h case    7:*/		return 0x82091D48;
		  /* 82091D48h */ case    8:  		/* lbzu R6, <#[R4 + 1]> */
		/* 82091D48h case    8:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R4 + 0x00000001) );
		regs.R4 = (uint32)(regs.R4 + 0x00000001);
		/* 82091D48h case    8:*/		return 0x82091D4C;
		  /* 82091D4Ch */ case    9:  		/* stbu R6, <#[R3 + 1]> */
		/* 82091D4Ch case    9:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R3 + 0x00000001) );
		regs.R3 = (uint32)(regs.R3 + 0x00000001);
		/* 82091D4Ch case    9:*/		return 0x82091D50;
		  /* 82091D50h */ case   10:  		/* bc 16, CR0_LT, -8 */
		/* 82091D50h case   10:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091D48;  }
		/* 82091D50h case   10:*/		return 0x82091D54;
	}
	return 0x82091D54;
} // Block from 82091D28h-82091D54h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82091D54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091D54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091D54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091D54);
		  /* 82091D54h */ case    0:  		/* ld R3, <#[R1 - 8]> */
		/* 82091D54h case    0:*/		cpu::mem::load64( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82091D54h case    0:*/		return 0x82091D58;
		  /* 82091D58h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82091D58h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82091D58h case    1:*/		return 0x82091D5C;
	}
	return 0x82091D5C;
} // Block from 82091D54h-82091D5Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82091D5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091D5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091D5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091D5C);
		  /* 82091D5Ch */ case    0:  		/* rlwinm R6, R3, 0, 25, 31 */
		/* 82091D5Ch case    0:*/		cpu::op::rlwinm<0,0,25,31>(regs,&regs.R6,regs.R3);
		/* 82091D5Ch case    0:*/		return 0x82091D60;
		  /* 82091D60h */ case    1:  		/* addi R3, R3, -1 */
		/* 82091D60h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0xFFFFFFFF);
		/* 82091D60h case    1:*/		return 0x82091D64;
		  /* 82091D64h */ case    2:  		/* cmplwi CR0, R6, 0 */
		/* 82091D64h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R6,0x00000000);
		/* 82091D64h case    2:*/		return 0x82091D68;
		  /* 82091D68h */ case    3:  		/* subfic R6, R6, 128 */
		/* 82091D68h case    3:*/		cpu::op::subfic<0>(regs,&regs.R6,regs.R6,0x80);
		/* 82091D68h case    3:*/		return 0x82091D6C;
		  /* 82091D6Ch */ case    4:  		/* bc 12, CR0_EQ, 24 */
		/* 82091D6Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x82091D84;  }
		/* 82091D6Ch case    4:*/		return 0x82091D70;
	}
	return 0x82091D70;
} // Block from 82091D5Ch-82091D70h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82091D70h
// Function '_vswprintf_s_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091D70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091D70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091D70);
		  /* 82091D70h */ case    0:  		/* subf R5, R6, R5 */
		/* 82091D70h case    0:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R6,regs.R5);
		/* 82091D70h case    0:*/		return 0x82091D74;
		  /* 82091D74h */ case    1:  		/* mtspr CTR, R6 */
		/* 82091D74h case    1:*/		regs.CTR = regs.R6;
		/* 82091D74h case    1:*/		return 0x82091D78;
		  /* 82091D78h */ case    2:  		/* lbzu R6, <#[R4 + 1]> */
		/* 82091D78h case    2:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R4 + 0x00000001) );
		regs.R4 = (uint32)(regs.R4 + 0x00000001);
		/* 82091D78h case    2:*/		return 0x82091D7C;
		  /* 82091D7Ch */ case    3:  		/* stbu R6, <#[R3 + 1]> */
		/* 82091D7Ch case    3:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R3 + 0x00000001) );
		regs.R3 = (uint32)(regs.R3 + 0x00000001);
		/* 82091D7Ch case    3:*/		return 0x82091D80;
		  /* 82091D80h */ case    4:  		/* bc 16, CR0_LT, -8 */
		/* 82091D80h case    4:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091D78;  }
		/* 82091D80h case    4:*/		return 0x82091D84;
	}
	return 0x82091D84;
} // Block from 82091D70h-82091D84h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82091D84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091D84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091D84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091D84);
		  /* 82091D84h */ case    0:  		/* rlwinm R6, R5, 25, 7, 31 */
		/* 82091D84h case    0:*/		cpu::op::rlwinm<0,25,7,31>(regs,&regs.R6,regs.R5);
		/* 82091D84h case    0:*/		return 0x82091D88;
		  /* 82091D88h */ case    1:  		/* cmplwi CR0, R6, 0 */
		/* 82091D88h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R6,0x00000000);
		/* 82091D88h case    1:*/		return 0x82091D8C;
		  /* 82091D8Ch */ case    2:  		/* bc 12, CR0_EQ, -84 */
		/* 82091D8Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x82091D38;  }
		/* 82091D8Ch case    2:*/		return 0x82091D90;
		  /* 82091D90h */ case    3:  		/* addi R10, R5, 127 */
		/* 82091D90h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0x7F);
		/* 82091D90h case    3:*/		return 0x82091D94;
		  /* 82091D94h */ case    4:  		/* rlwinm R8, R5, 0, 25, 31 */
		/* 82091D94h case    4:*/		cpu::op::rlwinm<0,0,25,31>(regs,&regs.R8,regs.R5);
		/* 82091D94h case    4:*/		return 0x82091D98;
		  /* 82091D98h */ case    5:  		/* rlwinm R10, R10, 25, 7, 31 */
		/* 82091D98h case    5:*/		cpu::op::rlwinm<0,25,7,31>(regs,&regs.R10,regs.R10);
		/* 82091D98h case    5:*/		return 0x82091D9C;
		  /* 82091D9Ch */ case    6:  		/* cmplwi CR1, R8, 0 */
		/* 82091D9Ch case    6:*/		cpu::op::cmplwi<1>(regs,regs.R8,0x00000000);
		/* 82091D9Ch case    6:*/		return 0x82091DA0;
		  /* 82091DA0h */ case    7:  		/* addi R10, R10, -1 */
		/* 82091DA0h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82091DA0h case    7:*/		return 0x82091DA4;
		  /* 82091DA4h */ case    8:  		/* rlwinm R10, R10, 0, 29, 31 */
		/* 82091DA4h case    8:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R10);
		/* 82091DA4h case    8:*/		return 0x82091DA8;
		  /* 82091DA8h */ case    9:  		/* addi R10, R10, 1 */
		/* 82091DA8h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82091DA8h case    9:*/		return 0x82091DAC;
		  /* 82091DACh */ case   10:  		/* li R9, 1 */
		/* 82091DACh case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82091DACh case   10:*/		return 0x82091DB0;
		  /* 82091DB0h */ case   11:  		/* mtspr CTR, R10 */
		/* 82091DB0h case   11:*/		regs.CTR = regs.R10;
		/* 82091DB0h case   11:*/		return 0x82091DB4;
		  /* 82091DB4h */ case   12:  		/* dcbt R9, R4 */
		/* 82091DB4h case   12:*/		cpu::op::dcbt<0>(regs,&regs.R9,regs.R4);
		/* 82091DB4h case   12:*/		return 0x82091DB8;
		  /* 82091DB8h */ case   13:  		/* addi R9, R9, 128 */
		/* 82091DB8h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x80);
		/* 82091DB8h case   13:*/		return 0x82091DBC;
		  /* 82091DBCh */ case   14:  		/* bc 16, CR0_LT, -8 */
		/* 82091DBCh case   14:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091DB4;  }
		/* 82091DBCh case   14:*/		return 0x82091DC0;
		  /* 82091DC0h */ case   15:  		/* add R12, R4, R5 */
		/* 82091DC0h case   15:*/		cpu::op::add<0>(regs,&regs.R12,regs.R4,regs.R5);
		/* 82091DC0h case   15:*/		return 0x82091DC4;
		  /* 82091DC4h */ case   16:  		/* li R10, 1 */
		/* 82091DC4h case   16:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82091DC4h case   16:*/		return 0x82091DC8;
		  /* 82091DC8h */ case   17:  		/* subf R11, R9, R12 */
		/* 82091DC8h case   17:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R12);
		/* 82091DC8h case   17:*/		return 0x82091DCC;
		  /* 82091DCCh */ case   18:  		/* add R12, R3, R5 */
		/* 82091DCCh case   18:*/		cpu::op::add<0>(regs,&regs.R12,regs.R3,regs.R5);
		/* 82091DCCh case   18:*/		return 0x82091DD0;
		  /* 82091DD0h */ case   19:  		/* mtspr CTR, R6 */
		/* 82091DD0h case   19:*/		regs.CTR = regs.R6;
		/* 82091DD0h case   19:*/		return 0x82091DD4;
		  /* 82091DD4h */ case   20:  		/* li R6, 32 */
		/* 82091DD4h case   20:*/		cpu::op::li<0>(regs,&regs.R6,0x20);
		/* 82091DD4h case   20:*/		return 0x82091DD8;
		  /* 82091DD8h */ case   21:  		/* lbz R7, <#[R4 + 4]> */
		/* 82091DD8h case   21:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000004) );
		/* 82091DD8h case   21:*/		return 0x82091DDC;
		  /* 82091DDCh */ case   22:  		/* lbz R8, <#[R4 + 3]> */
		/* 82091DDCh case   22:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000003) );
		/* 82091DDCh case   22:*/		return 0x82091DE0;
		  /* 82091DE0h */ case   23:  		/* addi R6, R6, -1 */
		/* 82091DE0h case   23:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0xFFFFFFFF);
		/* 82091DE0h case   23:*/		return 0x82091DE4;
		  /* 82091DE4h */ case   24:  		/* rlwimi R7, R8, 8, 16, 23 */
		/* 82091DE4h case   24:*/		cpu::op::rlwimi<0,8,16,23>(regs,&regs.R7,regs.R8);
		/* 82091DE4h case   24:*/		return 0x82091DE8;
		  /* 82091DE8h */ case   25:  		/* lbz R9, <#[R4 + 2]> */
		/* 82091DE8h case   25:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000002) );
		/* 82091DE8h case   25:*/		return 0x82091DEC;
		  /* 82091DECh */ case   26:  		/* cmplwi CR0, R6, 0 */
		/* 82091DECh case   26:*/		cpu::op::cmplwi<0>(regs,regs.R6,0x00000000);
		/* 82091DECh case   26:*/		return 0x82091DF0;
		  /* 82091DF0h */ case   27:  		/* rlwimi R7, R9, 16, 8, 15 */
		/* 82091DF0h case   27:*/		cpu::op::rlwimi<0,16,8,15>(regs,&regs.R7,regs.R9);
		/* 82091DF0h case   27:*/		return 0x82091DF4;
		  /* 82091DF4h */ case   28:  		/* lbz R10, <#[R4 + 1]> */
		/* 82091DF4h case   28:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000001) );
		/* 82091DF4h case   28:*/		return 0x82091DF8;
		  /* 82091DF8h */ case   29:  		/* addi R4, R4, 4 */
		/* 82091DF8h case   29:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 82091DF8h case   29:*/		return 0x82091DFC;
		  /* 82091DFCh */ case   30:  		/* rlwimi R7, R10, 24, 0, 7 */
		/* 82091DFCh case   30:*/		cpu::op::rlwimi<0,24,0,7>(regs,&regs.R7,regs.R10);
		/* 82091DFCh case   30:*/		return 0x82091E00;
		  /* 82091E00h */ case   31:  		/* stw R7, <#[R3 + 1]> */
		/* 82091E00h case   31:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000001) );
		/* 82091E00h case   31:*/		return 0x82091E04;
		  /* 82091E04h */ case   32:  		/* addi R3, R3, 4 */
		/* 82091E04h case   32:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 82091E04h case   32:*/		return 0x82091E08;
	}
	return 0x82091E08;
} // Block from 82091D84h-82091E08h (33 instructions)

//////////////////////////////////////////////////////
// Block at 82091E08h
// Function 'vswprintf_s'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091E08);
		  /* 82091E08h */ case    0:  		/* bc 4, CR0_EQ, -48 */
		/* 82091E08h case    0:*/		if ( !regs.CR[0].eq ) { return 0x82091DD8;  }
		/* 82091E08h case    0:*/		return 0x82091E0C;
		  /* 82091E0Ch */ case    1:  		/* cmplw CR0, R4, R11 */
		/* 82091E0Ch case    1:*/		cpu::op::cmplw<0>(regs,regs.R4,regs.R11);
		/* 82091E0Ch case    1:*/		return 0x82091E10;
		  /* 82091E10h */ case    2:  		/* bc 4, CR0_LT, 16 */
		/* 82091E10h case    2:*/		if ( !regs.CR[0].lt ) { return 0x82091E20;  }
		/* 82091E10h case    2:*/		return 0x82091E14;
		  /* 82091E14h */ case    3:  		/* dcbt R9, R4 */
		/* 82091E14h case    3:*/		cpu::op::dcbt<0>(regs,&regs.R9,regs.R4);
		/* 82091E14h case    3:*/		return 0x82091E18;
	}
	return 0x82091E18;
} // Block from 82091E08h-82091E18h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82091E18h
// Function '_vsnprintf_helper'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091E18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091E18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091E18);
		  /* 82091E18h */ case    0:  		/* bc 16, CR0_LT, -68 */
		/* 82091E18h case    0:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091DD4;  }
		/* 82091E18h case    0:*/		return 0x82091E1C;
		  /* 82091E1Ch */ case    1:  		/* b -228 */
		/* 82091E1Ch case    1:*/		return 0x82091D38;
		/* 82091E1Ch case    1:*/		return 0x82091E20;
	}
	return 0x82091E20;
} // Block from 82091E18h-82091E20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82091E20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091E20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091E20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091E20);
		  /* 82091E20h */ case    0:  		/* bc 12, CR1_EQ, 16 */
		/* 82091E20h case    0:*/		if ( regs.CR[1].eq ) { return 0x82091E30;  }
		/* 82091E20h case    0:*/		return 0x82091E24;
		  /* 82091E24h */ case    1:  		/* li R8, -1 */
		/* 82091E24h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 82091E24h case    1:*/		return 0x82091E28;
		  /* 82091E28h */ case    2:  		/* dcbtst R8, R12 */
		/* 82091E28h case    2:*/		cpu::op::dcbtst<0>(regs,&regs.R8,regs.R12);
		/* 82091E28h case    2:*/		return 0x82091E2C;
		  /* 82091E2Ch */ case    3:  		/* cmplwi CR1, R8, 0 */
		/* 82091E2Ch case    3:*/		cpu::op::cmplwi<1>(regs,regs.R8,0x00000000);
		/* 82091E2Ch case    3:*/		return 0x82091E30;
	}
	return 0x82091E30;
} // Block from 82091E20h-82091E30h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82091E30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091E30);
		  /* 82091E30h */ case    0:  		/* bc 16, CR0_LT, -92 */
		/* 82091E30h case    0:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091DD4;  }
		/* 82091E30h case    0:*/		return 0x82091E34;
		  /* 82091E34h */ case    1:  		/* b -252 */
		/* 82091E34h case    1:*/		return 0x82091D38;
		/* 82091E34h case    1:*/		return 0x82091E38;
	}
	return 0x82091E38;
} // Block from 82091E30h-82091E38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82091E38h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091E38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091E38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091E38);
		  /* 82091E38h */ case    0:  		/* addi R0, R5, 1 */
		/* 82091E38h case    0:*/		cpu::op::addi<0>(regs,&regs.R0,regs.R5,0x1);
		/* 82091E38h case    0:*/		return 0x82091E3C;
		  /* 82091E3Ch */ case    1:  		/* ori R6, R3, 0 */
		/* 82091E3Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R3,0x0);
		/* 82091E3Ch case    1:*/		return 0x82091E40;
		  /* 82091E40h */ case    2:  		/* mtspr CTR, R0 */
		/* 82091E40h case    2:*/		regs.CTR = regs.R0;
		/* 82091E40h case    2:*/		return 0x82091E44;
		  /* 82091E44h */ case    3:  		/* b 24 */
		/* 82091E44h case    3:*/		return 0x82091E5C;
		/* 82091E44h case    3:*/		return 0x82091E48;
		  /* 82091E48h */ case    4:  		/* addi R5, R5, -1 */
		/* 82091E48h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0xFFFFFFFF);
		/* 82091E48h case    4:*/		return 0x82091E4C;
		  /* 82091E4Ch */ case    5:  		/* lbz R0, <#[R4]> */
		/* 82091E4Ch case    5:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R4 + 0x00000000) );
		/* 82091E4Ch case    5:*/		return 0x82091E50;
		  /* 82091E50h */ case    6:  		/* addi R4, R4, 1 */
		/* 82091E50h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 82091E50h case    6:*/		return 0x82091E54;
		  /* 82091E54h */ case    7:  		/* stb R0, <#[R6]> */
		/* 82091E54h case    7:*/		cpu::mem::store8( regs, regs.R0, (uint32)(regs.R6 + 0x00000000) );
		/* 82091E54h case    7:*/		return 0x82091E58;
		  /* 82091E58h */ case    8:  		/* addi R6, R6, 1 */
		/* 82091E58h case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82091E58h case    8:*/		return 0x82091E5C;
	}
	return 0x82091E5C;
} // Block from 82091E38h-82091E5Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82091E5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091E5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091E5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091E5C);
		  /* 82091E5Ch */ case    0:  		/* andi. R0, R6, 3 */
		/* 82091E5Ch case    0:*/		cpu::op::andi<1>(regs,&regs.R0,regs.R6,0x3);
		/* 82091E5Ch case    0:*/		return 0x82091E60;
		  /* 82091E60h */ case    1:  		/* bc 0, CR0_EQ, -24 */
		/* 82091E60h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 && !regs.CR[0].eq ) { return 0x82091E48;  }
		/* 82091E60h case    1:*/		return 0x82091E64;
		  /* 82091E64h */ case    2:  		/* rlwinm. R0, R5, 30, 2, 31 */
		/* 82091E64h case    2:*/		cpu::op::rlwinm<1,30,2,31>(regs,&regs.R0,regs.R5);
		/* 82091E64h case    2:*/		return 0x82091E68;
		  /* 82091E68h */ case    3:  		/* bc 14, CR0_EQ, 36 */
		/* 82091E68h case    3:*/		if ( regs.CR[0].eq ) { return 0x82091E8C;  }
		/* 82091E68h case    3:*/		return 0x82091E6C;
		  /* 82091E6Ch */ case    4:  		/* mtspr CTR, R0 */
		/* 82091E6Ch case    4:*/		regs.CTR = regs.R0;
		/* 82091E6Ch case    4:*/		return 0x82091E70;
		  /* 82091E70h */ case    5:  		/* andi. R0, R4, 3 */
		/* 82091E70h case    5:*/		cpu::op::andi<1>(regs,&regs.R0,regs.R4,0x3);
		/* 82091E70h case    5:*/		return 0x82091E74;
		  /* 82091E74h */ case    6:  		/* bc 6, CR0_EQ, 60 */
		/* 82091E74h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82091EB0;  }
		/* 82091E74h case    6:*/		return 0x82091E78;
		  /* 82091E78h */ case    7:  		/* lwz R7, <#[R4]> */
		/* 82091E78h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000000) );
		/* 82091E78h case    7:*/		return 0x82091E7C;
		  /* 82091E7Ch */ case    8:  		/* addi R4, R4, 4 */
		/* 82091E7Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 82091E7Ch case    8:*/		return 0x82091E80;
		  /* 82091E80h */ case    9:  		/* stw R7, <#[R6]> */
		/* 82091E80h case    9:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R6 + 0x00000000) );
		/* 82091E80h case    9:*/		return 0x82091E84;
		  /* 82091E84h */ case   10:  		/* addi R6, R6, 4 */
		/* 82091E84h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x4);
		/* 82091E84h case   10:*/		return 0x82091E88;
		  /* 82091E88h */ case   11:  		/* bc 25, CR0_LT, -16 */
		/* 82091E88h case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091E78;  }
		/* 82091E88h case   11:*/		return 0x82091E8C;
	}
	return 0x82091E8C;
} // Block from 82091E5Ch-82091E8Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 82091E8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091E8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091E8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091E8C);
		  /* 82091E8Ch */ case    0:  		/* andi. R0, R5, 3 */
		/* 82091E8Ch case    0:*/		cpu::op::andi<1>(regs,&regs.R0,regs.R5,0x3);
		/* 82091E8Ch case    0:*/		return 0x82091E90;
		  /* 82091E90h */ case    1:  		/* mtspr CTR, R0 */
		/* 82091E90h case    1:*/		regs.CTR = regs.R0;
		/* 82091E90h case    1:*/		return 0x82091E94;
		  /* 82091E94h */ case    2:  		/* bclr 15, CR0_EQ */
		/* 82091E94h case    2:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82091E94h case    2:*/		return 0x82091E98;
	}
	return 0x82091E98;
} // Block from 82091E8Ch-82091E98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82091E98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091E98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091E98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091E98);
		  /* 82091E98h */ case    0:  		/* lbz R0, <#[R4]> */
		/* 82091E98h case    0:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R4 + 0x00000000) );
		/* 82091E98h case    0:*/		return 0x82091E9C;
		  /* 82091E9Ch */ case    1:  		/* addi R4, R4, 1 */
		/* 82091E9Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 82091E9Ch case    1:*/		return 0x82091EA0;
		  /* 82091EA0h */ case    2:  		/* stb R0, <#[R6]> */
		/* 82091EA0h case    2:*/		cpu::mem::store8( regs, regs.R0, (uint32)(regs.R6 + 0x00000000) );
		/* 82091EA0h case    2:*/		return 0x82091EA4;
		  /* 82091EA4h */ case    3:  		/* addi R6, R6, 1 */
		/* 82091EA4h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82091EA4h case    3:*/		return 0x82091EA8;
		  /* 82091EA8h */ case    4:  		/* bc 25, CR0_LT, -16 */
		/* 82091EA8h case    4:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091E98;  }
		/* 82091EA8h case    4:*/		return 0x82091EAC;
		  /* 82091EACh */ case    5:  		/* bclr 20, CR0_LT */
		/* 82091EACh case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82091EACh case    5:*/		return 0x82091EB0;
	}
	return 0x82091EB0;
} // Block from 82091E98h-82091EB0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82091EB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091EB0);
		  /* 82091EB0h */ case    0:  		/* lbz R7, <#[R4 + 3]> */
		/* 82091EB0h case    0:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000003) );
		/* 82091EB0h case    0:*/		return 0x82091EB4;
		  /* 82091EB4h */ case    1:  		/* lbz R8, <#[R4 + 2]> */
		/* 82091EB4h case    1:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000002) );
		/* 82091EB4h case    1:*/		return 0x82091EB8;
		  /* 82091EB8h */ case    2:  		/* rlwimi R7, R8, 8, 16, 23 */
		/* 82091EB8h case    2:*/		cpu::op::rlwimi<0,8,16,23>(regs,&regs.R7,regs.R8);
		/* 82091EB8h case    2:*/		return 0x82091EBC;
		  /* 82091EBCh */ case    3:  		/* lbz R9, <#[R4 + 1]> */
		/* 82091EBCh case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000001) );
		/* 82091EBCh case    3:*/		return 0x82091EC0;
		  /* 82091EC0h */ case    4:  		/* rlwimi R7, R9, 16, 8, 15 */
		/* 82091EC0h case    4:*/		cpu::op::rlwimi<0,16,8,15>(regs,&regs.R7,regs.R9);
		/* 82091EC0h case    4:*/		return 0x82091EC4;
		  /* 82091EC4h */ case    5:  		/* lbz R10, <#[R4]> */
		/* 82091EC4h case    5:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 82091EC4h case    5:*/		return 0x82091EC8;
		  /* 82091EC8h */ case    6:  		/* rlwimi R7, R10, 24, 0, 7 */
		/* 82091EC8h case    6:*/		cpu::op::rlwimi<0,24,0,7>(regs,&regs.R7,regs.R10);
		/* 82091EC8h case    6:*/		return 0x82091ECC;
		  /* 82091ECCh */ case    7:  		/* addi R4, R4, 4 */
		/* 82091ECCh case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 82091ECCh case    7:*/		return 0x82091ED0;
		  /* 82091ED0h */ case    8:  		/* stw R7, <#[R6]> */
		/* 82091ED0h case    8:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R6 + 0x00000000) );
		/* 82091ED0h case    8:*/		return 0x82091ED4;
		  /* 82091ED4h */ case    9:  		/* addi R6, R6, 4 */
		/* 82091ED4h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x4);
		/* 82091ED4h case    9:*/		return 0x82091ED8;
		  /* 82091ED8h */ case   10:  		/* bc 16, CR0_LT, -40 */
		/* 82091ED8h case   10:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091EB0;  }
		/* 82091ED8h case   10:*/		return 0x82091EDC;
		  /* 82091EDCh */ case   11:  		/* b -80 */
		/* 82091EDCh case   11:*/		return 0x82091E8C;
		/* 82091EDCh case   11:*/		return 0x82091EE0;
	}
	return 0x82091EE0;
} // Block from 82091EB0h-82091EE0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82091EE0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091EE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091EE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091EE0);
		  /* 82091EE0h */ case    0:  		/* fctidz FR12, FR1 */
		/* 82091EE0h case    0:*/		cpu::op::fctidz<0>(regs,&regs.FR12,regs.FR1);
		/* 82091EE0h case    0:*/		return 0x82091EE4;
		  /* 82091EE4h */ case    1:  		/* lis R11, -32256 */
		/* 82091EE4h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82091EE4h case    1:*/		return 0x82091EE8;
		  /* 82091EE8h */ case    2:  		/* fabs FR11, FR1 */
		/* 82091EE8h case    2:*/		cpu::op::fabs<0>(regs,&regs.FR11,regs.FR1);
		/* 82091EE8h case    2:*/		return 0x82091EEC;
		  /* 82091EECh */ case    3:  		/* lis R10, -32255 */
		/* 82091EECh case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 82091EECh case    3:*/		return 0x82091EF0;
		  /* 82091EF0h */ case    4:  		/* lfd FR13, <#[R11 + 1848]> */
		/* 82091EF0h case    4:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000738) );
		/* 82091EF0h case    4:*/		return 0x82091EF4;
		  /* 82091EF4h */ case    5:  		/* lfd FR0, <#[R10 - 24848]> */
		/* 82091EF4h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0xFFFF9EF0) );
		/* 82091EF4h case    5:*/		return 0x82091EF8;
		  /* 82091EF8h */ case    6:  		/* fcfid FR12, FR12 */
		/* 82091EF8h case    6:*/		cpu::op::fcfid<0>(regs,&regs.FR12,regs.FR12);
		/* 82091EF8h case    6:*/		return 0x82091EFC;
		  /* 82091EFCh */ case    7:  		/* fsub FR0, FR0, FR11 */
		/* 82091EFCh case    7:*/		cpu::op::fsub<0>(regs,&regs.FR0,regs.FR0,regs.FR11);
		/* 82091EFCh case    7:*/		return 0x82091F00;
		  /* 82091F00h */ case    8:  		/* fneg FR11, FR11 */
		/* 82091F00h case    8:*/		cpu::op::fneg<0>(regs,&regs.FR11,regs.FR11);
		/* 82091F00h case    8:*/		return 0x82091F04;
		  /* 82091F04h */ case    9:  		/* fsub FR10, FR1, FR12 */
		/* 82091F04h case    9:*/		cpu::op::fsub<0>(regs,&regs.FR10,regs.FR1,regs.FR12);
		/* 82091F04h case    9:*/		return 0x82091F08;
		  /* 82091F08h */ case   10:  		/* fsub FR13, FR12, FR13 */
		/* 82091F08h case   10:*/		cpu::op::fsub<0>(regs,&regs.FR13,regs.FR12,regs.FR13);
		/* 82091F08h case   10:*/		return 0x82091F0C;
		  /* 82091F0Ch */ case   11:  		/* fsel FR13, FR10, FR12, FR13 */
		/* 82091F0Ch case   11:*/		cpu::op::fsel<0>(regs,&regs.FR13,regs.FR10,regs.FR12,regs.FR13);
		/* 82091F0Ch case   11:*/		return 0x82091F10;
		  /* 82091F10h */ case   12:  		/* fsel FR0, FR0, FR13, FR1 */
		/* 82091F10h case   12:*/		cpu::op::fsel<0>(regs,&regs.FR0,regs.FR0,regs.FR13,regs.FR1);
		/* 82091F10h case   12:*/		return 0x82091F14;
		  /* 82091F14h */ case   13:  		/* fsel FR1, FR11, FR1, FR0 */
		/* 82091F14h case   13:*/		cpu::op::fsel<0>(regs,&regs.FR1,regs.FR11,regs.FR1,regs.FR0);
		/* 82091F14h case   13:*/		return 0x82091F18;
		  /* 82091F18h */ case   14:  		/* bclr 20, CR0_LT */
		/* 82091F18h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82091F18h case   14:*/		return 0x82091F1C;
	}
	return 0x82091F1C;
} // Block from 82091EE0h-82091F1Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 82091F1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091F1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091F1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091F1C);
		  /* 82091F1Ch */ case    0:  		/* nop */
		/* 82091F1Ch case    0:*/		cpu::op::nop();
		/* 82091F1Ch case    0:*/		return 0x82091F20;
	}
	return 0x82091F20;
} // Block from 82091F1Ch-82091F20h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82091F20h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091F20);
		  /* 82091F20h */ case    0:  		/* cmpw CR0, R3, R4 */
		/* 82091F20h case    0:*/		cpu::op::cmpw<0>(regs,regs.R3,regs.R4);
		/* 82091F20h case    0:*/		return 0x82091F24;
		  /* 82091F24h */ case    1:  		/* bclr 14, CR0_EQ */
		/* 82091F24h case    1:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82091F24h case    1:*/		return 0x82091F28;
	}
	return 0x82091F28;
} // Block from 82091F20h-82091F28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82091F28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091F28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091F28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091F28);
		  /* 82091F28h */ case    0:  		/* bc 7, CR0_LT, 8 */
		/* 82091F28h case    0:*/		if ( !regs.CR[0].lt ) { return 0x82091F30;  }
		/* 82091F28h case    0:*/		return 0x82091F2C;
		  /* 82091F2Ch */ case    1:  		/* b -1404 */
		/* 82091F2Ch case    1:*/		return 0x820919B0;
		/* 82091F2Ch case    1:*/		return 0x82091F30;
	}
	return 0x82091F30;
} // Block from 82091F28h-82091F30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82091F30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091F30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091F30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091F30);
		  /* 82091F30h */ case    0:  		/* addi R0, R5, 1 */
		/* 82091F30h case    0:*/		cpu::op::addi<0>(regs,&regs.R0,regs.R5,0x1);
		/* 82091F30h case    0:*/		return 0x82091F34;
		  /* 82091F34h */ case    1:  		/* add R3, R3, R5 */
		/* 82091F34h case    1:*/		cpu::op::add<0>(regs,&regs.R3,regs.R3,regs.R5);
		/* 82091F34h case    1:*/		return 0x82091F38;
	}
	return 0x82091F38;
} // Block from 82091F30h-82091F38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82091F38h
// Function '_vsprintf_s_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091F38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091F38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091F38);
		  /* 82091F38h */ case    0:  		/* add R4, R4, R5 */
		/* 82091F38h case    0:*/		cpu::op::add<0>(regs,&regs.R4,regs.R4,regs.R5);
		/* 82091F38h case    0:*/		return 0x82091F3C;
		  /* 82091F3Ch */ case    1:  		/* mtspr CTR, R0 */
		/* 82091F3Ch case    1:*/		regs.CTR = regs.R0;
		/* 82091F3Ch case    1:*/		return 0x82091F40;
		  /* 82091F40h */ case    2:  		/* b 24 */
		/* 82091F40h case    2:*/		return 0x82091F58;
		/* 82091F40h case    2:*/		return 0x82091F44;
		  /* 82091F44h */ case    3:  		/* addi R5, R5, -1 */
		/* 82091F44h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0xFFFFFFFF);
		/* 82091F44h case    3:*/		return 0x82091F48;
		  /* 82091F48h */ case    4:  		/* lbz R0, <#[R4 - 1]> */
		/* 82091F48h case    4:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R4 + 0xFFFFFFFF) );
		/* 82091F48h case    4:*/		return 0x82091F4C;
		  /* 82091F4Ch */ case    5:  		/* addi R4, R4, -1 */
		/* 82091F4Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFFFF);
		/* 82091F4Ch case    5:*/		return 0x82091F50;
		  /* 82091F50h */ case    6:  		/* stb R0, <#[R3 - 1]> */
		/* 82091F50h case    6:*/		cpu::mem::store8( regs, regs.R0, (uint32)(regs.R3 + 0xFFFFFFFF) );
		/* 82091F50h case    6:*/		return 0x82091F54;
		  /* 82091F54h */ case    7:  		/* addi R3, R3, -1 */
		/* 82091F54h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0xFFFFFFFF);
		/* 82091F54h case    7:*/		return 0x82091F58;
	}
	return 0x82091F58;
} // Block from 82091F38h-82091F58h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82091F58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091F58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091F58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091F58);
		  /* 82091F58h */ case    0:  		/* andi. R0, R3, 3 */
		/* 82091F58h case    0:*/		cpu::op::andi<1>(regs,&regs.R0,regs.R3,0x3);
		/* 82091F58h case    0:*/		return 0x82091F5C;
		  /* 82091F5Ch */ case    1:  		/* bc 0, CR0_EQ, -24 */
		/* 82091F5Ch case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 && !regs.CR[0].eq ) { return 0x82091F44;  }
		/* 82091F5Ch case    1:*/		return 0x82091F60;
		  /* 82091F60h */ case    2:  		/* rlwinm. R0, R5, 30, 2, 31 */
		/* 82091F60h case    2:*/		cpu::op::rlwinm<1,30,2,31>(regs,&regs.R0,regs.R5);
		/* 82091F60h case    2:*/		return 0x82091F64;
		  /* 82091F64h */ case    3:  		/* bc 14, CR0_EQ, 36 */
		/* 82091F64h case    3:*/		if ( regs.CR[0].eq ) { return 0x82091F88;  }
		/* 82091F64h case    3:*/		return 0x82091F68;
		  /* 82091F68h */ case    4:  		/* mtspr CTR, R0 */
		/* 82091F68h case    4:*/		regs.CTR = regs.R0;
		/* 82091F68h case    4:*/		return 0x82091F6C;
		  /* 82091F6Ch */ case    5:  		/* andi. R0, R4, 3 */
		/* 82091F6Ch case    5:*/		cpu::op::andi<1>(regs,&regs.R0,regs.R4,0x3);
		/* 82091F6Ch case    5:*/		return 0x82091F70;
		  /* 82091F70h */ case    6:  		/* bc 6, CR0_EQ, 60 */
		/* 82091F70h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82091FAC;  }
		/* 82091F70h case    6:*/		return 0x82091F74;
		  /* 82091F74h */ case    7:  		/* lwz R7, <#[R4 - 4]> */
		/* 82091F74h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R4 + 0xFFFFFFFC) );
		/* 82091F74h case    7:*/		return 0x82091F78;
		  /* 82091F78h */ case    8:  		/* addi R4, R4, -4 */
		/* 82091F78h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFFFC);
		/* 82091F78h case    8:*/		return 0x82091F7C;
		  /* 82091F7Ch */ case    9:  		/* stw R7, <#[R3 - 4]> */
		/* 82091F7Ch case    9:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0xFFFFFFFC) );
		/* 82091F7Ch case    9:*/		return 0x82091F80;
		  /* 82091F80h */ case   10:  		/* addi R3, R3, -4 */
		/* 82091F80h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0xFFFFFFFC);
		/* 82091F80h case   10:*/		return 0x82091F84;
		  /* 82091F84h */ case   11:  		/* bc 25, CR0_LT, -16 */
		/* 82091F84h case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091F74;  }
		/* 82091F84h case   11:*/		return 0x82091F88;
	}
	return 0x82091F88;
} // Block from 82091F58h-82091F88h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82091F88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091F88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091F88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091F88);
		  /* 82091F88h */ case    0:  		/* andi. R0, R5, 3 */
		/* 82091F88h case    0:*/		cpu::op::andi<1>(regs,&regs.R0,regs.R5,0x3);
		/* 82091F88h case    0:*/		return 0x82091F8C;
		  /* 82091F8Ch */ case    1:  		/* mtspr CTR, R0 */
		/* 82091F8Ch case    1:*/		regs.CTR = regs.R0;
		/* 82091F8Ch case    1:*/		return 0x82091F90;
		  /* 82091F90h */ case    2:  		/* bclr 15, CR0_EQ */
		/* 82091F90h case    2:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82091F90h case    2:*/		return 0x82091F94;
	}
	return 0x82091F94;
} // Block from 82091F88h-82091F94h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82091F94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091F94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091F94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091F94);
		  /* 82091F94h */ case    0:  		/* lbz R0, <#[R4 - 1]> */
		/* 82091F94h case    0:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R4 + 0xFFFFFFFF) );
		/* 82091F94h case    0:*/		return 0x82091F98;
		  /* 82091F98h */ case    1:  		/* addi R4, R4, -1 */
		/* 82091F98h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFFFF);
		/* 82091F98h case    1:*/		return 0x82091F9C;
		  /* 82091F9Ch */ case    2:  		/* stb R0, <#[R3 - 1]> */
		/* 82091F9Ch case    2:*/		cpu::mem::store8( regs, regs.R0, (uint32)(regs.R3 + 0xFFFFFFFF) );
		/* 82091F9Ch case    2:*/		return 0x82091FA0;
		  /* 82091FA0h */ case    3:  		/* addi R3, R3, -1 */
		/* 82091FA0h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0xFFFFFFFF);
		/* 82091FA0h case    3:*/		return 0x82091FA4;
		  /* 82091FA4h */ case    4:  		/* bc 25, CR0_LT, -16 */
		/* 82091FA4h case    4:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091F94;  }
		/* 82091FA4h case    4:*/		return 0x82091FA8;
		  /* 82091FA8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82091FA8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82091FA8h case    5:*/		return 0x82091FAC;
	}
	return 0x82091FAC;
} // Block from 82091F94h-82091FACh (6 instructions)

//////////////////////////////////////////////////////
// Block at 82091FACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091FAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091FAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091FAC);
		  /* 82091FACh */ case    0:  		/* lbz R7, <#[R4 - 1]> */
		/* 82091FACh case    0:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R4 + 0xFFFFFFFF) );
		/* 82091FACh case    0:*/		return 0x82091FB0;
		  /* 82091FB0h */ case    1:  		/* addi R3, R3, -4 */
		/* 82091FB0h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0xFFFFFFFC);
		/* 82091FB0h case    1:*/		return 0x82091FB4;
		  /* 82091FB4h */ case    2:  		/* lbz R8, <#[R4 - 2]> */
		/* 82091FB4h case    2:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R4 + 0xFFFFFFFE) );
		/* 82091FB4h case    2:*/		return 0x82091FB8;
		  /* 82091FB8h */ case    3:  		/* rlwimi R7, R8, 8, 16, 23 */
		/* 82091FB8h case    3:*/		cpu::op::rlwimi<0,8,16,23>(regs,&regs.R7,regs.R8);
		/* 82091FB8h case    3:*/		return 0x82091FBC;
		  /* 82091FBCh */ case    4:  		/* lbz R9, <#[R4 - 3]> */
		/* 82091FBCh case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R4 + 0xFFFFFFFD) );
		/* 82091FBCh case    4:*/		return 0x82091FC0;
		  /* 82091FC0h */ case    5:  		/* rlwimi R7, R9, 16, 8, 15 */
		/* 82091FC0h case    5:*/		cpu::op::rlwimi<0,16,8,15>(regs,&regs.R7,regs.R9);
		/* 82091FC0h case    5:*/		return 0x82091FC4;
		  /* 82091FC4h */ case    6:  		/* lbz R10, <#[R4 - 4]> */
		/* 82091FC4h case    6:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R4 + 0xFFFFFFFC) );
		/* 82091FC4h case    6:*/		return 0x82091FC8;
		  /* 82091FC8h */ case    7:  		/* rlwimi R7, R10, 24, 0, 7 */
		/* 82091FC8h case    7:*/		cpu::op::rlwimi<0,24,0,7>(regs,&regs.R7,regs.R10);
		/* 82091FC8h case    7:*/		return 0x82091FCC;
		  /* 82091FCCh */ case    8:  		/* addi R4, R4, -4 */
		/* 82091FCCh case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFFFC);
		/* 82091FCCh case    8:*/		return 0x82091FD0;
	}
	return 0x82091FD0;
} // Block from 82091FACh-82091FD0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82091FD0h
// Function 'vsprintf_s'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091FD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091FD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091FD0);
		  /* 82091FD0h */ case    0:  		/* stw R7, <#[R3]> */
		/* 82091FD0h case    0:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000000) );
		/* 82091FD0h case    0:*/		return 0x82091FD4;
		  /* 82091FD4h */ case    1:  		/* bc 16, CR0_LT, -40 */
		/* 82091FD4h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82091FAC;  }
		/* 82091FD4h case    1:*/		return 0x82091FD8;
		  /* 82091FD8h */ case    2:  		/* b -80 */
		/* 82091FD8h case    2:*/		return 0x82091F88;
		/* 82091FD8h case    2:*/		return 0x82091FDC;
		  /* 82091FDCh */ case    3:  		/* nop */
		/* 82091FDCh case    3:*/		cpu::op::nop();
		/* 82091FDCh case    3:*/		return 0x82091FE0;
	}
	return 0x82091FE0;
} // Block from 82091FD0h-82091FE0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82091FE0h
// Function '_vsnprintf_s_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82091FE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82091FE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82091FE0);
		  /* 82091FE0h */ case    0:  		/* mfspr R12, LR */
		/* 82091FE0h case    0:*/		regs.R12 = regs.LR;
		/* 82091FE0h case    0:*/		return 0x82091FE4;
		  /* 82091FE4h */ case    1:  		/* bl -3492 */
		/* 82091FE4h case    1:*/		regs.LR = 0x82091FE8; return 0x82091240;
		/* 82091FE4h case    1:*/		return 0x82091FE8;
		  /* 82091FE8h */ case    2:  		/* stwu R1, <#[R1 - 416]> */
		/* 82091FE8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE60);
		/* 82091FE8h case    2:*/		return 0x82091FEC;
		  /* 82091FECh */ case    3:  		/* mr R27, R5 */
		/* 82091FECh case    3:*/		regs.R27 = regs.R5;
		/* 82091FECh case    3:*/		return 0x82091FF0;
		  /* 82091FF0h */ case    4:  		/* mr R25, R6 */
		/* 82091FF0h case    4:*/		regs.R25 = regs.R6;
		/* 82091FF0h case    4:*/		return 0x82091FF4;
		  /* 82091FF4h */ case    5:  		/* cmplwi CR6, R3, 0 */
		/* 82091FF4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82091FF4h case    5:*/		return 0x82091FF8;
		  /* 82091FF8h */ case    6:  		/* bc 4, CR6_EQ, 36 */
		/* 82091FF8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8209201C;  }
		/* 82091FF8h case    6:*/		return 0x82091FFC;
		  /* 82091FFCh */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 82091FFCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82091FFCh case    7:*/		return 0x82092000;
		  /* 82092000h */ case    8:  		/* bc 12, CR6_EQ, 28 */
		/* 82092000h case    8:*/		if ( regs.CR[6].eq ) { return 0x8209201C;  }
		/* 82092000h case    8:*/		return 0x82092004;
		  /* 82092004h */ case    9:  		/* bl 12036 */
		/* 82092004h case    9:*/		regs.LR = 0x82092008; return 0x82094F08;
		/* 82092004h case    9:*/		return 0x82092008;
		  /* 82092008h */ case   10:  		/* li R11, 22 */
		/* 82092008h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 82092008h case   10:*/		return 0x8209200C;
		  /* 8209200Ch */ case   11:  		/* stw R11, <#[R3]> */
		/* 8209200Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209200Ch case   11:*/		return 0x82092010;
		  /* 82092010h */ case   12:  		/* bl 6480 */
		/* 82092010h case   12:*/		regs.LR = 0x82092014; return 0x82093960;
		/* 82092010h case   12:*/		return 0x82092014;
		  /* 82092014h */ case   13:  		/* addi R1, R1, 416 */
		/* 82092014h case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x1A0);
		/* 82092014h case   13:*/		return 0x82092018;
		  /* 82092018h */ case   14:  		/* b -3464 */
		/* 82092018h case   14:*/		return 0x82091290;
		/* 82092018h case   14:*/		return 0x8209201C;
	}
	return 0x8209201C;
} // Block from 82091FE0h-8209201Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8209201Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209201C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209201C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209201C);
		  /* 8209201Ch */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 8209201Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8209201Ch case    0:*/		return 0x82092020;
		  /* 82092020h */ case    1:  		/* bc 12, CR6_EQ, -28 */
		/* 82092020h case    1:*/		if ( regs.CR[6].eq ) { return 0x82092004;  }
		/* 82092020h case    1:*/		return 0x82092024;
		  /* 82092024h */ case    2:  		/* cmplwi CR6, R25, 0 */
		/* 82092024h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82092024h case    2:*/		return 0x82092028;
		  /* 82092028h */ case    3:  		/* bc 12, CR6_EQ, -36 */
		/* 82092028h case    3:*/		if ( regs.CR[6].eq ) { return 0x82092004;  }
		/* 82092028h case    3:*/		return 0x8209202C;
		  /* 8209202Ch */ case    4:  		/* cmplwi CR6, R4, 2 */
		/* 8209202Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000002);
		/* 8209202Ch case    4:*/		return 0x82092030;
		  /* 82092030h */ case    5:  		/* bc 12, CR6_LT, -28 */
		/* 82092030h case    5:*/		if ( regs.CR[6].lt ) { return 0x82092014;  }
		/* 82092030h case    5:*/		return 0x82092034;
		  /* 82092034h */ case    6:  		/* addi R11, R4, -1 */
		/* 82092034h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0xFFFFFFFF);
		/* 82092034h case    6:*/		return 0x82092038;
		  /* 82092038h */ case    7:  		/* addi R10, R1, 80 */
		/* 82092038h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82092038h case    7:*/		return 0x8209203C;
		  /* 8209203Ch */ case    8:  		/* mullw R11, R11, R27 */
		/* 8209203Ch case    8:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 8209203Ch case    8:*/		return 0x82092040;
		  /* 82092040h */ case    9:  		/* addi R9, R1, 208 */
		/* 82092040h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xD0);
		/* 82092040h case    9:*/		return 0x82092044;
		  /* 82092044h */ case   10:  		/* li R22, 0 */
		/* 82092044h case   10:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 82092044h case   10:*/		return 0x82092048;
		  /* 82092048h */ case   11:  		/* mr R26, R3 */
		/* 82092048h case   11:*/		regs.R26 = regs.R3;
		/* 82092048h case   11:*/		return 0x8209204C;
		  /* 8209204Ch */ case   12:  		/* add R28, R11, R3 */
		/* 8209204Ch case   12:*/		cpu::op::add<0>(regs,&regs.R28,regs.R11,regs.R3);
		/* 8209204Ch case   12:*/		return 0x82092050;
		  /* 82092050h */ case   13:  		/* addi R23, R10, -4 */
		/* 82092050h case   13:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R10,0xFFFFFFFC);
		/* 82092050h case   13:*/		return 0x82092054;
		  /* 82092054h */ case   14:  		/* addi R24, R9, -4 */
		/* 82092054h case   14:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R9,0xFFFFFFFC);
		/* 82092054h case   14:*/		return 0x82092058;
		  /* 82092058h */ case   15:  		/* subf R11, R26, R28 */
		/* 82092058h case   15:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R26,regs.R28);
		/* 82092058h case   15:*/		return 0x8209205C;
		  /* 8209205Ch */ case   16:  		/* twi 6, R27, 0 */
		/* 8209205Ch case   16:*/		cpu::op::tw<6>(regs, 0x8209205C, regs.R27, 0x00000000);
		/* 8209205Ch case   16:*/		return 0x82092060;
		  /* 82092060h */ case   17:  		/* divwu R11, R11, R27 */
		/* 82092060h case   17:*/		cpu::op::divwu<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 82092060h case   17:*/		return 0x82092064;
		  /* 82092064h */ case   18:  		/* addi R11, R11, 1 */
		/* 82092064h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82092064h case   18:*/		return 0x82092068;
		  /* 82092068h */ case   19:  		/* cmplwi CR6, R11, 8 */
		/* 82092068h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000008);
		/* 82092068h case   19:*/		return 0x8209206C;
		  /* 8209206Ch */ case   20:  		/* bc 12, CR6_GT, 160 */
		/* 8209206Ch case   20:*/		if ( regs.CR[6].gt ) { return 0x8209210C;  }
		/* 8209206Ch case   20:*/		return 0x82092070;
		  /* 82092070h */ case   21:  		/* mr R30, R28 */
		/* 82092070h case   21:*/		regs.R30 = regs.R28;
		/* 82092070h case   21:*/		return 0x82092074;
		  /* 82092074h */ case   22:  		/* cmplw CR6, R28, R26 */
		/* 82092074h case   22:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R26);
		/* 82092074h case   22:*/		return 0x82092078;
		  /* 82092078h */ case   23:  		/* bc 4, CR6_GT, 120 */
		/* 82092078h case   23:*/		if ( !regs.CR[6].gt ) { return 0x820920F0;  }
		/* 82092078h case   23:*/		return 0x8209207C;
		  /* 8209207Ch */ case   24:  		/* add R28, R26, R27 */
		/* 8209207Ch case   24:*/		cpu::op::add<0>(regs,&regs.R28,regs.R26,regs.R27);
		/* 8209207Ch case   24:*/		return 0x82092080;
		  /* 82092080h */ case   25:  		/* mr R29, R26 */
		/* 82092080h case   25:*/		regs.R29 = regs.R26;
		/* 82092080h case   25:*/		return 0x82092084;
		  /* 82092084h */ case   26:  		/* mr R31, R28 */
		/* 82092084h case   26:*/		regs.R31 = regs.R28;
		/* 82092084h case   26:*/		return 0x82092088;
		  /* 82092088h */ case   27:  		/* cmplw CR6, R28, R30 */
		/* 82092088h case   27:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R30);
		/* 82092088h case   27:*/		return 0x8209208C;
		  /* 8209208Ch */ case   28:  		/* bc 12, CR6_GT, 44 */
		/* 8209208Ch case   28:*/		if ( regs.CR[6].gt ) { return 0x820920B8;  }
		/* 8209208Ch case   28:*/		return 0x82092090;
		  /* 82092090h */ case   29:  		/* mr R4, R29 */
		/* 82092090h case   29:*/		regs.R4 = regs.R29;
		/* 82092090h case   29:*/		return 0x82092094;
		  /* 82092094h */ case   30:  		/* mtspr CTR, R25 */
		/* 82092094h case   30:*/		regs.CTR = regs.R25;
		/* 82092094h case   30:*/		return 0x82092098;
		  /* 82092098h */ case   31:  		/* mr R3, R31 */
		/* 82092098h case   31:*/		regs.R3 = regs.R31;
		/* 82092098h case   31:*/		return 0x8209209C;
		  /* 8209209Ch */ case   32:  		/* bcctrl 20, CR0_LT */
		/* 8209209Ch case   32:*/		if ( 1 ) { regs.LR = 0x820920A0; return (uint32)regs.CTR; }
		/* 8209209Ch case   32:*/		return 0x820920A0;
		  /* 820920A0h */ case   33:  		/* cmpwi CR6, R3, 0 */
		/* 820920A0h case   33:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820920A0h case   33:*/		return 0x820920A4;
		  /* 820920A4h */ case   34:  		/* bc 4, CR6_GT, 8 */
		/* 820920A4h case   34:*/		if ( !regs.CR[6].gt ) { return 0x820920AC;  }
		/* 820920A4h case   34:*/		return 0x820920A8;
		  /* 820920A8h */ case   35:  		/* mr R29, R31 */
		/* 820920A8h case   35:*/		regs.R29 = regs.R31;
		/* 820920A8h case   35:*/		return 0x820920AC;
	}
	return 0x820920AC;
} // Block from 8209201Ch-820920ACh (36 instructions)

//////////////////////////////////////////////////////
// Block at 820920ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820920AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820920AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820920AC);
		  /* 820920ACh */ case    0:  		/* add R31, R31, R27 */
		/* 820920ACh case    0:*/		cpu::op::add<0>(regs,&regs.R31,regs.R31,regs.R27);
		/* 820920ACh case    0:*/		return 0x820920B0;
		  /* 820920B0h */ case    1:  		/* cmplw CR6, R31, R30 */
		/* 820920B0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 820920B0h case    1:*/		return 0x820920B4;
		  /* 820920B4h */ case    2:  		/* bc 4, CR6_GT, -36 */
		/* 820920B4h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82092090;  }
		/* 820920B4h case    2:*/		return 0x820920B8;
	}
	return 0x820920B8;
} // Block from 820920ACh-820920B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820920B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820920B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820920B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820920B8);
		  /* 820920B8h */ case    0:  		/* mr R11, R30 */
		/* 820920B8h case    0:*/		regs.R11 = regs.R30;
		/* 820920B8h case    0:*/		return 0x820920BC;
		  /* 820920BCh */ case    1:  		/* cmplw CR6, R29, R30 */
		/* 820920BCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R30);
		/* 820920BCh case    1:*/		return 0x820920C0;
		  /* 820920C0h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820920C0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820920E4;  }
		/* 820920C0h case    2:*/		return 0x820920C4;
		  /* 820920C4h */ case    3:  		/* subf R10, R30, R29 */
		/* 820920C4h case    3:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R30,regs.R29);
		/* 820920C4h case    3:*/		return 0x820920C8;
		  /* 820920C8h */ case    4:  		/* mtspr CTR, R27 */
		/* 820920C8h case    4:*/		regs.CTR = regs.R27;
		/* 820920C8h case    4:*/		return 0x820920CC;
		  /* 820920CCh */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820920CCh case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820920CCh case    5:*/		return 0x820920D0;
		  /* 820920D0h */ case    6:  		/* lbzx R8, <#[R10 + R11]> */
		/* 820920D0h case    6:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820920D0h case    6:*/		return 0x820920D4;
		  /* 820920D4h */ case    7:  		/* stbx R9, <#[R10 + R11]> */
		/* 820920D4h case    7:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820920D4h case    7:*/		return 0x820920D8;
		  /* 820920D8h */ case    8:  		/* stb R8, <#[R11]> */
		/* 820920D8h case    8:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820920D8h case    8:*/		return 0x820920DC;
		  /* 820920DCh */ case    9:  		/* addi R11, R11, 1 */
		/* 820920DCh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820920DCh case    9:*/		return 0x820920E0;
		  /* 820920E0h */ case   10:  		/* bc 16, CR0_LT, -20 */
		/* 820920E0h case   10:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820920CC;  }
		/* 820920E0h case   10:*/		return 0x820920E4;
	}
	return 0x820920E4;
} // Block from 820920B8h-820920E4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820920E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820920E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820920E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820920E4);
		  /* 820920E4h */ case    0:  		/* subf R30, R27, R30 */
		/* 820920E4h case    0:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R27,regs.R30);
		/* 820920E4h case    0:*/		return 0x820920E8;
		  /* 820920E8h */ case    1:  		/* cmplw CR6, R30, R26 */
		/* 820920E8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R26);
		/* 820920E8h case    1:*/		return 0x820920EC;
		  /* 820920ECh */ case    2:  		/* bc 12, CR6_GT, -108 */
		/* 820920ECh case    2:*/		if ( regs.CR[6].gt ) { return 0x82092080;  }
		/* 820920ECh case    2:*/		return 0x820920F0;
	}
	return 0x820920F0;
} // Block from 820920E4h-820920F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820920F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820920F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820920F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820920F0);
		  /* 820920F0h */ case    0:  		/* addic. R22, R22, -1 */
		/* 820920F0h case    0:*/		cpu::op::addic<1>(regs,&regs.R22,regs.R22,0xFFFFFFFF);
		/* 820920F0h case    0:*/		return 0x820920F4;
		  /* 820920F4h */ case    1:  		/* addi R24, R24, -4 */
		/* 820920F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0xFFFFFFFC);
		/* 820920F4h case    1:*/		return 0x820920F8;
		  /* 820920F8h */ case    2:  		/* addi R23, R23, -4 */
		/* 820920F8h case    2:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0xFFFFFFFC);
		/* 820920F8h case    2:*/		return 0x820920FC;
		  /* 820920FCh */ case    3:  		/* bc 12, CR0_LT, -232 */
		/* 820920FCh case    3:*/		if ( regs.CR[0].lt ) { return 0x82092014;  }
		/* 820920FCh case    3:*/		return 0x82092100;
		  /* 82092100h */ case    4:  		/* lwz R26, <#[R24 + 4]> */
		/* 82092100h case    4:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R24 + 0x00000004) );
		/* 82092100h case    4:*/		return 0x82092104;
		  /* 82092104h */ case    5:  		/* lwz R28, <#[R23 + 4]> */
		/* 82092104h case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R23 + 0x00000004) );
		/* 82092104h case    5:*/		return 0x82092108;
		  /* 82092108h */ case    6:  		/* b -176 */
		/* 82092108h case    6:*/		return 0x82092058;
		/* 82092108h case    6:*/		return 0x8209210C;
	}
	return 0x8209210C;
} // Block from 820920F0h-8209210Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209210Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209210C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209210C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209210C);
		  /* 8209210Ch */ case    0:  		/* rlwinm R11, R11, 31, 1, 31 */
		/* 8209210Ch case    0:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R11,regs.R11);
		/* 8209210Ch case    0:*/		return 0x82092110;
		  /* 82092110h */ case    1:  		/* mtspr CTR, R25 */
		/* 82092110h case    1:*/		regs.CTR = regs.R25;
		/* 82092110h case    1:*/		return 0x82092114;
		  /* 82092114h */ case    2:  		/* mr R3, R26 */
		/* 82092114h case    2:*/		regs.R3 = regs.R26;
		/* 82092114h case    2:*/		return 0x82092118;
		  /* 82092118h */ case    3:  		/* mullw R11, R11, R27 */
		/* 82092118h case    3:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 82092118h case    3:*/		return 0x8209211C;
		  /* 8209211Ch */ case    4:  		/* add R29, R11, R26 */
		/* 8209211Ch case    4:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R26);
		/* 8209211Ch case    4:*/		return 0x82092120;
		  /* 82092120h */ case    5:  		/* mr R4, R29 */
		/* 82092120h case    5:*/		regs.R4 = regs.R29;
		/* 82092120h case    5:*/		return 0x82092124;
		  /* 82092124h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 82092124h case    6:*/		if ( 1 ) { regs.LR = 0x82092128; return (uint32)regs.CTR; }
		/* 82092124h case    6:*/		return 0x82092128;
		  /* 82092128h */ case    7:  		/* cmpwi CR6, R3, 0 */
		/* 82092128h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 82092128h case    7:*/		return 0x8209212C;
		  /* 8209212Ch */ case    8:  		/* bc 4, CR6_GT, 48 */
		/* 8209212Ch case    8:*/		if ( !regs.CR[6].gt ) { return 0x8209215C;  }
		/* 8209212Ch case    8:*/		return 0x82092130;
	}
	return 0x82092130;
} // Block from 8209210Ch-82092130h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82092130h
// Function '_vsnprintf_s'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092130);
		  /* 82092130h */ case    0:  		/* mr R11, R29 */
		/* 82092130h case    0:*/		regs.R11 = regs.R29;
		/* 82092130h case    0:*/		return 0x82092134;
		  /* 82092134h */ case    1:  		/* cmplw CR6, R26, R29 */
		/* 82092134h case    1:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R29);
		/* 82092134h case    1:*/		return 0x82092138;
		  /* 82092138h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 82092138h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209215C;  }
		/* 82092138h case    2:*/		return 0x8209213C;
		  /* 8209213Ch */ case    3:  		/* subf R10, R29, R26 */
		/* 8209213Ch case    3:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R29,regs.R26);
		/* 8209213Ch case    3:*/		return 0x82092140;
	}
	return 0x82092140;
} // Block from 82092130h-82092140h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82092140h
// Function 'srand'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092140);
		  /* 82092140h */ case    0:  		/* mtspr CTR, R27 */
		/* 82092140h case    0:*/		regs.CTR = regs.R27;
		/* 82092140h case    0:*/		return 0x82092144;
		  /* 82092144h */ case    1:  		/* lbz R9, <#[R11]> */
		/* 82092144h case    1:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82092144h case    1:*/		return 0x82092148;
		  /* 82092148h */ case    2:  		/* lbzx R8, <#[R10 + R11]> */
		/* 82092148h case    2:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82092148h case    2:*/		return 0x8209214C;
		  /* 8209214Ch */ case    3:  		/* stbx R9, <#[R10 + R11]> */
		/* 8209214Ch case    3:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8209214Ch case    3:*/		return 0x82092150;
		  /* 82092150h */ case    4:  		/* stb R8, <#[R11]> */
		/* 82092150h case    4:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82092150h case    4:*/		return 0x82092154;
		  /* 82092154h */ case    5:  		/* addi R11, R11, 1 */
		/* 82092154h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82092154h case    5:*/		return 0x82092158;
		  /* 82092158h */ case    6:  		/* bc 16, CR0_LT, -20 */
		/* 82092158h case    6:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82092144;  }
		/* 82092158h case    6:*/		return 0x8209215C;
	}
	return 0x8209215C;
} // Block from 82092140h-8209215Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209215Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209215C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209215C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209215C);
		  /* 8209215Ch */ case    0:  		/* mr R4, R28 */
		/* 8209215Ch case    0:*/		regs.R4 = regs.R28;
		/* 8209215Ch case    0:*/		return 0x82092160;
		  /* 82092160h */ case    1:  		/* mtspr CTR, R25 */
		/* 82092160h case    1:*/		regs.CTR = regs.R25;
		/* 82092160h case    1:*/		return 0x82092164;
		  /* 82092164h */ case    2:  		/* mr R3, R26 */
		/* 82092164h case    2:*/		regs.R3 = regs.R26;
		/* 82092164h case    2:*/		return 0x82092168;
		  /* 82092168h */ case    3:  		/* bcctrl 20, CR0_LT */
		/* 82092168h case    3:*/		if ( 1 ) { regs.LR = 0x8209216C; return (uint32)regs.CTR; }
		/* 82092168h case    3:*/		return 0x8209216C;
		  /* 8209216Ch */ case    4:  		/* cmpwi CR6, R3, 0 */
		/* 8209216Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8209216Ch case    4:*/		return 0x82092170;
	}
	return 0x82092170;
} // Block from 8209215Ch-82092170h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82092170h
// Function 'rand'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092170);
		  /* 82092170h */ case    0:  		/* bc 4, CR6_GT, 48 */
		/* 82092170h case    0:*/		if ( !regs.CR[6].gt ) { return 0x820921A0;  }
		/* 82092170h case    0:*/		return 0x82092174;
		  /* 82092174h */ case    1:  		/* mr R11, R28 */
		/* 82092174h case    1:*/		regs.R11 = regs.R28;
		/* 82092174h case    1:*/		return 0x82092178;
		  /* 82092178h */ case    2:  		/* cmplw CR6, R26, R28 */
		/* 82092178h case    2:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R28);
		/* 82092178h case    2:*/		return 0x8209217C;
		  /* 8209217Ch */ case    3:  		/* bc 12, CR6_EQ, 36 */
		/* 8209217Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820921A0;  }
		/* 8209217Ch case    3:*/		return 0x82092180;
		  /* 82092180h */ case    4:  		/* subf R10, R28, R26 */
		/* 82092180h case    4:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R28,regs.R26);
		/* 82092180h case    4:*/		return 0x82092184;
		  /* 82092184h */ case    5:  		/* mtspr CTR, R27 */
		/* 82092184h case    5:*/		regs.CTR = regs.R27;
		/* 82092184h case    5:*/		return 0x82092188;
		  /* 82092188h */ case    6:  		/* lbz R9, <#[R11]> */
		/* 82092188h case    6:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82092188h case    6:*/		return 0x8209218C;
		  /* 8209218Ch */ case    7:  		/* lbzx R8, <#[R10 + R11]> */
		/* 8209218Ch case    7:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8209218Ch case    7:*/		return 0x82092190;
		  /* 82092190h */ case    8:  		/* stbx R9, <#[R10 + R11]> */
		/* 82092190h case    8:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82092190h case    8:*/		return 0x82092194;
		  /* 82092194h */ case    9:  		/* stb R8, <#[R11]> */
		/* 82092194h case    9:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82092194h case    9:*/		return 0x82092198;
		  /* 82092198h */ case   10:  		/* addi R11, R11, 1 */
		/* 82092198h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82092198h case   10:*/		return 0x8209219C;
		  /* 8209219Ch */ case   11:  		/* bc 16, CR0_LT, -20 */
		/* 8209219Ch case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82092188;  }
		/* 8209219Ch case   11:*/		return 0x820921A0;
	}
	return 0x820921A0;
} // Block from 82092170h-820921A0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820921A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820921A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820921A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820921A0);
		  /* 820921A0h */ case    0:  		/* mr R4, R28 */
		/* 820921A0h case    0:*/		regs.R4 = regs.R28;
		/* 820921A0h case    0:*/		return 0x820921A4;
		  /* 820921A4h */ case    1:  		/* mtspr CTR, R25 */
		/* 820921A4h case    1:*/		regs.CTR = regs.R25;
		/* 820921A4h case    1:*/		return 0x820921A8;
		  /* 820921A8h */ case    2:  		/* mr R3, R29 */
		/* 820921A8h case    2:*/		regs.R3 = regs.R29;
		/* 820921A8h case    2:*/		return 0x820921AC;
		  /* 820921ACh */ case    3:  		/* bcctrl 20, CR0_LT */
		/* 820921ACh case    3:*/		if ( 1 ) { regs.LR = 0x820921B0; return (uint32)regs.CTR; }
		/* 820921ACh case    3:*/		return 0x820921B0;
	}
	return 0x820921B0;
} // Block from 820921A0h-820921B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820921B0h
// Function '_purecall'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820921B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820921B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820921B0);
		  /* 820921B0h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820921B0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820921B0h case    0:*/		return 0x820921B4;
		  /* 820921B4h */ case    1:  		/* bc 4, CR6_GT, 48 */
		/* 820921B4h case    1:*/		if ( !regs.CR[6].gt ) { return 0x820921E4;  }
		/* 820921B4h case    1:*/		return 0x820921B8;
		  /* 820921B8h */ case    2:  		/* mr R11, R28 */
		/* 820921B8h case    2:*/		regs.R11 = regs.R28;
		/* 820921B8h case    2:*/		return 0x820921BC;
		  /* 820921BCh */ case    3:  		/* cmplw CR6, R29, R28 */
		/* 820921BCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R28);
		/* 820921BCh case    3:*/		return 0x820921C0;
		  /* 820921C0h */ case    4:  		/* bc 12, CR6_EQ, 36 */
		/* 820921C0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820921E4;  }
		/* 820921C0h case    4:*/		return 0x820921C4;
		  /* 820921C4h */ case    5:  		/* subf R10, R28, R29 */
		/* 820921C4h case    5:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R28,regs.R29);
		/* 820921C4h case    5:*/		return 0x820921C8;
		  /* 820921C8h */ case    6:  		/* mtspr CTR, R27 */
		/* 820921C8h case    6:*/		regs.CTR = regs.R27;
		/* 820921C8h case    6:*/		return 0x820921CC;
		  /* 820921CCh */ case    7:  		/* lbz R9, <#[R11]> */
		/* 820921CCh case    7:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820921CCh case    7:*/		return 0x820921D0;
		  /* 820921D0h */ case    8:  		/* lbzx R8, <#[R10 + R11]> */
		/* 820921D0h case    8:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820921D0h case    8:*/		return 0x820921D4;
		  /* 820921D4h */ case    9:  		/* stbx R9, <#[R10 + R11]> */
		/* 820921D4h case    9:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820921D4h case    9:*/		return 0x820921D8;
		  /* 820921D8h */ case   10:  		/* stb R8, <#[R11]> */
		/* 820921D8h case   10:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820921D8h case   10:*/		return 0x820921DC;
		  /* 820921DCh */ case   11:  		/* addi R11, R11, 1 */
		/* 820921DCh case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820921DCh case   11:*/		return 0x820921E0;
		  /* 820921E0h */ case   12:  		/* bc 16, CR0_LT, -20 */
		/* 820921E0h case   12:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820921CC;  }
		/* 820921E0h case   12:*/		return 0x820921E4;
	}
	return 0x820921E4;
} // Block from 820921B0h-820921E4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820921E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820921E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820921E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820921E4);
		  /* 820921E4h */ case    0:  		/* mr R31, R26 */
		/* 820921E4h case    0:*/		regs.R31 = regs.R26;
		/* 820921E4h case    0:*/		return 0x820921E8;
		  /* 820921E8h */ case    1:  		/* mr R30, R28 */
		/* 820921E8h case    1:*/		regs.R30 = regs.R28;
		/* 820921E8h case    1:*/		return 0x820921EC;
		  /* 820921ECh */ case    2:  		/* cmplw CR6, R29, R31 */
		/* 820921ECh case    2:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R31);
		/* 820921ECh case    2:*/		return 0x820921F0;
		  /* 820921F0h */ case    3:  		/* bc 4, CR6_GT, 48 */
		/* 820921F0h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82092220;  }
		/* 820921F0h case    3:*/		return 0x820921F4;
		  /* 820921F4h */ case    4:  		/* add R31, R31, R27 */
		/* 820921F4h case    4:*/		cpu::op::add<0>(regs,&regs.R31,regs.R31,regs.R27);
		/* 820921F4h case    4:*/		return 0x820921F8;
		  /* 820921F8h */ case    5:  		/* cmplw CR6, R31, R29 */
		/* 820921F8h case    5:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 820921F8h case    5:*/		return 0x820921FC;
		  /* 820921FCh */ case    6:  		/* bc 4, CR6_LT, 36 */
		/* 820921FCh case    6:*/		if ( !regs.CR[6].lt ) { return 0x82092220;  }
		/* 820921FCh case    6:*/		return 0x82092200;
	}
	return 0x82092200;
} // Block from 820921E4h-82092200h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82092200h
// Function 'floor'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092200);
		  /* 82092200h */ case    0:  		/* mr R4, R29 */
		/* 82092200h case    0:*/		regs.R4 = regs.R29;
		/* 82092200h case    0:*/		return 0x82092204;
		  /* 82092204h */ case    1:  		/* mtspr CTR, R25 */
		/* 82092204h case    1:*/		regs.CTR = regs.R25;
		/* 82092204h case    1:*/		return 0x82092208;
		  /* 82092208h */ case    2:  		/* mr R3, R31 */
		/* 82092208h case    2:*/		regs.R3 = regs.R31;
		/* 82092208h case    2:*/		return 0x8209220C;
		  /* 8209220Ch */ case    3:  		/* bcctrl 20, CR0_LT */
		/* 8209220Ch case    3:*/		if ( 1 ) { regs.LR = 0x82092210; return (uint32)regs.CTR; }
		/* 8209220Ch case    3:*/		return 0x82092210;
		  /* 82092210h */ case    4:  		/* cmpwi CR6, R3, 0 */
		/* 82092210h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 82092210h case    4:*/		return 0x82092214;
		  /* 82092214h */ case    5:  		/* bc 4, CR6_GT, -32 */
		/* 82092214h case    5:*/		if ( !regs.CR[6].gt ) { return 0x820921F4;  }
		/* 82092214h case    5:*/		return 0x82092218;
		  /* 82092218h */ case    6:  		/* cmplw CR6, R29, R31 */
		/* 82092218h case    6:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R31);
		/* 82092218h case    6:*/		return 0x8209221C;
		  /* 8209221Ch */ case    7:  		/* bc 12, CR6_GT, 40 */
		/* 8209221Ch case    7:*/		if ( regs.CR[6].gt ) { return 0x82092244;  }
		/* 8209221Ch case    7:*/		return 0x82092220;
	}
	return 0x82092220;
} // Block from 82092200h-82092220h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82092220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092220);
		  /* 82092220h */ case    0:  		/* add R31, R31, R27 */
		/* 82092220h case    0:*/		cpu::op::add<0>(regs,&regs.R31,regs.R31,regs.R27);
		/* 82092220h case    0:*/		return 0x82092224;
		  /* 82092224h */ case    1:  		/* cmplw CR6, R31, R28 */
		/* 82092224h case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R28);
		/* 82092224h case    1:*/		return 0x82092228;
		  /* 82092228h */ case    2:  		/* bc 12, CR6_GT, 28 */
		/* 82092228h case    2:*/		if ( regs.CR[6].gt ) { return 0x82092244;  }
		/* 82092228h case    2:*/		return 0x8209222C;
		  /* 8209222Ch */ case    3:  		/* mr R4, R29 */
		/* 8209222Ch case    3:*/		regs.R4 = regs.R29;
		/* 8209222Ch case    3:*/		return 0x82092230;
		  /* 82092230h */ case    4:  		/* mtspr CTR, R25 */
		/* 82092230h case    4:*/		regs.CTR = regs.R25;
		/* 82092230h case    4:*/		return 0x82092234;
		  /* 82092234h */ case    5:  		/* mr R3, R31 */
		/* 82092234h case    5:*/		regs.R3 = regs.R31;
		/* 82092234h case    5:*/		return 0x82092238;
		  /* 82092238h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 82092238h case    6:*/		if ( 1 ) { regs.LR = 0x8209223C; return (uint32)regs.CTR; }
		/* 82092238h case    6:*/		return 0x8209223C;
		  /* 8209223Ch */ case    7:  		/* cmpwi CR6, R3, 0 */
		/* 8209223Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8209223Ch case    7:*/		return 0x82092240;
	}
	return 0x82092240;
} // Block from 82092220h-82092240h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82092240h
// Function 'memmove'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092240);
		  /* 82092240h */ case    0:  		/* bc 4, CR6_GT, -32 */
		/* 82092240h case    0:*/		if ( !regs.CR[6].gt ) { return 0x82092220;  }
		/* 82092240h case    0:*/		return 0x82092244;
	}
	return 0x82092244;
} // Block from 82092240h-82092244h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82092244h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092244( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092244) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092244);
		  /* 82092244h */ case    0:  		/* subf R30, R27, R30 */
		/* 82092244h case    0:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R27,regs.R30);
		/* 82092244h case    0:*/		return 0x82092248;
		  /* 82092248h */ case    1:  		/* cmplw CR6, R30, R29 */
		/* 82092248h case    1:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R29);
		/* 82092248h case    1:*/		return 0x8209224C;
		  /* 8209224Ch */ case    2:  		/* bc 4, CR6_GT, 28 */
		/* 8209224Ch case    2:*/		if ( !regs.CR[6].gt ) { return 0x82092268;  }
		/* 8209224Ch case    2:*/		return 0x82092250;
		  /* 82092250h */ case    3:  		/* mr R4, R29 */
		/* 82092250h case    3:*/		regs.R4 = regs.R29;
		/* 82092250h case    3:*/		return 0x82092254;
		  /* 82092254h */ case    4:  		/* mtspr CTR, R25 */
		/* 82092254h case    4:*/		regs.CTR = regs.R25;
		/* 82092254h case    4:*/		return 0x82092258;
		  /* 82092258h */ case    5:  		/* mr R3, R30 */
		/* 82092258h case    5:*/		regs.R3 = regs.R30;
		/* 82092258h case    5:*/		return 0x8209225C;
		  /* 8209225Ch */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 8209225Ch case    6:*/		if ( 1 ) { regs.LR = 0x82092260; return (uint32)regs.CTR; }
		/* 8209225Ch case    6:*/		return 0x82092260;
		  /* 82092260h */ case    7:  		/* cmpwi CR6, R3, 0 */
		/* 82092260h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 82092260h case    7:*/		return 0x82092264;
		  /* 82092264h */ case    8:  		/* bc 12, CR6_GT, -32 */
		/* 82092264h case    8:*/		if ( regs.CR[6].gt ) { return 0x82092244;  }
		/* 82092264h case    8:*/		return 0x82092268;
	}
	return 0x82092268;
} // Block from 82092244h-82092268h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82092268h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092268);
		  /* 82092268h */ case    0:  		/* cmplw CR6, R31, R30 */
		/* 82092268h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 82092268h case    0:*/		return 0x8209226C;
		  /* 8209226Ch */ case    1:  		/* bc 12, CR6_GT, 60 */
		/* 8209226Ch case    1:*/		if ( regs.CR[6].gt ) { return 0x820922A8;  }
		/* 8209226Ch case    1:*/		return 0x82092270;
		  /* 82092270h */ case    2:  		/* mr R11, R30 */
		/* 82092270h case    2:*/		regs.R11 = regs.R30;
		/* 82092270h case    2:*/		return 0x82092274;
		  /* 82092274h */ case    3:  		/* bc 12, CR6_EQ, 36 */
		/* 82092274h case    3:*/		if ( regs.CR[6].eq ) { return 0x82092298;  }
		/* 82092274h case    3:*/		return 0x82092278;
		  /* 82092278h */ case    4:  		/* subf R10, R30, R31 */
		/* 82092278h case    4:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R30,regs.R31);
		/* 82092278h case    4:*/		return 0x8209227C;
		  /* 8209227Ch */ case    5:  		/* mtspr CTR, R27 */
		/* 8209227Ch case    5:*/		regs.CTR = regs.R27;
		/* 8209227Ch case    5:*/		return 0x82092280;
		  /* 82092280h */ case    6:  		/* lbz R9, <#[R11]> */
		/* 82092280h case    6:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82092280h case    6:*/		return 0x82092284;
		  /* 82092284h */ case    7:  		/* lbzx R8, <#[R10 + R11]> */
		/* 82092284h case    7:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82092284h case    7:*/		return 0x82092288;
		  /* 82092288h */ case    8:  		/* stbx R9, <#[R10 + R11]> */
		/* 82092288h case    8:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82092288h case    8:*/		return 0x8209228C;
		  /* 8209228Ch */ case    9:  		/* stb R8, <#[R11]> */
		/* 8209228Ch case    9:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8209228Ch case    9:*/		return 0x82092290;
		  /* 82092290h */ case   10:  		/* addi R11, R11, 1 */
		/* 82092290h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82092290h case   10:*/		return 0x82092294;
		  /* 82092294h */ case   11:  		/* bc 16, CR0_LT, -20 */
		/* 82092294h case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82092280;  }
		/* 82092294h case   11:*/		return 0x82092298;
	}
	return 0x82092298;
} // Block from 82092268h-82092298h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82092298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092298);
		  /* 82092298h */ case    0:  		/* cmplw CR6, R29, R30 */
		/* 82092298h case    0:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R30);
		/* 82092298h case    0:*/		return 0x8209229C;
		  /* 8209229Ch */ case    1:  		/* bc 4, CR6_EQ, -176 */
		/* 8209229Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820921EC;  }
		/* 8209229Ch case    1:*/		return 0x820922A0;
		  /* 820922A0h */ case    2:  		/* mr R29, R31 */
		/* 820922A0h case    2:*/		regs.R29 = regs.R31;
		/* 820922A0h case    2:*/		return 0x820922A4;
		  /* 820922A4h */ case    3:  		/* b -184 */
		/* 820922A4h case    3:*/		return 0x820921EC;
		/* 820922A4h case    3:*/		return 0x820922A8;
	}
	return 0x820922A8;
} // Block from 82092298h-820922A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820922A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820922A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820922A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820922A8);
		  /* 820922A8h */ case    0:  		/* add R30, R30, R27 */
		/* 820922A8h case    0:*/		cpu::op::add<0>(regs,&regs.R30,regs.R30,regs.R27);
		/* 820922A8h case    0:*/		return 0x820922AC;
		  /* 820922ACh */ case    1:  		/* cmplw CR6, R29, R30 */
		/* 820922ACh case    1:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R30);
		/* 820922ACh case    1:*/		return 0x820922B0;
		  /* 820922B0h */ case    2:  		/* bc 4, CR6_LT, 48 */
		/* 820922B0h case    2:*/		if ( !regs.CR[6].lt ) { return 0x820922E0;  }
		/* 820922B0h case    2:*/		return 0x820922B4;
		  /* 820922B4h */ case    3:  		/* subf R30, R27, R30 */
		/* 820922B4h case    3:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R27,regs.R30);
		/* 820922B4h case    3:*/		return 0x820922B8;
		  /* 820922B8h */ case    4:  		/* cmplw CR6, R30, R29 */
		/* 820922B8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R29);
		/* 820922B8h case    4:*/		return 0x820922BC;
		  /* 820922BCh */ case    5:  		/* bc 4, CR6_GT, 36 */
		/* 820922BCh case    5:*/		if ( !regs.CR[6].gt ) { return 0x820922E0;  }
		/* 820922BCh case    5:*/		return 0x820922C0;
		  /* 820922C0h */ case    6:  		/* mr R4, R29 */
		/* 820922C0h case    6:*/		regs.R4 = regs.R29;
		/* 820922C0h case    6:*/		return 0x820922C4;
		  /* 820922C4h */ case    7:  		/* mtspr CTR, R25 */
		/* 820922C4h case    7:*/		regs.CTR = regs.R25;
		/* 820922C4h case    7:*/		return 0x820922C8;
		  /* 820922C8h */ case    8:  		/* mr R3, R30 */
		/* 820922C8h case    8:*/		regs.R3 = regs.R30;
		/* 820922C8h case    8:*/		return 0x820922CC;
		  /* 820922CCh */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820922CCh case    9:*/		if ( 1 ) { regs.LR = 0x820922D0; return (uint32)regs.CTR; }
		/* 820922CCh case    9:*/		return 0x820922D0;
		  /* 820922D0h */ case   10:  		/* cmpwi CR6, R3, 0 */
		/* 820922D0h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820922D0h case   10:*/		return 0x820922D4;
		  /* 820922D4h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820922D4h case   11:*/		if ( regs.CR[6].eq ) { return 0x820922B4;  }
		/* 820922D4h case   11:*/		return 0x820922D8;
		  /* 820922D8h */ case   12:  		/* cmplw CR6, R29, R30 */
		/* 820922D8h case   12:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R30);
		/* 820922D8h case   12:*/		return 0x820922DC;
		  /* 820922DCh */ case   13:  		/* bc 12, CR6_LT, 40 */
		/* 820922DCh case   13:*/		if ( regs.CR[6].lt ) { return 0x82092304;  }
		/* 820922DCh case   13:*/		return 0x820922E0;
	}
	return 0x820922E0;
} // Block from 820922A8h-820922E0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820922E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820922E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820922E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820922E0);
		  /* 820922E0h */ case    0:  		/* subf R30, R27, R30 */
		/* 820922E0h case    0:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R27,regs.R30);
		/* 820922E0h case    0:*/		return 0x820922E4;
		  /* 820922E4h */ case    1:  		/* cmplw CR6, R30, R26 */
		/* 820922E4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R26);
		/* 820922E4h case    1:*/		return 0x820922E8;
		  /* 820922E8h */ case    2:  		/* bc 4, CR6_GT, 28 */
		/* 820922E8h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82092304;  }
		/* 820922E8h case    2:*/		return 0x820922EC;
		  /* 820922ECh */ case    3:  		/* mr R4, R29 */
		/* 820922ECh case    3:*/		regs.R4 = regs.R29;
		/* 820922ECh case    3:*/		return 0x820922F0;
		  /* 820922F0h */ case    4:  		/* mtspr CTR, R25 */
		/* 820922F0h case    4:*/		regs.CTR = regs.R25;
		/* 820922F0h case    4:*/		return 0x820922F4;
		  /* 820922F4h */ case    5:  		/* mr R3, R30 */
		/* 820922F4h case    5:*/		regs.R3 = regs.R30;
		/* 820922F4h case    5:*/		return 0x820922F8;
		  /* 820922F8h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 820922F8h case    6:*/		if ( 1 ) { regs.LR = 0x820922FC; return (uint32)regs.CTR; }
		/* 820922F8h case    6:*/		return 0x820922FC;
		  /* 820922FCh */ case    7:  		/* cmpwi CR6, R3, 0 */
		/* 820922FCh case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820922FCh case    7:*/		return 0x82092300;
	}
	return 0x82092300;
} // Block from 820922E0h-82092300h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82092300h
// Function 'strncmp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092300);
		  /* 82092300h */ case    0:  		/* bc 12, CR6_EQ, -32 */
		/* 82092300h case    0:*/		if ( regs.CR[6].eq ) { return 0x820922E0;  }
		/* 82092300h case    0:*/		return 0x82092304;
	}
	return 0x82092304;
} // Block from 82092300h-82092304h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82092304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092304);
		  /* 82092304h */ case    0:  		/* subf R11, R31, R28 */
		/* 82092304h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R31,regs.R28);
		/* 82092304h case    0:*/		return 0x82092308;
		  /* 82092308h */ case    1:  		/* subf R10, R26, R30 */
		/* 82092308h case    1:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R26,regs.R30);
		/* 82092308h case    1:*/		return 0x8209230C;
		  /* 8209230Ch */ case    2:  		/* cmpw CR6, R10, R11 */
		/* 8209230Ch case    2:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 8209230Ch case    2:*/		return 0x82092310;
		  /* 82092310h */ case    3:  		/* bc 12, CR6_LT, 48 */
		/* 82092310h case    3:*/		if ( regs.CR[6].lt ) { return 0x82092340;  }
		/* 82092310h case    3:*/		return 0x82092314;
		  /* 82092314h */ case    4:  		/* cmplw CR6, R26, R30 */
		/* 82092314h case    4:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R30);
		/* 82092314h case    4:*/		return 0x82092318;
		  /* 82092318h */ case    5:  		/* bc 4, CR6_LT, 24 */
		/* 82092318h case    5:*/		if ( !regs.CR[6].lt ) { return 0x82092330;  }
		/* 82092318h case    5:*/		return 0x8209231C;
		  /* 8209231Ch */ case    6:  		/* stw R26, <#[R24 + 4]> */
		/* 8209231Ch case    6:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R24 + 0x00000004) );
		/* 8209231Ch case    6:*/		return 0x82092320;
		  /* 82092320h */ case    7:  		/* addi R22, R22, 1 */
		/* 82092320h case    7:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 82092320h case    7:*/		return 0x82092324;
		  /* 82092324h */ case    8:  		/* stw R30, <#[R23 + 4]> */
		/* 82092324h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R23 + 0x00000004) );
		/* 82092324h case    8:*/		return 0x82092328;
		  /* 82092328h */ case    9:  		/* addi R24, R24, 4 */
		/* 82092328h case    9:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x4);
		/* 82092328h case    9:*/		return 0x8209232C;
		  /* 8209232Ch */ case   10:  		/* addi R23, R23, 4 */
		/* 8209232Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x4);
		/* 8209232Ch case   10:*/		return 0x82092330;
	}
	return 0x82092330;
} // Block from 82092304h-82092330h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82092330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092330);
		  /* 82092330h */ case    0:  		/* cmplw CR6, R31, R28 */
		/* 82092330h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R28);
		/* 82092330h case    0:*/		return 0x82092334;
		  /* 82092334h */ case    1:  		/* bc 4, CR6_LT, -580 */
		/* 82092334h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820920F0;  }
		/* 82092334h case    1:*/		return 0x82092338;
		  /* 82092338h */ case    2:  		/* mr R26, R31 */
		/* 82092338h case    2:*/		regs.R26 = regs.R31;
		/* 82092338h case    2:*/		return 0x8209233C;
		  /* 8209233Ch */ case    3:  		/* b -740 */
		/* 8209233Ch case    3:*/		return 0x82092058;
		/* 8209233Ch case    3:*/		return 0x82092340;
	}
	return 0x82092340;
} // Block from 82092330h-82092340h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82092340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092340);
		  /* 82092340h */ case    0:  		/* cmplw CR6, R31, R28 */
		/* 82092340h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R28);
		/* 82092340h case    0:*/		return 0x82092344;
		  /* 82092344h */ case    1:  		/* bc 4, CR6_LT, 16 */
		/* 82092344h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82092354;  }
		/* 82092344h case    1:*/		return 0x82092348;
		  /* 82092348h */ case    2:  		/* stwu R31, <#[R24 + 4]> */
		/* 82092348h case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R24 + 0x00000004) );
		regs.R24 = (uint32)(regs.R24 + 0x00000004);
		/* 82092348h case    2:*/		return 0x8209234C;
		  /* 8209234Ch */ case    3:  		/* addi R22, R22, 1 */
		/* 8209234Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 8209234Ch case    3:*/		return 0x82092350;
	}
	return 0x82092350;
} // Block from 82092340h-82092350h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82092350h
// Function 'qsort'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092350);
		  /* 82092350h */ case    0:  		/* stwu R28, <#[R23 + 4]> */
		/* 82092350h case    0:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R23 + 0x00000004) );
		regs.R23 = (uint32)(regs.R23 + 0x00000004);
		/* 82092350h case    0:*/		return 0x82092354;
	}
	return 0x82092354;
} // Block from 82092350h-82092354h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82092354h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092354( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092354) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092354);
		  /* 82092354h */ case    0:  		/* cmplw CR6, R26, R30 */
		/* 82092354h case    0:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R30);
		/* 82092354h case    0:*/		return 0x82092358;
		  /* 82092358h */ case    1:  		/* bc 4, CR6_LT, -616 */
		/* 82092358h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820920F0;  }
		/* 82092358h case    1:*/		return 0x8209235C;
		  /* 8209235Ch */ case    2:  		/* mr R28, R30 */
		/* 8209235Ch case    2:*/		regs.R28 = regs.R30;
		/* 8209235Ch case    2:*/		return 0x82092360;
		  /* 82092360h */ case    3:  		/* b -776 */
		/* 82092360h case    3:*/		return 0x82092058;
		/* 82092360h case    3:*/		return 0x82092364;
		  /* 82092364h */ case    4:  		/* nop */
		/* 82092364h case    4:*/		cpu::op::nop();
		/* 82092364h case    4:*/		return 0x82092368;
	}
	return 0x82092368;
} // Block from 82092354h-82092368h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82092368h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092368);
		  /* 82092368h */ case    0:  		/* b 5312 */
		/* 82092368h case    0:*/		return 0x82093828;
		/* 82092368h case    0:*/		return 0x8209236C;
		  /* 8209236Ch */ case    1:  		/* nop */
		/* 8209236Ch case    1:*/		cpu::op::nop();
		/* 8209236Ch case    1:*/		return 0x82092370;
	}
	return 0x82092370;
} // Block from 82092368h-82092370h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82092370h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092370);
		  /* 82092370h */ case    0:  		/* or. R0, R5, R5 */
		/* 82092370h case    0:*/		cpu::op::or<1>(regs,&regs.R0,regs.R5,regs.R5);
		/* 82092370h case    0:*/		return 0x82092374;
		  /* 82092374h */ case    1:  		/* mtspr CTR, R5 */
		/* 82092374h case    1:*/		regs.CTR = regs.R5;
		/* 82092374h case    1:*/		return 0x82092378;
		  /* 82092378h */ case    2:  		/* bc 4, CR0_GT, 60 */
		/* 82092378h case    2:*/		if ( !regs.CR[0].gt ) { return 0x820923B4;  }
		/* 82092378h case    2:*/		return 0x8209237C;
		  /* 8209237Ch */ case    3:  		/* lbz R8, <#[R3]> */
		/* 8209237Ch case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 8209237Ch case    3:*/		return 0x82092380;
		  /* 82092380h */ case    4:  		/* lbz R7, <#[R4]> */
		/* 82092380h case    4:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000000) );
		/* 82092380h case    4:*/		return 0x82092384;
		  /* 82092384h */ case    5:  		/* mr R10, R3 */
		/* 82092384h case    5:*/		regs.R10 = regs.R3;
		/* 82092384h case    5:*/		return 0x82092388;
		  /* 82092388h */ case    6:  		/* cmpwi CR1, R8, 0 */
		/* 82092388h case    6:*/		cpu::op::cmpwi<1>(regs,regs.R8,0x00000000);
		/* 82092388h case    6:*/		return 0x8209238C;
		  /* 8209238Ch */ case    7:  		/* subfc. R3, R7, R8 */
		/* 8209238Ch case    7:*/		cpu::op::subfc<1>(regs,&regs.R3,regs.R7,regs.R8);
		/* 8209238Ch case    7:*/		return 0x82092390;
		  /* 82092390h */ case    8:  		/* bc 0, CR1_EQ, 8 */
		/* 82092390h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 && !regs.CR[1].eq ) { return 0x82092398;  }
		/* 82092390h case    8:*/		return 0x82092394;
		  /* 82092394h */ case    9:  		/* bclr 20, CR0_LT */
		/* 82092394h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82092394h case    9:*/		return 0x82092398;
	}
	return 0x82092398;
} // Block from 82092370h-82092398h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82092398h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092398);
		  /* 82092398h */ case    0:  		/* bclr 4, CR0_EQ */
		/* 82092398h case    0:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82092398h case    0:*/		return 0x8209239C;
	}
	return 0x8209239C;
} // Block from 82092398h-8209239Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209239Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209239C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209239C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209239C);
		  /* 8209239Ch */ case    0:  		/* lbzu R8, <#[R10 + 1]> */
		/* 8209239Ch case    0:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000001) );
		regs.R10 = (uint32)(regs.R10 + 0x00000001);
		/* 8209239Ch case    0:*/		return 0x820923A0;
		  /* 820923A0h */ case    1:  		/* lbzu R7, <#[R4 + 1]> */
		/* 820923A0h case    1:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000001) );
		regs.R4 = (uint32)(regs.R4 + 0x00000001);
		/* 820923A0h case    1:*/		return 0x820923A4;
		  /* 820923A4h */ case    2:  		/* cmpwi CR1, R8, 0 */
		/* 820923A4h case    2:*/		cpu::op::cmpwi<1>(regs,regs.R8,0x00000000);
		/* 820923A4h case    2:*/		return 0x820923A8;
		  /* 820923A8h */ case    3:  		/* subfc. R3, R7, R8 */
		/* 820923A8h case    3:*/		cpu::op::subfc<1>(regs,&regs.R3,regs.R7,regs.R8);
		/* 820923A8h case    3:*/		return 0x820923AC;
		  /* 820923ACh */ case    4:  		/* bc 0, CR1_EQ, -20 */
		/* 820923ACh case    4:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 && !regs.CR[1].eq ) { return 0x82092398;  }
		/* 820923ACh case    4:*/		return 0x820923B0;
		  /* 820923B0h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820923B0h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820923B0h case    5:*/		return 0x820923B4;
	}
	return 0x820923B4;
} // Block from 8209239Ch-820923B4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820923B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820923B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820923B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820923B4);
		  /* 820923B4h */ case    0:  		/* li R3, 0 */
		/* 820923B4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820923B4h case    0:*/		return 0x820923B8;
		  /* 820923B8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820923B8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820923B8h case    1:*/		return 0x820923BC;
	}
	return 0x820923BC;
} // Block from 820923B4h-820923BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820923BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820923BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820923BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820923BC);
		  /* 820923BCh */ case    0:  		/* nop */
		/* 820923BCh case    0:*/		cpu::op::nop();
		/* 820923BCh case    0:*/		return 0x820923C0;
		  /* 820923C0h */ case    1:  		/* stfd FR1, <#[R1 + 16]> */
		/* 820923C0h case    1:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000010) );
		/* 820923C0h case    1:*/		return 0x820923C4;
		  /* 820923C4h */ case    2:  		/* lhz R11, <#[R1 + 16]> */
		/* 820923C4h case    2:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000010) );
		/* 820923C4h case    2:*/		return 0x820923C8;
		  /* 820923C8h */ case    3:  		/* rlwinm. R11, R11, 0, 17, 27 */
		/* 820923C8h case    3:*/		cpu::op::rlwinm<1,0,17,27>(regs,&regs.R11,regs.R11);
		/* 820923C8h case    3:*/		return 0x820923CC;
		  /* 820923CCh */ case    4:  		/* bc 4, CR0_EQ, 28 */
		/* 820923CCh case    4:*/		if ( !regs.CR[0].eq ) { return 0x820923E8;  }
		/* 820923CCh case    4:*/		return 0x820923D0;
		  /* 820923D0h */ case    5:  		/* lwz R11, <#[R1 + 16]> */
		/* 820923D0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000010) );
		/* 820923D0h case    5:*/		return 0x820923D4;
		  /* 820923D4h */ case    6:  		/* rlwinm. R11, R11, 0, 12, 31 */
		/* 820923D4h case    6:*/		cpu::op::rlwinm<1,0,12,31>(regs,&regs.R11,regs.R11);
		/* 820923D4h case    6:*/		return 0x820923D8;
		  /* 820923D8h */ case    7:  		/* bc 4, CR0_EQ, 76 */
		/* 820923D8h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82092424;  }
		/* 820923D8h case    7:*/		return 0x820923DC;
		  /* 820923DCh */ case    8:  		/* lwz R11, <#[R1 + 20]> */
		/* 820923DCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000014) );
		/* 820923DCh case    8:*/		return 0x820923E0;
		  /* 820923E0h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820923E0h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820923E0h case    9:*/		return 0x820923E4;
		  /* 820923E4h */ case   10:  		/* bc 4, CR6_EQ, 64 */
		/* 820923E4h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82092424;  }
		/* 820923E4h case   10:*/		return 0x820923E8;
	}
	return 0x820923E8;
} // Block from 820923BCh-820923E8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820923E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820923E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820923E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820923E8);
		  /* 820923E8h */ case    0:  		/* fctid FR0, FR1 */
		/* 820923E8h case    0:*/		cpu::op::fctid<0>(regs,&regs.FR0,regs.FR1);
		/* 820923E8h case    0:*/		return 0x820923EC;
		  /* 820923ECh */ case    1:  		/* fcfid FR0, FR0 */
		/* 820923ECh case    1:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 820923ECh case    1:*/		return 0x820923F0;
		  /* 820923F0h */ case    2:  		/* fcmpu CR6, FR0, FR1 */
		/* 820923F0h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR1);
		/* 820923F0h case    2:*/		return 0x820923F4;
		  /* 820923F4h */ case    3:  		/* bc 4, CR6_EQ, 48 */
		/* 820923F4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82092424;  }
		/* 820923F4h case    3:*/		return 0x820923F8;
		  /* 820923F8h */ case    4:  		/* lis R11, -32256 */
		/* 820923F8h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820923F8h case    4:*/		return 0x820923FC;
		  /* 820923FCh */ case    5:  		/* lfd FR0, <#[R11 + 4736]> */
		/* 820923FCh case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001280) );
		/* 820923FCh case    5:*/		return 0x82092400;
		  /* 82092400h */ case    6:  		/* fmul FR0, FR1, FR0 */
		/* 82092400h case    6:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR1,regs.FR0);
		/* 82092400h case    6:*/		return 0x82092404;
		  /* 82092404h */ case    7:  		/* fctid FR13, FR0 */
		/* 82092404h case    7:*/		cpu::op::fctid<0>(regs,&regs.FR13,regs.FR0);
		/* 82092404h case    7:*/		return 0x82092408;
		  /* 82092408h */ case    8:  		/* fcfid FR13, FR13 */
		/* 82092408h case    8:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 82092408h case    8:*/		return 0x8209240C;
		  /* 8209240Ch */ case    9:  		/* fcmpu CR6, FR13, FR0 */
		/* 8209240Ch case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 8209240Ch case    9:*/		return 0x82092410;
		  /* 82092410h */ case   10:  		/* bc 4, CR6_EQ, 12 */
		/* 82092410h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8209241C;  }
		/* 82092410h case   10:*/		return 0x82092414;
		  /* 82092414h */ case   11:  		/* li R3, 2 */
		/* 82092414h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 82092414h case   11:*/		return 0x82092418;
		  /* 82092418h */ case   12:  		/* bclr 20, CR0_LT */
		/* 82092418h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82092418h case   12:*/		return 0x8209241C;
	}
	return 0x8209241C;
} // Block from 820923E8h-8209241Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209241Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209241C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209241C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209241C);
		  /* 8209241Ch */ case    0:  		/* li R3, 1 */
		/* 8209241Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8209241Ch case    0:*/		return 0x82092420;
		  /* 82092420h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82092420h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82092420h case    1:*/		return 0x82092424;
	}
	return 0x82092424;
} // Block from 8209241Ch-82092424h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82092424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092424);
		  /* 82092424h */ case    0:  		/* li R3, 0 */
		/* 82092424h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82092424h case    0:*/		return 0x82092428;
		  /* 82092428h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82092428h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82092428h case    1:*/		return 0x8209242C;
	}
	return 0x8209242C;
} // Block from 82092424h-8209242Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209242Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209242C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209242C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209242C);
		  /* 8209242Ch */ case    0:  		/* nop */
		/* 8209242Ch case    0:*/		cpu::op::nop();
		/* 8209242Ch case    0:*/		return 0x82092430;
	}
	return 0x82092430;
} // Block from 8209242Ch-82092430h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82092430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092430);
		  /* 82092430h */ case    0:  		/* mfspr R12, LR */
		/* 82092430h case    0:*/		regs.R12 = regs.LR;
		/* 82092430h case    0:*/		return 0x82092434;
		  /* 82092434h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82092434h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82092434h case    1:*/		return 0x82092438;
		  /* 82092438h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82092438h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82092438h case    2:*/		return 0x8209243C;
		  /* 8209243Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8209243Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209243Ch case    3:*/		return 0x82092440;
		  /* 82092440h */ case    4:  		/* stfd FR31, <#[R1 - 32]> */
		/* 82092440h case    4:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 82092440h case    4:*/		return 0x82092444;
		  /* 82092444h */ case    5:  		/* stwu R1, <#[R1 - 112]> */
		/* 82092444h case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82092444h case    5:*/		return 0x82092448;
		  /* 82092448h */ case    6:  		/* lis R10, 32752 */
		/* 82092448h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x7FF0);
		/* 82092448h case    6:*/		return 0x8209244C;
		  /* 8209244Ch */ case    7:  		/* stfd FR2, <#[R1 + 136]> */
		/* 8209244Ch case    7:*/		cpu::mem::store64f( regs, regs.FR2, (uint32)(regs.R1 + 0x00000088) );
		/* 8209244Ch case    7:*/		return 0x82092450;
		  /* 82092450h */ case    8:  		/* lwz R11, <#[R1 + 136]> */
		/* 82092450h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 82092450h case    8:*/		return 0x82092454;
		  /* 82092454h */ case    9:  		/* stfd FR1, <#[R1 + 128]> */
		/* 82092454h case    9:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000080) );
		/* 82092454h case    9:*/		return 0x82092458;
		  /* 82092458h */ case   10:  		/* fmr FR31, FR2 */
		/* 82092458h case   10:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR2);
		/* 82092458h case   10:*/		return 0x8209245C;
		  /* 8209245Ch */ case   11:  		/* lis R9, -16 */
		/* 8209245Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFFFF0);
		/* 8209245Ch case   11:*/		return 0x82092460;
		  /* 82092460h */ case   12:  		/* fabs FR0, FR1 */
		/* 82092460h case   12:*/		cpu::op::fabs<0>(regs,&regs.FR0,regs.FR1);
		/* 82092460h case   12:*/		return 0x82092464;
		  /* 82092464h */ case   13:  		/* mr R31, R5 */
		/* 82092464h case   13:*/		regs.R31 = regs.R5;
		/* 82092464h case   13:*/		return 0x82092468;
		  /* 82092468h */ case   14:  		/* li R30, 0 */
		/* 82092468h case   14:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82092468h case   14:*/		return 0x8209246C;
		  /* 8209246Ch */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 8209246Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8209246Ch case   15:*/		return 0x82092470;
		  /* 82092470h */ case   16:  		/* bc 4, CR6_EQ, 72 */
		/* 82092470h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820924B8;  }
		/* 82092470h case   16:*/		return 0x82092474;
		  /* 82092474h */ case   17:  		/* lwz R11, <#[R1 + 140]> */
		/* 82092474h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 82092474h case   17:*/		return 0x82092478;
		  /* 82092478h */ case   18:  		/* cmplwi CR6, R11, 0 */
		/* 82092478h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82092478h case   18:*/		return 0x8209247C;
		  /* 8209247Ch */ case   19:  		/* bc 4, CR6_EQ, 120 */
		/* 8209247Ch case   19:*/		if ( !regs.CR[6].eq ) { return 0x820924F4;  }
		/* 8209247Ch case   19:*/		return 0x82092480;
		  /* 82092480h */ case   20:  		/* lis R11, -32256 */
		/* 82092480h case   20:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82092480h case   20:*/		return 0x82092484;
		  /* 82092484h */ case   21:  		/* lfd FR13, <#[R11 + 1848]> */
		/* 82092484h case   21:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000738) );
		/* 82092484h case   21:*/		return 0x82092488;
		  /* 82092488h */ case   22:  		/* fcmpu CR6, FR0, FR13 */
		/* 82092488h case   22:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82092488h case   22:*/		return 0x8209248C;
		  /* 8209248Ch */ case   23:  		/* bc 4, CR6_GT, 16 */
		/* 8209248Ch case   23:*/		if ( !regs.CR[6].gt ) { return 0x8209249C;  }
		/* 8209248Ch case   23:*/		return 0x82092490;
		  /* 82092490h */ case   24:  		/* lis R11, -32217 */
		/* 82092490h case   24:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82092490h case   24:*/		return 0x82092494;
		  /* 82092494h */ case   25:  		/* lfd FR0, <#[R11 + 7328]> */
		/* 82092494h case   25:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001CA0) );
		/* 82092494h case   25:*/		return 0x82092498;
		  /* 82092498h */ case   26:  		/* b 252 */
		/* 82092498h case   26:*/		return 0x82092594;
		/* 82092498h case   26:*/		return 0x8209249C;
	}
	return 0x8209249C;
} // Block from 82092430h-8209249Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 8209249Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209249C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209249C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209249C);
		  /* 8209249Ch */ case    0:  		/* fcmpu CR6, FR0, FR13 */
		/* 8209249Ch case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 8209249Ch case    0:*/		return 0x820924A0;
		  /* 820924A0h */ case    1:  		/* bc 4, CR6_LT, 16 */
		/* 820924A0h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820924B0;  }
		/* 820924A0h case    1:*/		return 0x820924A4;
		  /* 820924A4h */ case    2:  		/* lis R11, -32256 */
		/* 820924A4h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820924A4h case    2:*/		return 0x820924A8;
		  /* 820924A8h */ case    3:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 820924A8h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 820924A8h case    3:*/		return 0x820924AC;
		  /* 820924ACh */ case    4:  		/* b 232 */
		/* 820924ACh case    4:*/		return 0x82092594;
		/* 820924ACh case    4:*/		return 0x820924B0;
	}
	return 0x820924B0;
} // Block from 8209249Ch-820924B0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820924B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820924B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820924B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820924B0);
		  /* 820924B0h */ case    0:  		/* stfd FR13, <#[R31]> */
		/* 820924B0h case    0:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R31 + 0x00000000) );
		/* 820924B0h case    0:*/		return 0x820924B4;
		  /* 820924B4h */ case    1:  		/* b 228 */
		/* 820924B4h case    1:*/		return 0x82092598;
		/* 820924B4h case    1:*/		return 0x820924B8;
	}
	return 0x820924B8;
} // Block from 820924B0h-820924B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820924B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820924B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820924B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820924B8);
		  /* 820924B8h */ case    0:  		/* cmplw CR6, R11, R9 */
		/* 820924B8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820924B8h case    0:*/		return 0x820924BC;
		  /* 820924BCh */ case    1:  		/* bc 4, CR6_EQ, 56 */
		/* 820924BCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820924F4;  }
		/* 820924BCh case    1:*/		return 0x820924C0;
		  /* 820924C0h */ case    2:  		/* lwz R11, <#[R1 + 140]> */
		/* 820924C0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 820924C0h case    2:*/		return 0x820924C4;
		  /* 820924C4h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820924C4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820924C4h case    3:*/		return 0x820924C8;
		  /* 820924C8h */ case    4:  		/* bc 4, CR6_EQ, 44 */
		/* 820924C8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820924F4;  }
		/* 820924C8h case    4:*/		return 0x820924CC;
		  /* 820924CCh */ case    5:  		/* lis R11, -32256 */
		/* 820924CCh case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820924CCh case    5:*/		return 0x820924D0;
		  /* 820924D0h */ case    6:  		/* lfd FR13, <#[R11 + 1848]> */
		/* 820924D0h case    6:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000738) );
		/* 820924D0h case    6:*/		return 0x820924D4;
		  /* 820924D4h */ case    7:  		/* fcmpu CR6, FR0, FR13 */
		/* 820924D4h case    7:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 820924D4h case    7:*/		return 0x820924D8;
		  /* 820924D8h */ case    8:  		/* bc 12, CR6_GT, -52 */
		/* 820924D8h case    8:*/		if ( regs.CR[6].gt ) { return 0x820924A4;  }
		/* 820924D8h case    8:*/		return 0x820924DC;
		  /* 820924DCh */ case    9:  		/* fcmpu CR6, FR0, FR13 */
		/* 820924DCh case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 820924DCh case    9:*/		return 0x820924E0;
		  /* 820924E0h */ case   10:  		/* bc 12, CR6_LT, -80 */
		/* 820924E0h case   10:*/		if ( regs.CR[6].lt ) { return 0x82092490;  }
		/* 820924E0h case   10:*/		return 0x820924E4;
		  /* 820924E4h */ case   11:  		/* lis R11, -32217 */
		/* 820924E4h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 820924E4h case   11:*/		return 0x820924E8;
		  /* 820924E8h */ case   12:  		/* li R30, 1 */
		/* 820924E8h case   12:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820924E8h case   12:*/		return 0x820924EC;
		  /* 820924ECh */ case   13:  		/* lfd FR0, <#[R11 + 7336]> */
		/* 820924ECh case   13:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001CA8) );
		/* 820924ECh case   13:*/		return 0x820924F0;
		  /* 820924F0h */ case   14:  		/* b 164 */
		/* 820924F0h case   14:*/		return 0x82092594;
		/* 820924F0h case   14:*/		return 0x820924F4;
	}
	return 0x820924F4;
} // Block from 820924B8h-820924F4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820924F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820924F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820924F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820924F4);
		  /* 820924F4h */ case    0:  		/* lwz R11, <#[R1 + 128]> */
		/* 820924F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 820924F4h case    0:*/		return 0x820924F8;
		  /* 820924F8h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820924F8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820924F8h case    1:*/		return 0x820924FC;
		  /* 820924FCh */ case    2:  		/* bc 4, CR6_EQ, 48 */
		/* 820924FCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x8209252C;  }
		/* 820924FCh case    2:*/		return 0x82092500;
		  /* 82092500h */ case    3:  		/* lwz R11, <#[R1 + 132]> */
		/* 82092500h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 82092500h case    3:*/		return 0x82092504;
		  /* 82092504h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82092504h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82092504h case    4:*/		return 0x82092508;
		  /* 82092508h */ case    5:  		/* bc 4, CR6_EQ, 144 */
		/* 82092508h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82092598;  }
		/* 82092508h case    5:*/		return 0x8209250C;
		  /* 8209250Ch */ case    6:  		/* lis R11, -32256 */
		/* 8209250Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8209250Ch case    6:*/		return 0x82092510;
		  /* 82092510h */ case    7:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 82092510h case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 82092510h case    7:*/		return 0x82092514;
		  /* 82092514h */ case    8:  		/* fcmpu CR6, FR31, FR0 */
		/* 82092514h case    8:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 82092514h case    8:*/		return 0x82092518;
		  /* 82092518h */ case    9:  		/* bc 12, CR6_GT, -136 */
		/* 82092518h case    9:*/		if ( regs.CR[6].gt ) { return 0x82092490;  }
		/* 82092518h case    9:*/		return 0x8209251C;
		  /* 8209251Ch */ case   10:  		/* lis R11, -32256 */
		/* 8209251Ch case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8209251Ch case   10:*/		return 0x82092520;
		  /* 82092520h */ case   11:  		/* lfd FR13, <#[R11 + 1848]> */
		/* 82092520h case   11:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000738) );
		/* 82092520h case   11:*/		return 0x82092524;
		  /* 82092524h */ case   12:  		/* fsel FR0, FR31, FR13, FR0 */
		/* 82092524h case   12:*/		cpu::op::fsel<0>(regs,&regs.FR0,regs.FR31,regs.FR13,regs.FR0);
		/* 82092524h case   12:*/		return 0x82092528;
		  /* 82092528h */ case   13:  		/* b 108 */
		/* 82092528h case   13:*/		return 0x82092594;
		/* 82092528h case   13:*/		return 0x8209252C;
	}
	return 0x8209252C;
} // Block from 820924F4h-8209252Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209252Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209252C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209252C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209252C);
		  /* 8209252Ch */ case    0:  		/* cmplw CR6, R11, R9 */
		/* 8209252Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8209252Ch case    0:*/		return 0x82092530;
		  /* 82092530h */ case    1:  		/* bc 4, CR6_EQ, 104 */
		/* 82092530h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82092598;  }
		/* 82092530h case    1:*/		return 0x82092534;
		  /* 82092534h */ case    2:  		/* lwz R11, <#[R1 + 132]> */
		/* 82092534h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 82092534h case    2:*/		return 0x82092538;
		  /* 82092538h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82092538h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82092538h case    3:*/		return 0x8209253C;
		  /* 8209253Ch */ case    4:  		/* bc 4, CR6_EQ, 92 */
		/* 8209253Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x82092598;  }
		/* 8209253Ch case    4:*/		return 0x82092540;
		  /* 82092540h */ case    5:  		/* fmr FR1, FR31 */
		/* 82092540h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82092540h case    5:*/		return 0x82092544;
		  /* 82092544h */ case    6:  		/* bl -388 */
		/* 82092544h case    6:*/		regs.LR = 0x82092548; return 0x820923C0;
		/* 82092544h case    6:*/		return 0x82092548;
		  /* 82092548h */ case    7:  		/* lis R11, -32256 */
		/* 82092548h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82092548h case    7:*/		return 0x8209254C;
		  /* 8209254Ch */ case    8:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 8209254Ch case    8:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 8209254Ch case    8:*/		return 0x82092550;
		  /* 82092550h */ case    9:  		/* fcmpu CR6, FR31, FR0 */
		/* 82092550h case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 82092550h case    9:*/		return 0x82092554;
		  /* 82092554h */ case   10:  		/* bc 4, CR6_GT, 28 */
		/* 82092554h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82092570;  }
		/* 82092554h case   10:*/		return 0x82092558;
		  /* 82092558h */ case   11:  		/* lis R11, -32217 */
		/* 82092558h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82092558h case   11:*/		return 0x8209255C;
		  /* 8209255Ch */ case   12:  		/* cmpwi CR6, R3, 1 */
		/* 8209255Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8209255Ch case   12:*/		return 0x82092560;
		  /* 82092560h */ case   13:  		/* lfd FR0, <#[R11 + 7328]> */
		/* 82092560h case   13:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001CA0) );
		/* 82092560h case   13:*/		return 0x82092564;
		  /* 82092564h */ case   14:  		/* bc 4, CR6_EQ, 48 */
		/* 82092564h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82092594;  }
		/* 82092564h case   14:*/		return 0x82092568;
		  /* 82092568h */ case   15:  		/* fneg FR0, FR0 */
		/* 82092568h case   15:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR0);
		/* 82092568h case   15:*/		return 0x8209256C;
		  /* 8209256Ch */ case   16:  		/* b 40 */
		/* 8209256Ch case   16:*/		return 0x82092594;
		/* 8209256Ch case   16:*/		return 0x82092570;
	}
	return 0x82092570;
} // Block from 8209252Ch-82092570h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82092570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092570);
		  /* 82092570h */ case    0:  		/* fcmpu CR6, FR31, FR0 */
		/* 82092570h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 82092570h case    0:*/		return 0x82092574;
		  /* 82092574h */ case    1:  		/* bc 4, CR6_LT, 24 */
		/* 82092574h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8209258C;  }
		/* 82092574h case    1:*/		return 0x82092578;
		  /* 82092578h */ case    2:  		/* cmpwi CR6, R3, 1 */
		/* 82092578h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82092578h case    2:*/		return 0x8209257C;
		  /* 8209257Ch */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 8209257Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82092594;  }
		/* 8209257Ch case    3:*/		return 0x82092580;
		  /* 82092580h */ case    4:  		/* lis R11, -32217 */
		/* 82092580h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82092580h case    4:*/		return 0x82092584;
		  /* 82092584h */ case    5:  		/* lfd FR0, <#[R11 + 7360]> */
		/* 82092584h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001CC0) );
		/* 82092584h case    5:*/		return 0x82092588;
		  /* 82092588h */ case    6:  		/* b 12 */
		/* 82092588h case    6:*/		return 0x82092594;
		/* 82092588h case    6:*/		return 0x8209258C;
	}
	return 0x8209258C;
} // Block from 82092570h-8209258Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209258Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209258C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209258C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209258C);
		  /* 8209258Ch */ case    0:  		/* lis R11, -32256 */
		/* 8209258Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8209258Ch case    0:*/		return 0x82092590;
		  /* 82092590h */ case    1:  		/* lfd FR0, <#[R11 + 1848]> */
		/* 82092590h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000738) );
		/* 82092590h case    1:*/		return 0x82092594;
	}
	return 0x82092594;
} // Block from 8209258Ch-82092594h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82092594h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092594( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092594) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092594);
		  /* 82092594h */ case    0:  		/* stfd FR0, <#[R31]> */
		/* 82092594h case    0:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000000) );
		/* 82092594h case    0:*/		return 0x82092598;
	}
	return 0x82092598;
} // Block from 82092594h-82092598h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82092598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092598);
		  /* 82092598h */ case    0:  		/* mr R3, R30 */
		/* 82092598h case    0:*/		regs.R3 = regs.R30;
		/* 82092598h case    0:*/		return 0x8209259C;
		  /* 8209259Ch */ case    1:  		/* addi R1, R1, 112 */
		/* 8209259Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8209259Ch case    1:*/		return 0x820925A0;
		  /* 820925A0h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820925A0h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820925A0h case    2:*/		return 0x820925A4;
		  /* 820925A4h */ case    3:  		/* mtspr LR, R12 */
		/* 820925A4h case    3:*/		regs.LR = regs.R12;
		/* 820925A4h case    3:*/		return 0x820925A8;
		  /* 820925A8h */ case    4:  		/* lfd FR31, <#[R1 - 32]> */
		/* 820925A8h case    4:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 820925A8h case    4:*/		return 0x820925AC;
		  /* 820925ACh */ case    5:  		/* ld R30, <#[R1 - 24]> */
		/* 820925ACh case    5:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820925ACh case    5:*/		return 0x820925B0;
		  /* 820925B0h */ case    6:  		/* ld R31, <#[R1 - 16]> */
		/* 820925B0h case    6:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820925B0h case    6:*/		return 0x820925B4;
		  /* 820925B4h */ case    7:  		/* bclr 20, CR0_LT */
		/* 820925B4h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820925B4h case    7:*/		return 0x820925B8;
	}
	return 0x820925B8;
} // Block from 82092598h-820925B8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820925B8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820925B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820925B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820925B8);
		  /* 820925B8h */ case    0:  		/* mfspr R12, LR */
		/* 820925B8h case    0:*/		regs.R12 = regs.LR;
		/* 820925B8h case    0:*/		return 0x820925BC;
		  /* 820925BCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820925BCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820925BCh case    1:*/		return 0x820925C0;
		  /* 820925C0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820925C0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820925C0h case    2:*/		return 0x820925C4;
		  /* 820925C4h */ case    3:  		/* addi R12, R1, -16 */
		/* 820925C4h case    3:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFFF0);
		/* 820925C4h case    3:*/		return 0x820925C8;
		  /* 820925C8h */ case    4:  		/* bl -4540 */
		/* 820925C8h case    4:*/		regs.LR = 0x820925CC; return 0x8209140C;
		/* 820925C8h case    4:*/		return 0x820925CC;
		  /* 820925CCh */ case    5:  		/* stwu R1, <#[R1 - 176]> */
		/* 820925CCh case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820925CCh case    5:*/		return 0x820925D0;
		  /* 820925D0h */ case    6:  		/* lis R11, -32256 */
		/* 820925D0h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820925D0h case    6:*/		return 0x820925D4;
		  /* 820925D4h */ case    7:  		/* stfd FR1, <#[R1 + 192]> */
		/* 820925D4h case    7:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x000000C0) );
		/* 820925D4h case    7:*/		return 0x820925D8;
		  /* 820925D8h */ case    8:  		/* stfd FR2, <#[R1 + 200]> */
		/* 820925D8h case    8:*/		cpu::mem::store64f( regs, regs.FR2, (uint32)(regs.R1 + 0x000000C8) );
		/* 820925D8h case    8:*/		return 0x820925DC;
		  /* 820925DCh */ case    9:  		/* fmr FR28, FR1 */
		/* 820925DCh case    9:*/		cpu::op::fmr<0>(regs,&regs.FR28,regs.FR1);
		/* 820925DCh case    9:*/		return 0x820925E0;
		  /* 820925E0h */ case   10:  		/* fmr FR29, FR2 */
		/* 820925E0h case   10:*/		cpu::op::fmr<0>(regs,&regs.FR29,regs.FR2);
		/* 820925E0h case   10:*/		return 0x820925E4;
		  /* 820925E4h */ case   11:  		/* lfd FR27, <#[R11 + 1808]> */
		/* 820925E4h case   11:*/		cpu::mem::load64f( regs, &regs.FR27, (uint32)(regs.R11 + 0x00000710) );
		/* 820925E4h case   11:*/		return 0x820925E8;
		  /* 820925E8h */ case   12:  		/* fcmpu CR6, FR2, FR27 */
		/* 820925E8h case   12:*/		cpu::op::fcmpu<6>(regs,regs.FR2,regs.FR27);
		/* 820925E8h case   12:*/		return 0x820925EC;
		  /* 820925ECh */ case   13:  		/* bc 4, CR6_EQ, 16 */
		/* 820925ECh case   13:*/		if ( !regs.CR[6].eq ) { return 0x820925FC;  }
		/* 820925ECh case   13:*/		return 0x820925F0;
		  /* 820925F0h */ case   14:  		/* lis R11, -32256 */
		/* 820925F0h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820925F0h case   14:*/		return 0x820925F4;
		  /* 820925F4h */ case   15:  		/* lfd FR1, <#[R11 + 1848]> */
		/* 820925F4h case   15:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000738) );
		/* 820925F4h case   15:*/		return 0x820925F8;
		  /* 820925F8h */ case   16:  		/* b 1160 */
		/* 820925F8h case   16:*/		return 0x82092A80;
		/* 820925F8h case   16:*/		return 0x820925FC;
	}
	return 0x820925FC;
} // Block from 820925B8h-820925FCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 820925FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820925FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820925FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820925FC);
		  /* 820925FCh */ case    0:  		/* fcmpu CR6, FR28, FR27 */
		/* 820925FCh case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR28,regs.FR27);
		/* 820925FCh case    0:*/		return 0x82092600;
		  /* 82092600h */ case    1:  		/* bc 4, CR6_EQ, 80 */
		/* 82092600h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82092650;  }
		/* 82092600h case    1:*/		return 0x82092604;
		  /* 82092604h */ case    2:  		/* fmr FR1, FR29 */
		/* 82092604h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR29);
		/* 82092604h case    2:*/		return 0x82092608;
		  /* 82092608h */ case    3:  		/* bl -584 */
		/* 82092608h case    3:*/		regs.LR = 0x8209260C; return 0x820923C0;
		/* 82092608h case    3:*/		return 0x8209260C;
		  /* 8209260Ch */ case    4:  		/* fcmpu CR6, FR29, FR27 */
		/* 8209260Ch case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR29,regs.FR27);
		/* 8209260Ch case    4:*/		return 0x82092610;
		  /* 82092610h */ case    5:  		/* bc 4, CR6_LT, 32 */
		/* 82092610h case    5:*/		if ( !regs.CR[6].lt ) { return 0x82092630;  }
		/* 82092610h case    5:*/		return 0x82092614;
		  /* 82092614h */ case    6:  		/* lis R11, -32217 */
		/* 82092614h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82092614h case    6:*/		return 0x82092618;
		  /* 82092618h */ case    7:  		/* cmpwi CR6, R3, 1 */
		/* 82092618h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82092618h case    7:*/		return 0x8209261C;
		  /* 8209261Ch */ case    8:  		/* lfd FR1, <#[R11 + 7328]> */
		/* 8209261Ch case    8:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00001CA0) );
		/* 8209261Ch case    8:*/		return 0x82092620;
		  /* 82092620h */ case    9:  		/* bc 4, CR6_EQ, 1120 */
		/* 82092620h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82092A80;  }
		/* 82092620h case    9:*/		return 0x82092624;
		  /* 82092624h */ case   10:  		/* fmr FR2, FR28 */
		/* 82092624h case   10:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR28);
		/* 82092624h case   10:*/		return 0x82092628;
		  /* 82092628h */ case   11:  		/* bl 22848 */
		/* 82092628h case   11:*/		regs.LR = 0x8209262C; return 0x82097F68;
		/* 82092628h case   11:*/		return 0x8209262C;
		  /* 8209262Ch */ case   12:  		/* b 1108 */
		/* 8209262Ch case   12:*/		return 0x82092A80;
		/* 8209262Ch case   12:*/		return 0x82092630;
	}
	return 0x82092630;
} // Block from 820925FCh-82092630h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82092630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092630);
		  /* 82092630h */ case    0:  		/* fcmpu CR6, FR29, FR27 */
		/* 82092630h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR29,regs.FR27);
		/* 82092630h case    0:*/		return 0x82092634;
		  /* 82092634h */ case    1:  		/* bc 4, CR6_GT, 28 */
		/* 82092634h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82092650;  }
		/* 82092634h case    1:*/		return 0x82092638;
		  /* 82092638h */ case    2:  		/* cmpwi CR6, R3, 1 */
		/* 82092638h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82092638h case    2:*/		return 0x8209263C;
		  /* 8209263Ch */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 8209263Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82092648;  }
		/* 8209263Ch case    3:*/		return 0x82092640;
		  /* 82092640h */ case    4:  		/* fmr FR1, FR28 */
		/* 82092640h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR28);
		/* 82092640h case    4:*/		return 0x82092644;
		  /* 82092644h */ case    5:  		/* b 1084 */
		/* 82092644h case    5:*/		return 0x82092A80;
		/* 82092644h case    5:*/		return 0x82092648;
	}
	return 0x82092648;
} // Block from 82092630h-82092648h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82092648h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092648);
		  /* 82092648h */ case    0:  		/* fmr FR1, FR27 */
		/* 82092648h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR27);
		/* 82092648h case    0:*/		return 0x8209264C;
		  /* 8209264Ch */ case    1:  		/* b 1076 */
		/* 8209264Ch case    1:*/		return 0x82092A80;
		/* 8209264Ch case    1:*/		return 0x82092650;
	}
	return 0x82092650;
} // Block from 82092648h-82092650h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82092650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092650);
		  /* 82092650h */ case    0:  		/* lhz R11, <#[R1 + 192]> */
		/* 82092650h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000C0) );
		/* 82092650h case    0:*/		return 0x82092654;
		  /* 82092654h */ case    1:  		/* lhz R9, <#[R1 + 200]> */
		/* 82092654h case    1:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000C8) );
		/* 82092654h case    1:*/		return 0x82092658;
		  /* 82092658h */ case    2:  		/* rlwinm R10, R11, 0, 17, 27 */
		/* 82092658h case    2:*/		cpu::op::rlwinm<0,0,17,27>(regs,&regs.R10,regs.R11);
		/* 82092658h case    2:*/		return 0x8209265C;
		  /* 8209265Ch */ case    3:  		/* cmplwi CR6, R10, 32752 */
		/* 8209265Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00007FF0);
		/* 8209265Ch case    3:*/		return 0x82092660;
		  /* 82092660h */ case    4:  		/* bc 12, CR6_EQ, 940 */
		/* 82092660h case    4:*/		if ( regs.CR[6].eq ) { return 0x82092A0C;  }
		/* 82092660h case    4:*/		return 0x82092664;
		  /* 82092664h */ case    5:  		/* rlwinm R10, R9, 0, 17, 27 */
		/* 82092664h case    5:*/		cpu::op::rlwinm<0,0,17,27>(regs,&regs.R10,regs.R9);
		/* 82092664h case    5:*/		return 0x82092668;
		  /* 82092668h */ case    6:  		/* cmplwi CR6, R10, 32752 */
		/* 82092668h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00007FF0);
		/* 82092668h case    6:*/		return 0x8209266C;
		  /* 8209266Ch */ case    7:  		/* bc 12, CR6_EQ, 928 */
		/* 8209266Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x82092A0C;  }
		/* 8209266Ch case    7:*/		return 0x82092670;
		  /* 82092670h */ case    8:  		/* lis R11, -32256 */
		/* 82092670h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82092670h case    8:*/		return 0x82092674;
		  /* 82092674h */ case    9:  		/* fcmpu CR6, FR28, FR27 */
		/* 82092674h case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR28,regs.FR27);
		/* 82092674h case    9:*/		return 0x82092678;
		  /* 82092678h */ case   10:  		/* lfd FR26, <#[R11 + 1848]> */
		/* 82092678h case   10:*/		cpu::mem::load64f( regs, &regs.FR26, (uint32)(regs.R11 + 0x00000738) );
		/* 82092678h case   10:*/		return 0x8209267C;
		  /* 8209267Ch */ case   11:  		/* fmr FR25, FR26 */
		/* 8209267Ch case   11:*/		cpu::op::fmr<0>(regs,&regs.FR25,regs.FR26);
		/* 8209267Ch case   11:*/		return 0x82092680;
		  /* 82092680h */ case   12:  		/* bc 4, CR6_LT, 52 */
		/* 82092680h case   12:*/		if ( !regs.CR[6].lt ) { return 0x820926B4;  }
		/* 82092680h case   12:*/		return 0x82092684;
		  /* 82092684h */ case   13:  		/* fmr FR1, FR29 */
		/* 82092684h case   13:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR29);
		/* 82092684h case   13:*/		return 0x82092688;
		  /* 82092688h */ case   14:  		/* bl -712 */
		/* 82092688h case   14:*/		regs.LR = 0x8209268C; return 0x820923C0;
		/* 82092688h case   14:*/		return 0x8209268C;
		  /* 8209268Ch */ case   15:  		/* cmpwi CR6, R3, 1 */
		/* 8209268Ch case   15:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8209268Ch case   15:*/		return 0x82092690;
		  /* 82092690h */ case   16:  		/* bc 12, CR6_EQ, 24 */
		/* 82092690h case   16:*/		if ( regs.CR[6].eq ) { return 0x820926A8;  }
		/* 82092690h case   16:*/		return 0x82092694;
		  /* 82092694h */ case   17:  		/* cmpwi CR6, R3, 2 */
		/* 82092694h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 82092694h case   17:*/		return 0x82092698;
		  /* 82092698h */ case   18:  		/* bc 12, CR6_EQ, 24 */
		/* 82092698h case   18:*/		if ( regs.CR[6].eq ) { return 0x820926B0;  }
		/* 82092698h case   18:*/		return 0x8209269C;
		  /* 8209269Ch */ case   19:  		/* lis R11, -32217 */
		/* 8209269Ch case   19:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 8209269Ch case   19:*/		return 0x820926A0;
		  /* 820926A0h */ case   20:  		/* lfd FR1, <#[R11 + 7336]> */
		/* 820926A0h case   20:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00001CA8) );
		/* 820926A0h case   20:*/		return 0x820926A4;
		  /* 820926A4h */ case   21:  		/* b 988 */
		/* 820926A4h case   21:*/		return 0x82092A80;
		/* 820926A4h case   21:*/		return 0x820926A8;
	}
	return 0x820926A8;
} // Block from 82092650h-820926A8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820926A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820926A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820926A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820926A8);
		  /* 820926A8h */ case    0:  		/* lis R11, -32255 */
		/* 820926A8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820926A8h case    0:*/		return 0x820926AC;
		  /* 820926ACh */ case    1:  		/* lfd FR25, <#[R11 - 24488]> */
		/* 820926ACh case    1:*/		cpu::mem::load64f( regs, &regs.FR25, (uint32)(regs.R11 + 0xFFFFA058) );
		/* 820926ACh case    1:*/		return 0x820926B0;
	}
	return 0x820926B0;
} // Block from 820926A8h-820926B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820926B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820926B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820926B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820926B0);
		  /* 820926B0h */ case    0:  		/* fneg FR28, FR28 */
		/* 820926B0h case    0:*/		cpu::op::fneg<0>(regs,&regs.FR28,regs.FR28);
		/* 820926B0h case    0:*/		return 0x820926B4;
	}
	return 0x820926B4;
} // Block from 820926B0h-820926B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820926B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820926B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820926B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820926B4);
		  /* 820926B4h */ case    0:  		/* fabs FR13, FR29 */
		/* 820926B4h case    0:*/		cpu::op::fabs<0>(regs,&regs.FR13,regs.FR29);
		/* 820926B4h case    0:*/		return 0x820926B8;
		  /* 820926B8h */ case    1:  		/* lis R11, -32217 */
		/* 820926B8h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 820926B8h case    1:*/		return 0x820926BC;
		  /* 820926BCh */ case    2:  		/* lfd FR0, <#[R11 + 7200]> */
		/* 820926BCh case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001C20) );
		/* 820926BCh case    2:*/		return 0x820926C0;
		  /* 820926C0h */ case    3:  		/* fcmpu CR6, FR13, FR0 */
		/* 820926C0h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820926C0h case    3:*/		return 0x820926C4;
		  /* 820926C4h */ case    4:  		/* bc 4, CR6_GT, 64 */
		/* 820926C4h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82092704;  }
		/* 820926C4h case    4:*/		return 0x820926C8;
		  /* 820926C8h */ case    5:  		/* fcmpu CR6, FR29, FR27 */
		/* 820926C8h case    5:*/		cpu::op::fcmpu<6>(regs,regs.FR29,regs.FR27);
		/* 820926C8h case    5:*/		return 0x820926CC;
		  /* 820926CCh */ case    6:  		/* bc 4, CR6_LT, 8 */
		/* 820926CCh case    6:*/		if ( !regs.CR[6].lt ) { return 0x820926D4;  }
		/* 820926CCh case    6:*/		return 0x820926D0;
		  /* 820926D0h */ case    7:  		/* fdiv FR28, FR26, FR28 */
		/* 820926D0h case    7:*/		cpu::op::fdiv<0>(regs,&regs.FR28,regs.FR26,regs.FR28);
		/* 820926D0h case    7:*/		return 0x820926D4;
	}
	return 0x820926D4;
} // Block from 820926B4h-820926D4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820926D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820926D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820926D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820926D4);
		  /* 820926D4h */ case    0:  		/* fcmpu CR6, FR28, FR26 */
		/* 820926D4h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR28,regs.FR26);
		/* 820926D4h case    0:*/		return 0x820926D8;
	}
	return 0x820926D8;
} // Block from 820926D4h-820926D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820926D8h
// Function '??3@YAXPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820926D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820926D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820926D8);
		  /* 820926D8h */ case    0:  		/* bc 4, CR6_GT, 20 */
		/* 820926D8h case    0:*/		if ( !regs.CR[6].gt ) { return 0x820926EC;  }
		/* 820926D8h case    0:*/		return 0x820926DC;
		  /* 820926DCh */ case    1:  		/* lis R11, -32217 */
		/* 820926DCh case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 820926DCh case    1:*/		return 0x820926E0;
	}
	return 0x820926E0;
} // Block from 820926D8h-820926E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820926E0h
// Function '_d_inttype'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820926E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820926E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820926E0);
		  /* 820926E0h */ case    0:  		/* lfd FR0, <#[R11 + 7328]> */
		/* 820926E0h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001CA0) );
		/* 820926E0h case    0:*/		return 0x820926E4;
		  /* 820926E4h */ case    1:  		/* fmul FR1, FR0, FR25 */
		/* 820926E4h case    1:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR0,regs.FR25);
		/* 820926E4h case    1:*/		return 0x820926E8;
		  /* 820926E8h */ case    2:  		/* b 920 */
		/* 820926E8h case    2:*/		return 0x82092A80;
		/* 820926E8h case    2:*/		return 0x820926EC;
	}
	return 0x820926EC;
} // Block from 820926E0h-820926ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820926ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820926EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820926EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820926EC);
		  /* 820926ECh */ case    0:  		/* fcmpu CR6, FR28, FR26 */
		/* 820926ECh case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR28,regs.FR26);
		/* 820926ECh case    0:*/		return 0x820926F0;
		  /* 820926F0h */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 820926F0h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820926FC;  }
		/* 820926F0h case    1:*/		return 0x820926F4;
		  /* 820926F4h */ case    2:  		/* fmul FR1, FR25, FR27 */
		/* 820926F4h case    2:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR25,regs.FR27);
		/* 820926F4h case    2:*/		return 0x820926F8;
		  /* 820926F8h */ case    3:  		/* b 904 */
		/* 820926F8h case    3:*/		return 0x82092A80;
		/* 820926F8h case    3:*/		return 0x820926FC;
	}
	return 0x820926FC;
} // Block from 820926ECh-820926FCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820926FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820926FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820926FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820926FC);
		  /* 820926FCh */ case    0:  		/* fmr FR1, FR25 */
		/* 820926FCh case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR25);
		/* 820926FCh case    0:*/		return 0x82092700;
		  /* 82092700h */ case    1:  		/* b 896 */
		/* 82092700h case    1:*/		return 0x82092A80;
		/* 82092700h case    1:*/		return 0x82092704;
	}
	return 0x82092704;
} // Block from 820926FCh-82092704h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82092704h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092704( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092704) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092704);
		  /* 82092704h */ case    0:  		/* addi R4, R1, 80 */
		/* 82092704h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82092704h case    0:*/		return 0x82092708;
		  /* 82092708h */ case    1:  		/* fmr FR1, FR28 */
		/* 82092708h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR28);
		/* 82092708h case    1:*/		return 0x8209270C;
		  /* 8209270Ch */ case    2:  		/* bl 9084 */
		/* 8209270Ch case    2:*/		regs.LR = 0x82092710; return 0x82094A88;
		/* 8209270Ch case    2:*/		return 0x82092710;
		  /* 82092710h */ case    3:  		/* lis R11, -32255 */
		/* 82092710h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82092710h case    3:*/		return 0x82092714;
		  /* 82092714h */ case    4:  		/* fmr FR30, FR1 */
		/* 82092714h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR1);
		/* 82092714h case    4:*/		return 0x82092718;
		  /* 82092718h */ case    5:  		/* lfd FR0, <#[R11 - 24496]> */
		/* 82092718h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFA050) );
		/* 82092718h case    5:*/		return 0x8209271C;
		  /* 8209271Ch */ case    6:  		/* fcmpu CR6, FR29, FR0 */
		/* 8209271Ch case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR29,regs.FR0);
		/* 8209271Ch case    6:*/		return 0x82092720;
		  /* 82092720h */ case    7:  		/* bc 12, CR6_GT, 156 */
		/* 82092720h case    7:*/		if ( regs.CR[6].gt ) { return 0x820927BC;  }
		/* 82092720h case    7:*/		return 0x82092724;
		  /* 82092724h */ case    8:  		/* fmr FR1, FR28 */
		/* 82092724h case    8:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR28);
		/* 82092724h case    8:*/		return 0x82092728;
		  /* 82092728h */ case    9:  		/* bl -872 */
		/* 82092728h case    9:*/		regs.LR = 0x8209272C; return 0x820923C0;
		/* 82092728h case    9:*/		return 0x8209272C;
		  /* 8209272Ch */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 8209272Ch case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209272Ch case   10:*/		return 0x82092730;
		  /* 82092730h */ case   11:  		/* bc 12, CR0_EQ, 140 */
		/* 82092730h case   11:*/		if ( regs.CR[0].eq ) { return 0x820927BC;  }
		/* 82092730h case   11:*/		return 0x82092734;
		  /* 82092734h */ case   12:  		/* fmr FR1, FR29 */
		/* 82092734h case   12:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR29);
		/* 82092734h case   12:*/		return 0x82092738;
		  /* 82092738h */ case   13:  		/* bl -888 */
		/* 82092738h case   13:*/		regs.LR = 0x8209273C; return 0x820923C0;
		/* 82092738h case   13:*/		return 0x8209273C;
		  /* 8209273Ch */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 8209273Ch case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209273Ch case   14:*/		return 0x82092740;
		  /* 82092740h */ case   15:  		/* bc 12, CR0_EQ, 124 */
		/* 82092740h case   15:*/		if ( regs.CR[0].eq ) { return 0x820927BC;  }
		/* 82092740h case   15:*/		return 0x82092744;
		  /* 82092744h */ case   16:  		/* fcmpu CR6, FR29, FR27 */
		/* 82092744h case   16:*/		cpu::op::fcmpu<6>(regs,regs.FR29,regs.FR27);
		/* 82092744h case   16:*/		return 0x82092748;
		  /* 82092748h */ case   17:  		/* bc 4, CR6_GT, 116 */
		/* 82092748h case   17:*/		if ( !regs.CR[6].gt ) { return 0x820927BC;  }
		/* 82092748h case   17:*/		return 0x8209274C;
		  /* 8209274Ch */ case   18:  		/* lwz R10, <#[R1 + 80]> */
		/* 8209274Ch case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8209274Ch case   18:*/		return 0x82092750;
	}
	return 0x82092750;
} // Block from 82092704h-82092750h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82092750h
// Function '_powhlp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092750);
		  /* 82092750h */ case    0:  		/* fctiwz FR0, FR29 */
		/* 82092750h case    0:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR29);
		/* 82092750h case    0:*/		return 0x82092754;
		  /* 82092754h */ case    1:  		/* stfd FR0, <#[R1 + 88]> */
		/* 82092754h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82092754h case    1:*/		return 0x82092758;
		  /* 82092758h */ case    2:  		/* lwz R11, <#[R1 + 92]> */
		/* 82092758h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 82092758h case    2:*/		return 0x8209275C;
		  /* 8209275Ch */ case    3:  		/* fmr FR31, FR26 */
		/* 8209275Ch case    3:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR26);
		/* 8209275Ch case    3:*/		return 0x82092760;
		  /* 82092760h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 82092760h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82092760h case    4:*/		return 0x82092764;
		  /* 82092764h */ case    5:  		/* mullw R31, R11, R10 */
		/* 82092764h case    5:*/		cpu::op::mullw<0>(regs,&regs.R31,regs.R11,regs.R10);
		/* 82092764h case    5:*/		return 0x82092768;
		  /* 82092768h */ case    6:  		/* bc 12, CR6_EQ, 28 */
		/* 82092768h case    6:*/		if ( regs.CR[6].eq ) { return 0x82092784;  }
		/* 82092768h case    6:*/		return 0x8209276C;
		  /* 8209276Ch */ case    7:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8209276Ch case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8209276Ch case    7:*/		return 0x82092770;
		  /* 82092770h */ case    8:  		/* bc 12, CR0_EQ, 8 */
		/* 82092770h case    8:*/		if ( regs.CR[0].eq ) { return 0x82092778;  }
		/* 82092770h case    8:*/		return 0x82092774;
		  /* 82092774h */ case    9:  		/* fmul FR31, FR31, FR30 */
		/* 82092774h case    9:*/		cpu::op::fmul<0>(regs,&regs.FR31,regs.FR31,regs.FR30);
		/* 82092774h case    9:*/		return 0x82092778;
	}
	return 0x82092778;
} // Block from 82092750h-82092778h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82092778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092778);
		  /* 82092778h */ case    0:  		/* srawi. R11, R11, 1 */
		/* 82092778h case    0:*/		cpu::op::srawi<1,1>(regs,&regs.R11,regs.R11);
		/* 82092778h case    0:*/		return 0x8209277C;
		  /* 8209277Ch */ case    1:  		/* fmul FR30, FR30, FR30 */
		/* 8209277Ch case    1:*/		cpu::op::fmul<0>(regs,&regs.FR30,regs.FR30,regs.FR30);
		/* 8209277Ch case    1:*/		return 0x82092780;
		  /* 82092780h */ case    2:  		/* bc 4, CR0_EQ, -20 */
		/* 82092780h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8209276C;  }
		/* 82092780h case    2:*/		return 0x82092784;
	}
	return 0x82092784;
} // Block from 82092778h-82092784h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82092784h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092784( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092784) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092784);
		  /* 82092784h */ case    0:  		/* fmr FR1, FR31 */
		/* 82092784h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82092784h case    0:*/		return 0x82092788;
		  /* 82092788h */ case    1:  		/* bl 8744 */
		/* 82092788h case    1:*/		regs.LR = 0x8209278C; return 0x820949B0;
		/* 82092788h case    1:*/		return 0x8209278C;
		  /* 8209278Ch */ case    2:  		/* add R4, R3, R31 */
		/* 8209278Ch case    2:*/		cpu::op::add<0>(regs,&regs.R4,regs.R3,regs.R31);
		/* 8209278Ch case    2:*/		return 0x82092790;
		  /* 82092790h */ case    3:  		/* cmpwi CR6, R4, 2560 */
		/* 82092790h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000A00);
		/* 82092790h case    3:*/		return 0x82092794;
		  /* 82092794h */ case    4:  		/* bc 4, CR6_GT, 20 */
		/* 82092794h case    4:*/		if ( !regs.CR[6].gt ) { return 0x820927A8;  }
		/* 82092794h case    4:*/		return 0x82092798;
		  /* 82092798h */ case    5:  		/* lis R11, -32217 */
		/* 82092798h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82092798h case    5:*/		return 0x8209279C;
		  /* 8209279Ch */ case    6:  		/* lfd FR0, <#[R11 + 7328]> */
		/* 8209279Ch case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001CA0) );
		/* 8209279Ch case    6:*/		return 0x820927A0;
		  /* 820927A0h */ case    7:  		/* fmul FR0, FR0, FR31 */
		/* 820927A0h case    7:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR0,regs.FR31);
		/* 820927A0h case    7:*/		return 0x820927A4;
		  /* 820927A4h */ case    8:  		/* b -192 */
		/* 820927A4h case    8:*/		return 0x820926E4;
		/* 820927A4h case    8:*/		return 0x820927A8;
	}
	return 0x820927A8;
} // Block from 82092784h-820927A8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820927A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820927A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820927A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820927A8);
		  /* 820927A8h */ case    0:  		/* cmpwi CR6, R4, -2557 */
		/* 820927A8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFF603);
		/* 820927A8h case    0:*/		return 0x820927AC;
		  /* 820927ACh */ case    1:  		/* bc 4, CR6_LT, 576 */
		/* 820927ACh case    1:*/		if ( !regs.CR[6].lt ) { return 0x820929EC;  }
		/* 820927ACh case    1:*/		return 0x820927B0;
		  /* 820927B0h */ case    2:  		/* fmul FR0, FR31, FR25 */
		/* 820927B0h case    2:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR31,regs.FR25);
		/* 820927B0h case    2:*/		return 0x820927B4;
		  /* 820927B4h */ case    3:  		/* fmul FR1, FR0, FR27 */
		/* 820927B4h case    3:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR0,regs.FR27);
		/* 820927B4h case    3:*/		return 0x820927B8;
		  /* 820927B8h */ case    4:  		/* b 712 */
		/* 820927B8h case    4:*/		return 0x82092A80;
		/* 820927B8h case    4:*/		return 0x820927BC;
	}
	return 0x820927BC;
} // Block from 820927A8h-820927BCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820927BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820927BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820927BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820927BC);
		  /* 820927BCh */ case    0:  		/* lis R10, -32255 */
		/* 820927BCh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820927BCh case    0:*/		return 0x820927C0;
		  /* 820927C0h */ case    1:  		/* li R11, 1 */
		/* 820927C0h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820927C0h case    1:*/		return 0x820927C4;
		  /* 820927C4h */ case    2:  		/* addi R31, R10, -24840 */
		/* 820927C4h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R10,0xFFFF9EF8);
		/* 820927C4h case    2:*/		return 0x820927C8;
		  /* 820927C8h */ case    3:  		/* lfd FR0, <#[R31 + 72]> */
		/* 820927C8h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000048) );
		/* 820927C8h case    3:*/		return 0x820927CC;
		  /* 820927CCh */ case    4:  		/* fcmpu CR6, FR30, FR0 */
		/* 820927CCh case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR0);
		/* 820927CCh case    4:*/		return 0x820927D0;
		  /* 820927D0h */ case    5:  		/* bc 12, CR6_GT, 8 */
		/* 820927D0h case    5:*/		if ( regs.CR[6].gt ) { return 0x820927D8;  }
		/* 820927D0h case    5:*/		return 0x820927D4;
		  /* 820927D4h */ case    6:  		/* li R11, 9 */
		/* 820927D4h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 820927D4h case    6:*/		return 0x820927D8;
	}
	return 0x820927D8;
} // Block from 820927BCh-820927D8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820927D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820927D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820927D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820927D8);
		  /* 820927D8h */ case    0:  		/* rlwinm R10, R11, 3, 0, 28 */
		/* 820927D8h case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R11);
		/* 820927D8h case    0:*/		return 0x820927DC;
		  /* 820927DCh */ case    1:  		/* addi R9, R31, 32 */
		/* 820927DCh case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x20);
		/* 820927DCh case    1:*/		return 0x820927E0;
		  /* 820927E0h */ case    2:  		/* lfdx FR0, <#[R10 + R9]> */
		/* 820927E0h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820927E0h case    2:*/		return 0x820927E4;
		  /* 820927E4h */ case    3:  		/* fcmpu CR6, FR30, FR0 */
		/* 820927E4h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR0);
		/* 820927E4h case    3:*/		return 0x820927E8;
		  /* 820927E8h */ case    4:  		/* bc 12, CR6_GT, 8 */
		/* 820927E8h case    4:*/		if ( regs.CR[6].gt ) { return 0x820927F0;  }
		/* 820927E8h case    4:*/		return 0x820927EC;
		  /* 820927ECh */ case    5:  		/* addi R11, R11, 4 */
		/* 820927ECh case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820927ECh case    5:*/		return 0x820927F0;
	}
	return 0x820927F0;
} // Block from 820927D8h-820927F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820927F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820927F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820927F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820927F0);
		  /* 820927F0h */ case    0:  		/* rlwinm R10, R11, 3, 0, 28 */
		/* 820927F0h case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R11);
		/* 820927F0h case    0:*/		return 0x820927F4;
		  /* 820927F4h */ case    1:  		/* addi R9, R31, 16 */
		/* 820927F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x10);
		/* 820927F4h case    1:*/		return 0x820927F8;
		  /* 820927F8h */ case    2:  		/* lfdx FR0, <#[R10 + R9]> */
		/* 820927F8h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820927F8h case    2:*/		return 0x820927FC;
		  /* 820927FCh */ case    3:  		/* fcmpu CR6, FR30, FR0 */
		/* 820927FCh case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR0);
		/* 820927FCh case    3:*/		return 0x82092800;
		  /* 82092800h */ case    4:  		/* bc 12, CR6_GT, 8 */
		/* 82092800h case    4:*/		if ( regs.CR[6].gt ) { return 0x82092808;  }
		/* 82092800h case    4:*/		return 0x82092804;
		  /* 82092804h */ case    5:  		/* addi R11, R11, 2 */
		/* 82092804h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82092804h case    5:*/		return 0x82092808;
	}
	return 0x82092808;
} // Block from 820927F0h-82092808h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82092808h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092808);
		  /* 82092808h */ case    0:  		/* lwz R10, <#[R1 + 80]> */
		/* 82092808h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82092808h case    0:*/		return 0x8209280C;
		  /* 8209280Ch */ case    1:  		/* lis R9, -32256 */
		/* 8209280Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 8209280Ch case    1:*/		return 0x82092810;
		  /* 82092810h */ case    2:  		/* rlwinm R10, R10, 4, 0, 27 */
		/* 82092810h case    2:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R10);
		/* 82092810h case    2:*/		return 0x82092814;
		  /* 82092814h */ case    3:  		/* subf R10, R11, R10 */
		/* 82092814h case    3:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82092814h case    3:*/		return 0x82092818;
		  /* 82092818h */ case    4:  		/* lfd FR31, <#[R9 + 4248]> */
		/* 82092818h case    4:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R9 + 0x00001098) );
		/* 82092818h case    4:*/		return 0x8209281C;
		  /* 8209281Ch */ case    5:  		/* srawi R9, R10, 31 */
		/* 8209281Ch case    5:*/		cpu::op::srawi<0,31>(regs,&regs.R9,regs.R10);
		/* 8209281Ch case    5:*/		return 0x82092820;
		  /* 82092820h */ case    6:  		/* xor R8, R10, R9 */
		/* 82092820h case    6:*/		cpu::op::xor<0>(regs,&regs.R8,regs.R10,regs.R9);
		/* 82092820h case    6:*/		return 0x82092824;
		  /* 82092824h */ case    7:  		/* subf R9, R9, R8 */
		/* 82092824h case    7:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82092824h case    7:*/		return 0x82092828;
		  /* 82092828h */ case    8:  		/* cmpwi CR6, R9, 1 */
		/* 82092828h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000001);
		/* 82092828h case    8:*/		return 0x8209282C;
		  /* 8209282Ch */ case    9:  		/* bc 4, CR6_EQ, 28 */
		/* 8209282Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x82092848;  }
		/* 8209282Ch case    9:*/		return 0x82092830;
		  /* 82092830h */ case   10:  		/* fmr FR1, FR28 */
		/* 82092830h case   10:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR28);
		/* 82092830h case   10:*/		return 0x82092834;
		  /* 82092834h */ case   11:  		/* bl 21924 */
		/* 82092834h case   11:*/		regs.LR = 0x82092838; return 0x82097DD8;
		/* 82092834h case   11:*/		return 0x82092838;
		  /* 82092838h */ case   12:  		/* lfd FR0, <#[R31 + 216]> */
		/* 82092838h case   12:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R31 + 0x000000D8) );
		/* 82092838h case   12:*/		return 0x8209283C;
		  /* 8209283Ch */ case   13:  		/* fmr FR13, FR27 */
		/* 8209283Ch case   13:*/		cpu::op::fmr<0>(regs,&regs.FR13,regs.FR27);
		/* 8209283Ch case   13:*/		return 0x82092840;
		  /* 82092840h */ case   14:  		/* fmul FR0, FR1, FR0 */
		/* 82092840h case   14:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR1,regs.FR0);
		/* 82092840h case   14:*/		return 0x82092844;
		  /* 82092844h */ case   15:  		/* b 148 */
		/* 82092844h case   15:*/		return 0x820928D8;
		/* 82092844h case   15:*/		return 0x82092848;
	}
	return 0x82092848;
} // Block from 82092808h-82092848h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82092848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092848);
		  /* 82092848h */ case    0:  		/* rlwinm R9, R11, 3, 0, 28 */
		/* 82092848h case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R11);
		/* 82092848h case    0:*/		return 0x8209284C;
		  /* 8209284Ch */ case    1:  		/* lfd FR11, <#[R31 + 256]> */
		/* 8209284Ch case    1:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R31 + 0x00000100) );
		/* 8209284Ch case    1:*/		return 0x82092850;
		  /* 82092850h */ case    2:  		/* addi R8, R31, 8 */
		/* 82092850h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0x8);
		/* 82092850h case    2:*/		return 0x82092854;
		  /* 82092854h */ case    3:  		/* lfd FR10, <#[R31 + 248]> */
		/* 82092854h case    3:*/		cpu::mem::load64f( regs, &regs.FR10, (uint32)(regs.R31 + 0x000000F8) );
		/* 82092854h case    3:*/		return 0x82092858;
		  /* 82092858h */ case    4:  		/* addi R11, R11, 1 */
		/* 82092858h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82092858h case    4:*/		return 0x8209285C;
		  /* 8209285Ch */ case    5:  		/* lfd FR9, <#[R31 + 240]> */
		/* 8209285Ch case    5:*/		cpu::mem::load64f( regs, &regs.FR9, (uint32)(regs.R31 + 0x000000F0) );
		/* 8209285Ch case    5:*/		return 0x82092860;
		  /* 82092860h */ case    6:  		/* addi R7, R31, 144 */
		/* 82092860h case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R31,0x90);
		/* 82092860h case    6:*/		return 0x82092864;
		  /* 82092864h */ case    7:  		/* lfd FR8, <#[R31 + 232]> */
		/* 82092864h case    7:*/		cpu::mem::load64f( regs, &regs.FR8, (uint32)(regs.R31 + 0x000000E8) );
		/* 82092864h case    7:*/		return 0x82092868;
		  /* 82092868h */ case    8:  		/* srawi R11, R11, 1 */
		/* 82092868h case    8:*/		cpu::op::srawi<0,1>(regs,&regs.R11,regs.R11);
		/* 82092868h case    8:*/		return 0x8209286C;
		  /* 8209286Ch */ case    9:  		/* lfd FR12, <#[R31 + 224]> */
		/* 8209286Ch case    9:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R31 + 0x000000E0) );
		/* 8209286Ch case    9:*/		return 0x82092870;
		  /* 82092870h */ case   10:  		/* lis R6, -32255 */
		/* 82092870h case   10:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8201);
		/* 82092870h case   10:*/		return 0x82092874;
		  /* 82092874h */ case   11:  		/* lfd FR7, <#[R31 + 216]> */
		/* 82092874h case   11:*/		cpu::mem::load64f( regs, &regs.FR7, (uint32)(regs.R31 + 0x000000D8) );
		/* 82092874h case   11:*/		return 0x82092878;
		  /* 82092878h */ case   12:  		/* lfdx FR0, <#[R9 + R8]> */
		/* 82092878h case   12:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82092878h case   12:*/		return 0x8209287C;
		  /* 8209287Ch */ case   13:  		/* addze R11, R11 */
		/* 8209287Ch case   13:*/		cpu::op::addze<0>(regs,&regs.R11,regs.R11);
		/* 8209287Ch case   13:*/		return 0x82092880;
		  /* 82092880h */ case   14:  		/* fsub FR6, FR30, FR0 */
		/* 82092880h case   14:*/		cpu::op::fsub<0>(regs,&regs.FR6,regs.FR30,regs.FR0);
		/* 82092880h case   14:*/		return 0x82092884;
		  /* 82092884h */ case   15:  		/* extsw R10, R10 */
		/* 82092884h case   15:*/		cpu::op::extsw<0>(regs,&regs.R10,regs.R10);
		/* 82092884h case   15:*/		return 0x82092888;
		  /* 82092888h */ case   16:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 82092888h case   16:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 82092888h case   16:*/		return 0x8209288C;
		  /* 8209288Ch */ case   17:  		/* fadd FR5, FR0, FR30 */
		/* 8209288Ch case   17:*/		cpu::op::fadd<0>(regs,&regs.FR5,regs.FR0,regs.FR30);
		/* 8209288Ch case   17:*/		return 0x82092890;
		  /* 82092890h */ case   18:  		/* std R10, <#[R1 + 88]> */
		/* 82092890h case   18:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82092890h case   18:*/		return 0x82092894;
		  /* 82092894h */ case   19:  		/* lfd FR0, <#[R1 + 88]> */
		/* 82092894h case   19:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82092894h case   19:*/		return 0x82092898;
		  /* 82092898h */ case   20:  		/* lfd FR13, <#[R6 - 24504]> */
		/* 82092898h case   20:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R6 + 0xFFFFA048) );
		/* 82092898h case   20:*/		return 0x8209289C;
		  /* 8209289Ch */ case   21:  		/* fcfid FR0, FR0 */
		/* 8209289Ch case   21:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 8209289Ch case   21:*/		return 0x820928A0;
		  /* 820928A0h */ case   22:  		/* lfdx FR4, <#[R11 + R7]> */
		/* 820928A0h case   22:*/		cpu::mem::load64f( regs, &regs.FR4, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820928A0h case   22:*/		return 0x820928A4;
		  /* 820928A4h */ case   23:  		/* fmul FR0, FR0, FR31 */
		/* 820928A4h case   23:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR0,regs.FR31);
		/* 820928A4h case   23:*/		return 0x820928A8;
		  /* 820928A8h */ case   24:  		/* fsub FR6, FR6, FR4 */
		/* 820928A8h case   24:*/		cpu::op::fsub<0>(regs,&regs.FR6,regs.FR6,regs.FR4);
		/* 820928A8h case   24:*/		return 0x820928AC;
		  /* 820928ACh */ case   25:  		/* fdiv FR6, FR6, FR5 */
		/* 820928ACh case   25:*/		cpu::op::fdiv<0>(regs,&regs.FR6,regs.FR6,regs.FR5);
		/* 820928ACh case   25:*/		return 0x820928B0;
		  /* 820928B0h */ case   26:  		/* fmul FR13, FR6, FR13 */
		/* 820928B0h case   26:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR6,regs.FR13);
		/* 820928B0h case   26:*/		return 0x820928B4;
		  /* 820928B4h */ case   27:  		/* fmul FR6, FR13, FR13 */
		/* 820928B4h case   27:*/		cpu::op::fmul<0>(regs,&regs.FR6,regs.FR13,regs.FR13);
		/* 820928B4h case   27:*/		return 0x820928B8;
		  /* 820928B8h */ case   28:  		/* fmul FR12, FR13, FR12 */
		/* 820928B8h case   28:*/		cpu::op::fmul<0>(regs,&regs.FR12,regs.FR13,regs.FR12);
		/* 820928B8h case   28:*/		return 0x820928BC;
		  /* 820928BCh */ case   29:  		/* fmadd FR11, FR6, FR11, FR10 */
		/* 820928BCh case   29:*/		cpu::op::fmadd<0>(regs,&regs.FR11,regs.FR6,regs.FR11,regs.FR10);
		/* 820928BCh case   29:*/		return 0x820928C0;
		  /* 820928C0h */ case   30:  		/* fmadd FR11, FR11, FR6, FR9 */
		/* 820928C0h case   30:*/		cpu::op::fmadd<0>(regs,&regs.FR11,regs.FR11,regs.FR6,regs.FR9);
		/* 820928C0h case   30:*/		return 0x820928C4;
		  /* 820928C4h */ case   31:  		/* fmadd FR11, FR11, FR6, FR8 */
		/* 820928C4h case   31:*/		cpu::op::fmadd<0>(regs,&regs.FR11,regs.FR11,regs.FR6,regs.FR8);
		/* 820928C4h case   31:*/		return 0x820928C8;
		  /* 820928C8h */ case   32:  		/* fmul FR11, FR11, FR6 */
		/* 820928C8h case   32:*/		cpu::op::fmul<0>(regs,&regs.FR11,regs.FR11,regs.FR6);
		/* 820928C8h case   32:*/		return 0x820928CC;
		  /* 820928CCh */ case   33:  		/* fmul FR11, FR11, FR13 */
		/* 820928CCh case   33:*/		cpu::op::fmul<0>(regs,&regs.FR11,regs.FR11,regs.FR13);
		/* 820928CCh case   33:*/		return 0x820928D0;
		  /* 820928D0h */ case   34:  		/* fmadd FR12, FR11, FR7, FR12 */
		/* 820928D0h case   34:*/		cpu::op::fmadd<0>(regs,&regs.FR12,regs.FR11,regs.FR7,regs.FR12);
		/* 820928D0h case   34:*/		return 0x820928D4;
		  /* 820928D4h */ case   35:  		/* fadd FR13, FR12, FR13 */
		/* 820928D4h case   35:*/		cpu::op::fadd<0>(regs,&regs.FR13,regs.FR12,regs.FR13);
		/* 820928D4h case   35:*/		return 0x820928D8;
	}
	return 0x820928D8;
} // Block from 82092848h-820928D8h (36 instructions)

//////////////////////////////////////////////////////
// Block at 820928D8h
// Function 'pow'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820928D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820928D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820928D8);
		  /* 820928D8h */ case    0:  		/* lis R11, -32256 */
		/* 820928D8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820928D8h case    0:*/		return 0x820928DC;
		  /* 820928DCh */ case    1:  		/* fmul FR11, FR13, FR29 */
		/* 820928DCh case    1:*/		cpu::op::fmul<0>(regs,&regs.FR11,regs.FR13,regs.FR29);
		/* 820928DCh case    1:*/		return 0x820928E0;
		  /* 820928E0h */ case    2:  		/* lfd FR12, <#[R31 + 320]> */
		/* 820928E0h case    2:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R31 + 0x00000140) );
		/* 820928E0h case    2:*/		return 0x820928E4;
		  /* 820928E4h */ case    3:  		/* lfd FR13, <#[R11 + 8376]> */
		/* 820928E4h case    3:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x000020B8) );
		/* 820928E4h case    3:*/		return 0x820928E8;
		  /* 820928E8h */ case    4:  		/* fmul FR10, FR29, FR13 */
		/* 820928E8h case    4:*/		cpu::op::fmul<0>(regs,&regs.FR10,regs.FR29,regs.FR13);
		/* 820928E8h case    4:*/		return 0x820928EC;
		  /* 820928ECh */ case    5:  		/* fctid FR10, FR10 */
		/* 820928ECh case    5:*/		cpu::op::fctid<0>(regs,&regs.FR10,regs.FR10);
		/* 820928ECh case    5:*/		return 0x820928F0;
		  /* 820928F0h */ case    6:  		/* fcfid FR10, FR10 */
		/* 820928F0h case    6:*/		cpu::op::fcfid<0>(regs,&regs.FR10,regs.FR10);
		/* 820928F0h case    6:*/		return 0x820928F4;
		  /* 820928F4h */ case    7:  		/* fmul FR10, FR10, FR31 */
		/* 820928F4h case    7:*/		cpu::op::fmul<0>(regs,&regs.FR10,regs.FR10,regs.FR31);
		/* 820928F4h case    7:*/		return 0x820928F8;
		  /* 820928F8h */ case    8:  		/* fsub FR9, FR29, FR10 */
		/* 820928F8h case    8:*/		cpu::op::fsub<0>(regs,&regs.FR9,regs.FR29,regs.FR10);
		/* 820928F8h case    8:*/		return 0x820928FC;
		  /* 820928FCh */ case    9:  		/* fmadd FR11, FR9, FR0, FR11 */
		/* 820928FCh case    9:*/		cpu::op::fmadd<0>(regs,&regs.FR11,regs.FR9,regs.FR0,regs.FR11);
		/* 820928FCh case    9:*/		return 0x82092900;
		  /* 82092900h */ case   10:  		/* fmul FR9, FR11, FR13 */
		/* 82092900h case   10:*/		cpu::op::fmul<0>(regs,&regs.FR9,regs.FR11,regs.FR13);
		/* 82092900h case   10:*/		return 0x82092904;
		  /* 82092904h */ case   11:  		/* fctid FR9, FR9 */
		/* 82092904h case   11:*/		cpu::op::fctid<0>(regs,&regs.FR9,regs.FR9);
		/* 82092904h case   11:*/		return 0x82092908;
		  /* 82092908h */ case   12:  		/* fcfid FR9, FR9 */
		/* 82092908h case   12:*/		cpu::op::fcfid<0>(regs,&regs.FR9,regs.FR9);
		/* 82092908h case   12:*/		return 0x8209290C;
		  /* 8209290Ch */ case   13:  		/* fmul FR9, FR9, FR31 */
		/* 8209290Ch case   13:*/		cpu::op::fmul<0>(regs,&regs.FR9,regs.FR9,regs.FR31);
		/* 8209290Ch case   13:*/		return 0x82092910;
		  /* 82092910h */ case   14:  		/* fmadd FR0, FR10, FR0, FR9 */
		/* 82092910h case   14:*/		cpu::op::fmadd<0>(regs,&regs.FR0,regs.FR10,regs.FR0,regs.FR9);
		/* 82092910h case   14:*/		return 0x82092914;
		  /* 82092914h */ case   15:  		/* fsub FR11, FR11, FR9 */
		/* 82092914h case   15:*/		cpu::op::fsub<0>(regs,&regs.FR11,regs.FR11,regs.FR9);
		/* 82092914h case   15:*/		return 0x82092918;
		  /* 82092918h */ case   16:  		/* fmul FR10, FR0, FR13 */
		/* 82092918h case   16:*/		cpu::op::fmul<0>(regs,&regs.FR10,regs.FR0,regs.FR13);
		/* 82092918h case   16:*/		return 0x8209291C;
		  /* 8209291Ch */ case   17:  		/* fctid FR10, FR10 */
		/* 8209291Ch case   17:*/		cpu::op::fctid<0>(regs,&regs.FR10,regs.FR10);
		/* 8209291Ch case   17:*/		return 0x82092920;
		  /* 82092920h */ case   18:  		/* fcfid FR10, FR10 */
		/* 82092920h case   18:*/		cpu::op::fcfid<0>(regs,&regs.FR10,regs.FR10);
		/* 82092920h case   18:*/		return 0x82092924;
		  /* 82092924h */ case   19:  		/* fmul FR10, FR10, FR31 */
		/* 82092924h case   19:*/		cpu::op::fmul<0>(regs,&regs.FR10,regs.FR10,regs.FR31);
		/* 82092924h case   19:*/		return 0x82092928;
		  /* 82092928h */ case   20:  		/* fsub FR0, FR0, FR10 */
		/* 82092928h case   20:*/		cpu::op::fsub<0>(regs,&regs.FR0,regs.FR0,regs.FR10);
		/* 82092928h case   20:*/		return 0x8209292C;
		  /* 8209292Ch */ case   21:  		/* fadd FR0, FR0, FR11 */
		/* 8209292Ch case   21:*/		cpu::op::fadd<0>(regs,&regs.FR0,regs.FR0,regs.FR11);
		/* 8209292Ch case   21:*/		return 0x82092930;
		  /* 82092930h */ case   22:  		/* fmul FR11, FR0, FR13 */
		/* 82092930h case   22:*/		cpu::op::fmul<0>(regs,&regs.FR11,regs.FR0,regs.FR13);
		/* 82092930h case   22:*/		return 0x82092934;
		  /* 82092934h */ case   23:  		/* fctid FR11, FR11 */
		/* 82092934h case   23:*/		cpu::op::fctid<0>(regs,&regs.FR11,regs.FR11);
		/* 82092934h case   23:*/		return 0x82092938;
		  /* 82092938h */ case   24:  		/* fcfid FR11, FR11 */
		/* 82092938h case   24:*/		cpu::op::fcfid<0>(regs,&regs.FR11,regs.FR11);
		/* 82092938h case   24:*/		return 0x8209293C;
		  /* 8209293Ch */ case   25:  		/* fmul FR11, FR11, FR31 */
		/* 8209293Ch case   25:*/		cpu::op::fmul<0>(regs,&regs.FR11,regs.FR11,regs.FR31);
		/* 8209293Ch case   25:*/		return 0x82092940;
		  /* 82092940h */ case   26:  		/* fadd FR10, FR10, FR11 */
		/* 82092940h case   26:*/		cpu::op::fadd<0>(regs,&regs.FR10,regs.FR10,regs.FR11);
		/* 82092940h case   26:*/		return 0x82092944;
		  /* 82092944h */ case   27:  		/* fsub FR0, FR0, FR11 */
		/* 82092944h case   27:*/		cpu::op::fsub<0>(regs,&regs.FR0,regs.FR0,regs.FR11);
		/* 82092944h case   27:*/		return 0x82092948;
		  /* 82092948h */ case   28:  		/* fmul FR13, FR10, FR13 */
		/* 82092948h case   28:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR10,regs.FR13);
		/* 82092948h case   28:*/		return 0x8209294C;
		  /* 8209294Ch */ case   29:  		/* fcmpu CR6, FR13, FR12 */
		/* 8209294Ch case   29:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR12);
		/* 8209294Ch case   29:*/		return 0x82092950;
		  /* 82092950h */ case   30:  		/* bc 12, CR6_GT, -628 */
		/* 82092950h case   30:*/		if ( regs.CR[6].gt ) { return 0x820926DC;  }
		/* 82092950h case   30:*/		return 0x82092954;
		  /* 82092954h */ case   31:  		/* lfd FR12, <#[R31 + 328]> */
		/* 82092954h case   31:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R31 + 0x00000148) );
		/* 82092954h case   31:*/		return 0x82092958;
		  /* 82092958h */ case   32:  		/* fcmpu CR6, FR13, FR12 */
		/* 82092958h case   32:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR12);
		/* 82092958h case   32:*/		return 0x8209295C;
		  /* 8209295Ch */ case   33:  		/* bc 12, CR6_LT, -616 */
		/* 8209295Ch case   33:*/		if ( regs.CR[6].lt ) { return 0x820926F4;  }
		/* 8209295Ch case   33:*/		return 0x82092960;
		  /* 82092960h */ case   34:  		/* fctiwz FR13, FR13 */
		/* 82092960h case   34:*/		cpu::op::fctiwz<0>(regs,&regs.FR13,regs.FR13);
		/* 82092960h case   34:*/		return 0x82092964;
		  /* 82092964h */ case   35:  		/* stfd FR13, <#[R1 + 88]> */
		/* 82092964h case   35:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 82092964h case   35:*/		return 0x82092968;
		  /* 82092968h */ case   36:  		/* fcmpu CR6, FR0, FR27 */
		/* 82092968h case   36:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR27);
		/* 82092968h case   36:*/		return 0x8209296C;
		  /* 8209296Ch */ case   37:  		/* lwz R11, <#[R1 + 92]> */
		/* 8209296Ch case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8209296Ch case   37:*/		return 0x82092970;
		  /* 82092970h */ case   38:  		/* bc 4, CR6_GT, 12 */
		/* 82092970h case   38:*/		if ( !regs.CR[6].gt ) { return 0x8209297C;  }
		/* 82092970h case   38:*/		return 0x82092974;
		  /* 82092974h */ case   39:  		/* addi R11, R11, 1 */
		/* 82092974h case   39:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82092974h case   39:*/		return 0x82092978;
		  /* 82092978h */ case   40:  		/* fsub FR0, FR0, FR31 */
		/* 82092978h case   40:*/		cpu::op::fsub<0>(regs,&regs.FR0,regs.FR0,regs.FR31);
		/* 82092978h case   40:*/		return 0x8209297C;
	}
	return 0x8209297C;
} // Block from 820928D8h-8209297Ch (41 instructions)

//////////////////////////////////////////////////////
// Block at 8209297Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209297C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209297C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209297C);
		  /* 8209297Ch */ case    0:  		/* lfd FR13, <#[R31 + 312]> */
		/* 8209297Ch case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R31 + 0x00000138) );
		/* 8209297Ch case    0:*/		return 0x82092980;
		  /* 82092980h */ case    1:  		/* srawi R10, R11, 4 */
		/* 82092980h case    1:*/		cpu::op::srawi<0,4>(regs,&regs.R10,regs.R11);
		/* 82092980h case    1:*/		return 0x82092984;
		  /* 82092984h */ case    2:  		/* lfd FR12, <#[R31 + 304]> */
		/* 82092984h case    2:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R31 + 0x00000130) );
		/* 82092984h case    2:*/		return 0x82092988;
		  /* 82092988h */ case    3:  		/* rlwinm R9, R11, 1, 31, 31 */
		/* 82092988h case    3:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R9,regs.R11);
		/* 82092988h case    3:*/		return 0x8209298C;
		  /* 8209298Ch */ case    4:  		/* fmadd FR8, FR0, FR13, FR12 */
		/* 8209298Ch case    4:*/		cpu::op::fmadd<0>(regs,&regs.FR8,regs.FR0,regs.FR13,regs.FR12);
		/* 8209298Ch case    4:*/		return 0x82092990;
		  /* 82092990h */ case    5:  		/* lfd FR13, <#[R31 + 296]> */
		/* 82092990h case    5:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R31 + 0x00000128) );
		/* 82092990h case    5:*/		return 0x82092994;
		  /* 82092994h */ case    6:  		/* lfd FR12, <#[R31 + 288]> */
		/* 82092994h case    6:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R31 + 0x00000120) );
		/* 82092994h case    6:*/		return 0x82092998;
		  /* 82092998h */ case    7:  		/* addze R10, R10 */
		/* 82092998h case    7:*/		cpu::op::addze<0>(regs,&regs.R10,regs.R10);
		/* 82092998h case    7:*/		return 0x8209299C;
		  /* 8209299Ch */ case    8:  		/* lfd FR11, <#[R31 + 280]> */
		/* 8209299Ch case    8:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R31 + 0x00000118) );
		/* 8209299Ch case    8:*/		return 0x820929A0;
		  /* 820929A0h */ case    9:  		/* xori R9, R9, 1 */
		/* 820929A0h case    9:*/		cpu::op::xori<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820929A0h case    9:*/		return 0x820929A4;
		  /* 820929A4h */ case   10:  		/* lfd FR10, <#[R31 + 272]> */
		/* 820929A4h case   10:*/		cpu::mem::load64f( regs, &regs.FR10, (uint32)(regs.R31 + 0x00000110) );
		/* 820929A4h case   10:*/		return 0x820929A8;
		  /* 820929A8h */ case   11:  		/* addi R8, R31, 8 */
		/* 820929A8h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0x8);
		/* 820929A8h case   11:*/		return 0x820929AC;
		  /* 820929ACh */ case   12:  		/* lfd FR9, <#[R31 + 264]> */
		/* 820929ACh case   12:*/		cpu::mem::load64f( regs, &regs.FR9, (uint32)(regs.R31 + 0x00000108) );
		/* 820929ACh case   12:*/		return 0x820929B0;
		  /* 820929B0h */ case   13:  		/* add R31, R9, R10 */
		/* 820929B0h case   13:*/		cpu::op::add<0>(regs,&regs.R31,regs.R9,regs.R10);
		/* 820929B0h case   13:*/		return 0x820929B4;
		  /* 820929B4h */ case   14:  		/* rlwinm R10, R31, 4, 0, 27 */
		/* 820929B4h case   14:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R31);
		/* 820929B4h case   14:*/		return 0x820929B8;
		  /* 820929B8h */ case   15:  		/* subf R11, R11, R10 */
		/* 820929B8h case   15:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820929B8h case   15:*/		return 0x820929BC;
		  /* 820929BCh */ case   16:  		/* fmadd FR13, FR8, FR0, FR13 */
		/* 820929BCh case   16:*/		cpu::op::fmadd<0>(regs,&regs.FR13,regs.FR8,regs.FR0,regs.FR13);
		/* 820929BCh case   16:*/		return 0x820929C0;
		  /* 820929C0h */ case   17:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 820929C0h case   17:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 820929C0h case   17:*/		return 0x820929C4;
		  /* 820929C4h */ case   18:  		/* lfdx FR8, <#[R11 + R8]> */
		/* 820929C4h case   18:*/		cpu::mem::load64f( regs, &regs.FR8, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820929C4h case   18:*/		return 0x820929C8;
		  /* 820929C8h */ case   19:  		/* fmadd FR13, FR13, FR0, FR12 */
		/* 820929C8h case   19:*/		cpu::op::fmadd<0>(regs,&regs.FR13,regs.FR13,regs.FR0,regs.FR12);
		/* 820929C8h case   19:*/		return 0x820929CC;
		  /* 820929CCh */ case   20:  		/* fmadd FR13, FR13, FR0, FR11 */
		/* 820929CCh case   20:*/		cpu::op::fmadd<0>(regs,&regs.FR13,regs.FR13,regs.FR0,regs.FR11);
		/* 820929CCh case   20:*/		return 0x820929D0;
		  /* 820929D0h */ case   21:  		/* fmadd FR13, FR13, FR0, FR10 */
		/* 820929D0h case   21:*/		cpu::op::fmadd<0>(regs,&regs.FR13,regs.FR13,regs.FR0,regs.FR10);
		/* 820929D0h case   21:*/		return 0x820929D4;
		  /* 820929D4h */ case   22:  		/* fmadd FR13, FR13, FR0, FR9 */
		/* 820929D4h case   22:*/		cpu::op::fmadd<0>(regs,&regs.FR13,regs.FR13,regs.FR0,regs.FR9);
		/* 820929D4h case   22:*/		return 0x820929D8;
		  /* 820929D8h */ case   23:  		/* fmadd FR0, FR13, FR0, FR26 */
		/* 820929D8h case   23:*/		cpu::op::fmadd<0>(regs,&regs.FR0,regs.FR13,regs.FR0,regs.FR26);
		/* 820929D8h case   23:*/		return 0x820929DC;
		  /* 820929DCh */ case   24:  		/* fmul FR31, FR0, FR8 */
		/* 820929DCh case   24:*/		cpu::op::fmul<0>(regs,&regs.FR31,regs.FR0,regs.FR8);
		/* 820929DCh case   24:*/		return 0x820929E0;
		  /* 820929E0h */ case   25:  		/* fmr FR1, FR31 */
		/* 820929E0h case   25:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820929E0h case   25:*/		return 0x820929E4;
		  /* 820929E4h */ case   26:  		/* bl 8140 */
		/* 820929E4h case   26:*/		regs.LR = 0x820929E8; return 0x820949B0;
		/* 820929E4h case   26:*/		return 0x820929E8;
		  /* 820929E8h */ case   27:  		/* add R4, R3, R31 */
		/* 820929E8h case   27:*/		cpu::op::add<0>(regs,&regs.R4,regs.R3,regs.R31);
		/* 820929E8h case   27:*/		return 0x820929EC;
	}
	return 0x820929EC;
} // Block from 8209297Ch-820929ECh (28 instructions)

//////////////////////////////////////////////////////
// Block at 820929ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820929EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820929EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820929EC);
		  /* 820929ECh */ case    0:  		/* cmpwi CR6, R4, 1024 */
		/* 820929ECh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000400);
		/* 820929ECh case    0:*/		return 0x820929F0;
		  /* 820929F0h */ case    1:  		/* bc 12, CR6_GT, -788 */
		/* 820929F0h case    1:*/		if ( regs.CR[6].gt ) { return 0x820926DC;  }
		/* 820929F0h case    1:*/		return 0x820929F4;
		  /* 820929F4h */ case    2:  		/* cmpwi CR6, R4, -1021 */
		/* 820929F4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFC03);
		/* 820929F4h case    2:*/		return 0x820929F8;
		  /* 820929F8h */ case    3:  		/* bc 12, CR6_LT, -772 */
		/* 820929F8h case    3:*/		if ( regs.CR[6].lt ) { return 0x820926F4;  }
		/* 820929F8h case    3:*/		return 0x820929FC;
		  /* 820929FCh */ case    4:  		/* fmr FR1, FR31 */
		/* 820929FCh case    4:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820929FCh case    4:*/		return 0x82092A00;
		  /* 82092A00h */ case    5:  		/* bl 8072 */
		/* 82092A00h case    5:*/		regs.LR = 0x82092A04; return 0x82094988;
		/* 82092A00h case    5:*/		return 0x82092A04;
		  /* 82092A04h */ case    6:  		/* fmul FR1, FR1, FR25 */
		/* 82092A04h case    6:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR1,regs.FR25);
		/* 82092A04h case    6:*/		return 0x82092A08;
		  /* 82092A08h */ case    7:  		/* b 120 */
		/* 82092A08h case    7:*/		return 0x82092A80;
		/* 82092A08h case    7:*/		return 0x82092A0C;
	}
	return 0x82092A0C;
} // Block from 820929ECh-82092A0Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 82092A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092A0C);
		  /* 82092A0Ch */ case    0:  		/* rlwinm R10, R11, 0, 17, 28 */
		/* 82092A0Ch case    0:*/		cpu::op::rlwinm<0,0,17,28>(regs,&regs.R10,regs.R11);
		/* 82092A0Ch case    0:*/		return 0x82092A10;
		  /* 82092A10h */ case    1:  		/* cmplwi CR6, R10, 32752 */
		/* 82092A10h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00007FF0);
		/* 82092A10h case    1:*/		return 0x82092A14;
		  /* 82092A14h */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 82092A14h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82092A30;  }
		/* 82092A14h case    2:*/		return 0x82092A18;
		  /* 82092A18h */ case    3:  		/* lwz R11, <#[R1 + 192]> */
		/* 82092A18h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000C0) );
		/* 82092A18h case    3:*/		return 0x82092A1C;
		  /* 82092A1Ch */ case    4:  		/* rlwinm. R11, R11, 0, 13, 31 */
		/* 82092A1Ch case    4:*/		cpu::op::rlwinm<1,0,13,31>(regs,&regs.R11,regs.R11);
		/* 82092A1Ch case    4:*/		return 0x82092A20;
		  /* 82092A20h */ case    5:  		/* bc 4, CR0_EQ, 92 */
		/* 82092A20h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82092A7C;  }
		/* 82092A20h case    5:*/		return 0x82092A24;
		  /* 82092A24h */ case    6:  		/* lwz R11, <#[R1 + 196]> */
		/* 82092A24h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000C4) );
		/* 82092A24h case    6:*/		return 0x82092A28;
		  /* 82092A28h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82092A28h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82092A28h case    7:*/		return 0x82092A2C;
		  /* 82092A2Ch */ case    8:  		/* bc 4, CR6_EQ, 80 */
		/* 82092A2Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x82092A7C;  }
		/* 82092A2Ch case    8:*/		return 0x82092A30;
	}
	return 0x82092A30;
} // Block from 82092A0Ch-82092A30h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82092A30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092A30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092A30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092A30);
		  /* 82092A30h */ case    0:  		/* rlwinm R11, R9, 0, 17, 28 */
		/* 82092A30h case    0:*/		cpu::op::rlwinm<0,0,17,28>(regs,&regs.R11,regs.R9);
		/* 82092A30h case    0:*/		return 0x82092A34;
		  /* 82092A34h */ case    1:  		/* cmplwi CR6, R11, 32752 */
		/* 82092A34h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00007FF0);
		/* 82092A34h case    1:*/		return 0x82092A38;
		  /* 82092A38h */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 82092A38h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82092A54;  }
		/* 82092A38h case    2:*/		return 0x82092A3C;
		  /* 82092A3Ch */ case    3:  		/* lwz R9, <#[R1 + 200]> */
		/* 82092A3Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000C8) );
		/* 82092A3Ch case    3:*/		return 0x82092A40;
		  /* 82092A40h */ case    4:  		/* rlwinm. R9, R9, 0, 13, 31 */
		/* 82092A40h case    4:*/		cpu::op::rlwinm<1,0,13,31>(regs,&regs.R9,regs.R9);
		/* 82092A40h case    4:*/		return 0x82092A44;
		  /* 82092A44h */ case    5:  		/* bc 4, CR0_EQ, 56 */
		/* 82092A44h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82092A7C;  }
		/* 82092A44h case    5:*/		return 0x82092A48;
		  /* 82092A48h */ case    6:  		/* lwz R9, <#[R1 + 204]> */
		/* 82092A48h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000CC) );
		/* 82092A48h case    6:*/		return 0x82092A4C;
		  /* 82092A4Ch */ case    7:  		/* cmplwi CR6, R9, 0 */
		/* 82092A4Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82092A4Ch case    7:*/		return 0x82092A50;
		  /* 82092A50h */ case    8:  		/* bc 4, CR6_EQ, 44 */
		/* 82092A50h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82092A7C;  }
		/* 82092A50h case    8:*/		return 0x82092A54;
	}
	return 0x82092A54;
} // Block from 82092A30h-82092A54h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82092A54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092A54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092A54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092A54);
		  /* 82092A54h */ case    0:  		/* cmplwi CR6, R10, 32760 */
		/* 82092A54h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00007FF8);
		/* 82092A54h case    0:*/		return 0x82092A58;
		  /* 82092A58h */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 82092A58h case    1:*/		if ( regs.CR[6].eq ) { return 0x82092A7C;  }
		/* 82092A58h case    1:*/		return 0x82092A5C;
		  /* 82092A5Ch */ case    2:  		/* cmplwi CR6, R11, 32760 */
		/* 82092A5Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00007FF8);
		/* 82092A5Ch case    2:*/		return 0x82092A60;
		  /* 82092A60h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 82092A60h case    3:*/		if ( regs.CR[6].eq ) { return 0x82092A7C;  }
		/* 82092A60h case    3:*/		return 0x82092A64;
		  /* 82092A64h */ case    4:  		/* addi R5, R1, 88 */
		/* 82092A64h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 82092A64h case    4:*/		return 0x82092A68;
		  /* 82092A68h */ case    5:  		/* fmr FR2, FR29 */
		/* 82092A68h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR29);
		/* 82092A68h case    5:*/		return 0x82092A6C;
		  /* 82092A6Ch */ case    6:  		/* fmr FR1, FR28 */
		/* 82092A6Ch case    6:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR28);
		/* 82092A6Ch case    6:*/		return 0x82092A70;
		  /* 82092A70h */ case    7:  		/* bl -1600 */
		/* 82092A70h case    7:*/		regs.LR = 0x82092A74; return 0x82092430;
		/* 82092A70h case    7:*/		return 0x82092A74;
		  /* 82092A74h */ case    8:  		/* lfd FR1, <#[R1 + 88]> */
		/* 82092A74h case    8:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0x00000058) );
		/* 82092A74h case    8:*/		return 0x82092A78;
		  /* 82092A78h */ case    9:  		/* b 8 */
		/* 82092A78h case    9:*/		return 0x82092A80;
		/* 82092A78h case    9:*/		return 0x82092A7C;
	}
	return 0x82092A7C;
} // Block from 82092A54h-82092A7Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 82092A7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092A7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092A7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092A7C);
		  /* 82092A7Ch */ case    0:  		/* fadd FR1, FR28, FR29 */
		/* 82092A7Ch case    0:*/		cpu::op::fadd<0>(regs,&regs.FR1,regs.FR28,regs.FR29);
		/* 82092A7Ch case    0:*/		return 0x82092A80;
	}
	return 0x82092A80;
} // Block from 82092A7Ch-82092A80h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82092A80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092A80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092A80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092A80);
		  /* 82092A80h */ case    0:  		/* addi R1, R1, 176 */
		/* 82092A80h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82092A80h case    0:*/		return 0x82092A84;
		  /* 82092A84h */ case    1:  		/* addi R12, R1, -16 */
		/* 82092A84h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFFF0);
		/* 82092A84h case    1:*/		return 0x82092A88;
		  /* 82092A88h */ case    2:  		/* bl -5680 */
		/* 82092A88h case    2:*/		regs.LR = 0x82092A8C; return 0x82091458;
		/* 82092A88h case    2:*/		return 0x82092A8C;
		  /* 82092A8Ch */ case    3:  		/* lwz R12, <#[R1 - 8]> */
		/* 82092A8Ch case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82092A8Ch case    3:*/		return 0x82092A90;
		  /* 82092A90h */ case    4:  		/* mtspr LR, R12 */
		/* 82092A90h case    4:*/		regs.LR = regs.R12;
		/* 82092A90h case    4:*/		return 0x82092A94;
		  /* 82092A94h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 82092A94h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82092A94h case    5:*/		return 0x82092A98;
		  /* 82092A98h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82092A98h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82092A98h case    6:*/		return 0x82092A9C;
	}
	return 0x82092A9C;
} // Block from 82092A80h-82092A9Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82092A9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092A9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092A9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092A9C);
		  /* 82092A9Ch */ case    0:  		/* nop */
		/* 82092A9Ch case    0:*/		cpu::op::nop();
		/* 82092A9Ch case    0:*/		return 0x82092AA0;
	}
	return 0x82092AA0;
} // Block from 82092A9Ch-82092AA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82092AA0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092AA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092AA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092AA0);
		  /* 82092AA0h */ case    0:  		/* cntlzd R5, R3 */
		/* 82092AA0h case    0:*/		cpu::op::cntlzd<0>(regs,&regs.R5,regs.R3);
		/* 82092AA0h case    0:*/		return 0x82092AA4;
		  /* 82092AA4h */ case    1:  		/* sld R3, R3, R5 */
		/* 82092AA4h case    1:*/		cpu::op::sld<0>(regs,&regs.R3,regs.R3,regs.R5);
		/* 82092AA4h case    1:*/		return 0x82092AA8;
		  /* 82092AA8h */ case    2:  		/* cmpdi CR0, R3, 0 */
		/* 82092AA8h case    2:*/		cpu::op::cmpdi<0>(regs,regs.R3,0x00000000);
		/* 82092AA8h case    2:*/		return 0x82092AAC;
		  /* 82092AACh */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 82092AACh case    3:*/		if ( regs.CR[0].eq ) { return 0x82092ABC;  }
		/* 82092AACh case    3:*/		return 0x82092AB0;
		  /* 82092AB0h */ case    4:  		/* subfic R5, R5, 1086 */
		/* 82092AB0h case    4:*/		cpu::op::subfic<0>(regs,&regs.R5,regs.R5,0x43E);
		/* 82092AB0h case    4:*/		return 0x82092AB4;
		  /* 82092AB4h */ case    5:  		/* rldicl R3, R3, 53, 12 */
		/* 82092AB4h case    5:*/		cpu::op::rldicl<0,53,12>(regs,&regs.R3,regs.R3);
		/* 82092AB4h case    5:*/		return 0x82092AB8;
		  /* 82092AB8h */ case    6:  		/* rldimi R3, R5, 52, 1 */
		/* 82092AB8h case    6:*/		cpu::op::rldimi<0,52,1>(regs,&regs.R3,regs.R5);
		/* 82092AB8h case    6:*/		return 0x82092ABC;
	}
	return 0x82092ABC;
} // Block from 82092AA0h-82092ABCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 82092ABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092ABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092ABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092ABC);
		  /* 82092ABCh */ case    0:  		/* std R3, <#[R1 - 8]> */
		/* 82092ABCh case    0:*/		cpu::mem::store64( regs, regs.R3, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82092ABCh case    0:*/		return 0x82092AC0;
		  /* 82092AC0h */ case    1:  		/* lfd FR1, <#[R1 - 8]> */
		/* 82092AC0h case    1:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82092AC0h case    1:*/		return 0x82092AC4;
		  /* 82092AC4h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82092AC4h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82092AC4h case    2:*/		return 0x82092AC8;
	}
	return 0x82092AC8;
} // Block from 82092ABCh-82092AC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82092AC8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092AC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092AC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092AC8);
		  /* 82092AC8h */ case    0:  		/* mr R11, R3 */
		/* 82092AC8h case    0:*/		regs.R11 = regs.R3;
		/* 82092AC8h case    0:*/		return 0x82092ACC;
		  /* 82092ACCh */ case    1:  		/* cmplwi CR6, R5, 0 */
		/* 82092ACCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82092ACCh case    1:*/		return 0x82092AD0;
		  /* 82092AD0h */ case    2:  		/* bclr 12, CR6_EQ */
		/* 82092AD0h case    2:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82092AD0h case    2:*/		return 0x82092AD4;
	}
	return 0x82092AD4;
} // Block from 82092AC8h-82092AD4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82092AD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092AD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092AD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092AD4);
		  /* 82092AD4h */ case    0:  		/* subf R10, R3, R4 */
		/* 82092AD4h case    0:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R3,regs.R4);
		/* 82092AD4h case    0:*/		return 0x82092AD8;
		  /* 82092AD8h */ case    1:  		/* lbzx R9, <#[R10 + R11]> */
		/* 82092AD8h case    1:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82092AD8h case    1:*/		return 0x82092ADC;
		  /* 82092ADCh */ case    2:  		/* cmplwi CR0, R9, 0 */
		/* 82092ADCh case    2:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 82092ADCh case    2:*/		return 0x82092AE0;
		  /* 82092AE0h */ case    3:  		/* stb R9, <#[R11]> */
		/* 82092AE0h case    3:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82092AE0h case    3:*/		return 0x82092AE4;
		  /* 82092AE4h */ case    4:  		/* addi R11, R11, 1 */
		/* 82092AE4h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82092AE4h case    4:*/		return 0x82092AE8;
		  /* 82092AE8h */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 82092AE8h case    5:*/		if ( regs.CR[0].eq ) { return 0x82092AF4;  }
		/* 82092AE8h case    5:*/		return 0x82092AEC;
		  /* 82092AECh */ case    6:  		/* addic. R5, R5, -1 */
		/* 82092AECh case    6:*/		cpu::op::addic<1>(regs,&regs.R5,regs.R5,0xFFFFFFFF);
		/* 82092AECh case    6:*/		return 0x82092AF0;
		  /* 82092AF0h */ case    7:  		/* bc 4, CR0_EQ, -24 */
		/* 82092AF0h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82092AD8;  }
		/* 82092AF0h case    7:*/		return 0x82092AF4;
	}
	return 0x82092AF4;
} // Block from 82092AD4h-82092AF4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82092AF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092AF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092AF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092AF4);
		  /* 82092AF4h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 82092AF4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82092AF4h case    0:*/		return 0x82092AF8;
		  /* 82092AF8h */ case    1:  		/* bclr 12, CR6_EQ */
		/* 82092AF8h case    1:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82092AF8h case    1:*/		return 0x82092AFC;
	}
	return 0x82092AFC;
} // Block from 82092AF4h-82092AFCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82092AFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092AFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092AFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092AFC);
		  /* 82092AFCh */ case    0:  		/* addic. R10, R5, -1 */
		/* 82092AFCh case    0:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R5,0xFFFFFFFF);
		/* 82092AFCh case    0:*/		return 0x82092B00;
		  /* 82092B00h */ case    1:  		/* bclr 12, CR0_EQ */
		/* 82092B00h case    1:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82092B00h case    1:*/		return 0x82092B04;
	}
	return 0x82092B04;
} // Block from 82092AFCh-82092B04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82092B04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092B04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092B04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092B04);
		  /* 82092B04h */ case    0:  		/* addi R11, R11, -1 */
		/* 82092B04h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82092B04h case    0:*/		return 0x82092B08;
		  /* 82092B08h */ case    1:  		/* li R9, 0 */
		/* 82092B08h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82092B08h case    1:*/		return 0x82092B0C;
		  /* 82092B0Ch */ case    2:  		/* cmplwi CR0, R10, 0 */
		/* 82092B0Ch case    2:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 82092B0Ch case    2:*/		return 0x82092B10;
		  /* 82092B10h */ case    3:  		/* bclr 12, CR0_EQ */
		/* 82092B10h case    3:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82092B10h case    3:*/		return 0x82092B14;
	}
	return 0x82092B14;
} // Block from 82092B04h-82092B14h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82092B14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092B14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092B14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092B14);
		  /* 82092B14h */ case    0:  		/* mtspr CTR, R10 */
		/* 82092B14h case    0:*/		regs.CTR = regs.R10;
		/* 82092B14h case    0:*/		return 0x82092B18;
		  /* 82092B18h */ case    1:  		/* stbu R9, <#[R11 + 1]> */
		/* 82092B18h case    1:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R11 + 0x00000001) );
		regs.R11 = (uint32)(regs.R11 + 0x00000001);
		/* 82092B18h case    1:*/		return 0x82092B1C;
		  /* 82092B1Ch */ case    2:  		/* bc 16, CR0_LT, -4 */
		/* 82092B1Ch case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82092B18;  }
		/* 82092B1Ch case    2:*/		return 0x82092B20;
		  /* 82092B20h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82092B20h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82092B20h case    3:*/		return 0x82092B24;
	}
	return 0x82092B24;
} // Block from 82092B14h-82092B24h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82092B24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092B24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092B24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092B24);
		  /* 82092B24h */ case    0:  		/* nop */
		/* 82092B24h case    0:*/		cpu::op::nop();
		/* 82092B24h case    0:*/		return 0x82092B28;
	}
	return 0x82092B28;
} // Block from 82092B24h-82092B28h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82092B28h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092B28);
		  /* 82092B28h */ case    0:  		/* fctidz FR12, FR1 */
		/* 82092B28h case    0:*/		cpu::op::fctidz<0>(regs,&regs.FR12,regs.FR1);
		/* 82092B28h case    0:*/		return 0x82092B2C;
		  /* 82092B2Ch */ case    1:  		/* lis R11, -32256 */
		/* 82092B2Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82092B2Ch case    1:*/		return 0x82092B30;
		  /* 82092B30h */ case    2:  		/* fabs FR11, FR1 */
		/* 82092B30h case    2:*/		cpu::op::fabs<0>(regs,&regs.FR11,regs.FR1);
		/* 82092B30h case    2:*/		return 0x82092B34;
		  /* 82092B34h */ case    3:  		/* lis R10, -32255 */
		/* 82092B34h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 82092B34h case    3:*/		return 0x82092B38;
		  /* 82092B38h */ case    4:  		/* lfd FR13, <#[R11 + 1848]> */
		/* 82092B38h case    4:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000738) );
		/* 82092B38h case    4:*/		return 0x82092B3C;
		  /* 82092B3Ch */ case    5:  		/* lfd FR0, <#[R10 - 24848]> */
		/* 82092B3Ch case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0xFFFF9EF0) );
		/* 82092B3Ch case    5:*/		return 0x82092B40;
		  /* 82092B40h */ case    6:  		/* fcfid FR12, FR12 */
		/* 82092B40h case    6:*/		cpu::op::fcfid<0>(regs,&regs.FR12,regs.FR12);
		/* 82092B40h case    6:*/		return 0x82092B44;
		  /* 82092B44h */ case    7:  		/* fsub FR0, FR0, FR11 */
		/* 82092B44h case    7:*/		cpu::op::fsub<0>(regs,&regs.FR0,regs.FR0,regs.FR11);
		/* 82092B44h case    7:*/		return 0x82092B48;
		  /* 82092B48h */ case    8:  		/* fneg FR11, FR11 */
		/* 82092B48h case    8:*/		cpu::op::fneg<0>(regs,&regs.FR11,regs.FR11);
		/* 82092B48h case    8:*/		return 0x82092B4C;
		  /* 82092B4Ch */ case    9:  		/* fsub FR10, FR12, FR1 */
		/* 82092B4Ch case    9:*/		cpu::op::fsub<0>(regs,&regs.FR10,regs.FR12,regs.FR1);
		/* 82092B4Ch case    9:*/		return 0x82092B50;
		  /* 82092B50h */ case   10:  		/* fadd FR13, FR12, FR13 */
		/* 82092B50h case   10:*/		cpu::op::fadd<0>(regs,&regs.FR13,regs.FR12,regs.FR13);
		/* 82092B50h case   10:*/		return 0x82092B54;
		  /* 82092B54h */ case   11:  		/* fsel FR13, FR10, FR12, FR13 */
		/* 82092B54h case   11:*/		cpu::op::fsel<0>(regs,&regs.FR13,regs.FR10,regs.FR12,regs.FR13);
		/* 82092B54h case   11:*/		return 0x82092B58;
		  /* 82092B58h */ case   12:  		/* fsel FR0, FR0, FR13, FR1 */
		/* 82092B58h case   12:*/		cpu::op::fsel<0>(regs,&regs.FR0,regs.FR0,regs.FR13,regs.FR1);
		/* 82092B58h case   12:*/		return 0x82092B5C;
		  /* 82092B5Ch */ case   13:  		/* fsel FR1, FR11, FR1, FR0 */
		/* 82092B5Ch case   13:*/		cpu::op::fsel<0>(regs,&regs.FR1,regs.FR11,regs.FR1,regs.FR0);
		/* 82092B5Ch case   13:*/		return 0x82092B60;
		  /* 82092B60h */ case   14:  		/* bclr 20, CR0_LT */
		/* 82092B60h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82092B60h case   14:*/		return 0x82092B64;
	}
	return 0x82092B64;
} // Block from 82092B28h-82092B64h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82092B64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092B64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092B64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092B64);
		  /* 82092B64h */ case    0:  		/* nop */
		/* 82092B64h case    0:*/		cpu::op::nop();
		/* 82092B64h case    0:*/		return 0x82092B68;
	}
	return 0x82092B68;
} // Block from 82092B64h-82092B68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82092B68h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092B68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092B68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092B68);
		  /* 82092B68h */ case    0:  		/* li R5, 10 */
		/* 82092B68h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0xA);
		/* 82092B68h case    0:*/		return 0x82092B6C;
		  /* 82092B6Ch */ case    1:  		/* li R4, 0 */
		/* 82092B6Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82092B6Ch case    1:*/		return 0x82092B70;
		  /* 82092B70h */ case    2:  		/* b 22648 */
		/* 82092B70h case    2:*/		return 0x820983E8;
		/* 82092B70h case    2:*/		return 0x82092B74;
		  /* 82092B74h */ case    3:  		/* nop */
		/* 82092B74h case    3:*/		cpu::op::nop();
		/* 82092B74h case    3:*/		return 0x82092B78;
	}
	return 0x82092B78;
} // Block from 82092B68h-82092B78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82092B78h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092B78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092B78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092B78);
		  /* 82092B78h */ case    0:  		/* mfspr R12, LR */
		/* 82092B78h case    0:*/		regs.R12 = regs.LR;
		/* 82092B78h case    0:*/		return 0x82092B7C;
		  /* 82092B7Ch */ case    1:  		/* bl -6432 */
		/* 82092B7Ch case    1:*/		regs.LR = 0x82092B80; return 0x8209125C;
		/* 82092B7Ch case    1:*/		return 0x82092B80;
		  /* 82092B80h */ case    2:  		/* stfd FR30, <#[R1 - 48]> */
		/* 82092B80h case    2:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFFD0) );
		/* 82092B80h case    2:*/		return 0x82092B84;
		  /* 82092B84h */ case    3:  		/* stfd FR31, <#[R1 - 40]> */
		/* 82092B84h case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFD8) );
		/* 82092B84h case    3:*/		return 0x82092B88;
		  /* 82092B88h */ case    4:  		/* stwu R1, <#[R1 - 144]> */
		/* 82092B88h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82092B88h case    4:*/		return 0x82092B8C;
		  /* 82092B8Ch */ case    5:  		/* lis R11, -16377 */
		/* 82092B8Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC007);
		/* 82092B8Ch case    5:*/		return 0x82092B90;
		  /* 82092B90h */ case    6:  		/* stfd FR1, <#[R1 + 160]> */
		/* 82092B90h case    6:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x000000A0) );
		/* 82092B90h case    6:*/		return 0x82092B94;
		  /* 82092B94h */ case    7:  		/* mr R31, R4 */
		/* 82092B94h case    7:*/		regs.R31 = regs.R4;
		/* 82092B94h case    7:*/		return 0x82092B98;
		  /* 82092B98h */ case    8:  		/* fmr FR31, FR1 */
		/* 82092B98h case    8:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 82092B98h case    8:*/		return 0x82092B9C;
		  /* 82092B9Ch */ case    9:  		/* ori R29, R11, 65279 */
		/* 82092B9Ch case    9:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R11,0xFEFF);
		/* 82092B9Ch case    9:*/		return 0x82092BA0;
		  /* 82092BA0h */ case   10:  		/* li R3, 248 */
		/* 82092BA0h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0xF8);
		/* 82092BA0h case   10:*/		return 0x82092BA4;
		  /* 82092BA4h */ case   11:  		/* mr R4, R29 */
		/* 82092BA4h case   11:*/		regs.R4 = regs.R29;
		/* 82092BA4h case   11:*/		return 0x82092BA8;
		  /* 82092BA8h */ case   12:  		/* bl 25368 */
		/* 82092BA8h case   12:*/		regs.LR = 0x82092BAC; return 0x82098EC0;
		/* 82092BA8h case   12:*/		return 0x82092BAC;
		  /* 82092BACh */ case   13:  		/* lhz R11, <#[R1 + 160]> */
		/* 82092BACh case   13:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000A0) );
		/* 82092BACh case   13:*/		return 0x82092BB0;
		  /* 82092BB0h */ case   14:  		/* mr R30, R3 */
		/* 82092BB0h case   14:*/		regs.R30 = regs.R3;
		/* 82092BB0h case   14:*/		return 0x82092BB4;
		  /* 82092BB4h */ case   15:  		/* rlwinm R11, R11, 0, 17, 27 */
		/* 82092BB4h case   15:*/		cpu::op::rlwinm<0,0,17,27>(regs,&regs.R11,regs.R11);
		/* 82092BB4h case   15:*/		return 0x82092BB8;
		  /* 82092BB8h */ case   16:  		/* cmplwi CR6, R11, 32752 */
		/* 82092BB8h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00007FF0);
		/* 82092BB8h case   16:*/		return 0x82092BBC;
		  /* 82092BBCh */ case   17:  		/* bc 4, CR6_EQ, 124 */
		/* 82092BBCh case   17:*/		if ( !regs.CR[6].eq ) { return 0x82092C38;  }
		/* 82092BBCh case   17:*/		return 0x82092BC0;
		  /* 82092BC0h */ case   18:  		/* fmr FR1, FR31 */
		/* 82092BC0h case   18:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82092BC0h case   18:*/		return 0x82092BC4;
		  /* 82092BC4h */ case   19:  		/* bl 7740 */
		/* 82092BC4h case   19:*/		regs.LR = 0x82092BC8; return 0x82094A00;
		/* 82092BC4h case   19:*/		return 0x82092BC8;
		  /* 82092BC8h */ case   20:  		/* cmpwi CR0, R3, 0 */
		/* 82092BC8h case   20:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82092BC8h case   20:*/		return 0x82092BCC;
		  /* 82092BCCh */ case   21:  		/* bc 4, CR0_GT, 56 */
		/* 82092BCCh case   21:*/		if ( !regs.CR[0].gt ) { return 0x82092C04;  }
		/* 82092BCCh case   21:*/		return 0x82092BD0;
		  /* 82092BD0h */ case   22:  		/* cmpwi CR6, R3, 2 */
		/* 82092BD0h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 82092BD0h case   22:*/		return 0x82092BD4;
		  /* 82092BD4h */ case   23:  		/* bc 4, CR6_GT, 344 */
		/* 82092BD4h case   23:*/		if ( !regs.CR[6].gt ) { return 0x82092D2C;  }
		/* 82092BD4h case   23:*/		return 0x82092BD8;
		  /* 82092BD8h */ case   24:  		/* cmpwi CR6, R3, 3 */
		/* 82092BD8h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000003);
		/* 82092BD8h case   24:*/		return 0x82092BDC;
		  /* 82092BDCh */ case   25:  		/* bc 4, CR6_EQ, 40 */
		/* 82092BDCh case   25:*/		if ( !regs.CR[6].eq ) { return 0x82092C04;  }
		/* 82092BDCh case   25:*/		return 0x82092BE0;
		  /* 82092BE0h */ case   26:  		/* extsw R11, R31 */
		/* 82092BE0h case   26:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R31);
		/* 82092BE0h case   26:*/		return 0x82092BE4;
		  /* 82092BE4h */ case   27:  		/* fmr FR1, FR31 */
		/* 82092BE4h case   27:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82092BE4h case   27:*/		return 0x82092BE8;
		  /* 82092BE8h */ case   28:  		/* mr R6, R30 */
		/* 82092BE8h case   28:*/		regs.R6 = regs.R30;
		/* 82092BE8h case   28:*/		return 0x82092BEC;
		  /* 82092BECh */ case   29:  		/* std R11, <#[R1 + 88]> */
		/* 82092BECh case   29:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82092BECh case   29:*/		return 0x82092BF0;
		  /* 82092BF0h */ case   30:  		/* li R3, 25 */
		/* 82092BF0h case   30:*/		cpu::op::li<0>(regs,&regs.R3,0x19);
		/* 82092BF0h case   30:*/		return 0x82092BF4;
		  /* 82092BF4h */ case   31:  		/* lfd FR0, <#[R1 + 88]> */
		/* 82092BF4h case   31:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82092BF4h case   31:*/		return 0x82092BF8;
		  /* 82092BF8h */ case   32:  		/* fcfid FR2, FR0 */
		/* 82092BF8h case   32:*/		cpu::op::fcfid<0>(regs,&regs.FR2,regs.FR0);
		/* 82092BF8h case   32:*/		return 0x82092BFC;
		  /* 82092BFCh */ case   33:  		/* bl 24700 */
		/* 82092BFCh case   33:*/		regs.LR = 0x82092C00; return 0x82098C78;
		/* 82092BFCh case   33:*/		return 0x82092C00;
		  /* 82092C00h */ case   34:  		/* b 316 */
		/* 82092C00h case   34:*/		return 0x82092D3C;
		/* 82092C00h case   34:*/		return 0x82092C04;
	}
	return 0x82092C04;
} // Block from 82092B78h-82092C04h (35 instructions)

//////////////////////////////////////////////////////
// Block at 82092C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092C04);
		  /* 82092C04h */ case    0:  		/* lis R11, -32256 */
		/* 82092C04h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82092C04h case    0:*/		return 0x82092C08;
		  /* 82092C08h */ case    1:  		/* extsw R10, R31 */
		/* 82092C08h case    1:*/		cpu::op::extsw<0>(regs,&regs.R10,regs.R31);
		/* 82092C08h case    1:*/		return 0x82092C0C;
		  /* 82092C0Ch */ case    2:  		/* li R3, 8 */
		/* 82092C0Ch case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x8);
		/* 82092C0Ch case    2:*/		return 0x82092C10;
		  /* 82092C10h */ case    3:  		/* std R10, <#[R1 + 88]> */
		/* 82092C10h case    3:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82092C10h case    3:*/		return 0x82092C14;
		  /* 82092C14h */ case    4:  		/* lfd FR13, <#[R1 + 88]> */
		/* 82092C14h case    4:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 82092C14h case    4:*/		return 0x82092C18;
		  /* 82092C18h */ case    5:  		/* fcfid FR2, FR13 */
		/* 82092C18h case    5:*/		cpu::op::fcfid<0>(regs,&regs.FR2,regs.FR13);
		/* 82092C18h case    5:*/		return 0x82092C1C;
		  /* 82092C1Ch */ case    6:  		/* lfd FR0, <#[R11 + 1848]> */
		/* 82092C1Ch case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000738) );
		/* 82092C1Ch case    6:*/		return 0x82092C20;
		  /* 82092C20h */ case    7:  		/* fadd FR3, FR31, FR0 */
		/* 82092C20h case    7:*/		cpu::op::fadd<0>(regs,&regs.FR3,regs.FR31,regs.FR0);
		/* 82092C20h case    7:*/		return 0x82092C24;
		  /* 82092C24h */ case    8:  		/* li R4, 25 */
		/* 82092C24h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x19);
		/* 82092C24h case    8:*/		return 0x82092C28;
		  /* 82092C28h */ case    9:  		/* fmr FR1, FR31 */
		/* 82092C28h case    9:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82092C28h case    9:*/		return 0x82092C2C;
		  /* 82092C2Ch */ case   10:  		/* mr R8, R30 */
		/* 82092C2Ch case   10:*/		regs.R8 = regs.R30;
		/* 82092C2Ch case   10:*/		return 0x82092C30;
		  /* 82092C30h */ case   11:  		/* bl 24992 */
		/* 82092C30h case   11:*/		regs.LR = 0x82092C34; return 0x82098DD0;
		/* 82092C30h case   11:*/		return 0x82092C34;
		  /* 82092C34h */ case   12:  		/* b 264 */
		/* 82092C34h case   12:*/		return 0x82092D3C;
		/* 82092C34h case   12:*/		return 0x82092C38;
	}
	return 0x82092C38;
} // Block from 82092C04h-82092C38h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82092C38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092C38);
		  /* 82092C38h */ case    0:  		/* lis R11, -32256 */
		/* 82092C38h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82092C38h case    0:*/		return 0x82092C3C;
		  /* 82092C3Ch */ case    1:  		/* lfd FR30, <#[R11 + 1808]> */
		/* 82092C3Ch case    1:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R11 + 0x00000710) );
		/* 82092C3Ch case    1:*/		return 0x82092C40;
		  /* 82092C40h */ case    2:  		/* fcmpu CR6, FR31, FR30 */
		/* 82092C40h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR30);
		/* 82092C40h case    2:*/		return 0x82092C44;
		  /* 82092C44h */ case    3:  		/* bc 12, CR6_EQ, 232 */
		/* 82092C44h case    3:*/		if ( regs.CR[6].eq ) { return 0x82092D2C;  }
		/* 82092C44h case    3:*/		return 0x82092C48;
		  /* 82092C48h */ case    4:  		/* addi R4, R1, 80 */
		/* 82092C48h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82092C48h case    4:*/		return 0x82092C4C;
		  /* 82092C4Ch */ case    5:  		/* fmr FR1, FR31 */
		/* 82092C4Ch case    5:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82092C4Ch case    5:*/		return 0x82092C50;
		  /* 82092C50h */ case    6:  		/* bl 7736 */
		/* 82092C50h case    6:*/		regs.LR = 0x82092C54; return 0x82094A88;
		/* 82092C50h case    6:*/		return 0x82092C54;
		  /* 82092C54h */ case    7:  		/* lwz R11, <#[R1 + 80]> */
		/* 82092C54h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82092C54h case    7:*/		return 0x82092C58;
		  /* 82092C58h */ case    8:  		/* cmpwi CR6, R31, 0 */
		/* 82092C58h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82092C58h case    8:*/		return 0x82092C5C;
		  /* 82092C5Ch */ case    9:  		/* bc 4, CR6_LT, 24 */
		/* 82092C5Ch case    9:*/		if ( !regs.CR[6].lt ) { return 0x82092C74;  }
		/* 82092C5Ch case    9:*/		return 0x82092C60;
		  /* 82092C60h */ case   10:  		/* lis R10, -32768 */
		/* 82092C60h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8000);
		/* 82092C60h case   10:*/		return 0x82092C64;
		  /* 82092C64h */ case   11:  		/* subf R10, R31, R10 */
		/* 82092C64h case   11:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R31,regs.R10);
		/* 82092C64h case   11:*/		return 0x82092C68;
		  /* 82092C68h */ case   12:  		/* cmpw CR6, R11, R10 */
		/* 82092C68h case   12:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82092C68h case   12:*/		return 0x82092C6C;
		  /* 82092C6Ch */ case   13:  		/* bc 12, CR6_LT, 124 */
		/* 82092C6Ch case   13:*/		if ( regs.CR[6].lt ) { return 0x82092CE8;  }
		/* 82092C6Ch case   13:*/		return 0x82092C70;
		  /* 82092C70h */ case   14:  		/* b 24 */
		/* 82092C70h case   14:*/		return 0x82092C88;
		/* 82092C70h case   14:*/		return 0x82092C74;
	}
	return 0x82092C74;
} // Block from 82092C38h-82092C74h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82092C74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092C74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092C74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092C74);
		  /* 82092C74h */ case    0:  		/* lis R10, 32767 */
		/* 82092C74h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x7FFF);
		/* 82092C74h case    0:*/		return 0x82092C78;
		  /* 82092C78h */ case    1:  		/* ori R10, R10, 65535 */
		/* 82092C78h case    1:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0xFFFF);
		/* 82092C78h case    1:*/		return 0x82092C7C;
		  /* 82092C7Ch */ case    2:  		/* subf R10, R31, R10 */
		/* 82092C7Ch case    2:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R31,regs.R10);
		/* 82092C7Ch case    2:*/		return 0x82092C80;
		  /* 82092C80h */ case    3:  		/* cmpw CR6, R11, R10 */
		/* 82092C80h case    3:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82092C80h case    3:*/		return 0x82092C84;
		  /* 82092C84h */ case    4:  		/* bc 12, CR6_GT, 16 */
		/* 82092C84h case    4:*/		if ( regs.CR[6].gt ) { return 0x82092C94;  }
		/* 82092C84h case    4:*/		return 0x82092C88;
	}
	return 0x82092C88;
} // Block from 82092C74h-82092C88h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82092C88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092C88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092C88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092C88);
		  /* 82092C88h */ case    0:  		/* add R4, R11, R31 */
		/* 82092C88h case    0:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R31);
		/* 82092C88h case    0:*/		return 0x82092C8C;
		  /* 82092C8Ch */ case    1:  		/* cmpwi CR6, R4, 2560 */
		/* 82092C8Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000A00);
		/* 82092C8Ch case    1:*/		return 0x82092C90;
		  /* 82092C90h */ case    2:  		/* bc 4, CR6_GT, 48 */
		/* 82092C90h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82092CC0;  }
		/* 82092C90h case    2:*/		return 0x82092C94;
	}
	return 0x82092C94;
} // Block from 82092C88h-82092C94h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82092C94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092C94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092C94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092C94);
		  /* 82092C94h */ case    0:  		/* lis R11, -32217 */
		/* 82092C94h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82092C94h case    0:*/		return 0x82092C98;
		  /* 82092C98h */ case    1:  		/* fmr FR2, FR1 */
		/* 82092C98h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR1);
		/* 82092C98h case    1:*/		return 0x82092C9C;
		  /* 82092C9Ch */ case    2:  		/* lfd FR1, <#[R11 + 7328]> */
		/* 82092C9Ch case    2:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00001CA0) );
		/* 82092C9Ch case    2:*/		return 0x82092CA0;
		  /* 82092CA0h */ case    3:  		/* bl 21192 */
		/* 82092CA0h case    3:*/		regs.LR = 0x82092CA4; return 0x82097F68;
		/* 82092CA0h case    3:*/		return 0x82092CA4;
		  /* 82092CA4h */ case    4:  		/* extsw R11, R31 */
		/* 82092CA4h case    4:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R31);
		/* 82092CA4h case    4:*/		return 0x82092CA8;
		  /* 82092CA8h */ case    5:  		/* std R11, <#[R1 + 88]> */
		/* 82092CA8h case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82092CA8h case    5:*/		return 0x82092CAC;
		  /* 82092CACh */ case    6:  		/* lfd FR0, <#[R1 + 88]> */
		/* 82092CACh case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82092CACh case    6:*/		return 0x82092CB0;
		  /* 82092CB0h */ case    7:  		/* li R3, 17 */
		/* 82092CB0h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x11);
		/* 82092CB0h case    7:*/		return 0x82092CB4;
		  /* 82092CB4h */ case    8:  		/* fmr FR3, FR1 */
		/* 82092CB4h case    8:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR1);
		/* 82092CB4h case    8:*/		return 0x82092CB8;
		  /* 82092CB8h */ case    9:  		/* fcfid FR2, FR0 */
		/* 82092CB8h case    9:*/		cpu::op::fcfid<0>(regs,&regs.FR2,regs.FR0);
		/* 82092CB8h case    9:*/		return 0x82092CBC;
		  /* 82092CBCh */ case   10:  		/* b -152 */
		/* 82092CBCh case   10:*/		return 0x82092C24;
		/* 82092CBCh case   10:*/		return 0x82092CC0;
	}
	return 0x82092CC0;
} // Block from 82092C94h-82092CC0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82092CC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092CC0);
		  /* 82092CC0h */ case    0:  		/* cmpwi CR6, R4, 1024 */
		/* 82092CC0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000400);
		/* 82092CC0h case    0:*/		return 0x82092CC4;
		  /* 82092CC4h */ case    1:  		/* bc 4, CR6_GT, 28 */
		/* 82092CC4h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82092CE0;  }
		/* 82092CC4h case    1:*/		return 0x82092CC8;
		  /* 82092CC8h */ case    2:  		/* addi R4, R4, -1536 */
		/* 82092CC8h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFA00);
		/* 82092CC8h case    2:*/		return 0x82092CCC;
		  /* 82092CCCh */ case    3:  		/* bl 7356 */
		/* 82092CCCh case    3:*/		regs.LR = 0x82092CD0; return 0x82094988;
		/* 82092CCCh case    3:*/		return 0x82092CD0;
		  /* 82092CD0h */ case    4:  		/* extsw R11, R31 */
		/* 82092CD0h case    4:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R31);
		/* 82092CD0h case    4:*/		return 0x82092CD4;
		  /* 82092CD4h */ case    5:  		/* std R11, <#[R1 + 88]> */
		/* 82092CD4h case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82092CD4h case    5:*/		return 0x82092CD8;
		  /* 82092CD8h */ case    6:  		/* lfd FR0, <#[R1 + 88]> */
		/* 82092CD8h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82092CD8h case    6:*/		return 0x82092CDC;
		  /* 82092CDCh */ case    7:  		/* b -44 */
		/* 82092CDCh case    7:*/		return 0x82092CB0;
		/* 82092CDCh case    7:*/		return 0x82092CE0;
	}
	return 0x82092CE0;
} // Block from 82092CC0h-82092CE0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82092CE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092CE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092CE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092CE0);
		  /* 82092CE0h */ case    0:  		/* cmpwi CR6, R4, -2557 */
		/* 82092CE0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFF603);
		/* 82092CE0h case    0:*/		return 0x82092CE4;
		  /* 82092CE4h */ case    1:  		/* bc 4, CR6_LT, 28 */
		/* 82092CE4h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82092D00;  }
		/* 82092CE4h case    1:*/		return 0x82092CE8;
	}
	return 0x82092CE8;
} // Block from 82092CE0h-82092CE8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82092CE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092CE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092CE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092CE8);
		  /* 82092CE8h */ case    0:  		/* extsw R11, R31 */
		/* 82092CE8h case    0:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R31);
		/* 82092CE8h case    0:*/		return 0x82092CEC;
		  /* 82092CECh */ case    1:  		/* fmul FR3, FR1, FR30 */
		/* 82092CECh case    1:*/		cpu::op::fmul<0>(regs,&regs.FR3,regs.FR1,regs.FR30);
		/* 82092CECh case    1:*/		return 0x82092CF0;
		  /* 82092CF0h */ case    2:  		/* li R3, 18 */
		/* 82092CF0h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x12);
		/* 82092CF0h case    2:*/		return 0x82092CF4;
		  /* 82092CF4h */ case    3:  		/* std R11, <#[R1 + 88]> */
		/* 82092CF4h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82092CF4h case    3:*/		return 0x82092CF8;
		  /* 82092CF8h */ case    4:  		/* lfd FR0, <#[R1 + 88]> */
		/* 82092CF8h case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82092CF8h case    4:*/		return 0x82092CFC;
		  /* 82092CFCh */ case    5:  		/* b -68 */
		/* 82092CFCh case    5:*/		return 0x82092CB8;
		/* 82092CFCh case    5:*/		return 0x82092D00;
	}
	return 0x82092D00;
} // Block from 82092CE8h-82092D00h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82092D00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092D00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092D00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092D00);
		  /* 82092D00h */ case    0:  		/* cmpwi CR6, R4, -1021 */
		/* 82092D00h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFC03);
		/* 82092D00h case    0:*/		return 0x82092D04;
		  /* 82092D04h */ case    1:  		/* bc 4, CR6_LT, 32 */
		/* 82092D04h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82092D24;  }
		/* 82092D04h case    1:*/		return 0x82092D08;
		  /* 82092D08h */ case    2:  		/* addi R4, R4, 1536 */
		/* 82092D08h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x600);
		/* 82092D08h case    2:*/		return 0x82092D0C;
		  /* 82092D0Ch */ case    3:  		/* bl 7292 */
		/* 82092D0Ch case    3:*/		regs.LR = 0x82092D10; return 0x82094988;
		/* 82092D0Ch case    3:*/		return 0x82092D10;
		  /* 82092D10h */ case    4:  		/* extsw R11, R31 */
		/* 82092D10h case    4:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R31);
		/* 82092D10h case    4:*/		return 0x82092D14;
		  /* 82092D14h */ case    5:  		/* li R3, 18 */
		/* 82092D14h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x12);
		/* 82092D14h case    5:*/		return 0x82092D18;
		  /* 82092D18h */ case    6:  		/* std R11, <#[R1 + 88]> */
		/* 82092D18h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82092D18h case    6:*/		return 0x82092D1C;
		  /* 82092D1Ch */ case    7:  		/* lfd FR0, <#[R1 + 88]> */
		/* 82092D1Ch case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82092D1Ch case    7:*/		return 0x82092D20;
		  /* 82092D20h */ case    8:  		/* b -108 */
		/* 82092D20h case    8:*/		return 0x82092CB4;
		/* 82092D20h case    8:*/		return 0x82092D24;
	}
	return 0x82092D24;
} // Block from 82092D00h-82092D24h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82092D24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092D24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092D24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092D24);
		  /* 82092D24h */ case    0:  		/* bl 7268 */
		/* 82092D24h case    0:*/		regs.LR = 0x82092D28; return 0x82094988;
		/* 82092D24h case    0:*/		return 0x82092D28;
		  /* 82092D28h */ case    1:  		/* fmr FR31, FR1 */
		/* 82092D28h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 82092D28h case    1:*/		return 0x82092D2C;
	}
	return 0x82092D2C;
} // Block from 82092D24h-82092D2Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82092D2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092D2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092D2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092D2C);
		  /* 82092D2Ch */ case    0:  		/* mr R4, R29 */
		/* 82092D2Ch case    0:*/		regs.R4 = regs.R29;
		/* 82092D2Ch case    0:*/		return 0x82092D30;
		  /* 82092D30h */ case    1:  		/* mr R3, R30 */
		/* 82092D30h case    1:*/		regs.R3 = regs.R30;
		/* 82092D30h case    1:*/		return 0x82092D34;
		  /* 82092D34h */ case    2:  		/* bl 24972 */
		/* 82092D34h case    2:*/		regs.LR = 0x82092D38; return 0x82098EC0;
		/* 82092D34h case    2:*/		return 0x82092D38;
		  /* 82092D38h */ case    3:  		/* fmr FR1, FR31 */
		/* 82092D38h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82092D38h case    3:*/		return 0x82092D3C;
	}
	return 0x82092D3C;
} // Block from 82092D2Ch-82092D3Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82092D3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092D3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092D3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092D3C);
		  /* 82092D3Ch */ case    0:  		/* addi R1, R1, 144 */
		/* 82092D3Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82092D3Ch case    0:*/		return 0x82092D40;
		  /* 82092D40h */ case    1:  		/* lfd FR30, <#[R1 - 48]> */
		/* 82092D40h case    1:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFFD0) );
		/* 82092D40h case    1:*/		return 0x82092D44;
		  /* 82092D44h */ case    2:  		/* lfd FR31, <#[R1 - 40]> */
		/* 82092D44h case    2:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFD8) );
		/* 82092D44h case    2:*/		return 0x82092D48;
		  /* 82092D48h */ case    3:  		/* b -6812 */
		/* 82092D48h case    3:*/		return 0x820912AC;
		/* 82092D48h case    3:*/		return 0x82092D4C;
		  /* 82092D4Ch */ case    4:  		/* nop */
		/* 82092D4Ch case    4:*/		cpu::op::nop();
		/* 82092D4Ch case    4:*/		return 0x82092D50;
		  /* 82092D50h */ case    5:  		/* li R3, 0 */
		/* 82092D50h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82092D50h case    5:*/		return 0x82092D54;
		  /* 82092D54h */ case    6:  		/* b 1942708 */
		/* 82092D54h case    6:*/		return 0x8226D208;
		/* 82092D54h case    6:*/		return 0x82092D58;
		  /* 82092D58h */ case    7:  		/* li R3, 8 */
		/* 82092D58h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x8);
		/* 82092D58h case    7:*/		return 0x82092D5C;
		  /* 82092D5Ch */ case    8:  		/* b 25852 */
		/* 82092D5Ch case    8:*/		return 0x82099258;
		/* 82092D5Ch case    8:*/		return 0x82092D60;
		  /* 82092D60h */ case    9:  		/* li R3, 8 */
		/* 82092D60h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x8);
		/* 82092D60h case    9:*/		return 0x82092D64;
		  /* 82092D64h */ case   10:  		/* b 25204 */
		/* 82092D64h case   10:*/		return 0x82098FD8;
		/* 82092D64h case   10:*/		return 0x82092D68;
	}
	return 0x82092D68;
} // Block from 82092D3Ch-82092D68h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82092D68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092D68);
		  /* 82092D68h */ case    0:  		/* mfspr R12, LR */
		/* 82092D68h case    0:*/		regs.R12 = regs.LR;
		/* 82092D68h case    0:*/		return 0x82092D6C;
		  /* 82092D6Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82092D6Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82092D6Ch case    1:*/		return 0x82092D70;
		  /* 82092D70h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82092D70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82092D70h case    2:*/		return 0x82092D74;
		  /* 82092D74h */ case    3:  		/* li R3, 0 */
		/* 82092D74h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82092D74h case    3:*/		return 0x82092D78;
		  /* 82092D78h */ case    4:  		/* bl 26040 */
		/* 82092D78h case    4:*/		regs.LR = 0x82092D7C; return 0x82099330;
		/* 82092D78h case    4:*/		return 0x82092D7C;
		  /* 82092D7Ch */ case    5:  		/* li R3, 0 */
		/* 82092D7Ch case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82092D7Ch case    5:*/		return 0x82092D80;
		  /* 82092D80h */ case    6:  		/* bl 3024 */
		/* 82092D80h case    6:*/		regs.LR = 0x82092D84; return 0x82093950;
		/* 82092D80h case    6:*/		return 0x82092D84;
		  /* 82092D84h */ case    7:  		/* li R3, 0 */
		/* 82092D84h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82092D84h case    7:*/		return 0x82092D88;
		  /* 82092D88h */ case    8:  		/* bl 7976 */
		/* 82092D88h case    8:*/		regs.LR = 0x82092D8C; return 0x82094CB0;
		/* 82092D88h case    8:*/		return 0x82092D8C;
		  /* 82092D8Ch */ case    9:  		/* li R3, 0 */
		/* 82092D8Ch case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82092D8Ch case    9:*/		return 0x82092D90;
		  /* 82092D90h */ case   10:  		/* bl 25992 */
		/* 82092D90h case   10:*/		regs.LR = 0x82092D94; return 0x82099318;
		/* 82092D90h case   10:*/		return 0x82092D94;
		  /* 82092D94h */ case   11:  		/* addi R1, R1, 96 */
		/* 82092D94h case   11:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82092D94h case   11:*/		return 0x82092D98;
		  /* 82092D98h */ case   12:  		/* lwz R12, <#[R1 - 8]> */
		/* 82092D98h case   12:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82092D98h case   12:*/		return 0x82092D9C;
		  /* 82092D9Ch */ case   13:  		/* mtspr LR, R12 */
		/* 82092D9Ch case   13:*/		regs.LR = regs.R12;
		/* 82092D9Ch case   13:*/		return 0x82092DA0;
		  /* 82092DA0h */ case   14:  		/* bclr 20, CR0_LT */
		/* 82092DA0h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82092DA0h case   14:*/		return 0x82092DA4;
	}
	return 0x82092DA4;
} // Block from 82092D68h-82092DA4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82092DA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092DA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092DA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092DA4);
		  /* 82092DA4h */ case    0:  		/* nop */
		/* 82092DA4h case    0:*/		cpu::op::nop();
		/* 82092DA4h case    0:*/		return 0x82092DA8;
	}
	return 0x82092DA8;
} // Block from 82092DA4h-82092DA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82092DA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092DA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092DA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092DA8);
		  /* 82092DA8h */ case    0:  		/* mfspr R12, LR */
		/* 82092DA8h case    0:*/		regs.R12 = regs.LR;
		/* 82092DA8h case    0:*/		return 0x82092DAC;
		  /* 82092DACh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82092DACh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82092DACh case    1:*/		return 0x82092DB0;
		  /* 82092DB0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82092DB0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82092DB0h case    2:*/		return 0x82092DB4;
		  /* 82092DB4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82092DB4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82092DB4h case    3:*/		return 0x82092DB8;
		  /* 82092DB8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82092DB8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82092DB8h case    4:*/		return 0x82092DBC;
		  /* 82092DBCh */ case    5:  		/* mr R31, R3 */
		/* 82092DBCh case    5:*/		regs.R31 = regs.R3;
		/* 82092DBCh case    5:*/		return 0x82092DC0;
	}
	return 0x82092DC0;
} // Block from 82092DA8h-82092DC0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82092DC0h
// Function 'ldexp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092DC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092DC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092DC0);
		  /* 82092DC0h */ case    0:  		/* mr R30, R4 */
		/* 82092DC0h case    0:*/		regs.R30 = regs.R4;
		/* 82092DC0h case    0:*/		return 0x82092DC4;
		  /* 82092DC4h */ case    1:  		/* b 28 */
		/* 82092DC4h case    1:*/		return 0x82092DE0;
		/* 82092DC4h case    1:*/		return 0x82092DC8;
		  /* 82092DC8h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 82092DC8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82092DC8h case    2:*/		return 0x82092DCC;
		  /* 82092DCCh */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82092DCCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82092DCCh case    3:*/		return 0x82092DD0;
		  /* 82092DD0h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 82092DD0h case    4:*/		if ( regs.CR[6].eq ) { return 0x82092DDC;  }
		/* 82092DD0h case    4:*/		return 0x82092DD4;
		  /* 82092DD4h */ case    5:  		/* mtspr CTR, R11 */
		/* 82092DD4h case    5:*/		regs.CTR = regs.R11;
		/* 82092DD4h case    5:*/		return 0x82092DD8;
		  /* 82092DD8h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 82092DD8h case    6:*/		if ( 1 ) { regs.LR = 0x82092DDC; return (uint32)regs.CTR; }
		/* 82092DD8h case    6:*/		return 0x82092DDC;
	}
	return 0x82092DDC;
} // Block from 82092DC0h-82092DDCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 82092DDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092DDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092DDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092DDC);
		  /* 82092DDCh */ case    0:  		/* addi R31, R31, 4 */
		/* 82092DDCh case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82092DDCh case    0:*/		return 0x82092DE0;
	}
	return 0x82092DE0;
} // Block from 82092DDCh-82092DE0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82092DE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092DE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092DE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092DE0);
		  /* 82092DE0h */ case    0:  		/* cmplw CR6, R31, R30 */
		/* 82092DE0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 82092DE0h case    0:*/		return 0x82092DE4;
		  /* 82092DE4h */ case    1:  		/* bc 12, CR6_LT, -28 */
		/* 82092DE4h case    1:*/		if ( regs.CR[6].lt ) { return 0x82092DC8;  }
		/* 82092DE4h case    1:*/		return 0x82092DE8;
		  /* 82092DE8h */ case    2:  		/* addi R1, R1, 112 */
		/* 82092DE8h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82092DE8h case    2:*/		return 0x82092DEC;
		  /* 82092DECh */ case    3:  		/* lwz R12, <#[R1 - 8]> */
		/* 82092DECh case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82092DECh case    3:*/		return 0x82092DF0;
		  /* 82092DF0h */ case    4:  		/* mtspr LR, R12 */
		/* 82092DF0h case    4:*/		regs.LR = regs.R12;
		/* 82092DF0h case    4:*/		return 0x82092DF4;
		  /* 82092DF4h */ case    5:  		/* ld R30, <#[R1 - 24]> */
		/* 82092DF4h case    5:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82092DF4h case    5:*/		return 0x82092DF8;
		  /* 82092DF8h */ case    6:  		/* ld R31, <#[R1 - 16]> */
		/* 82092DF8h case    6:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82092DF8h case    6:*/		return 0x82092DFC;
		  /* 82092DFCh */ case    7:  		/* bclr 20, CR0_LT */
		/* 82092DFCh case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82092DFCh case    7:*/		return 0x82092E00;
	}
	return 0x82092E00;
} // Block from 82092DE0h-82092E00h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82092E00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092E00);
		  /* 82092E00h */ case    0:  		/* lwz R17, <#[R6 - 11576]> */
		/* 82092E00h case    0:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 82092E00h case    0:*/		return 0x82092E04;
		  /* 82092E04h */ case    1:  		/* lwz R16, <#[R4 - 15448]> */
		/* 82092E04h case    1:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC3A8) );
		/* 82092E04h case    1:*/		return 0x82092E08;
	}
	return 0x82092E08;
} // Block from 82092E00h-82092E08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82092E08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092E08);
		  /* 82092E08h */ case    0:  		/* mfspr R12, LR */
		/* 82092E08h case    0:*/		regs.R12 = regs.LR;
		/* 82092E08h case    0:*/		return 0x82092E0C;
		  /* 82092E0Ch */ case    1:  		/* bl -7108 */
		/* 82092E0Ch case    1:*/		regs.LR = 0x82092E10; return 0x82091248;
		/* 82092E0Ch case    1:*/		return 0x82092E10;
		  /* 82092E10h */ case    2:  		/* addi R31, R1, -176 */
		/* 82092E10h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFF50);
		/* 82092E10h case    2:*/		return 0x82092E14;
		  /* 82092E14h */ case    3:  		/* stwu R1, <#[R1 - 176]> */
		/* 82092E14h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82092E14h case    3:*/		return 0x82092E18;
		  /* 82092E18h */ case    4:  		/* mr R30, R3 */
		/* 82092E18h case    4:*/		regs.R30 = regs.R3;
		/* 82092E18h case    4:*/		return 0x82092E1C;
		  /* 82092E1Ch */ case    5:  		/* mr R24, R4 */
		/* 82092E1Ch case    5:*/		regs.R24 = regs.R4;
		/* 82092E1Ch case    5:*/		return 0x82092E20;
		  /* 82092E20h */ case    6:  		/* stw R4, <#[R31 + 204]> */
		/* 82092E20h case    6:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R31 + 0x000000CC) );
		/* 82092E20h case    6:*/		return 0x82092E24;
		  /* 82092E24h */ case    7:  		/* li R3, 8 */
		/* 82092E24h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x8);
		/* 82092E24h case    7:*/		return 0x82092E28;
		  /* 82092E28h */ case    8:  		/* bl 25648 */
		/* 82092E28h case    8:*/		regs.LR = 0x82092E2C; return 0x82099258;
		/* 82092E28h case    8:*/		return 0x82092E2C;
		  /* 82092E2Ch */ case    9:  		/* nop */
		/* 82092E2Ch case    9:*/		cpu::op::nop();
		/* 82092E2Ch case    9:*/		return 0x82092E30;
	}
	return 0x82092E30;
} // Block from 82092E08h-82092E30h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82092E30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092E30);
		  /* 82092E30h */ case    0:  		/* lis R11, -32215 */
		/* 82092E30h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82092E30h case    0:*/		return 0x82092E34;
		  /* 82092E34h */ case    1:  		/* lwz R11, <#[R11 - 30724]> */
		/* 82092E34h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFF87FC) );
		/* 82092E34h case    1:*/		return 0x82092E38;
		  /* 82092E38h */ case    2:  		/* cmpwi CR6, R11, 1 */
		/* 82092E38h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 82092E38h case    2:*/		return 0x82092E3C;
		  /* 82092E3Ch */ case    3:  		/* bc 12, CR6_EQ, 264 */
		/* 82092E3Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82092F44;  }
		/* 82092E3Ch case    3:*/		return 0x82092E40;
		  /* 82092E40h */ case    4:  		/* lis R9, -32215 */
		/* 82092E40h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8229);
		/* 82092E40h case    4:*/		return 0x82092E44;
		  /* 82092E44h */ case    5:  		/* lwz R11, <#[R9 - 30728]> */
		/* 82092E44h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0xFFFF87F8) );
		/* 82092E44h case    5:*/		return 0x82092E48;
		  /* 82092E48h */ case    6:  		/* cmpwi CR6, R11, 1 */
		/* 82092E48h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 82092E48h case    6:*/		return 0x82092E4C;
		  /* 82092E4Ch */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 82092E4Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x82092E58;  }
		/* 82092E4Ch case    7:*/		return 0x82092E50;
		  /* 82092E50h */ case    8:  		/* li R3, 0 */
		/* 82092E50h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82092E50h case    8:*/		return 0x82092E54;
		  /* 82092E54h */ case    9:  		/* bl 1942452 */
		/* 82092E54h case    9:*/		regs.LR = 0x82092E58; return 0x8226D208;
		/* 82092E54h case    9:*/		return 0x82092E58;
	}
	return 0x82092E58;
} // Block from 82092E30h-82092E58h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82092E58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092E58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092E58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092E58);
		  /* 82092E58h */ case    0:  		/* lis R8, -32215 */
		/* 82092E58h case    0:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8229);
		/* 82092E58h case    0:*/		return 0x82092E5C;
		  /* 82092E5Ch */ case    1:  		/* li R11, 1 */
		/* 82092E5Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82092E5Ch case    1:*/		return 0x82092E60;
		  /* 82092E60h */ case    2:  		/* stw R11, <#[R9 - 30728]> */
		/* 82092E60h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0xFFFF87F8) );
		/* 82092E60h case    2:*/		return 0x82092E64;
		  /* 82092E64h */ case    3:  		/* cmpwi CR6, R30, 0 */
		/* 82092E64h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82092E64h case    3:*/		return 0x82092E68;
		  /* 82092E68h */ case    4:  		/* stb R24, <#[R8 - 30732]> */
		/* 82092E68h case    4:*/		cpu::mem::store8( regs, regs.R24, (uint32)(regs.R8 + 0xFFFF87F4) );
		/* 82092E68h case    4:*/		return 0x82092E6C;
		  /* 82092E6Ch */ case    5:  		/* bc 4, CR6_EQ, 196 */
		/* 82092E6Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x82092F30;  }
		/* 82092E6Ch case    5:*/		return 0x82092E70;
		  /* 82092E70h */ case    6:  		/* lis R25, -32215 */
		/* 82092E70h case    6:*/		cpu::op::lis<0>(regs,&regs.R25,0xFFFF8229);
		/* 82092E70h case    6:*/		return 0x82092E74;
		  /* 82092E74h */ case    7:  		/* lwz R28, <#[R25 - 25240]> */
		/* 82092E74h case    7:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R25 + 0xFFFF9D68) );
		/* 82092E74h case    7:*/		return 0x82092E78;
		  /* 82092E78h */ case    8:  		/* stw R28, <#[R31 + 88]> */
		/* 82092E78h case    8:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000058) );
		/* 82092E78h case    8:*/		return 0x82092E7C;
		  /* 82092E7Ch */ case    9:  		/* cmplwi CR0, R28, 0 */
		/* 82092E7Ch case    9:*/		cpu::op::cmplwi<0>(regs,regs.R28,0x00000000);
		/* 82092E7Ch case    9:*/		return 0x82092E80;
		  /* 82092E80h */ case   10:  		/* bc 12, CR0_EQ, 156 */
		/* 82092E80h case   10:*/		if ( regs.CR[0].eq ) { return 0x82092F1C;  }
		/* 82092E80h case   10:*/		return 0x82092E84;
		  /* 82092E84h */ case   11:  		/* lis R27, -32215 */
		/* 82092E84h case   11:*/		cpu::op::lis<0>(regs,&regs.R27,0xFFFF8229);
		/* 82092E84h case   11:*/		return 0x82092E88;
		  /* 82092E88h */ case   12:  		/* mr R29, R28 */
		/* 82092E88h case   12:*/		regs.R29 = regs.R28;
		/* 82092E88h case   12:*/		return 0x82092E8C;
		  /* 82092E8Ch */ case   13:  		/* stw R28, <#[R31 + 84]> */
		/* 82092E8Ch case   13:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000054) );
		/* 82092E8Ch case   13:*/		return 0x82092E90;
		  /* 82092E90h */ case   14:  		/* lwz R30, <#[R27 - 25244]> */
		/* 82092E90h case   14:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0xFFFF9D64) );
		/* 82092E90h case   14:*/		return 0x82092E94;
		  /* 82092E94h */ case   15:  		/* mr R26, R30 */
		/* 82092E94h case   15:*/		regs.R26 = regs.R30;
		/* 82092E94h case   15:*/		return 0x82092E98;
		  /* 82092E98h */ case   16:  		/* stw R30, <#[R31 + 80]> */
		/* 82092E98h case   16:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000050) );
		/* 82092E98h case   16:*/		return 0x82092E9C;
		  /* 82092E9Ch */ case   17:  		/* stw R30, <#[R31 + 92]> */
		/* 82092E9Ch case   17:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000005C) );
		/* 82092E9Ch case   17:*/		return 0x82092EA0;
		  /* 82092EA0h */ case   18:  		/* addi R30, R30, -4 */
		/* 82092EA0h case   18:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0xFFFFFFFC);
		/* 82092EA0h case   18:*/		return 0x82092EA4;
		  /* 82092EA4h */ case   19:  		/* stw R30, <#[R31 + 80]> */
		/* 82092EA4h case   19:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000050) );
		/* 82092EA4h case   19:*/		return 0x82092EA8;
		  /* 82092EA8h */ case   20:  		/* cmplw CR6, R30, R28 */
		/* 82092EA8h case   20:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R28);
		/* 82092EA8h case   20:*/		return 0x82092EAC;
		  /* 82092EACh */ case   21:  		/* bc 12, CR6_LT, 112 */
		/* 82092EACh case   21:*/		if ( regs.CR[6].lt ) { return 0x82092F1C;  }
		/* 82092EACh case   21:*/		return 0x82092EB0;
		  /* 82092EB0h */ case   22:  		/* lwz R11, <#[R30]> */
		/* 82092EB0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82092EB0h case   22:*/		return 0x82092EB4;
		  /* 82092EB4h */ case   23:  		/* cmplwi CR6, R11, 0 */
		/* 82092EB4h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82092EB4h case   23:*/		return 0x82092EB8;
		  /* 82092EB8h */ case   24:  		/* bc 4, CR6_EQ, 12 */
		/* 82092EB8h case   24:*/		if ( !regs.CR[6].eq ) { return 0x82092EC4;  }
		/* 82092EB8h case   24:*/		return 0x82092EBC;
		  /* 82092EBCh */ case   25:  		/* nop */
		/* 82092EBCh case   25:*/		cpu::op::nop();
		/* 82092EBCh case   25:*/		return 0x82092EC0;
		  /* 82092EC0h */ case   26:  		/* b -32 */
		/* 82092EC0h case   26:*/		return 0x82092EA0;
		/* 82092EC0h case   26:*/		return 0x82092EC4;
	}
	return 0x82092EC4;
} // Block from 82092E58h-82092EC4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82092EC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092EC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092EC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092EC4);
		  /* 82092EC4h */ case    0:  		/* cmplw CR6, R30, R28 */
		/* 82092EC4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R28);
		/* 82092EC4h case    0:*/		return 0x82092EC8;
		  /* 82092EC8h */ case    1:  		/* bc 12, CR6_LT, 84 */
		/* 82092EC8h case    1:*/		if ( regs.CR[6].lt ) { return 0x82092F1C;  }
		/* 82092EC8h case    1:*/		return 0x82092ECC;
		  /* 82092ECCh */ case    2:  		/* li R11, 0 */
		/* 82092ECCh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82092ECCh case    2:*/		return 0x82092ED0;
		  /* 82092ED0h */ case    3:  		/* lwz R10, <#[R30]> */
		/* 82092ED0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82092ED0h case    3:*/		return 0x82092ED4;
		  /* 82092ED4h */ case    4:  		/* stw R11, <#[R30]> */
		/* 82092ED4h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82092ED4h case    4:*/		return 0x82092ED8;
		  /* 82092ED8h */ case    5:  		/* mtspr CTR, R10 */
		/* 82092ED8h case    5:*/		regs.CTR = regs.R10;
		/* 82092ED8h case    5:*/		return 0x82092EDC;
		  /* 82092EDCh */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 82092EDCh case    6:*/		if ( 1 ) { regs.LR = 0x82092EE0; return (uint32)regs.CTR; }
		/* 82092EDCh case    6:*/		return 0x82092EE0;
		  /* 82092EE0h */ case    7:  		/* lwz R11, <#[R25 - 25240]> */
		/* 82092EE0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0xFFFF9D68) );
		/* 82092EE0h case    7:*/		return 0x82092EE4;
		  /* 82092EE4h */ case    8:  		/* lwz R10, <#[R27 - 25244]> */
		/* 82092EE4h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0xFFFF9D64) );
		/* 82092EE4h case    8:*/		return 0x82092EE8;
		  /* 82092EE8h */ case    9:  		/* cmplw CR6, R29, R11 */
		/* 82092EE8h case    9:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82092EE8h case    9:*/		return 0x82092EEC;
		  /* 82092EECh */ case   10:  		/* bc 4, CR6_EQ, 12 */
		/* 82092EECh case   10:*/		if ( !regs.CR[6].eq ) { return 0x82092EF8;  }
		/* 82092EECh case   10:*/		return 0x82092EF0;
		  /* 82092EF0h */ case   11:  		/* cmplw CR6, R26, R10 */
		/* 82092EF0h case   11:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R10);
		/* 82092EF0h case   11:*/		return 0x82092EF4;
		  /* 82092EF4h */ case   12:  		/* bc 12, CR6_EQ, -56 */
		/* 82092EF4h case   12:*/		if ( regs.CR[6].eq ) { return 0x82092EBC;  }
		/* 82092EF4h case   12:*/		return 0x82092EF8;
	}
	return 0x82092EF8;
} // Block from 82092EC4h-82092EF8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82092EF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092EF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092EF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092EF8);
		  /* 82092EF8h */ case    0:  		/* mr R29, R11 */
		/* 82092EF8h case    0:*/		regs.R29 = regs.R11;
		/* 82092EF8h case    0:*/		return 0x82092EFC;
		  /* 82092EFCh */ case    1:  		/* mr R28, R11 */
		/* 82092EFCh case    1:*/		regs.R28 = regs.R11;
		/* 82092EFCh case    1:*/		return 0x82092F00;
		  /* 82092F00h */ case    2:  		/* mr R26, R10 */
		/* 82092F00h case    2:*/		regs.R26 = regs.R10;
		/* 82092F00h case    2:*/		return 0x82092F04;
		  /* 82092F04h */ case    3:  		/* stw R11, <#[R31 + 84]> */
		/* 82092F04h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 82092F04h case    3:*/		return 0x82092F08;
		  /* 82092F08h */ case    4:  		/* mr R30, R10 */
		/* 82092F08h case    4:*/		regs.R30 = regs.R10;
		/* 82092F08h case    4:*/		return 0x82092F0C;
		  /* 82092F0Ch */ case    5:  		/* stw R11, <#[R31 + 88]> */
		/* 82092F0Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 82092F0Ch case    5:*/		return 0x82092F10;
		  /* 82092F10h */ case    6:  		/* stw R10, <#[R31 + 92]> */
		/* 82092F10h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000005C) );
		/* 82092F10h case    6:*/		return 0x82092F14;
		  /* 82092F14h */ case    7:  		/* stw R10, <#[R31 + 80]> */
		/* 82092F14h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 82092F14h case    7:*/		return 0x82092F18;
		  /* 82092F18h */ case    8:  		/* b -92 */
		/* 82092F18h case    8:*/		return 0x82092EBC;
		/* 82092F18h case    8:*/		return 0x82092F1C;
	}
	return 0x82092F1C;
} // Block from 82092EF8h-82092F1Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82092F1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092F1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092F1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092F1C);
		  /* 82092F1Ch */ case    0:  		/* lis R11, -32217 */
		/* 82092F1Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82092F1Ch case    0:*/		return 0x82092F20;
		  /* 82092F20h */ case    1:  		/* lis R10, -32217 */
		/* 82092F20h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 82092F20h case    1:*/		return 0x82092F24;
		  /* 82092F24h */ case    2:  		/* addi R4, R11, 72 */
		/* 82092F24h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x48);
		/* 82092F24h case    2:*/		return 0x82092F28;
		  /* 82092F28h */ case    3:  		/* addi R3, R10, 64 */
		/* 82092F28h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0x40);
		/* 82092F28h case    3:*/		return 0x82092F2C;
		  /* 82092F2Ch */ case    4:  		/* bl -388 */
		/* 82092F2Ch case    4:*/		regs.LR = 0x82092F30; return 0x82092DA8;
		/* 82092F2Ch case    4:*/		return 0x82092F30;
	}
	return 0x82092F30;
} // Block from 82092F1Ch-82092F30h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82092F30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092F30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092F30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092F30);
		  /* 82092F30h */ case    0:  		/* lis R11, -32217 */
		/* 82092F30h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82092F30h case    0:*/		return 0x82092F34;
		  /* 82092F34h */ case    1:  		/* lis R10, -32217 */
		/* 82092F34h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 82092F34h case    1:*/		return 0x82092F38;
		  /* 82092F38h */ case    2:  		/* addi R4, R11, 80 */
		/* 82092F38h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x50);
		/* 82092F38h case    2:*/		return 0x82092F3C;
		  /* 82092F3Ch */ case    3:  		/* addi R3, R10, 76 */
		/* 82092F3Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0x4C);
		/* 82092F3Ch case    3:*/		return 0x82092F40;
		  /* 82092F40h */ case    4:  		/* bl -408 */
		/* 82092F40h case    4:*/		regs.LR = 0x82092F44; return 0x82092DA8;
		/* 82092F40h case    4:*/		return 0x82092F44;
	}
	return 0x82092F44;
} // Block from 82092F30h-82092F44h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82092F44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092F44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092F44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092F44);
		  /* 82092F44h */ case    0:  		/* nop */
		/* 82092F44h case    0:*/		cpu::op::nop();
		/* 82092F44h case    0:*/		return 0x82092F48;
		  /* 82092F48h */ case    1:  		/* addi R12, R31, 176 */
		/* 82092F48h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R31,0xB0);
		/* 82092F48h case    1:*/		return 0x82092F4C;
		  /* 82092F4Ch */ case    2:  		/* bl 64 */
		/* 82092F4Ch case    2:*/		regs.LR = 0x82092F50; return 0x82092F8C;
		/* 82092F4Ch case    2:*/		return 0x82092F50;
		  /* 82092F50h */ case    3:  		/* lwz R11, <#[R31 + 204]> */
		/* 82092F50h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000CC) );
		/* 82092F50h case    3:*/		return 0x82092F54;
		  /* 82092F54h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 82092F54h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82092F54h case    4:*/		return 0x82092F58;
		  /* 82092F58h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 82092F58h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82092F64;  }
		/* 82092F58h case    5:*/		return 0x82092F5C;
		  /* 82092F5Ch */ case    6:  		/* li R3, 0 */
		/* 82092F5Ch case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82092F5Ch case    6:*/		return 0x82092F60;
		  /* 82092F60h */ case    7:  		/* bl 1942184 */
		/* 82092F60h case    7:*/		regs.LR = 0x82092F64; return 0x8226D208;
		/* 82092F60h case    7:*/		return 0x82092F64;
	}
	return 0x82092F64;
} // Block from 82092F44h-82092F64h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82092F64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092F64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092F64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092F64);
		  /* 82092F64h */ case    0:  		/* addi R1, R31, 176 */
		/* 82092F64h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0xB0);
		/* 82092F64h case    0:*/		return 0x82092F68;
		  /* 82092F68h */ case    1:  		/* b -7376 */
		/* 82092F68h case    1:*/		return 0x82091298;
		/* 82092F68h case    1:*/		return 0x82092F6C;
	}
	return 0x82092F6C;
} // Block from 82092F64h-82092F6Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82092F6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092F6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092F6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092F6C);
		  /* 82092F6Ch */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 82092F6Ch case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82092F6Ch case    0:*/		return 0x82092F70;
		  /* 82092F70h */ case    1:  		/* addi R31, R12, -176 */
		/* 82092F70h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFF50);
		/* 82092F70h case    1:*/		return 0x82092F74;
		  /* 82092F74h */ case    2:  		/* std R24, <#[R1 - 16]> */
		/* 82092F74h case    2:*/		cpu::mem::store64( regs, regs.R24, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82092F74h case    2:*/		return 0x82092F78;
		  /* 82092F78h */ case    3:  		/* mfspr R12, LR */
		/* 82092F78h case    3:*/		regs.R12 = regs.LR;
		/* 82092F78h case    3:*/		return 0x82092F7C;
		  /* 82092F7Ch */ case    4:  		/* stw R12, <#[R1 - 24]> */
		/* 82092F7Ch case    4:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82092F7Ch case    4:*/		return 0x82092F80;
		  /* 82092F80h */ case    5:  		/* stwu R1, <#[R1 - 112]> */
		/* 82092F80h case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82092F80h case    5:*/		return 0x82092F84;
		  /* 82092F84h */ case    6:  		/* lwz R24, <#[R31 + 204]> */
		/* 82092F84h case    6:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R31 + 0x000000CC) );
		/* 82092F84h case    6:*/		return 0x82092F88;
		  /* 82092F88h */ case    7:  		/* b 28 */
		/* 82092F88h case    7:*/		return 0x82092FA4;
		/* 82092F88h case    7:*/		return 0x82092F8C;
	}
	return 0x82092F8C;
} // Block from 82092F6Ch-82092F8Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 82092F8Ch
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092F8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092F8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092F8C);
		  /* 82092F8Ch */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 82092F8Ch case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82092F8Ch case    0:*/		return 0x82092F90;
		  /* 82092F90h */ case    1:  		/* addi R31, R12, -176 */
		/* 82092F90h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFF50);
		/* 82092F90h case    1:*/		return 0x82092F94;
		  /* 82092F94h */ case    2:  		/* std R24, <#[R1 - 16]> */
		/* 82092F94h case    2:*/		cpu::mem::store64( regs, regs.R24, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82092F94h case    2:*/		return 0x82092F98;
	}
	return 0x82092F98;
} // Block from 82092F8Ch-82092F98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82092F98h
// Function 'strncpy'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092F98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092F98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092F98);
		  /* 82092F98h */ case    0:  		/* mfspr R12, LR */
		/* 82092F98h case    0:*/		regs.R12 = regs.LR;
		/* 82092F98h case    0:*/		return 0x82092F9C;
		  /* 82092F9Ch */ case    1:  		/* stw R12, <#[R1 - 24]> */
		/* 82092F9Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82092F9Ch case    1:*/		return 0x82092FA0;
		  /* 82092FA0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82092FA0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82092FA0h case    2:*/		return 0x82092FA4;
	}
	return 0x82092FA4;
} // Block from 82092F98h-82092FA4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82092FA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092FA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092FA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092FA4);
		  /* 82092FA4h */ case    0:  		/* cmpwi CR6, R24, 0 */
		/* 82092FA4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 82092FA4h case    0:*/		return 0x82092FA8;
		  /* 82092FA8h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82092FA8h case    1:*/		if ( regs.CR[6].eq ) { return 0x82092FB4;  }
		/* 82092FA8h case    1:*/		return 0x82092FAC;
		  /* 82092FACh */ case    2:  		/* li R3, 8 */
		/* 82092FACh case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x8);
		/* 82092FACh case    2:*/		return 0x82092FB0;
		  /* 82092FB0h */ case    3:  		/* bl 24616 */
		/* 82092FB0h case    3:*/		regs.LR = 0x82092FB4; return 0x82098FD8;
		/* 82092FB0h case    3:*/		return 0x82092FB4;
	}
	return 0x82092FB4;
} // Block from 82092FA4h-82092FB4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82092FB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092FB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092FB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092FB4);
		  /* 82092FB4h */ case    0:  		/* lwz R1, <#[R1]> */
		/* 82092FB4h case    0:*/		cpu::mem::load32z( regs, &regs.R1, (uint32)(regs.R1 + 0x00000000) );
		/* 82092FB4h case    0:*/		return 0x82092FB8;
		  /* 82092FB8h */ case    1:  		/* ld R31, <#[R1 - 8]> */
		/* 82092FB8h case    1:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82092FB8h case    1:*/		return 0x82092FBC;
		  /* 82092FBCh */ case    2:  		/* ld R24, <#[R1 - 16]> */
		/* 82092FBCh case    2:*/		cpu::mem::load64( regs, &regs.R24, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82092FBCh case    2:*/		return 0x82092FC0;
		  /* 82092FC0h */ case    3:  		/* lwz R12, <#[R1 - 24]> */
		/* 82092FC0h case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82092FC0h case    3:*/		return 0x82092FC4;
		  /* 82092FC4h */ case    4:  		/* mtspr LR, R12 */
		/* 82092FC4h case    4:*/		regs.LR = regs.R12;
		/* 82092FC4h case    4:*/		return 0x82092FC8;
		  /* 82092FC8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82092FC8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82092FC8h case    5:*/		return 0x82092FCC;
	}
	return 0x82092FCC;
} // Block from 82092FB4h-82092FCCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 82092FCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092FCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092FCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092FCC);
		  /* 82092FCCh */ case    0:  		/* nop */
		/* 82092FCCh case    0:*/		cpu::op::nop();
		/* 82092FCCh case    0:*/		return 0x82092FD0;
	}
	return 0x82092FD0;
} // Block from 82092FCCh-82092FD0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82092FD0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092FD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092FD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092FD0);
		  /* 82092FD0h */ case    0:  		/* li R4, 0 */
		/* 82092FD0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82092FD0h case    0:*/		return 0x82092FD4;
		  /* 82092FD4h */ case    1:  		/* li R3, 0 */
		/* 82092FD4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82092FD4h case    1:*/		return 0x82092FD8;
		  /* 82092FD8h */ case    2:  		/* b -464 */
		/* 82092FD8h case    2:*/		return 0x82092E08;
		/* 82092FD8h case    2:*/		return 0x82092FDC;
		  /* 82092FDCh */ case    3:  		/* nop */
		/* 82092FDCh case    3:*/		cpu::op::nop();
		/* 82092FDCh case    3:*/		return 0x82092FE0;
		  /* 82092FE0h */ case    4:  		/* li R4, 0 */
		/* 82092FE0h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82092FE0h case    4:*/		return 0x82092FE4;
		  /* 82092FE4h */ case    5:  		/* li R3, 1 */
		/* 82092FE4h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82092FE4h case    5:*/		return 0x82092FE8;
		  /* 82092FE8h */ case    6:  		/* b -480 */
		/* 82092FE8h case    6:*/		return 0x82092E08;
		/* 82092FE8h case    6:*/		return 0x82092FEC;
		  /* 82092FECh */ case    7:  		/* nop */
		/* 82092FECh case    7:*/		cpu::op::nop();
		/* 82092FECh case    7:*/		return 0x82092FF0;
	}
	return 0x82092FF0;
} // Block from 82092FD0h-82092FF0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82092FF0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092FF0);
		  /* 82092FF0h */ case    0:  		/* li R4, 1 */
		/* 82092FF0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82092FF0h case    0:*/		return 0x82092FF4;
		  /* 82092FF4h */ case    1:  		/* li R3, 0 */
		/* 82092FF4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82092FF4h case    1:*/		return 0x82092FF8;
	}
	return 0x82092FF8;
} // Block from 82092FF0h-82092FF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82092FF8h
// Function 'atol'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82092FF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82092FF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82092FF8);
		  /* 82092FF8h */ case    0:  		/* b -496 */
		/* 82092FF8h case    0:*/		return 0x82092E08;
		/* 82092FF8h case    0:*/		return 0x82092FFC;
		  /* 82092FFCh */ case    1:  		/* nop */
		/* 82092FFCh case    1:*/		cpu::op::nop();
		/* 82092FFCh case    1:*/		return 0x82093000;
	}
	return 0x82093000;
} // Block from 82092FF8h-82093000h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82093000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093000);
		  /* 82093000h */ case    0:  		/* mfspr R12, LR */
		/* 82093000h case    0:*/		regs.R12 = regs.LR;
		/* 82093000h case    0:*/		return 0x82093004;
		  /* 82093004h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82093004h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093004h case    1:*/		return 0x82093008;
	}
	return 0x82093008;
} // Block from 82093000h-82093008h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82093008h
// Function 'ceil'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093008);
		  /* 82093008h */ case    0:  		/* std R31, <#[R1 - 16]> */
		/* 82093008h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82093008h case    0:*/		return 0x8209300C;
		  /* 8209300Ch */ case    1:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209300Ch case    1:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209300Ch case    1:*/		return 0x82093010;
		  /* 82093010h */ case    2:  		/* mr R31, R3 */
		/* 82093010h case    2:*/		regs.R31 = regs.R3;
		/* 82093010h case    2:*/		return 0x82093014;
		  /* 82093014h */ case    3:  		/* bl 7252 */
		/* 82093014h case    3:*/		regs.LR = 0x82093018; return 0x82094C68;
		/* 82093014h case    3:*/		return 0x82093018;
		  /* 82093018h */ case    4:  		/* mr R3, R31 */
		/* 82093018h case    4:*/		regs.R3 = regs.R31;
		/* 82093018h case    4:*/		return 0x8209301C;
		  /* 8209301Ch */ case    5:  		/* bl 7196 */
		/* 8209301Ch case    5:*/		regs.LR = 0x82093020; return 0x82094C38;
		/* 8209301Ch case    5:*/		return 0x82093020;
		  /* 82093020h */ case    6:  		/* li R4, 0 */
		/* 82093020h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82093020h case    6:*/		return 0x82093024;
		  /* 82093024h */ case    7:  		/* li R3, 1 */
		/* 82093024h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82093024h case    7:*/		return 0x82093028;
		  /* 82093028h */ case    8:  		/* bl -544 */
		/* 82093028h case    8:*/		regs.LR = 0x8209302C; return 0x82092E08;
		/* 82093028h case    8:*/		return 0x8209302C;
		  /* 8209302Ch */ case    9:  		/* nop */
		/* 8209302Ch case    9:*/		cpu::op::nop();
		/* 8209302Ch case    9:*/		return 0x82093030;
	}
	return 0x82093030;
} // Block from 82093008h-82093030h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82093030h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093030);
		  /* 82093030h */ case    0:  		/* mfspr R12, LR */
		/* 82093030h case    0:*/		regs.R12 = regs.LR;
		/* 82093030h case    0:*/		return 0x82093034;
		  /* 82093034h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82093034h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093034h case    1:*/		return 0x82093038;
		  /* 82093038h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82093038h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82093038h case    2:*/		return 0x8209303C;
		  /* 8209303Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209303Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209303Ch case    3:*/		return 0x82093040;
		  /* 82093040h */ case    4:  		/* lis R31, -32217 */
		/* 82093040h case    4:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8227);
		/* 82093040h case    4:*/		return 0x82093044;
		  /* 82093044h */ case    5:  		/* lwz R3, <#[R31 + 7216]> */
		/* 82093044h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00001C30) );
		/* 82093044h case    5:*/		return 0x82093048;
		  /* 82093048h */ case    6:  		/* cmpwi CR6, R3, -1 */
		/* 82093048h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82093048h case    6:*/		return 0x8209304C;
		  /* 8209304Ch */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 8209304Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x8209305C;  }
		/* 8209304Ch case    7:*/		return 0x82093050;
	}
	return 0x82093050;
} // Block from 82093030h-82093050h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82093050h
// Function '__savegprlr_14'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093050);
		  /* 82093050h */ case    0:  		/* bl 1942696 */
		/* 82093050h case    0:*/		regs.LR = 0x82093054; return 0x8226D4F8;
		/* 82093050h case    0:*/		return 0x82093054;
	}
	return 0x82093054;
} // Block from 82093050h-82093054h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093054h
// Function '__savegprlr_15'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093054( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093054) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093054);
		  /* 82093054h */ case    0:  		/* li R11, -1 */
		/* 82093054h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 82093054h case    0:*/		return 0x82093058;
	}
	return 0x82093058;
} // Block from 82093054h-82093058h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093058h
// Function '__savegprlr_16'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093058);
		  /* 82093058h */ case    0:  		/* stw R11, <#[R31 + 7216]> */
		/* 82093058h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00001C30) );
		/* 82093058h case    0:*/		return 0x8209305C;
	}
	return 0x8209305C;
} // Block from 82093058h-8209305Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209305Ch
// Function '__savegprlr_17'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209305C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209305C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209305C);
		  /* 8209305Ch */ case    0:  		/* bl 24332 */
		/* 8209305Ch case    0:*/		regs.LR = 0x82093060; return 0x82098F68;
		/* 8209305Ch case    0:*/		return 0x82093060;
	}
	return 0x82093060;
} // Block from 8209305Ch-82093060h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093060h
// Function '__savegprlr_18'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093060);
		  /* 82093060h */ case    0:  		/* addi R1, R1, 96 */
		/* 82093060h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82093060h case    0:*/		return 0x82093064;
	}
	return 0x82093064;
} // Block from 82093060h-82093064h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093064h
// Function '__savegprlr_19'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093064);
		  /* 82093064h */ case    0:  		/* lwz R12, <#[R1 - 8]> */
		/* 82093064h case    0:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093064h case    0:*/		return 0x82093068;
	}
	return 0x82093068;
} // Block from 82093064h-82093068h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093068h
// Function '__savegprlr_20'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093068);
		  /* 82093068h */ case    0:  		/* mtspr LR, R12 */
		/* 82093068h case    0:*/		regs.LR = regs.R12;
		/* 82093068h case    0:*/		return 0x8209306C;
	}
	return 0x8209306C;
} // Block from 82093068h-8209306Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209306Ch
// Function '__savegprlr_21'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209306C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209306C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209306C);
		  /* 8209306Ch */ case    0:  		/* ld R31, <#[R1 - 16]> */
		/* 8209306Ch case    0:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209306Ch case    0:*/		return 0x82093070;
	}
	return 0x82093070;
} // Block from 8209306Ch-82093070h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093070h
// Function '__savegprlr_22'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093070);
		  /* 82093070h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82093070h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82093070h case    0:*/		return 0x82093074;
	}
	return 0x82093074;
} // Block from 82093070h-82093074h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093074h
// Function '__savegprlr_23'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093074);
		  /* 82093074h */ case    0:  		/* nop */
		/* 82093074h case    0:*/		cpu::op::nop();
		/* 82093074h case    0:*/		return 0x82093078;
	}
	return 0x82093078;
} // Block from 82093074h-82093078h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093078h
// Function '__savegprlr_24'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093078);
		  /* 82093078h */ case    0:  		/* mfspr R12, LR */
		/* 82093078h case    0:*/		regs.R12 = regs.LR;
		/* 82093078h case    0:*/		return 0x8209307C;
	}
	return 0x8209307C;
} // Block from 82093078h-8209307Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209307Ch
// Function '__savegprlr_25'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209307C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209307C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209307C);
		  /* 8209307Ch */ case    0:  		/* bl -7712 */
		/* 8209307Ch case    0:*/		regs.LR = 0x82093080; return 0x8209125C;
		/* 8209307Ch case    0:*/		return 0x82093080;
	}
	return 0x82093080;
} // Block from 8209307Ch-82093080h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093080h
// Function '__savegprlr_26'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093080);
		  /* 82093080h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 82093080h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82093080h case    0:*/		return 0x82093084;
	}
	return 0x82093084;
} // Block from 82093080h-82093084h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093084h
// Function '__savegprlr_27'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093084( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093084) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093084);
		  /* 82093084h */ case    0:  		/* bl -35204 */
		/* 82093084h case    0:*/		regs.LR = 0x82093088; return 0x8208A700;
		/* 82093084h case    0:*/		return 0x82093088;
	}
	return 0x82093088;
} // Block from 82093084h-82093088h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093088h
// Function '__savegprlr_28'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093088);
		  /* 82093088h */ case    0:  		/* lis R30, -32217 */
		/* 82093088h case    0:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8227);
		/* 82093088h case    0:*/		return 0x8209308C;
	}
	return 0x8209308C;
} // Block from 82093088h-8209308Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209308Ch
// Function '__savegprlr_29'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209308C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209308C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209308C);
		  /* 8209308Ch */ case    0:  		/* mr R29, R3 */
		/* 8209308Ch case    0:*/		regs.R29 = regs.R3;
		/* 8209308Ch case    0:*/		return 0x82093090;
		  /* 82093090h */ case    1:  		/* lwz R3, <#[R30 + 7216]> */
		/* 82093090h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00001C30) );
		/* 82093090h case    1:*/		return 0x82093094;
		  /* 82093094h */ case    2:  		/* bl 1942596 */
		/* 82093094h case    2:*/		regs.LR = 0x82093098; return 0x8226D4D8;
		/* 82093094h case    2:*/		return 0x82093098;
		  /* 82093098h */ case    3:  		/* or. R31, R3, R3 */
		/* 82093098h case    3:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 82093098h case    3:*/		return 0x8209309C;
		  /* 8209309Ch */ case    4:  		/* bc 4, CR0_EQ, 140 */
		/* 8209309Ch case    4:*/		if ( !regs.CR[0].eq ) { return 0x82093128;  }
		/* 8209309Ch case    4:*/		return 0x820930A0;
	}
	return 0x820930A0;
} // Block from 8209308Ch-820930A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820930A0h
// Function '__restgprlr'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820930A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820930A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820930A0);
		  /* 820930A0h */ case    0:  		/* li R4, 1 */
		/* 820930A0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820930A0h case    0:*/		return 0x820930A4;
	}
	return 0x820930A4;
} // Block from 820930A0h-820930A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820930A4h
// Function '__restgprlr_15'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820930A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820930A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820930A4);
		  /* 820930A4h */ case    0:  		/* lwz R3, <#[R30 + 7216]> */
		/* 820930A4h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00001C30) );
		/* 820930A4h case    0:*/		return 0x820930A8;
	}
	return 0x820930A8;
} // Block from 820930A4h-820930A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820930A8h
// Function '__restgprlr_16'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820930A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820930A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820930A8);
		  /* 820930A8h */ case    0:  		/* bl 1942592 */
		/* 820930A8h case    0:*/		regs.LR = 0x820930AC; return 0x8226D4E8;
		/* 820930A8h case    0:*/		return 0x820930AC;
	}
	return 0x820930AC;
} // Block from 820930A8h-820930ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820930ACh
// Function '__restgprlr_17'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820930AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820930AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820930AC);
		  /* 820930ACh */ case    0:  		/* cmpwi CR0, R3, 0 */
		/* 820930ACh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820930ACh case    0:*/		return 0x820930B0;
	}
	return 0x820930B0;
} // Block from 820930ACh-820930B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820930B0h
// Function '__restgprlr_18'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820930B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820930B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820930B0);
		  /* 820930B0h */ case    0:  		/* bc 12, CR0_EQ, 136 */
		/* 820930B0h case    0:*/		if ( regs.CR[0].eq ) { return 0x82093138;  }
		/* 820930B0h case    0:*/		return 0x820930B4;
	}
	return 0x820930B4;
} // Block from 820930B0h-820930B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820930B4h
// Function '__restgprlr_19'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820930B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820930B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820930B4);
		  /* 820930B4h */ case    0:  		/* li R4, 196 */
		/* 820930B4h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xC4);
		/* 820930B4h case    0:*/		return 0x820930B8;
	}
	return 0x820930B8;
} // Block from 820930B4h-820930B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820930B8h
// Function '__restgprlr_20'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820930B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820930B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820930B8);
		  /* 820930B8h */ case    0:  		/* li R3, 1 */
		/* 820930B8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820930B8h case    0:*/		return 0x820930BC;
	}
	return 0x820930BC;
} // Block from 820930B8h-820930BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820930BCh
// Function '__restgprlr_21'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820930BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820930BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820930BC);
		  /* 820930BCh */ case    0:  		/* bl 25292 */
		/* 820930BCh case    0:*/		regs.LR = 0x820930C0; return 0x82099388;
		/* 820930BCh case    0:*/		return 0x820930C0;
	}
	return 0x820930C0;
} // Block from 820930BCh-820930C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820930C0h
// Function '__restgprlr_22'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820930C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820930C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820930C0);
		  /* 820930C0h */ case    0:  		/* or. R31, R3, R3 */
		/* 820930C0h case    0:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820930C0h case    0:*/		return 0x820930C4;
	}
	return 0x820930C4;
} // Block from 820930C0h-820930C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820930C4h
// Function '__restgprlr_23'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820930C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820930C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820930C4);
		  /* 820930C4h */ case    0:  		/* lwz R3, <#[R30 + 7216]> */
		/* 820930C4h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00001C30) );
		/* 820930C4h case    0:*/		return 0x820930C8;
	}
	return 0x820930C8;
} // Block from 820930C4h-820930C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820930C8h
// Function '__restgprlr_24'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820930C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820930C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820930C8);
		  /* 820930C8h */ case    0:  		/* bc 12, CR0_EQ, 84 */
		/* 820930C8h case    0:*/		if ( regs.CR[0].eq ) { return 0x8209311C;  }
		/* 820930C8h case    0:*/		return 0x820930CC;
	}
	return 0x820930CC;
} // Block from 820930C8h-820930CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820930CCh
// Function '__restgprlr_25'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820930CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820930CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820930CC);
		  /* 820930CCh */ case    0:  		/* mr R4, R31 */
		/* 820930CCh case    0:*/		regs.R4 = regs.R31;
		/* 820930CCh case    0:*/		return 0x820930D0;
	}
	return 0x820930D0;
} // Block from 820930CCh-820930D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820930D0h
// Function '__restgprlr_26'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820930D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820930D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820930D0);
		  /* 820930D0h */ case    0:  		/* bl 1942552 */
		/* 820930D0h case    0:*/		regs.LR = 0x820930D4; return 0x8226D4E8;
		/* 820930D0h case    0:*/		return 0x820930D4;
	}
	return 0x820930D4;
} // Block from 820930D0h-820930D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820930D4h
// Function '__restgprlr_27'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820930D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820930D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820930D4);
		  /* 820930D4h */ case    0:  		/* cmpwi CR0, R3, 0 */
		/* 820930D4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820930D4h case    0:*/		return 0x820930D8;
	}
	return 0x820930D8;
} // Block from 820930D4h-820930D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820930D8h
// Function '__restgprlr_28'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820930D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820930D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820930D8);
		  /* 820930D8h */ case    0:  		/* bc 12, CR0_EQ, 52 */
		/* 820930D8h case    0:*/		if ( regs.CR[0].eq ) { return 0x8209310C;  }
		/* 820930D8h case    0:*/		return 0x820930DC;
	}
	return 0x820930DC;
} // Block from 820930D8h-820930DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820930DCh
// Function '__restgprlr_29'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820930DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820930DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820930DC);
		  /* 820930DCh */ case    0:  		/* lis R11, -32255 */
		/* 820930DCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820930DCh case    0:*/		return 0x820930E0;
		  /* 820930E0h */ case    1:  		/* li R10, 0 */
		/* 820930E0h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820930E0h case    1:*/		return 0x820930E4;
		  /* 820930E4h */ case    2:  		/* addi R11, R11, -20928 */
		/* 820930E4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFAE40);
		/* 820930E4h case    2:*/		return 0x820930E8;
		  /* 820930E8h */ case    3:  		/* li R9, 1 */
		/* 820930E8h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820930E8h case    3:*/		return 0x820930EC;
		  /* 820930ECh */ case    4:  		/* stw R10, <#[R31 + 8]> */
		/* 820930ECh case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820930ECh case    4:*/		return 0x820930F0;
		  /* 820930F0h */ case    5:  		/* stw R11, <#[R31 + 92]> */
		/* 820930F0h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 820930F0h case    5:*/		return 0x820930F4;
	}
	return 0x820930F4;
} // Block from 820930DCh-820930F4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820930F4h
// Function '$$$00003'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820930F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820930F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820930F4);
		  /* 820930F4h */ case    0:  		/* stw R9, <#[R31 + 20]> */
		/* 820930F4h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820930F4h case    0:*/		return 0x820930F8;
		  /* 820930F8h */ case    1:  		/* bl -44384 */
		/* 820930F8h case    1:*/		regs.LR = 0x820930FC; return 0x82088398;
		/* 820930F8h case    1:*/		return 0x820930FC;
		  /* 820930FCh */ case    2:  		/* li R11, -1 */
		/* 820930FCh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820930FCh case    2:*/		return 0x82093100;
	}
	return 0x82093100;
} // Block from 820930F4h-82093100h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82093100h
// Function 'memset'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093100);
		  /* 82093100h */ case    0:  		/* stw R3, <#[R31]> */
		/* 82093100h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 82093100h case    0:*/		return 0x82093104;
		  /* 82093104h */ case    1:  		/* stw R11, <#[R31 + 4]> */
		/* 82093104h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82093104h case    1:*/		return 0x82093108;
		  /* 82093108h */ case    2:  		/* b 48 */
		/* 82093108h case    2:*/		return 0x82093138;
		/* 82093108h case    2:*/		return 0x8209310C;
	}
	return 0x8209310C;
} // Block from 82093100h-8209310Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209310Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209310C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209310C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209310C);
		  /* 8209310Ch */ case    0:  		/* mr R3, R31 */
		/* 8209310Ch case    0:*/		regs.R3 = regs.R31;
		/* 8209310Ch case    0:*/		return 0x82093110;
		  /* 82093110h */ case    1:  		/* bl 1816 */
		/* 82093110h case    1:*/		regs.LR = 0x82093114; return 0x82093828;
		/* 82093110h case    1:*/		return 0x82093114;
		  /* 82093114h */ case    2:  		/* li R31, 0 */
		/* 82093114h case    2:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82093114h case    2:*/		return 0x82093118;
		  /* 82093118h */ case    3:  		/* b 32 */
		/* 82093118h case    3:*/		return 0x82093138;
		/* 82093118h case    3:*/		return 0x8209311C;
	}
	return 0x8209311C;
} // Block from 8209310Ch-8209311Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209311Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209311C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209311C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209311C);
		  /* 8209311Ch */ case    0:  		/* li R4, 0 */
		/* 8209311Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8209311Ch case    0:*/		return 0x82093120;
		  /* 82093120h */ case    1:  		/* bl 1942472 */
		/* 82093120h case    1:*/		regs.LR = 0x82093124; return 0x8226D4E8;
		/* 82093120h case    1:*/		return 0x82093124;
		  /* 82093124h */ case    2:  		/* b 20 */
		/* 82093124h case    2:*/		return 0x82093138;
		/* 82093124h case    2:*/		return 0x82093128;
	}
	return 0x82093128;
} // Block from 8209311Ch-82093128h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82093128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093128);
		  /* 82093128h */ case    0:  		/* addi R11, R31, -1 */
		/* 82093128h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFF);
		/* 82093128h case    0:*/		return 0x8209312C;
		  /* 8209312Ch */ case    1:  		/* subfic R11, R11, 0 */
		/* 8209312Ch case    1:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 8209312Ch case    1:*/		return 0x82093130;
		  /* 82093130h */ case    2:  		/* subfe R11, R11, R11 */
		/* 82093130h case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82093130h case    2:*/		return 0x82093134;
		  /* 82093134h */ case    3:  		/* and R31, R11, R31 */
		/* 82093134h case    3:*/		cpu::op::and<0>(regs,&regs.R31,regs.R11,regs.R31);
		/* 82093134h case    3:*/		return 0x82093138;
	}
	return 0x82093138;
} // Block from 82093128h-82093138h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82093138h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093138);
		  /* 82093138h */ case    0:  		/* mr R3, R29 */
		/* 82093138h case    0:*/		regs.R3 = regs.R29;
		/* 82093138h case    0:*/		return 0x8209313C;
		  /* 8209313Ch */ case    1:  		/* bl -35396 */
		/* 8209313Ch case    1:*/		regs.LR = 0x82093140; return 0x8208A6F8;
		/* 8209313Ch case    1:*/		return 0x82093140;
		  /* 82093140h */ case    2:  		/* mr R3, R31 */
		/* 82093140h case    2:*/		regs.R3 = regs.R31;
		/* 82093140h case    2:*/		return 0x82093144;
		  /* 82093144h */ case    3:  		/* addi R1, R1, 112 */
		/* 82093144h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82093144h case    3:*/		return 0x82093148;
		  /* 82093148h */ case    4:  		/* b -7836 */
		/* 82093148h case    4:*/		return 0x820912AC;
		/* 82093148h case    4:*/		return 0x8209314C;
		  /* 8209314Ch */ case    5:  		/* nop */
		/* 8209314Ch case    5:*/		cpu::op::nop();
		/* 8209314Ch case    5:*/		return 0x82093150;
	}
	return 0x82093150;
} // Block from 82093138h-82093150h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82093150h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093150);
		  /* 82093150h */ case    0:  		/* mfspr R12, LR */
		/* 82093150h case    0:*/		regs.R12 = regs.LR;
		/* 82093150h case    0:*/		return 0x82093154;
		  /* 82093154h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82093154h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093154h case    1:*/		return 0x82093158;
		  /* 82093158h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82093158h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82093158h case    2:*/		return 0x8209315C;
		  /* 8209315Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209315Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209315Ch case    3:*/		return 0x82093160;
		  /* 82093160h */ case    4:  		/* bl -232 */
		/* 82093160h case    4:*/		regs.LR = 0x82093164; return 0x82093078;
		/* 82093160h case    4:*/		return 0x82093164;
		  /* 82093164h */ case    5:  		/* or. R31, R3, R3 */
		/* 82093164h case    5:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 82093164h case    5:*/		return 0x82093168;
		  /* 82093168h */ case    6:  		/* bc 4, CR0_EQ, 12 */
		/* 82093168h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82093174;  }
		/* 82093168h case    6:*/		return 0x8209316C;
		  /* 8209316Ch */ case    7:  		/* li R3, 16 */
		/* 8209316Ch case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x10);
		/* 8209316Ch case    7:*/		return 0x82093170;
		  /* 82093170h */ case    8:  		/* bl -368 */
		/* 82093170h case    8:*/		regs.LR = 0x82093174; return 0x82093000;
		/* 82093170h case    8:*/		return 0x82093174;
	}
	return 0x82093174;
} // Block from 82093150h-82093174h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82093174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093174);
		  /* 82093174h */ case    0:  		/* mr R3, R31 */
		/* 82093174h case    0:*/		regs.R3 = regs.R31;
		/* 82093174h case    0:*/		return 0x82093178;
		  /* 82093178h */ case    1:  		/* addi R1, R1, 96 */
		/* 82093178h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82093178h case    1:*/		return 0x8209317C;
		  /* 8209317Ch */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209317Ch case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209317Ch case    2:*/		return 0x82093180;
		  /* 82093180h */ case    3:  		/* mtspr LR, R12 */
		/* 82093180h case    3:*/		regs.LR = regs.R12;
		/* 82093180h case    3:*/		return 0x82093184;
		  /* 82093184h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82093184h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82093184h case    4:*/		return 0x82093188;
		  /* 82093188h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82093188h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82093188h case    5:*/		return 0x8209318C;
	}
	return 0x8209318C;
} // Block from 82093174h-8209318Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209318Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209318C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209318C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209318C);
		  /* 8209318Ch */ case    0:  		/* nop */
		/* 8209318Ch case    0:*/		cpu::op::nop();
		/* 8209318Ch case    0:*/		return 0x82093190;
	}
	return 0x82093190;
} // Block from 8209318Ch-82093190h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093190);
		  /* 82093190h */ case    0:  		/* mfspr R12, LR */
		/* 82093190h case    0:*/		regs.R12 = regs.LR;
		/* 82093190h case    0:*/		return 0x82093194;
		  /* 82093194h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82093194h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093194h case    1:*/		return 0x82093198;
		  /* 82093198h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82093198h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82093198h case    2:*/		return 0x8209319C;
		  /* 8209319Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209319Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209319Ch case    3:*/		return 0x820931A0;
	}
	return 0x820931A0;
} // Block from 82093190h-820931A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820931A0h
// Function '__crtExitProcess'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820931A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820931A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820931A0);
		  /* 820931A0h */ case    0:  		/* mr R31, R3 */
		/* 820931A0h case    0:*/		regs.R31 = regs.R3;
		/* 820931A0h case    0:*/		return 0x820931A4;
		  /* 820931A4h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820931A4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820931A4h case    1:*/		return 0x820931A8;
	}
	return 0x820931A8;
} // Block from 820931A0h-820931A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820931A8h
// Function '_lockexit'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820931A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820931A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820931A8);
		  /* 820931A8h */ case    0:  		/* bc 12, CR6_EQ, 148 */
		/* 820931A8h case    0:*/		if ( regs.CR[6].eq ) { return 0x8209323C;  }
		/* 820931A8h case    0:*/		return 0x820931AC;
		  /* 820931ACh */ case    1:  		/* lwz R3, <#[R3 + 36]> */
		/* 820931ACh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000024) );
		/* 820931ACh case    1:*/		return 0x820931B0;
	}
	return 0x820931B0;
} // Block from 820931A8h-820931B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820931B0h
// Function '_unlockexit'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820931B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820931B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820931B0);
		  /* 820931B0h */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 820931B0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820931B0h case    0:*/		return 0x820931B4;
		  /* 820931B4h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 820931B4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820931BC;  }
		/* 820931B4h case    1:*/		return 0x820931B8;
	}
	return 0x820931B8;
} // Block from 820931B0h-820931B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820931B8h
// Function '_init_pointers'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820931B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820931B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820931B8);
		  /* 820931B8h */ case    0:  		/* bl 1648 */
		/* 820931B8h case    0:*/		regs.LR = 0x820931BC; return 0x82093828;
		/* 820931B8h case    0:*/		return 0x820931BC;
	}
	return 0x820931BC;
} // Block from 820931B8h-820931BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820931BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820931BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820931BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820931BC);
		  /* 820931BCh */ case    0:  		/* lwz R3, <#[R31 + 44]> */
		/* 820931BCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 820931BCh case    0:*/		return 0x820931C0;
		  /* 820931C0h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820931C0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820931C0h case    1:*/		return 0x820931C4;
		  /* 820931C4h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 820931C4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820931CC;  }
		/* 820931C4h case    2:*/		return 0x820931C8;
		  /* 820931C8h */ case    3:  		/* bl 1632 */
		/* 820931C8h case    3:*/		regs.LR = 0x820931CC; return 0x82093828;
		/* 820931C8h case    3:*/		return 0x820931CC;
	}
	return 0x820931CC;
} // Block from 820931BCh-820931CCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820931CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820931CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820931CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820931CC);
		  /* 820931CCh */ case    0:  		/* lwz R3, <#[R31 + 52]> */
		/* 820931CCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000034) );
		/* 820931CCh case    0:*/		return 0x820931D0;
		  /* 820931D0h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820931D0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820931D0h case    1:*/		return 0x820931D4;
		  /* 820931D4h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 820931D4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820931DC;  }
		/* 820931D4h case    2:*/		return 0x820931D8;
		  /* 820931D8h */ case    3:  		/* bl 1616 */
		/* 820931D8h case    3:*/		regs.LR = 0x820931DC; return 0x82093828;
		/* 820931D8h case    3:*/		return 0x820931DC;
	}
	return 0x820931DC;
} // Block from 820931CCh-820931DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820931DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820931DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820931DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820931DC);
		  /* 820931DCh */ case    0:  		/* lwz R3, <#[R31 + 60]> */
		/* 820931DCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000003C) );
		/* 820931DCh case    0:*/		return 0x820931E0;
		  /* 820931E0h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820931E0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820931E0h case    1:*/		return 0x820931E4;
		  /* 820931E4h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 820931E4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820931EC;  }
		/* 820931E4h case    2:*/		return 0x820931E8;
		  /* 820931E8h */ case    3:  		/* bl 1600 */
		/* 820931E8h case    3:*/		regs.LR = 0x820931EC; return 0x82093828;
		/* 820931E8h case    3:*/		return 0x820931EC;
	}
	return 0x820931EC;
} // Block from 820931DCh-820931ECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820931ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820931EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820931EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820931EC);
		  /* 820931ECh */ case    0:  		/* lwz R3, <#[R31 + 64]> */
		/* 820931ECh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000040) );
		/* 820931ECh case    0:*/		return 0x820931F0;
		  /* 820931F0h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820931F0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820931F0h case    1:*/		return 0x820931F4;
		  /* 820931F4h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 820931F4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820931FC;  }
		/* 820931F4h case    2:*/		return 0x820931F8;
	}
	return 0x820931F8;
} // Block from 820931ECh-820931F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820931F8h
// Function '_initterm'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820931F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820931F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820931F8);
		  /* 820931F8h */ case    0:  		/* bl 1584 */
		/* 820931F8h case    0:*/		regs.LR = 0x820931FC; return 0x82093828;
		/* 820931F8h case    0:*/		return 0x820931FC;
	}
	return 0x820931FC;
} // Block from 820931F8h-820931FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820931FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820931FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820931FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820931FC);
		  /* 820931FCh */ case    0:  		/* lwz R3, <#[R31 + 68]> */
		/* 820931FCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000044) );
		/* 820931FCh case    0:*/		return 0x82093200;
		  /* 82093200h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 82093200h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82093200h case    1:*/		return 0x82093204;
		  /* 82093204h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 82093204h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209320C;  }
		/* 82093204h case    2:*/		return 0x82093208;
		  /* 82093208h */ case    3:  		/* bl 1568 */
		/* 82093208h case    3:*/		regs.LR = 0x8209320C; return 0x82093828;
		/* 82093208h case    3:*/		return 0x8209320C;
	}
	return 0x8209320C;
} // Block from 820931FCh-8209320Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209320Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209320C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209320C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209320C);
		  /* 8209320Ch */ case    0:  		/* lwz R3, <#[R31 + 72]> */
		/* 8209320Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000048) );
		/* 8209320Ch case    0:*/		return 0x82093210;
		  /* 82093210h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 82093210h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82093210h case    1:*/		return 0x82093214;
		  /* 82093214h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 82093214h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209321C;  }
		/* 82093214h case    2:*/		return 0x82093218;
		  /* 82093218h */ case    3:  		/* bl 1552 */
		/* 82093218h case    3:*/		regs.LR = 0x8209321C; return 0x82093828;
		/* 82093218h case    3:*/		return 0x8209321C;
	}
	return 0x8209321C;
} // Block from 8209320Ch-8209321Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209321Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209321C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209321C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209321C);
		  /* 8209321Ch */ case    0:  		/* lis R11, -32255 */
		/* 8209321Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209321Ch case    0:*/		return 0x82093220;
		  /* 82093220h */ case    1:  		/* lwz R3, <#[R31 + 92]> */
		/* 82093220h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000005C) );
		/* 82093220h case    1:*/		return 0x82093224;
		  /* 82093224h */ case    2:  		/* addi R11, R11, -20928 */
		/* 82093224h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFAE40);
		/* 82093224h case    2:*/		return 0x82093228;
		  /* 82093228h */ case    3:  		/* cmplw CR6, R3, R11 */
		/* 82093228h case    3:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 82093228h case    3:*/		return 0x8209322C;
		  /* 8209322Ch */ case    4:  		/* bc 12, CR6_EQ, 8 */
		/* 8209322Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x82093234;  }
		/* 8209322Ch case    4:*/		return 0x82093230;
		  /* 82093230h */ case    5:  		/* bl 1528 */
		/* 82093230h case    5:*/		regs.LR = 0x82093234; return 0x82093828;
		/* 82093230h case    5:*/		return 0x82093234;
	}
	return 0x82093234;
} // Block from 8209321Ch-82093234h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82093234h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093234( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093234) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093234);
		  /* 82093234h */ case    0:  		/* mr R3, R31 */
		/* 82093234h case    0:*/		regs.R3 = regs.R31;
		/* 82093234h case    0:*/		return 0x82093238;
		  /* 82093238h */ case    1:  		/* bl 1520 */
		/* 82093238h case    1:*/		regs.LR = 0x8209323C; return 0x82093828;
		/* 82093238h case    1:*/		return 0x8209323C;
	}
	return 0x8209323C;
} // Block from 82093234h-8209323Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209323Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209323C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209323C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209323C);
		  /* 8209323Ch */ case    0:  		/* addi R1, R1, 96 */
		/* 8209323Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209323Ch case    0:*/		return 0x82093240;
		  /* 82093240h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82093240h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093240h case    1:*/		return 0x82093244;
		  /* 82093244h */ case    2:  		/* mtspr LR, R12 */
		/* 82093244h case    2:*/		regs.LR = regs.R12;
		/* 82093244h case    2:*/		return 0x82093248;
		  /* 82093248h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82093248h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82093248h case    3:*/		return 0x8209324C;
		  /* 8209324Ch */ case    4:  		/* bclr 20, CR0_LT */
		/* 8209324Ch case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209324Ch case    4:*/		return 0x82093250;
	}
	return 0x82093250;
} // Block from 8209323Ch-82093250h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82093250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093250);
		  /* 82093250h */ case    0:  		/* mfspr R12, LR */
		/* 82093250h case    0:*/		regs.R12 = regs.LR;
		/* 82093250h case    0:*/		return 0x82093254;
		  /* 82093254h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82093254h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093254h case    1:*/		return 0x82093258;
	}
	return 0x82093258;
} // Block from 82093250h-82093258h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82093258h
// Function 'doexit'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093258);
		  /* 82093258h */ case    0:  		/* std R30, <#[R1 - 24]> */
		/* 82093258h case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82093258h case    0:*/		return 0x8209325C;
		  /* 8209325Ch */ case    1:  		/* std R31, <#[R1 - 16]> */
		/* 8209325Ch case    1:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209325Ch case    1:*/		return 0x82093260;
		  /* 82093260h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82093260h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82093260h case    2:*/		return 0x82093264;
		  /* 82093264h */ case    3:  		/* lis R30, -32217 */
		/* 82093264h case    3:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8227);
		/* 82093264h case    3:*/		return 0x82093268;
		  /* 82093268h */ case    4:  		/* mr R31, R3 */
		/* 82093268h case    4:*/		regs.R31 = regs.R3;
		/* 82093268h case    4:*/		return 0x8209326C;
		  /* 8209326Ch */ case    5:  		/* lwz R11, <#[R30 + 7216]> */
		/* 8209326Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00001C30) );
		/* 8209326Ch case    5:*/		return 0x82093270;
		  /* 82093270h */ case    6:  		/* cmpwi CR6, R11, -1 */
		/* 82093270h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82093270h case    6:*/		return 0x82093274;
		  /* 82093274h */ case    7:  		/* bc 12, CR6_EQ, 48 */
		/* 82093274h case    7:*/		if ( regs.CR[6].eq ) { return 0x820932A4;  }
		/* 82093274h case    7:*/		return 0x82093278;
		  /* 82093278h */ case    8:  		/* cmplwi CR6, R3, 0 */
		/* 82093278h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82093278h case    8:*/		return 0x8209327C;
		  /* 8209327Ch */ case    9:  		/* bc 4, CR6_EQ, 20 */
		/* 8209327Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x82093290;  }
		/* 8209327Ch case    9:*/		return 0x82093280;
		  /* 82093280h */ case   10:  		/* mr R3, R11 */
		/* 82093280h case   10:*/		regs.R3 = regs.R11;
		/* 82093280h case   10:*/		return 0x82093284;
		  /* 82093284h */ case   11:  		/* bl 1942100 */
		/* 82093284h case   11:*/		regs.LR = 0x82093288; return 0x8226D4D8;
		/* 82093284h case   11:*/		return 0x82093288;
		  /* 82093288h */ case   12:  		/* lwz R11, <#[R30 + 7216]> */
		/* 82093288h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00001C30) );
		/* 82093288h case   12:*/		return 0x8209328C;
		  /* 8209328Ch */ case   13:  		/* mr R31, R3 */
		/* 8209328Ch case   13:*/		regs.R31 = regs.R3;
		/* 8209328Ch case   13:*/		return 0x82093290;
	}
	return 0x82093290;
} // Block from 82093258h-82093290h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82093290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093290);
		  /* 82093290h */ case    0:  		/* li R4, 0 */
		/* 82093290h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82093290h case    0:*/		return 0x82093294;
		  /* 82093294h */ case    1:  		/* mr R3, R11 */
		/* 82093294h case    1:*/		regs.R3 = regs.R11;
		/* 82093294h case    1:*/		return 0x82093298;
		  /* 82093298h */ case    2:  		/* bl 1942096 */
		/* 82093298h case    2:*/		regs.LR = 0x8209329C; return 0x8226D4E8;
		/* 82093298h case    2:*/		return 0x8209329C;
		  /* 8209329Ch */ case    3:  		/* mr R3, R31 */
		/* 8209329Ch case    3:*/		regs.R3 = regs.R31;
		/* 8209329Ch case    3:*/		return 0x820932A0;
		  /* 820932A0h */ case    4:  		/* bl -272 */
		/* 820932A0h case    4:*/		regs.LR = 0x820932A4; return 0x82093190;
		/* 820932A0h case    4:*/		return 0x820932A4;
	}
	return 0x820932A4;
} // Block from 82093290h-820932A4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820932A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820932A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820932A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820932A4);
		  /* 820932A4h */ case    0:  		/* addi R1, R1, 112 */
		/* 820932A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820932A4h case    0:*/		return 0x820932A8;
		  /* 820932A8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820932A8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820932A8h case    1:*/		return 0x820932AC;
		  /* 820932ACh */ case    2:  		/* mtspr LR, R12 */
		/* 820932ACh case    2:*/		regs.LR = regs.R12;
		/* 820932ACh case    2:*/		return 0x820932B0;
		  /* 820932B0h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820932B0h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820932B0h case    3:*/		return 0x820932B4;
		  /* 820932B4h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820932B4h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820932B4h case    4:*/		return 0x820932B8;
		  /* 820932B8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820932B8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820932B8h case    5:*/		return 0x820932BC;
	}
	return 0x820932BC;
} // Block from 820932A4h-820932BCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820932BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820932BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820932BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820932BC);
		  /* 820932BCh */ case    0:  		/* nop */
		/* 820932BCh case    0:*/		cpu::op::nop();
		/* 820932BCh case    0:*/		return 0x820932C0;
	}
	return 0x820932C0;
} // Block from 820932BCh-820932C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820932C0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820932C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820932C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820932C0);
		  /* 820932C0h */ case    0:  		/* mfspr R12, LR */
		/* 820932C0h case    0:*/		regs.R12 = regs.LR;
		/* 820932C0h case    0:*/		return 0x820932C4;
		  /* 820932C4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820932C4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820932C4h case    1:*/		return 0x820932C8;
		  /* 820932C8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820932C8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820932C8h case    2:*/		return 0x820932CC;
		  /* 820932CCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820932CCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820932CCh case    3:*/		return 0x820932D0;
		  /* 820932D0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820932D0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820932D0h case    4:*/		return 0x820932D4;
		  /* 820932D4h */ case    5:  		/* bl -1388 */
		/* 820932D4h case    5:*/		regs.LR = 0x820932D8; return 0x82092D68;
		/* 820932D4h case    5:*/		return 0x820932D8;
		  /* 820932D8h */ case    6:  		/* bl 23992 */
		/* 820932D8h case    6:*/		regs.LR = 0x820932DC; return 0x82099090;
		/* 820932D8h case    6:*/		return 0x820932DC;
		  /* 820932DCh */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820932DCh case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820932DCh case    7:*/		return 0x820932E0;
		  /* 820932E0h */ case    8:  		/* bc 12, CR0_EQ, 152 */
		/* 820932E0h case    8:*/		if ( regs.CR[0].eq ) { return 0x82093378;  }
		/* 820932E0h case    8:*/		return 0x820932E4;
		  /* 820932E4h */ case    9:  		/* bl 1942052 */
		/* 820932E4h case    9:*/		regs.LR = 0x820932E8; return 0x8226D508;
		/* 820932E4h case    9:*/		return 0x820932E8;
		  /* 820932E8h */ case   10:  		/* lis R11, -32217 */
		/* 820932E8h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 820932E8h case   10:*/		return 0x820932EC;
		  /* 820932ECh */ case   11:  		/* mr R30, R3 */
		/* 820932ECh case   11:*/		regs.R30 = regs.R3;
		/* 820932ECh case   11:*/		return 0x820932F0;
		  /* 820932F0h */ case   12:  		/* cmpwi CR6, R3, -1 */
		/* 820932F0h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820932F0h case   12:*/		return 0x820932F4;
		  /* 820932F4h */ case   13:  		/* stw R3, <#[R11 + 7216]> */
		/* 820932F4h case   13:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00001C30) );
		/* 820932F4h case   13:*/		return 0x820932F8;
		  /* 820932F8h */ case   14:  		/* bc 12, CR6_EQ, 128 */
		/* 820932F8h case   14:*/		if ( regs.CR[6].eq ) { return 0x82093378;  }
		/* 820932F8h case   14:*/		return 0x820932FC;
		  /* 820932FCh */ case   15:  		/* li R4, 196 */
		/* 820932FCh case   15:*/		cpu::op::li<0>(regs,&regs.R4,0xC4);
		/* 820932FCh case   15:*/		return 0x82093300;
		  /* 82093300h */ case   16:  		/* li R3, 1 */
		/* 82093300h case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82093300h case   16:*/		return 0x82093304;
		  /* 82093304h */ case   17:  		/* bl 24708 */
		/* 82093304h case   17:*/		regs.LR = 0x82093308; return 0x82099388;
		/* 82093304h case   17:*/		return 0x82093308;
		  /* 82093308h */ case   18:  		/* or. R31, R3, R3 */
		/* 82093308h case   18:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 82093308h case   18:*/		return 0x8209330C;
		  /* 8209330Ch */ case   19:  		/* bc 12, CR0_EQ, 108 */
		/* 8209330Ch case   19:*/		if ( regs.CR[0].eq ) { return 0x82093378;  }
		/* 8209330Ch case   19:*/		return 0x82093310;
		  /* 82093310h */ case   20:  		/* mr R4, R31 */
		/* 82093310h case   20:*/		regs.R4 = regs.R31;
		/* 82093310h case   20:*/		return 0x82093314;
		  /* 82093314h */ case   21:  		/* mr R3, R30 */
		/* 82093314h case   21:*/		regs.R3 = regs.R30;
		/* 82093314h case   21:*/		return 0x82093318;
		  /* 82093318h */ case   22:  		/* bl 1941968 */
		/* 82093318h case   22:*/		regs.LR = 0x8209331C; return 0x8226D4E8;
		/* 82093318h case   22:*/		return 0x8209331C;
		  /* 8209331Ch */ case   23:  		/* cmpwi CR0, R3, 0 */
		/* 8209331Ch case   23:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209331Ch case   23:*/		return 0x82093320;
		  /* 82093320h */ case   24:  		/* bc 12, CR0_EQ, 88 */
		/* 82093320h case   24:*/		if ( regs.CR[0].eq ) { return 0x82093378;  }
		/* 82093320h case   24:*/		return 0x82093324;
		  /* 82093324h */ case   25:  		/* lis R11, -32255 */
		/* 82093324h case   25:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82093324h case   25:*/		return 0x82093328;
		  /* 82093328h */ case   26:  		/* li R10, 0 */
		/* 82093328h case   26:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82093328h case   26:*/		return 0x8209332C;
		  /* 8209332Ch */ case   27:  		/* addi R11, R11, -20928 */
		/* 8209332Ch case   27:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFAE40);
		/* 8209332Ch case   27:*/		return 0x82093330;
		  /* 82093330h */ case   28:  		/* li R9, 1 */
		/* 82093330h case   28:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82093330h case   28:*/		return 0x82093334;
		  /* 82093334h */ case   29:  		/* stw R10, <#[R31 + 8]> */
		/* 82093334h case   29:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82093334h case   29:*/		return 0x82093338;
		  /* 82093338h */ case   30:  		/* stw R11, <#[R31 + 92]> */
		/* 82093338h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 82093338h case   30:*/		return 0x8209333C;
		  /* 8209333Ch */ case   31:  		/* stw R9, <#[R31 + 20]> */
		/* 8209333Ch case   31:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 8209333Ch case   31:*/		return 0x82093340;
		  /* 82093340h */ case   32:  		/* bl -44968 */
		/* 82093340h case   32:*/		regs.LR = 0x82093344; return 0x82088398;
		/* 82093340h case   32:*/		return 0x82093344;
		  /* 82093344h */ case   33:  		/* lis R10, -32215 */
		/* 82093344h case   33:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 82093344h case   33:*/		return 0x82093348;
		  /* 82093348h */ case   34:  		/* lis R11, -32246 */
		/* 82093348h case   34:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820A);
		/* 82093348h case   34:*/		return 0x8209334C;
		  /* 8209334Ch */ case   35:  		/* stw R3, <#[R31]> */
		/* 8209334Ch case   35:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8209334Ch case   35:*/		return 0x82093350;
		  /* 82093350h */ case   36:  		/* addi R10, R10, -30720 */
		/* 82093350h case   36:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFF8800);
		/* 82093350h case   36:*/		return 0x82093354;
		  /* 82093354h */ case   37:  		/* li R9, -1 */
		/* 82093354h case   37:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 82093354h case   37:*/		return 0x82093358;
		  /* 82093358h */ case   38:  		/* addi R11, R11, -27664 */
		/* 82093358h case   38:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF93F0);
		/* 82093358h case   38:*/		return 0x8209335C;
		  /* 8209335Ch */ case   39:  		/* stw R9, <#[R31 + 4]> */
		/* 8209335Ch case   39:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 8209335Ch case   39:*/		return 0x82093360;
		  /* 82093360h */ case   40:  		/* mr R3, R10 */
		/* 82093360h case   40:*/		regs.R3 = regs.R10;
		/* 82093360h case   40:*/		return 0x82093364;
		  /* 82093364h */ case   41:  		/* li R4, 1 */
		/* 82093364h case   41:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82093364h case   41:*/		return 0x82093368;
		  /* 82093368h */ case   42:  		/* stw R11, <#[R10 + 8]> */
		/* 82093368h case   42:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82093368h case   42:*/		return 0x8209336C;
		  /* 8209336Ch */ case   43:  		/* bl -41140 */
		/* 8209336Ch case   43:*/		regs.LR = 0x82093370; return 0x820892B8;
		/* 8209336Ch case   43:*/		return 0x82093370;
		  /* 82093370h */ case   44:  		/* li R3, 1 */
		/* 82093370h case   44:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82093370h case   44:*/		return 0x82093374;
		  /* 82093374h */ case   45:  		/* b 12 */
		/* 82093374h case   45:*/		return 0x82093380;
		/* 82093374h case   45:*/		return 0x82093378;
	}
	return 0x82093378;
} // Block from 820932C0h-82093378h (46 instructions)

//////////////////////////////////////////////////////
// Block at 82093378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093378);
		  /* 82093378h */ case    0:  		/* bl -840 */
		/* 82093378h case    0:*/		regs.LR = 0x8209337C; return 0x82093030;
		/* 82093378h case    0:*/		return 0x8209337C;
		  /* 8209337Ch */ case    1:  		/* li R3, 0 */
		/* 8209337Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209337Ch case    1:*/		return 0x82093380;
	}
	return 0x82093380;
} // Block from 82093378h-82093380h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82093380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093380);
		  /* 82093380h */ case    0:  		/* addi R1, R1, 112 */
		/* 82093380h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82093380h case    0:*/		return 0x82093384;
		  /* 82093384h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82093384h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093384h case    1:*/		return 0x82093388;
		  /* 82093388h */ case    2:  		/* mtspr LR, R12 */
		/* 82093388h case    2:*/		regs.LR = regs.R12;
		/* 82093388h case    2:*/		return 0x8209338C;
		  /* 8209338Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 8209338Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209338Ch case    3:*/		return 0x82093390;
		  /* 82093390h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82093390h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82093390h case    4:*/		return 0x82093394;
		  /* 82093394h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82093394h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82093394h case    5:*/		return 0x82093398;
	}
	return 0x82093398;
} // Block from 82093380h-82093398h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82093398h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093398);
		  /* 82093398h */ case    0:  		/* nop */
		/* 82093398h case    0:*/		cpu::op::nop();
		/* 82093398h case    0:*/		return 0x8209339C;
		  /* 8209339Ch */ case    1:  		/* nop */
		/* 8209339Ch case    1:*/		cpu::op::nop();
		/* 8209339Ch case    1:*/		return 0x820933A0;
		  /* 820933A0h */ case    2:  		/* neg R12, R3 */
		/* 820933A0h case    2:*/		cpu::op::neg<0>(regs,&regs.R12,regs.R3);
		/* 820933A0h case    2:*/		return 0x820933A4;
	}
	return 0x820933A4;
} // Block from 82093398h-820933A4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820933A4h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820933A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820933A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820933A4);
		  /* 820933A4h */ case    0:  		/* neg R11, R12 */
		/* 820933A4h case    0:*/		cpu::op::neg<0>(regs,&regs.R11,regs.R12);
		/* 820933A4h case    0:*/		return 0x820933A8;
		  /* 820933A8h */ case    1:  		/* addi R0, R11, 4095 */
		/* 820933A8h case    1:*/		cpu::op::addi<0>(regs,&regs.R0,regs.R11,0xFFF);
		/* 820933A8h case    1:*/		return 0x820933AC;
		  /* 820933ACh */ case    2:  		/* srawi. R0, R0, 12 */
		/* 820933ACh case    2:*/		cpu::op::srawi<1,12>(regs,&regs.R0,regs.R0);
		/* 820933ACh case    2:*/		return 0x820933B0;
		  /* 820933B0h */ case    3:  		/* bclr 4, CR0_GT */
		/* 820933B0h case    3:*/		if ( !regs.CR[0].gt ) { return (uint32)regs.LR; }
		/* 820933B0h case    3:*/		return 0x820933B4;
	}
	return 0x820933B4;
} // Block from 820933A4h-820933B4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820933B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820933B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820933B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820933B4);
		  /* 820933B4h */ case    0:  		/* mr R11, R1 */
		/* 820933B4h case    0:*/		regs.R11 = regs.R1;
		/* 820933B4h case    0:*/		return 0x820933B8;
		  /* 820933B8h */ case    1:  		/* mtspr CTR, R0 */
		/* 820933B8h case    1:*/		regs.CTR = regs.R0;
		/* 820933B8h case    1:*/		return 0x820933BC;
		  /* 820933BCh */ case    2:  		/* lwzu R0, <#[R11 - 4096]> */
		/* 820933BCh case    2:*/		cpu::mem::load32z( regs, &regs.R0, (uint32)(regs.R11 + 0xFFFFF000) );
		regs.R11 = (uint32)(regs.R11 + 0xFFFFF000);
		/* 820933BCh case    2:*/		return 0x820933C0;
		  /* 820933C0h */ case    3:  		/* bc 16, CR0_LT, -4 */
		/* 820933C0h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820933BC;  }
		/* 820933C0h case    3:*/		return 0x820933C4;
		  /* 820933C4h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820933C4h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820933C4h case    4:*/		return 0x820933C8;
	}
	return 0x820933C8;
} // Block from 820933B4h-820933C8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820933C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820933C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820933C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820933C8);
		  /* 820933C8h */ case    0:  		/* nop */
		/* 820933C8h case    0:*/		cpu::op::nop();
		/* 820933C8h case    0:*/		return 0x820933CC;
		  /* 820933CCh */ case    1:  		/* nop */
		/* 820933CCh case    1:*/		cpu::op::nop();
		/* 820933CCh case    1:*/		return 0x820933D0;
		  /* 820933D0h */ case    2:  		/* lbz R5, <#[R3]> */
		/* 820933D0h case    2:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000000) );
		/* 820933D0h case    2:*/		return 0x820933D4;
		  /* 820933D4h */ case    3:  		/* mr R9, R3 */
		/* 820933D4h case    3:*/		regs.R9 = regs.R3;
		/* 820933D4h case    3:*/		return 0x820933D8;
		  /* 820933D8h */ case    4:  		/* cmpwi CR6, R4, 0 */
		/* 820933D8h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 820933D8h case    4:*/		return 0x820933DC;
		  /* 820933DCh */ case    5:  		/* cmpw CR0, R5, R4 */
		/* 820933DCh case    5:*/		cpu::op::cmpw<0>(regs,regs.R5,regs.R4);
		/* 820933DCh case    5:*/		return 0x820933E0;
		  /* 820933E0h */ case    6:  		/* bc 12, CR6_EQ, 52 */
		/* 820933E0h case    6:*/		if ( regs.CR[6].eq ) { return 0x82093414;  }
		/* 820933E0h case    6:*/		return 0x820933E4;
		  /* 820933E4h */ case    7:  		/* li R3, 0 */
		/* 820933E4h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820933E4h case    7:*/		return 0x820933E8;
		  /* 820933E8h */ case    8:  		/* bc 12, CR0_EQ, 24 */
		/* 820933E8h case    8:*/		if ( regs.CR[0].eq ) { return 0x82093400;  }
		/* 820933E8h case    8:*/		return 0x820933EC;
		  /* 820933ECh */ case    9:  		/* cmpwi CR6, R5, 0 */
		/* 820933ECh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 820933ECh case    9:*/		return 0x820933F0;
		  /* 820933F0h */ case   10:  		/* bc 12, CR6_EQ, 52 */
		/* 820933F0h case   10:*/		if ( regs.CR[6].eq ) { return 0x82093424;  }
		/* 820933F0h case   10:*/		return 0x820933F4;
		  /* 820933F4h */ case   11:  		/* lbzu R5, <#[R9 + 1]> */
		/* 820933F4h case   11:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000001) );
		regs.R9 = (uint32)(regs.R9 + 0x00000001);
		/* 820933F4h case   11:*/		return 0x820933F8;
		  /* 820933F8h */ case   12:  		/* cmpw CR0, R4, R5 */
		/* 820933F8h case   12:*/		cpu::op::cmpw<0>(regs,regs.R4,regs.R5);
		/* 820933F8h case   12:*/		return 0x820933FC;
		  /* 820933FCh */ case   13:  		/* bc 4, CR0_EQ, -16 */
		/* 820933FCh case   13:*/		if ( !regs.CR[0].eq ) { return 0x820933EC;  }
		/* 820933FCh case   13:*/		return 0x82093400;
	}
	return 0x82093400;
} // Block from 820933C8h-82093400h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82093400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093400);
		  /* 82093400h */ case    0:  		/* mr R3, R9 */
		/* 82093400h case    0:*/		regs.R3 = regs.R9;
		/* 82093400h case    0:*/		return 0x82093404;
		  /* 82093404h */ case    1:  		/* lbzu R5, <#[R9 + 1]> */
		/* 82093404h case    1:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000001) );
		regs.R9 = (uint32)(regs.R9 + 0x00000001);
		/* 82093404h case    1:*/		return 0x82093408;
		  /* 82093408h */ case    2:  		/* cmpw CR0, R4, R5 */
		/* 82093408h case    2:*/		cpu::op::cmpw<0>(regs,regs.R4,regs.R5);
		/* 82093408h case    2:*/		return 0x8209340C;
		  /* 8209340Ch */ case    3:  		/* bc 12, CR0_EQ, -12 */
		/* 8209340Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x82093400;  }
		/* 8209340Ch case    3:*/		return 0x82093410;
		  /* 82093410h */ case    4:  		/* b -36 */
		/* 82093410h case    4:*/		return 0x820933EC;
		/* 82093410h case    4:*/		return 0x82093414;
	}
	return 0x82093414;
} // Block from 82093400h-82093414h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82093414h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093414( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093414) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093414);
		  /* 82093414h */ case    0:  		/* bc 12, CR0_EQ, 16 */
		/* 82093414h case    0:*/		if ( regs.CR[0].eq ) { return 0x82093424;  }
		/* 82093414h case    0:*/		return 0x82093418;
		  /* 82093418h */ case    1:  		/* lbzu R5, <#[R3 + 1]> */
		/* 82093418h case    1:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000001) );
		regs.R3 = (uint32)(regs.R3 + 0x00000001);
		/* 82093418h case    1:*/		return 0x8209341C;
		  /* 8209341Ch */ case    2:  		/* cmpwi CR0, R5, 0 */
		/* 8209341Ch case    2:*/		cpu::op::cmpwi<0>(regs,regs.R5,0x00000000);
		/* 8209341Ch case    2:*/		return 0x82093420;
	}
	return 0x82093420;
} // Block from 82093414h-82093420h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82093420h
// Function 'exit'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093420);
		  /* 82093420h */ case    0:  		/* b -12 */
		/* 82093420h case    0:*/		return 0x82093414;
		/* 82093420h case    0:*/		return 0x82093424;
	}
	return 0x82093424;
} // Block from 82093420h-82093424h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093424);
		  /* 82093424h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82093424h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82093424h case    0:*/		return 0x82093428;
	}
	return 0x82093428;
} // Block from 82093424h-82093428h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093428);
		  /* 82093428h */ case    0:  		/* nop */
		/* 82093428h case    0:*/		cpu::op::nop();
		/* 82093428h case    0:*/		return 0x8209342C;
		  /* 8209342Ch */ case    1:  		/* nop */
		/* 8209342Ch case    1:*/		cpu::op::nop();
		/* 8209342Ch case    1:*/		return 0x82093430;
	}
	return 0x82093430;
} // Block from 82093428h-82093430h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82093430h
// Function '_exit'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093430);
		  /* 82093430h */ case    0:  		/* addi R9, R3, -1 */
		/* 82093430h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0xFFFFFFFF);
		/* 82093430h case    0:*/		return 0x82093434;
		  /* 82093434h */ case    1:  		/* addi R4, R4, -1 */
		/* 82093434h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFFFF);
		/* 82093434h case    1:*/		return 0x82093438;
		  /* 82093438h */ case    2:  		/* lbzu R6, <#[R4 + 1]> */
		/* 82093438h case    2:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R4 + 0x00000001) );
		regs.R4 = (uint32)(regs.R4 + 0x00000001);
		/* 82093438h case    2:*/		return 0x8209343C;
		  /* 8209343Ch */ case    3:  		/* lbzu R5, <#[R9 + 1]> */
		/* 8209343Ch case    3:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000001) );
		regs.R9 = (uint32)(regs.R9 + 0x00000001);
		/* 8209343Ch case    3:*/		return 0x82093440;
	}
	return 0x82093440;
} // Block from 82093430h-82093440h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82093440h
// Function '_cexit'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093440);
		  /* 82093440h */ case    0:  		/* cmpwi CR7, R6, 0 */
		/* 82093440h case    0:*/		cpu::op::cmpwi<7>(regs,regs.R6,0x00000000);
		/* 82093440h case    0:*/		return 0x82093444;
		  /* 82093444h */ case    1:  		/* subf. R3, R6, R5 */
		/* 82093444h case    1:*/		cpu::op::subf<1>(regs,&regs.R3,regs.R6,regs.R5);
		/* 82093444h case    1:*/		return 0x82093448;
		  /* 82093448h */ case    2:  		/* bc 12, CR7_EQ, 56 */
		/* 82093448h case    2:*/		if ( regs.CR[7].eq ) { return 0x82093480;  }
		/* 82093448h case    2:*/		return 0x8209344C;
		  /* 8209344Ch */ case    3:  		/* bc 12, CR0_EQ, -20 */
		/* 8209344Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x82093438;  }
		/* 8209344Ch case    3:*/		return 0x82093450;
	}
	return 0x82093450;
} // Block from 82093440h-82093450h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82093450h
// Function '_amsg_exit'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093450);
		  /* 82093450h */ case    0:  		/* cmpwi CR5, R6, 65 */
		/* 82093450h case    0:*/		cpu::op::cmpwi<5>(regs,regs.R6,0x00000041);
		/* 82093450h case    0:*/		return 0x82093454;
		  /* 82093454h */ case    1:  		/* cmpwi CR6, R6, 90 */
		/* 82093454h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x0000005A);
		/* 82093454h case    1:*/		return 0x82093458;
		  /* 82093458h */ case    2:  		/* bc 12, CR5_LT, 12 */
		/* 82093458h case    2:*/		if ( regs.CR[5].lt ) { return 0x82093464;  }
		/* 82093458h case    2:*/		return 0x8209345C;
		  /* 8209345Ch */ case    3:  		/* bc 12, CR6_GT, 8 */
		/* 8209345Ch case    3:*/		if ( regs.CR[6].gt ) { return 0x82093464;  }
		/* 8209345Ch case    3:*/		return 0x82093460;
		  /* 82093460h */ case    4:  		/* ori R6, R6, 32 */
		/* 82093460h case    4:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x20);
		/* 82093460h case    4:*/		return 0x82093464;
	}
	return 0x82093464;
} // Block from 82093450h-82093464h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82093464h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093464( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093464) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093464);
		  /* 82093464h */ case    0:  		/* cmpwi CR0, R5, 65 */
		/* 82093464h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R5,0x00000041);
		/* 82093464h case    0:*/		return 0x82093468;
		  /* 82093468h */ case    1:  		/* cmpwi CR1, R5, 90 */
		/* 82093468h case    1:*/		cpu::op::cmpwi<1>(regs,regs.R5,0x0000005A);
		/* 82093468h case    1:*/		return 0x8209346C;
		  /* 8209346Ch */ case    2:  		/* bc 12, CR0_LT, 12 */
		/* 8209346Ch case    2:*/		if ( regs.CR[0].lt ) { return 0x82093478;  }
		/* 8209346Ch case    2:*/		return 0x82093470;
		  /* 82093470h */ case    3:  		/* bc 12, CR1_GT, 8 */
		/* 82093470h case    3:*/		if ( regs.CR[1].gt ) { return 0x82093478;  }
		/* 82093470h case    3:*/		return 0x82093474;
		  /* 82093474h */ case    4:  		/* ori R5, R5, 32 */
		/* 82093474h case    4:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x20);
		/* 82093474h case    4:*/		return 0x82093478;
	}
	return 0x82093478;
} // Block from 82093464h-82093478h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82093478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093478);
		  /* 82093478h */ case    0:  		/* subf. R3, R6, R5 */
		/* 82093478h case    0:*/		cpu::op::subf<1>(regs,&regs.R3,regs.R6,regs.R5);
		/* 82093478h case    0:*/		return 0x8209347C;
		  /* 8209347Ch */ case    1:  		/* bc 12, CR0_EQ, -68 */
		/* 8209347Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82093438;  }
		/* 8209347Ch case    1:*/		return 0x82093480;
	}
	return 0x82093480;
} // Block from 82093478h-82093480h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82093480h
// Function '_mtterm'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093480);
		  /* 82093480h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82093480h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82093480h case    0:*/		return 0x82093484;
	}
	return 0x82093484;
} // Block from 82093480h-82093484h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093484);
		  /* 82093484h */ case    0:  		/* nop */
		/* 82093484h case    0:*/		cpu::op::nop();
		/* 82093484h case    0:*/		return 0x82093488;
	}
	return 0x82093488;
} // Block from 82093484h-82093488h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093488);
		  /* 82093488h */ case    0:  		/* lwz R3, <#[R3 + 4]> */
		/* 82093488h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000004) );
		/* 82093488h case    0:*/		return 0x8209348C;
		  /* 8209348Ch */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8209348Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209348Ch case    1:*/		return 0x82093490;
		  /* 82093490h */ case    2:  		/* bclr 4, CR6_EQ */
		/* 82093490h case    2:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82093490h case    2:*/		return 0x82093494;
	}
	return 0x82093494;
} // Block from 82093488h-82093494h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82093494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093494);
		  /* 82093494h */ case    0:  		/* lis R11, -32255 */
		/* 82093494h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82093494h case    0:*/		return 0x82093498;
		  /* 82093498h */ case    1:  		/* addi R3, R11, -24472 */
		/* 82093498h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFA068);
		/* 82093498h case    1:*/		return 0x8209349C;
		  /* 8209349Ch */ case    2:  		/* bclr 20, CR0_LT */
		/* 8209349Ch case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209349Ch case    2:*/		return 0x820934A0;
	}
	return 0x820934A0;
} // Block from 82093494h-820934A0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820934A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820934A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820934A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820934A0);
		  /* 820934A0h */ case    0:  		/* mfspr R12, LR */
		/* 820934A0h case    0:*/		regs.R12 = regs.LR;
		/* 820934A0h case    0:*/		return 0x820934A4;
		  /* 820934A4h */ case    1:  		/* bl -8776 */
		/* 820934A4h case    1:*/		regs.LR = 0x820934A8; return 0x8209125C;
		/* 820934A4h case    1:*/		return 0x820934A8;
		  /* 820934A8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820934A8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820934A8h case    2:*/		return 0x820934AC;
		  /* 820934ACh */ case    3:  		/* mr R29, R3 */
		/* 820934ACh case    3:*/		regs.R29 = regs.R3;
		/* 820934ACh case    3:*/		return 0x820934B0;
		  /* 820934B0h */ case    4:  		/* mr R30, R4 */
		/* 820934B0h case    4:*/		regs.R30 = regs.R4;
		/* 820934B0h case    4:*/		return 0x820934B4;
		  /* 820934B4h */ case    5:  		/* cmplwi CR6, R4, 0 */
		/* 820934B4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820934B4h case    5:*/		return 0x820934B8;
		  /* 820934B8h */ case    6:  		/* bc 12, CR6_EQ, 80 */
		/* 820934B8h case    6:*/		if ( regs.CR[6].eq ) { return 0x82093508;  }
		/* 820934B8h case    6:*/		return 0x820934BC;
		  /* 820934BCh */ case    7:  		/* mr R11, R4 */
		/* 820934BCh case    7:*/		regs.R11 = regs.R4;
		/* 820934BCh case    7:*/		return 0x820934C0;
		  /* 820934C0h */ case    8:  		/* lbz R10, <#[R11]> */
		/* 820934C0h case    8:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820934C0h case    8:*/		return 0x820934C4;
		  /* 820934C4h */ case    9:  		/* addi R11, R11, 1 */
		/* 820934C4h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820934C4h case    9:*/		return 0x820934C8;
	}
	return 0x820934C8;
} // Block from 820934A0h-820934C8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820934C8h
// Function '_getptd_noexit'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820934C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820934C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820934C8);
		  /* 820934C8h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 820934C8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820934C8h case    0:*/		return 0x820934CC;
		  /* 820934CCh */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 820934CCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820934C0;  }
		/* 820934CCh case    1:*/		return 0x820934D0;
		  /* 820934D0h */ case    2:  		/* subf R11, R30, R11 */
		/* 820934D0h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 820934D0h case    2:*/		return 0x820934D4;
		  /* 820934D4h */ case    3:  		/* addi R11, R11, -1 */
		/* 820934D4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820934D4h case    3:*/		return 0x820934D8;
		  /* 820934D8h */ case    4:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820934D8h case    4:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820934D8h case    4:*/		return 0x820934DC;
		  /* 820934DCh */ case    5:  		/* addi R31, R11, 1 */
		/* 820934DCh case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x1);
		/* 820934DCh case    5:*/		return 0x820934E0;
		  /* 820934E0h */ case    6:  		/* mr R3, R31 */
		/* 820934E0h case    6:*/		regs.R3 = regs.R31;
		/* 820934E0h case    6:*/		return 0x820934E4;
		  /* 820934E4h */ case    7:  		/* bl 932 */
		/* 820934E4h case    7:*/		regs.LR = 0x820934E8; return 0x82093888;
		/* 820934E4h case    7:*/		return 0x820934E8;
		  /* 820934E8h */ case    8:  		/* stw R3, <#[R29 + 4]> */
		/* 820934E8h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000004) );
		/* 820934E8h case    8:*/		return 0x820934EC;
		  /* 820934ECh */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820934ECh case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820934ECh case    9:*/		return 0x820934F0;
		  /* 820934F0h */ case   10:  		/* bc 12, CR0_EQ, 24 */
		/* 820934F0h case   10:*/		if ( regs.CR[0].eq ) { return 0x82093508;  }
		/* 820934F0h case   10:*/		return 0x820934F4;
		  /* 820934F4h */ case   11:  		/* mr R5, R30 */
		/* 820934F4h case   11:*/		regs.R5 = regs.R30;
		/* 820934F4h case   11:*/		return 0x820934F8;
		  /* 820934F8h */ case   12:  		/* mr R4, R31 */
		/* 820934F8h case   12:*/		regs.R4 = regs.R31;
		/* 820934F8h case   12:*/		return 0x820934FC;
		  /* 820934FCh */ case   13:  		/* bl 24324 */
		/* 820934FCh case   13:*/		regs.LR = 0x82093500; return 0x82099400;
		/* 820934FCh case   13:*/		return 0x82093500;
		  /* 82093500h */ case   14:  		/* li R11, 1 */
		/* 82093500h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82093500h case   14:*/		return 0x82093504;
		  /* 82093504h */ case   15:  		/* stb R11, <#[R29 + 8]> */
		/* 82093504h case   15:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82093504h case   15:*/		return 0x82093508;
	}
	return 0x82093508;
} // Block from 820934C8h-82093508h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82093508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093508);
		  /* 82093508h */ case    0:  		/* addi R1, R1, 112 */
		/* 82093508h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82093508h case    0:*/		return 0x8209350C;
		  /* 8209350Ch */ case    1:  		/* b -8800 */
		/* 8209350Ch case    1:*/		return 0x820912AC;
		/* 8209350Ch case    1:*/		return 0x82093510;
	}
	return 0x82093510;
} // Block from 82093508h-82093510h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82093510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093510);
		  /* 82093510h */ case    0:  		/* mfspr R12, LR */
		/* 82093510h case    0:*/		regs.R12 = regs.LR;
		/* 82093510h case    0:*/		return 0x82093514;
		  /* 82093514h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82093514h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093514h case    1:*/		return 0x82093518;
		  /* 82093518h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82093518h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82093518h case    2:*/		return 0x8209351C;
		  /* 8209351Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8209351Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209351Ch case    3:*/		return 0x82093520;
		  /* 82093520h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82093520h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82093520h case    4:*/		return 0x82093524;
		  /* 82093524h */ case    5:  		/* mr R31, R3 */
		/* 82093524h case    5:*/		regs.R31 = regs.R3;
		/* 82093524h case    5:*/		return 0x82093528;
		  /* 82093528h */ case    6:  		/* mr R30, R4 */
		/* 82093528h case    6:*/		regs.R30 = regs.R4;
		/* 82093528h case    6:*/		return 0x8209352C;
		  /* 8209352Ch */ case    7:  		/* cmplw CR6, R3, R4 */
		/* 8209352Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R4);
		/* 8209352Ch case    7:*/		return 0x82093530;
		  /* 82093530h */ case    8:  		/* bc 12, CR6_EQ, 72 */
		/* 82093530h case    8:*/		if ( regs.CR[6].eq ) { return 0x82093578;  }
		/* 82093530h case    8:*/		return 0x82093534;
		  /* 82093534h */ case    9:  		/* lbz R11, <#[R3 + 8]> */
		/* 82093534h case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82093534h case    9:*/		return 0x82093538;
		  /* 82093538h */ case   10:  		/* cmplwi CR0, R11, 0 */
		/* 82093538h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82093538h case   10:*/		return 0x8209353C;
		  /* 8209353Ch */ case   11:  		/* bc 12, CR0_EQ, 12 */
		/* 8209353Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x82093548;  }
		/* 8209353Ch case   11:*/		return 0x82093540;
		  /* 82093540h */ case   12:  		/* lwz R3, <#[R3 + 4]> */
		/* 82093540h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000004) );
		/* 82093540h case   12:*/		return 0x82093544;
		  /* 82093544h */ case   13:  		/* bl 740 */
		/* 82093544h case   13:*/		regs.LR = 0x82093548; return 0x82093828;
		/* 82093544h case   13:*/		return 0x82093548;
	}
	return 0x82093548;
} // Block from 82093510h-82093548h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82093548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093548);
		  /* 82093548h */ case    0:  		/* li R11, 0 */
		/* 82093548h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82093548h case    0:*/		return 0x8209354C;
		  /* 8209354Ch */ case    1:  		/* stb R11, <#[R31 + 8]> */
		/* 8209354Ch case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8209354Ch case    1:*/		return 0x82093550;
		  /* 82093550h */ case    2:  		/* stw R11, <#[R31 + 4]> */
		/* 82093550h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82093550h case    2:*/		return 0x82093554;
		  /* 82093554h */ case    3:  		/* lbz R11, <#[R30 + 8]> */
		/* 82093554h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82093554h case    3:*/		return 0x82093558;
		  /* 82093558h */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 82093558h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82093558h case    4:*/		return 0x8209355C;
		  /* 8209355Ch */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 8209355Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x82093570;  }
		/* 8209355Ch case    5:*/		return 0x82093560;
		  /* 82093560h */ case    6:  		/* mr R3, R31 */
		/* 82093560h case    6:*/		regs.R3 = regs.R31;
		/* 82093560h case    6:*/		return 0x82093564;
		  /* 82093564h */ case    7:  		/* lwz R4, <#[R30 + 4]> */
		/* 82093564h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000004) );
		/* 82093564h case    7:*/		return 0x82093568;
		  /* 82093568h */ case    8:  		/* bl -200 */
		/* 82093568h case    8:*/		regs.LR = 0x8209356C; return 0x820934A0;
		/* 82093568h case    8:*/		return 0x8209356C;
		  /* 8209356Ch */ case    9:  		/* b 12 */
		/* 8209356Ch case    9:*/		return 0x82093578;
		/* 8209356Ch case    9:*/		return 0x82093570;
	}
	return 0x82093570;
} // Block from 82093548h-82093570h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82093570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093570);
		  /* 82093570h */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 82093570h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82093570h case    0:*/		return 0x82093574;
		  /* 82093574h */ case    1:  		/* stw R11, <#[R31 + 4]> */
		/* 82093574h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82093574h case    1:*/		return 0x82093578;
	}
	return 0x82093578;
} // Block from 82093570h-82093578h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82093578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093578);
		  /* 82093578h */ case    0:  		/* mr R3, R31 */
		/* 82093578h case    0:*/		regs.R3 = regs.R31;
		/* 82093578h case    0:*/		return 0x8209357C;
		  /* 8209357Ch */ case    1:  		/* addi R1, R1, 112 */
		/* 8209357Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8209357Ch case    1:*/		return 0x82093580;
		  /* 82093580h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82093580h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093580h case    2:*/		return 0x82093584;
		  /* 82093584h */ case    3:  		/* mtspr LR, R12 */
		/* 82093584h case    3:*/		regs.LR = regs.R12;
		/* 82093584h case    3:*/		return 0x82093588;
		  /* 82093588h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 82093588h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82093588h case    4:*/		return 0x8209358C;
		  /* 8209358Ch */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 8209358Ch case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209358Ch case    5:*/		return 0x82093590;
		  /* 82093590h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82093590h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82093590h case    6:*/		return 0x82093594;
	}
	return 0x82093594;
} // Block from 82093578h-82093594h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82093594h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093594( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093594) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093594);
		  /* 82093594h */ case    0:  		/* nop */
		/* 82093594h case    0:*/		cpu::op::nop();
		/* 82093594h case    0:*/		return 0x82093598;
	}
	return 0x82093598;
} // Block from 82093594h-82093598h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093598);
		  /* 82093598h */ case    0:  		/* mfspr R12, LR */
		/* 82093598h case    0:*/		regs.R12 = regs.LR;
		/* 82093598h case    0:*/		return 0x8209359C;
		  /* 8209359Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209359Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209359Ch case    1:*/		return 0x820935A0;
	}
	return 0x820935A0;
} // Block from 82093598h-820935A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820935A0h
// Function '_getptd'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820935A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820935A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820935A0);
		  /* 820935A0h */ case    0:  		/* std R31, <#[R1 - 16]> */
		/* 820935A0h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820935A0h case    0:*/		return 0x820935A4;
		  /* 820935A4h */ case    1:  		/* stwu R1, <#[R1 - 96]> */
		/* 820935A4h case    1:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820935A4h case    1:*/		return 0x820935A8;
		  /* 820935A8h */ case    2:  		/* lis R11, -32255 */
		/* 820935A8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820935A8h case    2:*/		return 0x820935AC;
		  /* 820935ACh */ case    3:  		/* lbz R10, <#[R3 + 8]> */
		/* 820935ACh case    3:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820935ACh case    3:*/		return 0x820935B0;
		  /* 820935B0h */ case    4:  		/* mr R31, R3 */
		/* 820935B0h case    4:*/		regs.R31 = regs.R3;
		/* 820935B0h case    4:*/		return 0x820935B4;
		  /* 820935B4h */ case    5:  		/* addi R11, R11, -24480 */
		/* 820935B4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFA060);
		/* 820935B4h case    5:*/		return 0x820935B8;
		  /* 820935B8h */ case    6:  		/* cmplwi CR0, R10, 0 */
		/* 820935B8h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 820935B8h case    6:*/		return 0x820935BC;
		  /* 820935BCh */ case    7:  		/* stw R11, <#[R3]> */
		/* 820935BCh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820935BCh case    7:*/		return 0x820935C0;
		  /* 820935C0h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 820935C0h case    8:*/		if ( regs.CR[0].eq ) { return 0x820935CC;  }
		/* 820935C0h case    8:*/		return 0x820935C4;
		  /* 820935C4h */ case    9:  		/* lwz R3, <#[R3 + 4]> */
		/* 820935C4h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000004) );
		/* 820935C4h case    9:*/		return 0x820935C8;
		  /* 820935C8h */ case   10:  		/* bl 608 */
		/* 820935C8h case   10:*/		regs.LR = 0x820935CC; return 0x82093828;
		/* 820935C8h case   10:*/		return 0x820935CC;
	}
	return 0x820935CC;
} // Block from 820935A0h-820935CCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820935CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820935CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820935CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820935CC);
		  /* 820935CCh */ case    0:  		/* li R11, 0 */
		/* 820935CCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820935CCh case    0:*/		return 0x820935D0;
		  /* 820935D0h */ case    1:  		/* stw R11, <#[R31 + 4]> */
		/* 820935D0h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820935D0h case    1:*/		return 0x820935D4;
		  /* 820935D4h */ case    2:  		/* stb R11, <#[R31 + 8]> */
		/* 820935D4h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820935D4h case    2:*/		return 0x820935D8;
		  /* 820935D8h */ case    3:  		/* addi R1, R1, 96 */
		/* 820935D8h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820935D8h case    3:*/		return 0x820935DC;
		  /* 820935DCh */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 820935DCh case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820935DCh case    4:*/		return 0x820935E0;
	}
	return 0x820935E0;
} // Block from 820935CCh-820935E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820935E0h
// Function '_freefls'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820935E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820935E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820935E0);
		  /* 820935E0h */ case    0:  		/* mtspr LR, R12 */
		/* 820935E0h case    0:*/		regs.LR = regs.R12;
		/* 820935E0h case    0:*/		return 0x820935E4;
		  /* 820935E4h */ case    1:  		/* ld R31, <#[R1 - 16]> */
		/* 820935E4h case    1:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820935E4h case    1:*/		return 0x820935E8;
		  /* 820935E8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820935E8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820935E8h case    2:*/		return 0x820935EC;
	}
	return 0x820935EC;
} // Block from 820935E0h-820935ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820935ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820935EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820935EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820935EC);
		  /* 820935ECh */ case    0:  		/* nop */
		/* 820935ECh case    0:*/		cpu::op::nop();
		/* 820935ECh case    0:*/		return 0x820935F0;
	}
	return 0x820935F0;
} // Block from 820935ECh-820935F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820935F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820935F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820935F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820935F0);
		  /* 820935F0h */ case    0:  		/* lis R11, -32255 */
		/* 820935F0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820935F0h case    0:*/		return 0x820935F4;
		  /* 820935F4h */ case    1:  		/* addi R11, R11, -24452 */
		/* 820935F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFA07C);
		/* 820935F4h case    1:*/		return 0x820935F8;
		  /* 820935F8h */ case    2:  		/* stw R11, <#[R3]> */
		/* 820935F8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820935F8h case    2:*/		return 0x820935FC;
		  /* 820935FCh */ case    3:  		/* b -100 */
		/* 820935FCh case    3:*/		return 0x82093598;
		/* 820935FCh case    3:*/		return 0x82093600;
	}
	return 0x82093600;
} // Block from 820935F0h-82093600h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82093600h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093600);
		  /* 82093600h */ case    0:  		/* mfspr R12, LR */
		/* 82093600h case    0:*/		regs.R12 = regs.LR;
		/* 82093600h case    0:*/		return 0x82093604;
		  /* 82093604h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82093604h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093604h case    1:*/		return 0x82093608;
		  /* 82093608h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82093608h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82093608h case    2:*/		return 0x8209360C;
		  /* 8209360Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8209360Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209360Ch case    3:*/		return 0x82093610;
		  /* 82093610h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82093610h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82093610h case    4:*/		return 0x82093614;
		  /* 82093614h */ case    5:  		/* lis R11, -32255 */
		/* 82093614h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82093614h case    5:*/		return 0x82093618;
		  /* 82093618h */ case    6:  		/* mr R31, R3 */
		/* 82093618h case    6:*/		regs.R31 = regs.R3;
		/* 82093618h case    6:*/		return 0x8209361C;
		  /* 8209361Ch */ case    7:  		/* addi R11, R11, -24452 */
		/* 8209361Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFA07C);
		/* 8209361Ch case    7:*/		return 0x82093620;
		  /* 82093620h */ case    8:  		/* mr R30, R4 */
		/* 82093620h case    8:*/		regs.R30 = regs.R4;
		/* 82093620h case    8:*/		return 0x82093624;
		  /* 82093624h */ case    9:  		/* stw R11, <#[R3]> */
		/* 82093624h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82093624h case    9:*/		return 0x82093628;
		  /* 82093628h */ case   10:  		/* bl -144 */
		/* 82093628h case   10:*/		regs.LR = 0x8209362C; return 0x82093598;
		/* 82093628h case   10:*/		return 0x8209362C;
		  /* 8209362Ch */ case   11:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 8209362Ch case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 8209362Ch case   11:*/		return 0x82093630;
		  /* 82093630h */ case   12:  		/* bc 12, CR0_EQ, 12 */
		/* 82093630h case   12:*/		if ( regs.CR[0].eq ) { return 0x8209363C;  }
		/* 82093630h case   12:*/		return 0x82093634;
		  /* 82093634h */ case   13:  		/* mr R3, R31 */
		/* 82093634h case   13:*/		regs.R3 = regs.R31;
		/* 82093634h case   13:*/		return 0x82093638;
		  /* 82093638h */ case   14:  		/* bl -4816 */
		/* 82093638h case   14:*/		regs.LR = 0x8209363C; return 0x82092368;
		/* 82093638h case   14:*/		return 0x8209363C;
	}
	return 0x8209363C;
} // Block from 82093600h-8209363Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8209363Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209363C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209363C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209363C);
		  /* 8209363Ch */ case    0:  		/* mr R3, R31 */
		/* 8209363Ch case    0:*/		regs.R3 = regs.R31;
		/* 8209363Ch case    0:*/		return 0x82093640;
		  /* 82093640h */ case    1:  		/* addi R1, R1, 112 */
		/* 82093640h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82093640h case    1:*/		return 0x82093644;
		  /* 82093644h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82093644h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093644h case    2:*/		return 0x82093648;
		  /* 82093648h */ case    3:  		/* mtspr LR, R12 */
		/* 82093648h case    3:*/		regs.LR = regs.R12;
		/* 82093648h case    3:*/		return 0x8209364C;
		  /* 8209364Ch */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 8209364Ch case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209364Ch case    4:*/		return 0x82093650;
		  /* 82093650h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 82093650h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82093650h case    5:*/		return 0x82093654;
		  /* 82093654h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82093654h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82093654h case    6:*/		return 0x82093658;
	}
	return 0x82093658;
} // Block from 8209363Ch-82093658h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82093658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093658);
		  /* 82093658h */ case    0:  		/* mfspr R12, LR */
		/* 82093658h case    0:*/		regs.R12 = regs.LR;
		/* 82093658h case    0:*/		return 0x8209365C;
		  /* 8209365Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209365Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209365Ch case    1:*/		return 0x82093660;
		  /* 82093660h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82093660h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82093660h case    2:*/		return 0x82093664;
		  /* 82093664h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82093664h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82093664h case    3:*/		return 0x82093668;
		  /* 82093668h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82093668h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82093668h case    4:*/		return 0x8209366C;
		  /* 8209366Ch */ case    5:  		/* mr R31, R3 */
		/* 8209366Ch case    5:*/		regs.R31 = regs.R3;
		/* 8209366Ch case    5:*/		return 0x82093670;
		  /* 82093670h */ case    6:  		/* mr R30, R4 */
		/* 82093670h case    6:*/		regs.R30 = regs.R4;
		/* 82093670h case    6:*/		return 0x82093674;
		  /* 82093674h */ case    7:  		/* bl -220 */
		/* 82093674h case    7:*/		regs.LR = 0x82093678; return 0x82093598;
		/* 82093674h case    7:*/		return 0x82093678;
		  /* 82093678h */ case    8:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 82093678h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 82093678h case    8:*/		return 0x8209367C;
		  /* 8209367Ch */ case    9:  		/* bc 12, CR0_EQ, 12 */
		/* 8209367Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x82093688;  }
		/* 8209367Ch case    9:*/		return 0x82093680;
		  /* 82093680h */ case   10:  		/* mr R3, R31 */
		/* 82093680h case   10:*/		regs.R3 = regs.R31;
		/* 82093680h case   10:*/		return 0x82093684;
		  /* 82093684h */ case   11:  		/* bl -4892 */
		/* 82093684h case   11:*/		regs.LR = 0x82093688; return 0x82092368;
		/* 82093684h case   11:*/		return 0x82093688;
	}
	return 0x82093688;
} // Block from 82093658h-82093688h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82093688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093688);
		  /* 82093688h */ case    0:  		/* mr R3, R31 */
		/* 82093688h case    0:*/		regs.R3 = regs.R31;
		/* 82093688h case    0:*/		return 0x8209368C;
		  /* 8209368Ch */ case    1:  		/* addi R1, R1, 112 */
		/* 8209368Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8209368Ch case    1:*/		return 0x82093690;
		  /* 82093690h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82093690h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093690h case    2:*/		return 0x82093694;
		  /* 82093694h */ case    3:  		/* mtspr LR, R12 */
		/* 82093694h case    3:*/		regs.LR = regs.R12;
		/* 82093694h case    3:*/		return 0x82093698;
		  /* 82093698h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 82093698h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82093698h case    4:*/		return 0x8209369C;
		  /* 8209369Ch */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 8209369Ch case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209369Ch case    5:*/		return 0x820936A0;
	}
	return 0x820936A0;
} // Block from 82093688h-820936A0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820936A0h
// Function '_freeptd'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820936A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820936A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820936A0);
		  /* 820936A0h */ case    0:  		/* bclr 20, CR0_LT */
		/* 820936A0h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820936A0h case    0:*/		return 0x820936A4;
	}
	return 0x820936A4;
} // Block from 820936A0h-820936A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820936A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820936A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820936A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820936A4);
		  /* 820936A4h */ case    0:  		/* nop */
		/* 820936A4h case    0:*/		cpu::op::nop();
		/* 820936A4h case    0:*/		return 0x820936A8;
	}
	return 0x820936A8;
} // Block from 820936A4h-820936A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820936A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820936A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820936A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820936A8);
		  /* 820936A8h */ case    0:  		/* mfspr R12, LR */
		/* 820936A8h case    0:*/		regs.R12 = regs.LR;
		/* 820936A8h case    0:*/		return 0x820936AC;
		  /* 820936ACh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820936ACh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820936ACh case    1:*/		return 0x820936B0;
		  /* 820936B0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820936B0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820936B0h case    2:*/		return 0x820936B4;
		  /* 820936B4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820936B4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820936B4h case    3:*/		return 0x820936B8;
		  /* 820936B8h */ case    4:  		/* lis R10, -32255 */
		/* 820936B8h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820936B8h case    4:*/		return 0x820936BC;
		  /* 820936BCh */ case    5:  		/* li R11, 0 */
		/* 820936BCh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820936BCh case    5:*/		return 0x820936C0;
		  /* 820936C0h */ case    6:  		/* addi R10, R10, -24480 */
		/* 820936C0h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFA060);
		/* 820936C0h case    6:*/		return 0x820936C4;
		  /* 820936C4h */ case    7:  		/* stw R11, <#[R3 + 4]> */
		/* 820936C4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820936C4h case    7:*/		return 0x820936C8;
		  /* 820936C8h */ case    8:  		/* mr R31, R3 */
		/* 820936C8h case    8:*/		regs.R31 = regs.R3;
		/* 820936C8h case    8:*/		return 0x820936CC;
		  /* 820936CCh */ case    9:  		/* stw R10, <#[R3]> */
		/* 820936CCh case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820936CCh case    9:*/		return 0x820936D0;
		  /* 820936D0h */ case   10:  		/* stb R11, <#[R3 + 8]> */
		/* 820936D0h case   10:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820936D0h case   10:*/		return 0x820936D4;
		  /* 820936D4h */ case   11:  		/* bl -452 */
		/* 820936D4h case   11:*/		regs.LR = 0x820936D8; return 0x82093510;
		/* 820936D4h case   11:*/		return 0x820936D8;
		  /* 820936D8h */ case   12:  		/* mr R3, R31 */
		/* 820936D8h case   12:*/		regs.R3 = regs.R31;
		/* 820936D8h case   12:*/		return 0x820936DC;
		  /* 820936DCh */ case   13:  		/* addi R1, R1, 96 */
		/* 820936DCh case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820936DCh case   13:*/		return 0x820936E0;
		  /* 820936E0h */ case   14:  		/* lwz R12, <#[R1 - 8]> */
		/* 820936E0h case   14:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820936E0h case   14:*/		return 0x820936E4;
		  /* 820936E4h */ case   15:  		/* mtspr LR, R12 */
		/* 820936E4h case   15:*/		regs.LR = regs.R12;
		/* 820936E4h case   15:*/		return 0x820936E8;
		  /* 820936E8h */ case   16:  		/* ld R31, <#[R1 - 16]> */
		/* 820936E8h case   16:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820936E8h case   16:*/		return 0x820936EC;
		  /* 820936ECh */ case   17:  		/* bclr 20, CR0_LT */
		/* 820936ECh case   17:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820936ECh case   17:*/		return 0x820936F0;
	}
	return 0x820936F0;
} // Block from 820936A8h-820936F0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820936F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820936F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820936F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820936F0);
		  /* 820936F0h */ case    0:  		/* mfspr R12, LR */
		/* 820936F0h case    0:*/		regs.R12 = regs.LR;
		/* 820936F0h case    0:*/		return 0x820936F4;
		  /* 820936F4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820936F4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820936F4h case    1:*/		return 0x820936F8;
		  /* 820936F8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820936F8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820936F8h case    2:*/		return 0x820936FC;
		  /* 820936FCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820936FCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820936FCh case    3:*/		return 0x82093700;
		  /* 82093700h */ case    4:  		/* lis R10, -32255 */
		/* 82093700h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 82093700h case    4:*/		return 0x82093704;
		  /* 82093704h */ case    5:  		/* li R11, 0 */
		/* 82093704h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82093704h case    5:*/		return 0x82093708;
		  /* 82093708h */ case    6:  		/* addi R10, R10, -24480 */
		/* 82093708h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFA060);
		/* 82093708h case    6:*/		return 0x8209370C;
		  /* 8209370Ch */ case    7:  		/* stw R11, <#[R3 + 4]> */
		/* 8209370Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8209370Ch case    7:*/		return 0x82093710;
	}
	return 0x82093710;
} // Block from 820936F0h-82093710h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82093710h
// Function '_mtinit'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093710);
		  /* 82093710h */ case    0:  		/* mr R31, R3 */
		/* 82093710h case    0:*/		regs.R31 = regs.R3;
		/* 82093710h case    0:*/		return 0x82093714;
		  /* 82093714h */ case    1:  		/* stw R10, <#[R3]> */
		/* 82093714h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82093714h case    1:*/		return 0x82093718;
		  /* 82093718h */ case    2:  		/* stb R11, <#[R3 + 8]> */
		/* 82093718h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82093718h case    2:*/		return 0x8209371C;
		  /* 8209371Ch */ case    3:  		/* bl -524 */
		/* 8209371Ch case    3:*/		regs.LR = 0x82093720; return 0x82093510;
		/* 8209371Ch case    3:*/		return 0x82093720;
		  /* 82093720h */ case    4:  		/* lis R11, -32255 */
		/* 82093720h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82093720h case    4:*/		return 0x82093724;
		  /* 82093724h */ case    5:  		/* mr R3, R31 */
		/* 82093724h case    5:*/		regs.R3 = regs.R31;
		/* 82093724h case    5:*/		return 0x82093728;
		  /* 82093728h */ case    6:  		/* addi R11, R11, -24452 */
		/* 82093728h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFA07C);
		/* 82093728h case    6:*/		return 0x8209372C;
		  /* 8209372Ch */ case    7:  		/* stw R11, <#[R31]> */
		/* 8209372Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209372Ch case    7:*/		return 0x82093730;
		  /* 82093730h */ case    8:  		/* addi R1, R1, 96 */
		/* 82093730h case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82093730h case    8:*/		return 0x82093734;
		  /* 82093734h */ case    9:  		/* lwz R12, <#[R1 - 8]> */
		/* 82093734h case    9:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093734h case    9:*/		return 0x82093738;
		  /* 82093738h */ case   10:  		/* mtspr LR, R12 */
		/* 82093738h case   10:*/		regs.LR = regs.R12;
		/* 82093738h case   10:*/		return 0x8209373C;
		  /* 8209373Ch */ case   11:  		/* ld R31, <#[R1 - 16]> */
		/* 8209373Ch case   11:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209373Ch case   11:*/		return 0x82093740;
		  /* 82093740h */ case   12:  		/* bclr 20, CR0_LT */
		/* 82093740h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82093740h case   12:*/		return 0x82093744;
	}
	return 0x82093744;
} // Block from 82093710h-82093744h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82093744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093744);
		  /* 82093744h */ case    0:  		/* nop */
		/* 82093744h case    0:*/		cpu::op::nop();
		/* 82093744h case    0:*/		return 0x82093748;
	}
	return 0x82093748;
} // Block from 82093744h-82093748h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093748h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093748);
		  /* 82093748h */ case    0:  		/* mfspr R12, LR */
		/* 82093748h case    0:*/		regs.R12 = regs.LR;
		/* 82093748h case    0:*/		return 0x8209374C;
		  /* 8209374Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209374Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209374Ch case    1:*/		return 0x82093750;
		  /* 82093750h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82093750h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82093750h case    2:*/		return 0x82093754;
		  /* 82093754h */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 82093754h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82093754h case    3:*/		return 0x82093758;
		  /* 82093758h */ case    4:  		/* mr R31, R3 */
		/* 82093758h case    4:*/		regs.R31 = regs.R3;
		/* 82093758h case    4:*/		return 0x8209375C;
		  /* 8209375Ch */ case    5:  		/* b 20 */
		/* 8209375Ch case    5:*/		return 0x82093770;
		/* 8209375Ch case    5:*/		return 0x82093760;
		  /* 82093760h */ case    6:  		/* mr R3, R31 */
		/* 82093760h case    6:*/		regs.R3 = regs.R31;
		/* 82093760h case    6:*/		return 0x82093764;
		  /* 82093764h */ case    7:  		/* bl 23516 */
		/* 82093764h case    7:*/		regs.LR = 0x82093768; return 0x82099340;
		/* 82093764h case    7:*/		return 0x82093768;
		  /* 82093768h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 82093768h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82093768h case    8:*/		return 0x8209376C;
		  /* 8209376Ch */ case    9:  		/* bc 12, CR0_EQ, 40 */
		/* 8209376Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x82093794;  }
		/* 8209376Ch case    9:*/		return 0x82093770;
	}
	return 0x82093770;
} // Block from 82093748h-82093770h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82093770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093770);
		  /* 82093770h */ case    0:  		/* mr R3, R31 */
		/* 82093770h case    0:*/		regs.R3 = regs.R31;
		/* 82093770h case    0:*/		return 0x82093774;
		  /* 82093774h */ case    1:  		/* bl 276 */
		/* 82093774h case    1:*/		regs.LR = 0x82093778; return 0x82093888;
		/* 82093774h case    1:*/		return 0x82093778;
		  /* 82093778h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 82093778h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82093778h case    2:*/		return 0x8209377C;
		  /* 8209377Ch */ case    3:  		/* bc 12, CR0_EQ, -28 */
		/* 8209377Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x82093760;  }
		/* 8209377Ch case    3:*/		return 0x82093780;
		  /* 82093780h */ case    4:  		/* addi R1, R1, 112 */
		/* 82093780h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82093780h case    4:*/		return 0x82093784;
		  /* 82093784h */ case    5:  		/* lwz R12, <#[R1 - 8]> */
		/* 82093784h case    5:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093784h case    5:*/		return 0x82093788;
		  /* 82093788h */ case    6:  		/* mtspr LR, R12 */
		/* 82093788h case    6:*/		regs.LR = regs.R12;
		/* 82093788h case    6:*/		return 0x8209378C;
		  /* 8209378Ch */ case    7:  		/* ld R31, <#[R1 - 16]> */
		/* 8209378Ch case    7:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209378Ch case    7:*/		return 0x82093790;
		  /* 82093790h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82093790h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82093790h case    8:*/		return 0x82093794;
	}
	return 0x82093794;
} // Block from 82093770h-82093794h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82093794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093794);
		  /* 82093794h */ case    0:  		/* lis R7, -32215 */
		/* 82093794h case    0:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8229);
		/* 82093794h case    0:*/		return 0x82093798;
		  /* 82093798h */ case    1:  		/* lis R11, -32215 */
		/* 82093798h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82093798h case    1:*/		return 0x8209379C;
		  /* 8209379Ch */ case    2:  		/* addi R31, R11, -30708 */
		/* 8209379Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFF880C);
		/* 8209379Ch case    2:*/		return 0x820937A0;
		  /* 820937A0h */ case    3:  		/* lwz R8, <#[R7 - 30696]> */
		/* 820937A0h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + 0xFFFF8818) );
		/* 820937A0h case    3:*/		return 0x820937A4;
		  /* 820937A4h */ case    4:  		/* rlwinm. R11, R8, 0, 31, 31 */
		/* 820937A4h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R8);
		/* 820937A4h case    4:*/		return 0x820937A8;
		  /* 820937A8h */ case    5:  		/* bc 4, CR0_EQ, 56 */
		/* 820937A8h case    5:*/		if ( !regs.CR[0].eq ) { return 0x820937E0;  }
		/* 820937A8h case    5:*/		return 0x820937AC;
		  /* 820937ACh */ case    6:  		/* lis R10, -32255 */
		/* 820937ACh case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820937ACh case    6:*/		return 0x820937B0;
		  /* 820937B0h */ case    7:  		/* lis R11, -32255 */
		/* 820937B0h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820937B0h case    7:*/		return 0x820937B4;
		  /* 820937B4h */ case    8:  		/* addi R10, R10, -24444 */
		/* 820937B4h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFA084);
		/* 820937B4h case    8:*/		return 0x820937B8;
		  /* 820937B8h */ case    9:  		/* addi R9, R11, -24452 */
		/* 820937B8h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFA07C);
		/* 820937B8h case    9:*/		return 0x820937BC;
		  /* 820937BCh */ case   10:  		/* stw R10, <#[R31 + 4]> */
		/* 820937BCh case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820937BCh case   10:*/		return 0x820937C0;
		  /* 820937C0h */ case   11:  		/* ori R11, R8, 1 */
		/* 820937C0h case   11:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R8,0x1);
		/* 820937C0h case   11:*/		return 0x820937C4;
		  /* 820937C4h */ case   12:  		/* li R10, 0 */
		/* 820937C4h case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820937C4h case   12:*/		return 0x820937C8;
		  /* 820937C8h */ case   13:  		/* stw R9, <#[R31]> */
		/* 820937C8h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 820937C8h case   13:*/		return 0x820937CC;
		  /* 820937CCh */ case   14:  		/* stw R11, <#[R7 - 30696]> */
		/* 820937CCh case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0xFFFF8818) );
		/* 820937CCh case   14:*/		return 0x820937D0;
		  /* 820937D0h */ case   15:  		/* lis R11, -32217 */
		/* 820937D0h case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 820937D0h case   15:*/		return 0x820937D4;
		  /* 820937D4h */ case   16:  		/* stb R10, <#[R31 + 8]> */
		/* 820937D4h case   16:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820937D4h case   16:*/		return 0x820937D8;
		  /* 820937D8h */ case   17:  		/* addi R3, R11, -12640 */
		/* 820937D8h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFCEA0);
		/* 820937D8h case   17:*/		return 0x820937DC;
		  /* 820937DCh */ case   18:  		/* bl 1004 */
		/* 820937DCh case   18:*/		regs.LR = 0x820937E0; return 0x82093BC8;
		/* 820937DCh case   18:*/		return 0x820937E0;
	}
	return 0x820937E0;
} // Block from 82093794h-820937E0h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820937E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820937E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820937E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820937E0);
		  /* 820937E0h */ case    0:  		/* mr R4, R31 */
		/* 820937E0h case    0:*/		regs.R4 = regs.R31;
		/* 820937E0h case    0:*/		return 0x820937E4;
		  /* 820937E4h */ case    1:  		/* addi R3, R1, 80 */
		/* 820937E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820937E4h case    1:*/		return 0x820937E8;
		  /* 820937E8h */ case    2:  		/* bl -248 */
		/* 820937E8h case    2:*/		regs.LR = 0x820937EC; return 0x820936F0;
		/* 820937E8h case    2:*/		return 0x820937EC;
		  /* 820937ECh */ case    3:  		/* lis R11, -32251 */
		/* 820937ECh case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 820937ECh case    3:*/		return 0x820937F0;
	}
	return 0x820937F0;
} // Block from 820937E0h-820937F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820937F0h
// Function 'memcpy'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820937F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820937F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820937F0);
		  /* 820937F0h */ case    0:  		/* addi R3, R1, 80 */
		/* 820937F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820937F0h case    0:*/		return 0x820937F4;
		  /* 820937F4h */ case    1:  		/* addi R4, R11, -14868 */
		/* 820937F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC5EC);
		/* 820937F4h case    1:*/		return 0x820937F8;
		  /* 820937F8h */ case    2:  		/* bl 23744 */
		/* 820937F8h case    2:*/		regs.LR = 0x820937FC; return 0x820994B8;
		/* 820937F8h case    2:*/		return 0x820937FC;
		  /* 820937FCh */ case    3:  		/* nop */
		/* 820937FCh case    3:*/		cpu::op::nop();
		/* 820937FCh case    3:*/		return 0x82093800;
	}
	return 0x82093800;
} // Block from 820937F0h-82093800h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82093800h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093800);
		  /* 82093800h */ case    0:  		/* mr R11, R3 */
		/* 82093800h case    0:*/		regs.R11 = regs.R3;
		/* 82093800h case    0:*/		return 0x82093804;
		  /* 82093804h */ case    1:  		/* lhz R10, <#[R11]> */
		/* 82093804h case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82093804h case    1:*/		return 0x82093808;
		  /* 82093808h */ case    2:  		/* addi R11, R11, 2 */
		/* 82093808h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82093808h case    2:*/		return 0x8209380C;
		  /* 8209380Ch */ case    3:  		/* cmplwi CR0, R10, 0 */
		/* 8209380Ch case    3:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 8209380Ch case    3:*/		return 0x82093810;
		  /* 82093810h */ case    4:  		/* bc 4, CR0_EQ, -12 */
		/* 82093810h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82093804;  }
		/* 82093810h case    4:*/		return 0x82093814;
		  /* 82093814h */ case    5:  		/* subf R11, R3, R11 */
		/* 82093814h case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 82093814h case    5:*/		return 0x82093818;
		  /* 82093818h */ case    6:  		/* srawi R11, R11, 1 */
		/* 82093818h case    6:*/		cpu::op::srawi<0,1>(regs,&regs.R11,regs.R11);
		/* 82093818h case    6:*/		return 0x8209381C;
		  /* 8209381Ch */ case    7:  		/* addi R3, R11, -1 */
		/* 8209381Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFFF);
		/* 8209381Ch case    7:*/		return 0x82093820;
		  /* 82093820h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82093820h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82093820h case    8:*/		return 0x82093824;
	}
	return 0x82093824;
} // Block from 82093800h-82093824h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82093824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093824);
		  /* 82093824h */ case    0:  		/* nop */
		/* 82093824h case    0:*/		cpu::op::nop();
		/* 82093824h case    0:*/		return 0x82093828;
	}
	return 0x82093828;
} // Block from 82093824h-82093828h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093828h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093828);
		  /* 82093828h */ case    0:  		/* mfspr R12, LR */
		/* 82093828h case    0:*/		regs.R12 = regs.LR;
		/* 82093828h case    0:*/		return 0x8209382C;
		  /* 8209382Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209382Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209382Ch case    1:*/		return 0x82093830;
		  /* 82093830h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82093830h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82093830h case    2:*/		return 0x82093834;
		  /* 82093834h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82093834h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82093834h case    3:*/		return 0x82093838;
		  /* 82093838h */ case    4:  		/* mr R31, R3 */
		/* 82093838h case    4:*/		regs.R31 = regs.R3;
		/* 82093838h case    4:*/		return 0x8209383C;
		  /* 8209383Ch */ case    5:  		/* cmplwi CR6, R3, 0 */
		/* 8209383Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209383Ch case    5:*/		return 0x82093840;
		  /* 82093840h */ case    6:  		/* bc 12, CR6_EQ, 48 */
		/* 82093840h case    6:*/		if ( regs.CR[6].eq ) { return 0x82093870;  }
		/* 82093840h case    6:*/		return 0x82093844;
		  /* 82093844h */ case    7:  		/* bl -23316 */
		/* 82093844h case    7:*/		regs.LR = 0x82093848; return 0x8208DD30;
		/* 82093844h case    7:*/		return 0x82093848;
		  /* 82093848h */ case    8:  		/* li R4, 0 */
		/* 82093848h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82093848h case    8:*/		return 0x8209384C;
		  /* 8209384Ch */ case    9:  		/* mr R5, R31 */
		/* 8209384Ch case    9:*/		regs.R5 = regs.R31;
		/* 8209384Ch case    9:*/		return 0x82093850;
		  /* 82093850h */ case   10:  		/* bl -26688 */
		/* 82093850h case   10:*/		regs.LR = 0x82093854; return 0x8208D010;
		/* 82093850h case   10:*/		return 0x82093854;
		  /* 82093854h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 82093854h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82093854h case   11:*/		return 0x82093858;
		  /* 82093858h */ case   12:  		/* bc 4, CR0_EQ, 24 */
		/* 82093858h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82093870;  }
		/* 82093858h case   12:*/		return 0x8209385C;
		  /* 8209385Ch */ case   13:  		/* bl 5804 */
		/* 8209385Ch case   13:*/		regs.LR = 0x82093860; return 0x82094F08;
		/* 8209385Ch case   13:*/		return 0x82093860;
		  /* 82093860h */ case   14:  		/* mr R31, R3 */
		/* 82093860h case   14:*/		regs.R31 = regs.R3;
		/* 82093860h case   14:*/		return 0x82093864;
		  /* 82093864h */ case   15:  		/* bl -37220 */
		/* 82093864h case   15:*/		regs.LR = 0x82093868; return 0x8208A700;
		/* 82093864h case   15:*/		return 0x82093868;
		  /* 82093868h */ case   16:  		/* bl 5680 */
		/* 82093868h case   16:*/		regs.LR = 0x8209386C; return 0x82094E98;
		/* 82093868h case   16:*/		return 0x8209386C;
		  /* 8209386Ch */ case   17:  		/* stw R3, <#[R31]> */
		/* 8209386Ch case   17:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8209386Ch case   17:*/		return 0x82093870;
	}
	return 0x82093870;
} // Block from 82093828h-82093870h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82093870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093870);
		  /* 82093870h */ case    0:  		/* addi R1, R1, 96 */
		/* 82093870h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82093870h case    0:*/		return 0x82093874;
		  /* 82093874h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82093874h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093874h case    1:*/		return 0x82093878;
		  /* 82093878h */ case    2:  		/* mtspr LR, R12 */
		/* 82093878h case    2:*/		regs.LR = regs.R12;
		/* 82093878h case    2:*/		return 0x8209387C;
		  /* 8209387Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8209387Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209387Ch case    3:*/		return 0x82093880;
		  /* 82093880h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82093880h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82093880h case    4:*/		return 0x82093884;
	}
	return 0x82093884;
} // Block from 82093870h-82093884h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82093884h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093884( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093884) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093884);
		  /* 82093884h */ case    0:  		/* nop */
		/* 82093884h case    0:*/		cpu::op::nop();
		/* 82093884h case    0:*/		return 0x82093888;
	}
	return 0x82093888;
} // Block from 82093884h-82093888h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093888h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093888);
		  /* 82093888h */ case    0:  		/* mfspr R12, LR */
		/* 82093888h case    0:*/		regs.R12 = regs.LR;
		/* 82093888h case    0:*/		return 0x8209388C;
		  /* 8209388Ch */ case    1:  		/* bl -9780 */
		/* 8209388Ch case    1:*/		regs.LR = 0x82093890; return 0x82091258;
		/* 8209388Ch case    1:*/		return 0x82093890;
		  /* 82093890h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82093890h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82093890h case    2:*/		return 0x82093894;
		  /* 82093894h */ case    3:  		/* li R11, -4096 */
		/* 82093894h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFF000);
		/* 82093894h case    3:*/		return 0x82093898;
		  /* 82093898h */ case    4:  		/* mr R30, R3 */
		/* 82093898h case    4:*/		regs.R30 = regs.R3;
		/* 82093898h case    4:*/		return 0x8209389C;
		  /* 8209389Ch */ case    5:  		/* cmplw CR6, R3, R11 */
		/* 8209389Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8209389Ch case    5:*/		return 0x820938A0;
		  /* 820938A0h */ case    6:  		/* bc 12, CR6_GT, 140 */
		/* 820938A0h case    6:*/		if ( regs.CR[6].gt ) { return 0x8209392C;  }
		/* 820938A0h case    6:*/		return 0x820938A4;
		  /* 820938A4h */ case    7:  		/* lis R28, -32215 */
		/* 820938A4h case    7:*/		cpu::op::lis<0>(regs,&regs.R28,0xFFFF8229);
		/* 820938A4h case    7:*/		return 0x820938A8;
		  /* 820938A8h */ case    8:  		/* bl -23416 */
		/* 820938A8h case    8:*/		regs.LR = 0x820938AC; return 0x8208DD30;
		/* 820938A8h case    8:*/		return 0x820938AC;
		  /* 820938ACh */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820938ACh case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820938ACh case    9:*/		return 0x820938B0;
		  /* 820938B0h */ case   10:  		/* bc 4, CR0_EQ, 24 */
		/* 820938B0h case   10:*/		if ( !regs.CR[0].eq ) { return 0x820938C8;  }
		/* 820938B0h case   10:*/		return 0x820938B4;
		  /* 820938B4h */ case   11:  		/* bl 5044 */
		/* 820938B4h case   11:*/		regs.LR = 0x820938B8; return 0x82094C68;
		/* 820938B4h case   11:*/		return 0x820938B8;
		  /* 820938B8h */ case   12:  		/* li R3, 30 */
		/* 820938B8h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x1E);
		/* 820938B8h case   12:*/		return 0x820938BC;
		  /* 820938BCh */ case   13:  		/* bl 4988 */
		/* 820938BCh case   13:*/		regs.LR = 0x820938C0; return 0x82094C38;
		/* 820938BCh case   13:*/		return 0x820938C0;
		  /* 820938C0h */ case   14:  		/* li R3, 255 */
		/* 820938C0h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0xFF);
		/* 820938C0h case   14:*/		return 0x820938C4;
		  /* 820938C4h */ case   15:  		/* bl -2932 */
		/* 820938C4h case   15:*/		regs.LR = 0x820938C8; return 0x82092D50;
		/* 820938C4h case   15:*/		return 0x820938C8;
	}
	return 0x820938C8;
} // Block from 82093888h-820938C8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820938C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820938C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820938C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820938C8);
		  /* 820938C8h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820938C8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820938C8h case    0:*/		return 0x820938CC;
		  /* 820938CCh */ case    1:  		/* mr R31, R30 */
		/* 820938CCh case    1:*/		regs.R31 = regs.R30;
		/* 820938CCh case    1:*/		return 0x820938D0;
		  /* 820938D0h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820938D0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820938D8;  }
		/* 820938D0h case    2:*/		return 0x820938D4;
		  /* 820938D4h */ case    3:  		/* li R31, 1 */
		/* 820938D4h case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 820938D4h case    3:*/		return 0x820938D8;
	}
	return 0x820938D8;
} // Block from 820938C8h-820938D8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820938D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820938D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820938D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820938D8);
		  /* 820938D8h */ case    0:  		/* bl -23464 */
		/* 820938D8h case    0:*/		regs.LR = 0x820938DC; return 0x8208DD30;
		/* 820938D8h case    0:*/		return 0x820938DC;
		  /* 820938DCh */ case    1:  		/* li R4, 0 */
		/* 820938DCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820938DCh case    1:*/		return 0x820938E0;
		  /* 820938E0h */ case    2:  		/* mr R5, R31 */
		/* 820938E0h case    2:*/		regs.R5 = regs.R31;
		/* 820938E0h case    2:*/		return 0x820938E4;
		  /* 820938E4h */ case    3:  		/* bl -29132 */
		/* 820938E4h case    3:*/		regs.LR = 0x820938E8; return 0x8208C718;
		/* 820938E4h case    3:*/		return 0x820938E8;
		  /* 820938E8h */ case    4:  		/* or. R29, R3, R3 */
		/* 820938E8h case    4:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820938E8h case    4:*/		return 0x820938EC;
		  /* 820938ECh */ case    5:  		/* bc 4, CR0_EQ, 56 */
		/* 820938ECh case    5:*/		if ( !regs.CR[0].eq ) { return 0x82093924;  }
		/* 820938ECh case    5:*/		return 0x820938F0;
		  /* 820938F0h */ case    6:  		/* lwz R11, <#[R28 - 30280]> */
		/* 820938F0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0xFFFF89B8) );
		/* 820938F0h case    6:*/		return 0x820938F4;
		  /* 820938F4h */ case    7:  		/* li R31, 12 */
		/* 820938F4h case    7:*/		cpu::op::li<0>(regs,&regs.R31,0xC);
		/* 820938F4h case    7:*/		return 0x820938F8;
		  /* 820938F8h */ case    8:  		/* cmpwi CR6, R11, 0 */
		/* 820938F8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820938F8h case    8:*/		return 0x820938FC;
		  /* 820938FCh */ case    9:  		/* bc 12, CR6_EQ, 24 */
		/* 820938FCh case    9:*/		if ( regs.CR[6].eq ) { return 0x82093914;  }
		/* 820938FCh case    9:*/		return 0x82093900;
		  /* 82093900h */ case   10:  		/* mr R3, R30 */
		/* 82093900h case   10:*/		regs.R3 = regs.R30;
		/* 82093900h case   10:*/		return 0x82093904;
		  /* 82093904h */ case   11:  		/* bl 23100 */
		/* 82093904h case   11:*/		regs.LR = 0x82093908; return 0x82099340;
		/* 82093904h case   11:*/		return 0x82093908;
		  /* 82093908h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 82093908h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82093908h case   12:*/		return 0x8209390C;
		  /* 8209390Ch */ case   13:  		/* bc 4, CR0_EQ, -100 */
		/* 8209390Ch case   13:*/		if ( !regs.CR[0].eq ) { return 0x820938A8;  }
		/* 8209390Ch case   13:*/		return 0x82093910;
		  /* 82093910h */ case   14:  		/* b 12 */
		/* 82093910h case   14:*/		return 0x8209391C;
		/* 82093910h case   14:*/		return 0x82093914;
	}
	return 0x82093914;
} // Block from 820938D8h-82093914h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82093914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093914);
		  /* 82093914h */ case    0:  		/* bl 5620 */
		/* 82093914h case    0:*/		regs.LR = 0x82093918; return 0x82094F08;
		/* 82093914h case    0:*/		return 0x82093918;
		  /* 82093918h */ case    1:  		/* stw R31, <#[R3]> */
		/* 82093918h case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82093918h case    1:*/		return 0x8209391C;
	}
	return 0x8209391C;
} // Block from 82093914h-8209391Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209391Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209391C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209391C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209391C);
		  /* 8209391Ch */ case    0:  		/* bl 5612 */
		/* 8209391Ch case    0:*/		regs.LR = 0x82093920; return 0x82094F08;
		/* 8209391Ch case    0:*/		return 0x82093920;
		  /* 82093920h */ case    1:  		/* stw R31, <#[R3]> */
		/* 82093920h case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82093920h case    1:*/		return 0x82093924;
	}
	return 0x82093924;
} // Block from 8209391Ch-82093924h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82093924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093924);
		  /* 82093924h */ case    0:  		/* mr R3, R29 */
		/* 82093924h case    0:*/		regs.R3 = regs.R29;
		/* 82093924h case    0:*/		return 0x82093928;
		  /* 82093928h */ case    1:  		/* b 32 */
		/* 82093928h case    1:*/		return 0x82093948;
		/* 82093928h case    1:*/		return 0x8209392C;
	}
	return 0x8209392C;
} // Block from 82093924h-8209392Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209392Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209392C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209392C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209392C);
		  /* 8209392Ch */ case    0:  		/* mr R3, R30 */
		/* 8209392Ch case    0:*/		regs.R3 = regs.R30;
		/* 8209392Ch case    0:*/		return 0x82093930;
		  /* 82093930h */ case    1:  		/* bl 23056 */
		/* 82093930h case    1:*/		regs.LR = 0x82093934; return 0x82099340;
		/* 82093930h case    1:*/		return 0x82093934;
		  /* 82093934h */ case    2:  		/* bl 5588 */
		/* 82093934h case    2:*/		regs.LR = 0x82093938; return 0x82094F08;
		/* 82093934h case    2:*/		return 0x82093938;
		  /* 82093938h */ case    3:  		/* mr R11, R3 */
		/* 82093938h case    3:*/		regs.R11 = regs.R3;
		/* 82093938h case    3:*/		return 0x8209393C;
		  /* 8209393Ch */ case    4:  		/* li R10, 12 */
		/* 8209393Ch case    4:*/		cpu::op::li<0>(regs,&regs.R10,0xC);
		/* 8209393Ch case    4:*/		return 0x82093940;
		  /* 82093940h */ case    5:  		/* li R3, 0 */
		/* 82093940h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82093940h case    5:*/		return 0x82093944;
		  /* 82093944h */ case    6:  		/* stw R10, <#[R11]> */
		/* 82093944h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82093944h case    6:*/		return 0x82093948;
	}
	return 0x82093948;
} // Block from 8209392Ch-82093948h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82093948h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093948( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093948) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093948);
		  /* 82093948h */ case    0:  		/* addi R1, R1, 128 */
		/* 82093948h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82093948h case    0:*/		return 0x8209394C;
		  /* 8209394Ch */ case    1:  		/* b -9892 */
		/* 8209394Ch case    1:*/		return 0x820912A8;
		/* 8209394Ch case    1:*/		return 0x82093950;
	}
	return 0x82093950;
} // Block from 82093948h-82093950h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82093950h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093950);
		  /* 82093950h */ case    0:  		/* lis R11, -32215 */
		/* 82093950h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82093950h case    0:*/		return 0x82093954;
		  /* 82093954h */ case    1:  		/* stw R3, <#[R11 - 30692]> */
		/* 82093954h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0xFFFF881C) );
		/* 82093954h case    1:*/		return 0x82093958;
		  /* 82093958h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82093958h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82093958h case    2:*/		return 0x8209395C;
	}
	return 0x8209395C;
} // Block from 82093950h-8209395Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209395Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209395C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209395C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209395C);
		  /* 8209395Ch */ case    0:  		/* nop */
		/* 8209395Ch case    0:*/		cpu::op::nop();
		/* 8209395Ch case    0:*/		return 0x82093960;
	}
	return 0x82093960;
} // Block from 8209395Ch-82093960h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093960h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093960);
		  /* 82093960h */ case    0:  		/* lis R11, -32215 */
		/* 82093960h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82093960h case    0:*/		return 0x82093964;
		  /* 82093964h */ case    1:  		/* lwz R11, <#[R11 - 30692]> */
		/* 82093964h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFF881C) );
		/* 82093964h case    1:*/		return 0x82093968;
		  /* 82093968h */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 82093968h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82093968h case    2:*/		return 0x8209396C;
		  /* 8209396Ch */ case    3:  		/* bc 12, CR0_EQ, 32 */
		/* 8209396Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x8209398C;  }
		/* 8209396Ch case    3:*/		return 0x82093970;
		  /* 82093970h */ case    4:  		/* li R7, 0 */
		/* 82093970h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82093970h case    4:*/		return 0x82093974;
		  /* 82093974h */ case    5:  		/* mtspr CTR, R11 */
		/* 82093974h case    5:*/		regs.CTR = regs.R11;
		/* 82093974h case    5:*/		return 0x82093978;
		  /* 82093978h */ case    6:  		/* li R6, 0 */
		/* 82093978h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82093978h case    6:*/		return 0x8209397C;
		  /* 8209397Ch */ case    7:  		/* li R5, 0 */
		/* 8209397Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8209397Ch case    7:*/		return 0x82093980;
		  /* 82093980h */ case    8:  		/* li R4, 0 */
		/* 82093980h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82093980h case    8:*/		return 0x82093984;
		  /* 82093984h */ case    9:  		/* li R3, 0 */
		/* 82093984h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82093984h case    9:*/		return 0x82093988;
		  /* 82093988h */ case   10:  		/* bcctr 20, CR0_LT */
		/* 82093988h case   10:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 82093988h case   10:*/		return 0x8209398C;
	}
	return 0x8209398C;
} // Block from 82093960h-8209398Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209398Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209398C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209398C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209398C);
		  /* 8209398Ch */ case    0:  		/* twi 31, R0, 22 */
		/* 8209398Ch case    0:*/		cpu::op::trap(regs, 0x8209398C, regs.R0, 0x00000016);
		/* 8209398Ch case    0:*/		return 0x82093990;
		  /* 82093990h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82093990h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82093990h case    1:*/		return 0x82093994;
	}
	return 0x82093994;
} // Block from 8209398Ch-82093994h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82093994h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093994( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093994) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093994);
		  /* 82093994h */ case    0:  		/* nop */
		/* 82093994h case    0:*/		cpu::op::nop();
		/* 82093994h case    0:*/		return 0x82093998;
	}
	return 0x82093998;
} // Block from 82093994h-82093998h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093998);
		  /* 82093998h */ case    0:  		/* mfspr R12, LR */
		/* 82093998h case    0:*/		regs.R12 = regs.LR;
		/* 82093998h case    0:*/		return 0x8209399C;
		  /* 8209399Ch */ case    1:  		/* bl -10048 */
		/* 8209399Ch case    1:*/		regs.LR = 0x820939A0; return 0x8209125C;
		/* 8209399Ch case    1:*/		return 0x820939A0;
		  /* 820939A0h */ case    2:  		/* stwu R1, <#[R1 - 2832]> */
		/* 820939A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFF4F0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFF4F0);
		/* 820939A0h case    2:*/		return 0x820939A4;
		  /* 820939A4h */ case    3:  		/* mr R31, R3 */
		/* 820939A4h case    3:*/		regs.R31 = regs.R3;
		/* 820939A4h case    3:*/		return 0x820939A8;
		  /* 820939A8h */ case    4:  		/* mr R30, R4 */
		/* 820939A8h case    4:*/		regs.R30 = regs.R4;
		/* 820939A8h case    4:*/		return 0x820939AC;
		  /* 820939ACh */ case    5:  		/* mr R29, R5 */
		/* 820939ACh case    5:*/		regs.R29 = regs.R5;
		/* 820939ACh case    5:*/		return 0x820939B0;
		  /* 820939B0h */ case    6:  		/* cmpwi CR6, R3, -1 */
		/* 820939B0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820939B0h case    6:*/		return 0x820939B4;
		  /* 820939B4h */ case    7:  		/* bc 12, CR6_EQ, 8 */
		/* 820939B4h case    7:*/		if ( regs.CR[6].eq ) { return 0x820939BC;  }
		/* 820939B4h case    7:*/		return 0x820939B8;
		  /* 820939B8h */ case    8:  		/* bl 23520 */
		/* 820939B8h case    8:*/		regs.LR = 0x820939BC; return 0x82099598;
		/* 820939B8h case    8:*/		return 0x820939BC;
	}
	return 0x820939BC;
} // Block from 82093998h-820939BCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820939BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820939BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820939BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820939BC);
		  /* 820939BCh */ case    0:  		/* li R11, 0 */
		/* 820939BCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820939BCh case    0:*/		return 0x820939C0;
		  /* 820939C0h */ case    1:  		/* li R5, 76 */
		/* 820939C0h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x4C);
		/* 820939C0h case    1:*/		return 0x820939C4;
		  /* 820939C4h */ case    2:  		/* li R4, 0 */
		/* 820939C4h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820939C4h case    2:*/		return 0x820939C8;
		  /* 820939C8h */ case    3:  		/* stw R11, <#[R1 + 96]> */
		/* 820939C8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820939C8h case    3:*/		return 0x820939CC;
		  /* 820939CCh */ case    4:  		/* addi R3, R1, 100 */
		/* 820939CCh case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x64);
		/* 820939CCh case    4:*/		return 0x820939D0;
		  /* 820939D0h */ case    5:  		/* bl -9872 */
		/* 820939D0h case    5:*/		regs.LR = 0x820939D4; return 0x82091340;
		/* 820939D0h case    5:*/		return 0x820939D4;
		  /* 820939D4h */ case    6:  		/* addi R11, R1, 96 */
		/* 820939D4h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 820939D4h case    6:*/		return 0x820939D8;
		  /* 820939D8h */ case    7:  		/* addi R10, R1, 176 */
		/* 820939D8h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xB0);
		/* 820939D8h case    7:*/		return 0x820939DC;
		  /* 820939DCh */ case    8:  		/* li R5, 2624 */
		/* 820939DCh case    8:*/		cpu::op::li<0>(regs,&regs.R5,0xA40);
		/* 820939DCh case    8:*/		return 0x820939E0;
		  /* 820939E0h */ case    9:  		/* stw R11, <#[R1 + 80]> */
		/* 820939E0h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820939E0h case    9:*/		return 0x820939E4;
		  /* 820939E4h */ case   10:  		/* li R4, 0 */
		/* 820939E4h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820939E4h case   10:*/		return 0x820939E8;
		  /* 820939E8h */ case   11:  		/* stw R10, <#[R1 + 84]> */
		/* 820939E8h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 820939E8h case   11:*/		return 0x820939EC;
		  /* 820939ECh */ case   12:  		/* addi R3, R1, 176 */
		/* 820939ECh case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xB0);
		/* 820939ECh case   12:*/		return 0x820939F0;
		  /* 820939F0h */ case   13:  		/* bl -9904 */
		/* 820939F0h case   13:*/		regs.LR = 0x820939F4; return 0x82091340;
		/* 820939F0h case   13:*/		return 0x820939F4;
		  /* 820939F4h */ case   14:  		/* lwz R11, <#[R1 + 2824]> */
		/* 820939F4h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000B08) );
		/* 820939F4h case   14:*/		return 0x820939F8;
		  /* 820939F8h */ case   15:  		/* stw R30, <#[R1 + 96]> */
		/* 820939F8h case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000060) );
		/* 820939F8h case   15:*/		return 0x820939FC;
		  /* 820939FCh */ case   16:  		/* li R3, 0 */
		/* 820939FCh case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820939FCh case   16:*/		return 0x82093A00;
		  /* 82093A00h */ case   17:  		/* stw R29, <#[R1 + 100]> */
		/* 82093A00h case   17:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000064) );
		/* 82093A00h case   17:*/		return 0x82093A04;
		  /* 82093A04h */ case   18:  		/* stw R11, <#[R1 + 108]> */
		/* 82093A04h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 82093A04h case   18:*/		return 0x82093A08;
		  /* 82093A08h */ case   19:  		/* bl -43808 */
		/* 82093A08h case   19:*/		regs.LR = 0x82093A0C; return 0x82088EE8;
		/* 82093A08h case   19:*/		return 0x82093A0C;
		  /* 82093A0Ch */ case   20:  		/* addi R3, R1, 80 */
		/* 82093A0Ch case   20:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82093A0Ch case   20:*/		return 0x82093A10;
		  /* 82093A10h */ case   21:  		/* bl -43616 */
		/* 82093A10h case   21:*/		regs.LR = 0x82093A14; return 0x82088FB0;
		/* 82093A10h case   21:*/		return 0x82093A14;
		  /* 82093A14h */ case   22:  		/* cmplwi CR0, R3, 0 */
		/* 82093A14h case   22:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82093A14h case   22:*/		return 0x82093A18;
		  /* 82093A18h */ case   23:  		/* bc 4, CR0_EQ, 20 */
		/* 82093A18h case   23:*/		if ( !regs.CR[0].eq ) { return 0x82093A2C;  }
		/* 82093A18h case   23:*/		return 0x82093A1C;
		  /* 82093A1Ch */ case   24:  		/* cmpwi CR6, R31, -1 */
		/* 82093A1Ch case   24:*/		cpu::op::cmpwi<6>(regs,regs.R31,0xFFFFFFFF);
		/* 82093A1Ch case   24:*/		return 0x82093A20;
		  /* 82093A20h */ case   25:  		/* bc 12, CR6_EQ, 12 */
		/* 82093A20h case   25:*/		if ( regs.CR[6].eq ) { return 0x82093A2C;  }
		/* 82093A20h case   25:*/		return 0x82093A24;
		  /* 82093A24h */ case   26:  		/* mr R3, R31 */
		/* 82093A24h case   26:*/		regs.R3 = regs.R31;
		/* 82093A24h case   26:*/		return 0x82093A28;
		  /* 82093A28h */ case   27:  		/* bl 23408 */
		/* 82093A28h case   27:*/		regs.LR = 0x82093A2C; return 0x82099598;
		/* 82093A28h case   27:*/		return 0x82093A2C;
	}
	return 0x82093A2C;
} // Block from 820939BCh-82093A2Ch (28 instructions)

//////////////////////////////////////////////////////
// Block at 82093A2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093A2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093A2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093A2C);
		  /* 82093A2Ch */ case    0:  		/* addi R1, R1, 2832 */
		/* 82093A2Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB10);
		/* 82093A2Ch case    0:*/		return 0x82093A30;
		  /* 82093A30h */ case    1:  		/* b -10116 */
		/* 82093A30h case    1:*/		return 0x820912AC;
		/* 82093A30h case    1:*/		return 0x82093A34;
		  /* 82093A34h */ case    2:  		/* nop */
		/* 82093A34h case    2:*/		cpu::op::nop();
		/* 82093A34h case    2:*/		return 0x82093A38;
	}
	return 0x82093A38;
} // Block from 82093A2Ch-82093A38h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82093A38h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093A38);
		  /* 82093A38h */ case    0:  		/* mfspr R12, LR */
		/* 82093A38h case    0:*/		regs.R12 = regs.LR;
		/* 82093A38h case    0:*/		return 0x82093A3C;
		  /* 82093A3Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82093A3Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093A3Ch case    1:*/		return 0x82093A40;
		  /* 82093A40h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82093A40h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82093A40h case    2:*/		return 0x82093A44;
		  /* 82093A44h */ case    3:  		/* lis R4, -16384 */
		/* 82093A44h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFC000);
		/* 82093A44h case    3:*/		return 0x82093A48;
		  /* 82093A48h */ case    4:  		/* li R5, 1 */
		/* 82093A48h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82093A48h case    4:*/		return 0x82093A4C;
		  /* 82093A4Ch */ case    5:  		/* ori R4, R4, 1047 */
		/* 82093A4Ch case    5:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x417);
		/* 82093A4Ch case    5:*/		return 0x82093A50;
		  /* 82093A50h */ case    6:  		/* li R3, 2 */
		/* 82093A50h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 82093A50h case    6:*/		return 0x82093A54;
		  /* 82093A54h */ case    7:  		/* bl -188 */
		/* 82093A54h case    7:*/		regs.LR = 0x82093A58; return 0x82093998;
		/* 82093A54h case    7:*/		return 0x82093A58;
		  /* 82093A58h */ case    8:  		/* li R3, 30 */
		/* 82093A58h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x1E);
		/* 82093A58h case    8:*/		return 0x82093A5C;
		  /* 82093A5Ch */ case    9:  		/* bl 1939372 */
		/* 82093A5Ch case    9:*/		regs.LR = 0x82093A60; return 0x8226D208;
		/* 82093A5Ch case    9:*/		return 0x82093A60;
	}
	return 0x82093A60;
} // Block from 82093A38h-82093A60h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82093A60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093A60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093A60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093A60);
		  /* 82093A60h */ case    0:  		/* mfspr R12, LR */
		/* 82093A60h case    0:*/		regs.R12 = regs.LR;
		/* 82093A60h case    0:*/		return 0x82093A64;
		  /* 82093A64h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82093A64h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093A64h case    1:*/		return 0x82093A68;
		  /* 82093A68h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82093A68h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82093A68h case    2:*/		return 0x82093A6C;
		  /* 82093A6Ch */ case    3:  		/* li R4, 4 */
		/* 82093A6Ch case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 82093A6Ch case    3:*/		return 0x82093A70;
		  /* 82093A70h */ case    4:  		/* li R3, 32 */
		/* 82093A70h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x20);
		/* 82093A70h case    4:*/		return 0x82093A74;
		  /* 82093A74h */ case    5:  		/* bl 22804 */
		/* 82093A74h case    5:*/		regs.LR = 0x82093A78; return 0x82099388;
		/* 82093A74h case    5:*/		return 0x82093A78;
		  /* 82093A78h */ case    6:  		/* lis R10, -32215 */
		/* 82093A78h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 82093A78h case    6:*/		return 0x82093A7C;
		  /* 82093A7Ch */ case    7:  		/* lis R9, -32215 */
		/* 82093A7Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8229);
		/* 82093A7Ch case    7:*/		return 0x82093A80;
		  /* 82093A80h */ case    8:  		/* or. R11, R3, R3 */
		/* 82093A80h case    8:*/		cpu::op::or<1>(regs,&regs.R11,regs.R3,regs.R3);
		/* 82093A80h case    8:*/		return 0x82093A84;
		  /* 82093A84h */ case    9:  		/* stw R11, <#[R10 - 25240]> */
		/* 82093A84h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0xFFFF9D68) );
		/* 82093A84h case    9:*/		return 0x82093A88;
		  /* 82093A88h */ case   10:  		/* stw R11, <#[R9 - 25244]> */
		/* 82093A88h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0xFFFF9D64) );
		/* 82093A88h case   10:*/		return 0x82093A8C;
		  /* 82093A8Ch */ case   11:  		/* bc 4, CR0_EQ, 12 */
		/* 82093A8Ch case   11:*/		if ( !regs.CR[0].eq ) { return 0x82093A98;  }
		/* 82093A8Ch case   11:*/		return 0x82093A90;
		  /* 82093A90h */ case   12:  		/* li R3, 24 */
		/* 82093A90h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x18);
		/* 82093A90h case   12:*/		return 0x82093A94;
		  /* 82093A94h */ case   13:  		/* b 16 */
		/* 82093A94h case   13:*/		return 0x82093AA4;
		/* 82093A94h case   13:*/		return 0x82093A98;
	}
	return 0x82093A98;
} // Block from 82093A60h-82093A98h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82093A98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093A98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093A98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093A98);
		  /* 82093A98h */ case    0:  		/* li R10, 0 */
		/* 82093A98h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82093A98h case    0:*/		return 0x82093A9C;
		  /* 82093A9Ch */ case    1:  		/* li R3, 0 */
		/* 82093A9Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82093A9Ch case    1:*/		return 0x82093AA0;
		  /* 82093AA0h */ case    2:  		/* stw R10, <#[R11]> */
		/* 82093AA0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82093AA0h case    2:*/		return 0x82093AA4;
	}
	return 0x82093AA4;
} // Block from 82093A98h-82093AA4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82093AA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093AA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093AA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093AA4);
		  /* 82093AA4h */ case    0:  		/* addi R1, R1, 96 */
		/* 82093AA4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82093AA4h case    0:*/		return 0x82093AA8;
		  /* 82093AA8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82093AA8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093AA8h case    1:*/		return 0x82093AAC;
		  /* 82093AACh */ case    2:  		/* mtspr LR, R12 */
		/* 82093AACh case    2:*/		regs.LR = regs.R12;
		/* 82093AACh case    2:*/		return 0x82093AB0;
		  /* 82093AB0h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82093AB0h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82093AB0h case    3:*/		return 0x82093AB4;
	}
	return 0x82093AB4;
} // Block from 82093AA4h-82093AB4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82093AB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093AB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093AB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093AB4);
		  /* 82093AB4h */ case    0:  		/* nop */
		/* 82093AB4h case    0:*/		cpu::op::nop();
		/* 82093AB4h case    0:*/		return 0x82093AB8;
		  /* 82093AB8h */ case    1:  		/* lwz R17, <#[R6 - 11576]> */
		/* 82093AB8h case    1:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 82093AB8h case    1:*/		return 0x82093ABC;
		  /* 82093ABCh */ case    2:  		/* lwz R16, <#[R4 - 15424]> */
		/* 82093ABCh case    2:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC3C0) );
		/* 82093ABCh case    2:*/		return 0x82093AC0;
	}
	return 0x82093AC0;
} // Block from 82093AB4h-82093AC0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82093AC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093AC0);
		  /* 82093AC0h */ case    0:  		/* mfspr R12, LR */
		/* 82093AC0h case    0:*/		regs.R12 = regs.LR;
		/* 82093AC0h case    0:*/		return 0x82093AC4;
		  /* 82093AC4h */ case    1:  		/* bl -10368 */
		/* 82093AC4h case    1:*/		regs.LR = 0x82093AC8; return 0x82091244;
		/* 82093AC4h case    1:*/		return 0x82093AC8;
		  /* 82093AC8h */ case    2:  		/* addi R31, R1, -176 */
		/* 82093AC8h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFF50);
		/* 82093AC8h case    2:*/		return 0x82093ACC;
		  /* 82093ACCh */ case    3:  		/* stwu R1, <#[R1 - 176]> */
		/* 82093ACCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82093ACCh case    3:*/		return 0x82093AD0;
		  /* 82093AD0h */ case    4:  		/* mr R23, R3 */
		/* 82093AD0h case    4:*/		regs.R23 = regs.R3;
		/* 82093AD0h case    4:*/		return 0x82093AD4;
		  /* 82093AD4h */ case    5:  		/* bl -3452 */
		/* 82093AD4h case    5:*/		regs.LR = 0x82093AD8; return 0x82092D58;
		/* 82093AD4h case    5:*/		return 0x82093AD8;
		  /* 82093AD8h */ case    6:  		/* nop */
		/* 82093AD8h case    6:*/		cpu::op::nop();
		/* 82093AD8h case    6:*/		return 0x82093ADC;
	}
	return 0x82093ADC;
} // Block from 82093AC0h-82093ADCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 82093ADCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093ADC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093ADC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093ADC);
		  /* 82093ADCh */ case    0:  		/* lis R24, -32215 */
		/* 82093ADCh case    0:*/		cpu::op::lis<0>(regs,&regs.R24,0xFFFF8229);
		/* 82093ADCh case    0:*/		return 0x82093AE0;
		  /* 82093AE0h */ case    1:  		/* lis R25, -32215 */
		/* 82093AE0h case    1:*/		cpu::op::lis<0>(regs,&regs.R25,0xFFFF8229);
		/* 82093AE0h case    1:*/		return 0x82093AE4;
		  /* 82093AE4h */ case    2:  		/* lwz R30, <#[R24 - 25244]> */
		/* 82093AE4h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R24 + 0xFFFF9D64) );
		/* 82093AE4h case    2:*/		return 0x82093AE8;
		  /* 82093AE8h */ case    3:  		/* lwz R28, <#[R25 - 25240]> */
		/* 82093AE8h case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R25 + 0xFFFF9D68) );
		/* 82093AE8h case    3:*/		return 0x82093AEC;
		  /* 82093AECh */ case    4:  		/* cmplw CR6, R30, R28 */
		/* 82093AECh case    4:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R28);
		/* 82093AECh case    4:*/		return 0x82093AF0;
		  /* 82093AF0h */ case    5:  		/* bc 12, CR6_LT, 148 */
		/* 82093AF0h case    5:*/		if ( regs.CR[6].lt ) { return 0x82093B84;  }
		/* 82093AF0h case    5:*/		return 0x82093AF4;
		  /* 82093AF4h */ case    6:  		/* subf R26, R28, R30 */
		/* 82093AF4h case    6:*/		cpu::op::subf<0>(regs,&regs.R26,regs.R28,regs.R30);
		/* 82093AF4h case    6:*/		return 0x82093AF8;
		  /* 82093AF8h */ case    7:  		/* addi R27, R26, 4 */
		/* 82093AF8h case    7:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R26,0x4);
		/* 82093AF8h case    7:*/		return 0x82093AFC;
		  /* 82093AFCh */ case    8:  		/* cmplwi CR6, R27, 4 */
		/* 82093AFCh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000004);
		/* 82093AFCh case    8:*/		return 0x82093B00;
		  /* 82093B00h */ case    9:  		/* bc 12, CR6_LT, 132 */
		/* 82093B00h case    9:*/		if ( regs.CR[6].lt ) { return 0x82093B84;  }
		/* 82093B00h case    9:*/		return 0x82093B04;
		  /* 82093B04h */ case   10:  		/* mr R3, R28 */
		/* 82093B04h case   10:*/		regs.R3 = regs.R28;
		/* 82093B04h case   10:*/		return 0x82093B08;
		  /* 82093B08h */ case   11:  		/* bl 23440 */
		/* 82093B08h case   11:*/		regs.LR = 0x82093B0C; return 0x82099698;
		/* 82093B08h case   11:*/		return 0x82093B0C;
		  /* 82093B0Ch */ case   12:  		/* mr R29, R3 */
		/* 82093B0Ch case   12:*/		regs.R29 = regs.R3;
		/* 82093B0Ch case   12:*/		return 0x82093B10;
		  /* 82093B10h */ case   13:  		/* cmplw CR6, R3, R27 */
		/* 82093B10h case   13:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R27);
		/* 82093B10h case   13:*/		return 0x82093B14;
		  /* 82093B14h */ case   14:  		/* bc 4, CR6_LT, 92 */
		/* 82093B14h case   14:*/		if ( !regs.CR[6].lt ) { return 0x82093B70;  }
		/* 82093B14h case   14:*/		return 0x82093B18;
		  /* 82093B18h */ case   15:  		/* cmplwi CR6, R3, 2048 */
		/* 82093B18h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000800);
		/* 82093B18h case   15:*/		return 0x82093B1C;
		  /* 82093B1Ch */ case   16:  		/* mr R11, R3 */
		/* 82093B1Ch case   16:*/		regs.R11 = regs.R3;
		/* 82093B1Ch case   16:*/		return 0x82093B20;
		  /* 82093B20h */ case   17:  		/* bc 12, CR6_LT, 8 */
		/* 82093B20h case   17:*/		if ( regs.CR[6].lt ) { return 0x82093B28;  }
		/* 82093B20h case   17:*/		return 0x82093B24;
		  /* 82093B24h */ case   18:  		/* li R11, 2048 */
		/* 82093B24h case   18:*/		cpu::op::li<0>(regs,&regs.R11,0x800);
		/* 82093B24h case   18:*/		return 0x82093B28;
	}
	return 0x82093B28;
} // Block from 82093ADCh-82093B28h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82093B28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093B28);
		  /* 82093B28h */ case    0:  		/* add R4, R11, R29 */
		/* 82093B28h case    0:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R29);
		/* 82093B28h case    0:*/		return 0x82093B2C;
		  /* 82093B2Ch */ case    1:  		/* cmplw CR6, R4, R29 */
		/* 82093B2Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R29);
		/* 82093B2Ch case    1:*/		return 0x82093B30;
		  /* 82093B30h */ case    2:  		/* bc 12, CR6_LT, 20 */
		/* 82093B30h case    2:*/		if ( regs.CR[6].lt ) { return 0x82093B44;  }
		/* 82093B30h case    2:*/		return 0x82093B34;
		  /* 82093B34h */ case    3:  		/* mr R3, R28 */
		/* 82093B34h case    3:*/		regs.R3 = regs.R28;
		/* 82093B34h case    3:*/		return 0x82093B38;
		  /* 82093B38h */ case    4:  		/* bl 23152 */
		/* 82093B38h case    4:*/		regs.LR = 0x82093B3C; return 0x820995A8;
		/* 82093B38h case    4:*/		return 0x82093B3C;
		  /* 82093B3Ch */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 82093B3Ch case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82093B3Ch case    5:*/		return 0x82093B40;
		  /* 82093B40h */ case    6:  		/* bc 4, CR0_EQ, 32 */
		/* 82093B40h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82093B60;  }
		/* 82093B40h case    6:*/		return 0x82093B44;
	}
	return 0x82093B44;
} // Block from 82093B28h-82093B44h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82093B44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093B44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093B44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093B44);
		  /* 82093B44h */ case    0:  		/* addi R4, R29, 16 */
		/* 82093B44h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R29,0x10);
		/* 82093B44h case    0:*/		return 0x82093B48;
		  /* 82093B48h */ case    1:  		/* cmplw CR6, R4, R29 */
		/* 82093B48h case    1:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R29);
		/* 82093B48h case    1:*/		return 0x82093B4C;
		  /* 82093B4Ch */ case    2:  		/* bc 12, CR6_LT, 56 */
		/* 82093B4Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x82093B84;  }
		/* 82093B4Ch case    2:*/		return 0x82093B50;
		  /* 82093B50h */ case    3:  		/* mr R3, R28 */
		/* 82093B50h case    3:*/		regs.R3 = regs.R28;
		/* 82093B50h case    3:*/		return 0x82093B54;
		  /* 82093B54h */ case    4:  		/* bl 23124 */
		/* 82093B54h case    4:*/		regs.LR = 0x82093B58; return 0x820995A8;
		/* 82093B54h case    4:*/		return 0x82093B58;
		  /* 82093B58h */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 82093B58h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82093B58h case    5:*/		return 0x82093B5C;
		  /* 82093B5Ch */ case    6:  		/* bc 12, CR0_EQ, 40 */
		/* 82093B5Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x82093B84;  }
		/* 82093B5Ch case    6:*/		return 0x82093B60;
	}
	return 0x82093B60;
} // Block from 82093B44h-82093B60h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82093B60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093B60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093B60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093B60);
		  /* 82093B60h */ case    0:  		/* srawi R11, R26, 2 */
		/* 82093B60h case    0:*/		cpu::op::srawi<0,2>(regs,&regs.R11,regs.R26);
		/* 82093B60h case    0:*/		return 0x82093B64;
		  /* 82093B64h */ case    1:  		/* stw R3, <#[R25 - 25240]> */
		/* 82093B64h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R25 + 0xFFFF9D68) );
		/* 82093B64h case    1:*/		return 0x82093B68;
		  /* 82093B68h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82093B68h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82093B68h case    2:*/		return 0x82093B6C;
		  /* 82093B6Ch */ case    3:  		/* add R30, R11, R3 */
		/* 82093B6Ch case    3:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R3);
		/* 82093B6Ch case    3:*/		return 0x82093B70;
	}
	return 0x82093B70;
} // Block from 82093B60h-82093B70h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82093B70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093B70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093B70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093B70);
		  /* 82093B70h */ case    0:  		/* addi R11, R30, 4 */
		/* 82093B70h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x4);
		/* 82093B70h case    0:*/		return 0x82093B74;
		  /* 82093B74h */ case    1:  		/* stw R23, <#[R30]> */
		/* 82093B74h case    1:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R30 + 0x00000000) );
		/* 82093B74h case    1:*/		return 0x82093B78;
		  /* 82093B78h */ case    2:  		/* stw R23, <#[R31 + 80]> */
		/* 82093B78h case    2:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x00000050) );
		/* 82093B78h case    2:*/		return 0x82093B7C;
		  /* 82093B7Ch */ case    3:  		/* stw R11, <#[R24 - 25244]> */
		/* 82093B7Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0xFFFF9D64) );
		/* 82093B7Ch case    3:*/		return 0x82093B80;
		  /* 82093B80h */ case    4:  		/* b 12 */
		/* 82093B80h case    4:*/		return 0x82093B8C;
		/* 82093B80h case    4:*/		return 0x82093B84;
	}
	return 0x82093B84;
} // Block from 82093B70h-82093B84h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82093B84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093B84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093B84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093B84);
		  /* 82093B84h */ case    0:  		/* li R11, 0 */
		/* 82093B84h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82093B84h case    0:*/		return 0x82093B88;
		  /* 82093B88h */ case    1:  		/* stw R11, <#[R31 + 80]> */
		/* 82093B88h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 82093B88h case    1:*/		return 0x82093B8C;
	}
	return 0x82093B8C;
} // Block from 82093B84h-82093B8Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82093B8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093B8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093B8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093B8C);
		  /* 82093B8Ch */ case    0:  		/* nop */
		/* 82093B8Ch case    0:*/		cpu::op::nop();
		/* 82093B8Ch case    0:*/		return 0x82093B90;
		  /* 82093B90h */ case    1:  		/* addi R12, R31, 176 */
		/* 82093B90h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R31,0xB0);
		/* 82093B90h case    1:*/		return 0x82093B94;
		  /* 82093B94h */ case    2:  		/* bl 16 */
		/* 82093B94h case    2:*/		regs.LR = 0x82093B98; return 0x82093BA4;
		/* 82093B94h case    2:*/		return 0x82093B98;
		  /* 82093B98h */ case    3:  		/* lwz R3, <#[R31 + 80]> */
		/* 82093B98h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 82093B98h case    3:*/		return 0x82093B9C;
		  /* 82093B9Ch */ case    4:  		/* addi R1, R31, 176 */
		/* 82093B9Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0xB0);
		/* 82093B9Ch case    4:*/		return 0x82093BA0;
		  /* 82093BA0h */ case    5:  		/* b -10508 */
		/* 82093BA0h case    5:*/		return 0x82091294;
		/* 82093BA0h case    5:*/		return 0x82093BA4;
	}
	return 0x82093BA4;
} // Block from 82093B8Ch-82093BA4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82093BA4h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093BA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093BA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093BA4);
		  /* 82093BA4h */ case    0:  		/* mfspr R12, LR */
		/* 82093BA4h case    0:*/		regs.R12 = regs.LR;
		/* 82093BA4h case    0:*/		return 0x82093BA8;
		  /* 82093BA8h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82093BA8h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093BA8h case    1:*/		return 0x82093BAC;
		  /* 82093BACh */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82093BACh case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82093BACh case    2:*/		return 0x82093BB0;
		  /* 82093BB0h */ case    3:  		/* bl -3664 */
		/* 82093BB0h case    3:*/		regs.LR = 0x82093BB4; return 0x82092D60;
		/* 82093BB0h case    3:*/		return 0x82093BB4;
		  /* 82093BB4h */ case    4:  		/* lwz R1, <#[R1]> */
		/* 82093BB4h case    4:*/		cpu::mem::load32z( regs, &regs.R1, (uint32)(regs.R1 + 0x00000000) );
		/* 82093BB4h case    4:*/		return 0x82093BB8;
		  /* 82093BB8h */ case    5:  		/* lwz R12, <#[R1 - 8]> */
		/* 82093BB8h case    5:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093BB8h case    5:*/		return 0x82093BBC;
		  /* 82093BBCh */ case    6:  		/* mtspr LR, R12 */
		/* 82093BBCh case    6:*/		regs.LR = regs.R12;
		/* 82093BBCh case    6:*/		return 0x82093BC0;
		  /* 82093BC0h */ case    7:  		/* bclr 20, CR0_LT */
		/* 82093BC0h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82093BC0h case    7:*/		return 0x82093BC4;
	}
	return 0x82093BC4;
} // Block from 82093BA4h-82093BC4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82093BC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093BC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093BC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093BC4);
		  /* 82093BC4h */ case    0:  		/* nop */
		/* 82093BC4h case    0:*/		cpu::op::nop();
		/* 82093BC4h case    0:*/		return 0x82093BC8;
	}
	return 0x82093BC8;
} // Block from 82093BC4h-82093BC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093BC8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093BC8);
		  /* 82093BC8h */ case    0:  		/* mfspr R12, LR */
		/* 82093BC8h case    0:*/		regs.R12 = regs.LR;
		/* 82093BC8h case    0:*/		return 0x82093BCC;
		  /* 82093BCCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82093BCCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093BCCh case    1:*/		return 0x82093BD0;
		  /* 82093BD0h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82093BD0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82093BD0h case    2:*/		return 0x82093BD4;
		  /* 82093BD4h */ case    3:  		/* bl -276 */
		/* 82093BD4h case    3:*/		regs.LR = 0x82093BD8; return 0x82093AC0;
		/* 82093BD4h case    3:*/		return 0x82093BD8;
		  /* 82093BD8h */ case    4:  		/* addic R11, R3, -1 */
		/* 82093BD8h case    4:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R3,0xFFFFFFFF);
		/* 82093BD8h case    4:*/		return 0x82093BDC;
		  /* 82093BDCh */ case    5:  		/* subfe R3, R11, R11 */
		/* 82093BDCh case    5:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R11,regs.R11);
		/* 82093BDCh case    5:*/		return 0x82093BE0;
		  /* 82093BE0h */ case    6:  		/* addi R1, R1, 96 */
		/* 82093BE0h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82093BE0h case    6:*/		return 0x82093BE4;
		  /* 82093BE4h */ case    7:  		/* lwz R12, <#[R1 - 8]> */
		/* 82093BE4h case    7:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093BE4h case    7:*/		return 0x82093BE8;
		  /* 82093BE8h */ case    8:  		/* mtspr LR, R12 */
		/* 82093BE8h case    8:*/		regs.LR = regs.R12;
		/* 82093BE8h case    8:*/		return 0x82093BEC;
		  /* 82093BECh */ case    9:  		/* bclr 20, CR0_LT */
		/* 82093BECh case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82093BECh case    9:*/		return 0x82093BF0;
	}
	return 0x82093BF0;
} // Block from 82093BC8h-82093BF0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82093BF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093BF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093BF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093BF0);
		  /* 82093BF0h */ case    0:  		/* mfspr R12, LR */
		/* 82093BF0h case    0:*/		regs.R12 = regs.LR;
		/* 82093BF0h case    0:*/		return 0x82093BF4;
		  /* 82093BF4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82093BF4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093BF4h case    1:*/		return 0x82093BF8;
		  /* 82093BF8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82093BF8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82093BF8h case    2:*/		return 0x82093BFC;
		  /* 82093BFCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82093BFCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82093BFCh case    3:*/		return 0x82093C00;
		  /* 82093C00h */ case    4:  		/* lbz R11, <#[R3]> */
		/* 82093C00h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82093C00h case    4:*/		return 0x82093C04;
		  /* 82093C04h */ case    5:  		/* mr R31, R3 */
		/* 82093C04h case    5:*/		regs.R31 = regs.R3;
		/* 82093C04h case    5:*/		return 0x82093C08;
		  /* 82093C08h */ case    6:  		/* extsb R3, R11 */
		/* 82093C08h case    6:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 82093C08h case    6:*/		return 0x82093C0C;
		  /* 82093C0Ch */ case    7:  		/* bl 23428 */
		/* 82093C0Ch case    7:*/		regs.LR = 0x82093C10; return 0x82099790;
		/* 82093C0Ch case    7:*/		return 0x82093C10;
		  /* 82093C10h */ case    8:  		/* cmpwi CR6, R3, 101 */
		/* 82093C10h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000065);
		/* 82093C10h case    8:*/		return 0x82093C14;
		  /* 82093C14h */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 82093C14h case    9:*/		if ( regs.CR[6].eq ) { return 0x82093C28;  }
		/* 82093C14h case    9:*/		return 0x82093C18;
		  /* 82093C18h */ case   10:  		/* lbzu R3, <#[R31 + 1]> */
		/* 82093C18h case   10:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000001) );
		regs.R31 = (uint32)(regs.R31 + 0x00000001);
		/* 82093C18h case   10:*/		return 0x82093C1C;
		  /* 82093C1Ch */ case   11:  		/* bl 23284 */
		/* 82093C1Ch case   11:*/		regs.LR = 0x82093C20; return 0x82099710;
		/* 82093C1Ch case   11:*/		return 0x82093C20;
		  /* 82093C20h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 82093C20h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82093C20h case   12:*/		return 0x82093C24;
		  /* 82093C24h */ case   13:  		/* bc 4, CR0_EQ, -12 */
		/* 82093C24h case   13:*/		if ( !regs.CR[0].eq ) { return 0x82093C18;  }
		/* 82093C24h case   13:*/		return 0x82093C28;
	}
	return 0x82093C28;
} // Block from 82093BF0h-82093C28h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82093C28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093C28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093C28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093C28);
		  /* 82093C28h */ case    0:  		/* lbz R11, <#[R31]> */
		/* 82093C28h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82093C28h case    0:*/		return 0x82093C2C;
		  /* 82093C2Ch */ case    1:  		/* extsb R3, R11 */
		/* 82093C2Ch case    1:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 82093C2Ch case    1:*/		return 0x82093C30;
		  /* 82093C30h */ case    2:  		/* bl 23392 */
		/* 82093C30h case    2:*/		regs.LR = 0x82093C34; return 0x82099790;
		/* 82093C30h case    2:*/		return 0x82093C34;
		  /* 82093C34h */ case    3:  		/* cmpwi CR6, R3, 120 */
		/* 82093C34h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000078);
		/* 82093C34h case    3:*/		return 0x82093C38;
		  /* 82093C38h */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 82093C38h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82093C40;  }
		/* 82093C38h case    4:*/		return 0x82093C3C;
		  /* 82093C3Ch */ case    5:  		/* addi R31, R31, 2 */
		/* 82093C3Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x2);
		/* 82093C3Ch case    5:*/		return 0x82093C40;
	}
	return 0x82093C40;
} // Block from 82093C28h-82093C40h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82093C40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093C40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093C40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093C40);
		  /* 82093C40h */ case    0:  		/* lis R11, -32217 */
		/* 82093C40h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82093C40h case    0:*/		return 0x82093C44;
		  /* 82093C44h */ case    1:  		/* lbz R10, <#[R31]> */
		/* 82093C44h case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82093C44h case    1:*/		return 0x82093C48;
		  /* 82093C48h */ case    2:  		/* lwz R11, <#[R11 + 8856]> */
		/* 82093C48h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00002298) );
		/* 82093C48h case    2:*/		return 0x82093C4C;
		  /* 82093C4Ch */ case    3:  		/* lwz R9, <#[R11 + 188]> */
		/* 82093C4Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x000000BC) );
		/* 82093C4Ch case    3:*/		return 0x82093C50;
		  /* 82093C50h */ case    4:  		/* mr R11, R31 */
		/* 82093C50h case    4:*/		regs.R11 = regs.R31;
		/* 82093C50h case    4:*/		return 0x82093C54;
		  /* 82093C54h */ case    5:  		/* lwz R9, <#[R9]> */
		/* 82093C54h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 82093C54h case    5:*/		return 0x82093C58;
		  /* 82093C58h */ case    6:  		/* lbz R9, <#[R9]> */
		/* 82093C58h case    6:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 82093C58h case    6:*/		return 0x82093C5C;
		  /* 82093C5Ch */ case    7:  		/* stb R9, <#[R31]> */
		/* 82093C5Ch case    7:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82093C5Ch case    7:*/		return 0x82093C60;
		  /* 82093C60h */ case    8:  		/* lbz R9, <#[R11 + 1]> */
		/* 82093C60h case    8:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000001) );
		/* 82093C60h case    8:*/		return 0x82093C64;
		  /* 82093C64h */ case    9:  		/* stb R10, <#[R11 + 1]> */
		/* 82093C64h case    9:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000001) );
		/* 82093C64h case    9:*/		return 0x82093C68;
		  /* 82093C68h */ case   10:  		/* lbzu R8, <#[R11 + 1]> */
		/* 82093C68h case   10:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000001) );
		regs.R11 = (uint32)(regs.R11 + 0x00000001);
		/* 82093C68h case   10:*/		return 0x82093C6C;
		  /* 82093C6Ch */ case   11:  		/* mr R10, R9 */
		/* 82093C6Ch case   11:*/		regs.R10 = regs.R9;
		/* 82093C6Ch case   11:*/		return 0x82093C70;
		  /* 82093C70h */ case   12:  		/* cmplwi CR0, R8, 0 */
		/* 82093C70h case   12:*/		cpu::op::cmplwi<0>(regs,regs.R8,0x00000000);
		/* 82093C70h case   12:*/		return 0x82093C74;
		  /* 82093C74h */ case   13:  		/* bc 4, CR0_EQ, -20 */
		/* 82093C74h case   13:*/		if ( !regs.CR[0].eq ) { return 0x82093C60;  }
		/* 82093C74h case   13:*/		return 0x82093C78;
	}
	return 0x82093C78;
} // Block from 82093C40h-82093C78h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82093C78h
// Function '_blkmov'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093C78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093C78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093C78);
		  /* 82093C78h */ case    0:  		/* addi R1, R1, 96 */
		/* 82093C78h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82093C78h case    0:*/		return 0x82093C7C;
		  /* 82093C7Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82093C7Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093C7Ch case    1:*/		return 0x82093C80;
		  /* 82093C80h */ case    2:  		/* mtspr LR, R12 */
		/* 82093C80h case    2:*/		regs.LR = regs.R12;
		/* 82093C80h case    2:*/		return 0x82093C84;
		  /* 82093C84h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82093C84h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82093C84h case    3:*/		return 0x82093C88;
		  /* 82093C88h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82093C88h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82093C88h case    4:*/		return 0x82093C8C;
	}
	return 0x82093C8C;
} // Block from 82093C78h-82093C8Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82093C8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093C8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093C8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093C8C);
		  /* 82093C8Ch */ case    0:  		/* nop */
		/* 82093C8Ch case    0:*/		cpu::op::nop();
		/* 82093C8Ch case    0:*/		return 0x82093C90;
		  /* 82093C90h */ case    1:  		/* lis R10, -32217 */
		/* 82093C90h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 82093C90h case    1:*/		return 0x82093C94;
		  /* 82093C94h */ case    2:  		/* lbz R11, <#[R3]> */
		/* 82093C94h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82093C94h case    2:*/		return 0x82093C98;
		  /* 82093C98h */ case    3:  		/* extsb. R11, R11 */
		/* 82093C98h case    3:*/		cpu::op::extsb<1>(regs,&regs.R11,regs.R11);
		/* 82093C98h case    3:*/		return 0x82093C9C;
		  /* 82093C9Ch */ case    4:  		/* lwz R8, <#[R10 + 8856]> */
		/* 82093C9Ch case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00002298) );
		/* 82093C9Ch case    4:*/		return 0x82093CA0;
		  /* 82093CA0h */ case    5:  		/* bc 12, CR0_EQ, 40 */
		/* 82093CA0h case    5:*/		if ( regs.CR[0].eq ) { return 0x82093CC8;  }
		/* 82093CA0h case    5:*/		return 0x82093CA4;
		  /* 82093CA4h */ case    6:  		/* lwz R10, <#[R8 + 188]> */
		/* 82093CA4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x000000BC) );
		/* 82093CA4h case    6:*/		return 0x82093CA8;
		  /* 82093CA8h */ case    7:  		/* lwz R10, <#[R10]> */
		/* 82093CA8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 82093CA8h case    7:*/		return 0x82093CAC;
		  /* 82093CACh */ case    8:  		/* lbz R10, <#[R10]> */
		/* 82093CACh case    8:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 82093CACh case    8:*/		return 0x82093CB0;
		  /* 82093CB0h */ case    9:  		/* extsb R10, R10 */
		/* 82093CB0h case    9:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 82093CB0h case    9:*/		return 0x82093CB4;
		  /* 82093CB4h */ case   10:  		/* cmpw CR6, R11, R10 */
		/* 82093CB4h case   10:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82093CB4h case   10:*/		return 0x82093CB8;
		  /* 82093CB8h */ case   11:  		/* bc 12, CR6_EQ, 16 */
		/* 82093CB8h case   11:*/		if ( regs.CR[6].eq ) { return 0x82093CC8;  }
		/* 82093CB8h case   11:*/		return 0x82093CBC;
		  /* 82093CBCh */ case   12:  		/* lbzu R11, <#[R3 + 1]> */
		/* 82093CBCh case   12:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000001) );
		regs.R3 = (uint32)(regs.R3 + 0x00000001);
		/* 82093CBCh case   12:*/		return 0x82093CC0;
		  /* 82093CC0h */ case   13:  		/* extsb. R11, R11 */
		/* 82093CC0h case   13:*/		cpu::op::extsb<1>(regs,&regs.R11,regs.R11);
		/* 82093CC0h case   13:*/		return 0x82093CC4;
		  /* 82093CC4h */ case   14:  		/* bc 4, CR0_EQ, -16 */
		/* 82093CC4h case   14:*/		if ( !regs.CR[0].eq ) { return 0x82093CB4;  }
		/* 82093CC4h case   14:*/		return 0x82093CC8;
	}
	return 0x82093CC8;
} // Block from 82093C8Ch-82093CC8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82093CC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093CC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093CC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093CC8);
		  /* 82093CC8h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 82093CC8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82093CC8h case    0:*/		return 0x82093CCC;
		  /* 82093CCCh */ case    1:  		/* addi R11, R3, 1 */
		/* 82093CCCh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x1);
		/* 82093CCCh case    1:*/		return 0x82093CD0;
		  /* 82093CD0h */ case    2:  		/* bclr 12, CR6_EQ */
		/* 82093CD0h case    2:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82093CD0h case    2:*/		return 0x82093CD4;
	}
	return 0x82093CD4;
} // Block from 82093CC8h-82093CD4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82093CD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093CD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093CD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093CD4);
		  /* 82093CD4h */ case    0:  		/* lbz R10, <#[R11]> */
		/* 82093CD4h case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82093CD4h case    0:*/		return 0x82093CD8;
		  /* 82093CD8h */ case    1:  		/* b 24 */
		/* 82093CD8h case    1:*/		return 0x82093CF0;
		/* 82093CD8h case    1:*/		return 0x82093CDC;
		  /* 82093CDCh */ case    2:  		/* cmpwi CR6, R10, 101 */
		/* 82093CDCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000065);
		/* 82093CDCh case    2:*/		return 0x82093CE0;
		  /* 82093CE0h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 82093CE0h case    3:*/		if ( regs.CR[6].eq ) { return 0x82093CF8;  }
		/* 82093CE0h case    3:*/		return 0x82093CE4;
		  /* 82093CE4h */ case    4:  		/* cmpwi CR6, R10, 69 */
		/* 82093CE4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000045);
		/* 82093CE4h case    4:*/		return 0x82093CE8;
		  /* 82093CE8h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 82093CE8h case    5:*/		if ( regs.CR[6].eq ) { return 0x82093CF8;  }
		/* 82093CE8h case    5:*/		return 0x82093CEC;
		  /* 82093CECh */ case    6:  		/* lbzu R10, <#[R11 + 1]> */
		/* 82093CECh case    6:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000001) );
		regs.R11 = (uint32)(regs.R11 + 0x00000001);
		/* 82093CECh case    6:*/		return 0x82093CF0;
	}
	return 0x82093CF0;
} // Block from 82093CD4h-82093CF0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82093CF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093CF0);
		  /* 82093CF0h */ case    0:  		/* extsb. R10, R10 */
		/* 82093CF0h case    0:*/		cpu::op::extsb<1>(regs,&regs.R10,regs.R10);
		/* 82093CF0h case    0:*/		return 0x82093CF4;
		  /* 82093CF4h */ case    1:  		/* bc 4, CR0_EQ, -24 */
		/* 82093CF4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82093CDC;  }
		/* 82093CF4h case    1:*/		return 0x82093CF8;
	}
	return 0x82093CF8;
} // Block from 82093CF0h-82093CF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82093CF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093CF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093CF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093CF8);
		  /* 82093CF8h */ case    0:  		/* mr R9, R11 */
		/* 82093CF8h case    0:*/		regs.R9 = regs.R11;
		/* 82093CF8h case    0:*/		return 0x82093CFC;
		  /* 82093CFCh */ case    1:  		/* lbzu R10, <#[R11 - 1]> */
		/* 82093CFCh case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0xFFFFFFFF) );
		regs.R11 = (uint32)(regs.R11 + 0xFFFFFFFF);
		/* 82093CFCh case    1:*/		return 0x82093D00;
		  /* 82093D00h */ case    2:  		/* extsb R10, R10 */
		/* 82093D00h case    2:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 82093D00h case    2:*/		return 0x82093D04;
		  /* 82093D04h */ case    3:  		/* cmpwi CR6, R10, 48 */
		/* 82093D04h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000030);
		/* 82093D04h case    3:*/		return 0x82093D08;
		  /* 82093D08h */ case    4:  		/* bc 12, CR6_EQ, -12 */
		/* 82093D08h case    4:*/		if ( regs.CR[6].eq ) { return 0x82093CFC;  }
		/* 82093D08h case    4:*/		return 0x82093D0C;
		  /* 82093D0Ch */ case    5:  		/* lwz R8, <#[R8 + 188]> */
		/* 82093D0Ch case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x000000BC) );
		/* 82093D0Ch case    5:*/		return 0x82093D10;
		  /* 82093D10h */ case    6:  		/* lwz R8, <#[R8]> */
		/* 82093D10h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000000) );
		/* 82093D10h case    6:*/		return 0x82093D14;
		  /* 82093D14h */ case    7:  		/* lbz R8, <#[R8]> */
		/* 82093D14h case    7:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000000) );
		/* 82093D14h case    7:*/		return 0x82093D18;
		  /* 82093D18h */ case    8:  		/* extsb R8, R8 */
		/* 82093D18h case    8:*/		cpu::op::extsb<0>(regs,&regs.R8,regs.R8);
		/* 82093D18h case    8:*/		return 0x82093D1C;
		  /* 82093D1Ch */ case    9:  		/* cmpw CR6, R10, R8 */
		/* 82093D1Ch case    9:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R8);
		/* 82093D1Ch case    9:*/		return 0x82093D20;
	}
	return 0x82093D20;
} // Block from 82093CF8h-82093D20h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82093D20h
// Function 'strrchr'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093D20);
		  /* 82093D20h */ case    0:  		/* bc 4, CR6_EQ, 8 */
		/* 82093D20h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82093D28;  }
		/* 82093D20h case    0:*/		return 0x82093D24;
		  /* 82093D24h */ case    1:  		/* addi R11, R11, -1 */
		/* 82093D24h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82093D24h case    1:*/		return 0x82093D28;
	}
	return 0x82093D28;
} // Block from 82093D20h-82093D28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82093D28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093D28);
		  /* 82093D28h */ case    0:  		/* addi R9, R9, -1 */
		/* 82093D28h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82093D28h case    0:*/		return 0x82093D2C;
		  /* 82093D2Ch */ case    1:  		/* lbzu R10, <#[R9 + 1]> */
		/* 82093D2Ch case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000001) );
		regs.R9 = (uint32)(regs.R9 + 0x00000001);
		/* 82093D2Ch case    1:*/		return 0x82093D30;
		  /* 82093D30h */ case    2:  		/* extsb. R8, R10 */
		/* 82093D30h case    2:*/		cpu::op::extsb<1>(regs,&regs.R8,regs.R10);
		/* 82093D30h case    2:*/		return 0x82093D34;
		  /* 82093D34h */ case    3:  		/* stbu R10, <#[R11 + 1]> */
		/* 82093D34h case    3:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000001) );
		regs.R11 = (uint32)(regs.R11 + 0x00000001);
		/* 82093D34h case    3:*/		return 0x82093D38;
		  /* 82093D38h */ case    4:  		/* bc 4, CR0_EQ, -12 */
		/* 82093D38h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82093D2C;  }
		/* 82093D38h case    4:*/		return 0x82093D3C;
		  /* 82093D3Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 82093D3Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82093D3Ch case    5:*/		return 0x82093D40;
	}
	return 0x82093D40;
} // Block from 82093D28h-82093D40h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82093D40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093D40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093D40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093D40);
		  /* 82093D40h */ case    0:  		/* lis R11, -32256 */
		/* 82093D40h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82093D40h case    0:*/		return 0x82093D44;
		  /* 82093D44h */ case    1:  		/* lfd FR13, <#[R3]> */
		/* 82093D44h case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R3 + 0x00000000) );
		/* 82093D44h case    1:*/		return 0x82093D48;
		  /* 82093D48h */ case    2:  		/* li R3, 1 */
		/* 82093D48h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82093D48h case    2:*/		return 0x82093D4C;
		  /* 82093D4Ch */ case    3:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 82093D4Ch case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 82093D4Ch case    3:*/		return 0x82093D50;
		  /* 82093D50h */ case    4:  		/* fcmpu CR6, FR13, FR0 */
		/* 82093D50h case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 82093D50h case    4:*/		return 0x82093D54;
		  /* 82093D54h */ case    5:  		/* bclr 4, CR6_LT */
		/* 82093D54h case    5:*/		if ( !regs.CR[6].lt ) { return (uint32)regs.LR; }
		/* 82093D54h case    5:*/		return 0x82093D58;
	}
	return 0x82093D58;
} // Block from 82093D40h-82093D58h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82093D58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093D58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093D58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093D58);
		  /* 82093D58h */ case    0:  		/* li R3, 0 */
		/* 82093D58h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82093D58h case    0:*/		return 0x82093D5C;
		  /* 82093D5Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 82093D5Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82093D5Ch case    1:*/		return 0x82093D60;
	}
	return 0x82093D60;
} // Block from 82093D58h-82093D60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82093D60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093D60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093D60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093D60);
		  /* 82093D60h */ case    0:  		/* mfspr R12, LR */
		/* 82093D60h case    0:*/		regs.R12 = regs.LR;
		/* 82093D60h case    0:*/		return 0x82093D64;
		  /* 82093D64h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82093D64h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093D64h case    1:*/		return 0x82093D68;
		  /* 82093D68h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82093D68h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82093D68h case    2:*/		return 0x82093D6C;
		  /* 82093D6Ch */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 82093D6Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82093D6Ch case    3:*/		return 0x82093D70;
		  /* 82093D70h */ case    4:  		/* mr R31, R4 */
		/* 82093D70h case    4:*/		regs.R31 = regs.R4;
		/* 82093D70h case    4:*/		return 0x82093D74;
		  /* 82093D74h */ case    5:  		/* mr R4, R5 */
		/* 82093D74h case    5:*/		regs.R4 = regs.R5;
		/* 82093D74h case    5:*/		return 0x82093D78;
	}
	return 0x82093D78;
} // Block from 82093D60h-82093D78h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82093D78h
// Function '_cfltcvt_init'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093D78);
		  /* 82093D78h */ case    0:  		/* mr R5, R6 */
		/* 82093D78h case    0:*/		regs.R5 = regs.R6;
		/* 82093D78h case    0:*/		return 0x82093D7C;
		  /* 82093D7Ch */ case    1:  		/* cmpwi CR6, R3, 0 */
		/* 82093D7Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 82093D7Ch case    1:*/		return 0x82093D80;
		  /* 82093D80h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 82093D80h case    2:*/		if ( regs.CR[6].eq ) { return 0x82093D98;  }
		/* 82093D80h case    2:*/		return 0x82093D84;
		  /* 82093D84h */ case    3:  		/* addi R3, R1, 88 */
		/* 82093D84h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 82093D84h case    3:*/		return 0x82093D88;
		  /* 82093D88h */ case    4:  		/* bl 23072 */
		/* 82093D88h case    4:*/		regs.LR = 0x82093D8C; return 0x820997A8;
		/* 82093D88h case    4:*/		return 0x82093D8C;
		  /* 82093D8Ch */ case    5:  		/* ld R11, <#[R1 + 88]> */
		/* 82093D8Ch case    5:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82093D8Ch case    5:*/		return 0x82093D90;
		  /* 82093D90h */ case    6:  		/* std R11, <#[R31]> */
		/* 82093D90h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82093D90h case    6:*/		return 0x82093D94;
		  /* 82093D94h */ case    7:  		/* b 20 */
		/* 82093D94h case    7:*/		return 0x82093DA8;
		/* 82093D94h case    7:*/		return 0x82093D98;
	}
	return 0x82093D98;
} // Block from 82093D78h-82093D98h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82093D98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093D98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093D98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093D98);
		  /* 82093D98h */ case    0:  		/* addi R3, R1, 80 */
		/* 82093D98h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82093D98h case    0:*/		return 0x82093D9C;
		  /* 82093D9Ch */ case    1:  		/* bl 23220 */
		/* 82093D9Ch case    1:*/		regs.LR = 0x82093DA0; return 0x82099850;
		/* 82093D9Ch case    1:*/		return 0x82093DA0;
		  /* 82093DA0h */ case    2:  		/* lwz R11, <#[R1 + 80]> */
		/* 82093DA0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82093DA0h case    2:*/		return 0x82093DA4;
		  /* 82093DA4h */ case    3:  		/* stw R11, <#[R31]> */
		/* 82093DA4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82093DA4h case    3:*/		return 0x82093DA8;
	}
	return 0x82093DA8;
} // Block from 82093D98h-82093DA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82093DA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093DA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093DA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093DA8);
		  /* 82093DA8h */ case    0:  		/* addi R1, R1, 112 */
		/* 82093DA8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82093DA8h case    0:*/		return 0x82093DAC;
		  /* 82093DACh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82093DACh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82093DACh case    1:*/		return 0x82093DB0;
		  /* 82093DB0h */ case    2:  		/* mtspr LR, R12 */
		/* 82093DB0h case    2:*/		regs.LR = regs.R12;
		/* 82093DB0h case    2:*/		return 0x82093DB4;
		  /* 82093DB4h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82093DB4h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82093DB4h case    3:*/		return 0x82093DB8;
		  /* 82093DB8h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82093DB8h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82093DB8h case    4:*/		return 0x82093DBC;
	}
	return 0x82093DBC;
} // Block from 82093DA8h-82093DBCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82093DBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093DBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093DBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093DBC);
		  /* 82093DBCh */ case    0:  		/* nop */
		/* 82093DBCh case    0:*/		cpu::op::nop();
		/* 82093DBCh case    0:*/		return 0x82093DC0;
		  /* 82093DC0h */ case    1:  		/* li R6, 0 */
		/* 82093DC0h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82093DC0h case    1:*/		return 0x82093DC4;
		  /* 82093DC4h */ case    2:  		/* b -100 */
		/* 82093DC4h case    2:*/		return 0x82093D60;
		/* 82093DC4h case    2:*/		return 0x82093DC8;
		  /* 82093DC8h */ case    3:  		/* li R4, 0 */
		/* 82093DC8h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82093DC8h case    3:*/		return 0x82093DCC;
		  /* 82093DCCh */ case    4:  		/* b -476 */
		/* 82093DCCh case    4:*/		return 0x82093BF0;
		/* 82093DCCh case    4:*/		return 0x82093DD0;
		  /* 82093DD0h */ case    5:  		/* li R4, 0 */
		/* 82093DD0h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82093DD0h case    5:*/		return 0x82093DD4;
		  /* 82093DD4h */ case    6:  		/* b -324 */
		/* 82093DD4h case    6:*/		return 0x82093C90;
		/* 82093DD4h case    6:*/		return 0x82093DD8;
	}
	return 0x82093DD8;
} // Block from 82093DBCh-82093DD8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82093DD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093DD8);
		  /* 82093DD8h */ case    0:  		/* mfspr R12, LR */
		/* 82093DD8h case    0:*/		regs.R12 = regs.LR;
		/* 82093DD8h case    0:*/		return 0x82093DDC;
		  /* 82093DDCh */ case    1:  		/* bl -11152 */
		/* 82093DDCh case    1:*/		regs.LR = 0x82093DE0; return 0x8209124C;
		/* 82093DDCh case    1:*/		return 0x82093DE0;
		  /* 82093DE0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82093DE0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82093DE0h case    2:*/		return 0x82093DE4;
		  /* 82093DE4h */ case    3:  		/* mr R30, R3 */
		/* 82093DE4h case    3:*/		regs.R30 = regs.R3;
		/* 82093DE4h case    3:*/		return 0x82093DE8;
		  /* 82093DE8h */ case    4:  		/* mr R29, R4 */
		/* 82093DE8h case    4:*/		regs.R29 = regs.R4;
		/* 82093DE8h case    4:*/		return 0x82093DEC;
		  /* 82093DECh */ case    5:  		/* mr R31, R5 */
		/* 82093DECh case    5:*/		regs.R31 = regs.R5;
		/* 82093DECh case    5:*/		return 0x82093DF0;
		  /* 82093DF0h */ case    6:  		/* mr R25, R6 */
		/* 82093DF0h case    6:*/		regs.R25 = regs.R6;
		/* 82093DF0h case    6:*/		return 0x82093DF4;
		  /* 82093DF4h */ case    7:  		/* mr R27, R7 */
		/* 82093DF4h case    7:*/		regs.R27 = regs.R7;
		/* 82093DF4h case    7:*/		return 0x82093DF8;
		  /* 82093DF8h */ case    8:  		/* cmplwi CR6, R3, 0 */
		/* 82093DF8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82093DF8h case    8:*/		return 0x82093DFC;
		  /* 82093DFCh */ case    9:  		/* bc 4, CR6_EQ, 32 */
		/* 82093DFCh case    9:*/		if ( !regs.CR[6].eq ) { return 0x82093E1C;  }
		/* 82093DFCh case    9:*/		return 0x82093E00;
		  /* 82093E00h */ case   10:  		/* bl 4360 */
		/* 82093E00h case   10:*/		regs.LR = 0x82093E04; return 0x82094F08;
		/* 82093E00h case   10:*/		return 0x82093E04;
		  /* 82093E04h */ case   11:  		/* li R11, 22 */
		/* 82093E04h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 82093E04h case   11:*/		return 0x82093E08;
		  /* 82093E08h */ case   12:  		/* stw R11, <#[R3]> */
		/* 82093E08h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82093E08h case   12:*/		return 0x82093E0C;
		  /* 82093E0Ch */ case   13:  		/* bl -1196 */
		/* 82093E0Ch case   13:*/		regs.LR = 0x82093E10; return 0x82093960;
		/* 82093E0Ch case   13:*/		return 0x82093E10;
	}
	return 0x82093E10;
} // Block from 82093DD8h-82093E10h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82093E10h
// Function '_fpmath'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093E10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093E10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093E10);
		  /* 82093E10h */ case    0:  		/* li R3, 22 */
		/* 82093E10h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x16);
		/* 82093E10h case    0:*/		return 0x82093E14;
		  /* 82093E14h */ case    1:  		/* addi R1, R1, 144 */
		/* 82093E14h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82093E14h case    1:*/		return 0x82093E18;
		  /* 82093E18h */ case    2:  		/* b -11132 */
		/* 82093E18h case    2:*/		return 0x8209129C;
		/* 82093E18h case    2:*/		return 0x82093E1C;
	}
	return 0x82093E1C;
} // Block from 82093E10h-82093E1Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82093E1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093E1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093E1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093E1C);
		  /* 82093E1Ch */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 82093E1Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82093E1Ch case    0:*/		return 0x82093E20;
	}
	return 0x82093E20;
} // Block from 82093E1Ch-82093E20h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093E20h
// Function '_RtlCheckStack'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093E20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093E20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093E20);
		  /* 82093E20h */ case    0:  		/* bc 4, CR6_EQ, 28 */
		/* 82093E20h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82093E3C;  }
		/* 82093E20h case    0:*/		return 0x82093E24;
	}
	return 0x82093E24;
} // Block from 82093E20h-82093E24h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093E24h
// Function '_RtlCheckStack12'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093E24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093E24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093E24);
		  /* 82093E24h */ case    0:  		/* bl 4324 */
		/* 82093E24h case    0:*/		regs.LR = 0x82093E28; return 0x82094F08;
		/* 82093E24h case    0:*/		return 0x82093E28;
		  /* 82093E28h */ case    1:  		/* li R31, 22 */
		/* 82093E28h case    1:*/		cpu::op::li<0>(regs,&regs.R31,0x16);
		/* 82093E28h case    1:*/		return 0x82093E2C;
		  /* 82093E2Ch */ case    2:  		/* stw R31, <#[R3]> */
		/* 82093E2Ch case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82093E2Ch case    2:*/		return 0x82093E30;
		  /* 82093E30h */ case    3:  		/* bl -1232 */
		/* 82093E30h case    3:*/		regs.LR = 0x82093E34; return 0x82093960;
		/* 82093E30h case    3:*/		return 0x82093E34;
		  /* 82093E34h */ case    4:  		/* mr R3, R31 */
		/* 82093E34h case    4:*/		regs.R3 = regs.R31;
		/* 82093E34h case    4:*/		return 0x82093E38;
		  /* 82093E38h */ case    5:  		/* b -36 */
		/* 82093E38h case    5:*/		return 0x82093E14;
		/* 82093E38h case    5:*/		return 0x82093E3C;
	}
	return 0x82093E3C;
} // Block from 82093E24h-82093E3Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82093E3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093E3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093E3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093E3C);
		  /* 82093E3Ch */ case    0:  		/* subfic R11, R31, 0 */
		/* 82093E3Ch case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R31,0x0);
		/* 82093E3Ch case    0:*/		return 0x82093E40;
		  /* 82093E40h */ case    1:  		/* rlwinm R11, R31, 1, 31, 31 */
		/* 82093E40h case    1:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R31);
		/* 82093E40h case    1:*/		return 0x82093E44;
		  /* 82093E44h */ case    2:  		/* addme R11, R11 */
		/* 82093E44h case    2:*/		cpu::op::addme<0>(regs,&regs.R11,regs.R11);
		/* 82093E44h case    2:*/		return 0x82093E48;
	}
	return 0x82093E48;
} // Block from 82093E3Ch-82093E48h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82093E48h
// Function '?what@exception@std@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093E48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093E48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093E48);
		  /* 82093E48h */ case    0:  		/* and R11, R11, R31 */
		/* 82093E48h case    0:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 82093E48h case    0:*/		return 0x82093E4C;
		  /* 82093E4Ch */ case    1:  		/* addi R11, R11, 9 */
		/* 82093E4Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x9);
		/* 82093E4Ch case    1:*/		return 0x82093E50;
		  /* 82093E50h */ case    2:  		/* cmplw CR6, R29, R11 */
		/* 82093E50h case    2:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82093E50h case    2:*/		return 0x82093E54;
		  /* 82093E54h */ case    3:  		/* bc 12, CR6_GT, 16 */
		/* 82093E54h case    3:*/		if ( regs.CR[6].gt ) { return 0x82093E64;  }
		/* 82093E54h case    3:*/		return 0x82093E58;
		  /* 82093E58h */ case    4:  		/* bl 4272 */
		/* 82093E58h case    4:*/		regs.LR = 0x82093E5C; return 0x82094F08;
		/* 82093E58h case    4:*/		return 0x82093E5C;
		  /* 82093E5Ch */ case    5:  		/* li R31, 34 */
		/* 82093E5Ch case    5:*/		cpu::op::li<0>(regs,&regs.R31,0x22);
		/* 82093E5Ch case    5:*/		return 0x82093E60;
	}
	return 0x82093E60;
} // Block from 82093E48h-82093E60h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82093E60h
// Function '?_Copy_str@exception@std@@AAAXPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093E60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093E60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093E60);
		  /* 82093E60h */ case    0:  		/* b -52 */
		/* 82093E60h case    0:*/		return 0x82093E2C;
		/* 82093E60h case    0:*/		return 0x82093E64;
	}
	return 0x82093E64;
} // Block from 82093E60h-82093E64h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093E64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093E64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093E64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093E64);
		  /* 82093E64h */ case    0:  		/* extsb. R28, R8 */
		/* 82093E64h case    0:*/		cpu::op::extsb<1>(regs,&regs.R28,regs.R8);
		/* 82093E64h case    0:*/		return 0x82093E68;
		  /* 82093E68h */ case    1:  		/* bc 12, CR0_EQ, 76 */
		/* 82093E68h case    1:*/		if ( regs.CR[0].eq ) { return 0x82093EB4;  }
		/* 82093E68h case    1:*/		return 0x82093E6C;
		  /* 82093E6Ch */ case    2:  		/* lwz R11, <#[R27]> */
		/* 82093E6Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82093E6Ch case    2:*/		return 0x82093E70;
		  /* 82093E70h */ case    3:  		/* cmpwi CR6, R31, 0 */
		/* 82093E70h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82093E70h case    3:*/		return 0x82093E74;
		  /* 82093E74h */ case    4:  		/* addi R11, R11, -45 */
		/* 82093E74h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFD3);
		/* 82093E74h case    4:*/		return 0x82093E78;
		  /* 82093E78h */ case    5:  		/* cntlzw R11, R11 */
		/* 82093E78h case    5:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82093E78h case    5:*/		return 0x82093E7C;
		  /* 82093E7Ch */ case    6:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 82093E7Ch case    6:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82093E7Ch case    6:*/		return 0x82093E80;
		  /* 82093E80h */ case    7:  		/* add R4, R11, R30 */
		/* 82093E80h case    7:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R30);
		/* 82093E80h case    7:*/		return 0x82093E84;
		  /* 82093E84h */ case    8:  		/* bc 4, CR6_GT, 48 */
		/* 82093E84h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82093EB4;  }
		/* 82093E84h case    8:*/		return 0x82093E88;
		  /* 82093E88h */ case    9:  		/* mr R11, R4 */
		/* 82093E88h case    9:*/		regs.R11 = regs.R4;
		/* 82093E88h case    9:*/		return 0x82093E8C;
		  /* 82093E8Ch */ case   10:  		/* lbz R10, <#[R11]> */
		/* 82093E8Ch case   10:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82093E8Ch case   10:*/		return 0x82093E90;
		  /* 82093E90h */ case   11:  		/* addi R11, R11, 1 */
		/* 82093E90h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82093E90h case   11:*/		return 0x82093E94;
		  /* 82093E94h */ case   12:  		/* cmplwi CR6, R10, 0 */
		/* 82093E94h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82093E94h case   12:*/		return 0x82093E98;
		  /* 82093E98h */ case   13:  		/* bc 4, CR6_EQ, -12 */
		/* 82093E98h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82093E8C;  }
		/* 82093E98h case   13:*/		return 0x82093E9C;
		  /* 82093E9Ch */ case   14:  		/* subf R11, R4, R11 */
		/* 82093E9Ch case   14:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R4,regs.R11);
		/* 82093E9Ch case   14:*/		return 0x82093EA0;
		  /* 82093EA0h */ case   15:  		/* addi R3, R4, 1 */
		/* 82093EA0h case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R4,0x1);
		/* 82093EA0h case   15:*/		return 0x82093EA4;
		  /* 82093EA4h */ case   16:  		/* addi R11, R11, -1 */
		/* 82093EA4h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82093EA4h case   16:*/		return 0x82093EA8;
		  /* 82093EA8h */ case   17:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 82093EA8h case   17:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 82093EA8h case   17:*/		return 0x82093EAC;
		  /* 82093EACh */ case   18:  		/* addi R5, R11, 1 */
		/* 82093EACh case   18:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x1);
		/* 82093EACh case   18:*/		return 0x82093EB0;
		  /* 82093EB0h */ case   19:  		/* bl -8080 */
		/* 82093EB0h case   19:*/		regs.LR = 0x82093EB4; return 0x82091F20;
		/* 82093EB0h case   19:*/		return 0x82093EB4;
	}
	return 0x82093EB4;
} // Block from 82093E64h-82093EB4h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82093EB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093EB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093EB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093EB4);
		  /* 82093EB4h */ case    0:  		/* lwz R10, <#[R27]> */
		/* 82093EB4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 82093EB4h case    0:*/		return 0x82093EB8;
		  /* 82093EB8h */ case    1:  		/* mr R11, R30 */
		/* 82093EB8h case    1:*/		regs.R11 = regs.R30;
		/* 82093EB8h case    1:*/		return 0x82093EBC;
		  /* 82093EBCh */ case    2:  		/* li R26, 45 */
		/* 82093EBCh case    2:*/		cpu::op::li<0>(regs,&regs.R26,0x2D);
		/* 82093EBCh case    2:*/		return 0x82093EC0;
		  /* 82093EC0h */ case    3:  		/* cmpwi CR6, R10, 45 */
		/* 82093EC0h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000002D);
		/* 82093EC0h case    3:*/		return 0x82093EC4;
		  /* 82093EC4h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 82093EC4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82093ED0;  }
		/* 82093EC4h case    4:*/		return 0x82093EC8;
		  /* 82093EC8h */ case    5:  		/* addi R11, R30, 1 */
		/* 82093EC8h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x1);
		/* 82093EC8h case    5:*/		return 0x82093ECC;
		  /* 82093ECCh */ case    6:  		/* stb R26, <#[R30]> */
		/* 82093ECCh case    6:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R30 + 0x00000000) );
		/* 82093ECCh case    6:*/		return 0x82093ED0;
	}
	return 0x82093ED0;
} // Block from 82093EB4h-82093ED0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82093ED0h
// Function '??4exception@std@@QAAAAV01@ABV01@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093ED0);
		  /* 82093ED0h */ case    0:  		/* cmpwi CR6, R31, 0 */
		/* 82093ED0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82093ED0h case    0:*/		return 0x82093ED4;
		  /* 82093ED4h */ case    1:  		/* bc 4, CR6_GT, 44 */
		/* 82093ED4h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82093F00;  }
		/* 82093ED4h case    1:*/		return 0x82093ED8;
		  /* 82093ED8h */ case    2:  		/* lbz R9, <#[R11 + 1]> */
		/* 82093ED8h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000001) );
		/* 82093ED8h case    2:*/		return 0x82093EDC;
		  /* 82093EDCh */ case    3:  		/* lis R8, -32217 */
		/* 82093EDCh case    3:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8227);
		/* 82093EDCh case    3:*/		return 0x82093EE0;
		  /* 82093EE0h */ case    4:  		/* addi R10, R11, 1 */
		/* 82093EE0h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x1);
		/* 82093EE0h case    4:*/		return 0x82093EE4;
		  /* 82093EE4h */ case    5:  		/* stb R9, <#[R11]> */
		/* 82093EE4h case    5:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82093EE4h case    5:*/		return 0x82093EE8;
		  /* 82093EE8h */ case    6:  		/* mr R11, R10 */
		/* 82093EE8h case    6:*/		regs.R11 = regs.R10;
		/* 82093EE8h case    6:*/		return 0x82093EEC;
		  /* 82093EECh */ case    7:  		/* lwz R9, <#[R8 + 8856]> */
		/* 82093EECh case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00002298) );
		/* 82093EECh case    7:*/		return 0x82093EF0;
		  /* 82093EF0h */ case    8:  		/* lwz R9, <#[R9 + 188]> */
		/* 82093EF0h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x000000BC) );
		/* 82093EF0h case    8:*/		return 0x82093EF4;
		  /* 82093EF4h */ case    9:  		/* lwz R9, <#[R9]> */
		/* 82093EF4h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 82093EF4h case    9:*/		return 0x82093EF8;
		  /* 82093EF8h */ case   10:  		/* lbz R9, <#[R9]> */
		/* 82093EF8h case   10:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 82093EF8h case   10:*/		return 0x82093EFC;
		  /* 82093EFCh */ case   11:  		/* stb R9, <#[R10]> */
		/* 82093EFCh case   11:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82093EFCh case   11:*/		return 0x82093F00;
	}
	return 0x82093F00;
} // Block from 82093ED0h-82093F00h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82093F00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093F00);
		  /* 82093F00h */ case    0:  		/* cntlzw R10, R28 */
		/* 82093F00h case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R28);
		/* 82093F00h case    0:*/		return 0x82093F04;
		  /* 82093F04h */ case    1:  		/* cmpwi CR6, R29, -1 */
		/* 82093F04h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFF);
		/* 82093F04h case    1:*/		return 0x82093F08;
		  /* 82093F08h */ case    2:  		/* rlwinm R10, R10, 27, 31, 31 */
		/* 82093F08h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R10);
		/* 82093F08h case    2:*/		return 0x82093F0C;
		  /* 82093F0Ch */ case    3:  		/* add R11, R10, R11 */
		/* 82093F0Ch case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82093F0Ch case    3:*/		return 0x82093F10;
		  /* 82093F10h */ case    4:  		/* add R31, R11, R31 */
		/* 82093F10h case    4:*/		cpu::op::add<0>(regs,&regs.R31,regs.R11,regs.R31);
		/* 82093F10h case    4:*/		return 0x82093F14;
		  /* 82093F14h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 82093F14h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82093F20;  }
		/* 82093F14h case    5:*/		return 0x82093F18;
		  /* 82093F18h */ case    6:  		/* li R4, -1 */
		/* 82093F18h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0xFFFFFFFF);
		/* 82093F18h case    6:*/		return 0x82093F1C;
		  /* 82093F1Ch */ case    7:  		/* b 12 */
		/* 82093F1Ch case    7:*/		return 0x82093F28;
		/* 82093F1Ch case    7:*/		return 0x82093F20;
	}
	return 0x82093F20;
} // Block from 82093F00h-82093F20h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82093F20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093F20);
		  /* 82093F20h */ case    0:  		/* subf R11, R31, R30 */
		/* 82093F20h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R31,regs.R30);
		/* 82093F20h case    0:*/		return 0x82093F24;
		  /* 82093F24h */ case    1:  		/* add R4, R11, R29 */
		/* 82093F24h case    1:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R29);
		/* 82093F24h case    1:*/		return 0x82093F28;
	}
	return 0x82093F28;
} // Block from 82093F20h-82093F28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82093F28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093F28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093F28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093F28);
		  /* 82093F28h */ case    0:  		/* lis R11, -32255 */
		/* 82093F28h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82093F28h case    0:*/		return 0x82093F2C;
		  /* 82093F2Ch */ case    1:  		/* mr R3, R31 */
		/* 82093F2Ch case    1:*/		regs.R3 = regs.R31;
		/* 82093F2Ch case    1:*/		return 0x82093F30;
		  /* 82093F30h */ case    2:  		/* addi R5, R11, -24428 */
		/* 82093F30h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFA094);
		/* 82093F30h case    2:*/		return 0x82093F34;
		  /* 82093F34h */ case    3:  		/* bl 21708 */
		/* 82093F34h case    3:*/		regs.LR = 0x82093F38; return 0x82099400;
		/* 82093F34h case    3:*/		return 0x82093F38;
		  /* 82093F38h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 82093F38h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82093F38h case    4:*/		return 0x82093F3C;
		  /* 82093F3Ch */ case    5:  		/* bc 4, CR0_EQ, 212 */
		/* 82093F3Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x82094010;  }
		/* 82093F3Ch case    5:*/		return 0x82093F40;
		  /* 82093F40h */ case    6:  		/* addi R3, R31, 2 */
		/* 82093F40h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x2);
		/* 82093F40h case    6:*/		return 0x82093F44;
		  /* 82093F44h */ case    7:  		/* cmpwi CR6, R25, 0 */
		/* 82093F44h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82093F44h case    7:*/		return 0x82093F48;
		  /* 82093F48h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 82093F48h case    8:*/		if ( regs.CR[6].eq ) { return 0x82093F54;  }
		/* 82093F48h case    8:*/		return 0x82093F4C;
		  /* 82093F4Ch */ case    9:  		/* li R11, 69 */
		/* 82093F4Ch case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x45);
		/* 82093F4Ch case    9:*/		return 0x82093F50;
		  /* 82093F50h */ case   10:  		/* stb R11, <#[R31]> */
		/* 82093F50h case   10:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82093F50h case   10:*/		return 0x82093F54;
	}
	return 0x82093F54;
} // Block from 82093F28h-82093F54h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82093F54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093F54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093F54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093F54);
		  /* 82093F54h */ case    0:  		/* lwz R11, <#[R27 + 12]> */
		/* 82093F54h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 82093F54h case    0:*/		return 0x82093F58;
	}
	return 0x82093F58;
} // Block from 82093F54h-82093F58h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82093F58h
// Function '??1exception@std@@UAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093F58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093F58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093F58);
		  /* 82093F58h */ case    0:  		/* addi R10, R31, 1 */
		/* 82093F58h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x1);
		/* 82093F58h case    0:*/		return 0x82093F5C;
		  /* 82093F5Ch */ case    1:  		/* lbz R11, <#[R11]> */
		/* 82093F5Ch case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82093F5Ch case    1:*/		return 0x82093F60;
		  /* 82093F60h */ case    2:  		/* cmplwi CR6, R11, 48 */
		/* 82093F60h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 82093F60h case    2:*/		return 0x82093F64;
		  /* 82093F64h */ case    3:  		/* bc 12, CR6_EQ, 124 */
		/* 82093F64h case    3:*/		if ( regs.CR[6].eq ) { return 0x82093FE0;  }
		/* 82093F64h case    3:*/		return 0x82093F68;
		  /* 82093F68h */ case    4:  		/* lwz R11, <#[R27 + 4]> */
		/* 82093F68h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82093F68h case    4:*/		return 0x82093F6C;
		  /* 82093F6Ch */ case    5:  		/* addic. R11, R11, -1 */
		/* 82093F6Ch case    5:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82093F6Ch case    5:*/		return 0x82093F70;
		  /* 82093F70h */ case    6:  		/* bc 4, CR0_LT, 12 */
		/* 82093F70h case    6:*/		if ( !regs.CR[0].lt ) { return 0x82093F7C;  }
		/* 82093F70h case    6:*/		return 0x82093F74;
		  /* 82093F74h */ case    7:  		/* neg R11, R11 */
		/* 82093F74h case    7:*/		cpu::op::neg<0>(regs,&regs.R11,regs.R11);
		/* 82093F74h case    7:*/		return 0x82093F78;
		  /* 82093F78h */ case    8:  		/* stb R26, <#[R10]> */
		/* 82093F78h case    8:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R10 + 0x00000000) );
		/* 82093F78h case    8:*/		return 0x82093F7C;
	}
	return 0x82093F7C;
} // Block from 82093F58h-82093F7Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82093F7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093F7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093F7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093F7C);
		  /* 82093F7Ch */ case    0:  		/* addi R10, R10, 1 */
		/* 82093F7Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82093F7Ch case    0:*/		return 0x82093F80;
		  /* 82093F80h */ case    1:  		/* cmpwi CR6, R11, 100 */
		/* 82093F80h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000064);
		/* 82093F80h case    1:*/		return 0x82093F84;
		  /* 82093F84h */ case    2:  		/* bc 12, CR6_LT, 36 */
		/* 82093F84h case    2:*/		if ( regs.CR[6].lt ) { return 0x82093FA8;  }
		/* 82093F84h case    2:*/		return 0x82093F88;
		  /* 82093F88h */ case    3:  		/* li R7, 100 */
		/* 82093F88h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x64);
		/* 82093F88h case    3:*/		return 0x82093F8C;
		  /* 82093F8Ch */ case    4:  		/* lbz R8, <#[R10]> */
		/* 82093F8Ch case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82093F8Ch case    4:*/		return 0x82093F90;
		  /* 82093F90h */ case    5:  		/* divw R9, R11, R7 */
		/* 82093F90h case    5:*/		cpu::op::divw<0>(regs,&regs.R9,regs.R11,regs.R7);
		/* 82093F90h case    5:*/		return 0x82093F94;
		  /* 82093F94h */ case    6:  		/* divw R7, R11, R7 */
		/* 82093F94h case    6:*/		cpu::op::divw<0>(regs,&regs.R7,regs.R11,regs.R7);
		/* 82093F94h case    6:*/		return 0x82093F98;
		  /* 82093F98h */ case    7:  		/* add R9, R9, R8 */
		/* 82093F98h case    7:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82093F98h case    7:*/		return 0x82093F9C;
		  /* 82093F9Ch */ case    8:  		/* mulli R8, R7, 100 */
		/* 82093F9Ch case    8:*/		cpu::op::mulli<0>(regs,&regs.R8,regs.R7,0x64);
		/* 82093F9Ch case    8:*/		return 0x82093FA0;
		  /* 82093FA0h */ case    9:  		/* stb R9, <#[R10]> */
		/* 82093FA0h case    9:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82093FA0h case    9:*/		return 0x82093FA4;
		  /* 82093FA4h */ case   10:  		/* subf R11, R8, R11 */
		/* 82093FA4h case   10:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82093FA4h case   10:*/		return 0x82093FA8;
	}
	return 0x82093FA8;
} // Block from 82093F7Ch-82093FA8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82093FA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093FA8);
		  /* 82093FA8h */ case    0:  		/* addi R10, R10, 1 */
		/* 82093FA8h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82093FA8h case    0:*/		return 0x82093FAC;
		  /* 82093FACh */ case    1:  		/* cmpwi CR6, R11, 10 */
		/* 82093FACh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000A);
		/* 82093FACh case    1:*/		return 0x82093FB0;
	}
	return 0x82093FB0;
} // Block from 82093FA8h-82093FB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82093FB0h
// Function '??1bad_alloc@std@@UAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093FB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093FB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093FB0);
		  /* 82093FB0h */ case    0:  		/* bc 12, CR6_LT, 36 */
		/* 82093FB0h case    0:*/		if ( regs.CR[6].lt ) { return 0x82093FD4;  }
		/* 82093FB0h case    0:*/		return 0x82093FB4;
		  /* 82093FB4h */ case    1:  		/* li R7, 10 */
		/* 82093FB4h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0xA);
		/* 82093FB4h case    1:*/		return 0x82093FB8;
		  /* 82093FB8h */ case    2:  		/* lbz R8, <#[R10]> */
		/* 82093FB8h case    2:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82093FB8h case    2:*/		return 0x82093FBC;
		  /* 82093FBCh */ case    3:  		/* divw R9, R11, R7 */
		/* 82093FBCh case    3:*/		cpu::op::divw<0>(regs,&regs.R9,regs.R11,regs.R7);
		/* 82093FBCh case    3:*/		return 0x82093FC0;
	}
	return 0x82093FC0;
} // Block from 82093FB0h-82093FC0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82093FC0h
// Function '??_Gbad_alloc@std@@UAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093FC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093FC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093FC0);
		  /* 82093FC0h */ case    0:  		/* divw R7, R11, R7 */
		/* 82093FC0h case    0:*/		cpu::op::divw<0>(regs,&regs.R7,regs.R11,regs.R7);
		/* 82093FC0h case    0:*/		return 0x82093FC4;
		  /* 82093FC4h */ case    1:  		/* add R9, R9, R8 */
		/* 82093FC4h case    1:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82093FC4h case    1:*/		return 0x82093FC8;
		  /* 82093FC8h */ case    2:  		/* mulli R8, R7, 10 */
		/* 82093FC8h case    2:*/		cpu::op::mulli<0>(regs,&regs.R8,regs.R7,0xA);
		/* 82093FC8h case    2:*/		return 0x82093FCC;
		  /* 82093FCCh */ case    3:  		/* stb R9, <#[R10]> */
		/* 82093FCCh case    3:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82093FCCh case    3:*/		return 0x82093FD0;
		  /* 82093FD0h */ case    4:  		/* subf R11, R8, R11 */
		/* 82093FD0h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82093FD0h case    4:*/		return 0x82093FD4;
	}
	return 0x82093FD4;
} // Block from 82093FC0h-82093FD4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82093FD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093FD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093FD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093FD4);
		  /* 82093FD4h */ case    0:  		/* lbzu R9, <#[R10 + 1]> */
		/* 82093FD4h case    0:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000001) );
		regs.R10 = (uint32)(regs.R10 + 0x00000001);
		/* 82093FD4h case    0:*/		return 0x82093FD8;
		  /* 82093FD8h */ case    1:  		/* add R11, R9, R11 */
		/* 82093FD8h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82093FD8h case    1:*/		return 0x82093FDC;
		  /* 82093FDCh */ case    2:  		/* stb R11, <#[R10]> */
		/* 82093FDCh case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82093FDCh case    2:*/		return 0x82093FE0;
	}
	return 0x82093FE0;
} // Block from 82093FD4h-82093FE0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82093FE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82093FE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82093FE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82093FE0);
		  /* 82093FE0h */ case    0:  		/* lis R11, -32215 */
		/* 82093FE0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82093FE0h case    0:*/		return 0x82093FE4;
		  /* 82093FE4h */ case    1:  		/* lwz R11, <#[R11 - 30276]> */
		/* 82093FE4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFF89BC) );
		/* 82093FE4h case    1:*/		return 0x82093FE8;
		  /* 82093FE8h */ case    2:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82093FE8h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82093FE8h case    2:*/		return 0x82093FEC;
		  /* 82093FECh */ case    3:  		/* bc 12, CR0_EQ, 28 */
		/* 82093FECh case    3:*/		if ( regs.CR[0].eq ) { return 0x82094008;  }
		/* 82093FECh case    3:*/		return 0x82093FF0;
		  /* 82093FF0h */ case    4:  		/* lbz R11, <#[R3]> */
		/* 82093FF0h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82093FF0h case    4:*/		return 0x82093FF4;
		  /* 82093FF4h */ case    5:  		/* cmplwi CR6, R11, 48 */
		/* 82093FF4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 82093FF4h case    5:*/		return 0x82093FF8;
		  /* 82093FF8h */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 82093FF8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82094008;  }
		/* 82093FF8h case    6:*/		return 0x82093FFC;
		  /* 82093FFCh */ case    7:  		/* addi R4, R3, 1 */
		/* 82093FFCh case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0x1);
		/* 82093FFCh case    7:*/		return 0x82094000;
		  /* 82094000h */ case    8:  		/* li R5, 3 */
		/* 82094000h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 82094000h case    8:*/		return 0x82094004;
		  /* 82094004h */ case    9:  		/* bl -8420 */
		/* 82094004h case    9:*/		regs.LR = 0x82094008; return 0x82091F20;
		/* 82094004h case    9:*/		return 0x82094008;
	}
	return 0x82094008;
} // Block from 82093FE0h-82094008h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82094008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094008);
		  /* 82094008h */ case    0:  		/* li R3, 0 */
		/* 82094008h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82094008h case    0:*/		return 0x8209400C;
		  /* 8209400Ch */ case    1:  		/* b -504 */
		/* 8209400Ch case    1:*/		return 0x82093E14;
		/* 8209400Ch case    1:*/		return 0x82094010;
	}
	return 0x82094010;
} // Block from 82094008h-82094010h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82094010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094010);
		  /* 82094010h */ case    0:  		/* li R7, 0 */
		/* 82094010h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82094010h case    0:*/		return 0x82094014;
		  /* 82094014h */ case    1:  		/* li R6, 0 */
		/* 82094014h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82094014h case    1:*/		return 0x82094018;
	}
	return 0x82094018;
} // Block from 82094010h-82094018h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82094018h
// Function '??0exception@std@@QAA@ABV01@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094018);
		  /* 82094018h */ case    0:  		/* li R5, 0 */
		/* 82094018h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82094018h case    0:*/		return 0x8209401C;
		  /* 8209401Ch */ case    1:  		/* li R4, 0 */
		/* 8209401Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8209401Ch case    1:*/		return 0x82094020;
		  /* 82094020h */ case    2:  		/* li R3, 0 */
		/* 82094020h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82094020h case    2:*/		return 0x82094024;
		  /* 82094024h */ case    3:  		/* bl -1516 */
		/* 82094024h case    3:*/		regs.LR = 0x82094028; return 0x82093A38;
		/* 82094024h case    3:*/		return 0x82094028;
	}
	return 0x82094028;
} // Block from 82094018h-82094028h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82094028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094028);
		  /* 82094028h */ case    0:  		/* mfspr R12, LR */
		/* 82094028h case    0:*/		regs.R12 = regs.LR;
		/* 82094028h case    0:*/		return 0x8209402C;
		  /* 8209402Ch */ case    1:  		/* bl -11732 */
		/* 8209402Ch case    1:*/		regs.LR = 0x82094030; return 0x82091258;
		/* 8209402Ch case    1:*/		return 0x82094030;
		  /* 82094030h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82094030h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82094030h case    2:*/		return 0x82094034;
		  /* 82094034h */ case    3:  		/* mr R30, R4 */
		/* 82094034h case    3:*/		regs.R30 = regs.R4;
		/* 82094034h case    3:*/		return 0x82094038;
		  /* 82094038h */ case    4:  		/* ld R3, <#[R3]> */
		/* 82094038h case    4:*/		cpu::mem::load64( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 82094038h case    4:*/		return 0x8209403C;
		  /* 8209403Ch */ case    5:  		/* mr R29, R5 */
		/* 8209403Ch case    5:*/		regs.R29 = regs.R5;
		/* 8209403Ch case    5:*/		return 0x82094040;
		  /* 82094040h */ case    6:  		/* mr R31, R6 */
		/* 82094040h case    6:*/		regs.R31 = regs.R6;
		/* 82094040h case    6:*/		return 0x82094044;
		  /* 82094044h */ case    7:  		/* li R6, 22 */
		/* 82094044h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x16);
		/* 82094044h case    7:*/		return 0x82094048;
		  /* 82094048h */ case    8:  		/* addi R5, R1, 96 */
		/* 82094048h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 82094048h case    8:*/		return 0x8209404C;
		  /* 8209404Ch */ case    9:  		/* addi R4, R1, 80 */
		/* 8209404Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8209404Ch case    9:*/		return 0x82094050;
		  /* 82094050h */ case   10:  		/* mr R28, R7 */
		/* 82094050h case   10:*/		regs.R28 = regs.R7;
		/* 82094050h case   10:*/		return 0x82094054;
		  /* 82094054h */ case   11:  		/* bl 23268 */
		/* 82094054h case   11:*/		regs.LR = 0x82094058; return 0x82099B38;
		/* 82094054h case   11:*/		return 0x82094058;
		  /* 82094058h */ case   12:  		/* cmplwi CR6, R30, 0 */
		/* 82094058h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82094058h case   12:*/		return 0x8209405C;
		  /* 8209405Ch */ case   13:  		/* bc 4, CR6_EQ, 28 */
		/* 8209405Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x82094078;  }
		/* 8209405Ch case   13:*/		return 0x82094060;
	}
	return 0x82094060;
} // Block from 82094028h-82094060h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82094060h
// Function '??0bad_alloc@std@@QAA@ABV01@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094060);
		  /* 82094060h */ case    0:  		/* bl 3752 */
		/* 82094060h case    0:*/		regs.LR = 0x82094064; return 0x82094F08;
		/* 82094060h case    0:*/		return 0x82094064;
		  /* 82094064h */ case    1:  		/* li R11, 22 */
		/* 82094064h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 82094064h case    1:*/		return 0x82094068;
		  /* 82094068h */ case    2:  		/* stw R11, <#[R3]> */
		/* 82094068h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82094068h case    2:*/		return 0x8209406C;
		  /* 8209406Ch */ case    3:  		/* bl -1804 */
		/* 8209406Ch case    3:*/		regs.LR = 0x82094070; return 0x82093960;
		/* 8209406Ch case    3:*/		return 0x82094070;
		  /* 82094070h */ case    4:  		/* li R3, 22 */
		/* 82094070h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x16);
		/* 82094070h case    4:*/		return 0x82094074;
		  /* 82094074h */ case    5:  		/* b 156 */
		/* 82094074h case    5:*/		return 0x82094110;
		/* 82094074h case    5:*/		return 0x82094078;
	}
	return 0x82094078;
} // Block from 82094060h-82094078h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82094078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094078);
		  /* 82094078h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 82094078h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82094078h case    0:*/		return 0x8209407C;
		  /* 8209407Ch */ case    1:  		/* bc 12, CR6_EQ, -28 */
		/* 8209407Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82094060;  }
		/* 8209407Ch case    1:*/		return 0x82094080;
		  /* 82094080h */ case    2:  		/* lwz R11, <#[R1 + 80]> */
		/* 82094080h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82094080h case    2:*/		return 0x82094084;
		  /* 82094084h */ case    3:  		/* cmpwi CR6, R29, -1 */
		/* 82094084h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFF);
		/* 82094084h case    3:*/		return 0x82094088;
		  /* 82094088h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 82094088h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82094094;  }
		/* 82094088h case    4:*/		return 0x8209408C;
		  /* 8209408Ch */ case    5:  		/* li R4, -1 */
		/* 8209408Ch case    5:*/		cpu::op::li<0>(regs,&regs.R4,0xFFFFFFFF);
		/* 8209408Ch case    5:*/		return 0x82094090;
		  /* 82094090h */ case    6:  		/* b 36 */
		/* 82094090h case    6:*/		return 0x820940B4;
		/* 82094090h case    6:*/		return 0x82094094;
	}
	return 0x82094094;
} // Block from 82094078h-82094094h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82094094h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094094( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094094) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094094);
		  /* 82094094h */ case    0:  		/* addi R10, R11, -45 */
		/* 82094094h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFD3);
		/* 82094094h case    0:*/		return 0x82094098;
		  /* 82094098h */ case    1:  		/* neg R9, R31 */
		/* 82094098h case    1:*/		cpu::op::neg<0>(regs,&regs.R9,regs.R31);
		/* 82094098h case    1:*/		return 0x8209409C;
		  /* 8209409Ch */ case    2:  		/* cntlzw R10, R10 */
		/* 8209409Ch case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 8209409Ch case    2:*/		return 0x820940A0;
		  /* 820940A0h */ case    3:  		/* andc R9, R9, R31 */
		/* 820940A0h case    3:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R9,regs.R31);
		/* 820940A0h case    3:*/		return 0x820940A4;
		  /* 820940A4h */ case    4:  		/* rlwinm R10, R10, 27, 31, 31 */
		/* 820940A4h case    4:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R10);
		/* 820940A4h case    4:*/		return 0x820940A8;
		  /* 820940A8h */ case    5:  		/* rlwinm R9, R9, 1, 31, 31 */
		/* 820940A8h case    5:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R9,regs.R9);
		/* 820940A8h case    5:*/		return 0x820940AC;
		  /* 820940ACh */ case    6:  		/* subf R10, R10, R29 */
		/* 820940ACh case    6:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R29);
		/* 820940ACh case    6:*/		return 0x820940B0;
		  /* 820940B0h */ case    7:  		/* subf R4, R9, R10 */
		/* 820940B0h case    7:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R9,regs.R10);
		/* 820940B0h case    7:*/		return 0x820940B4;
	}
	return 0x820940B4;
} // Block from 82094094h-820940B4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820940B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820940B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820940B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820940B4);
		  /* 820940B4h */ case    0:  		/* addi R11, R11, -45 */
		/* 820940B4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFD3);
		/* 820940B4h case    0:*/		return 0x820940B8;
	}
	return 0x820940B8;
} // Block from 820940B4h-820940B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820940B8h
// Function '??2@YAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820940B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820940B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820940B8);
		  /* 820940B8h */ case    0:  		/* neg R10, R31 */
		/* 820940B8h case    0:*/		cpu::op::neg<0>(regs,&regs.R10,regs.R31);
		/* 820940B8h case    0:*/		return 0x820940BC;
		  /* 820940BCh */ case    1:  		/* cntlzw R11, R11 */
		/* 820940BCh case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820940BCh case    1:*/		return 0x820940C0;
		  /* 820940C0h */ case    2:  		/* andc R9, R10, R31 */
		/* 820940C0h case    2:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R10,regs.R31);
		/* 820940C0h case    2:*/		return 0x820940C4;
		  /* 820940C4h */ case    3:  		/* rlwinm R10, R11, 27, 31, 31 */
		/* 820940C4h case    3:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R11);
		/* 820940C4h case    3:*/		return 0x820940C8;
		  /* 820940C8h */ case    4:  		/* rlwinm R11, R9, 1, 31, 31 */
		/* 820940C8h case    4:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R9);
		/* 820940C8h case    4:*/		return 0x820940CC;
		  /* 820940CCh */ case    5:  		/* addi R6, R1, 80 */
		/* 820940CCh case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 820940CCh case    5:*/		return 0x820940D0;
		  /* 820940D0h */ case    6:  		/* add R11, R10, R11 */
		/* 820940D0h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820940D0h case    6:*/		return 0x820940D4;
		  /* 820940D4h */ case    7:  		/* addi R5, R31, 1 */
		/* 820940D4h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x1);
		/* 820940D4h case    7:*/		return 0x820940D8;
		  /* 820940D8h */ case    8:  		/* add R3, R11, R30 */
		/* 820940D8h case    8:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R30);
		/* 820940D8h case    8:*/		return 0x820940DC;
		  /* 820940DCh */ case    9:  		/* bl 22556 */
		/* 820940DCh case    9:*/		regs.LR = 0x820940E0; return 0x820998F8;
		/* 820940DCh case    9:*/		return 0x820940E0;
		  /* 820940E0h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 820940E0h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820940E0h case   10:*/		return 0x820940E4;
		  /* 820940E4h */ case   11:  		/* bc 12, CR0_EQ, 16 */
		/* 820940E4h case   11:*/		if ( regs.CR[0].eq ) { return 0x820940F4;  }
		/* 820940E4h case   11:*/		return 0x820940E8;
		  /* 820940E8h */ case   12:  		/* li R11, 0 */
		/* 820940E8h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820940E8h case   12:*/		return 0x820940EC;
		  /* 820940ECh */ case   13:  		/* stb R11, <#[R30]> */
		/* 820940ECh case   13:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820940ECh case   13:*/		return 0x820940F0;
		  /* 820940F0h */ case   14:  		/* b 32 */
		/* 820940F0h case   14:*/		return 0x82094110;
		/* 820940F0h case   14:*/		return 0x820940F4;
	}
	return 0x820940F4;
} // Block from 820940B8h-820940F4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820940F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820940F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820940F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820940F4);
		  /* 820940F4h */ case    0:  		/* li R8, 0 */
		/* 820940F4h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820940F4h case    0:*/		return 0x820940F8;
		  /* 820940F8h */ case    1:  		/* addi R7, R1, 80 */
		/* 820940F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 820940F8h case    1:*/		return 0x820940FC;
		  /* 820940FCh */ case    2:  		/* mr R6, R28 */
		/* 820940FCh case    2:*/		regs.R6 = regs.R28;
		/* 820940FCh case    2:*/		return 0x82094100;
		  /* 82094100h */ case    3:  		/* mr R5, R31 */
		/* 82094100h case    3:*/		regs.R5 = regs.R31;
		/* 82094100h case    3:*/		return 0x82094104;
		  /* 82094104h */ case    4:  		/* mr R4, R29 */
		/* 82094104h case    4:*/		regs.R4 = regs.R29;
		/* 82094104h case    4:*/		return 0x82094108;
		  /* 82094108h */ case    5:  		/* mr R3, R30 */
		/* 82094108h case    5:*/		regs.R3 = regs.R30;
		/* 82094108h case    5:*/		return 0x8209410C;
		  /* 8209410Ch */ case    6:  		/* bl -820 */
		/* 8209410Ch case    6:*/		regs.LR = 0x82094110; return 0x82093DD8;
		/* 8209410Ch case    6:*/		return 0x82094110;
	}
	return 0x82094110;
} // Block from 820940F4h-82094110h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82094110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094110);
		  /* 82094110h */ case    0:  		/* addi R1, R1, 160 */
		/* 82094110h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82094110h case    0:*/		return 0x82094114;
		  /* 82094114h */ case    1:  		/* b -11884 */
		/* 82094114h case    1:*/		return 0x820912A8;
		/* 82094114h case    1:*/		return 0x82094118;
	}
	return 0x82094118;
} // Block from 82094110h-82094118h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82094118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094118);
		  /* 82094118h */ case    0:  		/* mfspr R12, LR */
		/* 82094118h case    0:*/		regs.R12 = regs.LR;
		/* 82094118h case    0:*/		return 0x8209411C;
		  /* 8209411Ch */ case    1:  		/* bl -11980 */
		/* 8209411Ch case    1:*/		regs.LR = 0x82094120; return 0x82091250;
		/* 8209411Ch case    1:*/		return 0x82094120;
		  /* 82094120h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82094120h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82094120h case    2:*/		return 0x82094124;
		  /* 82094124h */ case    3:  		/* rlwinm R11, R6, 1, 31, 31 */
		/* 82094124h case    3:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R6);
		/* 82094124h case    3:*/		return 0x82094128;
		  /* 82094128h */ case    4:  		/* li R28, 48 */
		/* 82094128h case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x30);
		/* 82094128h case    4:*/		return 0x8209412C;
		  /* 8209412Ch */ case    5:  		/* addi R11, R11, -1 */
		/* 8209412Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8209412Ch case    5:*/		return 0x82094130;
		  /* 82094130h */ case    6:  		/* mr R29, R7 */
		/* 82094130h case    6:*/		regs.R29 = regs.R7;
		/* 82094130h case    6:*/		return 0x82094134;
		  /* 82094134h */ case    7:  		/* mr R31, R4 */
		/* 82094134h case    7:*/		regs.R31 = regs.R4;
		/* 82094134h case    7:*/		return 0x82094138;
		  /* 82094138h */ case    8:  		/* li R30, 1023 */
		/* 82094138h case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x3FF);
		/* 82094138h case    8:*/		return 0x8209413C;
		  /* 8209413Ch */ case    9:  		/* mr R7, R28 */
		/* 8209413Ch case    9:*/		regs.R7 = regs.R28;
		/* 8209413Ch case    9:*/		return 0x82094140;
		  /* 82094140h */ case   10:  		/* and R6, R11, R6 */
		/* 82094140h case   10:*/		cpu::op::and<0>(regs,&regs.R6,regs.R11,regs.R6);
		/* 82094140h case   10:*/		return 0x82094144;
		  /* 82094144h */ case   11:  		/* cmplwi CR6, R4, 0 */
		/* 82094144h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82094144h case   11:*/		return 0x82094148;
		  /* 82094148h */ case   12:  		/* bc 4, CR6_EQ, 28 */
		/* 82094148h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82094164;  }
		/* 82094148h case   12:*/		return 0x8209414C;
		  /* 8209414Ch */ case   13:  		/* bl 3516 */
		/* 8209414Ch case   13:*/		regs.LR = 0x82094150; return 0x82094F08;
		/* 8209414Ch case   13:*/		return 0x82094150;
		  /* 82094150h */ case   14:  		/* li R11, 22 */
		/* 82094150h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 82094150h case   14:*/		return 0x82094154;
		  /* 82094154h */ case   15:  		/* stw R11, <#[R3]> */
		/* 82094154h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82094154h case   15:*/		return 0x82094158;
		  /* 82094158h */ case   16:  		/* bl -2040 */
		/* 82094158h case   16:*/		regs.LR = 0x8209415C; return 0x82093960;
		/* 82094158h case   16:*/		return 0x8209415C;
		  /* 8209415Ch */ case   17:  		/* li R3, 22 */
		/* 8209415Ch case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x16);
		/* 8209415Ch case   17:*/		return 0x82094160;
		  /* 82094160h */ case   18:  		/* b 960 */
		/* 82094160h case   18:*/		return 0x82094520;
		/* 82094160h case   18:*/		return 0x82094164;
	}
	return 0x82094164;
} // Block from 82094118h-82094164h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82094164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094164);
		  /* 82094164h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 82094164h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82094164h case    0:*/		return 0x82094168;
		  /* 82094168h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 82094168h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82094184;  }
		/* 82094168h case    1:*/		return 0x8209416C;
		  /* 8209416Ch */ case    2:  		/* bl 3484 */
		/* 8209416Ch case    2:*/		regs.LR = 0x82094170; return 0x82094F08;
		/* 8209416Ch case    2:*/		return 0x82094170;
	}
	return 0x82094170;
} // Block from 82094164h-82094170h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82094170h
// Function 'malloc'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094170);
		  /* 82094170h */ case    0:  		/* li R31, 22 */
		/* 82094170h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x16);
		/* 82094170h case    0:*/		return 0x82094174;
		  /* 82094174h */ case    1:  		/* stw R31, <#[R3]> */
		/* 82094174h case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82094174h case    1:*/		return 0x82094178;
		  /* 82094178h */ case    2:  		/* bl -2072 */
		/* 82094178h case    2:*/		regs.LR = 0x8209417C; return 0x82093960;
		/* 82094178h case    2:*/		return 0x8209417C;
		  /* 8209417Ch */ case    3:  		/* mr R3, R31 */
		/* 8209417Ch case    3:*/		regs.R3 = regs.R31;
		/* 8209417Ch case    3:*/		return 0x82094180;
		  /* 82094180h */ case    4:  		/* b 928 */
		/* 82094180h case    4:*/		return 0x82094520;
		/* 82094180h case    4:*/		return 0x82094184;
	}
	return 0x82094184;
} // Block from 82094170h-82094184h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82094184h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094184( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094184) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094184);
		  /* 82094184h */ case    0:  		/* li R26, 0 */
		/* 82094184h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82094184h case    0:*/		return 0x82094188;
		  /* 82094188h */ case    1:  		/* addi R11, R6, 11 */
		/* 82094188h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R6,0xB);
		/* 82094188h case    1:*/		return 0x8209418C;
		  /* 8209418Ch */ case    2:  		/* stb R26, <#[R31]> */
		/* 8209418Ch case    2:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R31 + 0x00000000) );
		/* 8209418Ch case    2:*/		return 0x82094190;
		  /* 82094190h */ case    3:  		/* cmplw CR6, R5, R11 */
		/* 82094190h case    3:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 82094190h case    3:*/		return 0x82094194;
		  /* 82094194h */ case    4:  		/* bc 12, CR6_GT, 16 */
		/* 82094194h case    4:*/		if ( regs.CR[6].gt ) { return 0x820941A4;  }
		/* 82094194h case    4:*/		return 0x82094198;
		  /* 82094198h */ case    5:  		/* bl 3440 */
		/* 82094198h case    5:*/		regs.LR = 0x8209419C; return 0x82094F08;
		/* 82094198h case    5:*/		return 0x8209419C;
		  /* 8209419Ch */ case    6:  		/* li R31, 34 */
		/* 8209419Ch case    6:*/		cpu::op::li<0>(regs,&regs.R31,0x22);
		/* 8209419Ch case    6:*/		return 0x820941A0;
		  /* 820941A0h */ case    7:  		/* b -44 */
		/* 820941A0h case    7:*/		return 0x82094174;
		/* 820941A0h case    7:*/		return 0x820941A4;
	}
	return 0x820941A4;
} // Block from 82094184h-820941A4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820941A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820941A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820941A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820941A4);
		  /* 820941A4h */ case    0:  		/* ld R11, <#[R3]> */
		/* 820941A4h case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820941A4h case    0:*/		return 0x820941A8;
		  /* 820941A8h */ case    1:  		/* rldicl R10, R11, 12, 53 */
		/* 820941A8h case    1:*/		cpu::op::rldicl<0,12,53>(regs,&regs.R10,regs.R11);
		/* 820941A8h case    1:*/		return 0x820941AC;
		  /* 820941ACh */ case    2:  		/* cmpldi CR6, R10, 2047 */
		/* 820941ACh case    2:*/		cpu::op::cmpldi<6>(regs,regs.R10,0x000007FF);
		/* 820941ACh case    2:*/		return 0x820941B0;
		  /* 820941B0h */ case    3:  		/* bc 4, CR6_EQ, 152 */
		/* 820941B0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82094248;  }
		/* 820941B0h case    3:*/		return 0x820941B4;
		  /* 820941B4h */ case    4:  		/* cmpwi CR6, R5, -1 */
		/* 820941B4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R5,0xFFFFFFFF);
		/* 820941B4h case    4:*/		return 0x820941B8;
		  /* 820941B8h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 820941B8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820941C4;  }
		/* 820941B8h case    5:*/		return 0x820941BC;
		  /* 820941BCh */ case    6:  		/* li R5, -1 */
		/* 820941BCh case    6:*/		cpu::op::li<0>(regs,&regs.R5,0xFFFFFFFF);
		/* 820941BCh case    6:*/		return 0x820941C0;
		  /* 820941C0h */ case    7:  		/* b 8 */
		/* 820941C0h case    7:*/		return 0x820941C8;
		/* 820941C0h case    7:*/		return 0x820941C4;
	}
	return 0x820941C4;
} // Block from 820941A4h-820941C4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820941C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820941C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820941C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820941C4);
		  /* 820941C4h */ case    0:  		/* addi R5, R5, -2 */
		/* 820941C4h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0xFFFFFFFE);
		/* 820941C4h case    0:*/		return 0x820941C8;
	}
	return 0x820941C8;
} // Block from 820941C4h-820941C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820941C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820941C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820941C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820941C8);
		  /* 820941C8h */ case    0:  		/* addi R30, R31, 2 */
		/* 820941C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x2);
		/* 820941C8h case    0:*/		return 0x820941CC;
		  /* 820941CCh */ case    1:  		/* li R8, 0 */
		/* 820941CCh case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820941CCh case    1:*/		return 0x820941D0;
		  /* 820941D0h */ case    2:  		/* li R7, 0 */
		/* 820941D0h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820941D0h case    2:*/		return 0x820941D4;
		  /* 820941D4h */ case    3:  		/* mr R4, R30 */
		/* 820941D4h case    3:*/		regs.R4 = regs.R30;
		/* 820941D4h case    3:*/		return 0x820941D8;
		  /* 820941D8h */ case    4:  		/* bl -432 */
		/* 820941D8h case    4:*/		regs.LR = 0x820941DC; return 0x82094028;
		/* 820941D8h case    4:*/		return 0x820941DC;
		  /* 820941DCh */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820941DCh case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820941DCh case    5:*/		return 0x820941E0;
		  /* 820941E0h */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 820941E0h case    6:*/		if ( regs.CR[0].eq ) { return 0x820941EC;  }
		/* 820941E0h case    6:*/		return 0x820941E4;
		  /* 820941E4h */ case    7:  		/* stb R26, <#[R31]> */
		/* 820941E4h case    7:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R31 + 0x00000000) );
		/* 820941E4h case    7:*/		return 0x820941E8;
		  /* 820941E8h */ case    8:  		/* b 824 */
		/* 820941E8h case    8:*/		return 0x82094520;
		/* 820941E8h case    8:*/		return 0x820941EC;
	}
	return 0x820941EC;
} // Block from 820941C8h-820941ECh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820941ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820941EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820941EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820941EC);
		  /* 820941ECh */ case    0:  		/* lbz R11, <#[R30]> */
		/* 820941ECh case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820941ECh case    0:*/		return 0x820941F0;
		  /* 820941F0h */ case    1:  		/* cmplwi CR6, R11, 45 */
		/* 820941F0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002D);
		/* 820941F0h case    1:*/		return 0x820941F4;
		  /* 820941F4h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 820941F4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82094200;  }
		/* 820941F4h case    2:*/		return 0x820941F8;
		  /* 820941F8h */ case    3:  		/* stb R11, <#[R31]> */
		/* 820941F8h case    3:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820941F8h case    3:*/		return 0x820941FC;
		  /* 820941FCh */ case    4:  		/* addi R31, R31, 1 */
		/* 820941FCh case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820941FCh case    4:*/		return 0x82094200;
	}
	return 0x82094200;
} // Block from 820941ECh-82094200h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82094200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094200);
		  /* 82094200h */ case    0:  		/* subfic R11, R29, 0 */
		/* 82094200h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R29,0x0);
		/* 82094200h case    0:*/		return 0x82094204;
		  /* 82094204h */ case    1:  		/* stb R28, <#[R31]> */
		/* 82094204h case    1:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 82094204h case    1:*/		return 0x82094208;
		  /* 82094208h */ case    2:  		/* li R4, 101 */
		/* 82094208h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x65);
		/* 82094208h case    2:*/		return 0x8209420C;
		  /* 8209420Ch */ case    3:  		/* subfe R11, R11, R11 */
		/* 8209420Ch case    3:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8209420Ch case    3:*/		return 0x82094210;
		  /* 82094210h */ case    4:  		/* rlwinm R11, R11, 0, 0, 26 */
		/* 82094210h case    4:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R11,regs.R11);
		/* 82094210h case    4:*/		return 0x82094214;
		  /* 82094214h */ case    5:  		/* addi R11, R11, 120 */
		/* 82094214h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x78);
		/* 82094214h case    5:*/		return 0x82094218;
		  /* 82094218h */ case    6:  		/* stbu R11, <#[R31 + 1]> */
		/* 82094218h case    6:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000001) );
		regs.R31 = (uint32)(regs.R31 + 0x00000001);
		/* 82094218h case    6:*/		return 0x8209421C;
		  /* 8209421Ch */ case    7:  		/* addi R3, R31, 1 */
		/* 8209421Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x1);
		/* 8209421Ch case    7:*/		return 0x82094220;
		  /* 82094220h */ case    8:  		/* bl -3664 */
		/* 82094220h case    8:*/		regs.LR = 0x82094224; return 0x820933D0;
		/* 82094220h case    8:*/		return 0x82094224;
		  /* 82094224h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 82094224h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82094224h case    9:*/		return 0x82094228;
		  /* 82094228h */ case   10:  		/* bc 12, CR0_EQ, 756 */
		/* 82094228h case   10:*/		if ( regs.CR[0].eq ) { return 0x8209451C;  }
		/* 82094228h case   10:*/		return 0x8209422C;
		  /* 8209422Ch */ case   11:  		/* subfic R11, R29, 0 */
		/* 8209422Ch case   11:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R29,0x0);
		/* 8209422Ch case   11:*/		return 0x82094230;
		  /* 82094230h */ case   12:  		/* subfe R11, R11, R11 */
		/* 82094230h case   12:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82094230h case   12:*/		return 0x82094234;
		  /* 82094234h */ case   13:  		/* rlwinm R11, R11, 0, 0, 26 */
		/* 82094234h case   13:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R11,regs.R11);
		/* 82094234h case   13:*/		return 0x82094238;
	}
	return 0x82094238;
} // Block from 82094200h-82094238h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82094238h
// Function 'free'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094238);
		  /* 82094238h */ case    0:  		/* addi R11, R11, 112 */
		/* 82094238h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x70);
		/* 82094238h case    0:*/		return 0x8209423C;
		  /* 8209423Ch */ case    1:  		/* stb R11, <#[R3]> */
		/* 8209423Ch case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209423Ch case    1:*/		return 0x82094240;
		  /* 82094240h */ case    2:  		/* stb R26, <#[R3 + 3]> */
		/* 82094240h case    2:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R3 + 0x00000003) );
		/* 82094240h case    2:*/		return 0x82094244;
		  /* 82094244h */ case    3:  		/* b 728 */
		/* 82094244h case    3:*/		return 0x8209451C;
		/* 82094244h case    3:*/		return 0x82094248;
	}
	return 0x82094248;
} // Block from 82094238h-82094248h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82094248h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094248);
		  /* 82094248h */ case    0:  		/* rldicr R11, R11, 0, 0 */
		/* 82094248h case    0:*/		cpu::op::rldicr<0,0,0>(regs,&regs.R11,regs.R11);
		/* 82094248h case    0:*/		return 0x8209424C;
		  /* 8209424Ch */ case    1:  		/* li R27, 45 */
		/* 8209424Ch case    1:*/		cpu::op::li<0>(regs,&regs.R27,0x2D);
		/* 8209424Ch case    1:*/		return 0x82094250;
		  /* 82094250h */ case    2:  		/* cmpldi CR6, R11, 0 */
		/* 82094250h case    2:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82094250h case    2:*/		return 0x82094254;
		  /* 82094254h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82094254h case    3:*/		if ( regs.CR[6].eq ) { return 0x82094260;  }
		/* 82094254h case    3:*/		return 0x82094258;
		  /* 82094258h */ case    4:  		/* stb R27, <#[R31]> */
		/* 82094258h case    4:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R31 + 0x00000000) );
		/* 82094258h case    4:*/		return 0x8209425C;
		  /* 8209425Ch */ case    5:  		/* addi R31, R31, 1 */
		/* 8209425Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8209425Ch case    5:*/		return 0x82094260;
	}
	return 0x82094260;
} // Block from 82094248h-82094260h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82094260h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094260);
		  /* 82094260h */ case    0:  		/* subfic R11, R29, 0 */
		/* 82094260h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R29,0x0);
		/* 82094260h case    0:*/		return 0x82094264;
		  /* 82094264h */ case    1:  		/* stb R28, <#[R31]> */
		/* 82094264h case    1:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 82094264h case    1:*/		return 0x82094268;
		  /* 82094268h */ case    2:  		/* li R12, 2047 */
		/* 82094268h case    2:*/		cpu::op::li<0>(regs,&regs.R12,0x7FF);
		/* 82094268h case    2:*/		return 0x8209426C;
		  /* 8209426Ch */ case    3:  		/* subfe R11, R11, R11 */
		/* 8209426Ch case    3:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8209426Ch case    3:*/		return 0x82094270;
		  /* 82094270h */ case    4:  		/* subfic R10, R29, 0 */
		/* 82094270h case    4:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R29,0x0);
		/* 82094270h case    4:*/		return 0x82094274;
		  /* 82094274h */ case    5:  		/* rlwinm R11, R11, 0, 0, 26 */
		/* 82094274h case    5:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R11,regs.R11);
		/* 82094274h case    5:*/		return 0x82094278;
		  /* 82094278h */ case    6:  		/* subfe R10, R10, R10 */
		/* 82094278h case    6:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82094278h case    6:*/		return 0x8209427C;
		  /* 8209427Ch */ case    7:  		/* addi R11, R11, 120 */
		/* 8209427Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x78);
		/* 8209427Ch case    7:*/		return 0x82094280;
		  /* 82094280h */ case    8:  		/* rldicr R12, R12, 52, 11 */
		/* 82094280h case    8:*/		cpu::op::rldicr<0,52,11>(regs,&regs.R12,regs.R12);
		/* 82094280h case    8:*/		return 0x82094284;
		  /* 82094284h */ case    9:  		/* stbu R11, <#[R31 + 1]> */
		/* 82094284h case    9:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000001) );
		regs.R31 = (uint32)(regs.R31 + 0x00000001);
		/* 82094284h case    9:*/		return 0x82094288;
		  /* 82094288h */ case   10:  		/* rlwinm R10, R10, 0, 0, 26 */
		/* 82094288h case   10:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R10,regs.R10);
		/* 82094288h case   10:*/		return 0x8209428C;
		  /* 8209428Ch */ case   11:  		/* ld R11, <#[R3]> */
		/* 8209428Ch case   11:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209428Ch case   11:*/		return 0x82094290;
		  /* 82094290h */ case   12:  		/* and R9, R11, R12 */
		/* 82094290h case   12:*/		cpu::op::and<0>(regs,&regs.R9,regs.R11,regs.R12);
		/* 82094290h case   12:*/		return 0x82094294;
		  /* 82094294h */ case   13:  		/* addi R11, R31, 1 */
		/* 82094294h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x1);
		/* 82094294h case   13:*/		return 0x82094298;
	}
	return 0x82094298;
} // Block from 82094260h-82094298h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82094298h
// Function 'wcslen'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094298);
		  /* 82094298h */ case    0:  		/* addi R5, R10, 39 */
		/* 82094298h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x27);
		/* 82094298h case    0:*/		return 0x8209429C;
		  /* 8209429Ch */ case    1:  		/* cmpldi CR6, R9, 0 */
		/* 8209429Ch case    1:*/		cpu::op::cmpldi<6>(regs,regs.R9,0x00000000);
		/* 8209429Ch case    1:*/		return 0x820942A0;
		  /* 820942A0h */ case    2:  		/* bc 4, CR6_EQ, 44 */
		/* 820942A0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820942CC;  }
		/* 820942A0h case    2:*/		return 0x820942A4;
		  /* 820942A4h */ case    3:  		/* stb R28, <#[R11]> */
		/* 820942A4h case    3:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 820942A4h case    3:*/		return 0x820942A8;
		  /* 820942A8h */ case    4:  		/* addi R11, R11, 1 */
		/* 820942A8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820942A8h case    4:*/		return 0x820942AC;
		  /* 820942ACh */ case    5:  		/* ld R10, <#[R3]> */
		/* 820942ACh case    5:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820942ACh case    5:*/		return 0x820942B0;
		  /* 820942B0h */ case    6:  		/* rldicl R10, R10, 0, 12 */
		/* 820942B0h case    6:*/		cpu::op::rldicl<0,0,12>(regs,&regs.R10,regs.R10);
		/* 820942B0h case    6:*/		return 0x820942B4;
		  /* 820942B4h */ case    7:  		/* cmpldi CR6, R10, 0 */
		/* 820942B4h case    7:*/		cpu::op::cmpldi<6>(regs,regs.R10,0x00000000);
		/* 820942B4h case    7:*/		return 0x820942B8;
		  /* 820942B8h */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 820942B8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820942C4;  }
		/* 820942B8h case    8:*/		return 0x820942BC;
		  /* 820942BCh */ case    9:  		/* mr R30, R26 */
		/* 820942BCh case    9:*/		regs.R30 = regs.R26;
		/* 820942BCh case    9:*/		return 0x820942C0;
	}
	return 0x820942C0;
} // Block from 82094298h-820942C0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820942C0h
// Function '_initp_misc_invarg'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820942C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820942C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820942C0);
		  /* 820942C0h */ case    0:  		/* b 24 */
		/* 820942C0h case    0:*/		return 0x820942D8;
		/* 820942C0h case    0:*/		return 0x820942C4;
	}
	return 0x820942C4;
} // Block from 820942C0h-820942C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820942C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820942C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820942C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820942C4);
		  /* 820942C4h */ case    0:  		/* li R30, 1022 */
		/* 820942C4h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x3FE);
		/* 820942C4h case    0:*/		return 0x820942C8;
		  /* 820942C8h */ case    1:  		/* b 16 */
		/* 820942C8h case    1:*/		return 0x820942D8;
		/* 820942C8h case    1:*/		return 0x820942CC;
	}
	return 0x820942CC;
} // Block from 820942C4h-820942CCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820942CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820942CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820942CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820942CC);
		  /* 820942CCh */ case    0:  		/* li R10, 49 */
		/* 820942CCh case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x31);
		/* 820942CCh case    0:*/		return 0x820942D0;
	}
	return 0x820942D0;
} // Block from 820942CCh-820942D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820942D0h
// Function '_invalid_parameter_noinfo'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820942D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820942D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820942D0);
		  /* 820942D0h */ case    0:  		/* stb R10, <#[R11]> */
		/* 820942D0h case    0:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820942D0h case    0:*/		return 0x820942D4;
		  /* 820942D4h */ case    1:  		/* addi R11, R11, 1 */
		/* 820942D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820942D4h case    1:*/		return 0x820942D8;
	}
	return 0x820942D8;
} // Block from 820942D0h-820942D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820942D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820942D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820942D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820942D8);
		  /* 820942D8h */ case    0:  		/* mr R4, R11 */
		/* 820942D8h case    0:*/		regs.R4 = regs.R11;
		/* 820942D8h case    0:*/		return 0x820942DC;
		  /* 820942DCh */ case    1:  		/* addi R8, R11, 1 */
		/* 820942DCh case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x1);
		/* 820942DCh case    1:*/		return 0x820942E0;
		  /* 820942E0h */ case    2:  		/* cmpwi CR6, R6, 0 */
		/* 820942E0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 820942E0h case    2:*/		return 0x820942E4;
		  /* 820942E4h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 820942E4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820942F0;  }
		/* 820942E4h case    3:*/		return 0x820942E8;
		  /* 820942E8h */ case    4:  		/* stb R26, <#[R11]> */
		/* 820942E8h case    4:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R11 + 0x00000000) );
		/* 820942E8h case    4:*/		return 0x820942EC;
		  /* 820942ECh */ case    5:  		/* b 28 */
		/* 820942ECh case    5:*/		return 0x82094308;
		/* 820942ECh case    5:*/		return 0x820942F0;
	}
	return 0x820942F0;
} // Block from 820942D8h-820942F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820942F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820942F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820942F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820942F0);
		  /* 820942F0h */ case    0:  		/* lis R11, -32217 */
		/* 820942F0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 820942F0h case    0:*/		return 0x820942F4;
		  /* 820942F4h */ case    1:  		/* lwz R11, <#[R11 + 8856]> */
		/* 820942F4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00002298) );
		/* 820942F4h case    1:*/		return 0x820942F8;
		  /* 820942F8h */ case    2:  		/* lwz R11, <#[R11 + 188]> */
		/* 820942F8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000BC) );
		/* 820942F8h case    2:*/		return 0x820942FC;
		  /* 820942FCh */ case    3:  		/* lwz R11, <#[R11]> */
		/* 820942FCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820942FCh case    3:*/		return 0x82094300;
		  /* 82094300h */ case    4:  		/* lbz R11, <#[R11]> */
		/* 82094300h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82094300h case    4:*/		return 0x82094304;
		  /* 82094304h */ case    5:  		/* stb R11, <#[R4]> */
		/* 82094304h case    5:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82094304h case    5:*/		return 0x82094308;
	}
	return 0x82094308;
} // Block from 820942F0h-82094308h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82094308h
// Function '_call_reportfault'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094308);
		  /* 82094308h */ case    0:  		/* ld R11, <#[R3]> */
		/* 82094308h case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82094308h case    0:*/		return 0x8209430C;
		  /* 8209430Ch */ case    1:  		/* rldicl R11, R11, 0, 12 */
		/* 8209430Ch case    1:*/		cpu::op::rldicl<0,0,12>(regs,&regs.R11,regs.R11);
		/* 8209430Ch case    1:*/		return 0x82094310;
		  /* 82094310h */ case    2:  		/* cmpldi CR6, R11, 0 */
		/* 82094310h case    2:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82094310h case    2:*/		return 0x82094314;
		  /* 82094314h */ case    3:  		/* bc 4, CR6_GT, 228 */
		/* 82094314h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820943F8;  }
		/* 82094314h case    3:*/		return 0x82094318;
		  /* 82094318h */ case    4:  		/* li R10, 15 */
		/* 82094318h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0xF);
		/* 82094318h case    4:*/		return 0x8209431C;
		  /* 8209431Ch */ case    5:  		/* rldicr R10, R10, 48, 15 */
		/* 8209431Ch case    5:*/		cpu::op::rldicr<0,48,15>(regs,&regs.R10,regs.R10);
		/* 8209431Ch case    5:*/		return 0x82094320;
		  /* 82094320h */ case    6:  		/* cmpwi CR6, R6, 0 */
		/* 82094320h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 82094320h case    6:*/		return 0x82094324;
		  /* 82094324h */ case    7:  		/* bc 4, CR6_GT, 92 */
		/* 82094324h case    7:*/		if ( !regs.CR[6].gt ) { return 0x82094380;  }
		/* 82094324h case    7:*/		return 0x82094328;
		  /* 82094328h */ case    8:  		/* ld R11, <#[R3]> */
		/* 82094328h case    8:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82094328h case    8:*/		return 0x8209432C;
		  /* 8209432Ch */ case    9:  		/* extsh R9, R7 */
		/* 8209432Ch case    9:*/		cpu::op::extsh<0>(regs,&regs.R9,regs.R7);
		/* 8209432Ch case    9:*/		return 0x82094330;
		  /* 82094330h */ case   10:  		/* and R11, R11, R10 */
		/* 82094330h case   10:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82094330h case   10:*/		return 0x82094334;
		  /* 82094334h */ case   11:  		/* rldicl R11, R11, 0, 12 */
		/* 82094334h case   11:*/		cpu::op::rldicl<0,0,12>(regs,&regs.R11,regs.R11);
		/* 82094334h case   11:*/		return 0x82094338;
		  /* 82094338h */ case   12:  		/* srd R11, R11, R9 */
		/* 82094338h case   12:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82094338h case   12:*/		return 0x8209433C;
		  /* 8209433Ch */ case   13:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209433Ch case   13:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209433Ch case   13:*/		return 0x82094340;
		  /* 82094340h */ case   14:  		/* addi R11, R11, 48 */
		/* 82094340h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x30);
		/* 82094340h case   14:*/		return 0x82094344;
		  /* 82094344h */ case   15:  		/* rlwinm R9, R11, 0, 16, 31 */
		/* 82094344h case   15:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R11);
		/* 82094344h case   15:*/		return 0x82094348;
		  /* 82094348h */ case   16:  		/* cmplwi CR6, R9, 57 */
		/* 82094348h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000039);
		/* 82094348h case   16:*/		return 0x8209434C;
		  /* 8209434Ch */ case   17:  		/* bc 4, CR6_GT, 16 */
		/* 8209434Ch case   17:*/		if ( !regs.CR[6].gt ) { return 0x8209435C;  }
		/* 8209434Ch case   17:*/		return 0x82094350;
		  /* 82094350h */ case   18:  		/* rlwinm R11, R5, 0, 16, 31 */
		/* 82094350h case   18:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R5);
		/* 82094350h case   18:*/		return 0x82094354;
		  /* 82094354h */ case   19:  		/* add R11, R11, R9 */
		/* 82094354h case   19:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82094354h case   19:*/		return 0x82094358;
		  /* 82094358h */ case   20:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 82094358h case   20:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 82094358h case   20:*/		return 0x8209435C;
	}
	return 0x8209435C;
} // Block from 82094308h-8209435Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8209435Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209435C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209435C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209435C);
		  /* 8209435Ch */ case    0:  		/* extsh R9, R7 */
		/* 8209435Ch case    0:*/		cpu::op::extsh<0>(regs,&regs.R9,regs.R7);
		/* 8209435Ch case    0:*/		return 0x82094360;
		  /* 82094360h */ case    1:  		/* stb R11, <#[R8]> */
		/* 82094360h case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82094360h case    1:*/		return 0x82094364;
		  /* 82094364h */ case    2:  		/* addi R8, R8, 1 */
		/* 82094364h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82094364h case    2:*/		return 0x82094368;
		  /* 82094368h */ case    3:  		/* addi R9, R9, -4 */
		/* 82094368h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFC);
		/* 82094368h case    3:*/		return 0x8209436C;
		  /* 8209436Ch */ case    4:  		/* rldicl R10, R10, 60, 4 */
		/* 8209436Ch case    4:*/		cpu::op::rldicl<0,60,4>(regs,&regs.R10,regs.R10);
		/* 8209436Ch case    4:*/		return 0x82094370;
		  /* 82094370h */ case    5:  		/* extsh R7, R9 */
		/* 82094370h case    5:*/		cpu::op::extsh<0>(regs,&regs.R7,regs.R9);
		/* 82094370h case    5:*/		return 0x82094374;
		  /* 82094374h */ case    6:  		/* addi R6, R6, -1 */
		/* 82094374h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0xFFFFFFFF);
		/* 82094374h case    6:*/		return 0x82094378;
		  /* 82094378h */ case    7:  		/* or. R11, R7, R7 */
		/* 82094378h case    7:*/		cpu::op::or<1>(regs,&regs.R11,regs.R7,regs.R7);
		/* 82094378h case    7:*/		return 0x8209437C;
		  /* 8209437Ch */ case    8:  		/* bc 4, CR0_LT, -92 */
		/* 8209437Ch case    8:*/		if ( !regs.CR[0].lt ) { return 0x82094320;  }
		/* 8209437Ch case    8:*/		return 0x82094380;
	}
	return 0x82094380;
} // Block from 8209435Ch-82094380h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82094380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094380);
		  /* 82094380h */ case    0:  		/* extsh. R11, R7 */
		/* 82094380h case    0:*/		cpu::op::extsh<1>(regs,&regs.R11,regs.R7);
		/* 82094380h case    0:*/		return 0x82094384;
		  /* 82094384h */ case    1:  		/* bc 12, CR0_LT, 116 */
		/* 82094384h case    1:*/		if ( regs.CR[0].lt ) { return 0x820943F8;  }
		/* 82094384h case    1:*/		return 0x82094388;
		  /* 82094388h */ case    2:  		/* ld R11, <#[R3]> */
		/* 82094388h case    2:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82094388h case    2:*/		return 0x8209438C;
		  /* 8209438Ch */ case    3:  		/* extsh R9, R7 */
		/* 8209438Ch case    3:*/		cpu::op::extsh<0>(regs,&regs.R9,regs.R7);
		/* 8209438Ch case    3:*/		return 0x82094390;
		  /* 82094390h */ case    4:  		/* and R11, R11, R10 */
		/* 82094390h case    4:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82094390h case    4:*/		return 0x82094394;
		  /* 82094394h */ case    5:  		/* rldicl R11, R11, 0, 12 */
		/* 82094394h case    5:*/		cpu::op::rldicl<0,0,12>(regs,&regs.R11,regs.R11);
		/* 82094394h case    5:*/		return 0x82094398;
		  /* 82094398h */ case    6:  		/* srd R11, R11, R9 */
		/* 82094398h case    6:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82094398h case    6:*/		return 0x8209439C;
		  /* 8209439Ch */ case    7:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209439Ch case    7:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209439Ch case    7:*/		return 0x820943A0;
		  /* 820943A0h */ case    8:  		/* cmplwi CR6, R11, 8 */
		/* 820943A0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000008);
		/* 820943A0h case    8:*/		return 0x820943A4;
		  /* 820943A4h */ case    9:  		/* bc 4, CR6_GT, 84 */
		/* 820943A4h case    9:*/		if ( !regs.CR[6].gt ) { return 0x820943F8;  }
		/* 820943A4h case    9:*/		return 0x820943A8;
	}
	return 0x820943A8;
} // Block from 82094380h-820943A8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820943A8h
// Function '_invoke_watson'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820943A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820943A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820943A8);
		  /* 820943A8h */ case    0:  		/* addi R11, R8, -1 */
		/* 820943A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0xFFFFFFFF);
		/* 820943A8h case    0:*/		return 0x820943AC;
		  /* 820943ACh */ case    1:  		/* lbz R10, <#[R11]> */
		/* 820943ACh case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820943ACh case    1:*/		return 0x820943B0;
		  /* 820943B0h */ case    2:  		/* extsb R10, R10 */
		/* 820943B0h case    2:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 820943B0h case    2:*/		return 0x820943B4;
		  /* 820943B4h */ case    3:  		/* cmpwi CR6, R10, 102 */
		/* 820943B4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000066);
		/* 820943B4h case    3:*/		return 0x820943B8;
		  /* 820943B8h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 820943B8h case    4:*/		if ( regs.CR[6].eq ) { return 0x820943C4;  }
		/* 820943B8h case    4:*/		return 0x820943BC;
		  /* 820943BCh */ case    5:  		/* cmpwi CR6, R10, 70 */
		/* 820943BCh case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000046);
		/* 820943BCh case    5:*/		return 0x820943C0;
		  /* 820943C0h */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 820943C0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820943D0;  }
		/* 820943C0h case    6:*/		return 0x820943C4;
	}
	return 0x820943C4;
} // Block from 820943A8h-820943C4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820943C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820943C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820943C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820943C4);
		  /* 820943C4h */ case    0:  		/* stb R28, <#[R11]> */
		/* 820943C4h case    0:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 820943C4h case    0:*/		return 0x820943C8;
		  /* 820943C8h */ case    1:  		/* addi R11, R11, -1 */
		/* 820943C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820943C8h case    1:*/		return 0x820943CC;
		  /* 820943CCh */ case    2:  		/* b -32 */
		/* 820943CCh case    2:*/		return 0x820943AC;
		/* 820943CCh case    2:*/		return 0x820943D0;
	}
	return 0x820943D0;
} // Block from 820943C4h-820943D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820943D0h
// Function '__onexitinit'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820943D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820943D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820943D0);
		  /* 820943D0h */ case    0:  		/* cmplw CR6, R11, R4 */
		/* 820943D0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 820943D0h case    0:*/		return 0x820943D4;
		  /* 820943D4h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 820943D4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820943EC;  }
		/* 820943D4h case    1:*/		return 0x820943D8;
		  /* 820943D8h */ case    2:  		/* cmpwi CR6, R10, 57 */
		/* 820943D8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000039);
		/* 820943D8h case    2:*/		return 0x820943DC;
		  /* 820943DCh */ case    3:  		/* bc 4, CR6_EQ, 20 */
		/* 820943DCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x820943F0;  }
		/* 820943DCh case    3:*/		return 0x820943E0;
		  /* 820943E0h */ case    4:  		/* mr R10, R5 */
		/* 820943E0h case    4:*/		regs.R10 = regs.R5;
		/* 820943E0h case    4:*/		return 0x820943E4;
		  /* 820943E4h */ case    5:  		/* addi R10, R10, 58 */
		/* 820943E4h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x3A);
		/* 820943E4h case    5:*/		return 0x820943E8;
		  /* 820943E8h */ case    6:  		/* b 12 */
		/* 820943E8h case    6:*/		return 0x820943F4;
		/* 820943E8h case    6:*/		return 0x820943EC;
	}
	return 0x820943EC;
} // Block from 820943D0h-820943ECh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820943ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820943EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820943EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820943EC);
		  /* 820943ECh */ case    0:  		/* lbzu R10, <#[R11 - 1]> */
		/* 820943ECh case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0xFFFFFFFF) );
		regs.R11 = (uint32)(regs.R11 + 0xFFFFFFFF);
		/* 820943ECh case    0:*/		return 0x820943F0;
	}
	return 0x820943F0;
} // Block from 820943ECh-820943F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820943F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820943F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820943F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820943F0);
		  /* 820943F0h */ case    0:  		/* addi R10, R10, 1 */
		/* 820943F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820943F0h case    0:*/		return 0x820943F4;
	}
	return 0x820943F4;
} // Block from 820943F0h-820943F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820943F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820943F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820943F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820943F4);
		  /* 820943F4h */ case    0:  		/* stb R10, <#[R11]> */
		/* 820943F4h case    0:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820943F4h case    0:*/		return 0x820943F8;
	}
	return 0x820943F8;
} // Block from 820943F4h-820943F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820943F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820943F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820943F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820943F8);
		  /* 820943F8h */ case    0:  		/* cmpwi CR6, R6, 0 */
		/* 820943F8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 820943F8h case    0:*/		return 0x820943FC;
		  /* 820943FCh */ case    1:  		/* bc 4, CR6_GT, 36 */
		/* 820943FCh case    1:*/		if ( !regs.CR[6].gt ) { return 0x82094420;  }
		/* 820943FCh case    1:*/		return 0x82094400;
		  /* 82094400h */ case    2:  		/* addi R11, R8, -1 */
		/* 82094400h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0xFFFFFFFF);
		/* 82094400h case    2:*/		return 0x82094404;
		  /* 82094404h */ case    3:  		/* mr R10, R28 */
		/* 82094404h case    3:*/		regs.R10 = regs.R28;
		/* 82094404h case    3:*/		return 0x82094408;
		  /* 82094408h */ case    4:  		/* cmplwi CR0, R6, 0 */
		/* 82094408h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R6,0x00000000);
		/* 82094408h case    4:*/		return 0x8209440C;
		  /* 8209440Ch */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 8209440Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x8209441C;  }
		/* 8209440Ch case    5:*/		return 0x82094410;
		  /* 82094410h */ case    6:  		/* mtspr CTR, R6 */
		/* 82094410h case    6:*/		regs.CTR = regs.R6;
		/* 82094410h case    6:*/		return 0x82094414;
		  /* 82094414h */ case    7:  		/* stbu R10, <#[R11 + 1]> */
		/* 82094414h case    7:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000001) );
		regs.R11 = (uint32)(regs.R11 + 0x00000001);
		/* 82094414h case    7:*/		return 0x82094418;
		  /* 82094418h */ case    8:  		/* bc 16, CR0_LT, -4 */
		/* 82094418h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82094414;  }
		/* 82094418h case    8:*/		return 0x8209441C;
	}
	return 0x8209441C;
} // Block from 820943F8h-8209441Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209441Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209441C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209441C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209441C);
		  /* 8209441Ch */ case    0:  		/* add R8, R8, R6 */
		/* 8209441Ch case    0:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R6);
		/* 8209441Ch case    0:*/		return 0x82094420;
	}
	return 0x82094420;
} // Block from 8209441Ch-82094420h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82094420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094420);
		  /* 82094420h */ case    0:  		/* lbz R11, <#[R4]> */
		/* 82094420h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82094420h case    0:*/		return 0x82094424;
		  /* 82094424h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 82094424h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82094424h case    1:*/		return 0x82094428;
		  /* 82094428h */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 82094428h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82094430;  }
		/* 82094428h case    2:*/		return 0x8209442C;
		  /* 8209442Ch */ case    3:  		/* mr R8, R4 */
		/* 8209442Ch case    3:*/		regs.R8 = regs.R4;
		/* 8209442Ch case    3:*/		return 0x82094430;
	}
	return 0x82094430;
} // Block from 82094420h-82094430h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82094430h
// Function '_onexit'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094430);
		  /* 82094430h */ case    0:  		/* subfic R11, R29, 0 */
		/* 82094430h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R29,0x0);
		/* 82094430h case    0:*/		return 0x82094434;
		  /* 82094434h */ case    1:  		/* addi R10, R8, 1 */
		/* 82094434h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R8,0x1);
		/* 82094434h case    1:*/		return 0x82094438;
		  /* 82094438h */ case    2:  		/* subfe R11, R11, R11 */
		/* 82094438h case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82094438h case    2:*/		return 0x8209443C;
		  /* 8209443Ch */ case    3:  		/* rlwinm R11, R11, 0, 0, 26 */
		/* 8209443Ch case    3:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R11,regs.R11);
		/* 8209443Ch case    3:*/		return 0x82094440;
		  /* 82094440h */ case    4:  		/* addi R11, R11, 112 */
		/* 82094440h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x70);
		/* 82094440h case    4:*/		return 0x82094444;
		  /* 82094444h */ case    5:  		/* stb R11, <#[R8]> */
		/* 82094444h case    5:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82094444h case    5:*/		return 0x82094448;
		  /* 82094448h */ case    6:  		/* ld R11, <#[R3]> */
		/* 82094448h case    6:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82094448h case    6:*/		return 0x8209444C;
		  /* 8209444Ch */ case    7:  		/* rldicl R11, R11, 12, 53 */
		/* 8209444Ch case    7:*/		cpu::op::rldicl<0,12,53>(regs,&regs.R11,regs.R11);
		/* 8209444Ch case    7:*/		return 0x82094450;
		  /* 82094450h */ case    8:  		/* subf R11, R30, R11 */
		/* 82094450h case    8:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 82094450h case    8:*/		return 0x82094454;
		  /* 82094454h */ case    9:  		/* cmpdi CR6, R11, 0 */
		/* 82094454h case    9:*/		cpu::op::cmpdi<6>(regs,regs.R11,0x00000000);
		/* 82094454h case    9:*/		return 0x82094458;
		  /* 82094458h */ case   10:  		/* bc 12, CR6_LT, 16 */
		/* 82094458h case   10:*/		if ( regs.CR[6].lt ) { return 0x82094468;  }
		/* 82094458h case   10:*/		return 0x8209445C;
		  /* 8209445Ch */ case   11:  		/* li R9, 43 */
		/* 8209445Ch case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x2B);
		/* 8209445Ch case   11:*/		return 0x82094460;
		  /* 82094460h */ case   12:  		/* stb R9, <#[R10]> */
		/* 82094460h case   12:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82094460h case   12:*/		return 0x82094464;
		  /* 82094464h */ case   13:  		/* b 12 */
		/* 82094464h case   13:*/		return 0x82094470;
		/* 82094464h case   13:*/		return 0x82094468;
	}
	return 0x82094468;
} // Block from 82094430h-82094468h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82094468h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094468( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094468) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094468);
		  /* 82094468h */ case    0:  		/* stb R27, <#[R10]> */
		/* 82094468h case    0:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R10 + 0x00000000) );
		/* 82094468h case    0:*/		return 0x8209446C;
		  /* 8209446Ch */ case    1:  		/* neg R11, R11 */
		/* 8209446Ch case    1:*/		cpu::op::neg<0>(regs,&regs.R11,regs.R11);
		/* 8209446Ch case    1:*/		return 0x82094470;
	}
	return 0x82094470;
} // Block from 82094468h-82094470h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82094470h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094470);
		  /* 82094470h */ case    0:  		/* addi R10, R10, 1 */
		/* 82094470h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82094470h case    0:*/		return 0x82094474;
		  /* 82094474h */ case    1:  		/* cmpdi CR6, R11, 1000 */
		/* 82094474h case    1:*/		cpu::op::cmpdi<6>(regs,regs.R11,0x000003E8);
		/* 82094474h case    1:*/		return 0x82094478;
		  /* 82094478h */ case    2:  		/* mr R8, R10 */
		/* 82094478h case    2:*/		regs.R8 = regs.R10;
		/* 82094478h case    2:*/		return 0x8209447C;
		  /* 8209447Ch */ case    3:  		/* stb R28, <#[R10]> */
		/* 8209447Ch case    3:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R10 + 0x00000000) );
		/* 8209447Ch case    3:*/		return 0x82094480;
		  /* 82094480h */ case    4:  		/* bc 12, CR6_LT, 48 */
		/* 82094480h case    4:*/		if ( regs.CR[6].lt ) { return 0x820944B0;  }
		/* 82094480h case    4:*/		return 0x82094484;
		  /* 82094484h */ case    5:  		/* li R9, 1000 */
		/* 82094484h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x3E8);
		/* 82094484h case    5:*/		return 0x82094488;
		  /* 82094488h */ case    6:  		/* divd R7, R11, R9 */
		/* 82094488h case    6:*/		cpu::op::divd<0>(regs,&regs.R7,regs.R11,regs.R9);
		/* 82094488h case    6:*/		return 0x8209448C;
		  /* 8209448Ch */ case    7:  		/* divd R6, R11, R9 */
		/* 8209448Ch case    7:*/		cpu::op::divd<0>(regs,&regs.R6,regs.R11,regs.R9);
		/* 8209448Ch case    7:*/		return 0x82094490;
		  /* 82094490h */ case    8:  		/* mr R9, R7 */
		/* 82094490h case    8:*/		regs.R9 = regs.R7;
		/* 82094490h case    8:*/		return 0x82094494;
		  /* 82094494h */ case    9:  		/* mulli R7, R6, 1000 */
		/* 82094494h case    9:*/		cpu::op::mulli<0>(regs,&regs.R7,regs.R6,0x3E8);
		/* 82094494h case    9:*/		return 0x82094498;
		  /* 82094498h */ case   10:  		/* addi R9, R9, 48 */
		/* 82094498h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x30);
		/* 82094498h case   10:*/		return 0x8209449C;
		  /* 8209449Ch */ case   11:  		/* subf R11, R7, R11 */
		/* 8209449Ch case   11:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 8209449Ch case   11:*/		return 0x820944A0;
		  /* 820944A0h */ case   12:  		/* stb R9, <#[R10]> */
		/* 820944A0h case   12:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820944A0h case   12:*/		return 0x820944A4;
		  /* 820944A4h */ case   13:  		/* addi R10, R10, 1 */
		/* 820944A4h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820944A4h case   13:*/		return 0x820944A8;
		  /* 820944A8h */ case   14:  		/* cmplw CR6, R10, R8 */
		/* 820944A8h case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 820944A8h case   14:*/		return 0x820944AC;
		  /* 820944ACh */ case   15:  		/* bc 4, CR6_EQ, 12 */
		/* 820944ACh case   15:*/		if ( !regs.CR[6].eq ) { return 0x820944B8;  }
		/* 820944ACh case   15:*/		return 0x820944B0;
	}
	return 0x820944B0;
} // Block from 82094470h-820944B0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820944B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820944B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820944B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820944B0);
		  /* 820944B0h */ case    0:  		/* cmpdi CR6, R11, 100 */
		/* 820944B0h case    0:*/		cpu::op::cmpdi<6>(regs,regs.R11,0x00000064);
		/* 820944B0h case    0:*/		return 0x820944B4;
		  /* 820944B4h */ case    1:  		/* bc 12, CR6_LT, 40 */
		/* 820944B4h case    1:*/		if ( regs.CR[6].lt ) { return 0x820944DC;  }
		/* 820944B4h case    1:*/		return 0x820944B8;
	}
	return 0x820944B8;
} // Block from 820944B0h-820944B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820944B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820944B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820944B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820944B8);
		  /* 820944B8h */ case    0:  		/* li R9, 100 */
		/* 820944B8h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x64);
		/* 820944B8h case    0:*/		return 0x820944BC;
		  /* 820944BCh */ case    1:  		/* divd R7, R11, R9 */
		/* 820944BCh case    1:*/		cpu::op::divd<0>(regs,&regs.R7,regs.R11,regs.R9);
		/* 820944BCh case    1:*/		return 0x820944C0;
		  /* 820944C0h */ case    2:  		/* divd R6, R11, R9 */
		/* 820944C0h case    2:*/		cpu::op::divd<0>(regs,&regs.R6,regs.R11,regs.R9);
		/* 820944C0h case    2:*/		return 0x820944C4;
		  /* 820944C4h */ case    3:  		/* mr R9, R7 */
		/* 820944C4h case    3:*/		regs.R9 = regs.R7;
		/* 820944C4h case    3:*/		return 0x820944C8;
		  /* 820944C8h */ case    4:  		/* mulli R7, R6, 100 */
		/* 820944C8h case    4:*/		cpu::op::mulli<0>(regs,&regs.R7,regs.R6,0x64);
		/* 820944C8h case    4:*/		return 0x820944CC;
		  /* 820944CCh */ case    5:  		/* addi R9, R9, 48 */
		/* 820944CCh case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x30);
		/* 820944CCh case    5:*/		return 0x820944D0;
		  /* 820944D0h */ case    6:  		/* subf R11, R7, R11 */
		/* 820944D0h case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 820944D0h case    6:*/		return 0x820944D4;
		  /* 820944D4h */ case    7:  		/* stb R9, <#[R10]> */
		/* 820944D4h case    7:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820944D4h case    7:*/		return 0x820944D8;
		  /* 820944D8h */ case    8:  		/* addi R10, R10, 1 */
		/* 820944D8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820944D8h case    8:*/		return 0x820944DC;
	}
	return 0x820944DC;
} // Block from 820944B8h-820944DCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820944DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820944DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820944DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820944DC);
		  /* 820944DCh */ case    0:  		/* cmplw CR6, R10, R8 */
		/* 820944DCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 820944DCh case    0:*/		return 0x820944E0;
		  /* 820944E0h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820944E0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820944EC;  }
		/* 820944E0h case    1:*/		return 0x820944E4;
		  /* 820944E4h */ case    2:  		/* cmpdi CR6, R11, 10 */
		/* 820944E4h case    2:*/		cpu::op::cmpdi<6>(regs,regs.R11,0x0000000A);
		/* 820944E4h case    2:*/		return 0x820944E8;
		  /* 820944E8h */ case    3:  		/* bc 12, CR6_LT, 40 */
		/* 820944E8h case    3:*/		if ( regs.CR[6].lt ) { return 0x82094510;  }
		/* 820944E8h case    3:*/		return 0x820944EC;
	}
	return 0x820944EC;
} // Block from 820944DCh-820944ECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820944ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820944EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820944EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820944EC);
		  /* 820944ECh */ case    0:  		/* li R9, 10 */
		/* 820944ECh case    0:*/		cpu::op::li<0>(regs,&regs.R9,0xA);
		/* 820944ECh case    0:*/		return 0x820944F0;
		  /* 820944F0h */ case    1:  		/* divd R8, R11, R9 */
		/* 820944F0h case    1:*/		cpu::op::divd<0>(regs,&regs.R8,regs.R11,regs.R9);
		/* 820944F0h case    1:*/		return 0x820944F4;
		  /* 820944F4h */ case    2:  		/* divd R7, R11, R9 */
		/* 820944F4h case    2:*/		cpu::op::divd<0>(regs,&regs.R7,regs.R11,regs.R9);
		/* 820944F4h case    2:*/		return 0x820944F8;
		  /* 820944F8h */ case    3:  		/* mr R9, R8 */
		/* 820944F8h case    3:*/		regs.R9 = regs.R8;
		/* 820944F8h case    3:*/		return 0x820944FC;
		  /* 820944FCh */ case    4:  		/* mulli R8, R7, 10 */
		/* 820944FCh case    4:*/		cpu::op::mulli<0>(regs,&regs.R8,regs.R7,0xA);
		/* 820944FCh case    4:*/		return 0x82094500;
		  /* 82094500h */ case    5:  		/* addi R9, R9, 48 */
		/* 82094500h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x30);
		/* 82094500h case    5:*/		return 0x82094504;
		  /* 82094504h */ case    6:  		/* subf R11, R8, R11 */
		/* 82094504h case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82094504h case    6:*/		return 0x82094508;
		  /* 82094508h */ case    7:  		/* stb R9, <#[R10]> */
		/* 82094508h case    7:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82094508h case    7:*/		return 0x8209450C;
		  /* 8209450Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 8209450Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8209450Ch case    8:*/		return 0x82094510;
	}
	return 0x82094510;
} // Block from 820944ECh-82094510h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82094510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094510);
		  /* 82094510h */ case    0:  		/* addi R11, R11, 48 */
		/* 82094510h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x30);
		/* 82094510h case    0:*/		return 0x82094514;
		  /* 82094514h */ case    1:  		/* stb R11, <#[R10]> */
		/* 82094514h case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82094514h case    1:*/		return 0x82094518;
		  /* 82094518h */ case    2:  		/* stb R26, <#[R10 + 1]> */
		/* 82094518h case    2:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R10 + 0x00000001) );
		/* 82094518h case    2:*/		return 0x8209451C;
	}
	return 0x8209451C;
} // Block from 82094510h-8209451Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209451Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209451C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209451C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209451C);
		  /* 8209451Ch */ case    0:  		/* li R3, 0 */
		/* 8209451Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209451Ch case    0:*/		return 0x82094520;
	}
	return 0x82094520;
} // Block from 8209451Ch-82094520h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82094520h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094520);
		  /* 82094520h */ case    0:  		/* addi R1, R1, 144 */
		/* 82094520h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82094520h case    0:*/		return 0x82094524;
		  /* 82094524h */ case    1:  		/* b -12932 */
		/* 82094524h case    1:*/		return 0x820912A0;
		/* 82094524h case    1:*/		return 0x82094528;
	}
	return 0x82094528;
} // Block from 82094520h-82094528h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82094528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094528);
		  /* 82094528h */ case    0:  		/* mfspr R12, LR */
		/* 82094528h case    0:*/		regs.R12 = regs.LR;
		/* 82094528h case    0:*/		return 0x8209452C;
		  /* 8209452Ch */ case    1:  		/* bl -13020 */
		/* 8209452Ch case    1:*/		regs.LR = 0x82094530; return 0x82091250;
		/* 8209452Ch case    1:*/		return 0x82094530;
		  /* 82094530h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82094530h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82094530h case    2:*/		return 0x82094534;
		  /* 82094534h */ case    3:  		/* lwz R11, <#[R6 + 4]> */
		/* 82094534h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000004) );
		/* 82094534h case    3:*/		return 0x82094538;
	}
	return 0x82094538;
} // Block from 82094528h-82094538h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82094538h
// Function 'atexit'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094538);
		  /* 82094538h */ case    0:  		/* mr R27, R5 */
		/* 82094538h case    0:*/		regs.R27 = regs.R5;
		/* 82094538h case    0:*/		return 0x8209453C;
		  /* 8209453Ch */ case    1:  		/* mr R29, R6 */
		/* 8209453Ch case    1:*/		regs.R29 = regs.R6;
		/* 8209453Ch case    1:*/		return 0x82094540;
		  /* 82094540h */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 82094540h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82094540h case    2:*/		return 0x82094544;
		  /* 82094544h */ case    3:  		/* addi R10, R11, -1 */
		/* 82094544h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 82094544h case    3:*/		return 0x82094548;
		  /* 82094548h */ case    4:  		/* bc 4, CR6_EQ, 28 */
		/* 82094548h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82094564;  }
		/* 82094548h case    4:*/		return 0x8209454C;
		  /* 8209454Ch */ case    5:  		/* bl 2492 */
		/* 8209454Ch case    5:*/		regs.LR = 0x82094550; return 0x82094F08;
		/* 8209454Ch case    5:*/		return 0x82094550;
		  /* 82094550h */ case    6:  		/* li R11, 22 */
		/* 82094550h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 82094550h case    6:*/		return 0x82094554;
		  /* 82094554h */ case    7:  		/* stw R11, <#[R3]> */
		/* 82094554h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82094554h case    7:*/		return 0x82094558;
		  /* 82094558h */ case    8:  		/* bl -3064 */
		/* 82094558h case    8:*/		regs.LR = 0x8209455C; return 0x82093960;
		/* 82094558h case    8:*/		return 0x8209455C;
		  /* 8209455Ch */ case    9:  		/* li R3, 22 */
		/* 8209455Ch case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x16);
		/* 8209455Ch case    9:*/		return 0x82094560;
	}
	return 0x82094560;
} // Block from 82094538h-82094560h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82094560h
// Function '_stricmp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094560);
		  /* 82094560h */ case    0:  		/* b 372 */
		/* 82094560h case    0:*/		return 0x820946D4;
		/* 82094560h case    0:*/		return 0x82094564;
	}
	return 0x82094564;
} // Block from 82094560h-82094564h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82094564h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094564( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094564) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094564);
		  /* 82094564h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 82094564h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82094564h case    0:*/		return 0x82094568;
		  /* 82094568h */ case    1:  		/* bc 12, CR6_EQ, -28 */
		/* 82094568h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209454C;  }
		/* 82094568h case    1:*/		return 0x8209456C;
		  /* 8209456Ch */ case    2:  		/* extsb. R26, R7 */
		/* 8209456Ch case    2:*/		cpu::op::extsb<1>(regs,&regs.R26,regs.R7);
		/* 8209456Ch case    2:*/		return 0x82094570;
		  /* 82094570h */ case    3:  		/* li R28, 48 */
		/* 82094570h case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x30);
		/* 82094570h case    3:*/		return 0x82094574;
		  /* 82094574h */ case    4:  		/* bc 12, CR0_EQ, 48 */
		/* 82094574h case    4:*/		if ( regs.CR[0].eq ) { return 0x820945A4;  }
		/* 82094574h case    4:*/		return 0x82094578;
		  /* 82094578h */ case    5:  		/* cmpw CR6, R10, R27 */
		/* 82094578h case    5:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R27);
		/* 82094578h case    5:*/		return 0x8209457C;
		  /* 8209457Ch */ case    6:  		/* bc 4, CR6_EQ, 40 */
		/* 8209457Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x820945A4;  }
		/* 8209457Ch case    6:*/		return 0x82094580;
		  /* 82094580h */ case    7:  		/* lwz R11, <#[R29]> */
		/* 82094580h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82094580h case    7:*/		return 0x82094584;
		  /* 82094584h */ case    8:  		/* li R9, 0 */
		/* 82094584h case    8:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82094584h case    8:*/		return 0x82094588;
		  /* 82094588h */ case    9:  		/* addi R11, R11, -45 */
		/* 82094588h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFD3);
		/* 82094588h case    9:*/		return 0x8209458C;
		  /* 8209458Ch */ case   10:  		/* cntlzw R11, R11 */
		/* 8209458Ch case   10:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8209458Ch case   10:*/		return 0x82094590;
		  /* 82094590h */ case   11:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 82094590h case   11:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82094590h case   11:*/		return 0x82094594;
		  /* 82094594h */ case   12:  		/* add R11, R11, R10 */
		/* 82094594h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82094594h case   12:*/		return 0x82094598;
		  /* 82094598h */ case   13:  		/* add R11, R11, R3 */
		/* 82094598h case   13:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82094598h case   13:*/		return 0x8209459C;
		  /* 8209459Ch */ case   14:  		/* stb R28, <#[R11]> */
		/* 8209459Ch case   14:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 8209459Ch case   14:*/		return 0x820945A0;
		  /* 820945A0h */ case   15:  		/* stb R9, <#[R11 + 1]> */
		/* 820945A0h case   15:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R11 + 0x00000001) );
		/* 820945A0h case   15:*/		return 0x820945A4;
	}
	return 0x820945A4;
} // Block from 82094564h-820945A4h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820945A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820945A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820945A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820945A4);
		  /* 820945A4h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 820945A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820945A4h case    0:*/		return 0x820945A8;
		  /* 820945A8h */ case    1:  		/* mr R30, R3 */
		/* 820945A8h case    1:*/		regs.R30 = regs.R3;
		/* 820945A8h case    1:*/		return 0x820945AC;
		  /* 820945ACh */ case    2:  		/* cmpwi CR6, R11, 45 */
		/* 820945ACh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002D);
		/* 820945ACh case    2:*/		return 0x820945B0;
		  /* 820945B0h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 820945B0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820945BC;  }
		/* 820945B0h case    3:*/		return 0x820945B4;
		  /* 820945B4h */ case    4:  		/* addi R30, R3, 1 */
		/* 820945B4h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x1);
		/* 820945B4h case    4:*/		return 0x820945B8;
	}
	return 0x820945B8;
} // Block from 820945A4h-820945B8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820945B8h
// Function '_set_exp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820945B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820945B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820945B8);
		  /* 820945B8h */ case    0:  		/* stb R11, <#[R3]> */
		/* 820945B8h case    0:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820945B8h case    0:*/		return 0x820945BC;
	}
	return 0x820945BC;
} // Block from 820945B8h-820945BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820945BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820945BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820945BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820945BC);
		  /* 820945BCh */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 820945BCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 820945BCh case    0:*/		return 0x820945C0;
		  /* 820945C0h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820945C0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820945C0h case    1:*/		return 0x820945C4;
		  /* 820945C4h */ case    2:  		/* bc 12, CR6_GT, 64 */
		/* 820945C4h case    2:*/		if ( regs.CR[6].gt ) { return 0x82094604;  }
		/* 820945C4h case    2:*/		return 0x820945C8;
		  /* 820945C8h */ case    3:  		/* mr R11, R30 */
		/* 820945C8h case    3:*/		regs.R11 = regs.R30;
		/* 820945C8h case    3:*/		return 0x820945CC;
		  /* 820945CCh */ case    4:  		/* lbz R10, <#[R11]> */
		/* 820945CCh case    4:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820945CCh case    4:*/		return 0x820945D0;
		  /* 820945D0h */ case    5:  		/* addi R11, R11, 1 */
		/* 820945D0h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820945D0h case    5:*/		return 0x820945D4;
		  /* 820945D4h */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 820945D4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820945D4h case    6:*/		return 0x820945D8;
		  /* 820945D8h */ case    7:  		/* bc 4, CR6_EQ, -12 */
		/* 820945D8h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820945CC;  }
		/* 820945D8h case    7:*/		return 0x820945DC;
		  /* 820945DCh */ case    8:  		/* subf R11, R30, R11 */
		/* 820945DCh case    8:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 820945DCh case    8:*/		return 0x820945E0;
	}
	return 0x820945E0;
} // Block from 820945BCh-820945E0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820945E0h
// Function '_get_exp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820945E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820945E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820945E0);
		  /* 820945E0h */ case    0:  		/* addi R31, R30, 1 */
		/* 820945E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R30,0x1);
		/* 820945E0h case    0:*/		return 0x820945E4;
		  /* 820945E4h */ case    1:  		/* addi R11, R11, -1 */
		/* 820945E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820945E4h case    1:*/		return 0x820945E8;
		  /* 820945E8h */ case    2:  		/* mr R3, R31 */
		/* 820945E8h case    2:*/		regs.R3 = regs.R31;
		/* 820945E8h case    2:*/		return 0x820945EC;
		  /* 820945ECh */ case    3:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820945ECh case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820945ECh case    3:*/		return 0x820945F0;
		  /* 820945F0h */ case    4:  		/* mr R4, R30 */
		/* 820945F0h case    4:*/		regs.R4 = regs.R30;
		/* 820945F0h case    4:*/		return 0x820945F4;
		  /* 820945F4h */ case    5:  		/* addi R5, R11, 1 */
		/* 820945F4h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x1);
		/* 820945F4h case    5:*/		return 0x820945F8;
	}
	return 0x820945F8;
} // Block from 820945E0h-820945F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820945F8h
// Function '_add_exp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820945F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820945F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820945F8);
		  /* 820945F8h */ case    0:  		/* bl -9944 */
		/* 820945F8h case    0:*/		regs.LR = 0x820945FC; return 0x82091F20;
		/* 820945F8h case    0:*/		return 0x820945FC;
		  /* 820945FCh */ case    1:  		/* stb R28, <#[R30]> */
		/* 820945FCh case    1:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R30 + 0x00000000) );
		/* 820945FCh case    1:*/		return 0x82094600;
		  /* 82094600h */ case    2:  		/* b 8 */
		/* 82094600h case    2:*/		return 0x82094608;
		/* 82094600h case    2:*/		return 0x82094604;
	}
	return 0x82094604;
} // Block from 820945F8h-82094604h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82094604h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094604( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094604) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094604);
		  /* 82094604h */ case    0:  		/* add R31, R11, R30 */
		/* 82094604h case    0:*/		cpu::op::add<0>(regs,&regs.R31,regs.R11,regs.R30);
		/* 82094604h case    0:*/		return 0x82094608;
	}
	return 0x82094608;
} // Block from 82094604h-82094608h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82094608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094608);
		  /* 82094608h */ case    0:  		/* cmpwi CR6, R27, 0 */
		/* 82094608h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 82094608h case    0:*/		return 0x8209460C;
		  /* 8209460Ch */ case    1:  		/* bc 4, CR6_GT, 196 */
		/* 8209460Ch case    1:*/		if ( !regs.CR[6].gt ) { return 0x820946D0;  }
		/* 8209460Ch case    1:*/		return 0x82094610;
		  /* 82094610h */ case    2:  		/* mr R11, R31 */
		/* 82094610h case    2:*/		regs.R11 = regs.R31;
		/* 82094610h case    2:*/		return 0x82094614;
		  /* 82094614h */ case    3:  		/* lbz R10, <#[R11]> */
		/* 82094614h case    3:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82094614h case    3:*/		return 0x82094618;
		  /* 82094618h */ case    4:  		/* addi R11, R11, 1 */
		/* 82094618h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82094618h case    4:*/		return 0x8209461C;
		  /* 8209461Ch */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 8209461Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8209461Ch case    5:*/		return 0x82094620;
		  /* 82094620h */ case    6:  		/* bc 4, CR6_EQ, -12 */
		/* 82094620h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82094614;  }
		/* 82094620h case    6:*/		return 0x82094624;
		  /* 82094624h */ case    7:  		/* subf R11, R31, R11 */
		/* 82094624h case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 82094624h case    7:*/		return 0x82094628;
		  /* 82094628h */ case    8:  		/* addi R30, R31, 1 */
		/* 82094628h case    8:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x1);
		/* 82094628h case    8:*/		return 0x8209462C;
		  /* 8209462Ch */ case    9:  		/* addi R11, R11, -1 */
		/* 8209462Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8209462Ch case    9:*/		return 0x82094630;
	}
	return 0x82094630;
} // Block from 82094608h-82094630h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82094630h
// Function '_sptype'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094630);
		  /* 82094630h */ case    0:  		/* mr R4, R31 */
		/* 82094630h case    0:*/		regs.R4 = regs.R31;
		/* 82094630h case    0:*/		return 0x82094634;
		  /* 82094634h */ case    1:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 82094634h case    1:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 82094634h case    1:*/		return 0x82094638;
		  /* 82094638h */ case    2:  		/* mr R3, R30 */
		/* 82094638h case    2:*/		regs.R3 = regs.R30;
		/* 82094638h case    2:*/		return 0x8209463C;
		  /* 8209463Ch */ case    3:  		/* addi R5, R11, 1 */
		/* 8209463Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x1);
		/* 8209463Ch case    3:*/		return 0x82094640;
		  /* 82094640h */ case    4:  		/* bl -10016 */
		/* 82094640h case    4:*/		regs.LR = 0x82094644; return 0x82091F20;
		/* 82094640h case    4:*/		return 0x82094644;
		  /* 82094644h */ case    5:  		/* lis R11, -32217 */
		/* 82094644h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82094644h case    5:*/		return 0x82094648;
		  /* 82094648h */ case    6:  		/* lwz R11, <#[R11 + 8856]> */
		/* 82094648h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00002298) );
		/* 82094648h case    6:*/		return 0x8209464C;
		  /* 8209464Ch */ case    7:  		/* lwz R11, <#[R11 + 188]> */
		/* 8209464Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000BC) );
		/* 8209464Ch case    7:*/		return 0x82094650;
		  /* 82094650h */ case    8:  		/* lwz R11, <#[R11]> */
		/* 82094650h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82094650h case    8:*/		return 0x82094654;
		  /* 82094654h */ case    9:  		/* lbz R11, <#[R11]> */
		/* 82094654h case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82094654h case    9:*/		return 0x82094658;
		  /* 82094658h */ case   10:  		/* stb R11, <#[R31]> */
		/* 82094658h case   10:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82094658h case   10:*/		return 0x8209465C;
		  /* 8209465Ch */ case   11:  		/* lwz R11, <#[R29 + 4]> */
		/* 8209465Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8209465Ch case   11:*/		return 0x82094660;
		  /* 82094660h */ case   12:  		/* cmpwi CR6, R11, 0 */
		/* 82094660h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82094660h case   12:*/		return 0x82094664;
		  /* 82094664h */ case   13:  		/* bc 4, CR6_LT, 108 */
		/* 82094664h case   13:*/		if ( !regs.CR[6].lt ) { return 0x820946D0;  }
		/* 82094664h case   13:*/		return 0x82094668;
		  /* 82094668h */ case   14:  		/* cmpwi CR6, R26, 0 */
		/* 82094668h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 82094668h case   14:*/		return 0x8209466C;
		  /* 8209466Ch */ case   15:  		/* bc 12, CR6_EQ, 12 */
		/* 8209466Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x82094678;  }
		/* 8209466Ch case   15:*/		return 0x82094670;
		  /* 82094670h */ case   16:  		/* neg R27, R11 */
		/* 82094670h case   16:*/		cpu::op::neg<0>(regs,&regs.R27,regs.R11);
		/* 82094670h case   16:*/		return 0x82094674;
		  /* 82094674h */ case   17:  		/* b 20 */
		/* 82094674h case   17:*/		return 0x82094688;
		/* 82094674h case   17:*/		return 0x82094678;
	}
	return 0x82094678;
} // Block from 82094630h-82094678h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82094678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094678);
		  /* 82094678h */ case    0:  		/* neg R11, R11 */
		/* 82094678h case    0:*/		cpu::op::neg<0>(regs,&regs.R11,regs.R11);
		/* 82094678h case    0:*/		return 0x8209467C;
		  /* 8209467Ch */ case    1:  		/* cmpw CR6, R27, R11 */
		/* 8209467Ch case    1:*/		cpu::op::cmpw<6>(regs,regs.R27,regs.R11);
		/* 8209467Ch case    1:*/		return 0x82094680;
		  /* 82094680h */ case    2:  		/* bc 12, CR6_LT, 8 */
		/* 82094680h case    2:*/		if ( regs.CR[6].lt ) { return 0x82094688;  }
		/* 82094680h case    2:*/		return 0x82094684;
		  /* 82094684h */ case    3:  		/* mr R27, R11 */
		/* 82094684h case    3:*/		regs.R27 = regs.R11;
		/* 82094684h case    3:*/		return 0x82094688;
	}
	return 0x82094688;
} // Block from 82094678h-82094688h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82094688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094688);
		  /* 82094688h */ case    0:  		/* cmpwi CR6, R27, 0 */
		/* 82094688h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 82094688h case    0:*/		return 0x8209468C;
		  /* 8209468Ch */ case    1:  		/* bc 12, CR6_EQ, 52 */
		/* 8209468Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820946C0;  }
		/* 8209468Ch case    1:*/		return 0x82094690;
		  /* 82094690h */ case    2:  		/* mr R11, R30 */
		/* 82094690h case    2:*/		regs.R11 = regs.R30;
		/* 82094690h case    2:*/		return 0x82094694;
		  /* 82094694h */ case    3:  		/* lbz R10, <#[R11]> */
		/* 82094694h case    3:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82094694h case    3:*/		return 0x82094698;
		  /* 82094698h */ case    4:  		/* addi R11, R11, 1 */
		/* 82094698h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82094698h case    4:*/		return 0x8209469C;
		  /* 8209469Ch */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 8209469Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8209469Ch case    5:*/		return 0x820946A0;
		  /* 820946A0h */ case    6:  		/* bc 4, CR6_EQ, -12 */
		/* 820946A0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82094694;  }
		/* 820946A0h case    6:*/		return 0x820946A4;
		  /* 820946A4h */ case    7:  		/* subf R11, R30, R11 */
		/* 820946A4h case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 820946A4h case    7:*/		return 0x820946A8;
		  /* 820946A8h */ case    8:  		/* mr R4, R30 */
		/* 820946A8h case    8:*/		regs.R4 = regs.R30;
		/* 820946A8h case    8:*/		return 0x820946AC;
		  /* 820946ACh */ case    9:  		/* addi R11, R11, -1 */
		/* 820946ACh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820946ACh case    9:*/		return 0x820946B0;
		  /* 820946B0h */ case   10:  		/* add R3, R30, R27 */
		/* 820946B0h case   10:*/		cpu::op::add<0>(regs,&regs.R3,regs.R30,regs.R27);
		/* 820946B0h case   10:*/		return 0x820946B4;
		  /* 820946B4h */ case   11:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820946B4h case   11:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820946B4h case   11:*/		return 0x820946B8;
	}
	return 0x820946B8;
} // Block from 82094688h-820946B8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820946B8h
// Function '_decomp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820946B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820946B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820946B8);
		  /* 820946B8h */ case    0:  		/* addi R5, R11, 1 */
		/* 820946B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x1);
		/* 820946B8h case    0:*/		return 0x820946BC;
		  /* 820946BCh */ case    1:  		/* bl -10140 */
		/* 820946BCh case    1:*/		regs.LR = 0x820946C0; return 0x82091F20;
		/* 820946BCh case    1:*/		return 0x820946C0;
	}
	return 0x820946C0;
} // Block from 820946B8h-820946C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820946C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820946C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820946C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820946C0);
		  /* 820946C0h */ case    0:  		/* mr R5, R27 */
		/* 820946C0h case    0:*/		regs.R5 = regs.R27;
		/* 820946C0h case    0:*/		return 0x820946C4;
		  /* 820946C4h */ case    1:  		/* li R4, 48 */
		/* 820946C4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x30);
		/* 820946C4h case    1:*/		return 0x820946C8;
		  /* 820946C8h */ case    2:  		/* mr R3, R30 */
		/* 820946C8h case    2:*/		regs.R3 = regs.R30;
		/* 820946C8h case    2:*/		return 0x820946CC;
		  /* 820946CCh */ case    3:  		/* bl -13196 */
		/* 820946CCh case    3:*/		regs.LR = 0x820946D0; return 0x82091340;
		/* 820946CCh case    3:*/		return 0x820946D0;
	}
	return 0x820946D0;
} // Block from 820946C0h-820946D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820946D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820946D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820946D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820946D0);
		  /* 820946D0h */ case    0:  		/* li R3, 0 */
		/* 820946D0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820946D0h case    0:*/		return 0x820946D4;
	}
	return 0x820946D4;
} // Block from 820946D0h-820946D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820946D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820946D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820946D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820946D4);
		  /* 820946D4h */ case    0:  		/* addi R1, R1, 144 */
		/* 820946D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820946D4h case    0:*/		return 0x820946D8;
		  /* 820946D8h */ case    1:  		/* b -13368 */
		/* 820946D8h case    1:*/		return 0x820912A0;
		/* 820946D8h case    1:*/		return 0x820946DC;
		  /* 820946DCh */ case    2:  		/* nop */
		/* 820946DCh case    2:*/		cpu::op::nop();
		/* 820946DCh case    2:*/		return 0x820946E0;
	}
	return 0x820946E0;
} // Block from 820946D4h-820946E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820946E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820946E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820946E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820946E0);
		  /* 820946E0h */ case    0:  		/* mfspr R12, LR */
		/* 820946E0h case    0:*/		regs.R12 = regs.LR;
		/* 820946E0h case    0:*/		return 0x820946E4;
		  /* 820946E4h */ case    1:  		/* bl -13448 */
		/* 820946E4h case    1:*/		regs.LR = 0x820946E8; return 0x8209125C;
		/* 820946E4h case    1:*/		return 0x820946E8;
		  /* 820946E8h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820946E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820946E8h case    2:*/		return 0x820946EC;
		  /* 820946ECh */ case    3:  		/* mr R31, R4 */
		/* 820946ECh case    3:*/		regs.R31 = regs.R4;
		/* 820946ECh case    3:*/		return 0x820946F0;
		  /* 820946F0h */ case    4:  		/* ld R3, <#[R3]> */
		/* 820946F0h case    4:*/		cpu::mem::load64( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820946F0h case    4:*/		return 0x820946F4;
		  /* 820946F4h */ case    5:  		/* mr R29, R5 */
		/* 820946F4h case    5:*/		regs.R29 = regs.R5;
		/* 820946F4h case    5:*/		return 0x820946F8;
		  /* 820946F8h */ case    6:  		/* mr R30, R6 */
		/* 820946F8h case    6:*/		regs.R30 = regs.R6;
		/* 820946F8h case    6:*/		return 0x820946FC;
		  /* 820946FCh */ case    7:  		/* li R6, 22 */
		/* 820946FCh case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x16);
		/* 820946FCh case    7:*/		return 0x82094700;
		  /* 82094700h */ case    8:  		/* addi R5, R1, 96 */
		/* 82094700h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 82094700h case    8:*/		return 0x82094704;
		  /* 82094704h */ case    9:  		/* addi R4, R1, 80 */
		/* 82094704h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82094704h case    9:*/		return 0x82094708;
		  /* 82094708h */ case   10:  		/* bl 21552 */
		/* 82094708h case   10:*/		regs.LR = 0x8209470C; return 0x82099B38;
		/* 82094708h case   10:*/		return 0x8209470C;
		  /* 8209470Ch */ case   11:  		/* cmplwi CR6, R31, 0 */
		/* 8209470Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8209470Ch case   11:*/		return 0x82094710;
		  /* 82094710h */ case   12:  		/* bc 4, CR6_EQ, 28 */
		/* 82094710h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8209472C;  }
		/* 82094710h case   12:*/		return 0x82094714;
		  /* 82094714h */ case   13:  		/* bl 2036 */
		/* 82094714h case   13:*/		regs.LR = 0x82094718; return 0x82094F08;
		/* 82094714h case   13:*/		return 0x82094718;
		  /* 82094718h */ case   14:  		/* li R11, 22 */
		/* 82094718h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 82094718h case   14:*/		return 0x8209471C;
		  /* 8209471Ch */ case   15:  		/* stw R11, <#[R3]> */
		/* 8209471Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209471Ch case   15:*/		return 0x82094720;
		  /* 82094720h */ case   16:  		/* bl -3520 */
		/* 82094720h case   16:*/		regs.LR = 0x82094724; return 0x82093960;
		/* 82094720h case   16:*/		return 0x82094724;
		  /* 82094724h */ case   17:  		/* li R3, 22 */
		/* 82094724h case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x16);
		/* 82094724h case   17:*/		return 0x82094728;
		  /* 82094728h */ case   18:  		/* b 124 */
		/* 82094728h case   18:*/		return 0x820947A4;
		/* 82094728h case   18:*/		return 0x8209472C;
	}
	return 0x8209472C;
} // Block from 820946E0h-8209472Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8209472Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209472C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209472C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209472C);
		  /* 8209472Ch */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 8209472Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8209472Ch case    0:*/		return 0x82094730;
		  /* 82094730h */ case    1:  		/* bc 12, CR6_EQ, -28 */
		/* 82094730h case    1:*/		if ( regs.CR[6].eq ) { return 0x82094714;  }
		/* 82094730h case    1:*/		return 0x82094734;
		  /* 82094734h */ case    2:  		/* lwz R11, <#[R1 + 80]> */
		/* 82094734h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82094734h case    2:*/		return 0x82094738;
		  /* 82094738h */ case    3:  		/* cmpwi CR6, R29, -1 */
		/* 82094738h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFF);
		/* 82094738h case    3:*/		return 0x8209473C;
		  /* 8209473Ch */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 8209473Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x82094748;  }
		/* 8209473Ch case    4:*/		return 0x82094740;
		  /* 82094740h */ case    5:  		/* li R4, -1 */
		/* 82094740h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0xFFFFFFFF);
		/* 82094740h case    5:*/		return 0x82094744;
		  /* 82094744h */ case    6:  		/* b 20 */
		/* 82094744h case    6:*/		return 0x82094758;
		/* 82094744h case    6:*/		return 0x82094748;
	}
	return 0x82094748;
} // Block from 8209472Ch-82094748h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82094748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094748);
		  /* 82094748h */ case    0:  		/* addi R10, R11, -45 */
		/* 82094748h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFD3);
		/* 82094748h case    0:*/		return 0x8209474C;
		  /* 8209474Ch */ case    1:  		/* cntlzw R10, R10 */
		/* 8209474Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 8209474Ch case    1:*/		return 0x82094750;
		  /* 82094750h */ case    2:  		/* rlwinm R10, R10, 27, 31, 31 */
		/* 82094750h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R10);
		/* 82094750h case    2:*/		return 0x82094754;
		  /* 82094754h */ case    3:  		/* subf R4, R10, R29 */
		/* 82094754h case    3:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R10,regs.R29);
		/* 82094754h case    3:*/		return 0x82094758;
	}
	return 0x82094758;
} // Block from 82094748h-82094758h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82094758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094758);
		  /* 82094758h */ case    0:  		/* addi R10, R11, -45 */
		/* 82094758h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFD3);
		/* 82094758h case    0:*/		return 0x8209475C;
		  /* 8209475Ch */ case    1:  		/* lwz R11, <#[R1 + 84]> */
		/* 8209475Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8209475Ch case    1:*/		return 0x82094760;
		  /* 82094760h */ case    2:  		/* addi R6, R1, 80 */
		/* 82094760h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 82094760h case    2:*/		return 0x82094764;
		  /* 82094764h */ case    3:  		/* cntlzw R10, R10 */
		/* 82094764h case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 82094764h case    3:*/		return 0x82094768;
		  /* 82094768h */ case    4:  		/* add R5, R11, R30 */
		/* 82094768h case    4:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R30);
		/* 82094768h case    4:*/		return 0x8209476C;
		  /* 8209476Ch */ case    5:  		/* rlwinm R11, R10, 27, 31, 31 */
		/* 8209476Ch case    5:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R10);
		/* 8209476Ch case    5:*/		return 0x82094770;
		  /* 82094770h */ case    6:  		/* add R3, R11, R31 */
		/* 82094770h case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R31);
		/* 82094770h case    6:*/		return 0x82094774;
		  /* 82094774h */ case    7:  		/* bl 20868 */
		/* 82094774h case    7:*/		regs.LR = 0x82094778; return 0x820998F8;
		/* 82094774h case    7:*/		return 0x82094778;
		  /* 82094778h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 82094778h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82094778h case    8:*/		return 0x8209477C;
		  /* 8209477Ch */ case    9:  		/* bc 12, CR0_EQ, 16 */
		/* 8209477Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x8209478C;  }
		/* 8209477Ch case    9:*/		return 0x82094780;
		  /* 82094780h */ case   10:  		/* li R11, 0 */
		/* 82094780h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82094780h case   10:*/		return 0x82094784;
		  /* 82094784h */ case   11:  		/* stb R11, <#[R31]> */
		/* 82094784h case   11:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82094784h case   11:*/		return 0x82094788;
		  /* 82094788h */ case   12:  		/* b 28 */
		/* 82094788h case   12:*/		return 0x820947A4;
		/* 82094788h case   12:*/		return 0x8209478C;
	}
	return 0x8209478C;
} // Block from 82094758h-8209478Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209478Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209478C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209478C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209478C);
		  /* 8209478Ch */ case    0:  		/* li R7, 0 */
		/* 8209478Ch case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8209478Ch case    0:*/		return 0x82094790;
		  /* 82094790h */ case    1:  		/* addi R6, R1, 80 */
		/* 82094790h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 82094790h case    1:*/		return 0x82094794;
		  /* 82094794h */ case    2:  		/* mr R5, R30 */
		/* 82094794h case    2:*/		regs.R5 = regs.R30;
		/* 82094794h case    2:*/		return 0x82094798;
		  /* 82094798h */ case    3:  		/* mr R4, R29 */
		/* 82094798h case    3:*/		regs.R4 = regs.R29;
		/* 82094798h case    3:*/		return 0x8209479C;
		  /* 8209479Ch */ case    4:  		/* mr R3, R31 */
		/* 8209479Ch case    4:*/		regs.R3 = regs.R31;
		/* 8209479Ch case    4:*/		return 0x820947A0;
		  /* 820947A0h */ case    5:  		/* bl -632 */
		/* 820947A0h case    5:*/		regs.LR = 0x820947A4; return 0x82094528;
		/* 820947A0h case    5:*/		return 0x820947A4;
	}
	return 0x820947A4;
} // Block from 8209478Ch-820947A4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820947A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820947A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820947A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820947A4);
		  /* 820947A4h */ case    0:  		/* addi R1, R1, 160 */
		/* 820947A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820947A4h case    0:*/		return 0x820947A8;
		  /* 820947A8h */ case    1:  		/* b -13564 */
		/* 820947A8h case    1:*/		return 0x820912AC;
		/* 820947A8h case    1:*/		return 0x820947AC;
		  /* 820947ACh */ case    2:  		/* nop */
		/* 820947ACh case    2:*/		cpu::op::nop();
		/* 820947ACh case    2:*/		return 0x820947B0;
	}
	return 0x820947B0;
} // Block from 820947A4h-820947B0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820947B0h
// Function '_flsbuf'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820947B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820947B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820947B0);
		  /* 820947B0h */ case    0:  		/* mfspr R12, LR */
		/* 820947B0h case    0:*/		regs.R12 = regs.LR;
		/* 820947B0h case    0:*/		return 0x820947B4;
		  /* 820947B4h */ case    1:  		/* bl -13668 */
		/* 820947B4h case    1:*/		regs.LR = 0x820947B8; return 0x82091250;
		/* 820947B4h case    1:*/		return 0x820947B8;
		  /* 820947B8h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820947B8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820947B8h case    2:*/		return 0x820947BC;
		  /* 820947BCh */ case    3:  		/* mr R29, R4 */
		/* 820947BCh case    3:*/		regs.R29 = regs.R4;
		/* 820947BCh case    3:*/		return 0x820947C0;
		  /* 820947C0h */ case    4:  		/* ld R3, <#[R3]> */
		/* 820947C0h case    4:*/		cpu::mem::load64( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820947C0h case    4:*/		return 0x820947C4;
		  /* 820947C4h */ case    5:  		/* mr R31, R5 */
		/* 820947C4h case    5:*/		regs.R31 = regs.R5;
		/* 820947C4h case    5:*/		return 0x820947C8;
		  /* 820947C8h */ case    6:  		/* mr R27, R6 */
		/* 820947C8h case    6:*/		regs.R27 = regs.R6;
		/* 820947C8h case    6:*/		return 0x820947CC;
		  /* 820947CCh */ case    7:  		/* li R6, 22 */
		/* 820947CCh case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x16);
		/* 820947CCh case    7:*/		return 0x820947D0;
		  /* 820947D0h */ case    8:  		/* addi R5, R1, 96 */
		/* 820947D0h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 820947D0h case    8:*/		return 0x820947D4;
		  /* 820947D4h */ case    9:  		/* addi R4, R1, 80 */
		/* 820947D4h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820947D4h case    9:*/		return 0x820947D8;
		  /* 820947D8h */ case   10:  		/* mr R26, R7 */
		/* 820947D8h case   10:*/		regs.R26 = regs.R7;
		/* 820947D8h case   10:*/		return 0x820947DC;
		  /* 820947DCh */ case   11:  		/* bl 21340 */
		/* 820947DCh case   11:*/		regs.LR = 0x820947E0; return 0x82099B38;
		/* 820947DCh case   11:*/		return 0x820947E0;
		  /* 820947E0h */ case   12:  		/* cmplwi CR6, R29, 0 */
		/* 820947E0h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820947E0h case   12:*/		return 0x820947E4;
		  /* 820947E4h */ case   13:  		/* bc 4, CR6_EQ, 28 */
		/* 820947E4h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82094800;  }
		/* 820947E4h case   13:*/		return 0x820947E8;
		  /* 820947E8h */ case   14:  		/* bl 1824 */
		/* 820947E8h case   14:*/		regs.LR = 0x820947EC; return 0x82094F08;
		/* 820947E8h case   14:*/		return 0x820947EC;
		  /* 820947ECh */ case   15:  		/* li R11, 22 */
		/* 820947ECh case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 820947ECh case   15:*/		return 0x820947F0;
		  /* 820947F0h */ case   16:  		/* stw R11, <#[R3]> */
		/* 820947F0h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820947F0h case   16:*/		return 0x820947F4;
		  /* 820947F4h */ case   17:  		/* bl -3732 */
		/* 820947F4h case   17:*/		regs.LR = 0x820947F8; return 0x82093960;
		/* 820947F4h case   17:*/		return 0x820947F8;
		  /* 820947F8h */ case   18:  		/* li R3, 22 */
		/* 820947F8h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x16);
		/* 820947F8h case   18:*/		return 0x820947FC;
		  /* 820947FCh */ case   19:  		/* b 220 */
		/* 820947FCh case   19:*/		return 0x820948D8;
		/* 820947FCh case   19:*/		return 0x82094800;
	}
	return 0x82094800;
} // Block from 820947B0h-82094800h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82094800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094800);
		  /* 82094800h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82094800h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82094800h case    0:*/		return 0x82094804;
		  /* 82094804h */ case    1:  		/* bc 12, CR6_EQ, -28 */
		/* 82094804h case    1:*/		if ( regs.CR[6].eq ) { return 0x820947E8;  }
		/* 82094804h case    1:*/		return 0x82094808;
		  /* 82094808h */ case    2:  		/* lwz R11, <#[R1 + 80]> */
		/* 82094808h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82094808h case    2:*/		return 0x8209480C;
		  /* 8209480Ch */ case    3:  		/* cmpwi CR6, R31, -1 */
		/* 8209480Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R31,0xFFFFFFFF);
		/* 8209480Ch case    3:*/		return 0x82094810;
		  /* 82094810h */ case    4:  		/* lwz R10, <#[R1 + 84]> */
		/* 82094810h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82094810h case    4:*/		return 0x82094814;
		  /* 82094814h */ case    5:  		/* li R4, -1 */
		/* 82094814h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0xFFFFFFFF);
		/* 82094814h case    5:*/		return 0x82094818;
		  /* 82094818h */ case    6:  		/* addi R11, R11, -45 */
		/* 82094818h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFD3);
		/* 82094818h case    6:*/		return 0x8209481C;
		  /* 8209481Ch */ case    7:  		/* addi R30, R10, -1 */
		/* 8209481Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R10,0xFFFFFFFF);
		/* 8209481Ch case    7:*/		return 0x82094820;
		  /* 82094820h */ case    8:  		/* cntlzw R11, R11 */
		/* 82094820h case    8:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82094820h case    8:*/		return 0x82094824;
		  /* 82094824h */ case    9:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 82094824h case    9:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82094824h case    9:*/		return 0x82094828;
		  /* 82094828h */ case   10:  		/* add R28, R11, R29 */
		/* 82094828h case   10:*/		cpu::op::add<0>(regs,&regs.R28,regs.R11,regs.R29);
		/* 82094828h case   10:*/		return 0x8209482C;
		  /* 8209482Ch */ case   11:  		/* bc 12, CR6_EQ, 8 */
		/* 8209482Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x82094834;  }
		/* 8209482Ch case   11:*/		return 0x82094830;
		  /* 82094830h */ case   12:  		/* subf R4, R11, R31 */
		/* 82094830h case   12:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R11,regs.R31);
		/* 82094830h case   12:*/		return 0x82094834;
	}
	return 0x82094834;
} // Block from 82094800h-82094834h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82094834h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094834( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094834) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094834);
		  /* 82094834h */ case    0:  		/* addi R6, R1, 80 */
		/* 82094834h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 82094834h case    0:*/		return 0x82094838;
		  /* 82094838h */ case    1:  		/* mr R5, R27 */
		/* 82094838h case    1:*/		regs.R5 = regs.R27;
		/* 82094838h case    1:*/		return 0x8209483C;
		  /* 8209483Ch */ case    2:  		/* mr R3, R28 */
		/* 8209483Ch case    2:*/		regs.R3 = regs.R28;
		/* 8209483Ch case    2:*/		return 0x82094840;
		  /* 82094840h */ case    3:  		/* bl 20664 */
		/* 82094840h case    3:*/		regs.LR = 0x82094844; return 0x820998F8;
		/* 82094840h case    3:*/		return 0x82094844;
		  /* 82094844h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 82094844h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82094844h case    4:*/		return 0x82094848;
		  /* 82094848h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 82094848h case    5:*/		if ( regs.CR[0].eq ) { return 0x82094858;  }
		/* 82094848h case    5:*/		return 0x8209484C;
		  /* 8209484Ch */ case    6:  		/* li R11, 0 */
		/* 8209484Ch case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209484Ch case    6:*/		return 0x82094850;
		  /* 82094850h */ case    7:  		/* stb R11, <#[R29]> */
		/* 82094850h case    7:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82094850h case    7:*/		return 0x82094854;
		  /* 82094854h */ case    8:  		/* b 132 */
		/* 82094854h case    8:*/		return 0x820948D8;
		/* 82094854h case    8:*/		return 0x82094858;
	}
	return 0x82094858;
} // Block from 82094834h-82094858h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82094858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094858);
		  /* 82094858h */ case    0:  		/* lwz R11, <#[R1 + 84]> */
		/* 82094858h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82094858h case    0:*/		return 0x8209485C;
		  /* 8209485Ch */ case    1:  		/* addi R11, R11, -1 */
		/* 8209485Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8209485Ch case    1:*/		return 0x82094860;
		  /* 82094860h */ case    2:  		/* subfc R10, R11, R30 */
		/* 82094860h case    2:*/		cpu::op::subfc<0>(regs,&regs.R10,regs.R11,regs.R30);
		/* 82094860h case    2:*/		return 0x82094864;
		  /* 82094864h */ case    3:  		/* eqv R9, R11, R30 */
		/* 82094864h case    3:*/		cpu::op::eqv<0>(regs,&regs.R9,regs.R11,regs.R30);
		/* 82094864h case    3:*/		return 0x82094868;
		  /* 82094868h */ case    4:  		/* cmpwi CR6, R11, -4 */
		/* 82094868h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFC);
		/* 82094868h case    4:*/		return 0x8209486C;
		  /* 8209486Ch */ case    5:  		/* rlwinm R10, R9, 1, 31, 31 */
		/* 8209486Ch case    5:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R10,regs.R9);
		/* 8209486Ch case    5:*/		return 0x82094870;
		  /* 82094870h */ case    6:  		/* addze R10, R10 */
		/* 82094870h case    6:*/		cpu::op::addze<0>(regs,&regs.R10,regs.R10);
		/* 82094870h case    6:*/		return 0x82094874;
		  /* 82094874h */ case    7:  		/* rlwinm R10, R10, 0, 31, 31 */
		/* 82094874h case    7:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82094874h case    7:*/		return 0x82094878;
		  /* 82094878h */ case    8:  		/* bc 12, CR6_LT, 68 */
		/* 82094878h case    8:*/		if ( regs.CR[6].lt ) { return 0x820948BC;  }
		/* 82094878h case    8:*/		return 0x8209487C;
		  /* 8209487Ch */ case    9:  		/* cmpw CR6, R11, R27 */
		/* 8209487Ch case    9:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R27);
		/* 8209487Ch case    9:*/		return 0x82094880;
		  /* 82094880h */ case   10:  		/* bc 4, CR6_LT, 60 */
		/* 82094880h case   10:*/		if ( !regs.CR[6].lt ) { return 0x820948BC;  }
		/* 82094880h case   10:*/		return 0x82094884;
		  /* 82094884h */ case   11:  		/* extsb. R11, R10 */
		/* 82094884h case   11:*/		cpu::op::extsb<1>(regs,&regs.R11,regs.R10);
		/* 82094884h case   11:*/		return 0x82094888;
		  /* 82094888h */ case   12:  		/* bc 12, CR0_EQ, 24 */
		/* 82094888h case   12:*/		if ( regs.CR[0].eq ) { return 0x820948A0;  }
		/* 82094888h case   12:*/		return 0x8209488C;
		  /* 8209488Ch */ case   13:  		/* lbz R11, <#[R28]> */
		/* 8209488Ch case   13:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8209488Ch case   13:*/		return 0x82094890;
		  /* 82094890h */ case   14:  		/* addi R28, R28, 1 */
		/* 82094890h case   14:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82094890h case   14:*/		return 0x82094894;
		  /* 82094894h */ case   15:  		/* cmplwi CR0, R11, 0 */
		/* 82094894h case   15:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82094894h case   15:*/		return 0x82094898;
		  /* 82094898h */ case   16:  		/* bc 4, CR0_EQ, -12 */
		/* 82094898h case   16:*/		if ( !regs.CR[0].eq ) { return 0x8209488C;  }
		/* 82094898h case   16:*/		return 0x8209489C;
		  /* 8209489Ch */ case   17:  		/* stb R11, <#[R28 - 2]> */
		/* 8209489Ch case   17:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R28 + 0xFFFFFFFE) );
		/* 8209489Ch case   17:*/		return 0x820948A0;
	}
	return 0x820948A0;
} // Block from 82094858h-820948A0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820948A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820948A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820948A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820948A0);
		  /* 820948A0h */ case    0:  		/* li R7, 1 */
		/* 820948A0h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 820948A0h case    0:*/		return 0x820948A4;
		  /* 820948A4h */ case    1:  		/* addi R6, R1, 80 */
		/* 820948A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 820948A4h case    1:*/		return 0x820948A8;
		  /* 820948A8h */ case    2:  		/* mr R5, R27 */
		/* 820948A8h case    2:*/		regs.R5 = regs.R27;
		/* 820948A8h case    2:*/		return 0x820948AC;
		  /* 820948ACh */ case    3:  		/* mr R4, R31 */
		/* 820948ACh case    3:*/		regs.R4 = regs.R31;
		/* 820948ACh case    3:*/		return 0x820948B0;
		  /* 820948B0h */ case    4:  		/* mr R3, R29 */
		/* 820948B0h case    4:*/		regs.R3 = regs.R29;
		/* 820948B0h case    4:*/		return 0x820948B4;
		  /* 820948B4h */ case    5:  		/* bl -908 */
		/* 820948B4h case    5:*/		regs.LR = 0x820948B8; return 0x82094528;
		/* 820948B4h case    5:*/		return 0x820948B8;
		  /* 820948B8h */ case    6:  		/* b 32 */
		/* 820948B8h case    6:*/		return 0x820948D8;
		/* 820948B8h case    6:*/		return 0x820948BC;
	}
	return 0x820948BC;
} // Block from 820948A0h-820948BCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820948BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820948BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820948BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820948BC);
		  /* 820948BCh */ case    0:  		/* li R8, 1 */
		/* 820948BCh case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820948BCh case    0:*/		return 0x820948C0;
		  /* 820948C0h */ case    1:  		/* addi R7, R1, 80 */
		/* 820948C0h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 820948C0h case    1:*/		return 0x820948C4;
		  /* 820948C4h */ case    2:  		/* mr R6, R26 */
		/* 820948C4h case    2:*/		regs.R6 = regs.R26;
		/* 820948C4h case    2:*/		return 0x820948C8;
		  /* 820948C8h */ case    3:  		/* mr R5, R27 */
		/* 820948C8h case    3:*/		regs.R5 = regs.R27;
		/* 820948C8h case    3:*/		return 0x820948CC;
		  /* 820948CCh */ case    4:  		/* mr R4, R31 */
		/* 820948CCh case    4:*/		regs.R4 = regs.R31;
		/* 820948CCh case    4:*/		return 0x820948D0;
		  /* 820948D0h */ case    5:  		/* mr R3, R29 */
		/* 820948D0h case    5:*/		regs.R3 = regs.R29;
		/* 820948D0h case    5:*/		return 0x820948D4;
		  /* 820948D4h */ case    6:  		/* bl -2812 */
		/* 820948D4h case    6:*/		regs.LR = 0x820948D8; return 0x82093DD8;
		/* 820948D4h case    6:*/		return 0x820948D8;
	}
	return 0x820948D8;
} // Block from 820948BCh-820948D8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820948D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820948D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820948D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820948D8);
		  /* 820948D8h */ case    0:  		/* addi R1, R1, 176 */
		/* 820948D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820948D8h case    0:*/		return 0x820948DC;
		  /* 820948DCh */ case    1:  		/* b -13884 */
		/* 820948DCh case    1:*/		return 0x820912A0;
		/* 820948DCh case    1:*/		return 0x820948E0;
		  /* 820948E0h */ case    2:  		/* mr R11, R6 */
		/* 820948E0h case    2:*/		regs.R11 = regs.R6;
		/* 820948E0h case    2:*/		return 0x820948E4;
		  /* 820948E4h */ case    3:  		/* mr R6, R7 */
		/* 820948E4h case    3:*/		regs.R6 = regs.R7;
		/* 820948E4h case    3:*/		return 0x820948E8;
		  /* 820948E8h */ case    4:  		/* mr R7, R8 */
		/* 820948E8h case    4:*/		regs.R7 = regs.R8;
		/* 820948E8h case    4:*/		return 0x820948EC;
		  /* 820948ECh */ case    5:  		/* mr R8, R9 */
		/* 820948ECh case    5:*/		regs.R8 = regs.R9;
		/* 820948ECh case    5:*/		return 0x820948F0;
		  /* 820948F0h */ case    6:  		/* cmpwi CR6, R11, 101 */
		/* 820948F0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000065);
		/* 820948F0h case    6:*/		return 0x820948F4;
		  /* 820948F4h */ case    7:  		/* bc 12, CR6_EQ, 52 */
		/* 820948F4h case    7:*/		if ( regs.CR[6].eq ) { return 0x82094928;  }
		/* 820948F4h case    7:*/		return 0x820948F8;
		  /* 820948F8h */ case    8:  		/* cmpwi CR6, R11, 69 */
		/* 820948F8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000045);
		/* 820948F8h case    8:*/		return 0x820948FC;
		  /* 820948FCh */ case    9:  		/* bc 12, CR6_EQ, 44 */
		/* 820948FCh case    9:*/		if ( regs.CR[6].eq ) { return 0x82094928;  }
		/* 820948FCh case    9:*/		return 0x82094900;
		  /* 82094900h */ case   10:  		/* cmpwi CR6, R11, 102 */
		/* 82094900h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000066);
		/* 82094900h case   10:*/		return 0x82094904;
		  /* 82094904h */ case   11:  		/* bc 4, CR6_EQ, 12 */
		/* 82094904h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82094910;  }
		/* 82094904h case   11:*/		return 0x82094908;
		  /* 82094908h */ case   12:  		/* mr R7, R9 */
		/* 82094908h case   12:*/		regs.R7 = regs.R9;
		/* 82094908h case   12:*/		return 0x8209490C;
		  /* 8209490Ch */ case   13:  		/* b -556 */
		/* 8209490Ch case   13:*/		return 0x820946E0;
		/* 8209490Ch case   13:*/		return 0x82094910;
	}
	return 0x82094910;
} // Block from 820948D8h-82094910h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82094910h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094910( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094910) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094910);
		  /* 82094910h */ case    0:  		/* cmpwi CR6, R11, 97 */
		/* 82094910h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000061);
		/* 82094910h case    0:*/		return 0x82094914;
		  /* 82094914h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 82094914h case    1:*/		if ( regs.CR[6].eq ) { return 0x82094924;  }
		/* 82094914h case    1:*/		return 0x82094918;
		  /* 82094918h */ case    2:  		/* cmpwi CR6, R11, 65 */
		/* 82094918h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000041);
		/* 82094918h case    2:*/		return 0x8209491C;
		  /* 8209491Ch */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 8209491Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82094924;  }
		/* 8209491Ch case    3:*/		return 0x82094920;
		  /* 82094920h */ case    4:  		/* b -368 */
		/* 82094920h case    4:*/		return 0x820947B0;
		/* 82094920h case    4:*/		return 0x82094924;
	}
	return 0x82094924;
} // Block from 82094910h-82094924h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82094924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094924);
		  /* 82094924h */ case    0:  		/* b -2060 */
		/* 82094924h case    0:*/		return 0x82094118;
		/* 82094924h case    0:*/		return 0x82094928;
	}
	return 0x82094928;
} // Block from 82094924h-82094928h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82094928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094928);
		  /* 82094928h */ case    0:  		/* b -2304 */
		/* 82094928h case    0:*/		return 0x82094028;
		/* 82094928h case    0:*/		return 0x8209492C;
		  /* 8209492Ch */ case    1:  		/* nop */
		/* 8209492Ch case    1:*/		cpu::op::nop();
		/* 8209492Ch case    1:*/		return 0x82094930;
		  /* 82094930h */ case    2:  		/* mr R11, R6 */
		/* 82094930h case    2:*/		regs.R11 = regs.R6;
		/* 82094930h case    2:*/		return 0x82094934;
		  /* 82094934h */ case    3:  		/* mr R6, R7 */
		/* 82094934h case    3:*/		regs.R6 = regs.R7;
		/* 82094934h case    3:*/		return 0x82094938;
		  /* 82094938h */ case    4:  		/* mr R7, R8 */
		/* 82094938h case    4:*/		regs.R7 = regs.R8;
		/* 82094938h case    4:*/		return 0x8209493C;
		  /* 8209493Ch */ case    5:  		/* cmpwi CR6, R11, 101 */
		/* 8209493Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000065);
		/* 8209493Ch case    5:*/		return 0x82094940;
		  /* 82094940h */ case    6:  		/* bc 12, CR6_EQ, 60 */
		/* 82094940h case    6:*/		if ( regs.CR[6].eq ) { return 0x8209497C;  }
		/* 82094940h case    6:*/		return 0x82094944;
		  /* 82094944h */ case    7:  		/* cmpwi CR6, R11, 69 */
		/* 82094944h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000045);
		/* 82094944h case    7:*/		return 0x82094948;
		  /* 82094948h */ case    8:  		/* bc 12, CR6_EQ, 52 */
		/* 82094948h case    8:*/		if ( regs.CR[6].eq ) { return 0x8209497C;  }
		/* 82094948h case    8:*/		return 0x8209494C;
		  /* 8209494Ch */ case    9:  		/* cmpwi CR6, R11, 102 */
		/* 8209494Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000066);
		/* 8209494Ch case    9:*/		return 0x82094950;
		  /* 82094950h */ case   10:  		/* bc 4, CR6_EQ, 12 */
		/* 82094950h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8209495C;  }
		/* 82094950h case   10:*/		return 0x82094954;
		  /* 82094954h */ case   11:  		/* li R7, 0 */
		/* 82094954h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82094954h case   11:*/		return 0x82094958;
		  /* 82094958h */ case   12:  		/* b -632 */
		/* 82094958h case   12:*/		return 0x820946E0;
		/* 82094958h case   12:*/		return 0x8209495C;
	}
	return 0x8209495C;
} // Block from 82094928h-8209495Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209495Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209495C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209495C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209495C);
		  /* 8209495Ch */ case    0:  		/* cmpwi CR6, R11, 97 */
		/* 8209495Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000061);
		/* 8209495Ch case    0:*/		return 0x82094960;
		  /* 82094960h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 82094960h case    1:*/		if ( regs.CR[6].eq ) { return 0x82094974;  }
		/* 82094960h case    1:*/		return 0x82094964;
		  /* 82094964h */ case    2:  		/* cmpwi CR6, R11, 65 */
		/* 82094964h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000041);
		/* 82094964h case    2:*/		return 0x82094968;
		  /* 82094968h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82094968h case    3:*/		if ( regs.CR[6].eq ) { return 0x82094974;  }
		/* 82094968h case    3:*/		return 0x8209496C;
		  /* 8209496Ch */ case    4:  		/* li R8, 0 */
		/* 8209496Ch case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8209496Ch case    4:*/		return 0x82094970;
		  /* 82094970h */ case    5:  		/* b -448 */
		/* 82094970h case    5:*/		return 0x820947B0;
		/* 82094970h case    5:*/		return 0x82094974;
	}
	return 0x82094974;
} // Block from 8209495Ch-82094974h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82094974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094974);
		  /* 82094974h */ case    0:  		/* li R8, 0 */
		/* 82094974h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82094974h case    0:*/		return 0x82094978;
		  /* 82094978h */ case    1:  		/* b -2144 */
		/* 82094978h case    1:*/		return 0x82094118;
		/* 82094978h case    1:*/		return 0x8209497C;
	}
	return 0x8209497C;
} // Block from 82094974h-8209497Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209497Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209497C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209497C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209497C);
		  /* 8209497Ch */ case    0:  		/* li R8, 0 */
		/* 8209497Ch case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8209497Ch case    0:*/		return 0x82094980;
		  /* 82094980h */ case    1:  		/* b -2392 */
		/* 82094980h case    1:*/		return 0x82094028;
		/* 82094980h case    1:*/		return 0x82094984;
		  /* 82094984h */ case    2:  		/* nop */
		/* 82094984h case    2:*/		cpu::op::nop();
		/* 82094984h case    2:*/		return 0x82094988;
	}
	return 0x82094988;
} // Block from 8209497Ch-82094988h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82094988h
// Function '_get_errno_from_oserr'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094988);
		  /* 82094988h */ case    0:  		/* stfd FR1, <#[R1 + 16]> */
		/* 82094988h case    0:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000010) );
		/* 82094988h case    0:*/		return 0x8209498C;
		  /* 8209498Ch */ case    1:  		/* lhz R11, <#[R1 + 16]> */
		/* 8209498Ch case    1:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000010) );
		/* 8209498Ch case    1:*/		return 0x82094990;
		  /* 82094990h */ case    2:  		/* stfd FR1, <#[R1 - 16]> */
		/* 82094990h case    2:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82094990h case    2:*/		return 0x82094994;
		  /* 82094994h */ case    3:  		/* addi R10, R4, 1022 */
		/* 82094994h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x3FE);
		/* 82094994h case    3:*/		return 0x82094998;
		  /* 82094998h */ case    4:  		/* andi. R11, R11, 32783 */
		/* 82094998h case    4:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x800F);
		/* 82094998h case    4:*/		return 0x8209499C;
		  /* 8209499Ch */ case    5:  		/* rlwinm R10, R10, 4, 0, 27 */
		/* 8209499Ch case    5:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R10);
		/* 8209499Ch case    5:*/		return 0x820949A0;
		  /* 820949A0h */ case    6:  		/* or R11, R10, R11 */
		/* 820949A0h case    6:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820949A0h case    6:*/		return 0x820949A4;
		  /* 820949A4h */ case    7:  		/* sth R11, <#[R1 - 16]> */
		/* 820949A4h case    7:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820949A4h case    7:*/		return 0x820949A8;
		  /* 820949A8h */ case    8:  		/* lfd FR1, <#[R1 - 16]> */
		/* 820949A8h case    8:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820949A8h case    8:*/		return 0x820949AC;
		  /* 820949ACh */ case    9:  		/* bclr 20, CR0_LT */
		/* 820949ACh case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820949ACh case    9:*/		return 0x820949B0;
	}
	return 0x820949B0;
} // Block from 82094988h-820949B0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820949B0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820949B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820949B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820949B0);
		  /* 820949B0h */ case    0:  		/* stfd FR1, <#[R1 + 16]> */
		/* 820949B0h case    0:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000010) );
		/* 820949B0h case    0:*/		return 0x820949B4;
		  /* 820949B4h */ case    1:  		/* lhz R11, <#[R1 + 16]> */
		/* 820949B4h case    1:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000010) );
		/* 820949B4h case    1:*/		return 0x820949B8;
		  /* 820949B8h */ case    2:  		/* rlwinm R11, R11, 28, 21, 31 */
		/* 820949B8h case    2:*/		cpu::op::rlwinm<0,28,21,31>(regs,&regs.R11,regs.R11);
		/* 820949B8h case    2:*/		return 0x820949BC;
		  /* 820949BCh */ case    3:  		/* addi R11, R11, -1022 */
		/* 820949BCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFC02);
		/* 820949BCh case    3:*/		return 0x820949C0;
		  /* 820949C0h */ case    4:  		/* extsh R3, R11 */
		/* 820949C0h case    4:*/		cpu::op::extsh<0>(regs,&regs.R3,regs.R11);
		/* 820949C0h case    4:*/		return 0x820949C4;
		  /* 820949C4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820949C4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820949C4h case    5:*/		return 0x820949C8;
	}
	return 0x820949C8;
} // Block from 820949B0h-820949C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820949C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820949C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820949C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820949C8);
		  /* 820949C8h */ case    0:  		/* stfd FR1, <#[R1 + 16]> */
		/* 820949C8h case    0:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000010) );
		/* 820949C8h case    0:*/		return 0x820949CC;
		  /* 820949CCh */ case    1:  		/* lhz R11, <#[R1 + 16]> */
		/* 820949CCh case    1:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000010) );
		/* 820949CCh case    1:*/		return 0x820949D0;
		  /* 820949D0h */ case    2:  		/* stfd FR1, <#[R1 - 16]> */
		/* 820949D0h case    2:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820949D0h case    2:*/		return 0x820949D4;
		  /* 820949D4h */ case    3:  		/* lhz R10, <#[R1 - 16]> */
		/* 820949D4h case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820949D4h case    3:*/		return 0x820949D8;
		  /* 820949D8h */ case    4:  		/* stfd FR1, <#[R1 - 16]> */
		/* 820949D8h case    4:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820949D8h case    4:*/		return 0x820949DC;
		  /* 820949DCh */ case    5:  		/* rlwinm R11, R11, 28, 21, 31 */
		/* 820949DCh case    5:*/		cpu::op::rlwinm<0,28,21,31>(regs,&regs.R11,regs.R11);
		/* 820949DCh case    5:*/		return 0x820949E0;
		  /* 820949E0h */ case    6:  		/* add R11, R11, R4 */
		/* 820949E0h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 820949E0h case    6:*/		return 0x820949E4;
		  /* 820949E4h */ case    7:  		/* andi. R10, R10, 32783 */
		/* 820949E4h case    7:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R10,0x800F);
		/* 820949E4h case    7:*/		return 0x820949E8;
		  /* 820949E8h */ case    8:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 820949E8h case    8:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 820949E8h case    8:*/		return 0x820949EC;
		  /* 820949ECh */ case    9:  		/* or R11, R11, R10 */
		/* 820949ECh case    9:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820949ECh case    9:*/		return 0x820949F0;
		  /* 820949F0h */ case   10:  		/* sth R11, <#[R1 - 16]> */
		/* 820949F0h case   10:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820949F0h case   10:*/		return 0x820949F4;
		  /* 820949F4h */ case   11:  		/* lfd FR1, <#[R1 - 16]> */
		/* 820949F4h case   11:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820949F4h case   11:*/		return 0x820949F8;
	}
	return 0x820949F8;
} // Block from 820949C8h-820949F8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820949F8h
// Function '_errno'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820949F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820949F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820949F8);
		  /* 820949F8h */ case    0:  		/* bclr 20, CR0_LT */
		/* 820949F8h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820949F8h case    0:*/		return 0x820949FC;
	}
	return 0x820949FC;
} // Block from 820949F8h-820949FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820949FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820949FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820949FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820949FC);
		  /* 820949FCh */ case    0:  		/* nop */
		/* 820949FCh case    0:*/		cpu::op::nop();
		/* 820949FCh case    0:*/		return 0x82094A00;
	}
	return 0x82094A00;
} // Block from 820949FCh-82094A00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82094A00h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094A00);
		  /* 82094A00h */ case    0:  		/* lis R11, 32752 */
		/* 82094A00h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FF0);
		/* 82094A00h case    0:*/		return 0x82094A04;
		  /* 82094A04h */ case    1:  		/* stfd FR1, <#[R1 + 16]> */
		/* 82094A04h case    1:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000010) );
		/* 82094A04h case    1:*/		return 0x82094A08;
		  /* 82094A08h */ case    2:  		/* lwz R10, <#[R1 + 16]> */
		/* 82094A08h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000010) );
		/* 82094A08h case    2:*/		return 0x82094A0C;
		  /* 82094A0Ch */ case    3:  		/* lwz R9, <#[R1 + 20]> */
		/* 82094A0Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000014) );
		/* 82094A0Ch case    3:*/		return 0x82094A10;
		  /* 82094A10h */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 82094A10h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82094A10h case    4:*/		return 0x82094A14;
		  /* 82094A14h */ case    5:  		/* bc 4, CR6_EQ, 20 */
		/* 82094A14h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82094A28;  }
		/* 82094A14h case    5:*/		return 0x82094A18;
		  /* 82094A18h */ case    6:  		/* cmplwi CR6, R9, 0 */
		/* 82094A18h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82094A18h case    6:*/		return 0x82094A1C;
		  /* 82094A1Ch */ case    7:  		/* bc 4, CR6_EQ, 40 */
		/* 82094A1Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x82094A44;  }
		/* 82094A1Ch case    7:*/		return 0x82094A20;
		  /* 82094A20h */ case    8:  		/* li R3, 1 */
		/* 82094A20h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82094A20h case    8:*/		return 0x82094A24;
		  /* 82094A24h */ case    9:  		/* bclr 20, CR0_LT */
		/* 82094A24h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82094A24h case    9:*/		return 0x82094A28;
	}
	return 0x82094A28;
} // Block from 82094A00h-82094A28h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82094A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094A28);
		  /* 82094A28h */ case    0:  		/* lis R11, -16 */
		/* 82094A28h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFFFF0);
		/* 82094A28h case    0:*/		return 0x82094A2C;
		  /* 82094A2Ch */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 82094A2Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82094A2Ch case    1:*/		return 0x82094A30;
	}
	return 0x82094A30;
} // Block from 82094A28h-82094A30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82094A30h
// Function '__doserrno'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094A30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094A30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094A30);
		  /* 82094A30h */ case    0:  		/* bc 4, CR6_EQ, 20 */
		/* 82094A30h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82094A44;  }
		/* 82094A30h case    0:*/		return 0x82094A34;
		  /* 82094A34h */ case    1:  		/* cmplwi CR6, R9, 0 */
		/* 82094A34h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82094A34h case    1:*/		return 0x82094A38;
		  /* 82094A38h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 82094A38h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82094A44;  }
		/* 82094A38h case    2:*/		return 0x82094A3C;
		  /* 82094A3Ch */ case    3:  		/* li R3, 2 */
		/* 82094A3Ch case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 82094A3Ch case    3:*/		return 0x82094A40;
		  /* 82094A40h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82094A40h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82094A40h case    4:*/		return 0x82094A44;
	}
	return 0x82094A44;
} // Block from 82094A30h-82094A44h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82094A44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094A44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094A44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094A44);
		  /* 82094A44h */ case    0:  		/* lhz R11, <#[R1 + 16]> */
		/* 82094A44h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000010) );
		/* 82094A44h case    0:*/		return 0x82094A48;
		  /* 82094A48h */ case    1:  		/* rlwinm R11, R11, 0, 17, 28 */
		/* 82094A48h case    1:*/		cpu::op::rlwinm<0,0,17,28>(regs,&regs.R11,regs.R11);
		/* 82094A48h case    1:*/		return 0x82094A4C;
		  /* 82094A4Ch */ case    2:  		/* cmplwi CR6, R11, 32760 */
		/* 82094A4Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00007FF8);
		/* 82094A4Ch case    2:*/		return 0x82094A50;
		  /* 82094A50h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 82094A50h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82094A5C;  }
		/* 82094A50h case    3:*/		return 0x82094A54;
		  /* 82094A54h */ case    4:  		/* li R3, 3 */
		/* 82094A54h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 82094A54h case    4:*/		return 0x82094A58;
		  /* 82094A58h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82094A58h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82094A58h case    5:*/		return 0x82094A5C;
	}
	return 0x82094A5C;
} // Block from 82094A44h-82094A5Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82094A5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094A5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094A5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094A5C);
		  /* 82094A5Ch */ case    0:  		/* cmplwi CR6, R11, 32752 */
		/* 82094A5Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00007FF0);
		/* 82094A5Ch case    0:*/		return 0x82094A60;
		  /* 82094A60h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 82094A60h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82094A7C;  }
		/* 82094A60h case    1:*/		return 0x82094A64;
		  /* 82094A64h */ case    2:  		/* rlwinm. R11, R10, 0, 13, 31 */
		/* 82094A64h case    2:*/		cpu::op::rlwinm<1,0,13,31>(regs,&regs.R11,regs.R10);
		/* 82094A64h case    2:*/		return 0x82094A68;
	}
	return 0x82094A68;
} // Block from 82094A5Ch-82094A68h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82094A68h
// Function '_dosmaperr'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094A68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094A68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094A68);
		  /* 82094A68h */ case    0:  		/* bc 4, CR0_EQ, 12 */
		/* 82094A68h case    0:*/		if ( !regs.CR[0].eq ) { return 0x82094A74;  }
		/* 82094A68h case    0:*/		return 0x82094A6C;
		  /* 82094A6Ch */ case    1:  		/* cmplwi CR6, R9, 0 */
		/* 82094A6Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82094A6Ch case    1:*/		return 0x82094A70;
		  /* 82094A70h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 82094A70h case    2:*/		if ( regs.CR[6].eq ) { return 0x82094A7C;  }
		/* 82094A70h case    2:*/		return 0x82094A74;
	}
	return 0x82094A74;
} // Block from 82094A68h-82094A74h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82094A74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094A74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094A74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094A74);
		  /* 82094A74h */ case    0:  		/* li R3, 4 */
		/* 82094A74h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x4);
		/* 82094A74h case    0:*/		return 0x82094A78;
		  /* 82094A78h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82094A78h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82094A78h case    1:*/		return 0x82094A7C;
	}
	return 0x82094A7C;
} // Block from 82094A74h-82094A7Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82094A7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094A7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094A7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094A7C);
		  /* 82094A7Ch */ case    0:  		/* li R3, 0 */
		/* 82094A7Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82094A7Ch case    0:*/		return 0x82094A80;
		  /* 82094A80h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82094A80h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82094A80h case    1:*/		return 0x82094A84;
	}
	return 0x82094A84;
} // Block from 82094A7Ch-82094A84h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82094A84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094A84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094A84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094A84);
		  /* 82094A84h */ case    0:  		/* nop */
		/* 82094A84h case    0:*/		cpu::op::nop();
		/* 82094A84h case    0:*/		return 0x82094A88;
	}
	return 0x82094A88;
} // Block from 82094A84h-82094A88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82094A88h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094A88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094A88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094A88);
		  /* 82094A88h */ case    0:  		/* lis R11, -32256 */
		/* 82094A88h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82094A88h case    0:*/		return 0x82094A8C;
		  /* 82094A8Ch */ case    1:  		/* stfd FR1, <#[R1 + 16]> */
		/* 82094A8Ch case    1:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000010) );
		/* 82094A8Ch case    1:*/		return 0x82094A90;
		  /* 82094A90h */ case    2:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 82094A90h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 82094A90h case    2:*/		return 0x82094A94;
		  /* 82094A94h */ case    3:  		/* fcmpu CR6, FR1, FR0 */
		/* 82094A94h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82094A94h case    3:*/		return 0x82094A98;
		  /* 82094A98h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 82094A98h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82094AA4;  }
		/* 82094A98h case    4:*/		return 0x82094A9C;
		  /* 82094A9Ch */ case    5:  		/* li R9, 0 */
		/* 82094A9Ch case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82094A9Ch case    5:*/		return 0x82094AA0;
		  /* 82094AA0h */ case    6:  		/* b 212 */
		/* 82094AA0h case    6:*/		return 0x82094B74;
		/* 82094AA0h case    6:*/		return 0x82094AA4;
	}
	return 0x82094AA4;
} // Block from 82094A88h-82094AA4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82094AA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094AA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094AA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094AA4);
		  /* 82094AA4h */ case    0:  		/* lhz R11, <#[R1 + 16]> */
		/* 82094AA4h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000010) );
		/* 82094AA4h case    0:*/		return 0x82094AA8;
		  /* 82094AA8h */ case    1:  		/* rlwinm. R9, R11, 0, 17, 27 */
		/* 82094AA8h case    1:*/		cpu::op::rlwinm<1,0,17,27>(regs,&regs.R9,regs.R11);
		/* 82094AA8h case    1:*/		return 0x82094AAC;
		  /* 82094AACh */ case    2:  		/* bc 4, CR0_EQ, 160 */
		/* 82094AACh case    2:*/		if ( !regs.CR[0].eq ) { return 0x82094B4C;  }
		/* 82094AACh case    2:*/		return 0x82094AB0;
		  /* 82094AB0h */ case    3:  		/* lwz R8, <#[R1 + 16]> */
		/* 82094AB0h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000010) );
		/* 82094AB0h case    3:*/		return 0x82094AB4;
		  /* 82094AB4h */ case    4:  		/* lwz R10, <#[R1 + 20]> */
		/* 82094AB4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000014) );
		/* 82094AB4h case    4:*/		return 0x82094AB8;
		  /* 82094AB8h */ case    5:  		/* rlwinm. R7, R8, 0, 12, 31 */
		/* 82094AB8h case    5:*/		cpu::op::rlwinm<1,0,12,31>(regs,&regs.R7,regs.R8);
		/* 82094AB8h case    5:*/		return 0x82094ABC;
		  /* 82094ABCh */ case    6:  		/* bc 4, CR0_EQ, 12 */
		/* 82094ABCh case    6:*/		if ( !regs.CR[0].eq ) { return 0x82094AC8;  }
		/* 82094ABCh case    6:*/		return 0x82094AC0;
		  /* 82094AC0h */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 82094AC0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82094AC0h case    7:*/		return 0x82094AC4;
		  /* 82094AC4h */ case    8:  		/* bc 12, CR6_EQ, 136 */
		/* 82094AC4h case    8:*/		if ( regs.CR[6].eq ) { return 0x82094B4C;  }
		/* 82094AC4h case    8:*/		return 0x82094AC8;
	}
	return 0x82094AC8;
} // Block from 82094AA4h-82094AC8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82094AC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094AC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094AC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094AC8);
		  /* 82094AC8h */ case    0:  		/* li R9, -1021 */
		/* 82094AC8h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFC03);
		/* 82094AC8h case    0:*/		return 0x82094ACC;
		  /* 82094ACCh */ case    1:  		/* fcmpu CR6, FR1, FR0 */
		/* 82094ACCh case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82094ACCh case    1:*/		return 0x82094AD0;
		  /* 82094AD0h */ case    2:  		/* li R7, 1 */
		/* 82094AD0h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82094AD0h case    2:*/		return 0x82094AD4;
		  /* 82094AD4h */ case    3:  		/* bc 12, CR6_LT, 8 */
		/* 82094AD4h case    3:*/		if ( regs.CR[6].lt ) { return 0x82094ADC;  }
		/* 82094AD4h case    3:*/		return 0x82094AD8;
	}
	return 0x82094AD8;
} // Block from 82094AC8h-82094AD8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82094AD8h
// Function 'write_string'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094AD8);
		  /* 82094AD8h */ case    0:  		/* li R7, 0 */
		/* 82094AD8h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82094AD8h case    0:*/		return 0x82094ADC;
	}
	return 0x82094ADC;
} // Block from 82094AD8h-82094ADCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82094ADCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094ADC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094ADC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094ADC);
		  /* 82094ADCh */ case    0:  		/* rlwinm. R6, R11, 0, 27, 27 */
		/* 82094ADCh case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R6,regs.R11);
		/* 82094ADCh case    0:*/		return 0x82094AE0;
		  /* 82094AE0h */ case    1:  		/* bc 4, CR0_EQ, 52 */
		/* 82094AE0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82094B14;  }
		/* 82094AE0h case    1:*/		return 0x82094AE4;
		  /* 82094AE4h */ case    2:  		/* rlwinm R8, R8, 1, 0, 30 */
		/* 82094AE4h case    2:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R8,regs.R8);
		/* 82094AE4h case    2:*/		return 0x82094AE8;
		  /* 82094AE8h */ case    3:  		/* rlwinm. R11, R10, 0, 0, 0 */
		/* 82094AE8h case    3:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R10);
		/* 82094AE8h case    3:*/		return 0x82094AEC;
		  /* 82094AECh */ case    4:  		/* stw R8, <#[R1 + 16]> */
		/* 82094AECh case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000010) );
		/* 82094AECh case    4:*/		return 0x82094AF0;
		  /* 82094AF0h */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 82094AF0h case    5:*/		if ( regs.CR[0].eq ) { return 0x82094AFC;  }
		/* 82094AF0h case    5:*/		return 0x82094AF4;
		  /* 82094AF4h */ case    6:  		/* ori R8, R8, 1 */
		/* 82094AF4h case    6:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82094AF4h case    6:*/		return 0x82094AF8;
		  /* 82094AF8h */ case    7:  		/* stw R8, <#[R1 + 16]> */
		/* 82094AF8h case    7:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000010) );
		/* 82094AF8h case    7:*/		return 0x82094AFC;
	}
	return 0x82094AFC;
} // Block from 82094ADCh-82094AFCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 82094AFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094AFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094AFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094AFC);
		  /* 82094AFCh */ case    0:  		/* lhz R11, <#[R1 + 16]> */
		/* 82094AFCh case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000010) );
		/* 82094AFCh case    0:*/		return 0x82094B00;
		  /* 82094B00h */ case    1:  		/* rlwinm R10, R10, 1, 0, 30 */
		/* 82094B00h case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R10);
		/* 82094B00h case    1:*/		return 0x82094B04;
		  /* 82094B04h */ case    2:  		/* addi R9, R9, -1 */
		/* 82094B04h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82094B04h case    2:*/		return 0x82094B08;
		  /* 82094B08h */ case    3:  		/* rlwinm. R6, R11, 0, 27, 27 */
		/* 82094B08h case    3:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R6,regs.R11);
		/* 82094B08h case    3:*/		return 0x82094B0C;
		  /* 82094B0Ch */ case    4:  		/* bc 12, CR0_EQ, -40 */
		/* 82094B0Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x82094AE4;  }
		/* 82094B0Ch case    4:*/		return 0x82094B10;
		  /* 82094B10h */ case    5:  		/* stw R10, <#[R1 + 20]> */
		/* 82094B10h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000014) );
		/* 82094B10h case    5:*/		return 0x82094B14;
	}
	return 0x82094B14;
} // Block from 82094AFCh-82094B14h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82094B14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094B14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094B14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094B14);
		  /* 82094B14h */ case    0:  		/* andi. R11, R11, 65519 */
		/* 82094B14h case    0:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0xFFEF);
		/* 82094B14h case    0:*/		return 0x82094B18;
		  /* 82094B18h */ case    1:  		/* cmpwi CR6, R7, 0 */
		/* 82094B18h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 82094B18h case    1:*/		return 0x82094B1C;
		  /* 82094B1Ch */ case    2:  		/* sth R11, <#[R1 + 16]> */
		/* 82094B1Ch case    2:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000010) );
		/* 82094B1Ch case    2:*/		return 0x82094B20;
		  /* 82094B20h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82094B20h case    3:*/		if ( regs.CR[6].eq ) { return 0x82094B2C;  }
		/* 82094B20h case    3:*/		return 0x82094B24;
		  /* 82094B24h */ case    4:  		/* ori R11, R11, 32768 */
		/* 82094B24h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 82094B24h case    4:*/		return 0x82094B28;
		  /* 82094B28h */ case    5:  		/* sth R11, <#[R1 + 16]> */
		/* 82094B28h case    5:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000010) );
		/* 82094B28h case    5:*/		return 0x82094B2C;
	}
	return 0x82094B2C;
} // Block from 82094B14h-82094B2Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82094B2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094B2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094B2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094B2C);
		  /* 82094B2Ch */ case    0:  		/* lfd FR0, <#[R1 + 16]> */
		/* 82094B2Ch case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000010) );
		/* 82094B2Ch case    0:*/		return 0x82094B30;
		  /* 82094B30h */ case    1:  		/* stfd FR0, <#[R1 - 16]> */
		/* 82094B30h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82094B30h case    1:*/		return 0x82094B34;
		  /* 82094B34h */ case    2:  		/* lhz R11, <#[R1 - 16]> */
		/* 82094B34h case    2:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82094B34h case    2:*/		return 0x82094B38;
		  /* 82094B38h */ case    3:  		/* andi. R11, R11, 32783 */
		/* 82094B38h case    3:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x800F);
		/* 82094B38h case    3:*/		return 0x82094B3C;
		  /* 82094B3Ch */ case    4:  		/* stfd FR0, <#[R1 - 16]> */
		/* 82094B3Ch case    4:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82094B3Ch case    4:*/		return 0x82094B40;
		  /* 82094B40h */ case    5:  		/* ori R11, R11, 16352 */
		/* 82094B40h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x3FE0);
		/* 82094B40h case    5:*/		return 0x82094B44;
		  /* 82094B44h */ case    6:  		/* sth R11, <#[R1 - 16]> */
		/* 82094B44h case    6:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82094B44h case    6:*/		return 0x82094B48;
		  /* 82094B48h */ case    7:  		/* b 40 */
		/* 82094B48h case    7:*/		return 0x82094B70;
		/* 82094B48h case    7:*/		return 0x82094B4C;
	}
	return 0x82094B4C;
} // Block from 82094B2Ch-82094B4Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 82094B4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094B4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094B4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094B4C);
		  /* 82094B4Ch */ case    0:  		/* stfd FR1, <#[R1 - 16]> */
		/* 82094B4Ch case    0:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82094B4Ch case    0:*/		return 0x82094B50;
		  /* 82094B50h */ case    1:  		/* lhz R11, <#[R1 - 16]> */
		/* 82094B50h case    1:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82094B50h case    1:*/		return 0x82094B54;
		  /* 82094B54h */ case    2:  		/* andi. R11, R11, 32783 */
		/* 82094B54h case    2:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x800F);
		/* 82094B54h case    2:*/		return 0x82094B58;
		  /* 82094B58h */ case    3:  		/* stfd FR1, <#[R1 - 16]> */
		/* 82094B58h case    3:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82094B58h case    3:*/		return 0x82094B5C;
		  /* 82094B5Ch */ case    4:  		/* ori R11, R11, 16352 */
		/* 82094B5Ch case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x3FE0);
		/* 82094B5Ch case    4:*/		return 0x82094B60;
		  /* 82094B60h */ case    5:  		/* rlwinm R10, R9, 28, 20, 31 */
		/* 82094B60h case    5:*/		cpu::op::rlwinm<0,28,20,31>(regs,&regs.R10,regs.R9);
		/* 82094B60h case    5:*/		return 0x82094B64;
		  /* 82094B64h */ case    6:  		/* sth R11, <#[R1 - 16]> */
		/* 82094B64h case    6:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82094B64h case    6:*/		return 0x82094B68;
		  /* 82094B68h */ case    7:  		/* mr R11, R10 */
		/* 82094B68h case    7:*/		regs.R11 = regs.R10;
		/* 82094B68h case    7:*/		return 0x82094B6C;
		  /* 82094B6Ch */ case    8:  		/* addi R9, R10, -1022 */
		/* 82094B6Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0xFFFFFC02);
		/* 82094B6Ch case    8:*/		return 0x82094B70;
	}
	return 0x82094B70;
} // Block from 82094B4Ch-82094B70h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82094B70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094B70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094B70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094B70);
		  /* 82094B70h */ case    0:  		/* lfd FR1, <#[R1 - 16]> */
		/* 82094B70h case    0:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82094B70h case    0:*/		return 0x82094B74;
	}
	return 0x82094B74;
} // Block from 82094B70h-82094B74h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82094B74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094B74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094B74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094B74);
		  /* 82094B74h */ case    0:  		/* stw R9, <#[R4]> */
		/* 82094B74h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R4 + 0x00000000) );
		/* 82094B74h case    0:*/		return 0x82094B78;
		  /* 82094B78h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82094B78h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82094B78h case    1:*/		return 0x82094B7C;
	}
	return 0x82094B7C;
} // Block from 82094B74h-82094B7Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82094B7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094B7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094B7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094B7C);
		  /* 82094B7Ch */ case    0:  		/* nop */
		/* 82094B7Ch case    0:*/		cpu::op::nop();
		/* 82094B7Ch case    0:*/		return 0x82094B80;
	}
	return 0x82094B80;
} // Block from 82094B7Ch-82094B80h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82094B80h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094B80);
		  /* 82094B80h */ case    0:  		/* mfspr R12, LR */
		/* 82094B80h case    0:*/		regs.R12 = regs.LR;
		/* 82094B80h case    0:*/		return 0x82094B84;
		  /* 82094B84h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82094B84h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82094B84h case    1:*/		return 0x82094B88;
		  /* 82094B88h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82094B88h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82094B88h case    2:*/		return 0x82094B8C;
		  /* 82094B8Ch */ case    3:  		/* bl 20564 */
		/* 82094B8Ch case    3:*/		regs.LR = 0x82094B90; return 0x82099BE0;
		/* 82094B8Ch case    3:*/		return 0x82094B90;
		  /* 82094B90h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 82094B90h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82094B90h case    4:*/		return 0x82094B94;
		  /* 82094B94h */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 82094B94h case    5:*/		if ( regs.CR[0].eq ) { return 0x82094BA0;  }
		/* 82094B94h case    5:*/		return 0x82094B98;
		  /* 82094B98h */ case    6:  		/* li R3, 22 */
		/* 82094B98h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x16);
		/* 82094B98h case    6:*/		return 0x82094B9C;
		  /* 82094B9Ch */ case    7:  		/* bl 20572 */
		/* 82094B9Ch case    7:*/		regs.LR = 0x82094BA0; return 0x82099BF8;
		/* 82094B9Ch case    7:*/		return 0x82094BA0;
	}
	return 0x82094BA0;
} // Block from 82094B80h-82094BA0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82094BA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094BA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094BA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094BA0);
		  /* 82094BA0h */ case    0:  		/* lis R11, -32217 */
		/* 82094BA0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82094BA0h case    0:*/		return 0x82094BA4;
		  /* 82094BA4h */ case    1:  		/* lwz R11, <#[R11 + 7368]> */
		/* 82094BA4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00001CC8) );
		/* 82094BA4h case    1:*/		return 0x82094BA8;
	}
	return 0x82094BA8;
} // Block from 82094BA0h-82094BA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82094BA8h
// Function '_woutput_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094BA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094BA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094BA8);
		  /* 82094BA8h */ case    0:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 82094BA8h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 82094BA8h case    0:*/		return 0x82094BAC;
		  /* 82094BACh */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 82094BACh case    1:*/		if ( regs.CR[0].eq ) { return 0x82094BC4;  }
		/* 82094BACh case    1:*/		return 0x82094BB0;
		  /* 82094BB0h */ case    2:  		/* lis R4, 16384 */
		/* 82094BB0h case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x4000);
		/* 82094BB0h case    2:*/		return 0x82094BB4;
		  /* 82094BB4h */ case    3:  		/* li R5, 1 */
		/* 82094BB4h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82094BB4h case    3:*/		return 0x82094BB8;
		  /* 82094BB8h */ case    4:  		/* ori R4, R4, 21 */
		/* 82094BB8h case    4:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x15);
		/* 82094BB8h case    4:*/		return 0x82094BBC;
		  /* 82094BBCh */ case    5:  		/* li R3, 3 */
		/* 82094BBCh case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 82094BBCh case    5:*/		return 0x82094BC0;
		  /* 82094BC0h */ case    6:  		/* bl -4648 */
		/* 82094BC0h case    6:*/		regs.LR = 0x82094BC4; return 0x82093998;
		/* 82094BC0h case    6:*/		return 0x82094BC4;
	}
	return 0x82094BC4;
} // Block from 82094BA8h-82094BC4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82094BC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094BC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094BC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094BC4);
		  /* 82094BC4h */ case    0:  		/* li R3, 3 */
		/* 82094BC4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 82094BC4h case    0:*/		return 0x82094BC8;
		  /* 82094BC8h */ case    1:  		/* bl -7144 */
		/* 82094BC8h case    1:*/		regs.LR = 0x82094BCC; return 0x82092FE0;
		/* 82094BC8h case    1:*/		return 0x82094BCC;
		  /* 82094BCCh */ case    2:  		/* nop */
		/* 82094BCCh case    2:*/		cpu::op::nop();
		/* 82094BCCh case    2:*/		return 0x82094BD0;
	}
	return 0x82094BD0;
} // Block from 82094BC4h-82094BD0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82094BD0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094BD0);
		  /* 82094BD0h */ case    0:  		/* lis R10, -32217 */
		/* 82094BD0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 82094BD0h case    0:*/		return 0x82094BD4;
		  /* 82094BD4h */ case    1:  		/* and R11, R3, R4 */
		/* 82094BD4h case    1:*/		cpu::op::and<0>(regs,&regs.R11,regs.R3,regs.R4);
		/* 82094BD4h case    1:*/		return 0x82094BD8;
		  /* 82094BD8h */ case    2:  		/* lwz R3, <#[R10 + 7368]> */
		/* 82094BD8h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x00001CC8) );
		/* 82094BD8h case    2:*/		return 0x82094BDC;
		  /* 82094BDCh */ case    3:  		/* andc R9, R3, R4 */
		/* 82094BDCh case    3:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R3,regs.R4);
		/* 82094BDCh case    3:*/		return 0x82094BE0;
		  /* 82094BE0h */ case    4:  		/* or R11, R9, R11 */
		/* 82094BE0h case    4:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82094BE0h case    4:*/		return 0x82094BE4;
		  /* 82094BE4h */ case    5:  		/* stw R11, <#[R10 + 7368]> */
		/* 82094BE4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00001CC8) );
		/* 82094BE4h case    5:*/		return 0x82094BE8;
		  /* 82094BE8h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82094BE8h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82094BE8h case    6:*/		return 0x82094BEC;
	}
	return 0x82094BEC;
} // Block from 82094BD0h-82094BECh (7 instructions)

//////////////////////////////////////////////////////
// Block at 82094BECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094BEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094BEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094BEC);
		  /* 82094BECh */ case    0:  		/* nop */
		/* 82094BECh case    0:*/		cpu::op::nop();
		/* 82094BECh case    0:*/		return 0x82094BF0;
		  /* 82094BF0h */ case    1:  		/* lis R10, -32255 */
		/* 82094BF0h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 82094BF0h case    1:*/		return 0x82094BF4;
		  /* 82094BF4h */ case    2:  		/* li R11, 0 */
		/* 82094BF4h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82094BF4h case    2:*/		return 0x82094BF8;
		  /* 82094BF8h */ case    3:  		/* addi R9, R10, -22344 */
		/* 82094BF8h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0xFFFFA8B8);
		/* 82094BF8h case    3:*/		return 0x82094BFC;
		  /* 82094BFCh */ case    4:  		/* mr R10, R9 */
		/* 82094BFCh case    4:*/		regs.R10 = regs.R9;
		/* 82094BFCh case    4:*/		return 0x82094C00;
		  /* 82094C00h */ case    5:  		/* lwz R8, <#[R10]> */
		/* 82094C00h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82094C00h case    5:*/		return 0x82094C04;
		  /* 82094C04h */ case    6:  		/* cmpw CR6, R3, R8 */
		/* 82094C04h case    6:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R8);
		/* 82094C04h case    6:*/		return 0x82094C08;
		  /* 82094C08h */ case    7:  		/* bc 12, CR6_EQ, 28 */
		/* 82094C08h case    7:*/		if ( regs.CR[6].eq ) { return 0x82094C24;  }
		/* 82094C08h case    7:*/		return 0x82094C0C;
		  /* 82094C0Ch */ case    8:  		/* addi R11, R11, 1 */
		/* 82094C0Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82094C0Ch case    8:*/		return 0x82094C10;
		  /* 82094C10h */ case    9:  		/* addi R10, R10, 8 */
		/* 82094C10h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x8);
		/* 82094C10h case    9:*/		return 0x82094C14;
		  /* 82094C14h */ case   10:  		/* cmplwi CR6, R11, 22 */
		/* 82094C14h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000016);
		/* 82094C14h case   10:*/		return 0x82094C18;
		  /* 82094C18h */ case   11:  		/* bc 12, CR6_LT, -24 */
		/* 82094C18h case   11:*/		if ( regs.CR[6].lt ) { return 0x82094C00;  }
		/* 82094C18h case   11:*/		return 0x82094C1C;
		  /* 82094C1Ch */ case   12:  		/* li R3, 0 */
		/* 82094C1Ch case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82094C1Ch case   12:*/		return 0x82094C20;
		  /* 82094C20h */ case   13:  		/* bclr 20, CR0_LT */
		/* 82094C20h case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82094C20h case   13:*/		return 0x82094C24;
	}
	return 0x82094C24;
} // Block from 82094BECh-82094C24h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82094C24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094C24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094C24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094C24);
		  /* 82094C24h */ case    0:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 82094C24h case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 82094C24h case    0:*/		return 0x82094C28;
		  /* 82094C28h */ case    1:  		/* addi R10, R9, 4 */
		/* 82094C28h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x4);
		/* 82094C28h case    1:*/		return 0x82094C2C;
		  /* 82094C2Ch */ case    2:  		/* lwzx R3, <#[R11 + R10]> */
		/* 82094C2Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82094C2Ch case    2:*/		return 0x82094C30;
		  /* 82094C30h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82094C30h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82094C30h case    3:*/		return 0x82094C34;
	}
	return 0x82094C34;
} // Block from 82094C24h-82094C34h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82094C34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094C34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094C34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094C34);
		  /* 82094C34h */ case    0:  		/* nop */
		/* 82094C34h case    0:*/		cpu::op::nop();
		/* 82094C34h case    0:*/		return 0x82094C38;
	}
	return 0x82094C38;
} // Block from 82094C34h-82094C38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82094C38h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094C38);
		  /* 82094C38h */ case    0:  		/* mfspr R12, LR */
		/* 82094C38h case    0:*/		regs.R12 = regs.LR;
		/* 82094C38h case    0:*/		return 0x82094C3C;
		  /* 82094C3Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82094C3Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82094C3Ch case    1:*/		return 0x82094C40;
		  /* 82094C40h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82094C40h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82094C40h case    2:*/		return 0x82094C44;
		  /* 82094C44h */ case    3:  		/* bl -84 */
		/* 82094C44h case    3:*/		regs.LR = 0x82094C48; return 0x82094BF0;
		/* 82094C44h case    3:*/		return 0x82094C48;
		  /* 82094C48h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 82094C48h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82094C48h case    4:*/		return 0x82094C4C;
		  /* 82094C4Ch */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 82094C4Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x82094C54;  }
		/* 82094C4Ch case    5:*/		return 0x82094C50;
		  /* 82094C50h */ case    6:  		/* bl 1910760 */
		/* 82094C50h case    6:*/		regs.LR = 0x82094C54; return 0x82267438;
		/* 82094C50h case    6:*/		return 0x82094C54;
	}
	return 0x82094C54;
} // Block from 82094C38h-82094C54h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82094C54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094C54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094C54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094C54);
		  /* 82094C54h */ case    0:  		/* addi R1, R1, 96 */
		/* 82094C54h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82094C54h case    0:*/		return 0x82094C58;
		  /* 82094C58h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82094C58h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82094C58h case    1:*/		return 0x82094C5C;
		  /* 82094C5Ch */ case    2:  		/* mtspr LR, R12 */
		/* 82094C5Ch case    2:*/		regs.LR = regs.R12;
		/* 82094C5Ch case    2:*/		return 0x82094C60;
		  /* 82094C60h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82094C60h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82094C60h case    3:*/		return 0x82094C64;
	}
	return 0x82094C64;
} // Block from 82094C54h-82094C64h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82094C64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094C64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094C64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094C64);
		  /* 82094C64h */ case    0:  		/* nop */
		/* 82094C64h case    0:*/		cpu::op::nop();
		/* 82094C64h case    0:*/		return 0x82094C68;
	}
	return 0x82094C68;
} // Block from 82094C64h-82094C68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82094C68h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094C68);
		  /* 82094C68h */ case    0:  		/* mfspr R12, LR */
		/* 82094C68h case    0:*/		regs.R12 = regs.LR;
		/* 82094C68h case    0:*/		return 0x82094C6C;
		  /* 82094C6Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82094C6Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82094C6Ch case    1:*/		return 0x82094C70;
		  /* 82094C70h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82094C70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82094C70h case    2:*/		return 0x82094C74;
		  /* 82094C74h */ case    3:  		/* li R3, 252 */
		/* 82094C74h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0xFC);
		/* 82094C74h case    3:*/		return 0x82094C78;
		  /* 82094C78h */ case    4:  		/* bl -136 */
		/* 82094C78h case    4:*/		regs.LR = 0x82094C7C; return 0x82094BF0;
		/* 82094C78h case    4:*/		return 0x82094C7C;
		  /* 82094C7Ch */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 82094C7Ch case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82094C7Ch case    5:*/		return 0x82094C80;
		  /* 82094C80h */ case    6:  		/* bc 12, CR0_EQ, 8 */
		/* 82094C80h case    6:*/		if ( regs.CR[0].eq ) { return 0x82094C88;  }
		/* 82094C80h case    6:*/		return 0x82094C84;
		  /* 82094C84h */ case    7:  		/* bl 1910708 */
		/* 82094C84h case    7:*/		regs.LR = 0x82094C88; return 0x82267438;
		/* 82094C84h case    7:*/		return 0x82094C88;
	}
	return 0x82094C88;
} // Block from 82094C68h-82094C88h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82094C88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094C88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094C88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094C88);
		  /* 82094C88h */ case    0:  		/* li R3, 255 */
		/* 82094C88h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFF);
		/* 82094C88h case    0:*/		return 0x82094C8C;
		  /* 82094C8Ch */ case    1:  		/* bl -156 */
		/* 82094C8Ch case    1:*/		regs.LR = 0x82094C90; return 0x82094BF0;
		/* 82094C8Ch case    1:*/		return 0x82094C90;
		  /* 82094C90h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 82094C90h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82094C90h case    2:*/		return 0x82094C94;
		  /* 82094C94h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 82094C94h case    3:*/		if ( regs.CR[0].eq ) { return 0x82094C9C;  }
		/* 82094C94h case    3:*/		return 0x82094C98;
		  /* 82094C98h */ case    4:  		/* bl 1910688 */
		/* 82094C98h case    4:*/		regs.LR = 0x82094C9C; return 0x82267438;
		/* 82094C98h case    4:*/		return 0x82094C9C;
	}
	return 0x82094C9C;
} // Block from 82094C88h-82094C9Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82094C9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094C9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094C9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094C9C);
		  /* 82094C9Ch */ case    0:  		/* addi R1, R1, 96 */
		/* 82094C9Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82094C9Ch case    0:*/		return 0x82094CA0;
		  /* 82094CA0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82094CA0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82094CA0h case    1:*/		return 0x82094CA4;
		  /* 82094CA4h */ case    2:  		/* mtspr LR, R12 */
		/* 82094CA4h case    2:*/		regs.LR = regs.R12;
		/* 82094CA4h case    2:*/		return 0x82094CA8;
		  /* 82094CA8h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82094CA8h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82094CA8h case    3:*/		return 0x82094CAC;
	}
	return 0x82094CAC;
} // Block from 82094C9Ch-82094CACh (4 instructions)

//////////////////////////////////////////////////////
// Block at 82094CACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094CAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094CAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094CAC);
		  /* 82094CACh */ case    0:  		/* nop */
		/* 82094CACh case    0:*/		cpu::op::nop();
		/* 82094CACh case    0:*/		return 0x82094CB0;
	}
	return 0x82094CB0;
} // Block from 82094CACh-82094CB0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82094CB0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094CB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094CB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094CB0);
		  /* 82094CB0h */ case    0:  		/* lis R11, -32215 */
		/* 82094CB0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82094CB0h case    0:*/		return 0x82094CB4;
		  /* 82094CB4h */ case    1:  		/* stw R3, <#[R11 - 30688]> */
		/* 82094CB4h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0xFFFF8820) );
		/* 82094CB4h case    1:*/		return 0x82094CB8;
		  /* 82094CB8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82094CB8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82094CB8h case    2:*/		return 0x82094CBC;
	}
	return 0x82094CBC;
} // Block from 82094CB0h-82094CBCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82094CBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094CBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094CBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094CBC);
		  /* 82094CBCh */ case    0:  		/* nop */
		/* 82094CBCh case    0:*/		cpu::op::nop();
		/* 82094CBCh case    0:*/		return 0x82094CC0;
	}
	return 0x82094CC0;
} // Block from 82094CBCh-82094CC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82094CC0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094CC0);
		  /* 82094CC0h */ case    0:  		/* mfspr R12, LR */
		/* 82094CC0h case    0:*/		regs.R12 = regs.LR;
		/* 82094CC0h case    0:*/		return 0x82094CC4;
		  /* 82094CC4h */ case    1:  		/* bl -14956 */
		/* 82094CC4h case    1:*/		regs.LR = 0x82094CC8; return 0x82091258;
		/* 82094CC4h case    1:*/		return 0x82094CC8;
		  /* 82094CC8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82094CC8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82094CC8h case    2:*/		return 0x82094CCC;
		  /* 82094CCCh */ case    3:  		/* stw R3, <#[R1 + 148]> */
		/* 82094CCCh case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000094) );
		/* 82094CCCh case    3:*/		return 0x82094CD0;
		  /* 82094CD0h */ case    4:  		/* mr R3, R4 */
		/* 82094CD0h case    4:*/		regs.R3 = regs.R4;
		/* 82094CD0h case    4:*/		return 0x82094CD4;
		  /* 82094CD4h */ case    5:  		/* mr R31, R4 */
		/* 82094CD4h case    5:*/		regs.R31 = regs.R4;
		/* 82094CD4h case    5:*/		return 0x82094CD8;
		  /* 82094CD8h */ case    6:  		/* bl 23720 */
		/* 82094CD8h case    6:*/		regs.LR = 0x82094CDC; return 0x8209A980;
		/* 82094CD8h case    6:*/		return 0x82094CDC;
		  /* 82094CDCh */ case    7:  		/* lwz R11, <#[R31 + 12]> */
		/* 82094CDCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82094CDCh case    7:*/		return 0x82094CE0;
		  /* 82094CE0h */ case    8:  		/* mr R29, R3 */
		/* 82094CE0h case    8:*/		regs.R29 = regs.R3;
		/* 82094CE0h case    8:*/		return 0x82094CE4;
		  /* 82094CE4h */ case    9:  		/* andi. R10, R11, 130 */
		/* 82094CE4h case    9:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0x82);
		/* 82094CE4h case    9:*/		return 0x82094CE8;
		  /* 82094CE8h */ case   10:  		/* cmpwi CR0, R10, 0 */
		/* 82094CE8h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R10,0x00000000);
		/* 82094CE8h case   10:*/		return 0x82094CEC;
		  /* 82094CECh */ case   11:  		/* bc 4, CR0_EQ, 40 */
		/* 82094CECh case   11:*/		if ( !regs.CR[0].eq ) { return 0x82094D14;  }
		/* 82094CECh case   11:*/		return 0x82094CF0;
		  /* 82094CF0h */ case   12:  		/* bl 536 */
		/* 82094CF0h case   12:*/		regs.LR = 0x82094CF4; return 0x82094F08;
		/* 82094CF0h case   12:*/		return 0x82094CF4;
		  /* 82094CF4h */ case   13:  		/* li R10, 9 */
		/* 82094CF4h case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x9);
		/* 82094CF4h case   13:*/		return 0x82094CF8;
		  /* 82094CF8h */ case   14:  		/* mr R11, R3 */
		/* 82094CF8h case   14:*/		regs.R11 = regs.R3;
		/* 82094CF8h case   14:*/		return 0x82094CFC;
		  /* 82094CFCh */ case   15:  		/* stw R10, <#[R3]> */
		/* 82094CFCh case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82094CFCh case   15:*/		return 0x82094D00;
		  /* 82094D00h */ case   16:  		/* lwz R11, <#[R31 + 12]> */
		/* 82094D00h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82094D00h case   16:*/		return 0x82094D04;
		  /* 82094D04h */ case   17:  		/* ori R11, R11, 32 */
		/* 82094D04h case   17:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x20);
		/* 82094D04h case   17:*/		return 0x82094D08;
		  /* 82094D08h */ case   18:  		/* li R3, -1 */
		/* 82094D08h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82094D08h case   18:*/		return 0x82094D0C;
		  /* 82094D0Ch */ case   19:  		/* stw R11, <#[R31 + 12]> */
		/* 82094D0Ch case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82094D0Ch case   19:*/		return 0x82094D10;
		  /* 82094D10h */ case   20:  		/* b 380 */
		/* 82094D10h case   20:*/		return 0x82094E8C;
		/* 82094D10h case   20:*/		return 0x82094D14;
	}
	return 0x82094D14;
} // Block from 82094CC0h-82094D14h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82094D14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094D14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094D14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094D14);
		  /* 82094D14h */ case    0:  		/* rlwinm. R10, R11, 0, 25, 25 */
		/* 82094D14h case    0:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R11);
		/* 82094D14h case    0:*/		return 0x82094D18;
		  /* 82094D18h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82094D18h case    1:*/		if ( regs.CR[0].eq ) { return 0x82094D28;  }
		/* 82094D18h case    1:*/		return 0x82094D1C;
		  /* 82094D1Ch */ case    2:  		/* bl 492 */
		/* 82094D1Ch case    2:*/		regs.LR = 0x82094D20; return 0x82094F08;
		/* 82094D1Ch case    2:*/		return 0x82094D20;
		  /* 82094D20h */ case    3:  		/* li R10, 34 */
		/* 82094D20h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x22);
		/* 82094D20h case    3:*/		return 0x82094D24;
		  /* 82094D24h */ case    4:  		/* b -44 */
		/* 82094D24h case    4:*/		return 0x82094CF8;
		/* 82094D24h case    4:*/		return 0x82094D28;
	}
	return 0x82094D28;
} // Block from 82094D14h-82094D28h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82094D28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094D28);
		  /* 82094D28h */ case    0:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 82094D28h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 82094D28h case    0:*/		return 0x82094D2C;
		  /* 82094D2Ch */ case    1:  		/* li R10, 0 */
		/* 82094D2Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82094D2Ch case    1:*/		return 0x82094D30;
		  /* 82094D30h */ case    2:  		/* bc 12, CR0_EQ, 32 */
		/* 82094D30h case    2:*/		if ( regs.CR[0].eq ) { return 0x82094D50;  }
		/* 82094D30h case    2:*/		return 0x82094D34;
		  /* 82094D34h */ case    3:  		/* rlwinm. R9, R11, 0, 27, 27 */
		/* 82094D34h case    3:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R9,regs.R11);
		/* 82094D34h case    3:*/		return 0x82094D38;
		  /* 82094D38h */ case    4:  		/* stw R10, <#[R31 + 4]> */
		/* 82094D38h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82094D38h case    4:*/		return 0x82094D3C;
		  /* 82094D3Ch */ case    5:  		/* bc 12, CR0_EQ, -56 */
		/* 82094D3Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x82094D04;  }
		/* 82094D3Ch case    5:*/		return 0x82094D40;
		  /* 82094D40h */ case    6:  		/* lwz R9, <#[R31 + 8]> */
		/* 82094D40h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82094D40h case    6:*/		return 0x82094D44;
		  /* 82094D44h */ case    7:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82094D44h case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82094D44h case    7:*/		return 0x82094D48;
		  /* 82094D48h */ case    8:  		/* stw R11, <#[R31 + 12]> */
		/* 82094D48h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82094D48h case    8:*/		return 0x82094D4C;
		  /* 82094D4Ch */ case    9:  		/* stw R9, <#[R31]> */
		/* 82094D4Ch case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82094D4Ch case    9:*/		return 0x82094D50;
	}
	return 0x82094D50;
} // Block from 82094D28h-82094D50h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82094D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094D50);
		  /* 82094D50h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82094D50h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82094D50h case    0:*/		return 0x82094D54;
		  /* 82094D54h */ case    1:  		/* mr R28, R10 */
		/* 82094D54h case    1:*/		regs.R28 = regs.R10;
		/* 82094D54h case    1:*/		return 0x82094D58;
		  /* 82094D58h */ case    2:  		/* stw R10, <#[R31 + 4]> */
		/* 82094D58h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82094D58h case    2:*/		return 0x82094D5C;
		  /* 82094D5Ch */ case    3:  		/* rlwinm R11, R11, 0, 28, 26 */
		/* 82094D5Ch case    3:*/		cpu::op::rlwinm<0,0,28,26>(regs,&regs.R11,regs.R11);
		/* 82094D5Ch case    3:*/		return 0x82094D60;
		  /* 82094D60h */ case    4:  		/* ori R11, R11, 2 */
		/* 82094D60h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82094D60h case    4:*/		return 0x82094D64;
		  /* 82094D64h */ case    5:  		/* andi. R10, R11, 268 */
		/* 82094D64h case    5:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0x10C);
		/* 82094D64h case    5:*/		return 0x82094D68;
		  /* 82094D68h */ case    6:  		/* stw R11, <#[R31 + 12]> */
		/* 82094D68h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82094D68h case    6:*/		return 0x82094D6C;
		  /* 82094D6Ch */ case    7:  		/* cmpwi CR0, R10, 0 */
		/* 82094D6Ch case    7:*/		cpu::op::cmpwi<0>(regs,regs.R10,0x00000000);
		/* 82094D6Ch case    7:*/		return 0x82094D70;
		  /* 82094D70h */ case    8:  		/* bc 4, CR0_EQ, 60 */
		/* 82094D70h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82094DAC;  }
		/* 82094D70h case    8:*/		return 0x82094D74;
		  /* 82094D74h */ case    9:  		/* bl 22892 */
		/* 82094D74h case    9:*/		regs.LR = 0x82094D78; return 0x8209A6E0;
		/* 82094D74h case    9:*/		return 0x82094D78;
		  /* 82094D78h */ case   10:  		/* addi R11, R3, 32 */
		/* 82094D78h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x20);
		/* 82094D78h case   10:*/		return 0x82094D7C;
		  /* 82094D7Ch */ case   11:  		/* cmplw CR6, R31, R11 */
		/* 82094D7Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82094D7Ch case   11:*/		return 0x82094D80;
		  /* 82094D80h */ case   12:  		/* bc 12, CR6_EQ, 20 */
		/* 82094D80h case   12:*/		if ( regs.CR[6].eq ) { return 0x82094D94;  }
		/* 82094D80h case   12:*/		return 0x82094D84;
		  /* 82094D84h */ case   13:  		/* bl 22876 */
		/* 82094D84h case   13:*/		regs.LR = 0x82094D88; return 0x8209A6E0;
		/* 82094D84h case   13:*/		return 0x82094D88;
		  /* 82094D88h */ case   14:  		/* addi R11, R3, 64 */
		/* 82094D88h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x40);
		/* 82094D88h case   14:*/		return 0x82094D8C;
		  /* 82094D8Ch */ case   15:  		/* cmplw CR6, R31, R11 */
		/* 82094D8Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82094D8Ch case   15:*/		return 0x82094D90;
		  /* 82094D90h */ case   16:  		/* bc 4, CR6_EQ, 20 */
		/* 82094D90h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82094DA4;  }
		/* 82094D90h case   16:*/		return 0x82094D94;
	}
	return 0x82094D94;
} // Block from 82094D50h-82094D94h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82094D94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094D94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094D94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094D94);
		  /* 82094D94h */ case    0:  		/* mr R3, R29 */
		/* 82094D94h case    0:*/		regs.R3 = regs.R29;
		/* 82094D94h case    0:*/		return 0x82094D98;
		  /* 82094D98h */ case    1:  		/* bl 1855336 */
		/* 82094D98h case    1:*/		regs.LR = 0x82094D9C; return 0x82259D00;
		/* 82094D98h case    1:*/		return 0x82094D9C;
		  /* 82094D9Ch */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 82094D9Ch case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82094D9Ch case    2:*/		return 0x82094DA0;
		  /* 82094DA0h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 82094DA0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82094DAC;  }
		/* 82094DA0h case    3:*/		return 0x82094DA4;
	}
	return 0x82094DA4;
} // Block from 82094D94h-82094DA4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82094DA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094DA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094DA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094DA4);
		  /* 82094DA4h */ case    0:  		/* mr R3, R31 */
		/* 82094DA4h case    0:*/		regs.R3 = regs.R31;
		/* 82094DA4h case    0:*/		return 0x82094DA8;
		  /* 82094DA8h */ case    1:  		/* bl 22704 */
		/* 82094DA8h case    1:*/		regs.LR = 0x82094DAC; return 0x8209A658;
		/* 82094DA8h case    1:*/		return 0x82094DAC;
	}
	return 0x82094DAC;
} // Block from 82094DA4h-82094DACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82094DACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094DAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094DAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094DAC);
		  /* 82094DACh */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82094DACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82094DACh case    0:*/		return 0x82094DB0;
		  /* 82094DB0h */ case    1:  		/* andi. R11, R11, 264 */
		/* 82094DB0h case    1:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x108);
		/* 82094DB0h case    1:*/		return 0x82094DB4;
		  /* 82094DB4h */ case    2:  		/* cmpwi CR0, R11, 0 */
		/* 82094DB4h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 82094DB4h case    2:*/		return 0x82094DB8;
		  /* 82094DB8h */ case    3:  		/* bc 12, CR0_EQ, 172 */
		/* 82094DB8h case    3:*/		if ( regs.CR[0].eq ) { return 0x82094E64;  }
		/* 82094DB8h case    3:*/		return 0x82094DBC;
		  /* 82094DBCh */ case    4:  		/* lwz R10, <#[R31]> */
		/* 82094DBCh case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82094DBCh case    4:*/		return 0x82094DC0;
		  /* 82094DC0h */ case    5:  		/* lwz R4, <#[R31 + 8]> */
		/* 82094DC0h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 82094DC0h case    5:*/		return 0x82094DC4;
		  /* 82094DC4h */ case    6:  		/* lwz R11, <#[R31 + 24]> */
		/* 82094DC4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82094DC4h case    6:*/		return 0x82094DC8;
		  /* 82094DC8h */ case    7:  		/* subf. R30, R4, R10 */
		/* 82094DC8h case    7:*/		cpu::op::subf<1>(regs,&regs.R30,regs.R4,regs.R10);
		/* 82094DC8h case    7:*/		return 0x82094DCC;
		  /* 82094DCCh */ case    8:  		/* addi R11, R11, -1 */
		/* 82094DCCh case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82094DCCh case    8:*/		return 0x82094DD0;
		  /* 82094DD0h */ case    9:  		/* addi R10, R4, 1 */
		/* 82094DD0h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x1);
		/* 82094DD0h case    9:*/		return 0x82094DD4;
		  /* 82094DD4h */ case   10:  		/* stw R11, <#[R31 + 4]> */
		/* 82094DD4h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82094DD4h case   10:*/		return 0x82094DD8;
		  /* 82094DD8h */ case   11:  		/* stw R10, <#[R31]> */
		/* 82094DD8h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82094DD8h case   11:*/		return 0x82094DDC;
		  /* 82094DDCh */ case   12:  		/* bc 4, CR0_GT, 24 */
		/* 82094DDCh case   12:*/		if ( !regs.CR[0].gt ) { return 0x82094DF4;  }
		/* 82094DDCh case   12:*/		return 0x82094DE0;
		  /* 82094DE0h */ case   13:  		/* mr R5, R30 */
		/* 82094DE0h case   13:*/		regs.R5 = regs.R30;
		/* 82094DE0h case   13:*/		return 0x82094DE4;
		  /* 82094DE4h */ case   14:  		/* mr R3, R29 */
		/* 82094DE4h case   14:*/		regs.R3 = regs.R29;
		/* 82094DE4h case   14:*/		return 0x82094DE8;
		  /* 82094DE8h */ case   15:  		/* bl 22256 */
		/* 82094DE8h case   15:*/		regs.LR = 0x82094DEC; return 0x8209A4D8;
		/* 82094DE8h case   15:*/		return 0x82094DEC;
		  /* 82094DECh */ case   16:  		/* mr R28, R3 */
		/* 82094DECh case   16:*/		regs.R28 = regs.R3;
		/* 82094DECh case   16:*/		return 0x82094DF0;
		  /* 82094DF0h */ case   17:  		/* b 100 */
		/* 82094DF0h case   17:*/		return 0x82094E54;
		/* 82094DF0h case   17:*/		return 0x82094DF4;
	}
	return 0x82094DF4;
} // Block from 82094DACh-82094DF4h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82094DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094DF4);
		  /* 82094DF4h */ case    0:  		/* cmpwi CR6, R29, -1 */
		/* 82094DF4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFF);
		/* 82094DF4h case    0:*/		return 0x82094DF8;
		  /* 82094DF8h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 82094DF8h case    1:*/		if ( regs.CR[6].eq ) { return 0x82094E28;  }
		/* 82094DF8h case    1:*/		return 0x82094DFC;
		  /* 82094DFCh */ case    2:  		/* cmpwi CR6, R29, -2 */
		/* 82094DFCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFE);
		/* 82094DFCh case    2:*/		return 0x82094E00;
		  /* 82094E00h */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 82094E00h case    3:*/		if ( regs.CR[6].eq ) { return 0x82094E28;  }
		/* 82094E00h case    3:*/		return 0x82094E04;
		  /* 82094E04h */ case    4:  		/* srawi R11, R29, 5 */
		/* 82094E04h case    4:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R29);
		/* 82094E04h case    4:*/		return 0x82094E08;
		  /* 82094E08h */ case    5:  		/* lis R10, -32215 */
		/* 82094E08h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 82094E08h case    5:*/		return 0x82094E0C;
		  /* 82094E0Ch */ case    6:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 82094E0Ch case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 82094E0Ch case    6:*/		return 0x82094E10;
		  /* 82094E10h */ case    7:  		/* addi R10, R10, -25504 */
		/* 82094E10h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFF9C60);
		/* 82094E10h case    7:*/		return 0x82094E14;
		  /* 82094E14h */ case    8:  		/* rlwinm R11, R29, 0, 27, 31 */
		/* 82094E14h case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R29);
		/* 82094E14h case    8:*/		return 0x82094E18;
		  /* 82094E18h */ case    9:  		/* mulli R11, R11, 72 */
		/* 82094E18h case    9:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x48);
		/* 82094E18h case    9:*/		return 0x82094E1C;
		  /* 82094E1Ch */ case   10:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82094E1Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82094E1Ch case   10:*/		return 0x82094E20;
		  /* 82094E20h */ case   11:  		/* add R11, R10, R11 */
		/* 82094E20h case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82094E20h case   11:*/		return 0x82094E24;
		  /* 82094E24h */ case   12:  		/* b 12 */
		/* 82094E24h case   12:*/		return 0x82094E30;
		/* 82094E24h case   12:*/		return 0x82094E28;
	}
	return 0x82094E28;
} // Block from 82094DF4h-82094E28h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82094E28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094E28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094E28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094E28);
		  /* 82094E28h */ case    0:  		/* lis R11, -32217 */
		/* 82094E28h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82094E28h case    0:*/		return 0x82094E2C;
		  /* 82094E2Ch */ case    1:  		/* addi R11, R11, 8872 */
		/* 82094E2Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x22A8);
		/* 82094E2Ch case    1:*/		return 0x82094E30;
	}
	return 0x82094E30;
} // Block from 82094E28h-82094E30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82094E30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094E30);
		  /* 82094E30h */ case    0:  		/* lbz R11, <#[R11 + 4]> */
		/* 82094E30h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82094E30h case    0:*/		return 0x82094E34;
		  /* 82094E34h */ case    1:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 82094E34h case    1:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 82094E34h case    1:*/		return 0x82094E38;
		  /* 82094E38h */ case    2:  		/* bc 12, CR0_EQ, 28 */
		/* 82094E38h case    2:*/		if ( regs.CR[0].eq ) { return 0x82094E54;  }
		/* 82094E38h case    2:*/		return 0x82094E3C;
		  /* 82094E3Ch */ case    3:  		/* li R5, 2 */
		/* 82094E3Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 82094E3Ch case    3:*/		return 0x82094E40;
		  /* 82094E40h */ case    4:  		/* li R4, 0 */
		/* 82094E40h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82094E40h case    4:*/		return 0x82094E44;
		  /* 82094E44h */ case    5:  		/* mr R3, R29 */
		/* 82094E44h case    5:*/		regs.R3 = regs.R29;
		/* 82094E44h case    5:*/		return 0x82094E48;
		  /* 82094E48h */ case    6:  		/* bl 20840 */
		/* 82094E48h case    6:*/		regs.LR = 0x82094E4C; return 0x82099FB0;
		/* 82094E48h case    6:*/		return 0x82094E4C;
		  /* 82094E4Ch */ case    7:  		/* cmpdi CR6, R3, -1 */
		/* 82094E4Ch case    7:*/		cpu::op::cmpdi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82094E4Ch case    7:*/		return 0x82094E50;
		  /* 82094E50h */ case    8:  		/* bc 12, CR6_EQ, -336 */
		/* 82094E50h case    8:*/		if ( regs.CR[6].eq ) { return 0x82094D00;  }
		/* 82094E50h case    8:*/		return 0x82094E54;
	}
	return 0x82094E54;
} // Block from 82094E30h-82094E54h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82094E54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094E54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094E54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094E54);
		  /* 82094E54h */ case    0:  		/* lwz R11, <#[R1 + 148]> */
		/* 82094E54h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000094) );
		/* 82094E54h case    0:*/		return 0x82094E58;
		  /* 82094E58h */ case    1:  		/* lwz R10, <#[R31 + 8]> */
		/* 82094E58h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82094E58h case    1:*/		return 0x82094E5C;
		  /* 82094E5Ch */ case    2:  		/* stb R11, <#[R10]> */
		/* 82094E5Ch case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82094E5Ch case    2:*/		return 0x82094E60;
		  /* 82094E60h */ case    3:  		/* b 28 */
		/* 82094E60h case    3:*/		return 0x82094E7C;
		/* 82094E60h case    3:*/		return 0x82094E64;
	}
	return 0x82094E64;
} // Block from 82094E54h-82094E64h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82094E64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094E64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094E64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094E64);
		  /* 82094E64h */ case    0:  		/* li R5, 1 */
		/* 82094E64h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82094E64h case    0:*/		return 0x82094E68;
		  /* 82094E68h */ case    1:  		/* addi R4, R1, 148 */
		/* 82094E68h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x94);
		/* 82094E68h case    1:*/		return 0x82094E6C;
		  /* 82094E6Ch */ case    2:  		/* mr R3, R29 */
		/* 82094E6Ch case    2:*/		regs.R3 = regs.R29;
		/* 82094E6Ch case    2:*/		return 0x82094E70;
		  /* 82094E70h */ case    3:  		/* li R30, 1 */
		/* 82094E70h case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82094E70h case    3:*/		return 0x82094E74;
		  /* 82094E74h */ case    4:  		/* bl 22116 */
		/* 82094E74h case    4:*/		regs.LR = 0x82094E78; return 0x8209A4D8;
		/* 82094E74h case    4:*/		return 0x82094E78;
		  /* 82094E78h */ case    5:  		/* mr R28, R3 */
		/* 82094E78h case    5:*/		regs.R28 = regs.R3;
		/* 82094E78h case    5:*/		return 0x82094E7C;
	}
	return 0x82094E7C;
} // Block from 82094E64h-82094E7Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82094E7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094E7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094E7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094E7C);
		  /* 82094E7Ch */ case    0:  		/* cmpw CR6, R28, R30 */
		/* 82094E7Ch case    0:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R30);
		/* 82094E7Ch case    0:*/		return 0x82094E80;
		  /* 82094E80h */ case    1:  		/* bc 4, CR6_EQ, -384 */
		/* 82094E80h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82094D00;  }
		/* 82094E80h case    1:*/		return 0x82094E84;
		  /* 82094E84h */ case    2:  		/* lwz R11, <#[R1 + 148]> */
		/* 82094E84h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000094) );
		/* 82094E84h case    2:*/		return 0x82094E88;
		  /* 82094E88h */ case    3:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 82094E88h case    3:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 82094E88h case    3:*/		return 0x82094E8C;
	}
	return 0x82094E8C;
} // Block from 82094E7Ch-82094E8Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82094E8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094E8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094E8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094E8C);
		  /* 82094E8Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 82094E8Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82094E8Ch case    0:*/		return 0x82094E90;
		  /* 82094E90h */ case    1:  		/* b -15336 */
		/* 82094E90h case    1:*/		return 0x820912A8;
		/* 82094E90h case    1:*/		return 0x82094E94;
		  /* 82094E94h */ case    2:  		/* nop */
		/* 82094E94h case    2:*/		cpu::op::nop();
		/* 82094E94h case    2:*/		return 0x82094E98;
	}
	return 0x82094E98;
} // Block from 82094E8Ch-82094E98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82094E98h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094E98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094E98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094E98);
		  /* 82094E98h */ case    0:  		/* lis R10, -32217 */
		/* 82094E98h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 82094E98h case    0:*/		return 0x82094E9C;
		  /* 82094E9Ch */ case    1:  		/* li R11, 0 */
		/* 82094E9Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82094E9Ch case    1:*/		return 0x82094EA0;
		  /* 82094EA0h */ case    2:  		/* addi R9, R10, 7376 */
		/* 82094EA0h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x1CD0);
		/* 82094EA0h case    2:*/		return 0x82094EA4;
		  /* 82094EA4h */ case    3:  		/* mr R10, R9 */
		/* 82094EA4h case    3:*/		regs.R10 = regs.R9;
		/* 82094EA4h case    3:*/		return 0x82094EA8;
		  /* 82094EA8h */ case    4:  		/* lwz R8, <#[R10]> */
		/* 82094EA8h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82094EA8h case    4:*/		return 0x82094EAC;
		  /* 82094EACh */ case    5:  		/* cmplw CR6, R3, R8 */
		/* 82094EACh case    5:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R8);
		/* 82094EACh case    5:*/		return 0x82094EB0;
		  /* 82094EB0h */ case    6:  		/* bc 12, CR6_EQ, 44 */
		/* 82094EB0h case    6:*/		if ( regs.CR[6].eq ) { return 0x82094EDC;  }
		/* 82094EB0h case    6:*/		return 0x82094EB4;
		  /* 82094EB4h */ case    7:  		/* addi R11, R11, 1 */
		/* 82094EB4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82094EB4h case    7:*/		return 0x82094EB8;
		  /* 82094EB8h */ case    8:  		/* addi R10, R10, 8 */
		/* 82094EB8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x8);
		/* 82094EB8h case    8:*/		return 0x82094EBC;
		  /* 82094EBCh */ case    9:  		/* cmplwi CR6, R11, 45 */
		/* 82094EBCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002D);
		/* 82094EBCh case    9:*/		return 0x82094EC0;
		  /* 82094EC0h */ case   10:  		/* bc 12, CR6_LT, -24 */
		/* 82094EC0h case   10:*/		if ( regs.CR[6].lt ) { return 0x82094EA8;  }
		/* 82094EC0h case   10:*/		return 0x82094EC4;
		  /* 82094EC4h */ case   11:  		/* cmplwi CR6, R3, 19 */
		/* 82094EC4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000013);
		/* 82094EC4h case   11:*/		return 0x82094EC8;
		  /* 82094EC8h */ case   12:  		/* bc 12, CR6_LT, 36 */
		/* 82094EC8h case   12:*/		if ( regs.CR[6].lt ) { return 0x82094EEC;  }
		/* 82094EC8h case   12:*/		return 0x82094ECC;
		  /* 82094ECCh */ case   13:  		/* cmplwi CR6, R3, 36 */
		/* 82094ECCh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000024);
		/* 82094ECCh case   13:*/		return 0x82094ED0;
		  /* 82094ED0h */ case   14:  		/* bc 12, CR6_GT, 28 */
		/* 82094ED0h case   14:*/		if ( regs.CR[6].gt ) { return 0x82094EEC;  }
		/* 82094ED0h case   14:*/		return 0x82094ED4;
		  /* 82094ED4h */ case   15:  		/* li R3, 13 */
		/* 82094ED4h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0xD);
		/* 82094ED4h case   15:*/		return 0x82094ED8;
		  /* 82094ED8h */ case   16:  		/* bclr 20, CR0_LT */
		/* 82094ED8h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82094ED8h case   16:*/		return 0x82094EDC;
	}
	return 0x82094EDC;
} // Block from 82094E98h-82094EDCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 82094EDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094EDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094EDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094EDC);
		  /* 82094EDCh */ case    0:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 82094EDCh case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 82094EDCh case    0:*/		return 0x82094EE0;
		  /* 82094EE0h */ case    1:  		/* addi R10, R9, 4 */
		/* 82094EE0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x4);
		/* 82094EE0h case    1:*/		return 0x82094EE4;
		  /* 82094EE4h */ case    2:  		/* lwzx R3, <#[R11 + R10]> */
		/* 82094EE4h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82094EE4h case    2:*/		return 0x82094EE8;
		  /* 82094EE8h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82094EE8h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82094EE8h case    3:*/		return 0x82094EEC;
	}
	return 0x82094EEC;
} // Block from 82094EDCh-82094EECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 82094EECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094EEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094EEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094EEC);
		  /* 82094EECh */ case    0:  		/* cmplwi CR6, R3, 188 */
		/* 82094EECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x000000BC);
		/* 82094EECh case    0:*/		return 0x82094EF0;
		  /* 82094EF0h */ case    1:  		/* bc 12, CR6_LT, 16 */
		/* 82094EF0h case    1:*/		if ( regs.CR[6].lt ) { return 0x82094F00;  }
		/* 82094EF0h case    1:*/		return 0x82094EF4;
		  /* 82094EF4h */ case    2:  		/* cmplwi CR6, R3, 202 */
		/* 82094EF4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x000000CA);
		/* 82094EF4h case    2:*/		return 0x82094EF8;
		  /* 82094EF8h */ case    3:  		/* li R3, 8 */
		/* 82094EF8h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x8);
		/* 82094EF8h case    3:*/		return 0x82094EFC;
		  /* 82094EFCh */ case    4:  		/* bclr 4, CR6_GT */
		/* 82094EFCh case    4:*/		if ( !regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 82094EFCh case    4:*/		return 0x82094F00;
	}
	return 0x82094F00;
} // Block from 82094EECh-82094F00h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82094F00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094F00);
		  /* 82094F00h */ case    0:  		/* li R3, 22 */
		/* 82094F00h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x16);
		/* 82094F00h case    0:*/		return 0x82094F04;
		  /* 82094F04h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82094F04h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82094F04h case    1:*/		return 0x82094F08;
	}
	return 0x82094F08;
} // Block from 82094F00h-82094F08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82094F08h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094F08);
		  /* 82094F08h */ case    0:  		/* mfspr R12, LR */
		/* 82094F08h case    0:*/		regs.R12 = regs.LR;
		/* 82094F08h case    0:*/		return 0x82094F0C;
		  /* 82094F0Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82094F0Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82094F0Ch case    1:*/		return 0x82094F10;
		  /* 82094F10h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82094F10h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82094F10h case    2:*/		return 0x82094F14;
		  /* 82094F14h */ case    3:  		/* bl -7836 */
		/* 82094F14h case    3:*/		regs.LR = 0x82094F18; return 0x82093078;
		/* 82094F14h case    3:*/		return 0x82094F18;
		  /* 82094F18h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 82094F18h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82094F18h case    4:*/		return 0x82094F1C;
		  /* 82094F1Ch */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 82094F1Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x82094F2C;  }
		/* 82094F1Ch case    5:*/		return 0x82094F20;
		  /* 82094F20h */ case    6:  		/* lis R11, -32217 */
		/* 82094F20h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82094F20h case    6:*/		return 0x82094F24;
		  /* 82094F24h */ case    7:  		/* addi R3, R11, 7736 */
		/* 82094F24h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1E38);
		/* 82094F24h case    7:*/		return 0x82094F28;
		  /* 82094F28h */ case    8:  		/* b 8 */
		/* 82094F28h case    8:*/		return 0x82094F30;
		/* 82094F28h case    8:*/		return 0x82094F2C;
	}
	return 0x82094F2C;
} // Block from 82094F08h-82094F2Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82094F2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094F2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094F2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094F2C);
		  /* 82094F2Ch */ case    0:  		/* addi R3, R3, 8 */
		/* 82094F2Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x8);
		/* 82094F2Ch case    0:*/		return 0x82094F30;
	}
	return 0x82094F30;
} // Block from 82094F2Ch-82094F30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82094F30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094F30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094F30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094F30);
		  /* 82094F30h */ case    0:  		/* addi R1, R1, 96 */
		/* 82094F30h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82094F30h case    0:*/		return 0x82094F34;
		  /* 82094F34h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82094F34h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82094F34h case    1:*/		return 0x82094F38;
		  /* 82094F38h */ case    2:  		/* mtspr LR, R12 */
		/* 82094F38h case    2:*/		regs.LR = regs.R12;
		/* 82094F38h case    2:*/		return 0x82094F3C;
		  /* 82094F3Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 82094F3Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82094F3Ch case    3:*/		return 0x82094F40;
	}
	return 0x82094F40;
} // Block from 82094F30h-82094F40h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82094F40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094F40);
		  /* 82094F40h */ case    0:  		/* mfspr R12, LR */
		/* 82094F40h case    0:*/		regs.R12 = regs.LR;
		/* 82094F40h case    0:*/		return 0x82094F44;
		  /* 82094F44h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82094F44h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82094F44h case    1:*/		return 0x82094F48;
		  /* 82094F48h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82094F48h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82094F48h case    2:*/		return 0x82094F4C;
		  /* 82094F4Ch */ case    3:  		/* bl -7892 */
		/* 82094F4Ch case    3:*/		regs.LR = 0x82094F50; return 0x82093078;
		/* 82094F4Ch case    3:*/		return 0x82094F50;
		  /* 82094F50h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 82094F50h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82094F50h case    4:*/		return 0x82094F54;
		  /* 82094F54h */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 82094F54h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82094F64;  }
		/* 82094F54h case    5:*/		return 0x82094F58;
		  /* 82094F58h */ case    6:  		/* lis R11, -32217 */
		/* 82094F58h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82094F58h case    6:*/		return 0x82094F5C;
		  /* 82094F5Ch */ case    7:  		/* addi R3, R11, 7740 */
		/* 82094F5Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1E3C);
		/* 82094F5Ch case    7:*/		return 0x82094F60;
		  /* 82094F60h */ case    8:  		/* b 8 */
		/* 82094F60h case    8:*/		return 0x82094F68;
		/* 82094F60h case    8:*/		return 0x82094F64;
	}
	return 0x82094F64;
} // Block from 82094F40h-82094F64h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82094F64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094F64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094F64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094F64);
		  /* 82094F64h */ case    0:  		/* addi R3, R3, 12 */
		/* 82094F64h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0xC);
		/* 82094F64h case    0:*/		return 0x82094F68;
	}
	return 0x82094F68;
} // Block from 82094F64h-82094F68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82094F68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094F68);
		  /* 82094F68h */ case    0:  		/* addi R1, R1, 96 */
		/* 82094F68h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82094F68h case    0:*/		return 0x82094F6C;
		  /* 82094F6Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82094F6Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82094F6Ch case    1:*/		return 0x82094F70;
		  /* 82094F70h */ case    2:  		/* mtspr LR, R12 */
		/* 82094F70h case    2:*/		regs.LR = regs.R12;
		/* 82094F70h case    2:*/		return 0x82094F74;
		  /* 82094F74h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82094F74h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82094F74h case    3:*/		return 0x82094F78;
	}
	return 0x82094F78;
} // Block from 82094F68h-82094F78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82094F78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094F78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094F78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094F78);
		  /* 82094F78h */ case    0:  		/* mfspr R12, LR */
		/* 82094F78h case    0:*/		regs.R12 = regs.LR;
		/* 82094F78h case    0:*/		return 0x82094F7C;
		  /* 82094F7Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82094F7Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82094F7Ch case    1:*/		return 0x82094F80;
		  /* 82094F80h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82094F80h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82094F80h case    2:*/		return 0x82094F84;
		  /* 82094F84h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82094F84h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82094F84h case    3:*/		return 0x82094F88;
		  /* 82094F88h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82094F88h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82094F88h case    4:*/		return 0x82094F8C;
		  /* 82094F8Ch */ case    5:  		/* mr R30, R3 */
		/* 82094F8Ch case    5:*/		regs.R30 = regs.R3;
		/* 82094F8Ch case    5:*/		return 0x82094F90;
		  /* 82094F90h */ case    6:  		/* bl -7960 */
		/* 82094F90h case    6:*/		regs.LR = 0x82094F94; return 0x82093078;
		/* 82094F90h case    6:*/		return 0x82094F94;
		  /* 82094F94h */ case    7:  		/* lis R11, -32217 */
		/* 82094F94h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82094F94h case    7:*/		return 0x82094F98;
		  /* 82094F98h */ case    8:  		/* cmplwi CR0, R3, 0 */
		/* 82094F98h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82094F98h case    8:*/		return 0x82094F9C;
		  /* 82094F9Ch */ case    9:  		/* addi R31, R11, 7736 */
		/* 82094F9Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x1E38);
		/* 82094F9Ch case    9:*/		return 0x82094FA0;
		  /* 82094FA0h */ case   10:  		/* addi R11, R31, 4 */
		/* 82094FA0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x4);
		/* 82094FA0h case   10:*/		return 0x82094FA4;
		  /* 82094FA4h */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 82094FA4h case   11:*/		if ( regs.CR[0].eq ) { return 0x82094FAC;  }
		/* 82094FA4h case   11:*/		return 0x82094FA8;
		  /* 82094FA8h */ case   12:  		/* addi R11, R3, 12 */
		/* 82094FA8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0xC);
		/* 82094FA8h case   12:*/		return 0x82094FAC;
	}
	return 0x82094FAC;
} // Block from 82094F78h-82094FACh (13 instructions)

//////////////////////////////////////////////////////
// Block at 82094FACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094FAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094FAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094FAC);
		  /* 82094FACh */ case    0:  		/* stw R30, <#[R11]> */
		/* 82094FACh case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 82094FACh case    0:*/		return 0x82094FB0;
		  /* 82094FB0h */ case    1:  		/* bl -7992 */
		/* 82094FB0h case    1:*/		regs.LR = 0x82094FB4; return 0x82093078;
		/* 82094FB0h case    1:*/		return 0x82094FB4;
		  /* 82094FB4h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 82094FB4h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82094FB4h case    2:*/		return 0x82094FB8;
		  /* 82094FB8h */ case    3:  		/* mr R7, R31 */
		/* 82094FB8h case    3:*/		regs.R7 = regs.R31;
		/* 82094FB8h case    3:*/		return 0x82094FBC;
		  /* 82094FBCh */ case    4:  		/* bc 12, CR0_EQ, 8 */
		/* 82094FBCh case    4:*/		if ( regs.CR[0].eq ) { return 0x82094FC4;  }
		/* 82094FBCh case    4:*/		return 0x82094FC0;
		  /* 82094FC0h */ case    5:  		/* addi R7, R3, 8 */
		/* 82094FC0h case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R3,0x8);
		/* 82094FC0h case    5:*/		return 0x82094FC4;
	}
	return 0x82094FC4;
} // Block from 82094FACh-82094FC4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82094FC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094FC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094FC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094FC4);
		  /* 82094FC4h */ case    0:  		/* mr R3, R30 */
		/* 82094FC4h case    0:*/		regs.R3 = regs.R30;
		/* 82094FC4h case    0:*/		return 0x82094FC8;
		  /* 82094FC8h */ case    1:  		/* bl -304 */
		/* 82094FC8h case    1:*/		regs.LR = 0x82094FCC; return 0x82094E98;
		/* 82094FC8h case    1:*/		return 0x82094FCC;
		  /* 82094FCCh */ case    2:  		/* stw R3, <#[R7]> */
		/* 82094FCCh case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R7 + 0x00000000) );
		/* 82094FCCh case    2:*/		return 0x82094FD0;
		  /* 82094FD0h */ case    3:  		/* addi R1, R1, 112 */
		/* 82094FD0h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82094FD0h case    3:*/		return 0x82094FD4;
		  /* 82094FD4h */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 82094FD4h case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82094FD4h case    4:*/		return 0x82094FD8;
		  /* 82094FD8h */ case    5:  		/* mtspr LR, R12 */
		/* 82094FD8h case    5:*/		regs.LR = regs.R12;
		/* 82094FD8h case    5:*/		return 0x82094FDC;
		  /* 82094FDCh */ case    6:  		/* ld R30, <#[R1 - 24]> */
		/* 82094FDCh case    6:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82094FDCh case    6:*/		return 0x82094FE0;
		  /* 82094FE0h */ case    7:  		/* ld R31, <#[R1 - 16]> */
		/* 82094FE0h case    7:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82094FE0h case    7:*/		return 0x82094FE4;
		  /* 82094FE4h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82094FE4h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82094FE4h case    8:*/		return 0x82094FE8;
	}
	return 0x82094FE8;
} // Block from 82094FC4h-82094FE8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82094FE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82094FE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82094FE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82094FE8);
		  /* 82094FE8h */ case    0:  		/* mfspr R12, LR */
		/* 82094FE8h case    0:*/		regs.R12 = regs.LR;
		/* 82094FE8h case    0:*/		return 0x82094FEC;
		  /* 82094FECh */ case    1:  		/* bl -15820 */
		/* 82094FECh case    1:*/		regs.LR = 0x82094FF0; return 0x82091220;
		/* 82094FECh case    1:*/		return 0x82094FF0;
		  /* 82094FF0h */ case    2:  		/* stwu R1, <#[R1 - 2336]> */
		/* 82094FF0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFF6E0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFF6E0);
		/* 82094FF0h case    2:*/		return 0x82094FF4;
		  /* 82094FF4h */ case    3:  		/* li R30, 0 */
		/* 82094FF4h case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82094FF4h case    3:*/		return 0x82094FF8;
		  /* 82094FF8h */ case    4:  		/* mr R16, R3 */
		/* 82094FF8h case    4:*/		regs.R16 = regs.R3;
		/* 82094FF8h case    4:*/		return 0x82094FFC;
		  /* 82094FFCh */ case    5:  		/* mr R17, R4 */
		/* 82094FFCh case    5:*/		regs.R17 = regs.R4;
		/* 82094FFCh case    5:*/		return 0x82095000;
		  /* 82095000h */ case    6:  		/* stw R30, <#[R1 + 100]> */
		/* 82095000h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000064) );
		/* 82095000h case    6:*/		return 0x82095004;
		  /* 82095004h */ case    7:  		/* mr R24, R6 */
		/* 82095004h case    7:*/		regs.R24 = regs.R6;
		/* 82095004h case    7:*/		return 0x82095008;
		  /* 82095008h */ case    8:  		/* stw R30, <#[R1 + 96]> */
		/* 82095008h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000060) );
		/* 82095008h case    8:*/		return 0x8209500C;
		  /* 8209500Ch */ case    9:  		/* cmplwi CR6, R3, 0 */
		/* 8209500Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209500Ch case    9:*/		return 0x82095010;
		  /* 82095010h */ case   10:  		/* mr R25, R30 */
		/* 82095010h case   10:*/		regs.R25 = regs.R30;
		/* 82095010h case   10:*/		return 0x82095014;
		  /* 82095014h */ case   11:  		/* mr R14, R30 */
		/* 82095014h case   11:*/		regs.R14 = regs.R30;
		/* 82095014h case   11:*/		return 0x82095018;
		  /* 82095018h */ case   12:  		/* mr R23, R30 */
		/* 82095018h case   12:*/		regs.R23 = regs.R30;
		/* 82095018h case   12:*/		return 0x8209501C;
		  /* 8209501Ch */ case   13:  		/* mr R15, R30 */
		/* 8209501Ch case   13:*/		regs.R15 = regs.R30;
		/* 8209501Ch case   13:*/		return 0x82095020;
		  /* 82095020h */ case   14:  		/* mr R20, R30 */
		/* 82095020h case   14:*/		regs.R20 = regs.R30;
		/* 82095020h case   14:*/		return 0x82095024;
		  /* 82095024h */ case   15:  		/* bc 4, CR6_EQ, 28 */
		/* 82095024h case   15:*/		if ( !regs.CR[6].eq ) { return 0x82095040;  }
		/* 82095024h case   15:*/		return 0x82095028;
		  /* 82095028h */ case   16:  		/* bl -288 */
		/* 82095028h case   16:*/		regs.LR = 0x8209502C; return 0x82094F08;
		/* 82095028h case   16:*/		return 0x8209502C;
		  /* 8209502Ch */ case   17:  		/* li R11, 22 */
		/* 8209502Ch case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 8209502Ch case   17:*/		return 0x82095030;
		  /* 82095030h */ case   18:  		/* stw R11, <#[R3]> */
		/* 82095030h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82095030h case   18:*/		return 0x82095034;
		  /* 82095034h */ case   19:  		/* bl -5844 */
		/* 82095034h case   19:*/		regs.LR = 0x82095038; return 0x82093960;
		/* 82095034h case   19:*/		return 0x82095038;
		  /* 82095038h */ case   20:  		/* li R3, -1 */
		/* 82095038h case   20:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82095038h case   20:*/		return 0x8209503C;
		  /* 8209503Ch */ case   21:  		/* b 2560 */
		/* 8209503Ch case   21:*/		return 0x82095A3C;
		/* 8209503Ch case   21:*/		return 0x82095040;
	}
	return 0x82095040;
} // Block from 82094FE8h-82095040h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82095040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095040);
		  /* 82095040h */ case    0:  		/* cmplwi CR6, R17, 0 */
		/* 82095040h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 82095040h case    0:*/		return 0x82095044;
		  /* 82095044h */ case    1:  		/* bc 12, CR6_EQ, -28 */
		/* 82095044h case    1:*/		if ( regs.CR[6].eq ) { return 0x82095028;  }
		/* 82095044h case    1:*/		return 0x82095048;
		  /* 82095048h */ case    2:  		/* bl 22168 */
		/* 82095048h case    2:*/		regs.LR = 0x8209504C; return 0x8209A6E0;
		/* 82095048h case    2:*/		return 0x8209504C;
		  /* 8209504Ch */ case    3:  		/* addi R11, R3, 32 */
		/* 8209504Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x20);
		/* 8209504Ch case    3:*/		return 0x82095050;
		  /* 82095050h */ case    4:  		/* cmplw CR6, R16, R11 */
		/* 82095050h case    4:*/		cpu::op::cmplw<6>(regs,regs.R16,regs.R11);
		/* 82095050h case    4:*/		return 0x82095054;
		  /* 82095054h */ case    5:  		/* bc 12, CR6_EQ, 2484 */
		/* 82095054h case    5:*/		if ( regs.CR[6].eq ) { return 0x82095A08;  }
		/* 82095054h case    5:*/		return 0x82095058;
		  /* 82095058h */ case    6:  		/* bl 22152 */
		/* 82095058h case    6:*/		regs.LR = 0x8209505C; return 0x8209A6E0;
		/* 82095058h case    6:*/		return 0x8209505C;
		  /* 8209505Ch */ case    7:  		/* addi R11, R3, 64 */
		/* 8209505Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x40);
		/* 8209505Ch case    7:*/		return 0x82095060;
		  /* 82095060h */ case    8:  		/* cmplw CR6, R16, R11 */
		/* 82095060h case    8:*/		cpu::op::cmplw<6>(regs,regs.R16,regs.R11);
		/* 82095060h case    8:*/		return 0x82095064;
		  /* 82095064h */ case    9:  		/* bc 12, CR6_EQ, 2468 */
		/* 82095064h case    9:*/		if ( regs.CR[6].eq ) { return 0x82095A08;  }
		/* 82095064h case    9:*/		return 0x82095068;
		  /* 82095068h */ case   10:  		/* lhz R29, <#[R17]> */
		/* 82095068h case   10:*/		cpu::mem::load16z( regs, &regs.R29, (uint32)(regs.R17 + 0x00000000) );
		/* 82095068h case   10:*/		return 0x8209506C;
		  /* 8209506Ch */ case   11:  		/* mr R21, R30 */
		/* 8209506Ch case   11:*/		regs.R21 = regs.R30;
		/* 8209506Ch case   11:*/		return 0x82095070;
		  /* 82095070h */ case   12:  		/* mr R26, R30 */
		/* 82095070h case   12:*/		regs.R26 = regs.R30;
		/* 82095070h case   12:*/		return 0x82095074;
		  /* 82095074h */ case   13:  		/* stw R30, <#[R1 + 112]> */
		/* 82095074h case   13:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000070) );
		/* 82095074h case   13:*/		return 0x82095078;
		  /* 82095078h */ case   14:  		/* or. R8, R29, R29 */
		/* 82095078h case   14:*/		cpu::op::or<1>(regs,&regs.R8,regs.R29,regs.R29);
		/* 82095078h case   14:*/		return 0x8209507C;
		  /* 8209507Ch */ case   15:  		/* stw R30, <#[R1 + 80]> */
		/* 8209507Ch case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 8209507Ch case   15:*/		return 0x82095080;
		  /* 82095080h */ case   16:  		/* mr R7, R30 */
		/* 82095080h case   16:*/		regs.R7 = regs.R30;
		/* 82095080h case   16:*/		return 0x82095084;
		  /* 82095084h */ case   17:  		/* bc 12, CR0_EQ, 2428 */
		/* 82095084h case   17:*/		if ( regs.CR[0].eq ) { return 0x82095A00;  }
		/* 82095084h case   17:*/		return 0x82095088;
		  /* 82095088h */ case   18:  		/* lis R10, -32217 */
		/* 82095088h case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 82095088h case   18:*/		return 0x8209508C;
		  /* 8209508Ch */ case   19:  		/* lwz R18, <#[R1 + 104]> */
		/* 8209508Ch case   19:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R1 + 0x00000068) );
		/* 8209508Ch case   19:*/		return 0x82095090;
		  /* 82095090h */ case   20:  		/* lis R9, -32255 */
		/* 82095090h case   20:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 82095090h case   20:*/		return 0x82095094;
		  /* 82095094h */ case   21:  		/* lwz R27, <#[R1 + 104]> */
		/* 82095094h case   21:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000068) );
		/* 82095094h case   21:*/		return 0x82095098;
		  /* 82095098h */ case   22:  		/* addi R19, R10, 7288 */
		/* 82095098h case   22:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R10,0x1C78);
		/* 82095098h case   22:*/		return 0x8209509C;
		  /* 8209509Ch */ case   23:  		/* lis R11, -32217 */
		/* 8209509Ch case   23:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 8209509Ch case   23:*/		return 0x820950A0;
		  /* 820950A0h */ case   24:  		/* addi R10, R9, -21800 */
		/* 820950A0h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFAAD8);
		/* 820950A0h case   24:*/		return 0x820950A4;
		  /* 820950A4h */ case   25:  		/* addi R22, R11, 8856 */
		/* 820950A4h case   25:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R11,0x2298);
		/* 820950A4h case   25:*/		return 0x820950A8;
		  /* 820950A8h */ case   26:  		/* stw R10, <#[R1 + 104]> */
		/* 820950A8h case   26:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000068) );
		/* 820950A8h case   26:*/		return 0x820950AC;
		  /* 820950ACh */ case   27:  		/* addi R17, R17, 2 */
		/* 820950ACh case   27:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x2);
		/* 820950ACh case   27:*/		return 0x820950B0;
		  /* 820950B0h */ case   28:  		/* cmpwi CR6, R21, 0 */
		/* 820950B0h case   28:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 820950B0h case   28:*/		return 0x820950B4;
		  /* 820950B4h */ case   29:  		/* bc 12, CR6_LT, 2380 */
		/* 820950B4h case   29:*/		if ( regs.CR[6].lt ) { return 0x82095A00;  }
		/* 820950B4h case   29:*/		return 0x820950B8;
		  /* 820950B8h */ case   30:  		/* cmplwi CR6, R8, 32 */
		/* 820950B8h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000020);
		/* 820950B8h case   30:*/		return 0x820950BC;
		  /* 820950BCh */ case   31:  		/* bc 12, CR6_LT, 28 */
		/* 820950BCh case   31:*/		if ( regs.CR[6].lt ) { return 0x820950D8;  }
		/* 820950BCh case   31:*/		return 0x820950C0;
		  /* 820950C0h */ case   32:  		/* cmplwi CR6, R8, 120 */
		/* 820950C0h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000078);
		/* 820950C0h case   32:*/		return 0x820950C4;
		  /* 820950C4h */ case   33:  		/* bc 12, CR6_GT, 20 */
		/* 820950C4h case   33:*/		if ( regs.CR[6].gt ) { return 0x820950D8;  }
		/* 820950C4h case   33:*/		return 0x820950C8;
		  /* 820950C8h */ case   34:  		/* add R11, R8, R10 */
		/* 820950C8h case   34:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R10);
		/* 820950C8h case   34:*/		return 0x820950CC;
		  /* 820950CCh */ case   35:  		/* lbz R11, <#[R11 - 32]> */
		/* 820950CCh case   35:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFE0) );
		/* 820950CCh case   35:*/		return 0x820950D0;
		  /* 820950D0h */ case   36:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 820950D0h case   36:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 820950D0h case   36:*/		return 0x820950D4;
		  /* 820950D4h */ case   37:  		/* b 8 */
		/* 820950D4h case   37:*/		return 0x820950DC;
		/* 820950D4h case   37:*/		return 0x820950D8;
	}
	return 0x820950D8;
} // Block from 82095040h-820950D8h (38 instructions)

//////////////////////////////////////////////////////
// Block at 820950D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820950D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820950D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820950D8);
		  /* 820950D8h */ case    0:  		/* mr R11, R30 */
		/* 820950D8h case    0:*/		regs.R11 = regs.R30;
		/* 820950D8h case    0:*/		return 0x820950DC;
	}
	return 0x820950DC;
} // Block from 820950D8h-820950DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820950DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820950DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820950DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820950DC);
		  /* 820950DCh */ case    0:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 820950DCh case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 820950DCh case    0:*/		return 0x820950E0;
		  /* 820950E0h */ case    1:  		/* add R11, R11, R7 */
		/* 820950E0h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 820950E0h case    1:*/		return 0x820950E4;
		  /* 820950E4h */ case    2:  		/* lbzx R11, <#[R11 + R10]> */
		/* 820950E4h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820950E4h case    2:*/		return 0x820950E8;
		  /* 820950E8h */ case    3:  		/* extsb R11, R11 */
		/* 820950E8h case    3:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820950E8h case    3:*/		return 0x820950EC;
		  /* 820950ECh */ case    4:  		/* srawi R11, R11, 4 */
		/* 820950ECh case    4:*/		cpu::op::srawi<0,4>(regs,&regs.R11,regs.R11);
		/* 820950ECh case    4:*/		return 0x820950F0;
		  /* 820950F0h */ case    5:  		/* stw R11, <#[R1 + 108]> */
		/* 820950F0h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 820950F0h case    5:*/		return 0x820950F4;
		  /* 820950F4h */ case    6:  		/* cmplwi CR6, R11, 7 */
		/* 820950F4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000007);
		/* 820950F4h case    6:*/		return 0x820950F8;
		  /* 820950F8h */ case    7:  		/* bc 12, CR6_GT, 2284 */
		/* 820950F8h case    7:*/		if ( regs.CR[6].gt ) { return 0x820959E4;  }
		/* 820950F8h case    7:*/		return 0x820950FC;
		  /* 820950FCh */ case    8:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820950FCh case    8:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820950FCh case    8:*/		return 0x82095100;
		  /* 82095100h */ case    9:  		/* mtspr CTR, R11 */
		/* 82095100h case    9:*/		regs.CTR = regs.R11;
		/* 82095100h case    9:*/		return 0x82095104;
		  /* 82095104h */ case   10:  		/* cmpwi CR6, R11, 0 */
		/* 82095104h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82095104h case   10:*/		return 0x82095108;
		  /* 82095108h */ case   11:  		/* bc 12, CR6_EQ, 472 */
		/* 82095108h case   11:*/		if ( regs.CR[6].eq ) { return 0x820952E0;  }
		/* 82095108h case   11:*/		return 0x8209510C;
		  /* 8209510Ch */ case   12:  		/* bc 18, CR0_LT, 28 */
		/* 8209510Ch case   12:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x82095128;  }
		/* 8209510Ch case   12:*/		return 0x82095110;
		  /* 82095110h */ case   13:  		/* bc 18, CR0_LT, 56 */
		/* 82095110h case   13:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x82095148;  }
		/* 82095110h case   13:*/		return 0x82095114;
		  /* 82095114h */ case   14:  		/* bc 18, CR0_LT, 132 */
		/* 82095114h case   14:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x82095198;  }
		/* 82095114h case   14:*/		return 0x82095118;
		  /* 82095118h */ case   15:  		/* bc 18, CR0_LT, 188 */
		/* 82095118h case   15:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x820951D4;  }
		/* 82095118h case   15:*/		return 0x8209511C;
		  /* 8209511Ch */ case   16:  		/* bc 18, CR0_LT, 192 */
		/* 8209511Ch case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x820951DC;  }
		/* 8209511Ch case   16:*/		return 0x82095120;
		  /* 82095120h */ case   17:  		/* bc 18, CR0_LT, 244 */
		/* 82095120h case   17:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x82095214;  }
		/* 82095120h case   17:*/		return 0x82095124;
		  /* 82095124h */ case   18:  		/* b 472 */
		/* 82095124h case   18:*/		return 0x820952FC;
		/* 82095124h case   18:*/		return 0x82095128;
	}
	return 0x82095128;
} // Block from 820950DCh-82095128h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82095128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095128);
		  /* 82095128h */ case    0:  		/* li R20, 0 */
		/* 82095128h case    0:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 82095128h case    0:*/		return 0x8209512C;
		  /* 8209512Ch */ case    1:  		/* li R23, -1 */
		/* 8209512Ch case    1:*/		cpu::op::li<0>(regs,&regs.R23,0xFFFFFFFF);
		/* 8209512Ch case    1:*/		return 0x82095130;
		  /* 82095130h */ case    2:  		/* mr R18, R20 */
		/* 82095130h case    2:*/		regs.R18 = regs.R20;
		/* 82095130h case    2:*/		return 0x82095134;
		  /* 82095134h */ case    3:  		/* stw R20, <#[R1 + 96]> */
		/* 82095134h case    3:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x00000060) );
		/* 82095134h case    3:*/		return 0x82095138;
		  /* 82095138h */ case    4:  		/* mr R14, R20 */
		/* 82095138h case    4:*/		regs.R14 = regs.R20;
		/* 82095138h case    4:*/		return 0x8209513C;
		  /* 8209513Ch */ case    5:  		/* mr R15, R20 */
		/* 8209513Ch case    5:*/		regs.R15 = regs.R20;
		/* 8209513Ch case    5:*/		return 0x82095140;
		  /* 82095140h */ case    6:  		/* mr R25, R20 */
		/* 82095140h case    6:*/		regs.R25 = regs.R20;
		/* 82095140h case    6:*/		return 0x82095144;
		  /* 82095144h */ case    7:  		/* b 2208 */
		/* 82095144h case    7:*/		return 0x820959E4;
		/* 82095144h case    7:*/		return 0x82095148;
	}
	return 0x82095148;
} // Block from 82095128h-82095148h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82095148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095148);
		  /* 82095148h */ case    0:  		/* cmpwi CR6, R8, 32 */
		/* 82095148h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000020);
		/* 82095148h case    0:*/		return 0x8209514C;
		  /* 8209514Ch */ case    1:  		/* bc 12, CR6_EQ, 68 */
		/* 8209514Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82095190;  }
		/* 8209514Ch case    1:*/		return 0x82095150;
		  /* 82095150h */ case    2:  		/* cmpwi CR6, R8, 35 */
		/* 82095150h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000023);
		/* 82095150h case    2:*/		return 0x82095154;
		  /* 82095154h */ case    3:  		/* bc 12, CR6_EQ, 52 */
		/* 82095154h case    3:*/		if ( regs.CR[6].eq ) { return 0x82095188;  }
		/* 82095154h case    3:*/		return 0x82095158;
		  /* 82095158h */ case    4:  		/* cmpwi CR6, R8, 43 */
		/* 82095158h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000002B);
		/* 82095158h case    4:*/		return 0x8209515C;
		  /* 8209515Ch */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 8209515Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82095180;  }
		/* 8209515Ch case    5:*/		return 0x82095160;
		  /* 82095160h */ case    6:  		/* cmpwi CR6, R8, 45 */
		/* 82095160h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000002D);
		/* 82095160h case    6:*/		return 0x82095164;
		  /* 82095164h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 82095164h case    7:*/		if ( regs.CR[6].eq ) { return 0x82095178;  }
		/* 82095164h case    7:*/		return 0x82095168;
		  /* 82095168h */ case    8:  		/* cmpwi CR6, R8, 48 */
		/* 82095168h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000030);
		/* 82095168h case    8:*/		return 0x8209516C;
		  /* 8209516Ch */ case    9:  		/* bc 4, CR6_EQ, 2168 */
		/* 8209516Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x820959E4;  }
		/* 8209516Ch case    9:*/		return 0x82095170;
		  /* 82095170h */ case   10:  		/* ori R25, R25, 8 */
		/* 82095170h case   10:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x8);
		/* 82095170h case   10:*/		return 0x82095174;
		  /* 82095174h */ case   11:  		/* b 2160 */
		/* 82095174h case   11:*/		return 0x820959E4;
		/* 82095174h case   11:*/		return 0x82095178;
	}
	return 0x82095178;
} // Block from 82095148h-82095178h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82095178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095178);
		  /* 82095178h */ case    0:  		/* ori R25, R25, 4 */
		/* 82095178h case    0:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x4);
		/* 82095178h case    0:*/		return 0x8209517C;
		  /* 8209517Ch */ case    1:  		/* b 2152 */
		/* 8209517Ch case    1:*/		return 0x820959E4;
		/* 8209517Ch case    1:*/		return 0x82095180;
	}
	return 0x82095180;
} // Block from 82095178h-82095180h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82095180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095180);
		  /* 82095180h */ case    0:  		/* ori R25, R25, 1 */
		/* 82095180h case    0:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x1);
		/* 82095180h case    0:*/		return 0x82095184;
		  /* 82095184h */ case    1:  		/* b 2144 */
		/* 82095184h case    1:*/		return 0x820959E4;
		/* 82095184h case    1:*/		return 0x82095188;
	}
	return 0x82095188;
} // Block from 82095180h-82095188h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82095188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095188);
		  /* 82095188h */ case    0:  		/* ori R25, R25, 128 */
		/* 82095188h case    0:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x80);
		/* 82095188h case    0:*/		return 0x8209518C;
		  /* 8209518Ch */ case    1:  		/* b 2136 */
		/* 8209518Ch case    1:*/		return 0x820959E4;
		/* 8209518Ch case    1:*/		return 0x82095190;
	}
	return 0x82095190;
} // Block from 82095188h-82095190h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82095190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095190);
		  /* 82095190h */ case    0:  		/* ori R25, R25, 2 */
		/* 82095190h case    0:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x2);
		/* 82095190h case    0:*/		return 0x82095194;
		  /* 82095194h */ case    1:  		/* b 2128 */
		/* 82095194h case    1:*/		return 0x820959E4;
		/* 82095194h case    1:*/		return 0x82095198;
	}
	return 0x82095198;
} // Block from 82095190h-82095198h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82095198h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095198);
		  /* 82095198h */ case    0:  		/* cmplwi CR6, R8, 42 */
		/* 82095198h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000002A);
		/* 82095198h case    0:*/		return 0x8209519C;
		  /* 8209519Ch */ case    1:  		/* bc 4, CR6_EQ, 40 */
		/* 8209519Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820951C4;  }
		/* 8209519Ch case    1:*/		return 0x820951A0;
		  /* 820951A0h */ case    2:  		/* addi R11, R24, 7 */
		/* 820951A0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x7);
		/* 820951A0h case    2:*/		return 0x820951A4;
		  /* 820951A4h */ case    3:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 820951A4h case    3:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 820951A4h case    3:*/		return 0x820951A8;
		  /* 820951A8h */ case    4:  		/* addi R24, R11, 8 */
		/* 820951A8h case    4:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x8);
		/* 820951A8h case    4:*/		return 0x820951AC;
		  /* 820951ACh */ case    5:  		/* lwz R14, <#[R11 + 4]> */
		/* 820951ACh case    5:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R11 + 0x00000004) );
		/* 820951ACh case    5:*/		return 0x820951B0;
		  /* 820951B0h */ case    6:  		/* cmpwi CR6, R14, 0 */
		/* 820951B0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 820951B0h case    6:*/		return 0x820951B4;
		  /* 820951B4h */ case    7:  		/* bc 4, CR6_LT, 2096 */
		/* 820951B4h case    7:*/		if ( !regs.CR[6].lt ) { return 0x820959E4;  }
		/* 820951B4h case    7:*/		return 0x820951B8;
		  /* 820951B8h */ case    8:  		/* ori R25, R25, 4 */
		/* 820951B8h case    8:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x4);
		/* 820951B8h case    8:*/		return 0x820951BC;
		  /* 820951BCh */ case    9:  		/* neg R14, R14 */
		/* 820951BCh case    9:*/		cpu::op::neg<0>(regs,&regs.R14,regs.R14);
		/* 820951BCh case    9:*/		return 0x820951C0;
		  /* 820951C0h */ case   10:  		/* b 2084 */
		/* 820951C0h case   10:*/		return 0x820959E4;
		/* 820951C0h case   10:*/		return 0x820951C4;
	}
	return 0x820951C4;
} // Block from 82095198h-820951C4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820951C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820951C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820951C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820951C4);
		  /* 820951C4h */ case    0:  		/* mulli R11, R14, 10 */
		/* 820951C4h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R14,0xA);
		/* 820951C4h case    0:*/		return 0x820951C8;
		  /* 820951C8h */ case    1:  		/* add R11, R11, R8 */
		/* 820951C8h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 820951C8h case    1:*/		return 0x820951CC;
		  /* 820951CCh */ case    2:  		/* addi R14, R11, -48 */
		/* 820951CCh case    2:*/		cpu::op::addi<0>(regs,&regs.R14,regs.R11,0xFFFFFFD0);
		/* 820951CCh case    2:*/		return 0x820951D0;
		  /* 820951D0h */ case    3:  		/* b 2068 */
		/* 820951D0h case    3:*/		return 0x820959E4;
		/* 820951D0h case    3:*/		return 0x820951D4;
	}
	return 0x820951D4;
} // Block from 820951C4h-820951D4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820951D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820951D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820951D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820951D4);
		  /* 820951D4h */ case    0:  		/* li R23, 0 */
		/* 820951D4h case    0:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 820951D4h case    0:*/		return 0x820951D8;
		  /* 820951D8h */ case    1:  		/* b 2060 */
		/* 820951D8h case    1:*/		return 0x820959E4;
		/* 820951D8h case    1:*/		return 0x820951DC;
	}
	return 0x820951DC;
} // Block from 820951D4h-820951DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820951DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820951DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820951DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820951DC);
		  /* 820951DCh */ case    0:  		/* cmplwi CR6, R8, 42 */
		/* 820951DCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000002A);
		/* 820951DCh case    0:*/		return 0x820951E0;
		  /* 820951E0h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 820951E0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82095204;  }
		/* 820951E0h case    1:*/		return 0x820951E4;
		  /* 820951E4h */ case    2:  		/* addi R11, R24, 7 */
		/* 820951E4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x7);
		/* 820951E4h case    2:*/		return 0x820951E8;
		  /* 820951E8h */ case    3:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 820951E8h case    3:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 820951E8h case    3:*/		return 0x820951EC;
		  /* 820951ECh */ case    4:  		/* addi R24, R11, 8 */
		/* 820951ECh case    4:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x8);
		/* 820951ECh case    4:*/		return 0x820951F0;
		  /* 820951F0h */ case    5:  		/* lwz R23, <#[R11 + 4]> */
		/* 820951F0h case    5:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R11 + 0x00000004) );
		/* 820951F0h case    5:*/		return 0x820951F4;
		  /* 820951F4h */ case    6:  		/* cmpwi CR6, R23, 0 */
		/* 820951F4h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 820951F4h case    6:*/		return 0x820951F8;
		  /* 820951F8h */ case    7:  		/* bc 4, CR6_LT, 2028 */
		/* 820951F8h case    7:*/		if ( !regs.CR[6].lt ) { return 0x820959E4;  }
		/* 820951F8h case    7:*/		return 0x820951FC;
		  /* 820951FCh */ case    8:  		/* li R23, -1 */
		/* 820951FCh case    8:*/		cpu::op::li<0>(regs,&regs.R23,0xFFFFFFFF);
		/* 820951FCh case    8:*/		return 0x82095200;
		  /* 82095200h */ case    9:  		/* b 2020 */
		/* 82095200h case    9:*/		return 0x820959E4;
		/* 82095200h case    9:*/		return 0x82095204;
	}
	return 0x82095204;
} // Block from 820951DCh-82095204h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82095204h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095204( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095204) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095204);
		  /* 82095204h */ case    0:  		/* mulli R11, R23, 10 */
		/* 82095204h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R23,0xA);
		/* 82095204h case    0:*/		return 0x82095208;
		  /* 82095208h */ case    1:  		/* add R11, R11, R8 */
		/* 82095208h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 82095208h case    1:*/		return 0x8209520C;
		  /* 8209520Ch */ case    2:  		/* addi R23, R11, -48 */
		/* 8209520Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R11,0xFFFFFFD0);
		/* 8209520Ch case    2:*/		return 0x82095210;
		  /* 82095210h */ case    3:  		/* b 2004 */
		/* 82095210h case    3:*/		return 0x820959E4;
		/* 82095210h case    3:*/		return 0x82095214;
	}
	return 0x82095214;
} // Block from 82095204h-82095214h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82095214h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095214( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095214) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095214);
		  /* 82095214h */ case    0:  		/* cmpwi CR6, R8, 73 */
		/* 82095214h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000049);
		/* 82095214h case    0:*/		return 0x82095218;
		  /* 82095218h */ case    1:  		/* bc 12, CR6_EQ, 76 */
		/* 82095218h case    1:*/		if ( regs.CR[6].eq ) { return 0x82095264;  }
		/* 82095218h case    1:*/		return 0x8209521C;
		  /* 8209521Ch */ case    2:  		/* cmpwi CR6, R8, 104 */
		/* 8209521Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000068);
		/* 8209521Ch case    2:*/		return 0x82095220;
		  /* 82095220h */ case    3:  		/* bc 12, CR6_EQ, 60 */
		/* 82095220h case    3:*/		if ( regs.CR[6].eq ) { return 0x8209525C;  }
		/* 82095220h case    3:*/		return 0x82095224;
		  /* 82095224h */ case    4:  		/* cmpwi CR6, R8, 108 */
		/* 82095224h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000006C);
		/* 82095224h case    4:*/		return 0x82095228;
		  /* 82095228h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 82095228h case    5:*/		if ( regs.CR[6].eq ) { return 0x8209523C;  }
		/* 82095228h case    5:*/		return 0x8209522C;
		  /* 8209522Ch */ case    6:  		/* cmpwi CR6, R8, 119 */
		/* 8209522Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000077);
		/* 8209522Ch case    6:*/		return 0x82095230;
		  /* 82095230h */ case    7:  		/* bc 4, CR6_EQ, 1972 */
		/* 82095230h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820959E4;  }
		/* 82095230h case    7:*/		return 0x82095234;
		  /* 82095234h */ case    8:  		/* ori R25, R25, 2048 */
		/* 82095234h case    8:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x800);
		/* 82095234h case    8:*/		return 0x82095238;
		  /* 82095238h */ case    9:  		/* b 1964 */
		/* 82095238h case    9:*/		return 0x820959E4;
		/* 82095238h case    9:*/		return 0x8209523C;
	}
	return 0x8209523C;
} // Block from 82095214h-8209523Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209523Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209523C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209523C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209523C);
		  /* 8209523Ch */ case    0:  		/* lhz R11, <#[R17]> */
		/* 8209523Ch case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 8209523Ch case    0:*/		return 0x82095240;
		  /* 82095240h */ case    1:  		/* cmplwi CR6, R11, 108 */
		/* 82095240h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000006C);
		/* 82095240h case    1:*/		return 0x82095244;
		  /* 82095244h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 82095244h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82095254;  }
		/* 82095244h case    2:*/		return 0x82095248;
		  /* 82095248h */ case    3:  		/* addi R17, R17, 2 */
		/* 82095248h case    3:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x2);
		/* 82095248h case    3:*/		return 0x8209524C;
		  /* 8209524Ch */ case    4:  		/* ori R25, R25, 4096 */
		/* 8209524Ch case    4:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x1000);
		/* 8209524Ch case    4:*/		return 0x82095250;
		  /* 82095250h */ case    5:  		/* b 1940 */
		/* 82095250h case    5:*/		return 0x820959E4;
		/* 82095250h case    5:*/		return 0x82095254;
	}
	return 0x82095254;
} // Block from 8209523Ch-82095254h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82095254h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095254);
		  /* 82095254h */ case    0:  		/* ori R25, R25, 16 */
		/* 82095254h case    0:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x10);
		/* 82095254h case    0:*/		return 0x82095258;
		  /* 82095258h */ case    1:  		/* b 1932 */
		/* 82095258h case    1:*/		return 0x820959E4;
		/* 82095258h case    1:*/		return 0x8209525C;
	}
	return 0x8209525C;
} // Block from 82095254h-8209525Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209525Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209525C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209525C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209525C);
		  /* 8209525Ch */ case    0:  		/* ori R25, R25, 32 */
		/* 8209525Ch case    0:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x20);
		/* 8209525Ch case    0:*/		return 0x82095260;
		  /* 82095260h */ case    1:  		/* b 1924 */
		/* 82095260h case    1:*/		return 0x820959E4;
		/* 82095260h case    1:*/		return 0x82095264;
	}
	return 0x82095264;
} // Block from 8209525Ch-82095264h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82095264h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095264( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095264) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095264);
		  /* 82095264h */ case    0:  		/* lhz R11, <#[R17]> */
		/* 82095264h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82095264h case    0:*/		return 0x82095268;
		  /* 82095268h */ case    1:  		/* cmplwi CR6, R11, 54 */
		/* 82095268h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000036);
		/* 82095268h case    1:*/		return 0x8209526C;
		  /* 8209526Ch */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 8209526Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82095288;  }
		/* 8209526Ch case    2:*/		return 0x82095270;
		  /* 82095270h */ case    3:  		/* lhz R10, <#[R17 + 2]> */
		/* 82095270h case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000002) );
		/* 82095270h case    3:*/		return 0x82095274;
		  /* 82095274h */ case    4:  		/* cmplwi CR6, R10, 52 */
		/* 82095274h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000034);
		/* 82095274h case    4:*/		return 0x82095278;
		  /* 82095278h */ case    5:  		/* bc 4, CR6_EQ, 16 */
		/* 82095278h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82095288;  }
		/* 82095278h case    5:*/		return 0x8209527C;
		  /* 8209527Ch */ case    6:  		/* addi R17, R17, 4 */
		/* 8209527Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x4);
		/* 8209527Ch case    6:*/		return 0x82095280;
		  /* 82095280h */ case    7:  		/* ori R25, R25, 32768 */
		/* 82095280h case    7:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x8000);
		/* 82095280h case    7:*/		return 0x82095284;
		  /* 82095284h */ case    8:  		/* b 1888 */
		/* 82095284h case    8:*/		return 0x820959E4;
		/* 82095284h case    8:*/		return 0x82095288;
	}
	return 0x82095288;
} // Block from 82095264h-82095288h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82095288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095288);
		  /* 82095288h */ case    0:  		/* cmplwi CR6, R11, 51 */
		/* 82095288h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000033);
		/* 82095288h case    0:*/		return 0x8209528C;
		  /* 8209528Ch */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 8209528Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820952A8;  }
		/* 8209528Ch case    1:*/		return 0x82095290;
		  /* 82095290h */ case    2:  		/* lhz R10, <#[R17 + 2]> */
		/* 82095290h case    2:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000002) );
		/* 82095290h case    2:*/		return 0x82095294;
		  /* 82095294h */ case    3:  		/* cmplwi CR6, R10, 50 */
		/* 82095294h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000032);
		/* 82095294h case    3:*/		return 0x82095298;
		  /* 82095298h */ case    4:  		/* bc 4, CR6_EQ, 16 */
		/* 82095298h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820952A8;  }
		/* 82095298h case    4:*/		return 0x8209529C;
		  /* 8209529Ch */ case    5:  		/* addi R17, R17, 4 */
		/* 8209529Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x4);
		/* 8209529Ch case    5:*/		return 0x820952A0;
		  /* 820952A0h */ case    6:  		/* rlwinm R25, R25, 0, 17, 15 */
		/* 820952A0h case    6:*/		cpu::op::rlwinm<0,0,17,15>(regs,&regs.R25,regs.R25);
		/* 820952A0h case    6:*/		return 0x820952A4;
		  /* 820952A4h */ case    7:  		/* b 1856 */
		/* 820952A4h case    7:*/		return 0x820959E4;
		/* 820952A4h case    7:*/		return 0x820952A8;
	}
	return 0x820952A8;
} // Block from 82095288h-820952A8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820952A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820952A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820952A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820952A8);
		  /* 820952A8h */ case    0:  		/* cmplwi CR6, R11, 100 */
		/* 820952A8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000064);
		/* 820952A8h case    0:*/		return 0x820952AC;
		  /* 820952ACh */ case    1:  		/* bc 12, CR6_EQ, 1848 */
		/* 820952ACh case    1:*/		if ( regs.CR[6].eq ) { return 0x820959E4;  }
		/* 820952ACh case    1:*/		return 0x820952B0;
		  /* 820952B0h */ case    2:  		/* cmplwi CR6, R11, 105 */
		/* 820952B0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000069);
		/* 820952B0h case    2:*/		return 0x820952B4;
		  /* 820952B4h */ case    3:  		/* bc 12, CR6_EQ, 1840 */
		/* 820952B4h case    3:*/		if ( regs.CR[6].eq ) { return 0x820959E4;  }
		/* 820952B4h case    3:*/		return 0x820952B8;
		  /* 820952B8h */ case    4:  		/* cmplwi CR6, R11, 111 */
		/* 820952B8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000006F);
		/* 820952B8h case    4:*/		return 0x820952BC;
		  /* 820952BCh */ case    5:  		/* bc 12, CR6_EQ, 1832 */
		/* 820952BCh case    5:*/		if ( regs.CR[6].eq ) { return 0x820959E4;  }
		/* 820952BCh case    5:*/		return 0x820952C0;
		  /* 820952C0h */ case    6:  		/* cmplwi CR6, R11, 117 */
		/* 820952C0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000075);
		/* 820952C0h case    6:*/		return 0x820952C4;
		  /* 820952C4h */ case    7:  		/* bc 12, CR6_EQ, 1824 */
		/* 820952C4h case    7:*/		if ( regs.CR[6].eq ) { return 0x820959E4;  }
		/* 820952C4h case    7:*/		return 0x820952C8;
		  /* 820952C8h */ case    8:  		/* cmplwi CR6, R11, 120 */
		/* 820952C8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000078);
		/* 820952C8h case    8:*/		return 0x820952CC;
		  /* 820952CCh */ case    9:  		/* bc 12, CR6_EQ, 1816 */
		/* 820952CCh case    9:*/		if ( regs.CR[6].eq ) { return 0x820959E4;  }
		/* 820952CCh case    9:*/		return 0x820952D0;
		  /* 820952D0h */ case   10:  		/* cmplwi CR6, R11, 88 */
		/* 820952D0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000058);
		/* 820952D0h case   10:*/		return 0x820952D4;
		  /* 820952D4h */ case   11:  		/* bc 12, CR6_EQ, 1808 */
		/* 820952D4h case   11:*/		if ( regs.CR[6].eq ) { return 0x820959E4;  }
		/* 820952D4h case   11:*/		return 0x820952D8;
		  /* 820952D8h */ case   12:  		/* li R11, 0 */
		/* 820952D8h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820952D8h case   12:*/		return 0x820952DC;
		  /* 820952DCh */ case   13:  		/* stw R11, <#[R1 + 108]> */
		/* 820952DCh case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 820952DCh case   13:*/		return 0x820952E0;
	}
	return 0x820952E0;
} // Block from 820952A8h-820952E0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820952E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820952E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820952E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820952E0);
		  /* 820952E0h */ case    0:  		/* addi R5, R1, 80 */
		/* 820952E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820952E0h case    0:*/		return 0x820952E4;
		  /* 820952E4h */ case    1:  		/* mr R4, R16 */
		/* 820952E4h case    1:*/		regs.R4 = regs.R16;
		/* 820952E4h case    1:*/		return 0x820952E8;
		  /* 820952E8h */ case    2:  		/* mr R3, R29 */
		/* 820952E8h case    2:*/		regs.R3 = regs.R29;
		/* 820952E8h case    2:*/		return 0x820952EC;
		  /* 820952ECh */ case    3:  		/* li R20, 1 */
		/* 820952ECh case    3:*/		cpu::op::li<0>(regs,&regs.R20,0x1);
		/* 820952ECh case    3:*/		return 0x820952F0;
		  /* 820952F0h */ case    4:  		/* bl 1880 */
		/* 820952F0h case    4:*/		regs.LR = 0x820952F4; return 0x82095A48;
		/* 820952F0h case    4:*/		return 0x820952F4;
		  /* 820952F4h */ case    5:  		/* lwz R21, <#[R1 + 80]> */
		/* 820952F4h case    5:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000050) );
		/* 820952F4h case    5:*/		return 0x820952F8;
		  /* 820952F8h */ case    6:  		/* b 1772 */
		/* 820952F8h case    6:*/		return 0x820959E4;
		/* 820952F8h case    6:*/		return 0x820952FC;
	}
	return 0x820952FC;
} // Block from 820952E0h-820952FCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820952FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820952FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820952FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820952FC);
		  /* 820952FCh */ case    0:  		/* addi R11, R8, -65 */
		/* 820952FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0xFFFFFFBF);
		/* 820952FCh case    0:*/		return 0x82095300;
		  /* 82095300h */ case    1:  		/* cmplwi CR6, R11, 55 */
		/* 82095300h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000037);
		/* 82095300h case    1:*/		return 0x82095304;
		  /* 82095304h */ case    2:  		/* bc 12, CR6_GT, 1312 */
		/* 82095304h case    2:*/		if ( regs.CR[6].gt ) { return 0x82095824;  }
		/* 82095304h case    2:*/		return 0x82095308;
		  /* 82095308h */ case    3:  		/* lis R12, -32255 */
		/* 82095308h case    3:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8201);
		/* 82095308h case    3:*/		return 0x8209530C;
		  /* 8209530Ch */ case    4:  		/* rlwinm R0, R11, 1, 0, 30 */
		/* 8209530Ch case    4:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R0,regs.R11);
		/* 8209530Ch case    4:*/		return 0x82095310;
		  /* 82095310h */ case    5:  		/* addi R12, R12, -22168 */
		/* 82095310h case    5:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFA968);
		/* 82095310h case    5:*/		return 0x82095314;
		  /* 82095314h */ case    6:  		/* lhzx R0, <#[R12 + R0]> */
		/* 82095314h case    6:*/		cpu::mem::load16z( regs, &regs.R0, (uint32)(regs.R12 + regs.R0 + 0x00000000) );
		/* 82095314h case    6:*/		return 0x82095318;
		  /* 82095318h */ case    7:  		/* lis R12, -32247 */
		/* 82095318h case    7:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8209);
		/* 82095318h case    7:*/		return 0x8209531C;
		  /* 8209531Ch */ case    8:  		/* addi R12, R12, 21296 */
		/* 8209531Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x5330);
		/* 8209531Ch case    8:*/		return 0x82095320;
		  /* 82095320h */ case    9:  		/* ori R0, R0, 0 */
		/* 82095320h case    9:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82095320h case    9:*/		return 0x82095324;
		  /* 82095324h */ case   10:  		/* add R12, R12, R0 */
		/* 82095324h case   10:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 82095324h case   10:*/		return 0x82095328;
		  /* 82095328h */ case   11:  		/* mtspr CTR, R12 */
		/* 82095328h case   11:*/		regs.CTR = regs.R12;
		/* 82095328h case   11:*/		return 0x8209532C;
		  /* 8209532Ch */ case   12:  		/* bcctr 20, CR0_LT */
		/* 8209532Ch case   12:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 8209532Ch case   12:*/		return 0x82095330;
		  /* 82095330h */ case   13:  		/* andi. R11, R25, 2096 */
		/* 82095330h case   13:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R25,0x830);
		/* 82095330h case   13:*/		return 0x82095334;
		  /* 82095334h */ case   14:  		/* cmpwi CR0, R11, 0 */
		/* 82095334h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 82095334h case   14:*/		return 0x82095338;
		  /* 82095338h */ case   15:  		/* bc 4, CR0_EQ, 8 */
		/* 82095338h case   15:*/		if ( !regs.CR[0].eq ) { return 0x82095340;  }
		/* 82095338h case   15:*/		return 0x8209533C;
		  /* 8209533Ch */ case   16:  		/* ori R25, R25, 32 */
		/* 8209533Ch case   16:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x20);
		/* 8209533Ch case   16:*/		return 0x82095340;
	}
	return 0x82095340;
} // Block from 820952FCh-82095340h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82095340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095340);
		  /* 82095340h */ case    0:  		/* addi R11, R24, 7 */
		/* 82095340h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x7);
		/* 82095340h case    0:*/		return 0x82095344;
		  /* 82095344h */ case    1:  		/* li R26, 1 */
		/* 82095344h case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 82095344h case    1:*/		return 0x82095348;
		  /* 82095348h */ case    2:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82095348h case    2:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82095348h case    2:*/		return 0x8209534C;
		  /* 8209534Ch */ case    3:  		/* rlwinm. R10, R25, 0, 26, 26 */
		/* 8209534Ch case    3:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R10,regs.R25);
		/* 8209534Ch case    3:*/		return 0x82095350;
		  /* 82095350h */ case    4:  		/* addi R24, R11, 8 */
		/* 82095350h case    4:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x8);
		/* 82095350h case    4:*/		return 0x82095354;
		  /* 82095354h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 82095354h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82095354h case    5:*/		return 0x82095358;
		  /* 82095358h */ case    6:  		/* mr R20, R26 */
		/* 82095358h case    6:*/		regs.R20 = regs.R26;
		/* 82095358h case    6:*/		return 0x8209535C;
		  /* 8209535Ch */ case    7:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209535Ch case    7:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209535Ch case    7:*/		return 0x82095360;
		  /* 82095360h */ case    8:  		/* sth R11, <#[R1 + 92]> */
		/* 82095360h case    8:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 82095360h case    8:*/		return 0x82095364;
		  /* 82095364h */ case    9:  		/* bc 12, CR0_EQ, 60 */
		/* 82095364h case    9:*/		if ( regs.CR[0].eq ) { return 0x820953A0;  }
		/* 82095364h case    9:*/		return 0x82095368;
		  /* 82095368h */ case   10:  		/* mr R10, R11 */
		/* 82095368h case   10:*/		regs.R10 = regs.R11;
		/* 82095368h case   10:*/		return 0x8209536C;
		  /* 8209536Ch */ case   11:  		/* lwz R11, <#[R22]> */
		/* 8209536Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 8209536Ch case   11:*/		return 0x82095370;
		  /* 82095370h */ case   12:  		/* li R9, 0 */
		/* 82095370h case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82095370h case   12:*/		return 0x82095374;
		  /* 82095374h */ case   13:  		/* stb R10, <#[R1 + 84]> */
		/* 82095374h case   13:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82095374h case   13:*/		return 0x82095378;
		  /* 82095378h */ case   14:  		/* mr R6, R22 */
		/* 82095378h case   14:*/		regs.R6 = regs.R22;
		/* 82095378h case   14:*/		return 0x8209537C;
		  /* 8209537Ch */ case   15:  		/* stb R9, <#[R1 + 85]> */
		/* 8209537Ch case   15:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R1 + 0x00000055) );
		/* 8209537Ch case   15:*/		return 0x82095380;
		  /* 82095380h */ case   16:  		/* addi R4, R1, 84 */
		/* 82095380h case   16:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x54);
		/* 82095380h case   16:*/		return 0x82095384;
		  /* 82095384h */ case   17:  		/* addi R3, R1, 128 */
		/* 82095384h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 82095384h case   17:*/		return 0x82095388;
		  /* 82095388h */ case   18:  		/* lwz R5, <#[R11 + 172]> */
		/* 82095388h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x000000AC) );
		/* 82095388h case   18:*/		return 0x8209538C;
		  /* 8209538Ch */ case   19:  		/* bl 23308 */
		/* 8209538Ch case   19:*/		regs.LR = 0x82095390; return 0x8209AE98;
		/* 8209538Ch case   19:*/		return 0x82095390;
		  /* 82095390h */ case   20:  		/* cmpwi CR0, R3, 0 */
		/* 82095390h case   20:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82095390h case   20:*/		return 0x82095394;
		  /* 82095394h */ case   21:  		/* bc 4, CR0_LT, 16 */
		/* 82095394h case   21:*/		if ( !regs.CR[0].lt ) { return 0x820953A4;  }
		/* 82095394h case   21:*/		return 0x82095398;
		  /* 82095398h */ case   22:  		/* stw R26, <#[R1 + 96]> */
		/* 82095398h case   22:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000060) );
		/* 82095398h case   22:*/		return 0x8209539C;
		  /* 8209539Ch */ case   23:  		/* b 8 */
		/* 8209539Ch case   23:*/		return 0x820953A4;
		/* 8209539Ch case   23:*/		return 0x820953A0;
	}
	return 0x820953A0;
} // Block from 82095340h-820953A0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820953A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820953A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820953A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820953A0);
		  /* 820953A0h */ case    0:  		/* sth R11, <#[R1 + 128]> */
		/* 820953A0h case    0:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 820953A0h case    0:*/		return 0x820953A4;
	}
	return 0x820953A4;
} // Block from 820953A0h-820953A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820953A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820953A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820953A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820953A4);
		  /* 820953A4h */ case    0:  		/* addi R27, R1, 128 */
		/* 820953A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R1,0x80);
		/* 820953A4h case    0:*/		return 0x820953A8;
		  /* 820953A8h */ case    1:  		/* b 1148 */
		/* 820953A8h case    1:*/		return 0x82095824;
		/* 820953A8h case    1:*/		return 0x820953AC;
		  /* 820953ACh */ case    2:  		/* addi R11, R24, 7 */
		/* 820953ACh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x7);
		/* 820953ACh case    2:*/		return 0x820953B0;
		  /* 820953B0h */ case    3:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 820953B0h case    3:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 820953B0h case    3:*/		return 0x820953B4;
		  /* 820953B4h */ case    4:  		/* addi R24, R11, 8 */
		/* 820953B4h case    4:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x8);
		/* 820953B4h case    4:*/		return 0x820953B8;
		  /* 820953B8h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820953B8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820953B8h case    5:*/		return 0x820953BC;
		  /* 820953BCh */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820953BCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820953BCh case    6:*/		return 0x820953C0;
		  /* 820953C0h */ case    7:  		/* bc 12, CR6_EQ, 60 */
		/* 820953C0h case    7:*/		if ( regs.CR[6].eq ) { return 0x820953FC;  }
		/* 820953C0h case    7:*/		return 0x820953C4;
		  /* 820953C4h */ case    8:  		/* lwz R10, <#[R11 + 4]> */
		/* 820953C4h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820953C4h case    8:*/		return 0x820953C8;
		  /* 820953C8h */ case    9:  		/* cmplwi CR6, R10, 0 */
		/* 820953C8h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820953C8h case    9:*/		return 0x820953CC;
		  /* 820953CCh */ case   10:  		/* bc 12, CR6_EQ, 48 */
		/* 820953CCh case   10:*/		if ( regs.CR[6].eq ) { return 0x820953FC;  }
		/* 820953CCh case   10:*/		return 0x820953D0;
		  /* 820953D0h */ case   11:  		/* rlwinm. R9, R25, 0, 20, 20 */
		/* 820953D0h case   11:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R9,regs.R25);
		/* 820953D0h case   11:*/		return 0x820953D4;
		  /* 820953D4h */ case   12:  		/* mr R27, R10 */
		/* 820953D4h case   12:*/		regs.R27 = regs.R10;
		/* 820953D4h case   12:*/		return 0x820953D8;
		  /* 820953D8h */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 820953D8h case   13:*/		if ( regs.CR[0].eq ) { return 0x820953F0;  }
		/* 820953D8h case   13:*/		return 0x820953DC;
		  /* 820953DCh */ case   14:  		/* lha R11, <#[R11]> */
		/* 820953DCh case   14:*/		cpu::mem::load16a( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820953DCh case   14:*/		return 0x820953E0;
		  /* 820953E0h */ case   15:  		/* li R20, 1 */
		/* 820953E0h case   15:*/		cpu::op::li<0>(regs,&regs.R20,0x1);
		/* 820953E0h case   15:*/		return 0x820953E4;
		  /* 820953E4h */ case   16:  		/* srawi R11, R11, 1 */
		/* 820953E4h case   16:*/		cpu::op::srawi<0,1>(regs,&regs.R11,regs.R11);
		/* 820953E4h case   16:*/		return 0x820953E8;
		  /* 820953E8h */ case   17:  		/* addze R26, R11 */
		/* 820953E8h case   17:*/		cpu::op::addze<0>(regs,&regs.R26,regs.R11);
		/* 820953E8h case   17:*/		return 0x820953EC;
		  /* 820953ECh */ case   18:  		/* b 1080 */
		/* 820953ECh case   18:*/		return 0x82095824;
		/* 820953ECh case   18:*/		return 0x820953F0;
	}
	return 0x820953F0;
} // Block from 820953A4h-820953F0h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820953F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820953F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820953F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820953F0);
		  /* 820953F0h */ case    0:  		/* lha R26, <#[R11]> */
		/* 820953F0h case    0:*/		cpu::mem::load16a( regs, &regs.R26, (uint32)(regs.R11 + 0x00000000) );
		/* 820953F0h case    0:*/		return 0x820953F4;
		  /* 820953F4h */ case    1:  		/* li R20, 0 */
		/* 820953F4h case    1:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 820953F4h case    1:*/		return 0x820953F8;
		  /* 820953F8h */ case    2:  		/* b 1068 */
		/* 820953F8h case    2:*/		return 0x82095824;
		/* 820953F8h case    2:*/		return 0x820953FC;
	}
	return 0x820953FC;
} // Block from 820953F0h-820953FCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820953FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820953FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820953FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820953FC);
		  /* 820953FCh */ case    0:  		/* lis R10, -32255 */
		/* 820953FCh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820953FCh case    0:*/		return 0x82095400;
		  /* 82095400h */ case    1:  		/* lwz R27, <#[R10 - 21808]> */
		/* 82095400h case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R10 + 0xFFFFAAD0) );
		/* 82095400h case    1:*/		return 0x82095404;
		  /* 82095404h */ case    2:  		/* mr R11, R27 */
		/* 82095404h case    2:*/		regs.R11 = regs.R27;
		/* 82095404h case    2:*/		return 0x82095408;
		  /* 82095408h */ case    3:  		/* mr R10, R27 */
		/* 82095408h case    3:*/		regs.R10 = regs.R27;
		/* 82095408h case    3:*/		return 0x8209540C;
		  /* 8209540Ch */ case    4:  		/* lbz R9, <#[R11]> */
		/* 8209540Ch case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8209540Ch case    4:*/		return 0x82095410;
		  /* 82095410h */ case    5:  		/* addi R11, R11, 1 */
		/* 82095410h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82095410h case    5:*/		return 0x82095414;
		  /* 82095414h */ case    6:  		/* cmplwi CR6, R9, 0 */
		/* 82095414h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82095414h case    6:*/		return 0x82095418;
		  /* 82095418h */ case    7:  		/* bc 4, CR6_EQ, -12 */
		/* 82095418h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8209540C;  }
		/* 82095418h case    7:*/		return 0x8209541C;
		  /* 8209541Ch */ case    8:  		/* subf R11, R10, R11 */
		/* 8209541Ch case    8:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8209541Ch case    8:*/		return 0x82095420;
		  /* 82095420h */ case    9:  		/* addi R11, R11, -1 */
		/* 82095420h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82095420h case    9:*/		return 0x82095424;
		  /* 82095424h */ case   10:  		/* rlwinm R26, R11, 0, 0, 31 */
		/* 82095424h case   10:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R26,regs.R11);
		/* 82095424h case   10:*/		return 0x82095428;
		  /* 82095428h */ case   11:  		/* b 1020 */
		/* 82095428h case   11:*/		return 0x82095824;
		/* 82095428h case   11:*/		return 0x8209542C;
		  /* 8209542Ch */ case   12:  		/* andi. R11, R25, 2096 */
		/* 8209542Ch case   12:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R25,0x830);
		/* 8209542Ch case   12:*/		return 0x82095430;
		  /* 82095430h */ case   13:  		/* cmpwi CR0, R11, 0 */
		/* 82095430h case   13:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 82095430h case   13:*/		return 0x82095434;
		  /* 82095434h */ case   14:  		/* bc 4, CR0_EQ, 8 */
		/* 82095434h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8209543C;  }
		/* 82095434h case   14:*/		return 0x82095438;
		  /* 82095438h */ case   15:  		/* ori R25, R25, 32 */
		/* 82095438h case   15:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x20);
		/* 82095438h case   15:*/		return 0x8209543C;
	}
	return 0x8209543C;
} // Block from 820953FCh-8209543Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8209543Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209543C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209543C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209543C);
		  /* 8209543Ch */ case    0:  		/* cmpwi CR6, R23, -1 */
		/* 8209543Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R23,0xFFFFFFFF);
		/* 8209543Ch case    0:*/		return 0x82095440;
		  /* 82095440h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 82095440h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82095450;  }
		/* 82095440h case    1:*/		return 0x82095444;
		  /* 82095444h */ case    2:  		/* lis R30, 32767 */
		/* 82095444h case    2:*/		cpu::op::lis<0>(regs,&regs.R30,0x7FFF);
		/* 82095444h case    2:*/		return 0x82095448;
		  /* 82095448h */ case    3:  		/* ori R30, R30, 65535 */
		/* 82095448h case    3:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0xFFFF);
		/* 82095448h case    3:*/		return 0x8209544C;
		  /* 8209544Ch */ case    4:  		/* b 8 */
		/* 8209544Ch case    4:*/		return 0x82095454;
		/* 8209544Ch case    4:*/		return 0x82095450;
	}
	return 0x82095450;
} // Block from 8209543Ch-82095450h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82095450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095450);
		  /* 82095450h */ case    0:  		/* mr R30, R23 */
		/* 82095450h case    0:*/		regs.R30 = regs.R23;
		/* 82095450h case    0:*/		return 0x82095454;
	}
	return 0x82095454;
} // Block from 82095450h-82095454h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82095454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095454);
		  /* 82095454h */ case    0:  		/* addi R11, R24, 7 */
		/* 82095454h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x7);
		/* 82095454h case    0:*/		return 0x82095458;
		  /* 82095458h */ case    1:  		/* rlwinm. R10, R25, 0, 26, 26 */
		/* 82095458h case    1:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R10,regs.R25);
		/* 82095458h case    1:*/		return 0x8209545C;
		  /* 8209545Ch */ case    2:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 8209545Ch case    2:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 8209545Ch case    2:*/		return 0x82095460;
		  /* 82095460h */ case    3:  		/* addi R24, R11, 8 */
		/* 82095460h case    3:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x8);
		/* 82095460h case    3:*/		return 0x82095464;
		  /* 82095464h */ case    4:  		/* lwz R27, <#[R11 + 4]> */
		/* 82095464h case    4:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000004) );
		/* 82095464h case    4:*/		return 0x82095468;
		  /* 82095468h */ case    5:  		/* cmplwi CR6, R27, 0 */
		/* 82095468h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82095468h case    5:*/		return 0x8209546C;
		  /* 8209546Ch */ case    6:  		/* bc 12, CR0_EQ, 88 */
		/* 8209546Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820954C4;  }
		/* 8209546Ch case    6:*/		return 0x82095470;
		  /* 82095470h */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 82095470h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8209547C;  }
		/* 82095470h case    7:*/		return 0x82095474;
		  /* 82095474h */ case    8:  		/* lis R11, -32255 */
		/* 82095474h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82095474h case    8:*/		return 0x82095478;
		  /* 82095478h */ case    9:  		/* lwz R27, <#[R11 - 21808]> */
		/* 82095478h case    9:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0xFFFFAAD0) );
		/* 82095478h case    9:*/		return 0x8209547C;
	}
	return 0x8209547C;
} // Block from 82095454h-8209547Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209547Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209547C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209547C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209547C);
		  /* 8209547Ch */ case    0:  		/* mr R31, R27 */
		/* 8209547Ch case    0:*/		regs.R31 = regs.R27;
		/* 8209547Ch case    0:*/		return 0x82095480;
		  /* 82095480h */ case    1:  		/* li R26, 0 */
		/* 82095480h case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82095480h case    1:*/		return 0x82095484;
		  /* 82095484h */ case    2:  		/* cmpwi CR6, R30, 0 */
		/* 82095484h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82095484h case    2:*/		return 0x82095488;
		  /* 82095488h */ case    3:  		/* bc 4, CR6_GT, 924 */
		/* 82095488h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82095824;  }
		/* 82095488h case    3:*/		return 0x8209548C;
		  /* 8209548Ch */ case    4:  		/* lbz R11, <#[R31]> */
		/* 8209548Ch case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209548Ch case    4:*/		return 0x82095490;
		  /* 82095490h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 82095490h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82095490h case    5:*/		return 0x82095494;
		  /* 82095494h */ case    6:  		/* bc 12, CR0_EQ, 912 */
		/* 82095494h case    6:*/		if ( regs.CR[0].eq ) { return 0x82095824;  }
		/* 82095494h case    6:*/		return 0x82095498;
		  /* 82095498h */ case    7:  		/* mr R4, R22 */
		/* 82095498h case    7:*/		regs.R4 = regs.R22;
		/* 82095498h case    7:*/		return 0x8209549C;
		  /* 8209549Ch */ case    8:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 8209549Ch case    8:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 8209549Ch case    8:*/		return 0x820954A0;
		  /* 820954A0h */ case    9:  		/* bl 23000 */
		/* 820954A0h case    9:*/		regs.LR = 0x820954A4; return 0x8209AE78;
		/* 820954A0h case    9:*/		return 0x820954A4;
		  /* 820954A4h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 820954A4h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820954A4h case   10:*/		return 0x820954A8;
		  /* 820954A8h */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 820954A8h case   11:*/		if ( regs.CR[0].eq ) { return 0x820954B0;  }
		/* 820954A8h case   11:*/		return 0x820954AC;
		  /* 820954ACh */ case   12:  		/* addi R31, R31, 1 */
		/* 820954ACh case   12:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820954ACh case   12:*/		return 0x820954B0;
	}
	return 0x820954B0;
} // Block from 8209547Ch-820954B0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820954B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820954B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820954B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820954B0);
		  /* 820954B0h */ case    0:  		/* addi R26, R26, 1 */
		/* 820954B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820954B0h case    0:*/		return 0x820954B4;
		  /* 820954B4h */ case    1:  		/* addi R31, R31, 1 */
		/* 820954B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820954B4h case    1:*/		return 0x820954B8;
		  /* 820954B8h */ case    2:  		/* cmpw CR6, R26, R30 */
		/* 820954B8h case    2:*/		cpu::op::cmpw<6>(regs,regs.R26,regs.R30);
		/* 820954B8h case    2:*/		return 0x820954BC;
		  /* 820954BCh */ case    3:  		/* bc 12, CR6_LT, -48 */
		/* 820954BCh case    3:*/		if ( regs.CR[6].lt ) { return 0x8209548C;  }
		/* 820954BCh case    3:*/		return 0x820954C0;
		  /* 820954C0h */ case    4:  		/* b 868 */
		/* 820954C0h case    4:*/		return 0x82095824;
		/* 820954C0h case    4:*/		return 0x820954C4;
	}
	return 0x820954C4;
} // Block from 820954B0h-820954C4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820954C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820954C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820954C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820954C4);
		  /* 820954C4h */ case    0:  		/* bc 4, CR6_EQ, 12 */
		/* 820954C4h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820954D0;  }
		/* 820954C4h case    0:*/		return 0x820954C8;
		  /* 820954C8h */ case    1:  		/* lis R11, -32255 */
		/* 820954C8h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820954C8h case    1:*/		return 0x820954CC;
		  /* 820954CCh */ case    2:  		/* lwz R27, <#[R11 - 21804]> */
		/* 820954CCh case    2:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0xFFFFAAD4) );
		/* 820954CCh case    2:*/		return 0x820954D0;
	}
	return 0x820954D0;
} // Block from 820954C4h-820954D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820954D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820954D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820954D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820954D0);
		  /* 820954D0h */ case    0:  		/* li R20, 1 */
		/* 820954D0h case    0:*/		cpu::op::li<0>(regs,&regs.R20,0x1);
		/* 820954D0h case    0:*/		return 0x820954D4;
		  /* 820954D4h */ case    1:  		/* mr R11, R27 */
		/* 820954D4h case    1:*/		regs.R11 = regs.R27;
		/* 820954D4h case    1:*/		return 0x820954D8;
		  /* 820954D8h */ case    2:  		/* b 24 */
		/* 820954D8h case    2:*/		return 0x820954F0;
		/* 820954D8h case    2:*/		return 0x820954DC;
		  /* 820954DCh */ case    3:  		/* lhz R10, <#[R11]> */
		/* 820954DCh case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820954DCh case    3:*/		return 0x820954E0;
		  /* 820954E0h */ case    4:  		/* addi R30, R30, -1 */
		/* 820954E0h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 820954E0h case    4:*/		return 0x820954E4;
		  /* 820954E4h */ case    5:  		/* cmplwi CR0, R10, 0 */
		/* 820954E4h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 820954E4h case    5:*/		return 0x820954E8;
		  /* 820954E8h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 820954E8h case    6:*/		if ( regs.CR[0].eq ) { return 0x820954F8;  }
		/* 820954E8h case    6:*/		return 0x820954EC;
		  /* 820954ECh */ case    7:  		/* addi R11, R11, 2 */
		/* 820954ECh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820954ECh case    7:*/		return 0x820954F0;
	}
	return 0x820954F0;
} // Block from 820954D0h-820954F0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820954F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820954F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820954F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820954F0);
		  /* 820954F0h */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 820954F0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820954F0h case    0:*/		return 0x820954F4;
		  /* 820954F4h */ case    1:  		/* bc 4, CR6_EQ, -24 */
		/* 820954F4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820954DC;  }
		/* 820954F4h case    1:*/		return 0x820954F8;
	}
	return 0x820954F8;
} // Block from 820954F0h-820954F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820954F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820954F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820954F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820954F8);
		  /* 820954F8h */ case    0:  		/* subf R11, R27, R11 */
		/* 820954F8h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R27,regs.R11);
		/* 820954F8h case    0:*/		return 0x820954FC;
		  /* 820954FCh */ case    1:  		/* srawi R26, R11, 1 */
		/* 820954FCh case    1:*/		cpu::op::srawi<0,1>(regs,&regs.R26,regs.R11);
		/* 820954FCh case    1:*/		return 0x82095500;
		  /* 82095500h */ case    2:  		/* b 804 */
		/* 82095500h case    2:*/		return 0x82095824;
		/* 82095500h case    2:*/		return 0x82095504;
		  /* 82095504h */ case    3:  		/* addi R11, R24, 7 */
		/* 82095504h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x7);
		/* 82095504h case    3:*/		return 0x82095508;
		  /* 82095508h */ case    4:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82095508h case    4:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82095508h case    4:*/		return 0x8209550C;
		  /* 8209550Ch */ case    5:  		/* addi R24, R11, 8 */
		/* 8209550Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x8);
		/* 8209550Ch case    5:*/		return 0x82095510;
		  /* 82095510h */ case    6:  		/* lwz R31, <#[R11 + 4]> */
		/* 82095510h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 82095510h case    6:*/		return 0x82095514;
		  /* 82095514h */ case    7:  		/* bl 22844 */
		/* 82095514h case    7:*/		regs.LR = 0x82095518; return 0x8209AE50;
		/* 82095514h case    7:*/		return 0x82095518;
		  /* 82095518h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 82095518h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82095518h case    8:*/		return 0x8209551C;
		  /* 8209551Ch */ case    9:  		/* bc 12, CR0_EQ, -1268 */
		/* 8209551Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x82095028;  }
		/* 8209551Ch case    9:*/		return 0x82095520;
		  /* 82095520h */ case   10:  		/* rlwinm. R11, R25, 0, 26, 26 */
		/* 82095520h case   10:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R25);
		/* 82095520h case   10:*/		return 0x82095524;
		  /* 82095524h */ case   11:  		/* bc 12, CR0_EQ, 12 */
		/* 82095524h case   11:*/		if ( regs.CR[0].eq ) { return 0x82095530;  }
		/* 82095524h case   11:*/		return 0x82095528;
		  /* 82095528h */ case   12:  		/* sth R21, <#[R31]> */
		/* 82095528h case   12:*/		cpu::mem::store16( regs, regs.R21, (uint32)(regs.R31 + 0x00000000) );
		/* 82095528h case   12:*/		return 0x8209552C;
		  /* 8209552Ch */ case   13:  		/* b 8 */
		/* 8209552Ch case   13:*/		return 0x82095534;
		/* 8209552Ch case   13:*/		return 0x82095530;
	}
	return 0x82095530;
} // Block from 820954F8h-82095530h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82095530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095530);
		  /* 82095530h */ case    0:  		/* stw R21, <#[R31]> */
		/* 82095530h case    0:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R31 + 0x00000000) );
		/* 82095530h case    0:*/		return 0x82095534;
	}
	return 0x82095534;
} // Block from 82095530h-82095534h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82095534h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095534( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095534) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095534);
		  /* 82095534h */ case    0:  		/* li R11, 1 */
		/* 82095534h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82095534h case    0:*/		return 0x82095538;
		  /* 82095538h */ case    1:  		/* stw R11, <#[R1 + 96]> */
		/* 82095538h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82095538h case    1:*/		return 0x8209553C;
		  /* 8209553Ch */ case    2:  		/* b 1168 */
		/* 8209553Ch case    2:*/		return 0x820959CC;
		/* 8209553Ch case    2:*/		return 0x82095540;
		  /* 82095540h */ case    3:  		/* addi R11, R8, 32 */
		/* 82095540h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0x20);
		/* 82095540h case    3:*/		return 0x82095544;
		  /* 82095544h */ case    4:  		/* li R18, 1 */
		/* 82095544h case    4:*/		cpu::op::li<0>(regs,&regs.R18,0x1);
		/* 82095544h case    4:*/		return 0x82095548;
		  /* 82095548h */ case    5:  		/* rlwinm R29, R11, 0, 16, 31 */
		/* 82095548h case    5:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R29,regs.R11);
		/* 82095548h case    5:*/		return 0x8209554C;
		  /* 8209554Ch */ case    6:  		/* ori R25, R25, 64 */
		/* 8209554Ch case    6:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x40);
		/* 8209554Ch case    6:*/		return 0x82095550;
		  /* 82095550h */ case    7:  		/* addi R27, R1, 128 */
		/* 82095550h case    7:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R1,0x80);
		/* 82095550h case    7:*/		return 0x82095554;
		  /* 82095554h */ case    8:  		/* li R30, 512 */
		/* 82095554h case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x200);
		/* 82095554h case    8:*/		return 0x82095558;
		  /* 82095558h */ case    9:  		/* cmpwi CR6, R23, 0 */
		/* 82095558h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 82095558h case    9:*/		return 0x8209555C;
		  /* 8209555Ch */ case   10:  		/* bc 4, CR6_LT, 12 */
		/* 8209555Ch case   10:*/		if ( !regs.CR[6].lt ) { return 0x82095568;  }
		/* 8209555Ch case   10:*/		return 0x82095560;
		  /* 82095560h */ case   11:  		/* li R23, 6 */
		/* 82095560h case   11:*/		cpu::op::li<0>(regs,&regs.R23,0x6);
		/* 82095560h case   11:*/		return 0x82095564;
		  /* 82095564h */ case   12:  		/* b 88 */
		/* 82095564h case   12:*/		return 0x820955BC;
		/* 82095564h case   12:*/		return 0x82095568;
	}
	return 0x82095568;
} // Block from 82095534h-82095568h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82095568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095568);
		  /* 82095568h */ case    0:  		/* bc 4, CR6_EQ, 24 */
		/* 82095568h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82095580;  }
		/* 82095568h case    0:*/		return 0x8209556C;
		  /* 8209556Ch */ case    1:  		/* rlwinm R11, R29, 0, 16, 31 */
		/* 8209556Ch case    1:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R29);
		/* 8209556Ch case    1:*/		return 0x82095570;
		  /* 82095570h */ case    2:  		/* cmplwi CR6, R11, 103 */
		/* 82095570h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000067);
		/* 82095570h case    2:*/		return 0x82095574;
		  /* 82095574h */ case    3:  		/* bc 4, CR6_EQ, 72 */
		/* 82095574h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820955BC;  }
		/* 82095574h case    3:*/		return 0x82095578;
		  /* 82095578h */ case    4:  		/* li R23, 1 */
		/* 82095578h case    4:*/		cpu::op::li<0>(regs,&regs.R23,0x1);
		/* 82095578h case    4:*/		return 0x8209557C;
		  /* 8209557Ch */ case    5:  		/* b 64 */
		/* 8209557Ch case    5:*/		return 0x820955BC;
		/* 8209557Ch case    5:*/		return 0x82095580;
	}
	return 0x82095580;
} // Block from 82095568h-82095580h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82095580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095580);
		  /* 82095580h */ case    0:  		/* cmpwi CR6, R23, 512 */
		/* 82095580h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000200);
		/* 82095580h case    0:*/		return 0x82095584;
		  /* 82095584h */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 82095584h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8209558C;  }
		/* 82095584h case    1:*/		return 0x82095588;
		  /* 82095588h */ case    2:  		/* li R23, 512 */
		/* 82095588h case    2:*/		cpu::op::li<0>(regs,&regs.R23,0x200);
		/* 82095588h case    2:*/		return 0x8209558C;
	}
	return 0x8209558C;
} // Block from 82095580h-8209558Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209558Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209558C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209558C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209558C);
		  /* 8209558Ch */ case    0:  		/* cmpwi CR6, R23, 163 */
		/* 8209558Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x000000A3);
		/* 8209558Ch case    0:*/		return 0x82095590;
		  /* 82095590h */ case    1:  		/* bc 4, CR6_GT, 44 */
		/* 82095590h case    1:*/		if ( !regs.CR[6].gt ) { return 0x820955BC;  }
		/* 82095590h case    1:*/		return 0x82095594;
		  /* 82095594h */ case    2:  		/* addi R31, R23, 349 */
		/* 82095594h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R23,0x15D);
		/* 82095594h case    2:*/		return 0x82095598;
		  /* 82095598h */ case    3:  		/* mr R3, R31 */
		/* 82095598h case    3:*/		regs.R3 = regs.R31;
		/* 82095598h case    3:*/		return 0x8209559C;
		  /* 8209559Ch */ case    4:  		/* bl -7444 */
		/* 8209559Ch case    4:*/		regs.LR = 0x820955A0; return 0x82093888;
		/* 8209559Ch case    4:*/		return 0x820955A0;
		  /* 820955A0h */ case    5:  		/* stw R3, <#[R1 + 112]> */
		/* 820955A0h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000070) );
		/* 820955A0h case    5:*/		return 0x820955A4;
		  /* 820955A4h */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 820955A4h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820955A4h case    6:*/		return 0x820955A8;
		  /* 820955A8h */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 820955A8h case    7:*/		if ( regs.CR[0].eq ) { return 0x820955B8;  }
		/* 820955A8h case    7:*/		return 0x820955AC;
		  /* 820955ACh */ case    8:  		/* mr R27, R3 */
		/* 820955ACh case    8:*/		regs.R27 = regs.R3;
		/* 820955ACh case    8:*/		return 0x820955B0;
		  /* 820955B0h */ case    9:  		/* mr R30, R31 */
		/* 820955B0h case    9:*/		regs.R30 = regs.R31;
		/* 820955B0h case    9:*/		return 0x820955B4;
		  /* 820955B4h */ case   10:  		/* b 8 */
		/* 820955B4h case   10:*/		return 0x820955BC;
		/* 820955B4h case   10:*/		return 0x820955B8;
	}
	return 0x820955B8;
} // Block from 8209558Ch-820955B8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820955B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820955B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820955B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820955B8);
		  /* 820955B8h */ case    0:  		/* li R23, 163 */
		/* 820955B8h case    0:*/		cpu::op::li<0>(regs,&regs.R23,0xA3);
		/* 820955B8h case    0:*/		return 0x820955BC;
	}
	return 0x820955BC;
} // Block from 820955B8h-820955BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820955BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820955BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820955BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820955BC);
		  /* 820955BCh */ case    0:  		/* addi R11, R24, 7 */
		/* 820955BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x7);
		/* 820955BCh case    0:*/		return 0x820955C0;
		  /* 820955C0h */ case    1:  		/* lwz R10, <#[R19 + 24]> */
		/* 820955C0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R19 + 0x00000018) );
		/* 820955C0h case    1:*/		return 0x820955C4;
		  /* 820955C4h */ case    2:  		/* mr R9, R22 */
		/* 820955C4h case    2:*/		regs.R9 = regs.R22;
		/* 820955C4h case    2:*/		return 0x820955C8;
		  /* 820955C8h */ case    3:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 820955C8h case    3:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 820955C8h case    3:*/		return 0x820955CC;
		  /* 820955CCh */ case    4:  		/* mr R8, R18 */
		/* 820955CCh case    4:*/		regs.R8 = regs.R18;
		/* 820955CCh case    4:*/		return 0x820955D0;
		  /* 820955D0h */ case    5:  		/* mr R7, R23 */
		/* 820955D0h case    5:*/		regs.R7 = regs.R23;
		/* 820955D0h case    5:*/		return 0x820955D4;
		  /* 820955D4h */ case    6:  		/* mtspr CTR, R10 */
		/* 820955D4h case    6:*/		regs.CTR = regs.R10;
		/* 820955D4h case    6:*/		return 0x820955D8;
		  /* 820955D8h */ case    7:  		/* extsb R6, R29 */
		/* 820955D8h case    7:*/		cpu::op::extsb<0>(regs,&regs.R6,regs.R29);
		/* 820955D8h case    7:*/		return 0x820955DC;
		  /* 820955DCh */ case    8:  		/* mr R5, R30 */
		/* 820955DCh case    8:*/		regs.R5 = regs.R30;
		/* 820955DCh case    8:*/		return 0x820955E0;
		  /* 820955E0h */ case    9:  		/* ld R10, <#[R11]> */
		/* 820955E0h case    9:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820955E0h case    9:*/		return 0x820955E4;
		  /* 820955E4h */ case   10:  		/* mr R4, R27 */
		/* 820955E4h case   10:*/		regs.R4 = regs.R27;
		/* 820955E4h case   10:*/		return 0x820955E8;
		  /* 820955E8h */ case   11:  		/* addi R3, R1, 120 */
		/* 820955E8h case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x78);
		/* 820955E8h case   11:*/		return 0x820955EC;
		  /* 820955ECh */ case   12:  		/* addi R24, R11, 8 */
		/* 820955ECh case   12:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x8);
		/* 820955ECh case   12:*/		return 0x820955F0;
		  /* 820955F0h */ case   13:  		/* std R10, <#[R1 + 120]> */
		/* 820955F0h case   13:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000078) );
		/* 820955F0h case   13:*/		return 0x820955F4;
		  /* 820955F4h */ case   14:  		/* bcctrl 20, CR0_LT */
		/* 820955F4h case   14:*/		if ( 1 ) { regs.LR = 0x820955F8; return (uint32)regs.CTR; }
		/* 820955F4h case   14:*/		return 0x820955F8;
		  /* 820955F8h */ case   15:  		/* rlwinm. R31, R25, 0, 24, 24 */
		/* 820955F8h case   15:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R31,regs.R25);
		/* 820955F8h case   15:*/		return 0x820955FC;
		  /* 820955FCh */ case   16:  		/* bc 12, CR0_EQ, 32 */
		/* 820955FCh case   16:*/		if ( regs.CR[0].eq ) { return 0x8209561C;  }
		/* 820955FCh case   16:*/		return 0x82095600;
		  /* 82095600h */ case   17:  		/* cmpwi CR6, R23, 0 */
		/* 82095600h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 82095600h case   17:*/		return 0x82095604;
		  /* 82095604h */ case   18:  		/* bc 4, CR6_EQ, 24 */
		/* 82095604h case   18:*/		if ( !regs.CR[6].eq ) { return 0x8209561C;  }
		/* 82095604h case   18:*/		return 0x82095608;
	}
	return 0x82095608;
} // Block from 820955BCh-82095608h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82095608h
// Function 'write_char'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095608);
		  /* 82095608h */ case    0:  		/* lwz R11, <#[R19 + 36]> */
		/* 82095608h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000024) );
		/* 82095608h case    0:*/		return 0x8209560C;
		  /* 8209560Ch */ case    1:  		/* mr R4, R22 */
		/* 8209560Ch case    1:*/		regs.R4 = regs.R22;
		/* 8209560Ch case    1:*/		return 0x82095610;
		  /* 82095610h */ case    2:  		/* mr R3, R27 */
		/* 82095610h case    2:*/		regs.R3 = regs.R27;
		/* 82095610h case    2:*/		return 0x82095614;
		  /* 82095614h */ case    3:  		/* mtspr CTR, R11 */
		/* 82095614h case    3:*/		regs.CTR = regs.R11;
		/* 82095614h case    3:*/		return 0x82095618;
		  /* 82095618h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 82095618h case    4:*/		if ( 1 ) { regs.LR = 0x8209561C; return (uint32)regs.CTR; }
		/* 82095618h case    4:*/		return 0x8209561C;
	}
	return 0x8209561C;
} // Block from 82095608h-8209561Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209561Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209561C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209561C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209561C);
		  /* 8209561Ch */ case    0:  		/* rlwinm R11, R29, 0, 16, 31 */
		/* 8209561Ch case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R29);
		/* 8209561Ch case    0:*/		return 0x82095620;
		  /* 82095620h */ case    1:  		/* cmplwi CR6, R11, 103 */
		/* 82095620h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000067);
		/* 82095620h case    1:*/		return 0x82095624;
		  /* 82095624h */ case    2:  		/* bc 4, CR6_EQ, 32 */
		/* 82095624h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82095644;  }
		/* 82095624h case    2:*/		return 0x82095628;
		  /* 82095628h */ case    3:  		/* cmpwi CR6, R31, 0 */
		/* 82095628h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82095628h case    3:*/		return 0x8209562C;
		  /* 8209562Ch */ case    4:  		/* bc 4, CR6_EQ, 24 */
		/* 8209562Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x82095644;  }
		/* 8209562Ch case    4:*/		return 0x82095630;
		  /* 82095630h */ case    5:  		/* lwz R11, <#[R19 + 32]> */
		/* 82095630h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000020) );
		/* 82095630h case    5:*/		return 0x82095634;
		  /* 82095634h */ case    6:  		/* mr R4, R22 */
		/* 82095634h case    6:*/		regs.R4 = regs.R22;
		/* 82095634h case    6:*/		return 0x82095638;
		  /* 82095638h */ case    7:  		/* mr R3, R27 */
		/* 82095638h case    7:*/		regs.R3 = regs.R27;
		/* 82095638h case    7:*/		return 0x8209563C;
		  /* 8209563Ch */ case    8:  		/* mtspr CTR, R11 */
		/* 8209563Ch case    8:*/		regs.CTR = regs.R11;
		/* 8209563Ch case    8:*/		return 0x82095640;
		  /* 82095640h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 82095640h case    9:*/		if ( 1 ) { regs.LR = 0x82095644; return (uint32)regs.CTR; }
		/* 82095640h case    9:*/		return 0x82095644;
	}
	return 0x82095644;
} // Block from 8209561Ch-82095644h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82095644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095644);
		  /* 82095644h */ case    0:  		/* lbz R11, <#[R27]> */
		/* 82095644h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82095644h case    0:*/		return 0x82095648;
		  /* 82095648h */ case    1:  		/* cmplwi CR6, R11, 45 */
		/* 82095648h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002D);
		/* 82095648h case    1:*/		return 0x8209564C;
		  /* 8209564Ch */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 8209564Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82095658;  }
		/* 8209564Ch case    2:*/		return 0x82095650;
		  /* 82095650h */ case    3:  		/* ori R25, R25, 256 */
		/* 82095650h case    3:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x100);
		/* 82095650h case    3:*/		return 0x82095654;
		  /* 82095654h */ case    4:  		/* addi R27, R27, 1 */
		/* 82095654h case    4:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82095654h case    4:*/		return 0x82095658;
	}
	return 0x82095658;
} // Block from 82095644h-82095658h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82095658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095658);
		  /* 82095658h */ case    0:  		/* mr R11, R27 */
		/* 82095658h case    0:*/		regs.R11 = regs.R27;
		/* 82095658h case    0:*/		return 0x8209565C;
		  /* 8209565Ch */ case    1:  		/* lbz R10, <#[R11]> */
		/* 8209565Ch case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209565Ch case    1:*/		return 0x82095660;
		  /* 82095660h */ case    2:  		/* addi R11, R11, 1 */
		/* 82095660h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82095660h case    2:*/		return 0x82095664;
		  /* 82095664h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 82095664h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82095664h case    3:*/		return 0x82095668;
		  /* 82095668h */ case    4:  		/* bc 4, CR6_EQ, -12 */
		/* 82095668h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8209565C;  }
		/* 82095668h case    4:*/		return 0x8209566C;
		  /* 8209566Ch */ case    5:  		/* subf R11, R27, R11 */
		/* 8209566Ch case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R27,regs.R11);
		/* 8209566Ch case    5:*/		return 0x82095670;
	}
	return 0x82095670;
} // Block from 82095658h-82095670h (6 instructions)

