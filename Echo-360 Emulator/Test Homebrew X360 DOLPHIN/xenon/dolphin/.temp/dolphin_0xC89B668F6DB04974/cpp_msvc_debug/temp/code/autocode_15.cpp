#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 820F5714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5714);
		  /* 820F5714h */ case    0:  		/* rlwinm R29, R30, 4, 0, 27 */
		/* 820F5714h case    0:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R29,regs.R30);
		/* 820F5714h case    0:*/		return 0x820F5718;
		  /* 820F5718h */ case    1:  		/* lis R4, 9345 */
		/* 820F5718h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F5718h case    1:*/		return 0x820F571C;
		  /* 820F571Ch */ case    2:  		/* mr R3, R29 */
		/* 820F571Ch case    2:*/		regs.R3 = regs.R29;
		/* 820F571Ch case    2:*/		return 0x820F5720;
		  /* 820F5720h */ case    3:  		/* bl -447776 */
		/* 820F5720h case    3:*/		regs.LR = 0x820F5724; return 0x82088200;
		/* 820F5720h case    3:*/		return 0x820F5724;
		  /* 820F5724h */ case    4:  		/* or. R16, R3, R3 */
		/* 820F5724h case    4:*/		cpu::op::or<1>(regs,&regs.R16,regs.R3,regs.R3);
		/* 820F5724h case    4:*/		return 0x820F5728;
		  /* 820F5728h */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 820F5728h case    5:*/		if ( !regs.CR[0].eq ) { return 0x820F5738;  }
		/* 820F5728h case    5:*/		return 0x820F572C;
	}
	return 0x820F572C;
} // Block from 820F5714h-820F572Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F572Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F572C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F572C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F572C);
		  /* 820F572Ch */ case    0:  		/* lis R30, -32761 */
		/* 820F572Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8007);
		/* 820F572Ch case    0:*/		return 0x820F5730;
		  /* 820F5730h */ case    1:  		/* ori R30, R30, 14 */
		/* 820F5730h case    1:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0xE);
		/* 820F5730h case    1:*/		return 0x820F5734;
		  /* 820F5734h */ case    2:  		/* b 1504 */
		/* 820F5734h case    2:*/		return 0x820F5D14;
		/* 820F5734h case    2:*/		return 0x820F5738;
	}
	return 0x820F5738;
} // Block from 820F572Ch-820F5738h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F5738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5738);
		  /* 820F5738h */ case    0:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820F5738h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820F5738h case    0:*/		return 0x820F573C;
		  /* 820F573Ch */ case    1:  		/* lis R4, 9345 */
		/* 820F573Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F573Ch case    1:*/		return 0x820F5740;
		  /* 820F5740h */ case    2:  		/* mr R3, R30 */
		/* 820F5740h case    2:*/		regs.R3 = regs.R30;
		/* 820F5740h case    2:*/		return 0x820F5744;
		  /* 820F5744h */ case    3:  		/* bl -447812 */
		/* 820F5744h case    3:*/		regs.LR = 0x820F5748; return 0x82088200;
		/* 820F5744h case    3:*/		return 0x820F5748;
		  /* 820F5748h */ case    4:  		/* or. R14, R3, R3 */
		/* 820F5748h case    4:*/		cpu::op::or<1>(regs,&regs.R14,regs.R3,regs.R3);
		/* 820F5748h case    4:*/		return 0x820F574C;
		  /* 820F574Ch */ case    5:  		/* bc 12, CR0_EQ, 1164 */
		/* 820F574Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820F5BD8;  }
		/* 820F574Ch case    5:*/		return 0x820F5750;
		  /* 820F5750h */ case    6:  		/* mr R5, R29 */
		/* 820F5750h case    6:*/		regs.R5 = regs.R29;
		/* 820F5750h case    6:*/		return 0x820F5754;
		  /* 820F5754h */ case    7:  		/* li R4, 0 */
		/* 820F5754h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F5754h case    7:*/		return 0x820F5758;
		  /* 820F5758h */ case    8:  		/* mr R3, R16 */
		/* 820F5758h case    8:*/		regs.R3 = regs.R16;
		/* 820F5758h case    8:*/		return 0x820F575C;
		  /* 820F575Ch */ case    9:  		/* bl -410652 */
		/* 820F575Ch case    9:*/		regs.LR = 0x820F5760; return 0x82091340;
		/* 820F575Ch case    9:*/		return 0x820F5760;
		  /* 820F5760h */ case   10:  		/* mr R5, R30 */
		/* 820F5760h case   10:*/		regs.R5 = regs.R30;
		/* 820F5760h case   10:*/		return 0x820F5764;
		  /* 820F5764h */ case   11:  		/* li R4, 0 */
		/* 820F5764h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F5764h case   11:*/		return 0x820F5768;
		  /* 820F5768h */ case   12:  		/* mr R3, R14 */
		/* 820F5768h case   12:*/		regs.R3 = regs.R14;
		/* 820F5768h case   12:*/		return 0x820F576C;
		  /* 820F576Ch */ case   13:  		/* bl -410668 */
		/* 820F576Ch case   13:*/		regs.LR = 0x820F5770; return 0x82091340;
		/* 820F576Ch case   13:*/		return 0x820F5770;
		  /* 820F5770h */ case   14:  		/* lwz R11, <#[R31 + 8]> */
		/* 820F5770h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820F5770h case   14:*/		return 0x820F5774;
		  /* 820F5774h */ case   15:  		/* mr R6, R23 */
		/* 820F5774h case   15:*/		regs.R6 = regs.R23;
		/* 820F5774h case   15:*/		return 0x820F5778;
		  /* 820F5778h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 820F5778h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F5778h case   16:*/		return 0x820F577C;
		  /* 820F577Ch */ case   17:  		/* bc 4, CR6_GT, 196 */
		/* 820F577Ch case   17:*/		if ( !regs.CR[6].gt ) { return 0x820F5840;  }
		/* 820F577Ch case   17:*/		return 0x820F5780;
		  /* 820F5780h */ case   18:  		/* mr R7, R23 */
		/* 820F5780h case   18:*/		regs.R7 = regs.R23;
		/* 820F5780h case   18:*/		return 0x820F5784;
		  /* 820F5784h */ case   19:  		/* lwz R11, <#[R31 + 20]> */
		/* 820F5784h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820F5784h case   19:*/		return 0x820F5788;
		  /* 820F5788h */ case   20:  		/* lwz R9, <#[R31 + 16]> */
		/* 820F5788h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 820F5788h case   20:*/		return 0x820F578C;
		  /* 820F578Ch */ case   21:  		/* lwzx R10, <#[R11 + R7]> */
		/* 820F578Ch case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820F578Ch case   21:*/		return 0x820F5790;
		  /* 820F5790h */ case   22:  		/* lwz R11, <#[R10 + 4]> */
		/* 820F5790h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 820F5790h case   22:*/		return 0x820F5794;
		  /* 820F5794h */ case   23:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F5794h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F5794h case   23:*/		return 0x820F5798;
		  /* 820F5798h */ case   24:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820F5798h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F5798h case   24:*/		return 0x820F579C;
		  /* 820F579Ch */ case   25:  		/* lwz R11, <#[R11 + 4]> */
		/* 820F579Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820F579Ch case   25:*/		return 0x820F57A0;
		  /* 820F57A0h */ case   26:  		/* rlwinm. R9, R11, 0, 23, 23 */
		/* 820F57A0h case   26:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R9,regs.R11);
		/* 820F57A0h case   26:*/		return 0x820F57A4;
		  /* 820F57A4h */ case   27:  		/* bc 12, CR0_EQ, 136 */
		/* 820F57A4h case   27:*/		if ( regs.CR[0].eq ) { return 0x820F582C;  }
		/* 820F57A4h case   27:*/		return 0x820F57A8;
		  /* 820F57A8h */ case   28:  		/* lwz R9, <#[R10 + 8]> */
		/* 820F57A8h case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 820F57A8h case   28:*/		return 0x820F57AC;
		  /* 820F57ACh */ case   29:  		/* cmpwi CR6, R9, -1 */
		/* 820F57ACh case   29:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 820F57ACh case   29:*/		return 0x820F57B0;
		  /* 820F57B0h */ case   30:  		/* bc 4, CR6_EQ, 124 */
		/* 820F57B0h case   30:*/		if ( !regs.CR[6].eq ) { return 0x820F582C;  }
		/* 820F57B0h case   30:*/		return 0x820F57B4;
		  /* 820F57B4h */ case   31:  		/* lwz R9, <#[R10 + 56]> */
		/* 820F57B4h case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000038) );
		/* 820F57B4h case   31:*/		return 0x820F57B8;
		  /* 820F57B8h */ case   32:  		/* cmpwi CR6, R9, -1 */
		/* 820F57B8h case   32:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 820F57B8h case   32:*/		return 0x820F57BC;
		  /* 820F57BCh */ case   33:  		/* bc 4, CR6_EQ, 112 */
		/* 820F57BCh case   33:*/		if ( !regs.CR[6].eq ) { return 0x820F582C;  }
		/* 820F57BCh case   33:*/		return 0x820F57C0;
		  /* 820F57C0h */ case   34:  		/* rlwinm. R11, R11, 0, 13, 13 */
		/* 820F57C0h case   34:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R11,regs.R11);
		/* 820F57C0h case   34:*/		return 0x820F57C4;
		  /* 820F57C4h */ case   35:  		/* bc 12, CR0_EQ, 104 */
		/* 820F57C4h case   35:*/		if ( regs.CR[0].eq ) { return 0x820F582C;  }
		/* 820F57C4h case   35:*/		return 0x820F57C8;
		  /* 820F57C8h */ case   36:  		/* mr R11, R23 */
		/* 820F57C8h case   36:*/		regs.R11 = regs.R23;
		/* 820F57C8h case   36:*/		return 0x820F57CC;
		  /* 820F57CCh */ case   37:  		/* cmplwi CR6, R26, 0 */
		/* 820F57CCh case   37:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 820F57CCh case   37:*/		return 0x820F57D0;
		  /* 820F57D0h */ case   38:  		/* bc 12, CR6_EQ, 40 */
		/* 820F57D0h case   38:*/		if ( regs.CR[6].eq ) { return 0x820F57F8;  }
		/* 820F57D0h case   38:*/		return 0x820F57D4;
		  /* 820F57D4h */ case   39:  		/* lwz R8, <#[R10 + 12]> */
		/* 820F57D4h case   39:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x0000000C) );
		/* 820F57D4h case   39:*/		return 0x820F57D8;
		  /* 820F57D8h */ case   40:  		/* mr R9, R14 */
		/* 820F57D8h case   40:*/		regs.R9 = regs.R14;
		/* 820F57D8h case   40:*/		return 0x820F57DC;
		  /* 820F57DCh */ case   41:  		/* lwz R5, <#[R9]> */
		/* 820F57DCh case   41:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000000) );
		/* 820F57DCh case   41:*/		return 0x820F57E0;
		  /* 820F57E0h */ case   42:  		/* cmplw CR6, R5, R8 */
		/* 820F57E0h case   42:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R8);
		/* 820F57E0h case   42:*/		return 0x820F57E4;
		  /* 820F57E4h */ case   43:  		/* bc 12, CR6_EQ, 20 */
		/* 820F57E4h case   43:*/		if ( regs.CR[6].eq ) { return 0x820F57F8;  }
		/* 820F57E4h case   43:*/		return 0x820F57E8;
		  /* 820F57E8h */ case   44:  		/* addi R11, R11, 1 */
		/* 820F57E8h case   44:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F57E8h case   44:*/		return 0x820F57EC;
		  /* 820F57ECh */ case   45:  		/* addi R9, R9, 4 */
		/* 820F57ECh case   45:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820F57ECh case   45:*/		return 0x820F57F0;
		  /* 820F57F0h */ case   46:  		/* cmplw CR6, R11, R26 */
		/* 820F57F0h case   46:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 820F57F0h case   46:*/		return 0x820F57F4;
		  /* 820F57F4h */ case   47:  		/* bc 12, CR6_LT, -24 */
		/* 820F57F4h case   47:*/		if ( regs.CR[6].lt ) { return 0x820F57DC;  }
		/* 820F57F4h case   47:*/		return 0x820F57F8;
	}
	return 0x820F57F8;
} // Block from 820F5738h-820F57F8h (48 instructions)

//////////////////////////////////////////////////////
// Block at 820F57F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F57F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F57F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F57F8);
		  /* 820F57F8h */ case    0:  		/* cmplw CR6, R11, R26 */
		/* 820F57F8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 820F57F8h case    0:*/		return 0x820F57FC;
		  /* 820F57FCh */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 820F57FCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F5810;  }
		/* 820F57FCh case    1:*/		return 0x820F5800;
		  /* 820F5800h */ case    2:  		/* lwz R9, <#[R10 + 12]> */
		/* 820F5800h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		/* 820F5800h case    2:*/		return 0x820F5804;
		  /* 820F5804h */ case    3:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 820F5804h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 820F5804h case    3:*/		return 0x820F5808;
		  /* 820F5808h */ case    4:  		/* addi R26, R26, 1 */
		/* 820F5808h case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820F5808h case    4:*/		return 0x820F580C;
		  /* 820F580Ch */ case    5:  		/* stwx R9, <#[R8 + R14]> */
		/* 820F580Ch case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + regs.R14 + 0x00000000) );
		/* 820F580Ch case    5:*/		return 0x820F5810;
	}
	return 0x820F5810;
} // Block from 820F57F8h-820F5810h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F5810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5810);
		  /* 820F5810h */ case    0:  		/* lwz R9, <#[R10 + 16]> */
		/* 820F5810h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 820F5810h case    0:*/		return 0x820F5814;
		  /* 820F5814h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F5814h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F5814h case    1:*/		return 0x820F5818;
		  /* 820F5818h */ case    2:  		/* lfd FR0, <#[R10 + 32]> */
		/* 820F5818h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 820F5818h case    2:*/		return 0x820F581C;
		  /* 820F581Ch */ case    3:  		/* add R11, R11, R9 */
		/* 820F581Ch case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820F581Ch case    3:*/		return 0x820F5820;
		  /* 820F5820h */ case    4:  		/* fctidz FR0, FR0 */
		/* 820F5820h case    4:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR0);
		/* 820F5820h case    4:*/		return 0x820F5824;
		  /* 820F5824h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F5824h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F5824h case    5:*/		return 0x820F5828;
		  /* 820F5828h */ case    6:  		/* stfiwx FR0, <#[R11 + R16]> */
		/* 820F5828h case    6:*/		cpu::mem::store32( regs, regs.FR0, (uint32)(regs.R11 + regs.R16 + 0x00000000) );
		/* 820F5828h case    6:*/		return 0x820F582C;
	}
	return 0x820F582C;
} // Block from 820F5810h-820F582Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F582Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F582C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F582C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F582C);
		  /* 820F582Ch */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820F582Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820F582Ch case    0:*/		return 0x820F5830;
		  /* 820F5830h */ case    1:  		/* addi R6, R6, 1 */
		/* 820F5830h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820F5830h case    1:*/		return 0x820F5834;
		  /* 820F5834h */ case    2:  		/* addi R7, R7, 4 */
		/* 820F5834h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 820F5834h case    2:*/		return 0x820F5838;
		  /* 820F5838h */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 820F5838h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 820F5838h case    3:*/		return 0x820F583C;
		  /* 820F583Ch */ case    4:  		/* bc 12, CR6_LT, -184 */
		/* 820F583Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x820F5784;  }
		/* 820F583Ch case    4:*/		return 0x820F5840;
	}
	return 0x820F5840;
} // Block from 820F582Ch-820F5840h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F5840h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5840);
		  /* 820F5840h */ case    0:  		/* mr R27, R23 */
		/* 820F5840h case    0:*/		regs.R27 = regs.R23;
		/* 820F5840h case    0:*/		return 0x820F5844;
		  /* 820F5844h */ case    1:  		/* cmplwi CR6, R26, 0 */
		/* 820F5844h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 820F5844h case    1:*/		return 0x820F5848;
		  /* 820F5848h */ case    2:  		/* bc 12, CR6_EQ, 68 */
		/* 820F5848h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F588C;  }
		/* 820F5848h case    2:*/		return 0x820F584C;
		  /* 820F584Ch */ case    3:  		/* mr R28, R14 */
		/* 820F584Ch case    3:*/		regs.R28 = regs.R14;
		/* 820F584Ch case    3:*/		return 0x820F5850;
		  /* 820F5850h */ case    4:  		/* mr R29, R16 */
		/* 820F5850h case    4:*/		regs.R29 = regs.R16;
		/* 820F5850h case    4:*/		return 0x820F5854;
		  /* 820F5854h */ case    5:  		/* lwz R11, <#[R31]> */
		/* 820F5854h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F5854h case    5:*/		return 0x820F5858;
		  /* 820F5858h */ case    6:  		/* mr R5, R29 */
		/* 820F5858h case    6:*/		regs.R5 = regs.R29;
		/* 820F5858h case    6:*/		return 0x820F585C;
		  /* 820F585Ch */ case    7:  		/* mr R3, R31 */
		/* 820F585Ch case    7:*/		regs.R3 = regs.R31;
		/* 820F585Ch case    7:*/		return 0x820F5860;
		  /* 820F5860h */ case    8:  		/* lwz R4, <#[R28]> */
		/* 820F5860h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000000) );
		/* 820F5860h case    8:*/		return 0x820F5864;
		  /* 820F5864h */ case    9:  		/* lwz R11, <#[R11 + 64]> */
		/* 820F5864h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000040) );
		/* 820F5864h case    9:*/		return 0x820F5868;
		  /* 820F5868h */ case   10:  		/* mtspr CTR, R11 */
		/* 820F5868h case   10:*/		regs.CTR = regs.R11;
		/* 820F5868h case   10:*/		return 0x820F586C;
		  /* 820F586Ch */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 820F586Ch case   11:*/		if ( 1 ) { regs.LR = 0x820F5870; return (uint32)regs.CTR; }
		/* 820F586Ch case   11:*/		return 0x820F5870;
		  /* 820F5870h */ case   12:  		/* or. R30, R3, R3 */
		/* 820F5870h case   12:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F5870h case   12:*/		return 0x820F5874;
		  /* 820F5874h */ case   13:  		/* bc 12, CR0_LT, 1184 */
		/* 820F5874h case   13:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F5874h case   13:*/		return 0x820F5878;
		  /* 820F5878h */ case   14:  		/* addi R27, R27, 1 */
		/* 820F5878h case   14:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 820F5878h case   14:*/		return 0x820F587C;
		  /* 820F587Ch */ case   15:  		/* addi R29, R29, 16 */
		/* 820F587Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x10);
		/* 820F587Ch case   15:*/		return 0x820F5880;
		  /* 820F5880h */ case   16:  		/* addi R28, R28, 4 */
		/* 820F5880h case   16:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820F5880h case   16:*/		return 0x820F5884;
		  /* 820F5884h */ case   17:  		/* cmplw CR6, R27, R26 */
		/* 820F5884h case   17:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R26);
		/* 820F5884h case   17:*/		return 0x820F5888;
		  /* 820F5888h */ case   18:  		/* bc 12, CR6_LT, -52 */
		/* 820F5888h case   18:*/		if ( regs.CR[6].lt ) { return 0x820F5854;  }
		/* 820F5888h case   18:*/		return 0x820F588C;
	}
	return 0x820F588C;
} // Block from 820F5840h-820F588Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 820F588Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F588C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F588C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F588C);
		  /* 820F588Ch */ case    0:  		/* lwz R11, <#[R31 + 68]> */
		/* 820F588Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000044) );
		/* 820F588Ch case    0:*/		return 0x820F5890;
		  /* 820F5890h */ case    1:  		/* mr R3, R31 */
		/* 820F5890h case    1:*/		regs.R3 = regs.R31;
		/* 820F5890h case    1:*/		return 0x820F5894;
		  /* 820F5894h */ case    2:  		/* cmplw CR6, R25, R11 */
		/* 820F5894h case    2:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 820F5894h case    2:*/		return 0x820F5898;
		  /* 820F5898h */ case    3:  		/* bc 4, CR6_GT, 24 */
		/* 820F5898h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820F58B0;  }
		/* 820F5898h case    3:*/		return 0x820F589C;
		  /* 820F589Ch */ case    4:  		/* lis R11, -32254 */
		/* 820F589Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F589Ch case    4:*/		return 0x820F58A0;
		  /* 820F58A0h */ case    5:  		/* li R5, 4506 */
		/* 820F58A0h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x119A);
		/* 820F58A0h case    5:*/		return 0x820F58A4;
		  /* 820F58A4h */ case    6:  		/* addi R6, R11, -15968 */
		/* 820F58A4h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFC1A0);
		/* 820F58A4h case    6:*/		return 0x820F58A8;
		  /* 820F58A8h */ case    7:  		/* li R4, 0 */
		/* 820F58A8h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F58A8h case    7:*/		return 0x820F58AC;
		  /* 820F58ACh */ case    8:  		/* b 844 */
		/* 820F58ACh case    8:*/		return 0x820F5BF8;
		/* 820F58ACh case    8:*/		return 0x820F58B0;
	}
	return 0x820F58B0;
} // Block from 820F588Ch-820F58B0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F58B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F58B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F58B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F58B0);
		  /* 820F58B0h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820F58B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F58B0h case    0:*/		return 0x820F58B4;
		  /* 820F58B4h */ case    1:  		/* lwz R11, <#[R11 + 80]> */
		/* 820F58B4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 820F58B4h case    1:*/		return 0x820F58B8;
		  /* 820F58B8h */ case    2:  		/* mtspr CTR, R11 */
		/* 820F58B8h case    2:*/		regs.CTR = regs.R11;
		/* 820F58B8h case    2:*/		return 0x820F58BC;
		  /* 820F58BCh */ case    3:  		/* bcctrl 20, CR0_LT */
		/* 820F58BCh case    3:*/		if ( 1 ) { regs.LR = 0x820F58C0; return (uint32)regs.CTR; }
		/* 820F58BCh case    3:*/		return 0x820F58C0;
		  /* 820F58C0h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820F58C0h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F58C0h case    4:*/		return 0x820F58C4;
		  /* 820F58C4h */ case    5:  		/* bc 12, CR0_LT, 788 */
		/* 820F58C4h case    5:*/		if ( regs.CR[0].lt ) { return 0x820F5BD8;  }
		/* 820F58C4h case    5:*/		return 0x820F58C8;
		  /* 820F58C8h */ case    6:  		/* cmplwi CR6, R22, 0 */
		/* 820F58C8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 820F58C8h case    6:*/		return 0x820F58CC;
		  /* 820F58CCh */ case    7:  		/* bc 12, CR6_EQ, 40 */
		/* 820F58CCh case    7:*/		if ( regs.CR[6].eq ) { return 0x820F58F4;  }
		/* 820F58CCh case    7:*/		return 0x820F58D0;
		  /* 820F58D0h */ case    8:  		/* lwz R11, <#[R31]> */
		/* 820F58D0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F58D0h case    8:*/		return 0x820F58D4;
		  /* 820F58D4h */ case    9:  		/* mr R5, R20 */
		/* 820F58D4h case    9:*/		regs.R5 = regs.R20;
		/* 820F58D4h case    9:*/		return 0x820F58D8;
		  /* 820F58D8h */ case   10:  		/* mr R4, R22 */
		/* 820F58D8h case   10:*/		regs.R4 = regs.R22;
		/* 820F58D8h case   10:*/		return 0x820F58DC;
		  /* 820F58DCh */ case   11:  		/* mr R3, R31 */
		/* 820F58DCh case   11:*/		regs.R3 = regs.R31;
		/* 820F58DCh case   11:*/		return 0x820F58E0;
		  /* 820F58E0h */ case   12:  		/* lwz R11, <#[R11 + 88]> */
		/* 820F58E0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000058) );
		/* 820F58E0h case   12:*/		return 0x820F58E4;
		  /* 820F58E4h */ case   13:  		/* mtspr CTR, R11 */
		/* 820F58E4h case   13:*/		regs.CTR = regs.R11;
		/* 820F58E4h case   13:*/		return 0x820F58E8;
		  /* 820F58E8h */ case   14:  		/* bcctrl 20, CR0_LT */
		/* 820F58E8h case   14:*/		if ( 1 ) { regs.LR = 0x820F58EC; return (uint32)regs.CTR; }
		/* 820F58E8h case   14:*/		return 0x820F58EC;
		  /* 820F58ECh */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 820F58ECh case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F58ECh case   15:*/		return 0x820F58F0;
		  /* 820F58F0h */ case   16:  		/* bc 12, CR0_LT, 744 */
		/* 820F58F0h case   16:*/		if ( regs.CR[0].lt ) { return 0x820F5BD8;  }
		/* 820F58F0h case   16:*/		return 0x820F58F4;
	}
	return 0x820F58F4;
} // Block from 820F58B0h-820F58F4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820F58F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F58F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F58F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F58F4);
		  /* 820F58F4h */ case    0:  		/* mr R27, R23 */
		/* 820F58F4h case    0:*/		regs.R27 = regs.R23;
		/* 820F58F4h case    0:*/		return 0x820F58F8;
		  /* 820F58F8h */ case    1:  		/* cmplwi CR6, R22, 0 */
		/* 820F58F8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 820F58F8h case    1:*/		return 0x820F58FC;
		  /* 820F58FCh */ case    2:  		/* bc 12, CR6_EQ, 92 */
		/* 820F58FCh case    2:*/		if ( regs.CR[6].eq ) { return 0x820F5958;  }
		/* 820F58FCh case    2:*/		return 0x820F5900;
		  /* 820F5900h */ case    3:  		/* lwz R11, <#[R1 + 80]> */
		/* 820F5900h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820F5900h case    3:*/		return 0x820F5904;
		  /* 820F5904h */ case    4:  		/* mr R30, R20 */
		/* 820F5904h case    4:*/		regs.R30 = regs.R20;
		/* 820F5904h case    4:*/		return 0x820F5908;
		  /* 820F5908h */ case    5:  		/* mr R29, R22 */
		/* 820F5908h case    5:*/		regs.R29 = regs.R22;
		/* 820F5908h case    5:*/		return 0x820F590C;
		  /* 820F590Ch */ case    6:  		/* subf R28, R20, R11 */
		/* 820F590Ch case    6:*/		cpu::op::subf<0>(regs,&regs.R28,regs.R20,regs.R11);
		/* 820F590Ch case    6:*/		return 0x820F5910;
		  /* 820F5910h */ case    7:  		/* lwz R4, <#[R30]> */
		/* 820F5910h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000000) );
		/* 820F5910h case    7:*/		return 0x820F5914;
		  /* 820F5914h */ case    8:  		/* cmplwi CR6, R4, 0 */
		/* 820F5914h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820F5914h case    8:*/		return 0x820F5918;
		  /* 820F5918h */ case    9:  		/* bc 12, CR6_EQ, 52 */
		/* 820F5918h case    9:*/		if ( regs.CR[6].eq ) { return 0x820F594C;  }
		/* 820F5918h case    9:*/		return 0x820F591C;
		  /* 820F591Ch */ case   10:  		/* lwz R11, <#[R4]> */
		/* 820F591Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820F591Ch case   10:*/		return 0x820F5920;
		  /* 820F5920h */ case   11:  		/* rlwinm. R11, R11, 0, 3, 3 */
		/* 820F5920h case   11:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R11,regs.R11);
		/* 820F5920h case   11:*/		return 0x820F5924;
		  /* 820F5924h */ case   12:  		/* bc 4, CR0_EQ, 40 */
		/* 820F5924h case   12:*/		if ( !regs.CR[0].eq ) { return 0x820F594C;  }
		/* 820F5924h case   12:*/		return 0x820F5928;
		  /* 820F5928h */ case   13:  		/* lwz R11, <#[R31]> */
		/* 820F5928h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F5928h case   13:*/		return 0x820F592C;
		  /* 820F592Ch */ case   14:  		/* add R5, R28, R30 */
		/* 820F592Ch case   14:*/		cpu::op::add<0>(regs,&regs.R5,regs.R28,regs.R30);
		/* 820F592Ch case   14:*/		return 0x820F5930;
		  /* 820F5930h */ case   15:  		/* mr R3, R31 */
		/* 820F5930h case   15:*/		regs.R3 = regs.R31;
		/* 820F5930h case   15:*/		return 0x820F5934;
		  /* 820F5934h */ case   16:  		/* lwz R11, <#[R11 + 68]> */
		/* 820F5934h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000044) );
		/* 820F5934h case   16:*/		return 0x820F5938;
		  /* 820F5938h */ case   17:  		/* mtspr CTR, R11 */
		/* 820F5938h case   17:*/		regs.CTR = regs.R11;
		/* 820F5938h case   17:*/		return 0x820F593C;
		  /* 820F593Ch */ case   18:  		/* bcctrl 20, CR0_LT */
		/* 820F593Ch case   18:*/		if ( 1 ) { regs.LR = 0x820F5940; return (uint32)regs.CTR; }
		/* 820F593Ch case   18:*/		return 0x820F5940;
		  /* 820F5940h */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 820F5940h case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F5940h case   19:*/		return 0x820F5944;
		  /* 820F5944h */ case   20:  		/* bc 4, CR0_LT, 8 */
		/* 820F5944h case   20:*/		if ( !regs.CR[0].lt ) { return 0x820F594C;  }
		/* 820F5944h case   20:*/		return 0x820F5948;
		  /* 820F5948h */ case   21:  		/* li R27, 1 */
		/* 820F5948h case   21:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 820F5948h case   21:*/		return 0x820F594C;
	}
	return 0x820F594C;
} // Block from 820F58F4h-820F594Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 820F594Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F594C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F594C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F594C);
		  /* 820F594Ch */ case    0:  		/* addic. R29, R29, -1 */
		/* 820F594Ch case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 820F594Ch case    0:*/		return 0x820F5950;
		  /* 820F5950h */ case    1:  		/* addi R30, R30, 4 */
		/* 820F5950h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820F5950h case    1:*/		return 0x820F5954;
		  /* 820F5954h */ case    2:  		/* bc 4, CR0_EQ, -68 */
		/* 820F5954h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820F5910;  }
		/* 820F5954h case    2:*/		return 0x820F5958;
	}
	return 0x820F5958;
} // Block from 820F594Ch-820F5958h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F5958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5958);
		  /* 820F5958h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820F5958h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F5958h case    0:*/		return 0x820F595C;
		  /* 820F595Ch */ case    1:  		/* mr R3, R31 */
		/* 820F595Ch case    1:*/		regs.R3 = regs.R31;
		/* 820F595Ch case    1:*/		return 0x820F5960;
		  /* 820F5960h */ case    2:  		/* lwz R11, <#[R11 + 76]> */
		/* 820F5960h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 820F5960h case    2:*/		return 0x820F5964;
		  /* 820F5964h */ case    3:  		/* mtspr CTR, R11 */
		/* 820F5964h case    3:*/		regs.CTR = regs.R11;
		/* 820F5964h case    3:*/		return 0x820F5968;
		  /* 820F5968h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 820F5968h case    4:*/		if ( 1 ) { regs.LR = 0x820F596C; return (uint32)regs.CTR; }
		/* 820F5968h case    4:*/		return 0x820F596C;
		  /* 820F596Ch */ case    5:  		/* or. R30, R3, R3 */
		/* 820F596Ch case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F596Ch case    5:*/		return 0x820F5970;
		  /* 820F5970h */ case    6:  		/* bc 12, CR0_LT, 932 */
		/* 820F5970h case    6:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F5970h case    6:*/		return 0x820F5974;
		  /* 820F5974h */ case    7:  		/* cmplwi CR6, R21, 0 */
		/* 820F5974h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820F5974h case    7:*/		return 0x820F5978;
		  /* 820F5978h */ case    8:  		/* bc 12, CR6_EQ, 68 */
		/* 820F5978h case    8:*/		if ( regs.CR[6].eq ) { return 0x820F59BC;  }
		/* 820F5978h case    8:*/		return 0x820F597C;
		  /* 820F597Ch */ case    9:  		/* lwz R30, <#[R1 + 84]> */
		/* 820F597Ch case    9:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 820F597Ch case    9:*/		return 0x820F5980;
		  /* 820F5980h */ case   10:  		/* mr R29, R21 */
		/* 820F5980h case   10:*/		regs.R29 = regs.R21;
		/* 820F5980h case   10:*/		return 0x820F5984;
		  /* 820F5984h */ case   11:  		/* lwz R4, <#[R30]> */
		/* 820F5984h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000000) );
		/* 820F5984h case   11:*/		return 0x820F5988;
		  /* 820F5988h */ case   12:  		/* cmplwi CR6, R4, 0 */
		/* 820F5988h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820F5988h case   12:*/		return 0x820F598C;
		  /* 820F598Ch */ case   13:  		/* bc 12, CR6_EQ, 36 */
		/* 820F598Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x820F59B0;  }
		/* 820F598Ch case   13:*/		return 0x820F5990;
		  /* 820F5990h */ case   14:  		/* lwz R11, <#[R31]> */
		/* 820F5990h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F5990h case   14:*/		return 0x820F5994;
		  /* 820F5994h */ case   15:  		/* mr R3, R31 */
		/* 820F5994h case   15:*/		regs.R3 = regs.R31;
		/* 820F5994h case   15:*/		return 0x820F5998;
		  /* 820F5998h */ case   16:  		/* lwz R11, <#[R11 + 72]> */
		/* 820F5998h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 820F5998h case   16:*/		return 0x820F599C;
		  /* 820F599Ch */ case   17:  		/* mtspr CTR, R11 */
		/* 820F599Ch case   17:*/		regs.CTR = regs.R11;
		/* 820F599Ch case   17:*/		return 0x820F59A0;
		  /* 820F59A0h */ case   18:  		/* bcctrl 20, CR0_LT */
		/* 820F59A0h case   18:*/		if ( 1 ) { regs.LR = 0x820F59A4; return (uint32)regs.CTR; }
		/* 820F59A0h case   18:*/		return 0x820F59A4;
		  /* 820F59A4h */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 820F59A4h case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F59A4h case   19:*/		return 0x820F59A8;
		  /* 820F59A8h */ case   20:  		/* bc 4, CR0_LT, 8 */
		/* 820F59A8h case   20:*/		if ( !regs.CR[0].lt ) { return 0x820F59B0;  }
		/* 820F59A8h case   20:*/		return 0x820F59AC;
		  /* 820F59ACh */ case   21:  		/* li R27, 1 */
		/* 820F59ACh case   21:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 820F59ACh case   21:*/		return 0x820F59B0;
	}
	return 0x820F59B0;
} // Block from 820F5958h-820F59B0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820F59B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F59B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F59B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F59B0);
		  /* 820F59B0h */ case    0:  		/* addic. R29, R29, -1 */
		/* 820F59B0h case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 820F59B0h case    0:*/		return 0x820F59B4;
		  /* 820F59B4h */ case    1:  		/* addi R30, R30, 4 */
		/* 820F59B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820F59B4h case    1:*/		return 0x820F59B8;
		  /* 820F59B8h */ case    2:  		/* bc 4, CR0_EQ, -52 */
		/* 820F59B8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820F5984;  }
		/* 820F59B8h case    2:*/		return 0x820F59BC;
	}
	return 0x820F59BC;
} // Block from 820F59B0h-820F59BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F59BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F59BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F59BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F59BC);
		  /* 820F59BCh */ case    0:  		/* lwz R11, <#[R31 + 112]> */
		/* 820F59BCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820F59BCh case    0:*/		return 0x820F59C0;
		  /* 820F59C0h */ case    1:  		/* cmplwi CR6, R19, 0 */
		/* 820F59C0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 820F59C0h case    1:*/		return 0x820F59C4;
		  /* 820F59C4h */ case    2:  		/* rlwinm. R11, R11, 0, 8, 8 */
		/* 820F59C4h case    2:*/		cpu::op::rlwinm<1,0,8,8>(regs,&regs.R11,regs.R11);
		/* 820F59C4h case    2:*/		return 0x820F59C8;
		  /* 820F59C8h */ case    3:  		/* bc 12, CR6_EQ, 152 */
		/* 820F59C8h case    3:*/		if ( regs.CR[6].eq ) { return 0x820F5A60;  }
		/* 820F59C8h case    3:*/		return 0x820F59CC;
		  /* 820F59CCh */ case    4:  		/* mr R30, R18 */
		/* 820F59CCh case    4:*/		regs.R30 = regs.R18;
		/* 820F59CCh case    4:*/		return 0x820F59D0;
		  /* 820F59D0h */ case    5:  		/* subf R28, R18, R15 */
		/* 820F59D0h case    5:*/		cpu::op::subf<0>(regs,&regs.R28,regs.R18,regs.R15);
		/* 820F59D0h case    5:*/		return 0x820F59D4;
		  /* 820F59D4h */ case    6:  		/* mr R29, R19 */
		/* 820F59D4h case    6:*/		regs.R29 = regs.R19;
		/* 820F59D4h case    6:*/		return 0x820F59D8;
		  /* 820F59D8h */ case    7:  		/* bc 12, CR0_EQ, 68 */
		/* 820F59D8h case    7:*/		if ( regs.CR[0].eq ) { return 0x820F5A1C;  }
		/* 820F59D8h case    7:*/		return 0x820F59DC;
		  /* 820F59DCh */ case    8:  		/* lwz R4, <#[R30]> */
		/* 820F59DCh case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000000) );
		/* 820F59DCh case    8:*/		return 0x820F59E0;
		  /* 820F59E0h */ case    9:  		/* cmplwi CR6, R4, 0 */
		/* 820F59E0h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820F59E0h case    9:*/		return 0x820F59E4;
		  /* 820F59E4h */ case   10:  		/* bc 12, CR6_EQ, 40 */
		/* 820F59E4h case   10:*/		if ( regs.CR[6].eq ) { return 0x820F5A0C;  }
		/* 820F59E4h case   10:*/		return 0x820F59E8;
		  /* 820F59E8h */ case   11:  		/* lwz R11, <#[R31]> */
		/* 820F59E8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F59E8h case   11:*/		return 0x820F59EC;
		  /* 820F59ECh */ case   12:  		/* add R5, R28, R30 */
		/* 820F59ECh case   12:*/		cpu::op::add<0>(regs,&regs.R5,regs.R28,regs.R30);
		/* 820F59ECh case   12:*/		return 0x820F59F0;
		  /* 820F59F0h */ case   13:  		/* mr R3, R31 */
		/* 820F59F0h case   13:*/		regs.R3 = regs.R31;
		/* 820F59F0h case   13:*/		return 0x820F59F4;
		  /* 820F59F4h */ case   14:  		/* lwz R11, <#[R11 + 68]> */
		/* 820F59F4h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000044) );
		/* 820F59F4h case   14:*/		return 0x820F59F8;
		  /* 820F59F8h */ case   15:  		/* mtspr CTR, R11 */
		/* 820F59F8h case   15:*/		regs.CTR = regs.R11;
		/* 820F59F8h case   15:*/		return 0x820F59FC;
		  /* 820F59FCh */ case   16:  		/* bcctrl 20, CR0_LT */
		/* 820F59FCh case   16:*/		if ( 1 ) { regs.LR = 0x820F5A00; return (uint32)regs.CTR; }
		/* 820F59FCh case   16:*/		return 0x820F5A00;
		  /* 820F5A00h */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 820F5A00h case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F5A00h case   17:*/		return 0x820F5A04;
		  /* 820F5A04h */ case   18:  		/* bc 4, CR0_LT, 8 */
		/* 820F5A04h case   18:*/		if ( !regs.CR[0].lt ) { return 0x820F5A0C;  }
		/* 820F5A04h case   18:*/		return 0x820F5A08;
		  /* 820F5A08h */ case   19:  		/* li R27, 1 */
		/* 820F5A08h case   19:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 820F5A08h case   19:*/		return 0x820F5A0C;
	}
	return 0x820F5A0C;
} // Block from 820F59BCh-820F5A0Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 820F5A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5A0C);
		  /* 820F5A0Ch */ case    0:  		/* addic. R29, R29, -1 */
		/* 820F5A0Ch case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 820F5A0Ch case    0:*/		return 0x820F5A10;
		  /* 820F5A10h */ case    1:  		/* addi R30, R30, 4 */
		/* 820F5A10h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820F5A10h case    1:*/		return 0x820F5A14;
		  /* 820F5A14h */ case    2:  		/* bc 4, CR0_EQ, -56 */
		/* 820F5A14h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820F59DC;  }
		/* 820F5A14h case    2:*/		return 0x820F5A18;
		  /* 820F5A18h */ case    3:  		/* b 72 */
		/* 820F5A18h case    3:*/		return 0x820F5A60;
		/* 820F5A18h case    3:*/		return 0x820F5A1C;
	}
	return 0x820F5A1C;
} // Block from 820F5A0Ch-820F5A1Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F5A1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5A1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5A1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5A1C);
		  /* 820F5A1Ch */ case    0:  		/* lwz R4, <#[R30]> */
		/* 820F5A1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000000) );
		/* 820F5A1Ch case    0:*/		return 0x820F5A20;
		  /* 820F5A20h */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 820F5A20h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820F5A20h case    1:*/		return 0x820F5A24;
		  /* 820F5A24h */ case    2:  		/* bc 12, CR6_EQ, 48 */
		/* 820F5A24h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F5A54;  }
		/* 820F5A24h case    2:*/		return 0x820F5A28;
		  /* 820F5A28h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 820F5A28h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F5A28h case    3:*/		return 0x820F5A2C;
		  /* 820F5A2Ch */ case    4:  		/* li R7, 0 */
		/* 820F5A2Ch case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820F5A2Ch case    4:*/		return 0x820F5A30;
		  /* 820F5A30h */ case    5:  		/* li R6, 0 */
		/* 820F5A30h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820F5A30h case    5:*/		return 0x820F5A34;
		  /* 820F5A34h */ case    6:  		/* add R5, R30, R28 */
		/* 820F5A34h case    6:*/		cpu::op::add<0>(regs,&regs.R5,regs.R30,regs.R28);
		/* 820F5A34h case    6:*/		return 0x820F5A38;
		  /* 820F5A38h */ case    7:  		/* mr R3, R31 */
		/* 820F5A38h case    7:*/		regs.R3 = regs.R31;
		/* 820F5A38h case    7:*/		return 0x820F5A3C;
		  /* 820F5A3Ch */ case    8:  		/* lwz R11, <#[R11 + 320]> */
		/* 820F5A3Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000140) );
		/* 820F5A3Ch case    8:*/		return 0x820F5A40;
		  /* 820F5A40h */ case    9:  		/* mtspr CTR, R11 */
		/* 820F5A40h case    9:*/		regs.CTR = regs.R11;
		/* 820F5A40h case    9:*/		return 0x820F5A44;
		  /* 820F5A44h */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 820F5A44h case   10:*/		if ( 1 ) { regs.LR = 0x820F5A48; return (uint32)regs.CTR; }
		/* 820F5A44h case   10:*/		return 0x820F5A48;
		  /* 820F5A48h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820F5A48h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F5A48h case   11:*/		return 0x820F5A4C;
		  /* 820F5A4Ch */ case   12:  		/* bc 4, CR0_LT, 8 */
		/* 820F5A4Ch case   12:*/		if ( !regs.CR[0].lt ) { return 0x820F5A54;  }
		/* 820F5A4Ch case   12:*/		return 0x820F5A50;
		  /* 820F5A50h */ case   13:  		/* li R27, 1 */
		/* 820F5A50h case   13:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 820F5A50h case   13:*/		return 0x820F5A54;
	}
	return 0x820F5A54;
} // Block from 820F5A1Ch-820F5A54h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820F5A54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5A54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5A54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5A54);
		  /* 820F5A54h */ case    0:  		/* addic. R29, R29, -1 */
		/* 820F5A54h case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 820F5A54h case    0:*/		return 0x820F5A58;
		  /* 820F5A58h */ case    1:  		/* addi R30, R30, 4 */
		/* 820F5A58h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820F5A58h case    1:*/		return 0x820F5A5C;
		  /* 820F5A5Ch */ case    2:  		/* bc 4, CR0_EQ, -64 */
		/* 820F5A5Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x820F5A1C;  }
		/* 820F5A5Ch case    2:*/		return 0x820F5A60;
	}
	return 0x820F5A60;
} // Block from 820F5A54h-820F5A60h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F5A60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5A60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5A60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5A60);
		  /* 820F5A60h */ case    0:  		/* cmpwi CR6, R27, 0 */
		/* 820F5A60h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 820F5A60h case    0:*/		return 0x820F5A64;
		  /* 820F5A64h */ case    1:  		/* bc 4, CR6_EQ, 372 */
		/* 820F5A64h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F5BD8;  }
		/* 820F5A64h case    1:*/		return 0x820F5A68;
		  /* 820F5A68h */ case    2:  		/* cmplwi CR6, R22, 0 */
		/* 820F5A68h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 820F5A68h case    2:*/		return 0x820F5A6C;
		  /* 820F5A6Ch */ case    3:  		/* bc 12, CR6_EQ, 32 */
		/* 820F5A6Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820F5A8C;  }
		/* 820F5A6Ch case    3:*/		return 0x820F5A70;
		  /* 820F5A70h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 820F5A70h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F5A70h case    4:*/		return 0x820F5A74;
		  /* 820F5A74h */ case    5:  		/* mr R3, R31 */
		/* 820F5A74h case    5:*/		regs.R3 = regs.R31;
		/* 820F5A74h case    5:*/		return 0x820F5A78;
		  /* 820F5A78h */ case    6:  		/* lwz R11, <#[R11 + 92]> */
		/* 820F5A78h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000005C) );
		/* 820F5A78h case    6:*/		return 0x820F5A7C;
		  /* 820F5A7Ch */ case    7:  		/* mtspr CTR, R11 */
		/* 820F5A7Ch case    7:*/		regs.CTR = regs.R11;
		/* 820F5A7Ch case    7:*/		return 0x820F5A80;
		  /* 820F5A80h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 820F5A80h case    8:*/		if ( 1 ) { regs.LR = 0x820F5A84; return (uint32)regs.CTR; }
		/* 820F5A80h case    8:*/		return 0x820F5A84;
		  /* 820F5A84h */ case    9:  		/* or. R30, R3, R3 */
		/* 820F5A84h case    9:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F5A84h case    9:*/		return 0x820F5A88;
		  /* 820F5A88h */ case   10:  		/* bc 12, CR0_LT, 652 */
		/* 820F5A88h case   10:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F5A88h case   10:*/		return 0x820F5A8C;
	}
	return 0x820F5A8C;
} // Block from 820F5A60h-820F5A8Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820F5A8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5A8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5A8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5A8C);
		  /* 820F5A8Ch */ case    0:  		/* mr R10, R23 */
		/* 820F5A8Ch case    0:*/		regs.R10 = regs.R23;
		/* 820F5A8Ch case    0:*/		return 0x820F5A90;
		  /* 820F5A90h */ case    1:  		/* cmplwi CR6, R19, 0 */
		/* 820F5A90h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 820F5A90h case    1:*/		return 0x820F5A94;
		  /* 820F5A94h */ case    2:  		/* bc 12, CR6_EQ, 100 */
		/* 820F5A94h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F5AF8;  }
		/* 820F5A94h case    2:*/		return 0x820F5A98;
		  /* 820F5A98h */ case    3:  		/* mr R8, R23 */
		/* 820F5A98h case    3:*/		regs.R8 = regs.R23;
		/* 820F5A98h case    3:*/		return 0x820F5A9C;
		  /* 820F5A9Ch */ case    4:  		/* lwzx R6, <#[R8 + R18]> */
		/* 820F5A9Ch case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + regs.R18 + 0x00000000) );
		/* 820F5A9Ch case    4:*/		return 0x820F5AA0;
		  /* 820F5AA0h */ case    5:  		/* cmplwi CR6, R6, 0 */
		/* 820F5AA0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820F5AA0h case    5:*/		return 0x820F5AA4;
		  /* 820F5AA4h */ case    6:  		/* bc 12, CR6_EQ, 68 */
		/* 820F5AA4h case    6:*/		if ( regs.CR[6].eq ) { return 0x820F5AE8;  }
		/* 820F5AA4h case    6:*/		return 0x820F5AA8;
		  /* 820F5AA8h */ case    7:  		/* mr R9, R23 */
		/* 820F5AA8h case    7:*/		regs.R9 = regs.R23;
		/* 820F5AA8h case    7:*/		return 0x820F5AAC;
		  /* 820F5AACh */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 820F5AACh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F5AACh case    8:*/		return 0x820F5AB0;
		  /* 820F5AB0h */ case    9:  		/* bc 12, CR6_EQ, 56 */
		/* 820F5AB0h case    9:*/		if ( regs.CR[6].eq ) { return 0x820F5AE8;  }
		/* 820F5AB0h case    9:*/		return 0x820F5AB4;
		  /* 820F5AB4h */ case   10:  		/* mr R11, R15 */
		/* 820F5AB4h case   10:*/		regs.R11 = regs.R15;
		/* 820F5AB4h case   10:*/		return 0x820F5AB8;
		  /* 820F5AB8h */ case   11:  		/* subf R7, R15, R18 */
		/* 820F5AB8h case   11:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R15,regs.R18);
		/* 820F5AB8h case   11:*/		return 0x820F5ABC;
		  /* 820F5ABCh */ case   12:  		/* lwzx R5, <#[R7 + R11]> */
		/* 820F5ABCh case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 820F5ABCh case   12:*/		return 0x820F5AC0;
		  /* 820F5AC0h */ case   13:  		/* cmplwi CR6, R5, 0 */
		/* 820F5AC0h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820F5AC0h case   13:*/		return 0x820F5AC4;
		  /* 820F5AC4h */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 820F5AC4h case   14:*/		if ( regs.CR[6].eq ) { return 0x820F5AD8;  }
		/* 820F5AC4h case   14:*/		return 0x820F5AC8;
		  /* 820F5AC8h */ case   15:  		/* lwzx R5, <#[R8 + R15]> */
		/* 820F5AC8h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R8 + regs.R15 + 0x00000000) );
		/* 820F5AC8h case   15:*/		return 0x820F5ACC;
		  /* 820F5ACCh */ case   16:  		/* lwz R4, <#[R11]> */
		/* 820F5ACCh case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 820F5ACCh case   16:*/		return 0x820F5AD0;
		  /* 820F5AD0h */ case   17:  		/* cmplw CR6, R5, R4 */
		/* 820F5AD0h case   17:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R4);
		/* 820F5AD0h case   17:*/		return 0x820F5AD4;
		  /* 820F5AD4h */ case   18:  		/* bc 12, CR6_EQ, 272 */
		/* 820F5AD4h case   18:*/		if ( regs.CR[6].eq ) { return 0x820F5BE4;  }
		/* 820F5AD4h case   18:*/		return 0x820F5AD8;
	}
	return 0x820F5AD8;
} // Block from 820F5A8Ch-820F5AD8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820F5AD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5AD8);
		  /* 820F5AD8h */ case    0:  		/* addi R9, R9, 1 */
		/* 820F5AD8h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820F5AD8h case    0:*/		return 0x820F5ADC;
		  /* 820F5ADCh */ case    1:  		/* addi R11, R11, 4 */
		/* 820F5ADCh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F5ADCh case    1:*/		return 0x820F5AE0;
		  /* 820F5AE0h */ case    2:  		/* cmplw CR6, R9, R10 */
		/* 820F5AE0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 820F5AE0h case    2:*/		return 0x820F5AE4;
		  /* 820F5AE4h */ case    3:  		/* bc 12, CR6_LT, -40 */
		/* 820F5AE4h case    3:*/		if ( regs.CR[6].lt ) { return 0x820F5ABC;  }
		/* 820F5AE4h case    3:*/		return 0x820F5AE8;
	}
	return 0x820F5AE8;
} // Block from 820F5AD8h-820F5AE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F5AE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5AE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5AE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5AE8);
		  /* 820F5AE8h */ case    0:  		/* addi R10, R10, 1 */
		/* 820F5AE8h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820F5AE8h case    0:*/		return 0x820F5AEC;
		  /* 820F5AECh */ case    1:  		/* addi R8, R8, 4 */
		/* 820F5AECh case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820F5AECh case    1:*/		return 0x820F5AF0;
		  /* 820F5AF0h */ case    2:  		/* cmplw CR6, R10, R19 */
		/* 820F5AF0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R19);
		/* 820F5AF0h case    2:*/		return 0x820F5AF4;
		  /* 820F5AF4h */ case    3:  		/* bc 12, CR6_LT, -88 */
		/* 820F5AF4h case    3:*/		if ( regs.CR[6].lt ) { return 0x820F5A9C;  }
		/* 820F5AF4h case    3:*/		return 0x820F5AF8;
	}
	return 0x820F5AF8;
} // Block from 820F5AE8h-820F5AF8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F5AF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5AF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5AF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5AF8);
		  /* 820F5AF8h */ case    0:  		/* lwz R11, <#[R31 + 108]> */
		/* 820F5AF8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 820F5AF8h case    0:*/		return 0x820F5AFC;
		  /* 820F5AFCh */ case    1:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 820F5AFCh case    1:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 820F5AFCh case    1:*/		return 0x820F5B00;
		  /* 820F5B00h */ case    2:  		/* bc 4, CR0_EQ, 20 */
		/* 820F5B00h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820F5B14;  }
		/* 820F5B00h case    2:*/		return 0x820F5B04;
		  /* 820F5B04h */ case    3:  		/* mr R3, R31 */
		/* 820F5B04h case    3:*/		regs.R3 = regs.R31;
		/* 820F5B04h case    3:*/		return 0x820F5B08;
		  /* 820F5B08h */ case    4:  		/* bl -70440 */
		/* 820F5B08h case    4:*/		regs.LR = 0x820F5B0C; return 0x820E47E0;
		/* 820F5B08h case    4:*/		return 0x820F5B0C;
		  /* 820F5B0Ch */ case    5:  		/* or. R30, R3, R3 */
		/* 820F5B0Ch case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F5B0Ch case    5:*/		return 0x820F5B10;
		  /* 820F5B10h */ case    6:  		/* bc 12, CR0_LT, 516 */
		/* 820F5B10h case    6:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F5B10h case    6:*/		return 0x820F5B14;
	}
	return 0x820F5B14;
} // Block from 820F5AF8h-820F5B14h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F5B14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5B14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5B14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5B14);
		  /* 820F5B14h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820F5B14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F5B14h case    0:*/		return 0x820F5B18;
		  /* 820F5B18h */ case    1:  		/* mr R3, R31 */
		/* 820F5B18h case    1:*/		regs.R3 = regs.R31;
		/* 820F5B18h case    1:*/		return 0x820F5B1C;
		  /* 820F5B1Ch */ case    2:  		/* lwz R11, <#[R11 + 36]> */
		/* 820F5B1Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 820F5B1Ch case    2:*/		return 0x820F5B20;
		  /* 820F5B20h */ case    3:  		/* mtspr CTR, R11 */
		/* 820F5B20h case    3:*/		regs.CTR = regs.R11;
		/* 820F5B20h case    3:*/		return 0x820F5B24;
		  /* 820F5B24h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 820F5B24h case    4:*/		if ( 1 ) { regs.LR = 0x820F5B28; return (uint32)regs.CTR; }
		/* 820F5B24h case    4:*/		return 0x820F5B28;
		  /* 820F5B28h */ case    5:  		/* or. R30, R3, R3 */
		/* 820F5B28h case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F5B28h case    5:*/		return 0x820F5B2C;
		  /* 820F5B2Ch */ case    6:  		/* bc 12, CR0_LT, 488 */
		/* 820F5B2Ch case    6:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F5B2Ch case    6:*/		return 0x820F5B30;
		  /* 820F5B30h */ case    7:  		/* lwz R11, <#[R31]> */
		/* 820F5B30h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F5B30h case    7:*/		return 0x820F5B34;
		  /* 820F5B34h */ case    8:  		/* mr R3, R31 */
		/* 820F5B34h case    8:*/		regs.R3 = regs.R31;
		/* 820F5B34h case    8:*/		return 0x820F5B38;
		  /* 820F5B38h */ case    9:  		/* lwz R11, <#[R11 + 96]> */
		/* 820F5B38h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000060) );
		/* 820F5B38h case    9:*/		return 0x820F5B3C;
		  /* 820F5B3Ch */ case   10:  		/* mtspr CTR, R11 */
		/* 820F5B3Ch case   10:*/		regs.CTR = regs.R11;
		/* 820F5B3Ch case   10:*/		return 0x820F5B40;
		  /* 820F5B40h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 820F5B40h case   11:*/		if ( 1 ) { regs.LR = 0x820F5B44; return (uint32)regs.CTR; }
		/* 820F5B40h case   11:*/		return 0x820F5B44;
		  /* 820F5B44h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820F5B44h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F5B44h case   12:*/		return 0x820F5B48;
		  /* 820F5B48h */ case   13:  		/* bc 12, CR0_LT, 144 */
		/* 820F5B48h case   13:*/		if ( regs.CR[0].lt ) { return 0x820F5BD8;  }
		/* 820F5B48h case   13:*/		return 0x820F5B4C;
		  /* 820F5B4Ch */ case   14:  		/* lwz R11, <#[R31]> */
		/* 820F5B4Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F5B4Ch case   14:*/		return 0x820F5B50;
		  /* 820F5B50h */ case   15:  		/* mr R3, R31 */
		/* 820F5B50h case   15:*/		regs.R3 = regs.R31;
		/* 820F5B50h case   15:*/		return 0x820F5B54;
		  /* 820F5B54h */ case   16:  		/* lwz R11, <#[R11 + 76]> */
		/* 820F5B54h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 820F5B54h case   16:*/		return 0x820F5B58;
		  /* 820F5B58h */ case   17:  		/* mtspr CTR, R11 */
		/* 820F5B58h case   17:*/		regs.CTR = regs.R11;
		/* 820F5B58h case   17:*/		return 0x820F5B5C;
		  /* 820F5B5Ch */ case   18:  		/* bcctrl 20, CR0_LT */
		/* 820F5B5Ch case   18:*/		if ( 1 ) { regs.LR = 0x820F5B60; return (uint32)regs.CTR; }
		/* 820F5B5Ch case   18:*/		return 0x820F5B60;
		  /* 820F5B60h */ case   19:  		/* or. R30, R3, R3 */
		/* 820F5B60h case   19:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F5B60h case   19:*/		return 0x820F5B64;
		  /* 820F5B64h */ case   20:  		/* bc 12, CR0_LT, 432 */
		/* 820F5B64h case   20:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F5B64h case   20:*/		return 0x820F5B68;
		  /* 820F5B68h */ case   21:  		/* lwz R11, <#[R31 + 112]> */
		/* 820F5B68h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820F5B68h case   21:*/		return 0x820F5B6C;
		  /* 820F5B6Ch */ case   22:  		/* rlwinm. R11, R11, 0, 8, 8 */
		/* 820F5B6Ch case   22:*/		cpu::op::rlwinm<1,0,8,8>(regs,&regs.R11,regs.R11);
		/* 820F5B6Ch case   22:*/		return 0x820F5B70;
		  /* 820F5B70h */ case   23:  		/* bc 12, CR0_EQ, 76 */
		/* 820F5B70h case   23:*/		if ( regs.CR[0].eq ) { return 0x820F5BBC;  }
		/* 820F5B70h case   23:*/		return 0x820F5B74;
		  /* 820F5B74h */ case   24:  		/* cmplwi CR6, R19, 0 */
		/* 820F5B74h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 820F5B74h case   24:*/		return 0x820F5B78;
		  /* 820F5B78h */ case   25:  		/* bc 12, CR6_EQ, 68 */
		/* 820F5B78h case   25:*/		if ( regs.CR[6].eq ) { return 0x820F5BBC;  }
		/* 820F5B78h case   25:*/		return 0x820F5B7C;
		  /* 820F5B7Ch */ case   26:  		/* mr R30, R18 */
		/* 820F5B7Ch case   26:*/		regs.R30 = regs.R18;
		/* 820F5B7Ch case   26:*/		return 0x820F5B80;
		  /* 820F5B80h */ case   27:  		/* subf R28, R18, R15 */
		/* 820F5B80h case   27:*/		cpu::op::subf<0>(regs,&regs.R28,regs.R18,regs.R15);
		/* 820F5B80h case   27:*/		return 0x820F5B84;
		  /* 820F5B84h */ case   28:  		/* mr R29, R19 */
		/* 820F5B84h case   28:*/		regs.R29 = regs.R19;
		/* 820F5B84h case   28:*/		return 0x820F5B88;
		  /* 820F5B88h */ case   29:  		/* lwz R4, <#[R30]> */
		/* 820F5B88h case   29:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000000) );
		/* 820F5B88h case   29:*/		return 0x820F5B8C;
		  /* 820F5B8Ch */ case   30:  		/* cmplwi CR6, R4, 0 */
		/* 820F5B8Ch case   30:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820F5B8Ch case   30:*/		return 0x820F5B90;
		  /* 820F5B90h */ case   31:  		/* bc 12, CR6_EQ, 32 */
		/* 820F5B90h case   31:*/		if ( regs.CR[6].eq ) { return 0x820F5BB0;  }
		/* 820F5B90h case   31:*/		return 0x820F5B94;
		  /* 820F5B94h */ case   32:  		/* lwz R11, <#[R31]> */
		/* 820F5B94h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F5B94h case   32:*/		return 0x820F5B98;
		  /* 820F5B98h */ case   33:  		/* li R6, 0 */
		/* 820F5B98h case   33:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820F5B98h case   33:*/		return 0x820F5B9C;
		  /* 820F5B9Ch */ case   34:  		/* add R5, R30, R28 */
		/* 820F5B9Ch case   34:*/		cpu::op::add<0>(regs,&regs.R5,regs.R30,regs.R28);
		/* 820F5B9Ch case   34:*/		return 0x820F5BA0;
		  /* 820F5BA0h */ case   35:  		/* mr R3, R31 */
		/* 820F5BA0h case   35:*/		regs.R3 = regs.R31;
		/* 820F5BA0h case   35:*/		return 0x820F5BA4;
		  /* 820F5BA4h */ case   36:  		/* lwz R11, <#[R11 + 104]> */
		/* 820F5BA4h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000068) );
		/* 820F5BA4h case   36:*/		return 0x820F5BA8;
		  /* 820F5BA8h */ case   37:  		/* mtspr CTR, R11 */
		/* 820F5BA8h case   37:*/		regs.CTR = regs.R11;
		/* 820F5BA8h case   37:*/		return 0x820F5BAC;
		  /* 820F5BACh */ case   38:  		/* bcctrl 20, CR0_LT */
		/* 820F5BACh case   38:*/		if ( 1 ) { regs.LR = 0x820F5BB0; return (uint32)regs.CTR; }
		/* 820F5BACh case   38:*/		return 0x820F5BB0;
	}
	return 0x820F5BB0;
} // Block from 820F5B14h-820F5BB0h (39 instructions)

//////////////////////////////////////////////////////
// Block at 820F5BB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5BB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5BB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5BB0);
		  /* 820F5BB0h */ case    0:  		/* addic. R29, R29, -1 */
		/* 820F5BB0h case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 820F5BB0h case    0:*/		return 0x820F5BB4;
		  /* 820F5BB4h */ case    1:  		/* addi R30, R30, 4 */
		/* 820F5BB4h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820F5BB4h case    1:*/		return 0x820F5BB8;
		  /* 820F5BB8h */ case    2:  		/* bc 4, CR0_EQ, -48 */
		/* 820F5BB8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820F5B88;  }
		/* 820F5BB8h case    2:*/		return 0x820F5BBC;
	}
	return 0x820F5BBC;
} // Block from 820F5BB0h-820F5BBCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F5BBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5BBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5BBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5BBC);
		  /* 820F5BBCh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820F5BBCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F5BBCh case    0:*/		return 0x820F5BC0;
		  /* 820F5BC0h */ case    1:  		/* mr R3, R31 */
		/* 820F5BC0h case    1:*/		regs.R3 = regs.R31;
		/* 820F5BC0h case    1:*/		return 0x820F5BC4;
		  /* 820F5BC4h */ case    2:  		/* lwz R11, <#[R11 + 100]> */
		/* 820F5BC4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000064) );
		/* 820F5BC4h case    2:*/		return 0x820F5BC8;
		  /* 820F5BC8h */ case    3:  		/* mtspr CTR, R11 */
		/* 820F5BC8h case    3:*/		regs.CTR = regs.R11;
		/* 820F5BC8h case    3:*/		return 0x820F5BCC;
		  /* 820F5BCCh */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 820F5BCCh case    4:*/		if ( 1 ) { regs.LR = 0x820F5BD0; return (uint32)regs.CTR; }
		/* 820F5BCCh case    4:*/		return 0x820F5BD0;
		  /* 820F5BD0h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820F5BD0h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F5BD0h case    5:*/		return 0x820F5BD4;
		  /* 820F5BD4h */ case    6:  		/* bc 4, CR0_LT, 44 */
		/* 820F5BD4h case    6:*/		if ( !regs.CR[0].lt ) { return 0x820F5C00;  }
		/* 820F5BD4h case    6:*/		return 0x820F5BD8;
	}
	return 0x820F5BD8;
} // Block from 820F5BBCh-820F5BD8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F5BD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5BD8);
		  /* 820F5BD8h */ case    0:  		/* lis R30, -32768 */
		/* 820F5BD8h case    0:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8000);
		/* 820F5BD8h case    0:*/		return 0x820F5BDC;
		  /* 820F5BDCh */ case    1:  		/* ori R30, R30, 16389 */
		/* 820F5BDCh case    1:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0x4005);
		/* 820F5BDCh case    1:*/		return 0x820F5BE0;
		  /* 820F5BE0h */ case    2:  		/* b 308 */
		/* 820F5BE0h case    2:*/		return 0x820F5D14;
		/* 820F5BE0h case    2:*/		return 0x820F5BE4;
	}
	return 0x820F5BE4;
} // Block from 820F5BD8h-820F5BE4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F5BE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5BE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5BE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5BE4);
		  /* 820F5BE4h */ case    0:  		/* lis R11, -32254 */
		/* 820F5BE4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F5BE4h case    0:*/		return 0x820F5BE8;
		  /* 820F5BE8h */ case    1:  		/* lwz R4, <#[R6 + 104]> */
		/* 820F5BE8h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R6 + 0x00000068) );
		/* 820F5BE8h case    1:*/		return 0x820F5BEC;
		  /* 820F5BECh */ case    2:  		/* li R5, 4504 */
		/* 820F5BECh case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x1198);
		/* 820F5BECh case    2:*/		return 0x820F5BF0;
		  /* 820F5BF0h */ case    3:  		/* addi R6, R11, -16000 */
		/* 820F5BF0h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFC180);
		/* 820F5BF0h case    3:*/		return 0x820F5BF4;
	}
	return 0x820F5BF4;
} // Block from 820F5BE4h-820F5BF4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F5BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5BF4);
		  /* 820F5BF4h */ case    0:  		/* mr R3, R31 */
		/* 820F5BF4h case    0:*/		regs.R3 = regs.R31;
		/* 820F5BF4h case    0:*/		return 0x820F5BF8;
	}
	return 0x820F5BF8;
} // Block from 820F5BF4h-820F5BF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F5BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5BF8);
		  /* 820F5BF8h */ case    0:  		/* bl 101176 */
		/* 820F5BF8h case    0:*/		regs.LR = 0x820F5BFC; return 0x8210E730;
		/* 820F5BF8h case    0:*/		return 0x820F5BFC;
		  /* 820F5BFCh */ case    1:  		/* b -36 */
		/* 820F5BFCh case    1:*/		return 0x820F5BD8;
		/* 820F5BFCh case    1:*/		return 0x820F5C00;
	}
	return 0x820F5C00;
} // Block from 820F5BF8h-820F5C00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F5C00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5C00);
		  /* 820F5C00h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820F5C00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F5C00h case    0:*/		return 0x820F5C04;
		  /* 820F5C04h */ case    1:  		/* mr R3, R31 */
		/* 820F5C04h case    1:*/		regs.R3 = regs.R31;
		/* 820F5C04h case    1:*/		return 0x820F5C08;
		  /* 820F5C08h */ case    2:  		/* lwz R11, <#[R11 + 84]> */
		/* 820F5C08h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000054) );
		/* 820F5C08h case    2:*/		return 0x820F5C0C;
		  /* 820F5C0Ch */ case    3:  		/* mtspr CTR, R11 */
		/* 820F5C0Ch case    3:*/		regs.CTR = regs.R11;
		/* 820F5C0Ch case    3:*/		return 0x820F5C10;
		  /* 820F5C10h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 820F5C10h case    4:*/		if ( 1 ) { regs.LR = 0x820F5C14; return (uint32)regs.CTR; }
		/* 820F5C10h case    4:*/		return 0x820F5C14;
		  /* 820F5C14h */ case    5:  		/* or. R30, R3, R3 */
		/* 820F5C14h case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F5C14h case    5:*/		return 0x820F5C18;
		  /* 820F5C18h */ case    6:  		/* bc 12, CR0_LT, 252 */
		/* 820F5C18h case    6:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F5C18h case    6:*/		return 0x820F5C1C;
		  /* 820F5C1Ch */ case    7:  		/* lwz R11, <#[R31 + 228]> */
		/* 820F5C1Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 820F5C1Ch case    7:*/		return 0x820F5C20;
		  /* 820F5C20h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 820F5C20h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F5C20h case    8:*/		return 0x820F5C24;
		  /* 820F5C24h */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 820F5C24h case    9:*/		if ( regs.CR[6].eq ) { return 0x820F5C38;  }
		/* 820F5C24h case    9:*/		return 0x820F5C28;
		  /* 820F5C28h */ case   10:  		/* mr R3, R31 */
		/* 820F5C28h case   10:*/		regs.R3 = regs.R31;
		/* 820F5C28h case   10:*/		return 0x820F5C2C;
		  /* 820F5C2Ch */ case   11:  		/* bl -10324 */
		/* 820F5C2Ch case   11:*/		regs.LR = 0x820F5C30; return 0x820F33D8;
		/* 820F5C2Ch case   11:*/		return 0x820F5C30;
		  /* 820F5C30h */ case   12:  		/* or. R30, R3, R3 */
		/* 820F5C30h case   12:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F5C30h case   12:*/		return 0x820F5C34;
		  /* 820F5C34h */ case   13:  		/* bc 12, CR0_LT, 224 */
		/* 820F5C34h case   13:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F5C34h case   13:*/		return 0x820F5C38;
	}
	return 0x820F5C38;
} // Block from 820F5C00h-820F5C38h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820F5C38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5C38);
		  /* 820F5C38h */ case    0:  		/* mr R3, R31 */
		/* 820F5C38h case    0:*/		regs.R3 = regs.R31;
		/* 820F5C38h case    0:*/		return 0x820F5C3C;
		  /* 820F5C3Ch */ case    1:  		/* bl -9940 */
		/* 820F5C3Ch case    1:*/		regs.LR = 0x820F5C40; return 0x820F3568;
		/* 820F5C3Ch case    1:*/		return 0x820F5C40;
		  /* 820F5C40h */ case    2:  		/* or. R30, R3, R3 */
		/* 820F5C40h case    2:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F5C40h case    2:*/		return 0x820F5C44;
		  /* 820F5C44h */ case    3:  		/* bc 12, CR0_LT, 208 */
		/* 820F5C44h case    3:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F5C44h case    3:*/		return 0x820F5C48;
		  /* 820F5C48h */ case    4:  		/* lwz R11, <#[R31 + 204]> */
		/* 820F5C48h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000CC) );
		/* 820F5C48h case    4:*/		return 0x820F5C4C;
		  /* 820F5C4Ch */ case    5:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 820F5C4Ch case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 820F5C4Ch case    5:*/		return 0x820F5C50;
		  /* 820F5C50h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820F5C50h case    6:*/		if ( regs.CR[0].eq ) { return 0x820F5C64;  }
		/* 820F5C50h case    6:*/		return 0x820F5C54;
		  /* 820F5C54h */ case    7:  		/* mr R3, R31 */
		/* 820F5C54h case    7:*/		regs.R3 = regs.R31;
		/* 820F5C54h case    7:*/		return 0x820F5C58;
		  /* 820F5C58h */ case    8:  		/* bl -6784 */
		/* 820F5C58h case    8:*/		regs.LR = 0x820F5C5C; return 0x820F41D8;
		/* 820F5C58h case    8:*/		return 0x820F5C5C;
		  /* 820F5C5Ch */ case    9:  		/* or. R30, R3, R3 */
		/* 820F5C5Ch case    9:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F5C5Ch case    9:*/		return 0x820F5C60;
		  /* 820F5C60h */ case   10:  		/* bc 12, CR0_LT, 180 */
		/* 820F5C60h case   10:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F5C60h case   10:*/		return 0x820F5C64;
	}
	return 0x820F5C64;
} // Block from 820F5C38h-820F5C64h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820F5C64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5C64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5C64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5C64);
		  /* 820F5C64h */ case    0:  		/* lis R4, 0 */
		/* 820F5C64h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x0);
		/* 820F5C64h case    0:*/		return 0x820F5C68;
		  /* 820F5C68h */ case    1:  		/* mr R3, R31 */
		/* 820F5C68h case    1:*/		regs.R3 = regs.R31;
		/* 820F5C68h case    1:*/		return 0x820F5C6C;
		  /* 820F5C6Ch */ case    2:  		/* ori R4, R4, 65535 */
		/* 820F5C6Ch case    2:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0xFFFF);
		/* 820F5C6Ch case    2:*/		return 0x820F5C70;
		  /* 820F5C70h */ case    3:  		/* bl -10496 */
		/* 820F5C70h case    3:*/		regs.LR = 0x820F5C74; return 0x820F3370;
		/* 820F5C70h case    3:*/		return 0x820F5C74;
		  /* 820F5C74h */ case    4:  		/* or. R30, R3, R3 */
		/* 820F5C74h case    4:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F5C74h case    4:*/		return 0x820F5C78;
		  /* 820F5C78h */ case    5:  		/* bc 12, CR0_LT, 156 */
		/* 820F5C78h case    5:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F5C78h case    5:*/		return 0x820F5C7C;
		  /* 820F5C7Ch */ case    6:  		/* mr R3, R31 */
		/* 820F5C7Ch case    6:*/		regs.R3 = regs.R31;
		/* 820F5C7Ch case    6:*/		return 0x820F5C80;
		  /* 820F5C80h */ case    7:  		/* bl -33656 */
		/* 820F5C80h case    7:*/		regs.LR = 0x820F5C84; return 0x820ED908;
		/* 820F5C80h case    7:*/		return 0x820F5C84;
		  /* 820F5C84h */ case    8:  		/* or. R30, R3, R3 */
		/* 820F5C84h case    8:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F5C84h case    8:*/		return 0x820F5C88;
		  /* 820F5C88h */ case    9:  		/* bc 12, CR0_LT, 140 */
		/* 820F5C88h case    9:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F5C88h case    9:*/		return 0x820F5C8C;
		  /* 820F5C8Ch */ case   10:  		/* lwz R3, <#[R31 + 436]> */
		/* 820F5C8Ch case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000001B4) );
		/* 820F5C8Ch case   10:*/		return 0x820F5C90;
		  /* 820F5C90h */ case   11:  		/* cmplwi CR6, R3, 0 */
		/* 820F5C90h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820F5C90h case   11:*/		return 0x820F5C94;
		  /* 820F5C94h */ case   12:  		/* bc 12, CR6_EQ, 40 */
		/* 820F5C94h case   12:*/		if ( regs.CR[6].eq ) { return 0x820F5CBC;  }
		/* 820F5C94h case   12:*/		return 0x820F5C98;
		  /* 820F5C98h */ case   13:  		/* lwz R11, <#[R31 + 212]> */
		/* 820F5C98h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000D4) );
		/* 820F5C98h case   13:*/		return 0x820F5C9C;
		  /* 820F5C9Ch */ case   14:  		/* cmpwi CR6, R11, 0 */
		/* 820F5C9Ch case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820F5C9Ch case   14:*/		return 0x820F5CA0;
		  /* 820F5CA0h */ case   15:  		/* bc 4, CR6_EQ, 28 */
		/* 820F5CA0h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820F5CBC;  }
		/* 820F5CA0h case   15:*/		return 0x820F5CA4;
		  /* 820F5CA4h */ case   16:  		/* lwz R11, <#[R3]> */
		/* 820F5CA4h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F5CA4h case   16:*/		return 0x820F5CA8;
		  /* 820F5CA8h */ case   17:  		/* lwz R11, <#[R11 + 16]> */
		/* 820F5CA8h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820F5CA8h case   17:*/		return 0x820F5CAC;
		  /* 820F5CACh */ case   18:  		/* mtspr CTR, R11 */
		/* 820F5CACh case   18:*/		regs.CTR = regs.R11;
		/* 820F5CACh case   18:*/		return 0x820F5CB0;
		  /* 820F5CB0h */ case   19:  		/* bcctrl 20, CR0_LT */
		/* 820F5CB0h case   19:*/		if ( 1 ) { regs.LR = 0x820F5CB4; return (uint32)regs.CTR; }
		/* 820F5CB0h case   19:*/		return 0x820F5CB4;
		  /* 820F5CB4h */ case   20:  		/* or. R30, R3, R3 */
		/* 820F5CB4h case   20:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F5CB4h case   20:*/		return 0x820F5CB8;
		  /* 820F5CB8h */ case   21:  		/* bc 12, CR0_LT, 92 */
		/* 820F5CB8h case   21:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F5CB8h case   21:*/		return 0x820F5CBC;
	}
	return 0x820F5CBC;
} // Block from 820F5C64h-820F5CBCh (22 instructions)

//////////////////////////////////////////////////////
// Block at 820F5CBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5CBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5CBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5CBC);
		  /* 820F5CBCh */ case    0:  		/* lwz R29, <#[R1 + 300]> */
		/* 820F5CBCh case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x0000012C) );
		/* 820F5CBCh case    0:*/		return 0x820F5CC0;
		  /* 820F5CC0h */ case    1:  		/* cmplwi CR6, R29, 0 */
		/* 820F5CC0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820F5CC0h case    1:*/		return 0x820F5CC4;
		  /* 820F5CC4h */ case    2:  		/* bc 12, CR6_EQ, 76 */
		/* 820F5CC4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F5D10;  }
		/* 820F5CC4h case    2:*/		return 0x820F5CC8;
		  /* 820F5CC8h */ case    3:  		/* lwz R11, <#[R31 + 276]> */
		/* 820F5CC8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000114) );
		/* 820F5CC8h case    3:*/		return 0x820F5CCC;
		  /* 820F5CCCh */ case    4:  		/* addi R4, R1, 88 */
		/* 820F5CCCh case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x58);
		/* 820F5CCCh case    4:*/		return 0x820F5CD0;
		  /* 820F5CD0h */ case    5:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820F5CD0h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820F5CD0h case    5:*/		return 0x820F5CD4;
		  /* 820F5CD4h */ case    6:  		/* bl -328388 */
		/* 820F5CD4h case    6:*/		regs.LR = 0x820F5CD8; return 0x820A5A10;
		/* 820F5CD4h case    6:*/		return 0x820F5CD8;
		  /* 820F5CD8h */ case    7:  		/* or. R30, R3, R3 */
		/* 820F5CD8h case    7:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F5CD8h case    7:*/		return 0x820F5CDC;
		  /* 820F5CDCh */ case    8:  		/* bc 12, CR0_LT, 56 */
		/* 820F5CDCh case    8:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F5CDCh case    8:*/		return 0x820F5CE0;
		  /* 820F5CE0h */ case    9:  		/* lwz R3, <#[R1 + 88]> */
		/* 820F5CE0h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000058) );
		/* 820F5CE0h case    9:*/		return 0x820F5CE4;
		  /* 820F5CE4h */ case   10:  		/* lwz R30, <#[R31 + 276]> */
		/* 820F5CE4h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000114) );
		/* 820F5CE4h case   10:*/		return 0x820F5CE8;
		  /* 820F5CE8h */ case   11:  		/* lwz R28, <#[R31 + 272]> */
		/* 820F5CE8h case   11:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000110) );
		/* 820F5CE8h case   11:*/		return 0x820F5CEC;
		  /* 820F5CECh */ case   12:  		/* lwz R11, <#[R3]> */
		/* 820F5CECh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F5CECh case   12:*/		return 0x820F5CF0;
		  /* 820F5CF0h */ case   13:  		/* lwz R11, <#[R11 + 12]> */
		/* 820F5CF0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F5CF0h case   13:*/		return 0x820F5CF4;
		  /* 820F5CF4h */ case   14:  		/* mtspr CTR, R11 */
		/* 820F5CF4h case   14:*/		regs.CTR = regs.R11;
		/* 820F5CF4h case   14:*/		return 0x820F5CF8;
		  /* 820F5CF8h */ case   15:  		/* bcctrl 20, CR0_LT */
		/* 820F5CF8h case   15:*/		if ( 1 ) { regs.LR = 0x820F5CFC; return (uint32)regs.CTR; }
		/* 820F5CF8h case   15:*/		return 0x820F5CFC;
		  /* 820F5CFCh */ case   16:  		/* mr R4, R28 */
		/* 820F5CFCh case   16:*/		regs.R4 = regs.R28;
		/* 820F5CFCh case   16:*/		return 0x820F5D00;
		  /* 820F5D00h */ case   17:  		/* rlwinm R5, R30, 2, 0, 29 */
		/* 820F5D00h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R30);
		/* 820F5D00h case   17:*/		return 0x820F5D04;
		  /* 820F5D04h */ case   18:  		/* bl -410452 */
		/* 820F5D04h case   18:*/		regs.LR = 0x820F5D08; return 0x820919B0;
		/* 820F5D04h case   18:*/		return 0x820F5D08;
		  /* 820F5D08h */ case   19:  		/* lwz R11, <#[R1 + 88]> */
		/* 820F5D08h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 820F5D08h case   19:*/		return 0x820F5D0C;
		  /* 820F5D0Ch */ case   20:  		/* stw R11, <#[R29]> */
		/* 820F5D0Ch case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820F5D0Ch case   20:*/		return 0x820F5D10;
	}
	return 0x820F5D10;
} // Block from 820F5CBCh-820F5D10h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820F5D10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5D10);
		  /* 820F5D10h */ case    0:  		/* mr R30, R23 */
		/* 820F5D10h case    0:*/		regs.R30 = regs.R23;
		/* 820F5D10h case    0:*/		return 0x820F5D14;
	}
	return 0x820F5D14;
} // Block from 820F5D10h-820F5D14h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F5D14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5D14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5D14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5D14);
		  /* 820F5D14h */ case    0:  		/* lis R4, 9345 */
		/* 820F5D14h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F5D14h case    0:*/		return 0x820F5D18;
		  /* 820F5D18h */ case    1:  		/* mr R3, R20 */
		/* 820F5D18h case    1:*/		regs.R3 = regs.R20;
		/* 820F5D18h case    1:*/		return 0x820F5D1C;
		  /* 820F5D1Ch */ case    2:  		/* bl -448996 */
		/* 820F5D1Ch case    2:*/		regs.LR = 0x820F5D20; return 0x82088338;
		/* 820F5D1Ch case    2:*/		return 0x820F5D20;
		  /* 820F5D20h */ case    3:  		/* lis R4, 9345 */
		/* 820F5D20h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F5D20h case    3:*/		return 0x820F5D24;
		  /* 820F5D24h */ case    4:  		/* mr R3, R18 */
		/* 820F5D24h case    4:*/		regs.R3 = regs.R18;
		/* 820F5D24h case    4:*/		return 0x820F5D28;
		  /* 820F5D28h */ case    5:  		/* bl -449008 */
		/* 820F5D28h case    5:*/		regs.LR = 0x820F5D2C; return 0x82088338;
		/* 820F5D28h case    5:*/		return 0x820F5D2C;
		  /* 820F5D2Ch */ case    6:  		/* lis R4, 9345 */
		/* 820F5D2Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F5D2Ch case    6:*/		return 0x820F5D30;
		  /* 820F5D30h */ case    7:  		/* lwz R3, <#[R1 + 80]> */
		/* 820F5D30h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 820F5D30h case    7:*/		return 0x820F5D34;
		  /* 820F5D34h */ case    8:  		/* bl -449020 */
		/* 820F5D34h case    8:*/		regs.LR = 0x820F5D38; return 0x82088338;
		/* 820F5D34h case    8:*/		return 0x820F5D38;
		  /* 820F5D38h */ case    9:  		/* lis R4, 9345 */
		/* 820F5D38h case    9:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F5D38h case    9:*/		return 0x820F5D3C;
		  /* 820F5D3Ch */ case   10:  		/* mr R3, R15 */
		/* 820F5D3Ch case   10:*/		regs.R3 = regs.R15;
		/* 820F5D3Ch case   10:*/		return 0x820F5D40;
		  /* 820F5D40h */ case   11:  		/* bl -449032 */
		/* 820F5D40h case   11:*/		regs.LR = 0x820F5D44; return 0x82088338;
		/* 820F5D40h case   11:*/		return 0x820F5D44;
		  /* 820F5D44h */ case   12:  		/* lis R4, 9345 */
		/* 820F5D44h case   12:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F5D44h case   12:*/		return 0x820F5D48;
		  /* 820F5D48h */ case   13:  		/* li R3, 0 */
		/* 820F5D48h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F5D48h case   13:*/		return 0x820F5D4C;
		  /* 820F5D4Ch */ case   14:  		/* bl -449044 */
		/* 820F5D4Ch case   14:*/		regs.LR = 0x820F5D50; return 0x82088338;
		/* 820F5D4Ch case   14:*/		return 0x820F5D50;
		  /* 820F5D50h */ case   15:  		/* lis R4, 9345 */
		/* 820F5D50h case   15:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F5D50h case   15:*/		return 0x820F5D54;
		  /* 820F5D54h */ case   16:  		/* mr R3, R17 */
		/* 820F5D54h case   16:*/		regs.R3 = regs.R17;
		/* 820F5D54h case   16:*/		return 0x820F5D58;
		  /* 820F5D58h */ case   17:  		/* bl -449056 */
		/* 820F5D58h case   17:*/		regs.LR = 0x820F5D5C; return 0x82088338;
		/* 820F5D58h case   17:*/		return 0x820F5D5C;
		  /* 820F5D5Ch */ case   18:  		/* lis R4, 9345 */
		/* 820F5D5Ch case   18:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F5D5Ch case   18:*/		return 0x820F5D60;
		  /* 820F5D60h */ case   19:  		/* lwz R3, <#[R1 + 92]> */
		/* 820F5D60h case   19:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F5D60h case   19:*/		return 0x820F5D64;
		  /* 820F5D64h */ case   20:  		/* bl -449068 */
		/* 820F5D64h case   20:*/		regs.LR = 0x820F5D68; return 0x82088338;
		/* 820F5D64h case   20:*/		return 0x820F5D68;
		  /* 820F5D68h */ case   21:  		/* lis R4, 9345 */
		/* 820F5D68h case   21:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F5D68h case   21:*/		return 0x820F5D6C;
		  /* 820F5D6Ch */ case   22:  		/* lwz R3, <#[R1 + 84]> */
		/* 820F5D6Ch case   22:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 820F5D6Ch case   22:*/		return 0x820F5D70;
		  /* 820F5D70h */ case   23:  		/* bl -449080 */
		/* 820F5D70h case   23:*/		regs.LR = 0x820F5D74; return 0x82088338;
		/* 820F5D70h case   23:*/		return 0x820F5D74;
		  /* 820F5D74h */ case   24:  		/* lis R4, 9345 */
		/* 820F5D74h case   24:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F5D74h case   24:*/		return 0x820F5D78;
		  /* 820F5D78h */ case   25:  		/* mr R3, R16 */
		/* 820F5D78h case   25:*/		regs.R3 = regs.R16;
		/* 820F5D78h case   25:*/		return 0x820F5D7C;
		  /* 820F5D7Ch */ case   26:  		/* bl -449092 */
		/* 820F5D7Ch case   26:*/		regs.LR = 0x820F5D80; return 0x82088338;
		/* 820F5D7Ch case   26:*/		return 0x820F5D80;
		  /* 820F5D80h */ case   27:  		/* lis R4, 9345 */
		/* 820F5D80h case   27:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F5D80h case   27:*/		return 0x820F5D84;
		  /* 820F5D84h */ case   28:  		/* mr R3, R14 */
		/* 820F5D84h case   28:*/		regs.R3 = regs.R14;
		/* 820F5D84h case   28:*/		return 0x820F5D88;
		  /* 820F5D88h */ case   29:  		/* bl -449104 */
		/* 820F5D88h case   29:*/		regs.LR = 0x820F5D8C; return 0x82088338;
		/* 820F5D88h case   29:*/		return 0x820F5D8C;
		  /* 820F5D8Ch */ case   30:  		/* lis R4, 9345 */
		/* 820F5D8Ch case   30:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F5D8Ch case   30:*/		return 0x820F5D90;
		  /* 820F5D90h */ case   31:  		/* lwz R3, <#[R31 + 272]> */
		/* 820F5D90h case   31:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000110) );
		/* 820F5D90h case   31:*/		return 0x820F5D94;
		  /* 820F5D94h */ case   32:  		/* bl -449116 */
		/* 820F5D94h case   32:*/		regs.LR = 0x820F5D98; return 0x82088338;
		/* 820F5D94h case   32:*/		return 0x820F5D98;
		  /* 820F5D98h */ case   33:  		/* stw R23, <#[R31 + 272]> */
		/* 820F5D98h case   33:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x00000110) );
		/* 820F5D98h case   33:*/		return 0x820F5D9C;
		  /* 820F5D9Ch */ case   34:  		/* lis R4, 9345 */
		/* 820F5D9Ch case   34:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F5D9Ch case   34:*/		return 0x820F5DA0;
		  /* 820F5DA0h */ case   35:  		/* lwz R3, <#[R31 + 296]> */
		/* 820F5DA0h case   35:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000128) );
		/* 820F5DA0h case   35:*/		return 0x820F5DA4;
		  /* 820F5DA4h */ case   36:  		/* bl -449132 */
		/* 820F5DA4h case   36:*/		regs.LR = 0x820F5DA8; return 0x82088338;
		/* 820F5DA4h case   36:*/		return 0x820F5DA8;
		  /* 820F5DA8h */ case   37:  		/* stw R23, <#[R31 + 296]> */
		/* 820F5DA8h case   37:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x00000128) );
		/* 820F5DA8h case   37:*/		return 0x820F5DAC;
		  /* 820F5DACh */ case   38:  		/* lwz R3, <#[R31 + 436]> */
		/* 820F5DACh case   38:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000001B4) );
		/* 820F5DACh case   38:*/		return 0x820F5DB0;
		  /* 820F5DB0h */ case   39:  		/* cmplwi CR6, R3, 0 */
		/* 820F5DB0h case   39:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820F5DB0h case   39:*/		return 0x820F5DB4;
		  /* 820F5DB4h */ case   40:  		/* bc 12, CR6_EQ, 24 */
		/* 820F5DB4h case   40:*/		if ( regs.CR[6].eq ) { return 0x820F5DCC;  }
		/* 820F5DB4h case   40:*/		return 0x820F5DB8;
		  /* 820F5DB8h */ case   41:  		/* lwz R11, <#[R3]> */
		/* 820F5DB8h case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F5DB8h case   41:*/		return 0x820F5DBC;
		  /* 820F5DBCh */ case   42:  		/* lwz R11, <#[R11 + 4]> */
		/* 820F5DBCh case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820F5DBCh case   42:*/		return 0x820F5DC0;
		  /* 820F5DC0h */ case   43:  		/* mtspr CTR, R11 */
		/* 820F5DC0h case   43:*/		regs.CTR = regs.R11;
		/* 820F5DC0h case   43:*/		return 0x820F5DC4;
		  /* 820F5DC4h */ case   44:  		/* bcctrl 20, CR0_LT */
		/* 820F5DC4h case   44:*/		if ( 1 ) { regs.LR = 0x820F5DC8; return (uint32)regs.CTR; }
		/* 820F5DC4h case   44:*/		return 0x820F5DC8;
		  /* 820F5DC8h */ case   45:  		/* stw R23, <#[R31 + 436]> */
		/* 820F5DC8h case   45:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x000001B4) );
		/* 820F5DC8h case   45:*/		return 0x820F5DCC;
	}
	return 0x820F5DCC;
} // Block from 820F5D14h-820F5DCCh (46 instructions)

//////////////////////////////////////////////////////
// Block at 820F5DCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5DCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5DCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5DCC);
		  /* 820F5DCCh */ case    0:  		/* mr R3, R30 */
		/* 820F5DCCh case    0:*/		regs.R3 = regs.R30;
		/* 820F5DCCh case    0:*/		return 0x820F5DD0;
		  /* 820F5DD0h */ case    1:  		/* addi R1, R1, 272 */
		/* 820F5DD0h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x110);
		/* 820F5DD0h case    1:*/		return 0x820F5DD4;
		  /* 820F5DD4h */ case    2:  		/* b -412516 */
		/* 820F5DD4h case    2:*/		return 0x82091270;
		/* 820F5DD4h case    2:*/		return 0x820F5DD8;
	}
	return 0x820F5DD8;
} // Block from 820F5DCCh-820F5DD8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F5DD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5DD8);
		  /* 820F5DD8h */ case    0:  		/* mfspr R12, LR */
		/* 820F5DD8h case    0:*/		regs.R12 = regs.LR;
		/* 820F5DD8h case    0:*/		return 0x820F5DDC;
		  /* 820F5DDCh */ case    1:  		/* bl -412548 */
		/* 820F5DDCh case    1:*/		regs.LR = 0x820F5DE0; return 0x82091258;
		/* 820F5DDCh case    1:*/		return 0x820F5DE0;
		  /* 820F5DE0h */ case    2:  		/* stwu R1, <#[R1 - 656]> */
		/* 820F5DE0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFD70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFD70);
		/* 820F5DE0h case    2:*/		return 0x820F5DE4;
		  /* 820F5DE4h */ case    3:  		/* mr R29, R4 */
		/* 820F5DE4h case    3:*/		regs.R29 = regs.R4;
		/* 820F5DE4h case    3:*/		return 0x820F5DE8;
		  /* 820F5DE8h */ case    4:  		/* lwz R4, <#[R4 + 104]> */
		/* 820F5DE8h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000068) );
		/* 820F5DE8h case    4:*/		return 0x820F5DEC;
		  /* 820F5DECh */ case    5:  		/* li R11, 0 */
		/* 820F5DECh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F5DECh case    5:*/		return 0x820F5DF0;
		  /* 820F5DF0h */ case    6:  		/* mr R31, R3 */
		/* 820F5DF0h case    6:*/		regs.R31 = regs.R3;
		/* 820F5DF0h case    6:*/		return 0x820F5DF4;
		  /* 820F5DF4h */ case    7:  		/* stw R11, <#[R1 + 80]> */
		/* 820F5DF4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820F5DF4h case    7:*/		return 0x820F5DF8;
		  /* 820F5DF8h */ case    8:  		/* cmplwi CR6, R4, 0 */
		/* 820F5DF8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820F5DF8h case    8:*/		return 0x820F5DFC;
		  /* 820F5DFCh */ case    9:  		/* bc 4, CR6_EQ, 52 */
		/* 820F5DFCh case    9:*/		if ( !regs.CR[6].eq ) { return 0x820F5E30;  }
		/* 820F5DFCh case    9:*/		return 0x820F5E00;
		  /* 820F5E00h */ case   10:  		/* lwz R11, <#[R29]> */
		/* 820F5E00h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820F5E00h case   10:*/		return 0x820F5E04;
		  /* 820F5E04h */ case   11:  		/* li R5, 0 */
		/* 820F5E04h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F5E04h case   11:*/		return 0x820F5E08;
		  /* 820F5E08h */ case   12:  		/* oris R11, R11, 16384 */
		/* 820F5E08h case   12:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 820F5E08h case   12:*/		return 0x820F5E0C;
		  /* 820F5E0Ch */ case   13:  		/* stw R11, <#[R29]> */
		/* 820F5E0Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820F5E0Ch case   13:*/		return 0x820F5E10;
		  /* 820F5E10h */ case   14:  		/* lwz R11, <#[R3]> */
		/* 820F5E10h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F5E10h case   14:*/		return 0x820F5E14;
		  /* 820F5E14h */ case   15:  		/* lwz R11, <#[R11 + 108]> */
		/* 820F5E14h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000006C) );
		/* 820F5E14h case   15:*/		return 0x820F5E18;
		  /* 820F5E18h */ case   16:  		/* mtspr CTR, R11 */
		/* 820F5E18h case   16:*/		regs.CTR = regs.R11;
		/* 820F5E18h case   16:*/		return 0x820F5E1C;
		  /* 820F5E1Ch */ case   17:  		/* bcctrl 20, CR0_LT */
		/* 820F5E1Ch case   17:*/		if ( 1 ) { regs.LR = 0x820F5E20; return (uint32)regs.CTR; }
		/* 820F5E1Ch case   17:*/		return 0x820F5E20;
		  /* 820F5E20h */ case   18:  		/* stw R3, <#[R29 + 108]> */
		/* 820F5E20h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000006C) );
		/* 820F5E20h case   18:*/		return 0x820F5E24;
		  /* 820F5E24h */ case   19:  		/* li R3, 0 */
		/* 820F5E24h case   19:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F5E24h case   19:*/		return 0x820F5E28;
		  /* 820F5E28h */ case   20:  		/* addi R1, R1, 656 */
		/* 820F5E28h case   20:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x290);
		/* 820F5E28h case   20:*/		return 0x820F5E2C;
		  /* 820F5E2Ch */ case   21:  		/* b -412548 */
		/* 820F5E2Ch case   21:*/		return 0x820912A8;
		/* 820F5E2Ch case   21:*/		return 0x820F5E30;
	}
	return 0x820F5E30;
} // Block from 820F5DD8h-820F5E30h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820F5E30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5E30);
		  /* 820F5E30h */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 820F5E30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 820F5E30h case    0:*/		return 0x820F5E34;
		  /* 820F5E34h */ case    1:  		/* lwz R10, <#[R31 + 16]> */
		/* 820F5E34h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820F5E34h case    1:*/		return 0x820F5E38;
		  /* 820F5E38h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F5E38h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F5E38h case    2:*/		return 0x820F5E3C;
		  /* 820F5E3Ch */ case    3:  		/* lwz R9, <#[R31 + 348]> */
		/* 820F5E3Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000015C) );
		/* 820F5E3Ch case    3:*/		return 0x820F5E40;
		  /* 820F5E40h */ case    4:  		/* lwz R30, <#[R4 + 24]> */
		/* 820F5E40h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R4 + 0x00000018) );
		/* 820F5E40h case    4:*/		return 0x820F5E44;
		  /* 820F5E44h */ case    5:  		/* cmpwi CR6, R9, 0 */
		/* 820F5E44h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820F5E44h case    5:*/		return 0x820F5E48;
		  /* 820F5E48h */ case    6:  		/* lwzx R7, <#[R11 + R10]> */
		/* 820F5E48h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F5E48h case    6:*/		return 0x820F5E4C;
		  /* 820F5E4Ch */ case    7:  		/* bc 12, CR6_EQ, 276 */
		/* 820F5E4Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x820F5F60;  }
		/* 820F5E4Ch case    7:*/		return 0x820F5E50;
		  /* 820F5E50h */ case    8:  		/* mr R11, R30 */
		/* 820F5E50h case    8:*/		regs.R11 = regs.R30;
		/* 820F5E50h case    8:*/		return 0x820F5E54;
		  /* 820F5E54h */ case    9:  		/* lbz R10, <#[R11]> */
		/* 820F5E54h case    9:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820F5E54h case    9:*/		return 0x820F5E58;
		  /* 820F5E58h */ case   10:  		/* addi R11, R11, 1 */
		/* 820F5E58h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F5E58h case   10:*/		return 0x820F5E5C;
		  /* 820F5E5Ch */ case   11:  		/* cmplwi CR6, R10, 0 */
		/* 820F5E5Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F5E5Ch case   11:*/		return 0x820F5E60;
		  /* 820F5E60h */ case   12:  		/* bc 4, CR6_EQ, -12 */
		/* 820F5E60h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820F5E54;  }
		/* 820F5E60h case   12:*/		return 0x820F5E64;
		  /* 820F5E64h */ case   13:  		/* subf R11, R30, R11 */
		/* 820F5E64h case   13:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 820F5E64h case   13:*/		return 0x820F5E68;
		  /* 820F5E68h */ case   14:  		/* addi R11, R11, -1 */
		/* 820F5E68h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820F5E68h case   14:*/		return 0x820F5E6C;
		  /* 820F5E6Ch */ case   15:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820F5E6Ch case   15:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820F5E6Ch case   15:*/		return 0x820F5E70;
		  /* 820F5E70h */ case   16:  		/* cmplwi CR6, R11, 2 */
		/* 820F5E70h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 820F5E70h case   16:*/		return 0x820F5E74;
		  /* 820F5E74h */ case   17:  		/* bc 4, CR6_GT, 236 */
		/* 820F5E74h case   17:*/		if ( !regs.CR[6].gt ) { return 0x820F5F60;  }
		/* 820F5E74h case   17:*/		return 0x820F5E78;
		  /* 820F5E78h */ case   18:  		/* lis R11, -32255 */
		/* 820F5E78h case   18:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820F5E78h case   18:*/		return 0x820F5E7C;
		  /* 820F5E7Ch */ case   19:  		/* mr R10, R30 */
		/* 820F5E7Ch case   19:*/		regs.R10 = regs.R30;
		/* 820F5E7Ch case   19:*/		return 0x820F5E80;
		  /* 820F5E80h */ case   20:  		/* addi R11, R11, 2484 */
		/* 820F5E80h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x9B4);
		/* 820F5E80h case   20:*/		return 0x820F5E84;
		  /* 820F5E84h */ case   21:  		/* addi R8, R11, 2 */
		/* 820F5E84h case   21:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x2);
		/* 820F5E84h case   21:*/		return 0x820F5E88;
		  /* 820F5E88h */ case   22:  		/* lbz R9, <#[R11]> */
		/* 820F5E88h case   22:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820F5E88h case   22:*/		return 0x820F5E8C;
		  /* 820F5E8Ch */ case   23:  		/* lbz R6, <#[R10]> */
		/* 820F5E8Ch case   23:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 820F5E8Ch case   23:*/		return 0x820F5E90;
		  /* 820F5E90h */ case   24:  		/* subf. R9, R6, R9 */
		/* 820F5E90h case   24:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R6,regs.R9);
		/* 820F5E90h case   24:*/		return 0x820F5E94;
		  /* 820F5E94h */ case   25:  		/* bc 4, CR0_EQ, 20 */
		/* 820F5E94h case   25:*/		if ( !regs.CR[0].eq ) { return 0x820F5EA8;  }
		/* 820F5E94h case   25:*/		return 0x820F5E98;
		  /* 820F5E98h */ case   26:  		/* addi R11, R11, 1 */
		/* 820F5E98h case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F5E98h case   26:*/		return 0x820F5E9C;
		  /* 820F5E9Ch */ case   27:  		/* addi R10, R10, 1 */
		/* 820F5E9Ch case   27:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820F5E9Ch case   27:*/		return 0x820F5EA0;
		  /* 820F5EA0h */ case   28:  		/* cmpw CR6, R11, R8 */
		/* 820F5EA0h case   28:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 820F5EA0h case   28:*/		return 0x820F5EA4;
		  /* 820F5EA4h */ case   29:  		/* bc 4, CR6_EQ, -28 */
		/* 820F5EA4h case   29:*/		if ( !regs.CR[6].eq ) { return 0x820F5E88;  }
		/* 820F5EA4h case   29:*/		return 0x820F5EA8;
	}
	return 0x820F5EA8;
} // Block from 820F5E30h-820F5EA8h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820F5EA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5EA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5EA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5EA8);
		  /* 820F5EA8h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820F5EA8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820F5EA8h case    0:*/		return 0x820F5EAC;
		  /* 820F5EACh */ case    1:  		/* bc 4, CR0_EQ, 180 */
		/* 820F5EACh case    1:*/		if ( !regs.CR[0].eq ) { return 0x820F5F60;  }
		/* 820F5EACh case    1:*/		return 0x820F5EB0;
		  /* 820F5EB0h */ case    2:  		/* lwz R11, <#[R29 + 112]> */
		/* 820F5EB0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000070) );
		/* 820F5EB0h case    2:*/		return 0x820F5EB4;
		  /* 820F5EB4h */ case    3:  		/* cmplwi CR6, R11, 4 */
		/* 820F5EB4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 820F5EB4h case    3:*/		return 0x820F5EB8;
		  /* 820F5EB8h */ case    4:  		/* bc 4, CR6_GT, 36 */
		/* 820F5EB8h case    4:*/		if ( !regs.CR[6].gt ) { return 0x820F5EDC;  }
		/* 820F5EB8h case    4:*/		return 0x820F5EBC;
		  /* 820F5EBCh */ case    5:  		/* lis R11, -32254 */
		/* 820F5EBCh case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F5EBCh case    5:*/		return 0x820F5EC0;
		  /* 820F5EC0h */ case    6:  		/* mr R7, R30 */
		/* 820F5EC0h case    6:*/		regs.R7 = regs.R30;
		/* 820F5EC0h case    6:*/		return 0x820F5EC4;
		  /* 820F5EC4h */ case    7:  		/* addi R6, R11, -15588 */
		/* 820F5EC4h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFC31C);
		/* 820F5EC4h case    7:*/		return 0x820F5EC8;
		  /* 820F5EC8h */ case    8:  		/* li R5, 4543 */
		/* 820F5EC8h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x11BF);
		/* 820F5EC8h case    8:*/		return 0x820F5ECC;
		  /* 820F5ECCh */ case    9:  		/* mr R3, R31 */
		/* 820F5ECCh case    9:*/		regs.R3 = regs.R31;
		/* 820F5ECCh case    9:*/		return 0x820F5ED0;
		  /* 820F5ED0h */ case   10:  		/* bl 100448 */
		/* 820F5ED0h case   10:*/		regs.LR = 0x820F5ED4; return 0x8210E730;
		/* 820F5ED0h case   10:*/		return 0x820F5ED4;
		  /* 820F5ED4h */ case   11:  		/* li R11, 1 */
		/* 820F5ED4h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820F5ED4h case   11:*/		return 0x820F5ED8;
		  /* 820F5ED8h */ case   12:  		/* stw R11, <#[R1 + 80]> */
		/* 820F5ED8h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820F5ED8h case   12:*/		return 0x820F5EDC;
	}
	return 0x820F5EDC;
} // Block from 820F5EA8h-820F5EDCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820F5EDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5EDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5EDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5EDC);
		  /* 820F5EDCh */ case    0:  		/* addi R28, R31, 440 */
		/* 820F5EDCh case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x1B8);
		/* 820F5EDCh case    0:*/		return 0x820F5EE0;
		  /* 820F5EE0h */ case    1:  		/* mr R4, R30 */
		/* 820F5EE0h case    1:*/		regs.R4 = regs.R30;
		/* 820F5EE0h case    1:*/		return 0x820F5EE4;
		  /* 820F5EE4h */ case    2:  		/* mr R3, R28 */
		/* 820F5EE4h case    2:*/		regs.R3 = regs.R28;
		/* 820F5EE4h case    2:*/		return 0x820F5EE8;
		  /* 820F5EE8h */ case    3:  		/* bl -316152 */
		/* 820F5EE8h case    3:*/		regs.LR = 0x820F5EEC; return 0x820A8BF0;
		/* 820F5EE8h case    3:*/		return 0x820F5EEC;
		  /* 820F5EECh */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 820F5EECh case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820F5EECh case    4:*/		return 0x820F5EF0;
		  /* 820F5EF0h */ case    5:  		/* bc 4, CR0_EQ, 48 */
		/* 820F5EF0h case    5:*/		if ( !regs.CR[0].eq ) { return 0x820F5F20;  }
		/* 820F5EF0h case    5:*/		return 0x820F5EF4;
		  /* 820F5EF4h */ case    6:  		/* li R6, 1 */
		/* 820F5EF4h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820F5EF4h case    6:*/		return 0x820F5EF8;
		  /* 820F5EF8h */ case    7:  		/* lwz R5, <#[R31 + 468]> */
		/* 820F5EF8h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x000001D4) );
		/* 820F5EF8h case    7:*/		return 0x820F5EFC;
		  /* 820F5EFCh */ case    8:  		/* mr R4, R30 */
		/* 820F5EFCh case    8:*/		regs.R4 = regs.R30;
		/* 820F5EFCh case    8:*/		return 0x820F5F00;
		  /* 820F5F00h */ case    9:  		/* mr R3, R28 */
		/* 820F5F00h case    9:*/		regs.R3 = regs.R28;
		/* 820F5F00h case    9:*/		return 0x820F5F04;
		  /* 820F5F04h */ case   10:  		/* bl -313740 */
		/* 820F5F04h case   10:*/		regs.LR = 0x820F5F08; return 0x820A9578;
		/* 820F5F04h case   10:*/		return 0x820F5F08;
		  /* 820F5F08h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820F5F08h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F5F08h case   11:*/		return 0x820F5F0C;
		  /* 820F5F0Ch */ case   12:  		/* bc 12, CR0_LT, -228 */
		/* 820F5F0Ch case   12:*/		if ( regs.CR[0].lt ) { return 0x820F5E28;  }
		/* 820F5F0Ch case   12:*/		return 0x820F5F10;
		  /* 820F5F10h */ case   13:  		/* lwz R11, <#[R31 + 468]> */
		/* 820F5F10h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000001D4) );
		/* 820F5F10h case   13:*/		return 0x820F5F14;
		  /* 820F5F14h */ case   14:  		/* addi R10, R11, 1 */
		/* 820F5F14h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x1);
		/* 820F5F14h case   14:*/		return 0x820F5F18;
		  /* 820F5F18h */ case   15:  		/* stw R10, <#[R31 + 468]> */
		/* 820F5F18h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x000001D4) );
		/* 820F5F18h case   15:*/		return 0x820F5F1C;
		  /* 820F5F1Ch */ case   16:  		/* b 8 */
		/* 820F5F1Ch case   16:*/		return 0x820F5F24;
		/* 820F5F1Ch case   16:*/		return 0x820F5F20;
	}
	return 0x820F5F20;
} // Block from 820F5EDCh-820F5F20h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820F5F20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5F20);
		  /* 820F5F20h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 820F5F20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820F5F20h case    0:*/		return 0x820F5F24;
	}
	return 0x820F5F24;
} // Block from 820F5F20h-820F5F24h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F5F24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5F24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5F24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5F24);
		  /* 820F5F24h */ case    0:  		/* lwz R10, <#[R31]> */
		/* 820F5F24h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F5F24h case    0:*/		return 0x820F5F28;
		  /* 820F5F28h */ case    1:  		/* mr R5, R11 */
		/* 820F5F28h case    1:*/		regs.R5 = regs.R11;
		/* 820F5F28h case    1:*/		return 0x820F5F2C;
		  /* 820F5F2Ch */ case    2:  		/* lis R4, 0 */
		/* 820F5F2Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x0);
		/* 820F5F2Ch case    2:*/		return 0x820F5F30;
		  /* 820F5F30h */ case    3:  		/* mr R3, R31 */
		/* 820F5F30h case    3:*/		regs.R3 = regs.R31;
		/* 820F5F30h case    3:*/		return 0x820F5F34;
		  /* 820F5F34h */ case    4:  		/* ori R4, R4, 65535 */
		/* 820F5F34h case    4:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0xFFFF);
		/* 820F5F34h case    4:*/		return 0x820F5F38;
		  /* 820F5F38h */ case    5:  		/* lwz R11, <#[R10 + 108]> */
		/* 820F5F38h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000006C) );
		/* 820F5F38h case    5:*/		return 0x820F5F3C;
		  /* 820F5F3Ch */ case    6:  		/* mtspr CTR, R11 */
		/* 820F5F3Ch case    6:*/		regs.CTR = regs.R11;
		/* 820F5F3Ch case    6:*/		return 0x820F5F40;
		  /* 820F5F40h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820F5F40h case    7:*/		if ( 1 ) { regs.LR = 0x820F5F44; return (uint32)regs.CTR; }
		/* 820F5F40h case    7:*/		return 0x820F5F44;
		  /* 820F5F44h */ case    8:  		/* stw R3, <#[R29 + 108]> */
		/* 820F5F44h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000006C) );
		/* 820F5F44h case    8:*/		return 0x820F5F48;
		  /* 820F5F48h */ case    9:  		/* lwz R11, <#[R1 + 80]> */
		/* 820F5F48h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820F5F48h case    9:*/		return 0x820F5F4C;
		  /* 820F5F4Ch */ case   10:  		/* cmpwi CR6, R11, 0 */
		/* 820F5F4Ch case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820F5F4Ch case   10:*/		return 0x820F5F50;
		  /* 820F5F50h */ case   11:  		/* bc 12, CR6_EQ, -300 */
		/* 820F5F50h case   11:*/		if ( regs.CR[6].eq ) { return 0x820F5E24;  }
		/* 820F5F50h case   11:*/		return 0x820F5F54;
		  /* 820F5F54h */ case   12:  		/* lis R3, -32768 */
		/* 820F5F54h case   12:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820F5F54h case   12:*/		return 0x820F5F58;
		  /* 820F5F58h */ case   13:  		/* ori R3, R3, 16389 */
		/* 820F5F58h case   13:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820F5F58h case   13:*/		return 0x820F5F5C;
		  /* 820F5F5Ch */ case   14:  		/* b -308 */
		/* 820F5F5Ch case   14:*/		return 0x820F5E28;
		/* 820F5F5Ch case   14:*/		return 0x820F5F60;
	}
	return 0x820F5F60;
} // Block from 820F5F24h-820F5F60h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820F5F60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5F60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5F60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5F60);
		  /* 820F5F60h */ case    0:  		/* lwz R11, <#[R29 + 108]> */
		/* 820F5F60h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000006C) );
		/* 820F5F60h case    0:*/		return 0x820F5F64;
		  /* 820F5F64h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 820F5F64h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820F5F64h case    1:*/		return 0x820F5F68;
		  /* 820F5F68h */ case    2:  		/* bc 12, CR6_EQ, 76 */
		/* 820F5F68h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F5FB4;  }
		/* 820F5F68h case    2:*/		return 0x820F5F6C;
		  /* 820F5F6Ch */ case    3:  		/* lwz R11, <#[R29]> */
		/* 820F5F6Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820F5F6Ch case    3:*/		return 0x820F5F70;
		  /* 820F5F70h */ case    4:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 820F5F70h case    4:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 820F5F70h case    4:*/		return 0x820F5F74;
		  /* 820F5F74h */ case    5:  		/* bc 12, CR0_EQ, 64 */
		/* 820F5F74h case    5:*/		if ( regs.CR[0].eq ) { return 0x820F5FB4;  }
		/* 820F5F74h case    5:*/		return 0x820F5F78;
		  /* 820F5F78h */ case    6:  		/* cmpwi CR6, R5, 0 */
		/* 820F5F78h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 820F5F78h case    6:*/		return 0x820F5F7C;
		  /* 820F5F7Ch */ case    7:  		/* bc 4, CR6_EQ, 56 */
		/* 820F5F7Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x820F5FB4;  }
		/* 820F5F7Ch case    7:*/		return 0x820F5F80;
		  /* 820F5F80h */ case    8:  		/* li R6, 512 */
		/* 820F5F80h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x200);
		/* 820F5F80h case    8:*/		return 0x820F5F84;
		  /* 820F5F84h */ case    9:  		/* addi R5, R1, 96 */
		/* 820F5F84h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 820F5F84h case    9:*/		return 0x820F5F88;
		  /* 820F5F88h */ case   10:  		/* mr R4, R29 */
		/* 820F5F88h case   10:*/		regs.R4 = regs.R29;
		/* 820F5F88h case   10:*/		return 0x820F5F8C;
		  /* 820F5F8Ch */ case   11:  		/* mr R3, R31 */
		/* 820F5F8Ch case   11:*/		regs.R3 = regs.R31;
		/* 820F5F8Ch case   11:*/		return 0x820F5F90;
		  /* 820F5F90h */ case   12:  		/* bl 30752 */
		/* 820F5F90h case   12:*/		regs.LR = 0x820F5F94; return 0x820FD7B0;
		/* 820F5F90h case   12:*/		return 0x820F5F94;
		  /* 820F5F94h */ case   13:  		/* lis R11, -32254 */
		/* 820F5F94h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F5F94h case   13:*/		return 0x820F5F98;
		  /* 820F5F98h */ case   14:  		/* addi R7, R1, 96 */
		/* 820F5F98h case   14:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820F5F98h case   14:*/		return 0x820F5F9C;
		  /* 820F5F9Ch */ case   15:  		/* addi R6, R11, -15600 */
		/* 820F5F9Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFC310);
		/* 820F5F9Ch case   15:*/		return 0x820F5FA0;
		  /* 820F5FA0h */ case   16:  		/* li R5, 4502 */
		/* 820F5FA0h case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x1196);
		/* 820F5FA0h case   16:*/		return 0x820F5FA4;
		  /* 820F5FA4h */ case   17:  		/* lwz R4, <#[R29 + 104]> */
		/* 820F5FA4h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000068) );
		/* 820F5FA4h case   17:*/		return 0x820F5FA8;
		  /* 820F5FA8h */ case   18:  		/* mr R3, R31 */
		/* 820F5FA8h case   18:*/		regs.R3 = regs.R31;
		/* 820F5FA8h case   18:*/		return 0x820F5FAC;
		  /* 820F5FACh */ case   19:  		/* bl 100228 */
		/* 820F5FACh case   19:*/		regs.LR = 0x820F5FB0; return 0x8210E730;
		/* 820F5FACh case   19:*/		return 0x820F5FB0;
		  /* 820F5FB0h */ case   20:  		/* b -92 */
		/* 820F5FB0h case   20:*/		return 0x820F5F54;
		/* 820F5FB0h case   20:*/		return 0x820F5FB4;
	}
	return 0x820F5FB4;
} // Block from 820F5F60h-820F5FB4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820F5FB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5FB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5FB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5FB4);
		  /* 820F5FB4h */ case    0:  		/* lwz R11, <#[R31 + 112]> */
		/* 820F5FB4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820F5FB4h case    0:*/		return 0x820F5FB8;
		  /* 820F5FB8h */ case    1:  		/* rlwinm. R11, R11, 0, 7, 7 */
		/* 820F5FB8h case    1:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R11,regs.R11);
		/* 820F5FB8h case    1:*/		return 0x820F5FBC;
		  /* 820F5FBCh */ case    2:  		/* lwz R11, <#[R7 + 4]> */
		/* 820F5FBCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000004) );
		/* 820F5FBCh case    2:*/		return 0x820F5FC0;
		  /* 820F5FC0h */ case    3:  		/* bc 12, CR0_EQ, 148 */
		/* 820F5FC0h case    3:*/		if ( regs.CR[0].eq ) { return 0x820F6054;  }
		/* 820F5FC0h case    3:*/		return 0x820F5FC4;
		  /* 820F5FC4h */ case    4:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 820F5FC4h case    4:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 820F5FC4h case    4:*/		return 0x820F5FC8;
		  /* 820F5FC8h */ case    5:  		/* bc 12, CR0_EQ, 96 */
		/* 820F5FC8h case    5:*/		if ( regs.CR[0].eq ) { return 0x820F6028;  }
		/* 820F5FC8h case    5:*/		return 0x820F5FCC;
		  /* 820F5FCCh */ case    6:  		/* rlwinm. R10, R11, 0, 22, 22 */
		/* 820F5FCCh case    6:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R10,regs.R11);
		/* 820F5FCCh case    6:*/		return 0x820F5FD0;
		  /* 820F5FD0h */ case    7:  		/* bc 4, CR0_EQ, 88 */
		/* 820F5FD0h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820F6028;  }
		/* 820F5FD0h case    7:*/		return 0x820F5FD4;
		  /* 820F5FD4h */ case    8:  		/* addi R7, R1, 80 */
		/* 820F5FD4h case    8:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 820F5FD4h case    8:*/		return 0x820F5FD8;
		  /* 820F5FD8h */ case    9:  		/* lwz R5, <#[R31 + 244]> */
		/* 820F5FD8h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x000000F4) );
		/* 820F5FD8h case    9:*/		return 0x820F5FDC;
		  /* 820F5FDCh */ case   10:  		/* li R6, 2 */
		/* 820F5FDCh case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 820F5FDCh case   10:*/		return 0x820F5FE0;
		  /* 820F5FE0h */ case   11:  		/* mr R4, R29 */
		/* 820F5FE0h case   11:*/		regs.R4 = regs.R29;
		/* 820F5FE0h case   11:*/		return 0x820F5FE4;
		  /* 820F5FE4h */ case   12:  		/* mr R3, R31 */
		/* 820F5FE4h case   12:*/		regs.R3 = regs.R31;
		/* 820F5FE4h case   12:*/		return 0x820F5FE8;
		  /* 820F5FE8h */ case   13:  		/* bl -16800 */
		/* 820F5FE8h case   13:*/		regs.LR = 0x820F5FEC; return 0x820F1E48;
		/* 820F5FE8h case   13:*/		return 0x820F5FEC;
		  /* 820F5FECh */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 820F5FECh case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F5FECh case   14:*/		return 0x820F5FF0;
		  /* 820F5FF0h */ case   15:  		/* bc 12, CR0_LT, -456 */
		/* 820F5FF0h case   15:*/		if ( regs.CR[0].lt ) { return 0x820F5E28;  }
		/* 820F5FF0h case   15:*/		return 0x820F5FF4;
		  /* 820F5FF4h */ case   16:  		/* lwz R11, <#[R29 + 108]> */
		/* 820F5FF4h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000006C) );
		/* 820F5FF4h case   16:*/		return 0x820F5FF8;
		  /* 820F5FF8h */ case   17:  		/* cmplwi CR6, R11, 10 */
		/* 820F5FF8h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000A);
		/* 820F5FF8h case   17:*/		return 0x820F5FFC;
		  /* 820F5FFCh */ case   18:  		/* bc 4, CR6_EQ, -180 */
		/* 820F5FFCh case   18:*/		if ( !regs.CR[6].eq ) { return 0x820F5F48;  }
		/* 820F5FFCh case   18:*/		return 0x820F6000;
		  /* 820F6000h */ case   19:  		/* lwz R11, <#[R29 + 16]> */
		/* 820F6000h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 820F6000h case   19:*/		return 0x820F6004;
		  /* 820F6004h */ case   20:  		/* cmplwi CR6, R11, 0 */
		/* 820F6004h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F6004h case   20:*/		return 0x820F6008;
		  /* 820F6008h */ case   21:  		/* bc 4, CR6_EQ, -192 */
		/* 820F6008h case   21:*/		if ( !regs.CR[6].eq ) { return 0x820F5F48;  }
		/* 820F6008h case   21:*/		return 0x820F600C;
		  /* 820F600Ch */ case   22:  		/* mr R4, R29 */
		/* 820F600Ch case   22:*/		regs.R4 = regs.R29;
		/* 820F600Ch case   22:*/		return 0x820F6010;
		  /* 820F6010h */ case   23:  		/* mr R3, R31 */
		/* 820F6010h case   23:*/		regs.R3 = regs.R31;
		/* 820F6010h case   23:*/		return 0x820F6014;
		  /* 820F6014h */ case   24:  		/* bl 28132 */
		/* 820F6014h case   24:*/		regs.LR = 0x820F6018; return 0x820FCDF8;
		/* 820F6014h case   24:*/		return 0x820F6018;
		  /* 820F6018h */ case   25:  		/* lis R11, -32254 */
		/* 820F6018h case   25:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F6018h case   25:*/		return 0x820F601C;
		  /* 820F601Ch */ case   26:  		/* mr R7, R3 */
		/* 820F601Ch case   26:*/		regs.R7 = regs.R3;
		/* 820F601Ch case   26:*/		return 0x820F6020;
		  /* 820F6020h */ case   27:  		/* addi R6, R11, -15636 */
		/* 820F6020h case   27:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFC2EC);
		/* 820F6020h case   27:*/		return 0x820F6024;
		  /* 820F6024h */ case   28:  		/* b -132 */
		/* 820F6024h case   28:*/		return 0x820F5FA0;
		/* 820F6024h case   28:*/		return 0x820F6028;
	}
	return 0x820F6028;
} // Block from 820F5FB4h-820F6028h (29 instructions)

//////////////////////////////////////////////////////
// Block at 820F6028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6028);
		  /* 820F6028h */ case    0:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 820F6028h case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 820F6028h case    0:*/		return 0x820F602C;
		  /* 820F602Ch */ case    1:  		/* bc 12, CR0_EQ, -520 */
		/* 820F602Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820F5E24;  }
		/* 820F602Ch case    1:*/		return 0x820F6030;
		  /* 820F6030h */ case    2:  		/* lwz R5, <#[R31 + 248]> */
		/* 820F6030h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x000000F8) );
		/* 820F6030h case    2:*/		return 0x820F6034;
		  /* 820F6034h */ case    3:  		/* li R6, 2 */
		/* 820F6034h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 820F6034h case    3:*/		return 0x820F6038;
		  /* 820F6038h */ case    4:  		/* addi R7, R1, 80 */
		/* 820F6038h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 820F6038h case    4:*/		return 0x820F603C;
		  /* 820F603Ch */ case    5:  		/* mr R4, R29 */
		/* 820F603Ch case    5:*/		regs.R4 = regs.R29;
		/* 820F603Ch case    5:*/		return 0x820F6040;
		  /* 820F6040h */ case    6:  		/* mr R3, R31 */
		/* 820F6040h case    6:*/		regs.R3 = regs.R31;
		/* 820F6040h case    6:*/		return 0x820F6044;
		  /* 820F6044h */ case    7:  		/* bl -16892 */
		/* 820F6044h case    7:*/		regs.LR = 0x820F6048; return 0x820F1E48;
		/* 820F6044h case    7:*/		return 0x820F6048;
		  /* 820F6048h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 820F6048h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6048h case    8:*/		return 0x820F604C;
		  /* 820F604Ch */ case    9:  		/* bc 4, CR0_LT, -260 */
		/* 820F604Ch case    9:*/		if ( !regs.CR[0].lt ) { return 0x820F5F48;  }
		/* 820F604Ch case    9:*/		return 0x820F6050;
		  /* 820F6050h */ case   10:  		/* b -552 */
		/* 820F6050h case   10:*/		return 0x820F5E28;
		/* 820F6050h case   10:*/		return 0x820F6054;
	}
	return 0x820F6054;
} // Block from 820F6028h-820F6054h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820F6054h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6054( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6054) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6054);
		  /* 820F6054h */ case    0:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 820F6054h case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 820F6054h case    0:*/		return 0x820F6058;
		  /* 820F6058h */ case    1:  		/* bc 12, CR0_EQ, 128 */
		/* 820F6058h case    1:*/		if ( regs.CR[0].eq ) { return 0x820F60D8;  }
		/* 820F6058h case    1:*/		return 0x820F605C;
		  /* 820F605Ch */ case    2:  		/* rlwinm. R10, R11, 0, 22, 22 */
		/* 820F605Ch case    2:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R10,regs.R11);
		/* 820F605Ch case    2:*/		return 0x820F6060;
		  /* 820F6060h */ case    3:  		/* bc 4, CR0_EQ, 120 */
		/* 820F6060h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820F60D8;  }
		/* 820F6060h case    3:*/		return 0x820F6064;
		  /* 820F6064h */ case    4:  		/* addi R7, R1, 80 */
		/* 820F6064h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 820F6064h case    4:*/		return 0x820F6068;
		  /* 820F6068h */ case    5:  		/* lwz R5, <#[R31 + 248]> */
		/* 820F6068h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x000000F8) );
		/* 820F6068h case    5:*/		return 0x820F606C;
		  /* 820F606Ch */ case    6:  		/* li R6, 1 */
		/* 820F606Ch case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820F606Ch case    6:*/		return 0x820F6070;
		  /* 820F6070h */ case    7:  		/* mr R4, R29 */
		/* 820F6070h case    7:*/		regs.R4 = regs.R29;
		/* 820F6070h case    7:*/		return 0x820F6074;
		  /* 820F6074h */ case    8:  		/* mr R3, R31 */
		/* 820F6074h case    8:*/		regs.R3 = regs.R31;
		/* 820F6074h case    8:*/		return 0x820F6078;
		  /* 820F6078h */ case    9:  		/* bl -16944 */
		/* 820F6078h case    9:*/		regs.LR = 0x820F607C; return 0x820F1E48;
		/* 820F6078h case    9:*/		return 0x820F607C;
		  /* 820F607Ch */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 820F607Ch case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F607Ch case   10:*/		return 0x820F6080;
		  /* 820F6080h */ case   11:  		/* bc 12, CR0_LT, -600 */
		/* 820F6080h case   11:*/		if ( regs.CR[0].lt ) { return 0x820F5E28;  }
		/* 820F6080h case   11:*/		return 0x820F6084;
		  /* 820F6084h */ case   12:  		/* lwz R11, <#[R31 + 40]> */
		/* 820F6084h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820F6084h case   12:*/		return 0x820F6088;
		  /* 820F6088h */ case   13:  		/* cmplwi CR6, R11, 2 */
		/* 820F6088h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 820F6088h case   13:*/		return 0x820F608C;
		  /* 820F608Ch */ case   14:  		/* bc 4, CR6_EQ, -324 */
		/* 820F608Ch case   14:*/		if ( !regs.CR[6].eq ) { return 0x820F5F48;  }
		/* 820F608Ch case   14:*/		return 0x820F6090;
		  /* 820F6090h */ case   15:  		/* lwz R11, <#[R31]> */
		/* 820F6090h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6090h case   15:*/		return 0x820F6094;
		  /* 820F6094h */ case   16:  		/* mr R3, R31 */
		/* 820F6094h case   16:*/		regs.R3 = regs.R31;
		/* 820F6094h case   16:*/		return 0x820F6098;
		  /* 820F6098h */ case   17:  		/* lwz R4, <#[R29 + 108]> */
		/* 820F6098h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x0000006C) );
		/* 820F6098h case   17:*/		return 0x820F609C;
		  /* 820F609Ch */ case   18:  		/* lwz R11, <#[R11 + 112]> */
		/* 820F609Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000070) );
		/* 820F609Ch case   18:*/		return 0x820F60A0;
		  /* 820F60A0h */ case   19:  		/* mtspr CTR, R11 */
		/* 820F60A0h case   19:*/		regs.CTR = regs.R11;
		/* 820F60A0h case   19:*/		return 0x820F60A4;
		  /* 820F60A4h */ case   20:  		/* bcctrl 20, CR0_LT */
		/* 820F60A4h case   20:*/		if ( 1 ) { regs.LR = 0x820F60A8; return (uint32)regs.CTR; }
		/* 820F60A4h case   20:*/		return 0x820F60A8;
		  /* 820F60A8h */ case   21:  		/* cmplwi CR6, R3, 11 */
		/* 820F60A8h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x0000000B);
		/* 820F60A8h case   21:*/		return 0x820F60AC;
		  /* 820F60ACh */ case   22:  		/* bc 4, CR6_EQ, -356 */
		/* 820F60ACh case   22:*/		if ( !regs.CR[6].eq ) { return 0x820F5F48;  }
		/* 820F60ACh case   22:*/		return 0x820F60B0;
		  /* 820F60B0h */ case   23:  		/* lis R11, -32256 */
		/* 820F60B0h case   23:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820F60B0h case   23:*/		return 0x820F60B4;
		  /* 820F60B4h */ case   24:  		/* lwz R10, <#[R29]> */
		/* 820F60B4h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 820F60B4h case   24:*/		return 0x820F60B8;
		  /* 820F60B8h */ case   25:  		/* lis R9, -32256 */
		/* 820F60B8h case   25:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 820F60B8h case   25:*/		return 0x820F60BC;
		  /* 820F60BCh */ case   26:  		/* ori R10, R10, 276 */
		/* 820F60BCh case   26:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x114);
		/* 820F60BCh case   26:*/		return 0x820F60C0;
		  /* 820F60C0h */ case   27:  		/* stw R10, <#[R29]> */
		/* 820F60C0h case   27:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 820F60C0h case   27:*/		return 0x820F60C4;
		  /* 820F60C4h */ case   28:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 820F60C4h case   28:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 820F60C4h case   28:*/		return 0x820F60C8;
		  /* 820F60C8h */ case   29:  		/* lfd FR13, <#[R9 + 1848]> */
		/* 820F60C8h case   29:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R9 + 0x00000738) );
		/* 820F60C8h case   29:*/		return 0x820F60CC;
		  /* 820F60CCh */ case   30:  		/* stfd FR0, <#[R29 + 32]> */
		/* 820F60CCh case   30:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R29 + 0x00000020) );
		/* 820F60CCh case   30:*/		return 0x820F60D0;
		  /* 820F60D0h */ case   31:  		/* stfd FR13, <#[R29 + 40]> */
		/* 820F60D0h case   31:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R29 + 0x00000028) );
		/* 820F60D0h case   31:*/		return 0x820F60D4;
		  /* 820F60D4h */ case   32:  		/* b -396 */
		/* 820F60D4h case   32:*/		return 0x820F5F48;
		/* 820F60D4h case   32:*/		return 0x820F60D8;
	}
	return 0x820F60D8;
} // Block from 820F6054h-820F60D8h (33 instructions)

//////////////////////////////////////////////////////
// Block at 820F60D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F60D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F60D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F60D8);
		  /* 820F60D8h */ case    0:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 820F60D8h case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 820F60D8h case    0:*/		return 0x820F60DC;
		  /* 820F60DCh */ case    1:  		/* bc 12, CR0_EQ, -696 */
		/* 820F60DCh case    1:*/		if ( regs.CR[0].eq ) { return 0x820F5E24;  }
		/* 820F60DCh case    1:*/		return 0x820F60E0;
		  /* 820F60E0h */ case    2:  		/* lwz R5, <#[R31 + 252]> */
		/* 820F60E0h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x000000FC) );
		/* 820F60E0h case    2:*/		return 0x820F60E4;
		  /* 820F60E4h */ case    3:  		/* li R6, 1 */
		/* 820F60E4h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820F60E4h case    3:*/		return 0x820F60E8;
		  /* 820F60E8h */ case    4:  		/* b -176 */
		/* 820F60E8h case    4:*/		return 0x820F6038;
		/* 820F60E8h case    4:*/		return 0x820F60EC;
		  /* 820F60ECh */ case    5:  		/* nop */
		/* 820F60ECh case    5:*/		cpu::op::nop();
		/* 820F60ECh case    5:*/		return 0x820F60F0;
	}
	return 0x820F60F0;
} // Block from 820F60D8h-820F60F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F60F0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F60F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F60F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F60F0);
		  /* 820F60F0h */ case    0:  		/* mfspr R12, LR */
		/* 820F60F0h case    0:*/		regs.R12 = regs.LR;
		/* 820F60F0h case    0:*/		return 0x820F60F4;
		  /* 820F60F4h */ case    1:  		/* bl -413336 */
		/* 820F60F4h case    1:*/		regs.LR = 0x820F60F8; return 0x8209125C;
		/* 820F60F4h case    1:*/		return 0x820F60F8;
		  /* 820F60F8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820F60F8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820F60F8h case    2:*/		return 0x820F60FC;
		  /* 820F60FCh */ case    3:  		/* lwz R11, <#[R3 + 204]> */
		/* 820F60FCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000CC) );
		/* 820F60FCh case    3:*/		return 0x820F6100;
		  /* 820F6100h */ case    4:  		/* mr R31, R3 */
		/* 820F6100h case    4:*/		regs.R31 = regs.R3;
		/* 820F6100h case    4:*/		return 0x820F6104;
		  /* 820F6104h */ case    5:  		/* mr R29, R4 */
		/* 820F6104h case    5:*/		regs.R29 = regs.R4;
		/* 820F6104h case    5:*/		return 0x820F6108;
		  /* 820F6108h */ case    6:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 820F6108h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 820F6108h case    6:*/		return 0x820F610C;
		  /* 820F610Ch */ case    7:  		/* bc 12, CR0_EQ, 224 */
		/* 820F610Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820F61EC;  }
		/* 820F610Ch case    7:*/		return 0x820F6110;
		  /* 820F6110h */ case    8:  		/* lwz R11, <#[R3 + 296]> */
		/* 820F6110h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000128) );
		/* 820F6110h case    8:*/		return 0x820F6114;
		  /* 820F6114h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820F6114h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F6114h case    9:*/		return 0x820F6118;
		  /* 820F6118h */ case   10:  		/* bc 12, CR6_EQ, 212 */
		/* 820F6118h case   10:*/		if ( regs.CR[6].eq ) { return 0x820F61EC;  }
		/* 820F6118h case   10:*/		return 0x820F611C;
		  /* 820F611Ch */ case   11:  		/* lwz R11, <#[R3 + 304]> */
		/* 820F611Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000130) );
		/* 820F611Ch case   11:*/		return 0x820F6120;
		  /* 820F6120h */ case   12:  		/* lwz R10, <#[R3 + 300]> */
		/* 820F6120h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000012C) );
		/* 820F6120h case   12:*/		return 0x820F6124;
		  /* 820F6124h */ case   13:  		/* cmplw CR6, R10, R11 */
		/* 820F6124h case   13:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820F6124h case   13:*/		return 0x820F6128;
		  /* 820F6128h */ case   14:  		/* bc 12, CR6_LT, 84 */
		/* 820F6128h case   14:*/		if ( regs.CR[6].lt ) { return 0x820F617C;  }
		/* 820F6128h case   14:*/		return 0x820F612C;
		  /* 820F612Ch */ case   15:  		/* mulli R3, R11, 48 */
		/* 820F612Ch case   15:*/		cpu::op::mulli<0>(regs,&regs.R3,regs.R11,0x30);
		/* 820F612Ch case   15:*/		return 0x820F6130;
		  /* 820F6130h */ case   16:  		/* lis R4, 9345 */
		/* 820F6130h case   16:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F6130h case   16:*/		return 0x820F6134;
		  /* 820F6134h */ case   17:  		/* bl -450356 */
		/* 820F6134h case   17:*/		regs.LR = 0x820F6138; return 0x82088200;
		/* 820F6134h case   17:*/		return 0x820F6138;
		  /* 820F6138h */ case   18:  		/* or. R30, R3, R3 */
		/* 820F6138h case   18:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F6138h case   18:*/		return 0x820F613C;
		  /* 820F613Ch */ case   19:  		/* bc 4, CR0_EQ, 16 */
		/* 820F613Ch case   19:*/		if ( !regs.CR[0].eq ) { return 0x820F614C;  }
		/* 820F613Ch case   19:*/		return 0x820F6140;
		  /* 820F6140h */ case   20:  		/* lis R3, -32761 */
		/* 820F6140h case   20:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820F6140h case   20:*/		return 0x820F6144;
		  /* 820F6144h */ case   21:  		/* ori R3, R3, 14 */
		/* 820F6144h case   21:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820F6144h case   21:*/		return 0x820F6148;
		  /* 820F6148h */ case   22:  		/* b 188 */
		/* 820F6148h case   22:*/		return 0x820F6204;
		/* 820F6148h case   22:*/		return 0x820F614C;
	}
	return 0x820F614C;
} // Block from 820F60F0h-820F614Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 820F614Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F614C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F614C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F614C);
		  /* 820F614Ch */ case    0:  		/* lwz R11, <#[R31 + 300]> */
		/* 820F614Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000012C) );
		/* 820F614Ch case    0:*/		return 0x820F6150;
		  /* 820F6150h */ case    1:  		/* mr R3, R30 */
		/* 820F6150h case    1:*/		regs.R3 = regs.R30;
		/* 820F6150h case    1:*/		return 0x820F6154;
		  /* 820F6154h */ case    2:  		/* lwz R4, <#[R31 + 296]> */
		/* 820F6154h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000128) );
		/* 820F6154h case    2:*/		return 0x820F6158;
		  /* 820F6158h */ case    3:  		/* mulli R5, R11, 24 */
		/* 820F6158h case    3:*/		cpu::op::mulli<0>(regs,&regs.R5,regs.R11,0x18);
		/* 820F6158h case    3:*/		return 0x820F615C;
		  /* 820F615Ch */ case    4:  		/* bl -411564 */
		/* 820F615Ch case    4:*/		regs.LR = 0x820F6160; return 0x820919B0;
		/* 820F615Ch case    4:*/		return 0x820F6160;
		  /* 820F6160h */ case    5:  		/* lwz R3, <#[R31 + 296]> */
		/* 820F6160h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000128) );
		/* 820F6160h case    5:*/		return 0x820F6164;
		  /* 820F6164h */ case    6:  		/* lis R4, 9345 */
		/* 820F6164h case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F6164h case    6:*/		return 0x820F6168;
		  /* 820F6168h */ case    7:  		/* bl -450096 */
		/* 820F6168h case    7:*/		regs.LR = 0x820F616C; return 0x82088338;
		/* 820F6168h case    7:*/		return 0x820F616C;
		  /* 820F616Ch */ case    8:  		/* lwz R11, <#[R31 + 304]> */
		/* 820F616Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000130) );
		/* 820F616Ch case    8:*/		return 0x820F6170;
		  /* 820F6170h */ case    9:  		/* stw R30, <#[R31 + 296]> */
		/* 820F6170h case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000128) );
		/* 820F6170h case    9:*/		return 0x820F6174;
		  /* 820F6174h */ case   10:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 820F6174h case   10:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 820F6174h case   10:*/		return 0x820F6178;
		  /* 820F6178h */ case   11:  		/* stw R11, <#[R31 + 304]> */
		/* 820F6178h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000130) );
		/* 820F6178h case   11:*/		return 0x820F617C;
	}
	return 0x820F617C;
} // Block from 820F614Ch-820F617Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820F617Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F617C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F617C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F617C);
		  /* 820F617Ch */ case    0:  		/* lwz R9, <#[R31 + 300]> */
		/* 820F617Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000012C) );
		/* 820F617Ch case    0:*/		return 0x820F6180;
		  /* 820F6180h */ case    1:  		/* li R10, 4 */
		/* 820F6180h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 820F6180h case    1:*/		return 0x820F6184;
		  /* 820F6184h */ case    2:  		/* lwz R8, <#[R31 + 296]> */
		/* 820F6184h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000128) );
		/* 820F6184h case    2:*/		return 0x820F6188;
		  /* 820F6188h */ case    3:  		/* li R11, 0 */
		/* 820F6188h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F6188h case    3:*/		return 0x820F618C;
		  /* 820F618Ch */ case    4:  		/* lwz R7, <#[R31 + 264]> */
		/* 820F618Ch case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000108) );
		/* 820F618Ch case    4:*/		return 0x820F6190;
		  /* 820F6190h */ case    5:  		/* mulli R9, R9, 24 */
		/* 820F6190h case    5:*/		cpu::op::mulli<0>(regs,&regs.R9,regs.R9,0x18);
		/* 820F6190h case    5:*/		return 0x820F6194;
		  /* 820F6194h */ case    6:  		/* mtspr CTR, R10 */
		/* 820F6194h case    6:*/		regs.CTR = regs.R10;
		/* 820F6194h case    6:*/		return 0x820F6198;
		  /* 820F6198h */ case    7:  		/* stwx R7, <#[R9 + R8]> */
		/* 820F6198h case    7:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820F6198h case    7:*/		return 0x820F619C;
		  /* 820F619Ch */ case    8:  		/* lwz R9, <#[R31 + 296]> */
		/* 820F619Ch case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000128) );
		/* 820F619Ch case    8:*/		return 0x820F61A0;
		  /* 820F61A0h */ case    9:  		/* lwz R8, <#[R31 + 276]> */
		/* 820F61A0h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000114) );
		/* 820F61A0h case    9:*/		return 0x820F61A4;
		  /* 820F61A4h */ case   10:  		/* lwz R10, <#[R31 + 300]> */
		/* 820F61A4h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000012C) );
		/* 820F61A4h case   10:*/		return 0x820F61A8;
		  /* 820F61A8h */ case   11:  		/* mulli R10, R10, 24 */
		/* 820F61A8h case   11:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x18);
		/* 820F61A8h case   11:*/		return 0x820F61AC;
		  /* 820F61ACh */ case   12:  		/* add R10, R10, R9 */
		/* 820F61ACh case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820F61ACh case   12:*/		return 0x820F61B0;
		  /* 820F61B0h */ case   13:  		/* rlwinm R9, R8, 2, 0, 29 */
		/* 820F61B0h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 820F61B0h case   13:*/		return 0x820F61B4;
		  /* 820F61B4h */ case   14:  		/* stw R9, <#[R10 + 4]> */
		/* 820F61B4h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 820F61B4h case   14:*/		return 0x820F61B8;
		  /* 820F61B8h */ case   15:  		/* lwz R10, <#[R31 + 300]> */
		/* 820F61B8h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000012C) );
		/* 820F61B8h case   15:*/		return 0x820F61BC;
		  /* 820F61BCh */ case   16:  		/* li R9, -1 */
		/* 820F61BCh case   16:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 820F61BCh case   16:*/		return 0x820F61C0;
		  /* 820F61C0h */ case   17:  		/* lwz R8, <#[R31 + 296]> */
		/* 820F61C0h case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000128) );
		/* 820F61C0h case   17:*/		return 0x820F61C4;
		  /* 820F61C4h */ case   18:  		/* mulli R10, R10, 6 */
		/* 820F61C4h case   18:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x6);
		/* 820F61C4h case   18:*/		return 0x820F61C8;
		  /* 820F61C8h */ case   19:  		/* add R10, R10, R11 */
		/* 820F61C8h case   19:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820F61C8h case   19:*/		return 0x820F61CC;
		  /* 820F61CCh */ case   20:  		/* addi R11, R11, 1 */
		/* 820F61CCh case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F61CCh case   20:*/		return 0x820F61D0;
		  /* 820F61D0h */ case   21:  		/* addi R10, R10, 2 */
		/* 820F61D0h case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 820F61D0h case   21:*/		return 0x820F61D4;
		  /* 820F61D4h */ case   22:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F61D4h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F61D4h case   22:*/		return 0x820F61D8;
		  /* 820F61D8h */ case   23:  		/* stwx R9, <#[R10 + R8]> */
		/* 820F61D8h case   23:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820F61D8h case   23:*/		return 0x820F61DC;
		  /* 820F61DCh */ case   24:  		/* bc 16, CR0_LT, -36 */
		/* 820F61DCh case   24:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F61B8;  }
		/* 820F61DCh case   24:*/		return 0x820F61E0;
		  /* 820F61E0h */ case   25:  		/* lwz R11, <#[R31 + 300]> */
		/* 820F61E0h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000012C) );
		/* 820F61E0h case   25:*/		return 0x820F61E4;
		  /* 820F61E4h */ case   26:  		/* addi R11, R11, 1 */
		/* 820F61E4h case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F61E4h case   26:*/		return 0x820F61E8;
		  /* 820F61E8h */ case   27:  		/* stw R11, <#[R31 + 300]> */
		/* 820F61E8h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000012C) );
		/* 820F61E8h case   27:*/		return 0x820F61EC;
	}
	return 0x820F61EC;
} // Block from 820F617Ch-820F61ECh (28 instructions)

//////////////////////////////////////////////////////
// Block at 820F61ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F61EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F61EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F61EC);
		  /* 820F61ECh */ case    0:  		/* lwz R11, <#[R31 + 276]> */
		/* 820F61ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000114) );
		/* 820F61ECh case    0:*/		return 0x820F61F0;
		  /* 820F61F0h */ case    1:  		/* mr R4, R29 */
		/* 820F61F0h case    1:*/		regs.R4 = regs.R29;
		/* 820F61F0h case    1:*/		return 0x820F61F4;
		  /* 820F61F4h */ case    2:  		/* mr R3, R31 */
		/* 820F61F4h case    2:*/		regs.R3 = regs.R31;
		/* 820F61F4h case    2:*/		return 0x820F61F8;
		  /* 820F61F8h */ case    3:  		/* stw R11, <#[R31 + 284]> */
		/* 820F61F8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000011C) );
		/* 820F61F8h case    3:*/		return 0x820F61FC;
		  /* 820F61FCh */ case    4:  		/* bl -11916 */
		/* 820F61FCh case    4:*/		regs.LR = 0x820F6200; return 0x820F3370;
		/* 820F61FCh case    4:*/		return 0x820F6200;
		  /* 820F6200h */ case    5:  		/* li R3, 0 */
		/* 820F6200h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F6200h case    5:*/		return 0x820F6204;
	}
	return 0x820F6204;
} // Block from 820F61ECh-820F6204h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F6204h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6204( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6204) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6204);
		  /* 820F6204h */ case    0:  		/* addi R1, R1, 112 */
		/* 820F6204h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820F6204h case    0:*/		return 0x820F6208;
		  /* 820F6208h */ case    1:  		/* b -413532 */
		/* 820F6208h case    1:*/		return 0x820912AC;
		/* 820F6208h case    1:*/		return 0x820F620C;
		  /* 820F620Ch */ case    2:  		/* nop */
		/* 820F620Ch case    2:*/		cpu::op::nop();
		/* 820F620Ch case    2:*/		return 0x820F6210;
	}
	return 0x820F6210;
} // Block from 820F6204h-820F6210h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F6210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6210);
		  /* 820F6210h */ case    0:  		/* mfspr R12, LR */
		/* 820F6210h case    0:*/		regs.R12 = regs.LR;
		/* 820F6210h case    0:*/		return 0x820F6214;
		  /* 820F6214h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820F6214h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F6214h case    1:*/		return 0x820F6218;
		  /* 820F6218h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820F6218h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820F6218h case    2:*/		return 0x820F621C;
		  /* 820F621Ch */ case    3:  		/* bl -11948 */
		/* 820F621Ch case    3:*/		regs.LR = 0x820F6220; return 0x820F3370;
		/* 820F621Ch case    3:*/		return 0x820F6220;
		  /* 820F6220h */ case    4:  		/* srawi R11, R3, 31 */
		/* 820F6220h case    4:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 820F6220h case    4:*/		return 0x820F6224;
		  /* 820F6224h */ case    5:  		/* and R3, R11, R3 */
		/* 820F6224h case    5:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820F6224h case    5:*/		return 0x820F6228;
		  /* 820F6228h */ case    6:  		/* addi R1, R1, 96 */
		/* 820F6228h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820F6228h case    6:*/		return 0x820F622C;
		  /* 820F622Ch */ case    7:  		/* lwz R12, <#[R1 - 8]> */
		/* 820F622Ch case    7:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F622Ch case    7:*/		return 0x820F6230;
		  /* 820F6230h */ case    8:  		/* mtspr LR, R12 */
		/* 820F6230h case    8:*/		regs.LR = regs.R12;
		/* 820F6230h case    8:*/		return 0x820F6234;
		  /* 820F6234h */ case    9:  		/* bclr 20, CR0_LT */
		/* 820F6234h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F6234h case    9:*/		return 0x820F6238;
	}
	return 0x820F6238;
} // Block from 820F6210h-820F6238h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F6238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6238);
		  /* 820F6238h */ case    0:  		/* mfspr R12, LR */
		/* 820F6238h case    0:*/		regs.R12 = regs.LR;
		/* 820F6238h case    0:*/		return 0x820F623C;
		  /* 820F623Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820F623Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F623Ch case    1:*/		return 0x820F6240;
		  /* 820F6240h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820F6240h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820F6240h case    2:*/		return 0x820F6244;
		  /* 820F6244h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820F6244h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F6244h case    3:*/		return 0x820F6248;
		  /* 820F6248h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820F6248h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820F6248h case    4:*/		return 0x820F624C;
		  /* 820F624Ch */ case    5:  		/* or R4, R4, R5 */
		/* 820F624Ch case    5:*/		cpu::op::or<0>(regs,&regs.R4,regs.R4,regs.R5);
		/* 820F624Ch case    5:*/		return 0x820F6250;
		  /* 820F6250h */ case    6:  		/* mr R31, R3 */
		/* 820F6250h case    6:*/		regs.R31 = regs.R3;
		/* 820F6250h case    6:*/		return 0x820F6254;
		  /* 820F6254h */ case    7:  		/* mr R30, R6 */
		/* 820F6254h case    7:*/		regs.R30 = regs.R6;
		/* 820F6254h case    7:*/		return 0x820F6258;
		  /* 820F6258h */ case    8:  		/* bl -12008 */
		/* 820F6258h case    8:*/		regs.LR = 0x820F625C; return 0x820F3370;
		/* 820F6258h case    8:*/		return 0x820F625C;
		  /* 820F625Ch */ case    9:  		/* srawi R11, R3, 31 */
		/* 820F625Ch case    9:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 820F625Ch case    9:*/		return 0x820F6260;
		  /* 820F6260h */ case   10:  		/* and R3, R11, R3 */
		/* 820F6260h case   10:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820F6260h case   10:*/		return 0x820F6264;
		  /* 820F6264h */ case   11:  		/* cmpwi CR6, R3, 0 */
		/* 820F6264h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820F6264h case   11:*/		return 0x820F6268;
		  /* 820F6268h */ case   12:  		/* bc 12, CR6_LT, 68 */
		/* 820F6268h case   12:*/		if ( regs.CR[6].lt ) { return 0x820F62AC;  }
		/* 820F6268h case   12:*/		return 0x820F626C;
		  /* 820F626Ch */ case   13:  		/* cmplwi CR6, R30, 0 */
		/* 820F626Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820F626Ch case   13:*/		return 0x820F6270;
		  /* 820F6270h */ case   14:  		/* bc 12, CR6_EQ, 56 */
		/* 820F6270h case   14:*/		if ( regs.CR[6].eq ) { return 0x820F62A8;  }
		/* 820F6270h case   14:*/		return 0x820F6274;
		  /* 820F6274h */ case   15:  		/* mr R4, R30 */
		/* 820F6274h case   15:*/		regs.R4 = regs.R30;
		/* 820F6274h case   15:*/		return 0x820F6278;
		  /* 820F6278h */ case   16:  		/* mr R3, R31 */
		/* 820F6278h case   16:*/		regs.R3 = regs.R31;
		/* 820F6278h case   16:*/		return 0x820F627C;
		  /* 820F627Ch */ case   17:  		/* bl -12044 */
		/* 820F627Ch case   17:*/		regs.LR = 0x820F6280; return 0x820F3370;
		/* 820F627Ch case   17:*/		return 0x820F6280;
		  /* 820F6280h */ case   18:  		/* srawi R11, R3, 31 */
		/* 820F6280h case   18:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 820F6280h case   18:*/		return 0x820F6284;
		  /* 820F6284h */ case   19:  		/* and R3, R11, R3 */
		/* 820F6284h case   19:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820F6284h case   19:*/		return 0x820F6288;
		  /* 820F6288h */ case   20:  		/* cmpwi CR6, R3, 0 */
		/* 820F6288h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820F6288h case   20:*/		return 0x820F628C;
		  /* 820F628Ch */ case   21:  		/* bc 12, CR6_LT, 32 */
		/* 820F628Ch case   21:*/		if ( regs.CR[6].lt ) { return 0x820F62AC;  }
		/* 820F628Ch case   21:*/		return 0x820F6290;
		  /* 820F6290h */ case   22:  		/* lwz R10, <#[R31 + 284]> */
		/* 820F6290h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000011C) );
		/* 820F6290h case   22:*/		return 0x820F6294;
		  /* 820F6294h */ case   23:  		/* lwz R11, <#[R31 + 272]> */
		/* 820F6294h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000110) );
		/* 820F6294h case   23:*/		return 0x820F6298;
		  /* 820F6298h */ case   24:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F6298h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F6298h case   24:*/		return 0x820F629C;
		  /* 820F629Ch */ case   25:  		/* lwzx R9, <#[R10 + R11]> */
		/* 820F629Ch case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820F629Ch case   25:*/		return 0x820F62A0;
		  /* 820F62A0h */ case   26:  		/* oris R9, R9, 4096 */
		/* 820F62A0h case   26:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R9,0x1000);
		/* 820F62A0h case   26:*/		return 0x820F62A4;
		  /* 820F62A4h */ case   27:  		/* stwx R9, <#[R10 + R11]> */
		/* 820F62A4h case   27:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820F62A4h case   27:*/		return 0x820F62A8;
	}
	return 0x820F62A8;
} // Block from 820F6238h-820F62A8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820F62A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F62A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F62A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F62A8);
		  /* 820F62A8h */ case    0:  		/* li R3, 0 */
		/* 820F62A8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F62A8h case    0:*/		return 0x820F62AC;
	}
	return 0x820F62AC;
} // Block from 820F62A8h-820F62ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F62ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F62AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F62AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F62AC);
		  /* 820F62ACh */ case    0:  		/* addi R1, R1, 112 */
		/* 820F62ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820F62ACh case    0:*/		return 0x820F62B0;
		  /* 820F62B0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820F62B0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F62B0h case    1:*/		return 0x820F62B4;
		  /* 820F62B4h */ case    2:  		/* mtspr LR, R12 */
		/* 820F62B4h case    2:*/		regs.LR = regs.R12;
		/* 820F62B4h case    2:*/		return 0x820F62B8;
		  /* 820F62B8h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820F62B8h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820F62B8h case    3:*/		return 0x820F62BC;
		  /* 820F62BCh */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820F62BCh case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F62BCh case    4:*/		return 0x820F62C0;
		  /* 820F62C0h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820F62C0h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F62C0h case    5:*/		return 0x820F62C4;
	}
	return 0x820F62C4;
} // Block from 820F62ACh-820F62C4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F62C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F62C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F62C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F62C4);
		  /* 820F62C4h */ case    0:  		/* nop */
		/* 820F62C4h case    0:*/		cpu::op::nop();
		/* 820F62C4h case    0:*/		return 0x820F62C8;
	}
	return 0x820F62C8;
} // Block from 820F62C4h-820F62C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F62C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F62C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F62C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F62C8);
		  /* 820F62C8h */ case    0:  		/* mfspr R12, LR */
		/* 820F62C8h case    0:*/		regs.R12 = regs.LR;
		/* 820F62C8h case    0:*/		return 0x820F62CC;
		  /* 820F62CCh */ case    1:  		/* bl -413808 */
		/* 820F62CCh case    1:*/		regs.LR = 0x820F62D0; return 0x8209125C;
		/* 820F62CCh case    1:*/		return 0x820F62D0;
		  /* 820F62D0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820F62D0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820F62D0h case    2:*/		return 0x820F62D4;
		  /* 820F62D4h */ case    3:  		/* or R31, R4, R5 */
		/* 820F62D4h case    3:*/		cpu::op::or<0>(regs,&regs.R31,regs.R4,regs.R5);
		/* 820F62D4h case    3:*/		return 0x820F62D8;
		  /* 820F62D8h */ case    4:  		/* mr R30, R3 */
		/* 820F62D8h case    4:*/		regs.R30 = regs.R3;
		/* 820F62D8h case    4:*/		return 0x820F62DC;
		  /* 820F62DCh */ case    5:  		/* mr R4, R31 */
		/* 820F62DCh case    5:*/		regs.R4 = regs.R31;
		/* 820F62DCh case    5:*/		return 0x820F62E0;
		  /* 820F62E0h */ case    6:  		/* mr R29, R6 */
		/* 820F62E0h case    6:*/		regs.R29 = regs.R6;
		/* 820F62E0h case    6:*/		return 0x820F62E4;
		  /* 820F62E4h */ case    7:  		/* bl -12148 */
		/* 820F62E4h case    7:*/		regs.LR = 0x820F62E8; return 0x820F3370;
		/* 820F62E4h case    7:*/		return 0x820F62E8;
		  /* 820F62E8h */ case    8:  		/* srawi R11, R3, 31 */
		/* 820F62E8h case    8:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 820F62E8h case    8:*/		return 0x820F62EC;
		  /* 820F62ECh */ case    9:  		/* and R3, R11, R3 */
		/* 820F62ECh case    9:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820F62ECh case    9:*/		return 0x820F62F0;
		  /* 820F62F0h */ case   10:  		/* cmpwi CR6, R3, 0 */
		/* 820F62F0h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820F62F0h case   10:*/		return 0x820F62F4;
		  /* 820F62F4h */ case   11:  		/* bc 12, CR6_LT, 96 */
		/* 820F62F4h case   11:*/		if ( regs.CR[6].lt ) { return 0x820F6354;  }
		/* 820F62F4h case   11:*/		return 0x820F62F8;
		  /* 820F62F8h */ case   12:  		/* rlwinm. R11, R31, 0, 18, 18 */
		/* 820F62F8h case   12:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R11,regs.R31);
		/* 820F62F8h case   12:*/		return 0x820F62FC;
		  /* 820F62FCh */ case   13:  		/* bc 12, CR0_EQ, 84 */
		/* 820F62FCh case   13:*/		if ( regs.CR[0].eq ) { return 0x820F6350;  }
		/* 820F62FCh case   13:*/		return 0x820F6300;
		  /* 820F6300h */ case   14:  		/* lwz R11, <#[R30 + 20]> */
		/* 820F6300h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820F6300h case   14:*/		return 0x820F6304;
		  /* 820F6304h */ case   15:  		/* rlwinm R10, R29, 2, 0, 29 */
		/* 820F6304h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R29);
		/* 820F6304h case   15:*/		return 0x820F6308;
		  /* 820F6308h */ case   16:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820F6308h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820F6308h case   16:*/		return 0x820F630C;
		  /* 820F630Ch */ case   17:  		/* lwz R10, <#[R11 + 12]> */
		/* 820F630Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F630Ch case   17:*/		return 0x820F6310;
		  /* 820F6310h */ case   18:  		/* lwz R11, <#[R11 + 16]> */
		/* 820F6310h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820F6310h case   18:*/		return 0x820F6314;
		  /* 820F6314h */ case   19:  		/* rlwinm R10, R10, 0, 21, 31 */
		/* 820F6314h case   19:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R10,regs.R10);
		/* 820F6314h case   19:*/		return 0x820F6318;
		  /* 820F6318h */ case   20:  		/* cmplwi CR6, R11, 1 */
		/* 820F6318h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820F6318h case   20:*/		return 0x820F631C;
		  /* 820F631Ch */ case   21:  		/* oris R4, R10, 45056 */
		/* 820F631Ch case   21:*/		cpu::op::oris<0>(regs,&regs.R4,regs.R10,0xB000);
		/* 820F631Ch case   21:*/		return 0x820F6320;
		  /* 820F6320h */ case   22:  		/* bc 12, CR6_LT, 40 */
		/* 820F6320h case   22:*/		if ( regs.CR[6].lt ) { return 0x820F6348;  }
		/* 820F6320h case   22:*/		return 0x820F6324;
		  /* 820F6324h */ case   23:  		/* bc 12, CR6_EQ, 32 */
		/* 820F6324h case   23:*/		if ( regs.CR[6].eq ) { return 0x820F6344;  }
		/* 820F6324h case   23:*/		return 0x820F6328;
		  /* 820F6328h */ case   24:  		/* cmplwi CR6, R11, 3 */
		/* 820F6328h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820F6328h case   24:*/		return 0x820F632C;
		  /* 820F632Ch */ case   25:  		/* bc 12, CR6_LT, 16 */
		/* 820F632Ch case   25:*/		if ( regs.CR[6].lt ) { return 0x820F633C;  }
		/* 820F632Ch case   25:*/		return 0x820F6330;
		  /* 820F6330h */ case   26:  		/* bc 4, CR6_EQ, 24 */
		/* 820F6330h case   26:*/		if ( !regs.CR[6].eq ) { return 0x820F6348;  }
		/* 820F6330h case   26:*/		return 0x820F6334;
		  /* 820F6334h */ case   27:  		/* oris R4, R4, 255 */
		/* 820F6334h case   27:*/		cpu::op::oris<0>(regs,&regs.R4,regs.R4,0xFF);
		/* 820F6334h case   27:*/		return 0x820F6338;
		  /* 820F6338h */ case   28:  		/* b 16 */
		/* 820F6338h case   28:*/		return 0x820F6348;
		/* 820F6338h case   28:*/		return 0x820F633C;
	}
	return 0x820F633C;
} // Block from 820F62C8h-820F633Ch (29 instructions)

//////////////////////////////////////////////////////
// Block at 820F633Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F633C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F633C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F633C);
		  /* 820F633Ch */ case    0:  		/* oris R4, R4, 170 */
		/* 820F633Ch case    0:*/		cpu::op::oris<0>(regs,&regs.R4,regs.R4,0xAA);
		/* 820F633Ch case    0:*/		return 0x820F6340;
		  /* 820F6340h */ case    1:  		/* b 8 */
		/* 820F6340h case    1:*/		return 0x820F6348;
		/* 820F6340h case    1:*/		return 0x820F6344;
	}
	return 0x820F6344;
} // Block from 820F633Ch-820F6344h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F6344h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6344( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6344) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6344);
		  /* 820F6344h */ case    0:  		/* oris R4, R4, 85 */
		/* 820F6344h case    0:*/		cpu::op::oris<0>(regs,&regs.R4,regs.R4,0x55);
		/* 820F6344h case    0:*/		return 0x820F6348;
	}
	return 0x820F6348;
} // Block from 820F6344h-820F6348h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F6348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6348);
		  /* 820F6348h */ case    0:  		/* mr R3, R30 */
		/* 820F6348h case    0:*/		regs.R3 = regs.R30;
		/* 820F6348h case    0:*/		return 0x820F634C;
		  /* 820F634Ch */ case    1:  		/* bl -12252 */
		/* 820F634Ch case    1:*/		regs.LR = 0x820F6350; return 0x820F3370;
		/* 820F634Ch case    1:*/		return 0x820F6350;
	}
	return 0x820F6350;
} // Block from 820F6348h-820F6350h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F6350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6350);
		  /* 820F6350h */ case    0:  		/* li R3, 0 */
		/* 820F6350h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F6350h case    0:*/		return 0x820F6354;
	}
	return 0x820F6354;
} // Block from 820F6350h-820F6354h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F6354h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6354( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6354) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6354);
		  /* 820F6354h */ case    0:  		/* addi R1, R1, 112 */
		/* 820F6354h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820F6354h case    0:*/		return 0x820F6358;
		  /* 820F6358h */ case    1:  		/* b -413868 */
		/* 820F6358h case    1:*/		return 0x820912AC;
		/* 820F6358h case    1:*/		return 0x820F635C;
		  /* 820F635Ch */ case    2:  		/* nop */
		/* 820F635Ch case    2:*/		cpu::op::nop();
		/* 820F635Ch case    2:*/		return 0x820F6360;
	}
	return 0x820F6360;
} // Block from 820F6354h-820F6360h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F6360h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6360);
		  /* 820F6360h */ case    0:  		/* mfspr R12, LR */
		/* 820F6360h case    0:*/		regs.R12 = regs.LR;
		/* 820F6360h case    0:*/		return 0x820F6364;
		  /* 820F6364h */ case    1:  		/* bl -413980 */
		/* 820F6364h case    1:*/		regs.LR = 0x820F6368; return 0x82091248;
		/* 820F6364h case    1:*/		return 0x820F6368;
		  /* 820F6368h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820F6368h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820F6368h case    2:*/		return 0x820F636C;
		  /* 820F636Ch */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820F636Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F636Ch case    3:*/		return 0x820F6370;
		  /* 820F6370h */ case    4:  		/* mr R31, R3 */
		/* 820F6370h case    4:*/		regs.R31 = regs.R3;
		/* 820F6370h case    4:*/		return 0x820F6374;
		  /* 820F6374h */ case    5:  		/* mr R30, R4 */
		/* 820F6374h case    5:*/		regs.R30 = regs.R4;
		/* 820F6374h case    5:*/		return 0x820F6378;
		  /* 820F6378h */ case    6:  		/* mr R29, R5 */
		/* 820F6378h case    6:*/		regs.R29 = regs.R5;
		/* 820F6378h case    6:*/		return 0x820F637C;
		  /* 820F637Ch */ case    7:  		/* mr R28, R6 */
		/* 820F637Ch case    7:*/		regs.R28 = regs.R6;
		/* 820F637Ch case    7:*/		return 0x820F6380;
		  /* 820F6380h */ case    8:  		/* mr R27, R7 */
		/* 820F6380h case    8:*/		regs.R27 = regs.R7;
		/* 820F6380h case    8:*/		return 0x820F6384;
		  /* 820F6384h */ case    9:  		/* lwz R11, <#[R11 + 304]> */
		/* 820F6384h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000130) );
		/* 820F6384h case    9:*/		return 0x820F6388;
		  /* 820F6388h */ case   10:  		/* mr R26, R8 */
		/* 820F6388h case   10:*/		regs.R26 = regs.R8;
		/* 820F6388h case   10:*/		return 0x820F638C;
		  /* 820F638Ch */ case   11:  		/* mr R24, R9 */
		/* 820F638Ch case   11:*/		regs.R24 = regs.R9;
		/* 820F638Ch case   11:*/		return 0x820F6390;
		  /* 820F6390h */ case   12:  		/* mr R25, R10 */
		/* 820F6390h case   12:*/		regs.R25 = regs.R10;
		/* 820F6390h case   12:*/		return 0x820F6394;
		  /* 820F6394h */ case   13:  		/* mtspr CTR, R11 */
		/* 820F6394h case   13:*/		regs.CTR = regs.R11;
		/* 820F6394h case   13:*/		return 0x820F6398;
		  /* 820F6398h */ case   14:  		/* bcctrl 20, CR0_LT */
		/* 820F6398h case   14:*/		if ( 1 ) { regs.LR = 0x820F639C; return (uint32)regs.CTR; }
		/* 820F6398h case   14:*/		return 0x820F639C;
		  /* 820F639Ch */ case   15:  		/* mr R4, R3 */
		/* 820F639Ch case   15:*/		regs.R4 = regs.R3;
		/* 820F639Ch case   15:*/		return 0x820F63A0;
		  /* 820F63A0h */ case   16:  		/* mr R3, R31 */
		/* 820F63A0h case   16:*/		regs.R3 = regs.R31;
		/* 820F63A0h case   16:*/		return 0x820F63A4;
		  /* 820F63A4h */ case   17:  		/* bl -692 */
		/* 820F63A4h case   17:*/		regs.LR = 0x820F63A8; return 0x820F60F0;
		/* 820F63A4h case   17:*/		return 0x820F63A8;
		  /* 820F63A8h */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 820F63A8h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F63A8h case   18:*/		return 0x820F63AC;
		  /* 820F63ACh */ case   19:  		/* bc 12, CR0_LT, 828 */
		/* 820F63ACh case   19:*/		if ( regs.CR[0].lt ) { return 0x820F66E8;  }
		/* 820F63ACh case   19:*/		return 0x820F63B0;
		  /* 820F63B0h */ case   20:  		/* lwz R11, <#[R31]> */
		/* 820F63B0h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F63B0h case   20:*/		return 0x820F63B4;
		  /* 820F63B4h */ case   21:  		/* addi R7, R1, 96 */
		/* 820F63B4h case   21:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820F63B4h case   21:*/		return 0x820F63B8;
		  /* 820F63B8h */ case   22:  		/* lwz R10, <#[R29]> */
		/* 820F63B8h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 820F63B8h case   22:*/		return 0x820F63BC;
		  /* 820F63BCh */ case   23:  		/* addi R6, R1, 100 */
		/* 820F63BCh case   23:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x64);
		/* 820F63BCh case   23:*/		return 0x820F63C0;
		  /* 820F63C0h */ case   24:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F63C0h case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F63C0h case   24:*/		return 0x820F63C4;
		  /* 820F63C4h */ case   25:  		/* addi R5, R1, 84 */
		/* 820F63C4h case   25:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 820F63C4h case   25:*/		return 0x820F63C8;
		  /* 820F63C8h */ case   26:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F63C8h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F63C8h case   26:*/		return 0x820F63CC;
		  /* 820F63CCh */ case   27:  		/* mr R3, R31 */
		/* 820F63CCh case   27:*/		regs.R3 = regs.R31;
		/* 820F63CCh case   27:*/		return 0x820F63D0;
		  /* 820F63D0h */ case   28:  		/* lwz R11, <#[R11 + 320]> */
		/* 820F63D0h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000140) );
		/* 820F63D0h case   28:*/		return 0x820F63D4;
		  /* 820F63D4h */ case   29:  		/* lwzx R4, <#[R10 + R9]> */
		/* 820F63D4h case   29:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820F63D4h case   29:*/		return 0x820F63D8;
		  /* 820F63D8h */ case   30:  		/* mtspr CTR, R11 */
		/* 820F63D8h case   30:*/		regs.CTR = regs.R11;
		/* 820F63D8h case   30:*/		return 0x820F63DC;
		  /* 820F63DCh */ case   31:  		/* bcctrl 20, CR0_LT */
		/* 820F63DCh case   31:*/		if ( 1 ) { regs.LR = 0x820F63E0; return (uint32)regs.CTR; }
		/* 820F63DCh case   31:*/		return 0x820F63E0;
		  /* 820F63E0h */ case   32:  		/* cmpwi CR0, R3, 0 */
		/* 820F63E0h case   32:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F63E0h case   32:*/		return 0x820F63E4;
		  /* 820F63E4h */ case   33:  		/* bc 12, CR0_LT, 772 */
		/* 820F63E4h case   33:*/		if ( regs.CR[0].lt ) { return 0x820F66E8;  }
		/* 820F63E4h case   33:*/		return 0x820F63E8;
		  /* 820F63E8h */ case   34:  		/* lwz R11, <#[R31]> */
		/* 820F63E8h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F63E8h case   34:*/		return 0x820F63EC;
		  /* 820F63ECh */ case   35:  		/* addi R6, R1, 80 */
		/* 820F63ECh case   35:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 820F63ECh case   35:*/		return 0x820F63F0;
		  /* 820F63F0h */ case   36:  		/* mr R5, R28 */
		/* 820F63F0h case   36:*/		regs.R5 = regs.R28;
		/* 820F63F0h case   36:*/		return 0x820F63F4;
		  /* 820F63F4h */ case   37:  		/* lwz R7, <#[R1 + 96]> */
		/* 820F63F4h case   37:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000060) );
		/* 820F63F4h case   37:*/		return 0x820F63F8;
		  /* 820F63F8h */ case   38:  		/* mr R4, R29 */
		/* 820F63F8h case   38:*/		regs.R4 = regs.R29;
		/* 820F63F8h case   38:*/		return 0x820F63FC;
		  /* 820F63FCh */ case   39:  		/* mr R3, R31 */
		/* 820F63FCh case   39:*/		regs.R3 = regs.R31;
		/* 820F63FCh case   39:*/		return 0x820F6400;
		  /* 820F6400h */ case   40:  		/* lwz R11, <#[R11 + 324]> */
		/* 820F6400h case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000144) );
		/* 820F6400h case   40:*/		return 0x820F6404;
		  /* 820F6404h */ case   41:  		/* mtspr CTR, R11 */
		/* 820F6404h case   41:*/		regs.CTR = regs.R11;
		/* 820F6404h case   41:*/		return 0x820F6408;
		  /* 820F6408h */ case   42:  		/* bcctrl 20, CR0_LT */
		/* 820F6408h case   42:*/		if ( 1 ) { regs.LR = 0x820F640C; return (uint32)regs.CTR; }
		/* 820F6408h case   42:*/		return 0x820F640C;
		  /* 820F640Ch */ case   43:  		/* cmpwi CR0, R3, 0 */
		/* 820F640Ch case   43:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F640Ch case   43:*/		return 0x820F6410;
		  /* 820F6410h */ case   44:  		/* bc 12, CR0_LT, 728 */
		/* 820F6410h case   44:*/		if ( regs.CR[0].lt ) { return 0x820F66E8;  }
		/* 820F6410h case   44:*/		return 0x820F6414;
		  /* 820F6414h */ case   45:  		/* lwz R11, <#[R1 + 284]> */
		/* 820F6414h case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000011C) );
		/* 820F6414h case   45:*/		return 0x820F6418;
		  /* 820F6418h */ case   46:  		/* lis R10, 64 */
		/* 820F6418h case   46:*/		cpu::op::lis<0>(regs,&regs.R10,0x40);
		/* 820F6418h case   46:*/		return 0x820F641C;
		  /* 820F641Ch */ case   47:  		/* lwz R9, <#[R31]> */
		/* 820F641Ch case   47:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 820F641Ch case   47:*/		return 0x820F6420;
		  /* 820F6420h */ case   48:  		/* mr R3, R31 */
		/* 820F6420h case   48:*/		regs.R3 = regs.R31;
		/* 820F6420h case   48:*/		return 0x820F6424;
		  /* 820F6424h */ case   49:  		/* subfic R11, R11, 0 */
		/* 820F6424h case   49:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 820F6424h case   49:*/		return 0x820F6428;
		  /* 820F6428h */ case   50:  		/* lwz R8, <#[R1 + 84]> */
		/* 820F6428h case   50:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 820F6428h case   50:*/		return 0x820F642C;
		  /* 820F642Ch */ case   51:  		/* lwz R6, <#[R1 + 100]> */
		/* 820F642Ch case   51:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000064) );
		/* 820F642Ch case   51:*/		return 0x820F6430;
		  /* 820F6430h */ case   52:  		/* subfe R11, R11, R11 */
		/* 820F6430h case   52:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820F6430h case   52:*/		return 0x820F6434;
		  /* 820F6434h */ case   53:  		/* lwz R5, <#[R1 + 80]> */
		/* 820F6434h case   53:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 820F6434h case   53:*/		return 0x820F6438;
		  /* 820F6438h */ case   54:  		/* lwz R9, <#[R9 + 312]> */
		/* 820F6438h case   54:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000138) );
		/* 820F6438h case   54:*/		return 0x820F643C;
		  /* 820F643Ch */ case   55:  		/* and R11, R11, R10 */
		/* 820F643Ch case   55:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820F643Ch case   55:*/		return 0x820F6440;
		  /* 820F6440h */ case   56:  		/* or R4, R11, R8 */
		/* 820F6440h case   56:*/		cpu::op::or<0>(regs,&regs.R4,regs.R11,regs.R8);
		/* 820F6440h case   56:*/		return 0x820F6444;
		  /* 820F6444h */ case   57:  		/* mtspr CTR, R9 */
		/* 820F6444h case   57:*/		regs.CTR = regs.R9;
		/* 820F6444h case   57:*/		return 0x820F6448;
		  /* 820F6448h */ case   58:  		/* bcctrl 20, CR0_LT */
		/* 820F6448h case   58:*/		if ( 1 ) { regs.LR = 0x820F644C; return (uint32)regs.CTR; }
		/* 820F6448h case   58:*/		return 0x820F644C;
		  /* 820F644Ch */ case   59:  		/* cmpwi CR0, R3, 0 */
		/* 820F644Ch case   59:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F644Ch case   59:*/		return 0x820F6450;
		  /* 820F6450h */ case   60:  		/* bc 12, CR0_LT, 664 */
		/* 820F6450h case   60:*/		if ( regs.CR[0].lt ) { return 0x820F66E8;  }
		/* 820F6450h case   60:*/		return 0x820F6454;
		  /* 820F6454h */ case   61:  		/* cmplwi CR6, R30, 8 */
		/* 820F6454h case   61:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000008);
		/* 820F6454h case   61:*/		return 0x820F6458;
		  /* 820F6458h */ case   62:  		/* bc 4, CR6_EQ, 12 */
		/* 820F6458h case   62:*/		if ( !regs.CR[6].eq ) { return 0x820F6464;  }
		/* 820F6458h case   62:*/		return 0x820F645C;
		  /* 820F645Ch */ case   63:  		/* lis R11, 7 */
		/* 820F645Ch case   63:*/		cpu::op::lis<0>(regs,&regs.R11,0x7);
		/* 820F645Ch case   63:*/		return 0x820F6460;
		  /* 820F6460h */ case   64:  		/* b 80 */
		/* 820F6460h case   64:*/		return 0x820F64B0;
		/* 820F6460h case   64:*/		return 0x820F6464;
	}
	return 0x820F6464;
} // Block from 820F6360h-820F6464h (65 instructions)

//////////////////////////////////////////////////////
// Block at 820F6464h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6464( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6464) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6464);
		  /* 820F6464h */ case    0:  		/* cmplwi CR6, R30, 9 */
		/* 820F6464h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000009);
		/* 820F6464h case    0:*/		return 0x820F6468;
		  /* 820F6468h */ case    1:  		/* bc 12, CR6_EQ, 68 */
		/* 820F6468h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F64AC;  }
		/* 820F6468h case    1:*/		return 0x820F646C;
		  /* 820F646Ch */ case    2:  		/* cmplwi CR6, R30, 90 */
		/* 820F646Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x0000005A);
		/* 820F646Ch case    2:*/		return 0x820F6470;
		  /* 820F6470h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 820F6470h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820F647C;  }
		/* 820F6470h case    3:*/		return 0x820F6474;
		  /* 820F6474h */ case    4:  		/* lis R11, 3 */
		/* 820F6474h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0x3);
		/* 820F6474h case    4:*/		return 0x820F6478;
		  /* 820F6478h */ case    5:  		/* b 56 */
		/* 820F6478h case    5:*/		return 0x820F64B0;
		/* 820F6478h case    5:*/		return 0x820F647C;
	}
	return 0x820F647C;
} // Block from 820F6464h-820F647Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F647Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F647C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F647C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F647C);
		  /* 820F647Ch */ case    0:  		/* cmplwi CR6, R30, 6 */
		/* 820F647Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000006);
		/* 820F647Ch case    0:*/		return 0x820F6480;
		  /* 820F6480h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820F6480h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F648C;  }
		/* 820F6480h case    1:*/		return 0x820F6484;
		  /* 820F6484h */ case    2:  		/* lis R11, 1 */
		/* 820F6484h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x1);
		/* 820F6484h case    2:*/		return 0x820F6488;
		  /* 820F6488h */ case    3:  		/* b 40 */
		/* 820F6488h case    3:*/		return 0x820F64B0;
		/* 820F6488h case    3:*/		return 0x820F648C;
	}
	return 0x820F648C;
} // Block from 820F647Ch-820F648Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F648Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F648C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F648C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F648C);
		  /* 820F648Ch */ case    0:  		/* cmplwi CR6, R30, 14 */
		/* 820F648Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x0000000E);
		/* 820F648Ch case    0:*/		return 0x820F6490;
		  /* 820F6490h */ case    1:  		/* bc 12, CR6_EQ, -12 */
		/* 820F6490h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F6484;  }
		/* 820F6490h case    1:*/		return 0x820F6494;
		  /* 820F6494h */ case    2:  		/* cmplwi CR6, R30, 15 */
		/* 820F6494h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x0000000F);
		/* 820F6494h case    2:*/		return 0x820F6498;
		  /* 820F6498h */ case    3:  		/* bc 12, CR6_EQ, -20 */
		/* 820F6498h case    3:*/		if ( regs.CR[6].eq ) { return 0x820F6484;  }
		/* 820F6498h case    3:*/		return 0x820F649C;
		  /* 820F649Ch */ case    4:  		/* cmplwi CR6, R30, 7 */
		/* 820F649Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000007);
		/* 820F649Ch case    4:*/		return 0x820F64A0;
		  /* 820F64A0h */ case    5:  		/* bc 12, CR6_EQ, -28 */
		/* 820F64A0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820F6484;  }
		/* 820F64A0h case    5:*/		return 0x820F64A4;
		  /* 820F64A4h */ case    6:  		/* cmplwi CR6, R30, 37 */
		/* 820F64A4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000025);
		/* 820F64A4h case    6:*/		return 0x820F64A8;
		  /* 820F64A8h */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 820F64A8h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820F64B4;  }
		/* 820F64A8h case    7:*/		return 0x820F64AC;
	}
	return 0x820F64AC;
} // Block from 820F648Ch-820F64ACh (8 instructions)

//////////////////////////////////////////////////////
// Block at 820F64ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F64AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F64AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F64AC);
		  /* 820F64ACh */ case    0:  		/* lis R11, 15 */
		/* 820F64ACh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xF);
		/* 820F64ACh case    0:*/		return 0x820F64B0;
	}
	return 0x820F64B0;
} // Block from 820F64ACh-820F64B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F64B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F64B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F64B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F64B0);
		  /* 820F64B0h */ case    0:  		/* stw R11, <#[R1 + 80]> */
		/* 820F64B0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820F64B0h case    0:*/		return 0x820F64B4;
	}
	return 0x820F64B4;
} // Block from 820F64B0h-820F64B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F64B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F64B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F64B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F64B4);
		  /* 820F64B4h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 820F64B4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820F64B4h case    0:*/		return 0x820F64B8;
		  /* 820F64B8h */ case    1:  		/* bc 12, CR6_EQ, 168 */
		/* 820F64B8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F6560;  }
		/* 820F64B8h case    1:*/		return 0x820F64BC;
		  /* 820F64BCh */ case    2:  		/* lwz R11, <#[R31]> */
		/* 820F64BCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F64BCh case    2:*/		return 0x820F64C0;
		  /* 820F64C0h */ case    3:  		/* addi R6, R1, 88 */
		/* 820F64C0h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x58);
		/* 820F64C0h case    3:*/		return 0x820F64C4;
		  /* 820F64C4h */ case    4:  		/* lwz R10, <#[R27]> */
		/* 820F64C4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 820F64C4h case    4:*/		return 0x820F64C8;
		  /* 820F64C8h */ case    5:  		/* addi R5, R1, 84 */
		/* 820F64C8h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 820F64C8h case    5:*/		return 0x820F64CC;
		  /* 820F64CCh */ case    6:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F64CCh case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F64CCh case    6:*/		return 0x820F64D0;
		  /* 820F64D0h */ case    7:  		/* mr R3, R31 */
		/* 820F64D0h case    7:*/		regs.R3 = regs.R31;
		/* 820F64D0h case    7:*/		return 0x820F64D4;
		  /* 820F64D4h */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F64D4h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F64D4h case    8:*/		return 0x820F64D8;
		  /* 820F64D8h */ case    9:  		/* lwz R11, <#[R11 + 328]> */
		/* 820F64D8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000148) );
		/* 820F64D8h case    9:*/		return 0x820F64DC;
		  /* 820F64DCh */ case   10:  		/* lwzx R4, <#[R10 + R9]> */
		/* 820F64DCh case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820F64DCh case   10:*/		return 0x820F64E0;
		  /* 820F64E0h */ case   11:  		/* mtspr CTR, R11 */
		/* 820F64E0h case   11:*/		regs.CTR = regs.R11;
		/* 820F64E0h case   11:*/		return 0x820F64E4;
		  /* 820F64E4h */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 820F64E4h case   12:*/		if ( 1 ) { regs.LR = 0x820F64E8; return (uint32)regs.CTR; }
		/* 820F64E4h case   12:*/		return 0x820F64E8;
		  /* 820F64E8h */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 820F64E8h case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F64E8h case   13:*/		return 0x820F64EC;
		  /* 820F64ECh */ case   14:  		/* bc 12, CR0_LT, 508 */
		/* 820F64ECh case   14:*/		if ( regs.CR[0].lt ) { return 0x820F66E8;  }
		/* 820F64ECh case   14:*/		return 0x820F64F0;
		  /* 820F64F0h */ case   15:  		/* lwz R11, <#[R31]> */
		/* 820F64F0h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F64F0h case   15:*/		return 0x820F64F4;
		  /* 820F64F4h */ case   16:  		/* addi R7, R1, 92 */
		/* 820F64F4h case   16:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x5C);
		/* 820F64F4h case   16:*/		return 0x820F64F8;
		  /* 820F64F8h */ case   17:  		/* mr R5, R25 */
		/* 820F64F8h case   17:*/		regs.R5 = regs.R25;
		/* 820F64F8h case   17:*/		return 0x820F64FC;
		  /* 820F64FCh */ case   18:  		/* lwz R6, <#[R1 + 80]> */
		/* 820F64FCh case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 820F64FCh case   18:*/		return 0x820F6500;
		  /* 820F6500h */ case   19:  		/* mr R4, R27 */
		/* 820F6500h case   19:*/		regs.R4 = regs.R27;
		/* 820F6500h case   19:*/		return 0x820F6504;
		  /* 820F6504h */ case   20:  		/* mr R3, R31 */
		/* 820F6504h case   20:*/		regs.R3 = regs.R31;
		/* 820F6504h case   20:*/		return 0x820F6508;
		  /* 820F6508h */ case   21:  		/* lwz R11, <#[R11 + 332]> */
		/* 820F6508h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000014C) );
		/* 820F6508h case   21:*/		return 0x820F650C;
		  /* 820F650Ch */ case   22:  		/* mtspr CTR, R11 */
		/* 820F650Ch case   22:*/		regs.CTR = regs.R11;
		/* 820F650Ch case   22:*/		return 0x820F6510;
		  /* 820F6510h */ case   23:  		/* bcctrl 20, CR0_LT */
		/* 820F6510h case   23:*/		if ( 1 ) { regs.LR = 0x820F6514; return (uint32)regs.CTR; }
		/* 820F6510h case   23:*/		return 0x820F6514;
		  /* 820F6514h */ case   24:  		/* cmpwi CR0, R3, 0 */
		/* 820F6514h case   24:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6514h case   24:*/		return 0x820F6518;
		  /* 820F6518h */ case   25:  		/* bc 12, CR0_LT, 464 */
		/* 820F6518h case   25:*/		if ( regs.CR[0].lt ) { return 0x820F66E8;  }
		/* 820F6518h case   25:*/		return 0x820F651C;
		  /* 820F651Ch */ case   26:  		/* lwz R11, <#[R1 + 260]> */
		/* 820F651Ch case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000104) );
		/* 820F651Ch case   26:*/		return 0x820F6520;
		  /* 820F6520h */ case   27:  		/* cmplwi CR6, R11, 0 */
		/* 820F6520h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F6520h case   27:*/		return 0x820F6524;
		  /* 820F6524h */ case   28:  		/* bc 12, CR6_EQ, 20 */
		/* 820F6524h case   28:*/		if ( regs.CR[6].eq ) { return 0x820F6538;  }
		/* 820F6524h case   28:*/		return 0x820F6528;
		  /* 820F6528h */ case   29:  		/* lwz R3, <#[R1 + 84]> */
		/* 820F6528h case   29:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 820F6528h case   29:*/		return 0x820F652C;
		  /* 820F652Ch */ case   30:  		/* bl -39388 */
		/* 820F652Ch case   30:*/		regs.LR = 0x820F6530; return 0x820ECB50;
		/* 820F652Ch case   30:*/		return 0x820F6530;
		  /* 820F6530h */ case   31:  		/* mr R4, R3 */
		/* 820F6530h case   31:*/		regs.R4 = regs.R3;
		/* 820F6530h case   31:*/		return 0x820F6534;
		  /* 820F6534h */ case   32:  		/* b 8 */
		/* 820F6534h case   32:*/		return 0x820F653C;
		/* 820F6534h case   32:*/		return 0x820F6538;
	}
	return 0x820F6538;
} // Block from 820F64B4h-820F6538h (33 instructions)

//////////////////////////////////////////////////////
// Block at 820F6538h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6538);
		  /* 820F6538h */ case    0:  		/* lwz R4, <#[R1 + 84]> */
		/* 820F6538h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 820F6538h case    0:*/		return 0x820F653C;
	}
	return 0x820F653C;
} // Block from 820F6538h-820F653Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F653Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F653C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F653C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F653C);
		  /* 820F653Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820F653Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F653Ch case    0:*/		return 0x820F6540;
		  /* 820F6540h */ case    1:  		/* mr R3, R31 */
		/* 820F6540h case    1:*/		regs.R3 = regs.R31;
		/* 820F6540h case    1:*/		return 0x820F6544;
		  /* 820F6544h */ case    2:  		/* lwz R6, <#[R1 + 88]> */
		/* 820F6544h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000058) );
		/* 820F6544h case    2:*/		return 0x820F6548;
		  /* 820F6548h */ case    3:  		/* lwz R5, <#[R1 + 92]> */
		/* 820F6548h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F6548h case    3:*/		return 0x820F654C;
		  /* 820F654Ch */ case    4:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F654Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F654Ch case    4:*/		return 0x820F6550;
		  /* 820F6550h */ case    5:  		/* mtspr CTR, R11 */
		/* 820F6550h case    5:*/		regs.CTR = regs.R11;
		/* 820F6550h case    5:*/		return 0x820F6554;
		  /* 820F6554h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 820F6554h case    6:*/		if ( 1 ) { regs.LR = 0x820F6558; return (uint32)regs.CTR; }
		/* 820F6554h case    6:*/		return 0x820F6558;
		  /* 820F6558h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820F6558h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6558h case    7:*/		return 0x820F655C;
		  /* 820F655Ch */ case    8:  		/* bc 12, CR0_LT, 396 */
		/* 820F655Ch case    8:*/		if ( regs.CR[0].lt ) { return 0x820F66E8;  }
		/* 820F655Ch case    8:*/		return 0x820F6560;
	}
	return 0x820F6560;
} // Block from 820F653Ch-820F6560h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F6560h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6560);
		  /* 820F6560h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 820F6560h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 820F6560h case    0:*/		return 0x820F6564;
		  /* 820F6564h */ case    1:  		/* bc 12, CR6_EQ, 168 */
		/* 820F6564h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F660C;  }
		/* 820F6564h case    1:*/		return 0x820F6568;
		  /* 820F6568h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 820F6568h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6568h case    2:*/		return 0x820F656C;
		  /* 820F656Ch */ case    3:  		/* addi R6, R1, 88 */
		/* 820F656Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x58);
		/* 820F656Ch case    3:*/		return 0x820F6570;
		  /* 820F6570h */ case    4:  		/* lwz R10, <#[R26]> */
		/* 820F6570h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 820F6570h case    4:*/		return 0x820F6574;
		  /* 820F6574h */ case    5:  		/* addi R5, R1, 84 */
		/* 820F6574h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 820F6574h case    5:*/		return 0x820F6578;
	}
	return 0x820F6578;
} // Block from 820F6560h-820F6578h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F6578h
// Function '?IndexSemantic@CShaderProgram@D3DXShader@@UAAJPAVCArgument@2@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6578);
		  /* 820F6578h */ case    0:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F6578h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F6578h case    0:*/		return 0x820F657C;
		  /* 820F657Ch */ case    1:  		/* mr R3, R31 */
		/* 820F657Ch case    1:*/		regs.R3 = regs.R31;
		/* 820F657Ch case    1:*/		return 0x820F6580;
		  /* 820F6580h */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F6580h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F6580h case    2:*/		return 0x820F6584;
		  /* 820F6584h */ case    3:  		/* lwz R11, <#[R11 + 328]> */
		/* 820F6584h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000148) );
		/* 820F6584h case    3:*/		return 0x820F6588;
		  /* 820F6588h */ case    4:  		/* lwzx R4, <#[R10 + R9]> */
		/* 820F6588h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820F6588h case    4:*/		return 0x820F658C;
		  /* 820F658Ch */ case    5:  		/* mtspr CTR, R11 */
		/* 820F658Ch case    5:*/		regs.CTR = regs.R11;
		/* 820F658Ch case    5:*/		return 0x820F6590;
		  /* 820F6590h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 820F6590h case    6:*/		if ( 1 ) { regs.LR = 0x820F6594; return (uint32)regs.CTR; }
		/* 820F6590h case    6:*/		return 0x820F6594;
		  /* 820F6594h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820F6594h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6594h case    7:*/		return 0x820F6598;
		  /* 820F6598h */ case    8:  		/* bc 12, CR0_LT, 336 */
		/* 820F6598h case    8:*/		if ( regs.CR[0].lt ) { return 0x820F66E8;  }
		/* 820F6598h case    8:*/		return 0x820F659C;
		  /* 820F659Ch */ case    9:  		/* lwz R11, <#[R31]> */
		/* 820F659Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F659Ch case    9:*/		return 0x820F65A0;
		  /* 820F65A0h */ case   10:  		/* addi R7, R1, 92 */
		/* 820F65A0h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x5C);
		/* 820F65A0h case   10:*/		return 0x820F65A4;
		  /* 820F65A4h */ case   11:  		/* mr R5, R25 */
		/* 820F65A4h case   11:*/		regs.R5 = regs.R25;
		/* 820F65A4h case   11:*/		return 0x820F65A8;
		  /* 820F65A8h */ case   12:  		/* lwz R6, <#[R1 + 80]> */
		/* 820F65A8h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 820F65A8h case   12:*/		return 0x820F65AC;
		  /* 820F65ACh */ case   13:  		/* mr R4, R26 */
		/* 820F65ACh case   13:*/		regs.R4 = regs.R26;
		/* 820F65ACh case   13:*/		return 0x820F65B0;
		  /* 820F65B0h */ case   14:  		/* mr R3, R31 */
		/* 820F65B0h case   14:*/		regs.R3 = regs.R31;
		/* 820F65B0h case   14:*/		return 0x820F65B4;
		  /* 820F65B4h */ case   15:  		/* lwz R11, <#[R11 + 332]> */
		/* 820F65B4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000014C) );
		/* 820F65B4h case   15:*/		return 0x820F65B8;
		  /* 820F65B8h */ case   16:  		/* mtspr CTR, R11 */
		/* 820F65B8h case   16:*/		regs.CTR = regs.R11;
		/* 820F65B8h case   16:*/		return 0x820F65BC;
		  /* 820F65BCh */ case   17:  		/* bcctrl 20, CR0_LT */
		/* 820F65BCh case   17:*/		if ( 1 ) { regs.LR = 0x820F65C0; return (uint32)regs.CTR; }
		/* 820F65BCh case   17:*/		return 0x820F65C0;
		  /* 820F65C0h */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 820F65C0h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F65C0h case   18:*/		return 0x820F65C4;
		  /* 820F65C4h */ case   19:  		/* bc 12, CR0_LT, 292 */
		/* 820F65C4h case   19:*/		if ( regs.CR[0].lt ) { return 0x820F66E8;  }
		/* 820F65C4h case   19:*/		return 0x820F65C8;
		  /* 820F65C8h */ case   20:  		/* lwz R11, <#[R1 + 268]> */
		/* 820F65C8h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000010C) );
		/* 820F65C8h case   20:*/		return 0x820F65CC;
		  /* 820F65CCh */ case   21:  		/* cmplwi CR6, R11, 0 */
		/* 820F65CCh case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F65CCh case   21:*/		return 0x820F65D0;
		  /* 820F65D0h */ case   22:  		/* bc 12, CR6_EQ, 20 */
		/* 820F65D0h case   22:*/		if ( regs.CR[6].eq ) { return 0x820F65E4;  }
		/* 820F65D0h case   22:*/		return 0x820F65D4;
		  /* 820F65D4h */ case   23:  		/* lwz R3, <#[R1 + 84]> */
		/* 820F65D4h case   23:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 820F65D4h case   23:*/		return 0x820F65D8;
		  /* 820F65D8h */ case   24:  		/* bl -39560 */
		/* 820F65D8h case   24:*/		regs.LR = 0x820F65DC; return 0x820ECB50;
		/* 820F65D8h case   24:*/		return 0x820F65DC;
		  /* 820F65DCh */ case   25:  		/* mr R4, R3 */
		/* 820F65DCh case   25:*/		regs.R4 = regs.R3;
		/* 820F65DCh case   25:*/		return 0x820F65E0;
		  /* 820F65E0h */ case   26:  		/* b 8 */
		/* 820F65E0h case   26:*/		return 0x820F65E8;
		/* 820F65E0h case   26:*/		return 0x820F65E4;
	}
	return 0x820F65E4;
} // Block from 820F6578h-820F65E4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820F65E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F65E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F65E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F65E4);
		  /* 820F65E4h */ case    0:  		/* lwz R4, <#[R1 + 84]> */
		/* 820F65E4h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 820F65E4h case    0:*/		return 0x820F65E8;
	}
	return 0x820F65E8;
} // Block from 820F65E4h-820F65E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F65E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F65E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F65E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F65E8);
		  /* 820F65E8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820F65E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F65E8h case    0:*/		return 0x820F65EC;
		  /* 820F65ECh */ case    1:  		/* mr R3, R31 */
		/* 820F65ECh case    1:*/		regs.R3 = regs.R31;
		/* 820F65ECh case    1:*/		return 0x820F65F0;
		  /* 820F65F0h */ case    2:  		/* lwz R6, <#[R1 + 88]> */
		/* 820F65F0h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000058) );
		/* 820F65F0h case    2:*/		return 0x820F65F4;
		  /* 820F65F4h */ case    3:  		/* lwz R5, <#[R1 + 92]> */
		/* 820F65F4h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F65F4h case    3:*/		return 0x820F65F8;
		  /* 820F65F8h */ case    4:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F65F8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F65F8h case    4:*/		return 0x820F65FC;
		  /* 820F65FCh */ case    5:  		/* mtspr CTR, R11 */
		/* 820F65FCh case    5:*/		regs.CTR = regs.R11;
		/* 820F65FCh case    5:*/		return 0x820F6600;
		  /* 820F6600h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 820F6600h case    6:*/		if ( 1 ) { regs.LR = 0x820F6604; return (uint32)regs.CTR; }
		/* 820F6600h case    6:*/		return 0x820F6604;
		  /* 820F6604h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820F6604h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6604h case    7:*/		return 0x820F6608;
		  /* 820F6608h */ case    8:  		/* bc 12, CR0_LT, 224 */
		/* 820F6608h case    8:*/		if ( regs.CR[0].lt ) { return 0x820F66E8;  }
		/* 820F6608h case    8:*/		return 0x820F660C;
	}
	return 0x820F660C;
} // Block from 820F65E8h-820F660Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F660Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F660C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F660C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F660C);
		  /* 820F660Ch */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 820F660Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820F660Ch case    0:*/		return 0x820F6610;
		  /* 820F6610h */ case    1:  		/* bc 12, CR6_EQ, 168 */
		/* 820F6610h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F66B8;  }
		/* 820F6610h case    1:*/		return 0x820F6614;
		  /* 820F6614h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 820F6614h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6614h case    2:*/		return 0x820F6618;
		  /* 820F6618h */ case    3:  		/* addi R6, R1, 88 */
		/* 820F6618h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x58);
		/* 820F6618h case    3:*/		return 0x820F661C;
		  /* 820F661Ch */ case    4:  		/* lwz R10, <#[R24]> */
		/* 820F661Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000000) );
		/* 820F661Ch case    4:*/		return 0x820F6620;
		  /* 820F6620h */ case    5:  		/* addi R5, R1, 84 */
		/* 820F6620h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 820F6620h case    5:*/		return 0x820F6624;
		  /* 820F6624h */ case    6:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F6624h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F6624h case    6:*/		return 0x820F6628;
		  /* 820F6628h */ case    7:  		/* mr R3, R31 */
		/* 820F6628h case    7:*/		regs.R3 = regs.R31;
		/* 820F6628h case    7:*/		return 0x820F662C;
		  /* 820F662Ch */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F662Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F662Ch case    8:*/		return 0x820F6630;
		  /* 820F6630h */ case    9:  		/* lwz R11, <#[R11 + 328]> */
		/* 820F6630h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000148) );
		/* 820F6630h case    9:*/		return 0x820F6634;
		  /* 820F6634h */ case   10:  		/* lwzx R4, <#[R10 + R9]> */
		/* 820F6634h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820F6634h case   10:*/		return 0x820F6638;
		  /* 820F6638h */ case   11:  		/* mtspr CTR, R11 */
		/* 820F6638h case   11:*/		regs.CTR = regs.R11;
		/* 820F6638h case   11:*/		return 0x820F663C;
		  /* 820F663Ch */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 820F663Ch case   12:*/		if ( 1 ) { regs.LR = 0x820F6640; return (uint32)regs.CTR; }
		/* 820F663Ch case   12:*/		return 0x820F6640;
		  /* 820F6640h */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 820F6640h case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6640h case   13:*/		return 0x820F6644;
		  /* 820F6644h */ case   14:  		/* bc 12, CR0_LT, 164 */
		/* 820F6644h case   14:*/		if ( regs.CR[0].lt ) { return 0x820F66E8;  }
		/* 820F6644h case   14:*/		return 0x820F6648;
		  /* 820F6648h */ case   15:  		/* lwz R11, <#[R31]> */
		/* 820F6648h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6648h case   15:*/		return 0x820F664C;
		  /* 820F664Ch */ case   16:  		/* addi R7, R1, 92 */
		/* 820F664Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x5C);
		/* 820F664Ch case   16:*/		return 0x820F6650;
		  /* 820F6650h */ case   17:  		/* mr R5, R25 */
		/* 820F6650h case   17:*/		regs.R5 = regs.R25;
		/* 820F6650h case   17:*/		return 0x820F6654;
		  /* 820F6654h */ case   18:  		/* lwz R6, <#[R1 + 80]> */
		/* 820F6654h case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 820F6654h case   18:*/		return 0x820F6658;
		  /* 820F6658h */ case   19:  		/* mr R4, R24 */
		/* 820F6658h case   19:*/		regs.R4 = regs.R24;
		/* 820F6658h case   19:*/		return 0x820F665C;
		  /* 820F665Ch */ case   20:  		/* mr R3, R31 */
		/* 820F665Ch case   20:*/		regs.R3 = regs.R31;
		/* 820F665Ch case   20:*/		return 0x820F6660;
		  /* 820F6660h */ case   21:  		/* lwz R11, <#[R11 + 332]> */
		/* 820F6660h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000014C) );
		/* 820F6660h case   21:*/		return 0x820F6664;
		  /* 820F6664h */ case   22:  		/* mtspr CTR, R11 */
		/* 820F6664h case   22:*/		regs.CTR = regs.R11;
		/* 820F6664h case   22:*/		return 0x820F6668;
		  /* 820F6668h */ case   23:  		/* bcctrl 20, CR0_LT */
		/* 820F6668h case   23:*/		if ( 1 ) { regs.LR = 0x820F666C; return (uint32)regs.CTR; }
		/* 820F6668h case   23:*/		return 0x820F666C;
		  /* 820F666Ch */ case   24:  		/* cmpwi CR0, R3, 0 */
		/* 820F666Ch case   24:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F666Ch case   24:*/		return 0x820F6670;
		  /* 820F6670h */ case   25:  		/* bc 12, CR0_LT, 120 */
		/* 820F6670h case   25:*/		if ( regs.CR[0].lt ) { return 0x820F66E8;  }
		/* 820F6670h case   25:*/		return 0x820F6674;
		  /* 820F6674h */ case   26:  		/* lwz R11, <#[R1 + 276]> */
		/* 820F6674h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000114) );
		/* 820F6674h case   26:*/		return 0x820F6678;
		  /* 820F6678h */ case   27:  		/* cmplwi CR6, R11, 0 */
		/* 820F6678h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F6678h case   27:*/		return 0x820F667C;
		  /* 820F667Ch */ case   28:  		/* bc 12, CR6_EQ, 20 */
		/* 820F667Ch case   28:*/		if ( regs.CR[6].eq ) { return 0x820F6690;  }
		/* 820F667Ch case   28:*/		return 0x820F6680;
		  /* 820F6680h */ case   29:  		/* lwz R3, <#[R1 + 84]> */
		/* 820F6680h case   29:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 820F6680h case   29:*/		return 0x820F6684;
		  /* 820F6684h */ case   30:  		/* bl -39732 */
		/* 820F6684h case   30:*/		regs.LR = 0x820F6688; return 0x820ECB50;
		/* 820F6684h case   30:*/		return 0x820F6688;
		  /* 820F6688h */ case   31:  		/* mr R4, R3 */
		/* 820F6688h case   31:*/		regs.R4 = regs.R3;
		/* 820F6688h case   31:*/		return 0x820F668C;
		  /* 820F668Ch */ case   32:  		/* b 8 */
		/* 820F668Ch case   32:*/		return 0x820F6694;
		/* 820F668Ch case   32:*/		return 0x820F6690;
	}
	return 0x820F6690;
} // Block from 820F660Ch-820F6690h (33 instructions)

//////////////////////////////////////////////////////
// Block at 820F6690h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6690);
		  /* 820F6690h */ case    0:  		/* lwz R4, <#[R1 + 84]> */
		/* 820F6690h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 820F6690h case    0:*/		return 0x820F6694;
	}
	return 0x820F6694;
} // Block from 820F6690h-820F6694h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F6694h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6694( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6694) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6694);
		  /* 820F6694h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820F6694h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6694h case    0:*/		return 0x820F6698;
		  /* 820F6698h */ case    1:  		/* mr R3, R31 */
		/* 820F6698h case    1:*/		regs.R3 = regs.R31;
		/* 820F6698h case    1:*/		return 0x820F669C;
		  /* 820F669Ch */ case    2:  		/* lwz R6, <#[R1 + 88]> */
		/* 820F669Ch case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000058) );
		/* 820F669Ch case    2:*/		return 0x820F66A0;
		  /* 820F66A0h */ case    3:  		/* lwz R5, <#[R1 + 92]> */
		/* 820F66A0h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F66A0h case    3:*/		return 0x820F66A4;
		  /* 820F66A4h */ case    4:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F66A4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F66A4h case    4:*/		return 0x820F66A8;
		  /* 820F66A8h */ case    5:  		/* mtspr CTR, R11 */
		/* 820F66A8h case    5:*/		regs.CTR = regs.R11;
		/* 820F66A8h case    5:*/		return 0x820F66AC;
		  /* 820F66ACh */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 820F66ACh case    6:*/		if ( 1 ) { regs.LR = 0x820F66B0; return (uint32)regs.CTR; }
		/* 820F66ACh case    6:*/		return 0x820F66B0;
		  /* 820F66B0h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820F66B0h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F66B0h case    7:*/		return 0x820F66B4;
		  /* 820F66B4h */ case    8:  		/* bc 12, CR0_LT, 52 */
		/* 820F66B4h case    8:*/		if ( regs.CR[0].lt ) { return 0x820F66E8;  }
		/* 820F66B4h case    8:*/		return 0x820F66B8;
	}
	return 0x820F66B8;
} // Block from 820F6694h-820F66B8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F66B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F66B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F66B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F66B8);
		  /* 820F66B8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820F66B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F66B8h case    0:*/		return 0x820F66BC;
		  /* 820F66BCh */ case    1:  		/* mr R3, R31 */
		/* 820F66BCh case    1:*/		regs.R3 = regs.R31;
		/* 820F66BCh case    1:*/		return 0x820F66C0;
		  /* 820F66C0h */ case    2:  		/* lwz R11, <#[R11 + 308]> */
		/* 820F66C0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000134) );
		/* 820F66C0h case    2:*/		return 0x820F66C4;
		  /* 820F66C4h */ case    3:  		/* mtspr CTR, R11 */
		/* 820F66C4h case    3:*/		regs.CTR = regs.R11;
		/* 820F66C4h case    3:*/		return 0x820F66C8;
		  /* 820F66C8h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 820F66C8h case    4:*/		if ( 1 ) { regs.LR = 0x820F66CC; return (uint32)regs.CTR; }
		/* 820F66C8h case    4:*/		return 0x820F66CC;
		  /* 820F66CCh */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820F66CCh case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F66CCh case    5:*/		return 0x820F66D0;
		  /* 820F66D0h */ case    6:  		/* bc 12, CR0_LT, 24 */
		/* 820F66D0h case    6:*/		if ( regs.CR[0].lt ) { return 0x820F66E8;  }
		/* 820F66D0h case    6:*/		return 0x820F66D4;
		  /* 820F66D4h */ case    7:  		/* mr R3, R31 */
		/* 820F66D4h case    7:*/		regs.R3 = regs.R31;
		/* 820F66D4h case    7:*/		return 0x820F66D8;
		  /* 820F66D8h */ case    8:  		/* bl -36304 */
		/* 820F66D8h case    8:*/		regs.LR = 0x820F66DC; return 0x820ED908;
		/* 820F66D8h case    8:*/		return 0x820F66DC;
		  /* 820F66DCh */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820F66DCh case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F66DCh case    9:*/		return 0x820F66E0;
		  /* 820F66E0h */ case   10:  		/* bc 12, CR0_LT, 8 */
		/* 820F66E0h case   10:*/		if ( regs.CR[0].lt ) { return 0x820F66E8;  }
		/* 820F66E0h case   10:*/		return 0x820F66E4;
		  /* 820F66E4h */ case   11:  		/* li R3, 0 */
		/* 820F66E4h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F66E4h case   11:*/		return 0x820F66E8;
	}
	return 0x820F66E8;
} // Block from 820F66B8h-820F66E8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820F66E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F66E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F66E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F66E8);
		  /* 820F66E8h */ case    0:  		/* addi R1, R1, 176 */
		/* 820F66E8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820F66E8h case    0:*/		return 0x820F66EC;
		  /* 820F66ECh */ case    1:  		/* b -414804 */
		/* 820F66ECh case    1:*/		return 0x82091298;
		/* 820F66ECh case    1:*/		return 0x820F66F0;
	}
	return 0x820F66F0;
} // Block from 820F66E8h-820F66F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F66F0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F66F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F66F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F66F0);
		  /* 820F66F0h */ case    0:  		/* mfspr R12, LR */
		/* 820F66F0h case    0:*/		regs.R12 = regs.LR;
		/* 820F66F0h case    0:*/		return 0x820F66F4;
		  /* 820F66F4h */ case    1:  		/* bl -414876 */
		/* 820F66F4h case    1:*/		regs.LR = 0x820F66F8; return 0x82091258;
		/* 820F66F4h case    1:*/		return 0x820F66F8;
		  /* 820F66F8h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820F66F8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820F66F8h case    2:*/		return 0x820F66FC;
		  /* 820F66FCh */ case    3:  		/* lwz R11, <#[R3 + 348]> */
		/* 820F66FCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000015C) );
		/* 820F66FCh case    3:*/		return 0x820F6700;
		  /* 820F6700h */ case    4:  		/* mr R31, R3 */
		/* 820F6700h case    4:*/		regs.R31 = regs.R3;
		/* 820F6700h case    4:*/		return 0x820F6704;
		  /* 820F6704h */ case    5:  		/* mr R30, R4 */
		/* 820F6704h case    5:*/		regs.R30 = regs.R4;
		/* 820F6704h case    5:*/		return 0x820F6708;
		  /* 820F6708h */ case    6:  		/* mr R28, R5 */
		/* 820F6708h case    6:*/		regs.R28 = regs.R5;
		/* 820F6708h case    6:*/		return 0x820F670C;
		  /* 820F670Ch */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 820F670Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820F670Ch case    7:*/		return 0x820F6710;
		  /* 820F6710h */ case    8:  		/* bc 4, CR6_EQ, 248 */
		/* 820F6710h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820F6808;  }
		/* 820F6710h case    8:*/		return 0x820F6714;
		  /* 820F6714h */ case    9:  		/* cmplwi CR6, R4, 2048 */
		/* 820F6714h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000800);
		/* 820F6714h case    9:*/		return 0x820F6718;
		  /* 820F6718h */ case   10:  		/* rlwinm R11, R4, 0, 21, 31 */
		/* 820F6718h case   10:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R11,regs.R4);
		/* 820F6718h case   10:*/		return 0x820F671C;
		  /* 820F671Ch */ case   11:  		/* bc 4, CR6_LT, 12 */
		/* 820F671Ch case   11:*/		if ( !regs.CR[6].lt ) { return 0x820F6728;  }
		/* 820F671Ch case   11:*/		return 0x820F6720;
		  /* 820F6720h */ case   12:  		/* oris R30, R11, 40960 */
		/* 820F6720h case   12:*/		cpu::op::oris<0>(regs,&regs.R30,regs.R11,0xA000);
		/* 820F6720h case   12:*/		return 0x820F6724;
		  /* 820F6724h */ case   13:  		/* b 40 */
		/* 820F6724h case   13:*/		return 0x820F674C;
		/* 820F6724h case   13:*/		return 0x820F6728;
	}
	return 0x820F6728;
} // Block from 820F66F0h-820F6728h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820F6728h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6728);
		  /* 820F6728h */ case    0:  		/* cmplwi CR6, R30, 4096 */
		/* 820F6728h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00001000);
		/* 820F6728h case    0:*/		return 0x820F672C;
		  /* 820F672Ch */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 820F672Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x820F6738;  }
		/* 820F672Ch case    1:*/		return 0x820F6730;
		  /* 820F6730h */ case    2:  		/* oris R30, R11, 45056 */
		/* 820F6730h case    2:*/		cpu::op::oris<0>(regs,&regs.R30,regs.R11,0xB000);
		/* 820F6730h case    2:*/		return 0x820F6734;
		  /* 820F6734h */ case    3:  		/* b 20 */
		/* 820F6734h case    3:*/		return 0x820F6748;
		/* 820F6734h case    3:*/		return 0x820F6738;
	}
	return 0x820F6738;
} // Block from 820F6728h-820F6738h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F6738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6738);
		  /* 820F6738h */ case    0:  		/* cmplwi CR6, R30, 6144 */
		/* 820F6738h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00001800);
		/* 820F6738h case    0:*/		return 0x820F673C;
		  /* 820F673Ch */ case    1:  		/* oris R30, R11, 49152 */
		/* 820F673Ch case    1:*/		cpu::op::oris<0>(regs,&regs.R30,regs.R11,0xC000);
		/* 820F673Ch case    1:*/		return 0x820F6740;
		  /* 820F6740h */ case    2:  		/* bc 12, CR6_LT, 8 */
		/* 820F6740h case    2:*/		if ( regs.CR[6].lt ) { return 0x820F6748;  }
		/* 820F6740h case    2:*/		return 0x820F6744;
		  /* 820F6744h */ case    3:  		/* oris R30, R11, 53248 */
		/* 820F6744h case    3:*/		cpu::op::oris<0>(regs,&regs.R30,regs.R11,0xD000);
		/* 820F6744h case    3:*/		return 0x820F6748;
	}
	return 0x820F6748;
} // Block from 820F6738h-820F6748h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F6748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6748);
		  /* 820F6748h */ case    0:  		/* ori R30, R30, 2048 */
		/* 820F6748h case    0:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0x800);
		/* 820F6748h case    0:*/		return 0x820F674C;
	}
	return 0x820F674C;
} // Block from 820F6748h-820F674Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F674Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F674C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F674C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F674C);
		  /* 820F674Ch */ case    0:  		/* li R4, 81 */
		/* 820F674Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x51);
		/* 820F674Ch case    0:*/		return 0x820F6750;
		  /* 820F6750h */ case    1:  		/* mr R3, R31 */
		/* 820F6750h case    1:*/		regs.R3 = regs.R31;
		/* 820F6750h case    1:*/		return 0x820F6754;
		  /* 820F6754h */ case    2:  		/* bl -1636 */
		/* 820F6754h case    2:*/		regs.LR = 0x820F6758; return 0x820F60F0;
		/* 820F6754h case    2:*/		return 0x820F6758;
		  /* 820F6758h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820F6758h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6758h case    3:*/		return 0x820F675C;
		  /* 820F675Ch */ case    4:  		/* bc 12, CR0_LT, 300 */
		/* 820F675Ch case    4:*/		if ( regs.CR[0].lt ) { return 0x820F6888;  }
		/* 820F675Ch case    4:*/		return 0x820F6760;
		  /* 820F6760h */ case    5:  		/* lwz R11, <#[R31]> */
		/* 820F6760h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6760h case    5:*/		return 0x820F6764;
		  /* 820F6764h */ case    6:  		/* li R6, 0 */
		/* 820F6764h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820F6764h case    6:*/		return 0x820F6768;
		  /* 820F6768h */ case    7:  		/* lis R5, 15 */
		/* 820F6768h case    7:*/		cpu::op::lis<0>(regs,&regs.R5,0xF);
		/* 820F6768h case    7:*/		return 0x820F676C;
		  /* 820F676Ch */ case    8:  		/* mr R4, R30 */
		/* 820F676Ch case    8:*/		regs.R4 = regs.R30;
		/* 820F676Ch case    8:*/		return 0x820F6770;
		  /* 820F6770h */ case    9:  		/* mr R3, R31 */
		/* 820F6770h case    9:*/		regs.R3 = regs.R31;
		/* 820F6770h case    9:*/		return 0x820F6774;
		  /* 820F6774h */ case   10:  		/* lwz R11, <#[R11 + 312]> */
		/* 820F6774h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000138) );
		/* 820F6774h case   10:*/		return 0x820F6778;
		  /* 820F6778h */ case   11:  		/* mtspr CTR, R11 */
		/* 820F6778h case   11:*/		regs.CTR = regs.R11;
		/* 820F6778h case   11:*/		return 0x820F677C;
		  /* 820F677Ch */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 820F677Ch case   12:*/		if ( 1 ) { regs.LR = 0x820F6780; return (uint32)regs.CTR; }
		/* 820F677Ch case   12:*/		return 0x820F6780;
		  /* 820F6780h */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 820F6780h case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6780h case   13:*/		return 0x820F6784;
		  /* 820F6784h */ case   14:  		/* bc 12, CR0_LT, 260 */
		/* 820F6784h case   14:*/		if ( regs.CR[0].lt ) { return 0x820F6888;  }
		/* 820F6784h case   14:*/		return 0x820F6788;
		  /* 820F6788h */ case   15:  		/* mr R3, R31 */
		/* 820F6788h case   15:*/		regs.R3 = regs.R31;
		/* 820F6788h case   15:*/		return 0x820F678C;
		  /* 820F678Ch */ case   16:  		/* lwz R4, <#[R28]> */
		/* 820F678Ch case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000000) );
		/* 820F678Ch case   16:*/		return 0x820F6790;
		  /* 820F6790h */ case   17:  		/* bl -13344 */
		/* 820F6790h case   17:*/		regs.LR = 0x820F6794; return 0x820F3370;
		/* 820F6790h case   17:*/		return 0x820F6794;
		  /* 820F6794h */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 820F6794h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6794h case   18:*/		return 0x820F6798;
		  /* 820F6798h */ case   19:  		/* bc 12, CR0_LT, 240 */
		/* 820F6798h case   19:*/		if ( regs.CR[0].lt ) { return 0x820F6888;  }
		/* 820F6798h case   19:*/		return 0x820F679C;
		  /* 820F679Ch */ case   20:  		/* mr R3, R31 */
		/* 820F679Ch case   20:*/		regs.R3 = regs.R31;
		/* 820F679Ch case   20:*/		return 0x820F67A0;
		  /* 820F67A0h */ case   21:  		/* lwz R4, <#[R28 + 4]> */
		/* 820F67A0h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000004) );
		/* 820F67A0h case   21:*/		return 0x820F67A4;
		  /* 820F67A4h */ case   22:  		/* bl -13364 */
		/* 820F67A4h case   22:*/		regs.LR = 0x820F67A8; return 0x820F3370;
		/* 820F67A4h case   22:*/		return 0x820F67A8;
		  /* 820F67A8h */ case   23:  		/* cmpwi CR0, R3, 0 */
		/* 820F67A8h case   23:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F67A8h case   23:*/		return 0x820F67AC;
		  /* 820F67ACh */ case   24:  		/* bc 12, CR0_LT, 220 */
		/* 820F67ACh case   24:*/		if ( regs.CR[0].lt ) { return 0x820F6888;  }
		/* 820F67ACh case   24:*/		return 0x820F67B0;
		  /* 820F67B0h */ case   25:  		/* mr R3, R31 */
		/* 820F67B0h case   25:*/		regs.R3 = regs.R31;
		/* 820F67B0h case   25:*/		return 0x820F67B4;
		  /* 820F67B4h */ case   26:  		/* lwz R4, <#[R28 + 8]> */
		/* 820F67B4h case   26:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000008) );
		/* 820F67B4h case   26:*/		return 0x820F67B8;
		  /* 820F67B8h */ case   27:  		/* bl -13384 */
		/* 820F67B8h case   27:*/		regs.LR = 0x820F67BC; return 0x820F3370;
		/* 820F67B8h case   27:*/		return 0x820F67BC;
		  /* 820F67BCh */ case   28:  		/* cmpwi CR0, R3, 0 */
		/* 820F67BCh case   28:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F67BCh case   28:*/		return 0x820F67C0;
		  /* 820F67C0h */ case   29:  		/* bc 12, CR0_LT, 200 */
		/* 820F67C0h case   29:*/		if ( regs.CR[0].lt ) { return 0x820F6888;  }
		/* 820F67C0h case   29:*/		return 0x820F67C4;
		  /* 820F67C4h */ case   30:  		/* mr R3, R31 */
		/* 820F67C4h case   30:*/		regs.R3 = regs.R31;
		/* 820F67C4h case   30:*/		return 0x820F67C8;
		  /* 820F67C8h */ case   31:  		/* lwz R4, <#[R28 + 12]> */
		/* 820F67C8h case   31:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x0000000C) );
		/* 820F67C8h case   31:*/		return 0x820F67CC;
		  /* 820F67CCh */ case   32:  		/* bl -13404 */
		/* 820F67CCh case   32:*/		regs.LR = 0x820F67D0; return 0x820F3370;
		/* 820F67CCh case   32:*/		return 0x820F67D0;
		  /* 820F67D0h */ case   33:  		/* cmpwi CR0, R3, 0 */
		/* 820F67D0h case   33:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F67D0h case   33:*/		return 0x820F67D4;
		  /* 820F67D4h */ case   34:  		/* bc 12, CR0_LT, 180 */
		/* 820F67D4h case   34:*/		if ( regs.CR[0].lt ) { return 0x820F6888;  }
		/* 820F67D4h case   34:*/		return 0x820F67D8;
		  /* 820F67D8h */ case   35:  		/* lwz R11, <#[R31]> */
		/* 820F67D8h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F67D8h case   35:*/		return 0x820F67DC;
		  /* 820F67DCh */ case   36:  		/* mr R3, R31 */
		/* 820F67DCh case   36:*/		regs.R3 = regs.R31;
		/* 820F67DCh case   36:*/		return 0x820F67E0;
		  /* 820F67E0h */ case   37:  		/* lwz R11, <#[R11 + 308]> */
		/* 820F67E0h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000134) );
		/* 820F67E0h case   37:*/		return 0x820F67E4;
		  /* 820F67E4h */ case   38:  		/* mtspr CTR, R11 */
		/* 820F67E4h case   38:*/		regs.CTR = regs.R11;
		/* 820F67E4h case   38:*/		return 0x820F67E8;
		  /* 820F67E8h */ case   39:  		/* bcctrl 20, CR0_LT */
		/* 820F67E8h case   39:*/		if ( 1 ) { regs.LR = 0x820F67EC; return (uint32)regs.CTR; }
		/* 820F67E8h case   39:*/		return 0x820F67EC;
		  /* 820F67ECh */ case   40:  		/* cmpwi CR0, R3, 0 */
		/* 820F67ECh case   40:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F67ECh case   40:*/		return 0x820F67F0;
		  /* 820F67F0h */ case   41:  		/* bc 12, CR0_LT, 152 */
		/* 820F67F0h case   41:*/		if ( regs.CR[0].lt ) { return 0x820F6888;  }
		/* 820F67F0h case   41:*/		return 0x820F67F4;
		  /* 820F67F4h */ case   42:  		/* mr R3, R31 */
		/* 820F67F4h case   42:*/		regs.R3 = regs.R31;
		/* 820F67F4h case   42:*/		return 0x820F67F8;
		  /* 820F67F8h */ case   43:  		/* bl -36592 */
		/* 820F67F8h case   43:*/		regs.LR = 0x820F67FC; return 0x820ED908;
		/* 820F67F8h case   43:*/		return 0x820F67FC;
		  /* 820F67FCh */ case   44:  		/* cmpwi CR0, R3, 0 */
		/* 820F67FCh case   44:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F67FCh case   44:*/		return 0x820F6800;
		  /* 820F6800h */ case   45:  		/* bc 4, CR0_LT, 132 */
		/* 820F6800h case   45:*/		if ( !regs.CR[0].lt ) { return 0x820F6884;  }
		/* 820F6800h case   45:*/		return 0x820F6804;
		  /* 820F6804h */ case   46:  		/* b 132 */
		/* 820F6804h case   46:*/		return 0x820F6888;
		/* 820F6804h case   46:*/		return 0x820F6808;
	}
	return 0x820F6808;
} // Block from 820F674Ch-820F6808h (47 instructions)

//////////////////////////////////////////////////////
// Block at 820F6808h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6808);
		  /* 820F6808h */ case    0:  		/* lis R11, -32254 */
		/* 820F6808h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F6808h case    0:*/		return 0x820F680C;
		  /* 820F680Ch */ case    1:  		/* mr R6, R30 */
		/* 820F680Ch case    1:*/		regs.R6 = regs.R30;
		/* 820F680Ch case    1:*/		return 0x820F6810;
		  /* 820F6810h */ case    2:  		/* addi R5, R11, -15528 */
		/* 820F6810h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFC358);
		/* 820F6810h case    2:*/		return 0x820F6814;
		  /* 820F6814h */ case    3:  		/* li R4, 32 */
		/* 820F6814h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x20);
		/* 820F6814h case    3:*/		return 0x820F6818;
		  /* 820F6818h */ case    4:  		/* addi R3, R1, 80 */
		/* 820F6818h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820F6818h case    4:*/		return 0x820F681C;
		  /* 820F681Ch */ case    5:  		/* bl -344540 */
		/* 820F681Ch case    5:*/		regs.LR = 0x820F6820; return 0x820A2640;
		/* 820F681Ch case    5:*/		return 0x820F6820;
		  /* 820F6820h */ case    6:  		/* addi R29, R31, 440 */
		/* 820F6820h case    6:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x1B8);
		/* 820F6820h case    6:*/		return 0x820F6824;
		  /* 820F6824h */ case    7:  		/* li R6, 1 */
		/* 820F6824h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820F6824h case    7:*/		return 0x820F6828;
		  /* 820F6828h */ case    8:  		/* mr R5, R30 */
		/* 820F6828h case    8:*/		regs.R5 = regs.R30;
		/* 820F6828h case    8:*/		return 0x820F682C;
		  /* 820F682Ch */ case    9:  		/* addi R4, R1, 80 */
		/* 820F682Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820F682Ch case    9:*/		return 0x820F6830;
		  /* 820F6830h */ case   10:  		/* mr R3, R29 */
		/* 820F6830h case   10:*/		regs.R3 = regs.R29;
		/* 820F6830h case   10:*/		return 0x820F6834;
		  /* 820F6834h */ case   11:  		/* bl -316092 */
		/* 820F6834h case   11:*/		regs.LR = 0x820F6838; return 0x820A9578;
		/* 820F6834h case   11:*/		return 0x820F6838;
		  /* 820F6838h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820F6838h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6838h case   12:*/		return 0x820F683C;
		  /* 820F683Ch */ case   13:  		/* bc 12, CR0_LT, 76 */
		/* 820F683Ch case   13:*/		if ( regs.CR[0].lt ) { return 0x820F6888;  }
		/* 820F683Ch case   13:*/		return 0x820F6840;
		  /* 820F6840h */ case   14:  		/* addi R4, R1, 80 */
		/* 820F6840h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820F6840h case   14:*/		return 0x820F6844;
		  /* 820F6844h */ case   15:  		/* mr R3, R29 */
		/* 820F6844h case   15:*/		regs.R3 = regs.R29;
		/* 820F6844h case   15:*/		return 0x820F6848;
		  /* 820F6848h */ case   16:  		/* bl -318552 */
		/* 820F6848h case   16:*/		regs.LR = 0x820F684C; return 0x820A8BF0;
		/* 820F6848h case   16:*/		return 0x820F684C;
		  /* 820F684Ch */ case   17:  		/* li R10, 1 */
		/* 820F684Ch case   17:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820F684Ch case   17:*/		return 0x820F6850;
		  /* 820F6850h */ case   18:  		/* mr R11, R3 */
		/* 820F6850h case   18:*/		regs.R11 = regs.R3;
		/* 820F6850h case   18:*/		return 0x820F6854;
		  /* 820F6854h */ case   19:  		/* stw R10, <#[R3 + 12]> */
		/* 820F6854h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 820F6854h case   19:*/		return 0x820F6858;
		  /* 820F6858h */ case   20:  		/* lfs FR0, <#[R28]> */
		/* 820F6858h case   20:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R28 + 0x00000000) );
		/* 820F6858h case   20:*/		return 0x820F685C;
		  /* 820F685Ch */ case   21:  		/* stfs FR0, <#[R3 + 16]> */
		/* 820F685Ch case   21:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x00000010) );
		/* 820F685Ch case   21:*/		return 0x820F6860;
		  /* 820F6860h */ case   22:  		/* lfs FR0, <#[R28 + 4]> */
		/* 820F6860h case   22:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R28 + 0x00000004) );
		/* 820F6860h case   22:*/		return 0x820F6864;
		  /* 820F6864h */ case   23:  		/* stfs FR0, <#[R3 + 20]> */
		/* 820F6864h case   23:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x00000014) );
		/* 820F6864h case   23:*/		return 0x820F6868;
		  /* 820F6868h */ case   24:  		/* lfs FR0, <#[R28 + 8]> */
		/* 820F6868h case   24:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R28 + 0x00000008) );
		/* 820F6868h case   24:*/		return 0x820F686C;
		  /* 820F686Ch */ case   25:  		/* stfs FR0, <#[R3 + 24]> */
		/* 820F686Ch case   25:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x00000018) );
		/* 820F686Ch case   25:*/		return 0x820F6870;
		  /* 820F6870h */ case   26:  		/* lfs FR0, <#[R28 + 12]> */
		/* 820F6870h case   26:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R28 + 0x0000000C) );
		/* 820F6870h case   26:*/		return 0x820F6874;
		  /* 820F6874h */ case   27:  		/* stfs FR0, <#[R3 + 28]> */
		/* 820F6874h case   27:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x0000001C) );
		/* 820F6874h case   27:*/		return 0x820F6878;
		  /* 820F6878h */ case   28:  		/* lwz R11, <#[R31 + 504]> */
		/* 820F6878h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000001F8) );
		/* 820F6878h case   28:*/		return 0x820F687C;
		  /* 820F687Ch */ case   29:  		/* addi R11, R11, 1 */
		/* 820F687Ch case   29:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F687Ch case   29:*/		return 0x820F6880;
		  /* 820F6880h */ case   30:  		/* stw R11, <#[R31 + 504]> */
		/* 820F6880h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000001F8) );
		/* 820F6880h case   30:*/		return 0x820F6884;
	}
	return 0x820F6884;
} // Block from 820F6808h-820F6884h (31 instructions)

//////////////////////////////////////////////////////
// Block at 820F6884h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6884( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6884) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6884);
		  /* 820F6884h */ case    0:  		/* li R3, 0 */
		/* 820F6884h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F6884h case    0:*/		return 0x820F6888;
	}
	return 0x820F6888;
} // Block from 820F6884h-820F6888h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F6888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6888);
		  /* 820F6888h */ case    0:  		/* addi R1, R1, 160 */
		/* 820F6888h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820F6888h case    0:*/		return 0x820F688C;
		  /* 820F688Ch */ case    1:  		/* b -415204 */
		/* 820F688Ch case    1:*/		return 0x820912A8;
		/* 820F688Ch case    1:*/		return 0x820F6890;
	}
	return 0x820F6890;
} // Block from 820F6888h-820F6890h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F6890h
// Function '?EmitInst@CShaderProgram@D3DXShader@@IAAJK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6890);
		  /* 820F6890h */ case    0:  		/* mfspr R12, LR */
		/* 820F6890h case    0:*/		regs.R12 = regs.LR;
		/* 820F6890h case    0:*/		return 0x820F6894;
		  /* 820F6894h */ case    1:  		/* bl -415292 */
		/* 820F6894h case    1:*/		regs.LR = 0x820F6898; return 0x82091258;
		/* 820F6894h case    1:*/		return 0x820F6898;
		  /* 820F6898h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820F6898h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820F6898h case    2:*/		return 0x820F689C;
		  /* 820F689Ch */ case    3:  		/* lwz R11, <#[R3 + 348]> */
		/* 820F689Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000015C) );
		/* 820F689Ch case    3:*/		return 0x820F68A0;
		  /* 820F68A0h */ case    4:  		/* mr R31, R3 */
		/* 820F68A0h case    4:*/		regs.R31 = regs.R3;
		/* 820F68A0h case    4:*/		return 0x820F68A4;
		  /* 820F68A4h */ case    5:  		/* mr R28, R4 */
		/* 820F68A4h case    5:*/		regs.R28 = regs.R4;
		/* 820F68A4h case    5:*/		return 0x820F68A8;
		  /* 820F68A8h */ case    6:  		/* mr R30, R5 */
		/* 820F68A8h case    6:*/		regs.R30 = regs.R5;
		/* 820F68A8h case    6:*/		return 0x820F68AC;
		  /* 820F68ACh */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 820F68ACh case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820F68ACh case    7:*/		return 0x820F68B0;
		  /* 820F68B0h */ case    8:  		/* bc 4, CR6_EQ, 196 */
		/* 820F68B0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820F6974;  }
		/* 820F68B0h case    8:*/		return 0x820F68B4;
		  /* 820F68B4h */ case    9:  		/* li R4, 48 */
		/* 820F68B4h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x30);
		/* 820F68B4h case    9:*/		return 0x820F68B8;
		  /* 820F68B8h */ case   10:  		/* bl -1992 */
		/* 820F68B8h case   10:*/		regs.LR = 0x820F68BC; return 0x820F60F0;
		/* 820F68B8h case   10:*/		return 0x820F68BC;
		  /* 820F68BCh */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820F68BCh case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F68BCh case   11:*/		return 0x820F68C0;
		  /* 820F68C0h */ case   12:  		/* bc 12, CR0_LT, 308 */
		/* 820F68C0h case   12:*/		if ( regs.CR[0].lt ) { return 0x820F69F4;  }
		/* 820F68C0h case   12:*/		return 0x820F68C4;
		  /* 820F68C4h */ case   13:  		/* lwz R11, <#[R31]> */
		/* 820F68C4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F68C4h case   13:*/		return 0x820F68C8;
		  /* 820F68C8h */ case   14:  		/* li R10, 15 */
		/* 820F68C8h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0xF);
		/* 820F68C8h case   14:*/		return 0x820F68CC;
		  /* 820F68CCh */ case   15:  		/* mr R4, R28 */
		/* 820F68CCh case   15:*/		regs.R4 = regs.R28;
		/* 820F68CCh case   15:*/		return 0x820F68D0;
		  /* 820F68D0h */ case   16:  		/* li R6, 0 */
		/* 820F68D0h case   16:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820F68D0h case   16:*/		return 0x820F68D4;
		  /* 820F68D4h */ case   17:  		/* rlwimi R4, R10, 28, 0, 20 */
		/* 820F68D4h case   17:*/		cpu::op::rlwimi<0,28,0,20>(regs,&regs.R4,regs.R10);
		/* 820F68D4h case   17:*/		return 0x820F68D8;
		  /* 820F68D8h */ case   18:  		/* lis R5, 15 */
		/* 820F68D8h case   18:*/		cpu::op::lis<0>(regs,&regs.R5,0xF);
		/* 820F68D8h case   18:*/		return 0x820F68DC;
		  /* 820F68DCh */ case   19:  		/* lwz R11, <#[R11 + 312]> */
		/* 820F68DCh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000138) );
		/* 820F68DCh case   19:*/		return 0x820F68E0;
		  /* 820F68E0h */ case   20:  		/* mr R3, R31 */
		/* 820F68E0h case   20:*/		regs.R3 = regs.R31;
		/* 820F68E0h case   20:*/		return 0x820F68E4;
		  /* 820F68E4h */ case   21:  		/* mtspr CTR, R11 */
		/* 820F68E4h case   21:*/		regs.CTR = regs.R11;
		/* 820F68E4h case   21:*/		return 0x820F68E8;
		  /* 820F68E8h */ case   22:  		/* bcctrl 20, CR0_LT */
		/* 820F68E8h case   22:*/		if ( 1 ) { regs.LR = 0x820F68EC; return (uint32)regs.CTR; }
		/* 820F68E8h case   22:*/		return 0x820F68EC;
		  /* 820F68ECh */ case   23:  		/* cmpwi CR0, R3, 0 */
		/* 820F68ECh case   23:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F68ECh case   23:*/		return 0x820F68F0;
		  /* 820F68F0h */ case   24:  		/* bc 12, CR0_LT, 260 */
		/* 820F68F0h case   24:*/		if ( regs.CR[0].lt ) { return 0x820F69F4;  }
		/* 820F68F0h case   24:*/		return 0x820F68F4;
		  /* 820F68F4h */ case   25:  		/* mr R3, R31 */
		/* 820F68F4h case   25:*/		regs.R3 = regs.R31;
		/* 820F68F4h case   25:*/		return 0x820F68F8;
		  /* 820F68F8h */ case   26:  		/* lwz R4, <#[R30]> */
		/* 820F68F8h case   26:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000000) );
		/* 820F68F8h case   26:*/		return 0x820F68FC;
		  /* 820F68FCh */ case   27:  		/* bl -13708 */
		/* 820F68FCh case   27:*/		regs.LR = 0x820F6900; return 0x820F3370;
		/* 820F68FCh case   27:*/		return 0x820F6900;
		  /* 820F6900h */ case   28:  		/* cmpwi CR0, R3, 0 */
		/* 820F6900h case   28:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6900h case   28:*/		return 0x820F6904;
		  /* 820F6904h */ case   29:  		/* bc 12, CR0_LT, 240 */
		/* 820F6904h case   29:*/		if ( regs.CR[0].lt ) { return 0x820F69F4;  }
		/* 820F6904h case   29:*/		return 0x820F6908;
		  /* 820F6908h */ case   30:  		/* mr R3, R31 */
		/* 820F6908h case   30:*/		regs.R3 = regs.R31;
		/* 820F6908h case   30:*/		return 0x820F690C;
		  /* 820F690Ch */ case   31:  		/* lwz R4, <#[R30 + 4]> */
		/* 820F690Ch case   31:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000004) );
		/* 820F690Ch case   31:*/		return 0x820F6910;
		  /* 820F6910h */ case   32:  		/* bl -13728 */
		/* 820F6910h case   32:*/		regs.LR = 0x820F6914; return 0x820F3370;
		/* 820F6910h case   32:*/		return 0x820F6914;
		  /* 820F6914h */ case   33:  		/* cmpwi CR0, R3, 0 */
		/* 820F6914h case   33:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6914h case   33:*/		return 0x820F6918;
		  /* 820F6918h */ case   34:  		/* bc 12, CR0_LT, 220 */
		/* 820F6918h case   34:*/		if ( regs.CR[0].lt ) { return 0x820F69F4;  }
		/* 820F6918h case   34:*/		return 0x820F691C;
		  /* 820F691Ch */ case   35:  		/* mr R3, R31 */
		/* 820F691Ch case   35:*/		regs.R3 = regs.R31;
		/* 820F691Ch case   35:*/		return 0x820F6920;
		  /* 820F6920h */ case   36:  		/* lwz R4, <#[R30 + 8]> */
		/* 820F6920h case   36:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000008) );
		/* 820F6920h case   36:*/		return 0x820F6924;
		  /* 820F6924h */ case   37:  		/* bl -13748 */
		/* 820F6924h case   37:*/		regs.LR = 0x820F6928; return 0x820F3370;
		/* 820F6924h case   37:*/		return 0x820F6928;
		  /* 820F6928h */ case   38:  		/* cmpwi CR0, R3, 0 */
		/* 820F6928h case   38:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6928h case   38:*/		return 0x820F692C;
		  /* 820F692Ch */ case   39:  		/* bc 12, CR0_LT, 200 */
		/* 820F692Ch case   39:*/		if ( regs.CR[0].lt ) { return 0x820F69F4;  }
		/* 820F692Ch case   39:*/		return 0x820F6930;
		  /* 820F6930h */ case   40:  		/* mr R3, R31 */
		/* 820F6930h case   40:*/		regs.R3 = regs.R31;
		/* 820F6930h case   40:*/		return 0x820F6934;
		  /* 820F6934h */ case   41:  		/* lwz R4, <#[R30 + 12]> */
		/* 820F6934h case   41:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000000C) );
		/* 820F6934h case   41:*/		return 0x820F6938;
		  /* 820F6938h */ case   42:  		/* bl -13768 */
		/* 820F6938h case   42:*/		regs.LR = 0x820F693C; return 0x820F3370;
		/* 820F6938h case   42:*/		return 0x820F693C;
		  /* 820F693Ch */ case   43:  		/* cmpwi CR0, R3, 0 */
		/* 820F693Ch case   43:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F693Ch case   43:*/		return 0x820F6940;
		  /* 820F6940h */ case   44:  		/* bc 12, CR0_LT, 180 */
		/* 820F6940h case   44:*/		if ( regs.CR[0].lt ) { return 0x820F69F4;  }
		/* 820F6940h case   44:*/		return 0x820F6944;
		  /* 820F6944h */ case   45:  		/* lwz R11, <#[R31]> */
		/* 820F6944h case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6944h case   45:*/		return 0x820F6948;
		  /* 820F6948h */ case   46:  		/* mr R3, R31 */
		/* 820F6948h case   46:*/		regs.R3 = regs.R31;
		/* 820F6948h case   46:*/		return 0x820F694C;
		  /* 820F694Ch */ case   47:  		/* lwz R11, <#[R11 + 308]> */
		/* 820F694Ch case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000134) );
		/* 820F694Ch case   47:*/		return 0x820F6950;
		  /* 820F6950h */ case   48:  		/* mtspr CTR, R11 */
		/* 820F6950h case   48:*/		regs.CTR = regs.R11;
		/* 820F6950h case   48:*/		return 0x820F6954;
		  /* 820F6954h */ case   49:  		/* bcctrl 20, CR0_LT */
		/* 820F6954h case   49:*/		if ( 1 ) { regs.LR = 0x820F6958; return (uint32)regs.CTR; }
		/* 820F6954h case   49:*/		return 0x820F6958;
		  /* 820F6958h */ case   50:  		/* cmpwi CR0, R3, 0 */
		/* 820F6958h case   50:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6958h case   50:*/		return 0x820F695C;
		  /* 820F695Ch */ case   51:  		/* bc 12, CR0_LT, 152 */
		/* 820F695Ch case   51:*/		if ( regs.CR[0].lt ) { return 0x820F69F4;  }
		/* 820F695Ch case   51:*/		return 0x820F6960;
		  /* 820F6960h */ case   52:  		/* mr R3, R31 */
		/* 820F6960h case   52:*/		regs.R3 = regs.R31;
		/* 820F6960h case   52:*/		return 0x820F6964;
		  /* 820F6964h */ case   53:  		/* bl -36956 */
		/* 820F6964h case   53:*/		regs.LR = 0x820F6968; return 0x820ED908;
		/* 820F6964h case   53:*/		return 0x820F6968;
		  /* 820F6968h */ case   54:  		/* cmpwi CR0, R3, 0 */
		/* 820F6968h case   54:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6968h case   54:*/		return 0x820F696C;
		  /* 820F696Ch */ case   55:  		/* bc 4, CR0_LT, 132 */
		/* 820F696Ch case   55:*/		if ( !regs.CR[0].lt ) { return 0x820F69F0;  }
		/* 820F696Ch case   55:*/		return 0x820F6970;
		  /* 820F6970h */ case   56:  		/* b 132 */
		/* 820F6970h case   56:*/		return 0x820F69F4;
		/* 820F6970h case   56:*/		return 0x820F6974;
	}
	return 0x820F6974;
} // Block from 820F6890h-820F6974h (57 instructions)

//////////////////////////////////////////////////////
// Block at 820F6974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6974);
		  /* 820F6974h */ case    0:  		/* lis R11, -32254 */
		/* 820F6974h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F6974h case    0:*/		return 0x820F6978;
		  /* 820F6978h */ case    1:  		/* mr R6, R28 */
		/* 820F6978h case    1:*/		regs.R6 = regs.R28;
		/* 820F6978h case    1:*/		return 0x820F697C;
		  /* 820F697Ch */ case    2:  		/* addi R5, R11, -15520 */
		/* 820F697Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFC360);
		/* 820F697Ch case    2:*/		return 0x820F6980;
		  /* 820F6980h */ case    3:  		/* li R4, 32 */
		/* 820F6980h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x20);
		/* 820F6980h case    3:*/		return 0x820F6984;
		  /* 820F6984h */ case    4:  		/* addi R3, R1, 80 */
		/* 820F6984h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820F6984h case    4:*/		return 0x820F6988;
		  /* 820F6988h */ case    5:  		/* bl -344904 */
		/* 820F6988h case    5:*/		regs.LR = 0x820F698C; return 0x820A2640;
		/* 820F6988h case    5:*/		return 0x820F698C;
		  /* 820F698Ch */ case    6:  		/* addi R29, R31, 440 */
		/* 820F698Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x1B8);
		/* 820F698Ch case    6:*/		return 0x820F6990;
		  /* 820F6990h */ case    7:  		/* li R6, 1 */
		/* 820F6990h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820F6990h case    7:*/		return 0x820F6994;
		  /* 820F6994h */ case    8:  		/* mr R5, R28 */
		/* 820F6994h case    8:*/		regs.R5 = regs.R28;
		/* 820F6994h case    8:*/		return 0x820F6998;
		  /* 820F6998h */ case    9:  		/* addi R4, R1, 80 */
		/* 820F6998h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820F6998h case    9:*/		return 0x820F699C;
		  /* 820F699Ch */ case   10:  		/* mr R3, R29 */
		/* 820F699Ch case   10:*/		regs.R3 = regs.R29;
		/* 820F699Ch case   10:*/		return 0x820F69A0;
		  /* 820F69A0h */ case   11:  		/* bl -316456 */
		/* 820F69A0h case   11:*/		regs.LR = 0x820F69A4; return 0x820A9578;
		/* 820F69A0h case   11:*/		return 0x820F69A4;
		  /* 820F69A4h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820F69A4h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F69A4h case   12:*/		return 0x820F69A8;
		  /* 820F69A8h */ case   13:  		/* bc 12, CR0_LT, 76 */
		/* 820F69A8h case   13:*/		if ( regs.CR[0].lt ) { return 0x820F69F4;  }
		/* 820F69A8h case   13:*/		return 0x820F69AC;
		  /* 820F69ACh */ case   14:  		/* addi R4, R1, 80 */
		/* 820F69ACh case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820F69ACh case   14:*/		return 0x820F69B0;
	}
	return 0x820F69B0;
} // Block from 820F6974h-820F69B0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820F69B0h
// Function '?EmitReg@CShaderProgram@D3DXShader@@IAAJK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F69B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F69B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F69B0);
		  /* 820F69B0h */ case    0:  		/* mr R3, R29 */
		/* 820F69B0h case    0:*/		regs.R3 = regs.R29;
		/* 820F69B0h case    0:*/		return 0x820F69B4;
		  /* 820F69B4h */ case    1:  		/* bl -318916 */
		/* 820F69B4h case    1:*/		regs.LR = 0x820F69B8; return 0x820A8BF0;
		/* 820F69B4h case    1:*/		return 0x820F69B8;
		  /* 820F69B8h */ case    2:  		/* li R10, 1 */
		/* 820F69B8h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820F69B8h case    2:*/		return 0x820F69BC;
		  /* 820F69BCh */ case    3:  		/* mr R11, R3 */
		/* 820F69BCh case    3:*/		regs.R11 = regs.R3;
		/* 820F69BCh case    3:*/		return 0x820F69C0;
		  /* 820F69C0h */ case    4:  		/* stw R10, <#[R3 + 12]> */
		/* 820F69C0h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 820F69C0h case    4:*/		return 0x820F69C4;
		  /* 820F69C4h */ case    5:  		/* lfs FR0, <#[R30]> */
		/* 820F69C4h case    5:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R30 + 0x00000000) );
		/* 820F69C4h case    5:*/		return 0x820F69C8;
		  /* 820F69C8h */ case    6:  		/* stfs FR0, <#[R3 + 16]> */
		/* 820F69C8h case    6:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x00000010) );
		/* 820F69C8h case    6:*/		return 0x820F69CC;
		  /* 820F69CCh */ case    7:  		/* lfs FR0, <#[R30 + 4]> */
		/* 820F69CCh case    7:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R30 + 0x00000004) );
		/* 820F69CCh case    7:*/		return 0x820F69D0;
		  /* 820F69D0h */ case    8:  		/* stfs FR0, <#[R3 + 20]> */
		/* 820F69D0h case    8:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x00000014) );
		/* 820F69D0h case    8:*/		return 0x820F69D4;
		  /* 820F69D4h */ case    9:  		/* lfs FR0, <#[R30 + 8]> */
		/* 820F69D4h case    9:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R30 + 0x00000008) );
		/* 820F69D4h case    9:*/		return 0x820F69D8;
	}
	return 0x820F69D8;
} // Block from 820F69B0h-820F69D8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F69D8h
// Function '?EmitDest@CShaderProgram@D3DXShader@@MAAJKKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F69D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F69D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F69D8);
		  /* 820F69D8h */ case    0:  		/* stfs FR0, <#[R3 + 24]> */
		/* 820F69D8h case    0:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x00000018) );
		/* 820F69D8h case    0:*/		return 0x820F69DC;
		  /* 820F69DCh */ case    1:  		/* lfs FR0, <#[R30 + 12]> */
		/* 820F69DCh case    1:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R30 + 0x0000000C) );
		/* 820F69DCh case    1:*/		return 0x820F69E0;
		  /* 820F69E0h */ case    2:  		/* stfs FR0, <#[R3 + 28]> */
		/* 820F69E0h case    2:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x0000001C) );
		/* 820F69E0h case    2:*/		return 0x820F69E4;
		  /* 820F69E4h */ case    3:  		/* lwz R11, <#[R31 + 504]> */
		/* 820F69E4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000001F8) );
		/* 820F69E4h case    3:*/		return 0x820F69E8;
		  /* 820F69E8h */ case    4:  		/* addi R11, R11, 1 */
		/* 820F69E8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F69E8h case    4:*/		return 0x820F69EC;
		  /* 820F69ECh */ case    5:  		/* stw R11, <#[R31 + 504]> */
		/* 820F69ECh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000001F8) );
		/* 820F69ECh case    5:*/		return 0x820F69F0;
	}
	return 0x820F69F0;
} // Block from 820F69D8h-820F69F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F69F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F69F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F69F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F69F0);
		  /* 820F69F0h */ case    0:  		/* li R3, 0 */
		/* 820F69F0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F69F0h case    0:*/		return 0x820F69F4;
	}
	return 0x820F69F4;
} // Block from 820F69F0h-820F69F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F69F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F69F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F69F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F69F4);
		  /* 820F69F4h */ case    0:  		/* addi R1, R1, 160 */
		/* 820F69F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820F69F4h case    0:*/		return 0x820F69F8;
		  /* 820F69F8h */ case    1:  		/* b -415568 */
		/* 820F69F8h case    1:*/		return 0x820912A8;
		/* 820F69F8h case    1:*/		return 0x820F69FC;
		  /* 820F69FCh */ case    2:  		/* nop */
		/* 820F69FCh case    2:*/		cpu::op::nop();
		/* 820F69FCh case    2:*/		return 0x820F6A00;
	}
	return 0x820F6A00;
} // Block from 820F69F4h-820F6A00h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F6A00h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6A00);
		  /* 820F6A00h */ case    0:  		/* mfspr R12, LR */
		/* 820F6A00h case    0:*/		regs.R12 = regs.LR;
		/* 820F6A00h case    0:*/		return 0x820F6A04;
		  /* 820F6A04h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820F6A04h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F6A04h case    1:*/		return 0x820F6A08;
		  /* 820F6A08h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820F6A08h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F6A08h case    2:*/		return 0x820F6A0C;
		  /* 820F6A0Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820F6A0Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820F6A0Ch case    3:*/		return 0x820F6A10;
		  /* 820F6A10h */ case    4:  		/* li R4, 39 */
		/* 820F6A10h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x27);
		/* 820F6A10h case    4:*/		return 0x820F6A14;
		  /* 820F6A14h */ case    5:  		/* mr R31, R3 */
		/* 820F6A14h case    5:*/		regs.R31 = regs.R3;
		/* 820F6A14h case    5:*/		return 0x820F6A18;
		  /* 820F6A18h */ case    6:  		/* bl -2344 */
		/* 820F6A18h case    6:*/		regs.LR = 0x820F6A1C; return 0x820F60F0;
		/* 820F6A18h case    6:*/		return 0x820F6A1C;
		  /* 820F6A1Ch */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820F6A1Ch case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6A1Ch case    7:*/		return 0x820F6A20;
		  /* 820F6A20h */ case    8:  		/* bc 12, CR0_LT, 52 */
		/* 820F6A20h case    8:*/		if ( regs.CR[0].lt ) { return 0x820F6A54;  }
		/* 820F6A20h case    8:*/		return 0x820F6A24;
		  /* 820F6A24h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 820F6A24h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6A24h case    9:*/		return 0x820F6A28;
		  /* 820F6A28h */ case   10:  		/* mr R3, R31 */
		/* 820F6A28h case   10:*/		regs.R3 = regs.R31;
		/* 820F6A28h case   10:*/		return 0x820F6A2C;
		  /* 820F6A2Ch */ case   11:  		/* lwz R11, <#[R11 + 308]> */
		/* 820F6A2Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000134) );
		/* 820F6A2Ch case   11:*/		return 0x820F6A30;
		  /* 820F6A30h */ case   12:  		/* mtspr CTR, R11 */
		/* 820F6A30h case   12:*/		regs.CTR = regs.R11;
		/* 820F6A30h case   12:*/		return 0x820F6A34;
		  /* 820F6A34h */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 820F6A34h case   13:*/		if ( 1 ) { regs.LR = 0x820F6A38; return (uint32)regs.CTR; }
		/* 820F6A34h case   13:*/		return 0x820F6A38;
		  /* 820F6A38h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 820F6A38h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6A38h case   14:*/		return 0x820F6A3C;
		  /* 820F6A3Ch */ case   15:  		/* bc 12, CR0_LT, 24 */
		/* 820F6A3Ch case   15:*/		if ( regs.CR[0].lt ) { return 0x820F6A54;  }
		/* 820F6A3Ch case   15:*/		return 0x820F6A40;
		  /* 820F6A40h */ case   16:  		/* mr R3, R31 */
		/* 820F6A40h case   16:*/		regs.R3 = regs.R31;
		/* 820F6A40h case   16:*/		return 0x820F6A44;
		  /* 820F6A44h */ case   17:  		/* bl -37180 */
		/* 820F6A44h case   17:*/		regs.LR = 0x820F6A48; return 0x820ED908;
		/* 820F6A44h case   17:*/		return 0x820F6A48;
		  /* 820F6A48h */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 820F6A48h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6A48h case   18:*/		return 0x820F6A4C;
		  /* 820F6A4Ch */ case   19:  		/* bc 12, CR0_LT, 8 */
		/* 820F6A4Ch case   19:*/		if ( regs.CR[0].lt ) { return 0x820F6A54;  }
		/* 820F6A4Ch case   19:*/		return 0x820F6A50;
		  /* 820F6A50h */ case   20:  		/* li R3, 0 */
		/* 820F6A50h case   20:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F6A50h case   20:*/		return 0x820F6A54;
	}
	return 0x820F6A54;
} // Block from 820F6A00h-820F6A54h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820F6A54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6A54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6A54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6A54);
		  /* 820F6A54h */ case    0:  		/* addi R1, R1, 96 */
		/* 820F6A54h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820F6A54h case    0:*/		return 0x820F6A58;
		  /* 820F6A58h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820F6A58h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F6A58h case    1:*/		return 0x820F6A5C;
		  /* 820F6A5Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820F6A5Ch case    2:*/		regs.LR = regs.R12;
		/* 820F6A5Ch case    2:*/		return 0x820F6A60;
		  /* 820F6A60h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820F6A60h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F6A60h case    3:*/		return 0x820F6A64;
		  /* 820F6A64h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820F6A64h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F6A64h case    4:*/		return 0x820F6A68;
	}
	return 0x820F6A68;
} // Block from 820F6A54h-820F6A68h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F6A68h
// Function '?EmitSrc@CShaderProgram@D3DXShader@@MAAJKKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6A68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6A68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6A68);
		  /* 820F6A68h */ case    0:  		/* mfspr R12, LR */
		/* 820F6A68h case    0:*/		regs.R12 = regs.LR;
		/* 820F6A68h case    0:*/		return 0x820F6A6C;
		  /* 820F6A6Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820F6A6Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F6A6Ch case    1:*/		return 0x820F6A70;
		  /* 820F6A70h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820F6A70h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F6A70h case    2:*/		return 0x820F6A74;
		  /* 820F6A74h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820F6A74h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820F6A74h case    3:*/		return 0x820F6A78;
		  /* 820F6A78h */ case    4:  		/* li R4, 29 */
		/* 820F6A78h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1D);
		/* 820F6A78h case    4:*/		return 0x820F6A7C;
		  /* 820F6A7Ch */ case    5:  		/* mr R31, R3 */
		/* 820F6A7Ch case    5:*/		regs.R31 = regs.R3;
		/* 820F6A7Ch case    5:*/		return 0x820F6A80;
		  /* 820F6A80h */ case    6:  		/* bl -2448 */
		/* 820F6A80h case    6:*/		regs.LR = 0x820F6A84; return 0x820F60F0;
		/* 820F6A80h case    6:*/		return 0x820F6A84;
		  /* 820F6A84h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820F6A84h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6A84h case    7:*/		return 0x820F6A88;
		  /* 820F6A88h */ case    8:  		/* bc 12, CR0_LT, 52 */
		/* 820F6A88h case    8:*/		if ( regs.CR[0].lt ) { return 0x820F6ABC;  }
		/* 820F6A88h case    8:*/		return 0x820F6A8C;
		  /* 820F6A8Ch */ case    9:  		/* lwz R11, <#[R31]> */
		/* 820F6A8Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6A8Ch case    9:*/		return 0x820F6A90;
		  /* 820F6A90h */ case   10:  		/* mr R3, R31 */
		/* 820F6A90h case   10:*/		regs.R3 = regs.R31;
		/* 820F6A90h case   10:*/		return 0x820F6A94;
		  /* 820F6A94h */ case   11:  		/* lwz R11, <#[R11 + 308]> */
		/* 820F6A94h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000134) );
		/* 820F6A94h case   11:*/		return 0x820F6A98;
		  /* 820F6A98h */ case   12:  		/* mtspr CTR, R11 */
		/* 820F6A98h case   12:*/		regs.CTR = regs.R11;
		/* 820F6A98h case   12:*/		return 0x820F6A9C;
		  /* 820F6A9Ch */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 820F6A9Ch case   13:*/		if ( 1 ) { regs.LR = 0x820F6AA0; return (uint32)regs.CTR; }
		/* 820F6A9Ch case   13:*/		return 0x820F6AA0;
		  /* 820F6AA0h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 820F6AA0h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6AA0h case   14:*/		return 0x820F6AA4;
		  /* 820F6AA4h */ case   15:  		/* bc 12, CR0_LT, 24 */
		/* 820F6AA4h case   15:*/		if ( regs.CR[0].lt ) { return 0x820F6ABC;  }
		/* 820F6AA4h case   15:*/		return 0x820F6AA8;
		  /* 820F6AA8h */ case   16:  		/* mr R3, R31 */
		/* 820F6AA8h case   16:*/		regs.R3 = regs.R31;
		/* 820F6AA8h case   16:*/		return 0x820F6AAC;
		  /* 820F6AACh */ case   17:  		/* bl -37284 */
		/* 820F6AACh case   17:*/		regs.LR = 0x820F6AB0; return 0x820ED908;
		/* 820F6AACh case   17:*/		return 0x820F6AB0;
		  /* 820F6AB0h */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 820F6AB0h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6AB0h case   18:*/		return 0x820F6AB4;
		  /* 820F6AB4h */ case   19:  		/* bc 12, CR0_LT, 8 */
		/* 820F6AB4h case   19:*/		if ( regs.CR[0].lt ) { return 0x820F6ABC;  }
		/* 820F6AB4h case   19:*/		return 0x820F6AB8;
		  /* 820F6AB8h */ case   20:  		/* li R3, 0 */
		/* 820F6AB8h case   20:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F6AB8h case   20:*/		return 0x820F6ABC;
	}
	return 0x820F6ABC;
} // Block from 820F6A68h-820F6ABCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 820F6ABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6ABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6ABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6ABC);
		  /* 820F6ABCh */ case    0:  		/* addi R1, R1, 96 */
		/* 820F6ABCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820F6ABCh case    0:*/		return 0x820F6AC0;
		  /* 820F6AC0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820F6AC0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F6AC0h case    1:*/		return 0x820F6AC4;
		  /* 820F6AC4h */ case    2:  		/* mtspr LR, R12 */
		/* 820F6AC4h case    2:*/		regs.LR = regs.R12;
		/* 820F6AC4h case    2:*/		return 0x820F6AC8;
		  /* 820F6AC8h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820F6AC8h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F6AC8h case    3:*/		return 0x820F6ACC;
		  /* 820F6ACCh */ case    4:  		/* bclr 20, CR0_LT */
		/* 820F6ACCh case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F6ACCh case    4:*/		return 0x820F6AD0;
	}
	return 0x820F6AD0;
} // Block from 820F6ABCh-820F6AD0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F6AD0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6AD0);
		  /* 820F6AD0h */ case    0:  		/* mfspr R12, LR */
		/* 820F6AD0h case    0:*/		regs.R12 = regs.LR;
		/* 820F6AD0h case    0:*/		return 0x820F6AD4;
		  /* 820F6AD4h */ case    1:  		/* bl -415864 */
		/* 820F6AD4h case    1:*/		regs.LR = 0x820F6AD8; return 0x8209125C;
		/* 820F6AD4h case    1:*/		return 0x820F6AD8;
		  /* 820F6AD8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820F6AD8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820F6AD8h case    2:*/		return 0x820F6ADC;
		  /* 820F6ADCh */ case    3:  		/* lwz R11, <#[R3 + 260]> */
		/* 820F6ADCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000104) );
		/* 820F6ADCh case    3:*/		return 0x820F6AE0;
		  /* 820F6AE0h */ case    4:  		/* lis R9, 29744 */
		/* 820F6AE0h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0x7430);
		/* 820F6AE0h case    4:*/		return 0x820F6AE4;
		  /* 820F6AE4h */ case    5:  		/* mr R31, R3 */
		/* 820F6AE4h case    5:*/		regs.R31 = regs.R3;
		/* 820F6AE4h case    5:*/		return 0x820F6AE8;
		  /* 820F6AE8h */ case    6:  		/* li R10, 0 */
		/* 820F6AE8h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820F6AE8h case    6:*/		return 0x820F6AEC;
		  /* 820F6AECh */ case    7:  		/* lwz R8, <#[R11]> */
		/* 820F6AECh case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820F6AECh case    7:*/		return 0x820F6AF0;
		  /* 820F6AF0h */ case    8:  		/* rlwinm R11, R8, 0, 0, 11 */
		/* 820F6AF0h case    8:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R8);
		/* 820F6AF0h case    8:*/		return 0x820F6AF4;
		  /* 820F6AF4h */ case    9:  		/* rlwinm R29, R8, 0, 12, 31 */
		/* 820F6AF4h case    9:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R29,regs.R8);
		/* 820F6AF4h case    9:*/		return 0x820F6AF8;
		  /* 820F6AF8h */ case   10:  		/* cmplw CR6, R11, R9 */
		/* 820F6AF8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F6AF8h case   10:*/		return 0x820F6AFC;
		  /* 820F6AFCh */ case   11:  		/* bc 12, CR6_EQ, 464 */
		/* 820F6AFCh case   11:*/		if ( regs.CR[6].eq ) { return 0x820F6CCC;  }
		/* 820F6AFCh case   11:*/		return 0x820F6B00;
	}
	return 0x820F6B00;
} // Block from 820F6AD0h-820F6B00h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820F6B00h
// Function '?EmitInstComplex@CShaderProgram@D3DXShader@@IAAJKPAII000IKKKH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6B00);
		  /* 820F6B00h */ case    0:  		/* lis R9, 29760 */
		/* 820F6B00h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0x7440);
		/* 820F6B00h case    0:*/		return 0x820F6B04;
		  /* 820F6B04h */ case    1:  		/* cmplw CR6, R11, R9 */
		/* 820F6B04h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F6B04h case    1:*/		return 0x820F6B08;
		  /* 820F6B08h */ case    2:  		/* bc 12, CR6_EQ, 64 */
		/* 820F6B08h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F6B48;  }
		/* 820F6B08h case    2:*/		return 0x820F6B0C;
		  /* 820F6B0Ch */ case    3:  		/* lis R9, 29776 */
		/* 820F6B0Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0x7450);
		/* 820F6B0Ch case    3:*/		return 0x820F6B10;
		  /* 820F6B10h */ case    4:  		/* cmplw CR6, R11, R9 */
		/* 820F6B10h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F6B10h case    4:*/		return 0x820F6B14;
		  /* 820F6B14h */ case    5:  		/* bc 12, CR6_EQ, 44 */
		/* 820F6B14h case    5:*/		if ( regs.CR[6].eq ) { return 0x820F6B40;  }
		/* 820F6B14h case    5:*/		return 0x820F6B18;
		  /* 820F6B18h */ case    6:  		/* lis R9, 29792 */
		/* 820F6B18h case    6:*/		cpu::op::lis<0>(regs,&regs.R9,0x7460);
		/* 820F6B18h case    6:*/		return 0x820F6B1C;
		  /* 820F6B1Ch */ case    7:  		/* cmplw CR6, R11, R9 */
		/* 820F6B1Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F6B1Ch case    7:*/		return 0x820F6B20;
		  /* 820F6B20h */ case    8:  		/* bc 12, CR6_EQ, 24 */
		/* 820F6B20h case    8:*/		if ( regs.CR[6].eq ) { return 0x820F6B38;  }
		/* 820F6B20h case    8:*/		return 0x820F6B24;
		  /* 820F6B24h */ case    9:  		/* lis R9, 29808 */
		/* 820F6B24h case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0x7470);
		/* 820F6B24h case    9:*/		return 0x820F6B28;
		  /* 820F6B28h */ case   10:  		/* cmplw CR6, R11, R9 */
		/* 820F6B28h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F6B28h case   10:*/		return 0x820F6B2C;
		  /* 820F6B2Ch */ case   11:  		/* bc 4, CR6_EQ, 32 */
		/* 820F6B2Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x820F6B4C;  }
		/* 820F6B2Ch case   11:*/		return 0x820F6B30;
		  /* 820F6B30h */ case   12:  		/* li R10, 3 */
		/* 820F6B30h case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 820F6B30h case   12:*/		return 0x820F6B34;
		  /* 820F6B34h */ case   13:  		/* b 24 */
		/* 820F6B34h case   13:*/		return 0x820F6B4C;
		/* 820F6B34h case   13:*/		return 0x820F6B38;
	}
	return 0x820F6B38;
} // Block from 820F6B00h-820F6B38h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820F6B38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6B38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6B38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6B38);
		  /* 820F6B38h */ case    0:  		/* li R10, 4 */
		/* 820F6B38h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 820F6B38h case    0:*/		return 0x820F6B3C;
		  /* 820F6B3Ch */ case    1:  		/* b 16 */
		/* 820F6B3Ch case    1:*/		return 0x820F6B4C;
		/* 820F6B3Ch case    1:*/		return 0x820F6B40;
	}
	return 0x820F6B40;
} // Block from 820F6B38h-820F6B40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F6B40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6B40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6B40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6B40);
		  /* 820F6B40h */ case    0:  		/* li R10, 2 */
		/* 820F6B40h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 820F6B40h case    0:*/		return 0x820F6B44;
		  /* 820F6B44h */ case    1:  		/* b 8 */
		/* 820F6B44h case    1:*/		return 0x820F6B4C;
		/* 820F6B44h case    1:*/		return 0x820F6B48;
	}
	return 0x820F6B48;
} // Block from 820F6B40h-820F6B48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F6B48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6B48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6B48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6B48);
		  /* 820F6B48h */ case    0:  		/* li R10, 5 */
		/* 820F6B48h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 820F6B48h case    0:*/		return 0x820F6B4C;
	}
	return 0x820F6B4C;
} // Block from 820F6B48h-820F6B4Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F6B4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6B4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6B4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6B4C);
		  /* 820F6B4Ch */ case    0:  		/* li R4, 45 */
		/* 820F6B4Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x2D);
		/* 820F6B4Ch case    0:*/		return 0x820F6B50;
		  /* 820F6B50h */ case    1:  		/* mr R3, R31 */
		/* 820F6B50h case    1:*/		regs.R3 = regs.R31;
		/* 820F6B50h case    1:*/		return 0x820F6B54;
		  /* 820F6B54h */ case    2:  		/* rlwimi R4, R10, 16, 0, 15 */
		/* 820F6B54h case    2:*/		cpu::op::rlwimi<0,16,0,15>(regs,&regs.R4,regs.R10);
		/* 820F6B54h case    2:*/		return 0x820F6B58;
		  /* 820F6B58h */ case    3:  		/* bl -2664 */
		/* 820F6B58h case    3:*/		regs.LR = 0x820F6B5C; return 0x820F60F0;
		/* 820F6B58h case    3:*/		return 0x820F6B5C;
		  /* 820F6B5Ch */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820F6B5Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6B5Ch case    4:*/		return 0x820F6B60;
		  /* 820F6B60h */ case    5:  		/* bc 12, CR0_LT, 356 */
		/* 820F6B60h case    5:*/		if ( regs.CR[0].lt ) { return 0x820F6CC4;  }
		/* 820F6B60h case    5:*/		return 0x820F6B64;
		  /* 820F6B64h */ case    6:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F6B64h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F6B64h case    6:*/		return 0x820F6B68;
		  /* 820F6B68h */ case    7:  		/* addi R6, R1, 80 */
		/* 820F6B68h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 820F6B68h case    7:*/		return 0x820F6B6C;
		  /* 820F6B6Ch */ case    8:  		/* lwz R10, <#[R31]> */
		/* 820F6B6Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6B6Ch case    8:*/		return 0x820F6B70;
		  /* 820F6B70h */ case    9:  		/* addi R5, R1, 88 */
		/* 820F6B70h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 820F6B70h case    9:*/		return 0x820F6B74;
		  /* 820F6B74h */ case   10:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F6B74h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F6B74h case   10:*/		return 0x820F6B78;
		  /* 820F6B78h */ case   11:  		/* mr R3, R31 */
		/* 820F6B78h case   11:*/		regs.R3 = regs.R31;
		/* 820F6B78h case   11:*/		return 0x820F6B7C;
		  /* 820F6B7Ch */ case   12:  		/* lwz R11, <#[R11 + 8]> */
		/* 820F6B7Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820F6B7Ch case   12:*/		return 0x820F6B80;
		  /* 820F6B80h */ case   13:  		/* lwz R10, <#[R10 + 328]> */
		/* 820F6B80h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000148) );
		/* 820F6B80h case   13:*/		return 0x820F6B84;
		  /* 820F6B84h */ case   14:  		/* lwz R11, <#[R11]> */
		/* 820F6B84h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F6B84h case   14:*/		return 0x820F6B88;
		  /* 820F6B88h */ case   15:  		/* mtspr CTR, R10 */
		/* 820F6B88h case   15:*/		regs.CTR = regs.R10;
		/* 820F6B88h case   15:*/		return 0x820F6B8C;
		  /* 820F6B8Ch */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F6B8Ch case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F6B8Ch case   16:*/		return 0x820F6B90;
		  /* 820F6B90h */ case   17:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F6B90h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F6B90h case   17:*/		return 0x820F6B94;
		  /* 820F6B94h */ case   18:  		/* bcctrl 20, CR0_LT */
		/* 820F6B94h case   18:*/		if ( 1 ) { regs.LR = 0x820F6B98; return (uint32)regs.CTR; }
		/* 820F6B94h case   18:*/		return 0x820F6B98;
		  /* 820F6B98h */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 820F6B98h case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6B98h case   19:*/		return 0x820F6B9C;
		  /* 820F6B9Ch */ case   20:  		/* bc 12, CR0_LT, 296 */
		/* 820F6B9Ch case   20:*/		if ( regs.CR[0].lt ) { return 0x820F6CC4;  }
		/* 820F6B9Ch case   20:*/		return 0x820F6BA0;
		  /* 820F6BA0h */ case   21:  		/* lwz R11, <#[R31]> */
		/* 820F6BA0h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6BA0h case   21:*/		return 0x820F6BA4;
		  /* 820F6BA4h */ case   22:  		/* addi R7, R1, 84 */
		/* 820F6BA4h case   22:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x54);
		/* 820F6BA4h case   22:*/		return 0x820F6BA8;
		  /* 820F6BA8h */ case   23:  		/* lwz R10, <#[R31 + 260]> */
		/* 820F6BA8h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000104) );
		/* 820F6BA8h case   23:*/		return 0x820F6BAC;
		  /* 820F6BACh */ case   24:  		/* lis R6, 15 */
		/* 820F6BACh case   24:*/		cpu::op::lis<0>(regs,&regs.R6,0xF);
		/* 820F6BACh case   24:*/		return 0x820F6BB0;
		  /* 820F6BB0h */ case   25:  		/* mr R5, R29 */
		/* 820F6BB0h case   25:*/		regs.R5 = regs.R29;
		/* 820F6BB0h case   25:*/		return 0x820F6BB4;
		  /* 820F6BB4h */ case   26:  		/* mr R3, R31 */
		/* 820F6BB4h case   26:*/		regs.R3 = regs.R31;
		/* 820F6BB4h case   26:*/		return 0x820F6BB8;
		  /* 820F6BB8h */ case   27:  		/* lwz R11, <#[R11 + 332]> */
		/* 820F6BB8h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000014C) );
		/* 820F6BB8h case   27:*/		return 0x820F6BBC;
		  /* 820F6BBCh */ case   28:  		/* lwz R4, <#[R10 + 8]> */
		/* 820F6BBCh case   28:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000008) );
		/* 820F6BBCh case   28:*/		return 0x820F6BC0;
		  /* 820F6BC0h */ case   29:  		/* mtspr CTR, R11 */
		/* 820F6BC0h case   29:*/		regs.CTR = regs.R11;
		/* 820F6BC0h case   29:*/		return 0x820F6BC4;
		  /* 820F6BC4h */ case   30:  		/* bcctrl 20, CR0_LT */
		/* 820F6BC4h case   30:*/		if ( 1 ) { regs.LR = 0x820F6BC8; return (uint32)regs.CTR; }
		/* 820F6BC4h case   30:*/		return 0x820F6BC8;
		  /* 820F6BC8h */ case   31:  		/* cmpwi CR0, R3, 0 */
		/* 820F6BC8h case   31:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6BC8h case   31:*/		return 0x820F6BCC;
		  /* 820F6BCCh */ case   32:  		/* bc 12, CR0_LT, 248 */
		/* 820F6BCCh case   32:*/		if ( regs.CR[0].lt ) { return 0x820F6CC4;  }
		/* 820F6BCCh case   32:*/		return 0x820F6BD0;
		  /* 820F6BD0h */ case   33:  		/* lwz R11, <#[R31]> */
		/* 820F6BD0h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6BD0h case   33:*/		return 0x820F6BD4;
		  /* 820F6BD4h */ case   34:  		/* mr R3, R31 */
		/* 820F6BD4h case   34:*/		regs.R3 = regs.R31;
		/* 820F6BD4h case   34:*/		return 0x820F6BD8;
		  /* 820F6BD8h */ case   35:  		/* lwz R6, <#[R1 + 80]> */
		/* 820F6BD8h case   35:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 820F6BD8h case   35:*/		return 0x820F6BDC;
		  /* 820F6BDCh */ case   36:  		/* lwz R5, <#[R1 + 84]> */
		/* 820F6BDCh case   36:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 820F6BDCh case   36:*/		return 0x820F6BE0;
		  /* 820F6BE0h */ case   37:  		/* lwz R4, <#[R1 + 88]> */
		/* 820F6BE0h case   37:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000058) );
		/* 820F6BE0h case   37:*/		return 0x820F6BE4;
		  /* 820F6BE4h */ case   38:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F6BE4h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F6BE4h case   38:*/		return 0x820F6BE8;
		  /* 820F6BE8h */ case   39:  		/* mtspr CTR, R11 */
		/* 820F6BE8h case   39:*/		regs.CTR = regs.R11;
		/* 820F6BE8h case   39:*/		return 0x820F6BEC;
		  /* 820F6BECh */ case   40:  		/* bcctrl 20, CR0_LT */
		/* 820F6BECh case   40:*/		if ( 1 ) { regs.LR = 0x820F6BF0; return (uint32)regs.CTR; }
		/* 820F6BECh case   40:*/		return 0x820F6BF0;
		  /* 820F6BF0h */ case   41:  		/* cmpwi CR0, R3, 0 */
		/* 820F6BF0h case   41:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6BF0h case   41:*/		return 0x820F6BF4;
		  /* 820F6BF4h */ case   42:  		/* bc 12, CR0_LT, 208 */
		/* 820F6BF4h case   42:*/		if ( regs.CR[0].lt ) { return 0x820F6CC4;  }
		/* 820F6BF4h case   42:*/		return 0x820F6BF8;
		  /* 820F6BF8h */ case   43:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F6BF8h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F6BF8h case   43:*/		return 0x820F6BFC;
		  /* 820F6BFCh */ case   44:  		/* rlwinm R30, R29, 2, 0, 29 */
		/* 820F6BFCh case   44:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R29);
		/* 820F6BFCh case   44:*/		return 0x820F6C00;
		  /* 820F6C00h */ case   45:  		/* lwz R10, <#[R31]> */
		/* 820F6C00h case   45:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6C00h case   45:*/		return 0x820F6C04;
		  /* 820F6C04h */ case   46:  		/* addi R6, R1, 80 */
		/* 820F6C04h case   46:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 820F6C04h case   46:*/		return 0x820F6C08;
		  /* 820F6C08h */ case   47:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F6C08h case   47:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F6C08h case   47:*/		return 0x820F6C0C;
		  /* 820F6C0Ch */ case   48:  		/* addi R5, R1, 88 */
		/* 820F6C0Ch case   48:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 820F6C0Ch case   48:*/		return 0x820F6C10;
		  /* 820F6C10h */ case   49:  		/* mr R3, R31 */
		/* 820F6C10h case   49:*/		regs.R3 = regs.R31;
		/* 820F6C10h case   49:*/		return 0x820F6C14;
		  /* 820F6C14h */ case   50:  		/* lwz R11, <#[R11 + 8]> */
		/* 820F6C14h case   50:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820F6C14h case   50:*/		return 0x820F6C18;
		  /* 820F6C18h */ case   51:  		/* lwz R10, <#[R10 + 328]> */
		/* 820F6C18h case   51:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000148) );
		/* 820F6C18h case   51:*/		return 0x820F6C1C;
		  /* 820F6C1Ch */ case   52:  		/* lwzx R11, <#[R11 + R30]> */
		/* 820F6C1Ch case   52:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820F6C1Ch case   52:*/		return 0x820F6C20;
		  /* 820F6C20h */ case   53:  		/* mtspr CTR, R10 */
		/* 820F6C20h case   53:*/		regs.CTR = regs.R10;
		/* 820F6C20h case   53:*/		return 0x820F6C24;
		  /* 820F6C24h */ case   54:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F6C24h case   54:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F6C24h case   54:*/		return 0x820F6C28;
		  /* 820F6C28h */ case   55:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F6C28h case   55:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F6C28h case   55:*/		return 0x820F6C2C;
		  /* 820F6C2Ch */ case   56:  		/* bcctrl 20, CR0_LT */
		/* 820F6C2Ch case   56:*/		if ( 1 ) { regs.LR = 0x820F6C30; return (uint32)regs.CTR; }
		/* 820F6C2Ch case   56:*/		return 0x820F6C30;
		  /* 820F6C30h */ case   57:  		/* cmpwi CR0, R3, 0 */
		/* 820F6C30h case   57:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6C30h case   57:*/		return 0x820F6C34;
		  /* 820F6C34h */ case   58:  		/* bc 12, CR0_LT, 144 */
		/* 820F6C34h case   58:*/		if ( regs.CR[0].lt ) { return 0x820F6CC4;  }
		/* 820F6C34h case   58:*/		return 0x820F6C38;
		  /* 820F6C38h */ case   59:  		/* lwz R11, <#[R31]> */
		/* 820F6C38h case   59:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6C38h case   59:*/		return 0x820F6C3C;
		  /* 820F6C3Ch */ case   60:  		/* addi R7, R1, 84 */
		/* 820F6C3Ch case   60:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x54);
		/* 820F6C3Ch case   60:*/		return 0x820F6C40;
		  /* 820F6C40h */ case   61:  		/* lwz R10, <#[R31 + 260]> */
		/* 820F6C40h case   61:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000104) );
		/* 820F6C40h case   61:*/		return 0x820F6C44;
		  /* 820F6C44h */ case   62:  		/* lis R6, 15 */
		/* 820F6C44h case   62:*/		cpu::op::lis<0>(regs,&regs.R6,0xF);
		/* 820F6C44h case   62:*/		return 0x820F6C48;
		  /* 820F6C48h */ case   63:  		/* mr R5, R29 */
		/* 820F6C48h case   63:*/		regs.R5 = regs.R29;
		/* 820F6C48h case   63:*/		return 0x820F6C4C;
		  /* 820F6C4Ch */ case   64:  		/* mr R3, R31 */
		/* 820F6C4Ch case   64:*/		regs.R3 = regs.R31;
		/* 820F6C4Ch case   64:*/		return 0x820F6C50;
		  /* 820F6C50h */ case   65:  		/* lwz R9, <#[R11 + 332]> */
		/* 820F6C50h case   65:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000014C) );
		/* 820F6C50h case   65:*/		return 0x820F6C54;
		  /* 820F6C54h */ case   66:  		/* lwz R11, <#[R10 + 8]> */
		/* 820F6C54h case   66:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 820F6C54h case   66:*/		return 0x820F6C58;
		  /* 820F6C58h */ case   67:  		/* add R4, R11, R30 */
		/* 820F6C58h case   67:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R30);
		/* 820F6C58h case   67:*/		return 0x820F6C5C;
		  /* 820F6C5Ch */ case   68:  		/* mtspr CTR, R9 */
		/* 820F6C5Ch case   68:*/		regs.CTR = regs.R9;
		/* 820F6C5Ch case   68:*/		return 0x820F6C60;
		  /* 820F6C60h */ case   69:  		/* bcctrl 20, CR0_LT */
		/* 820F6C60h case   69:*/		if ( 1 ) { regs.LR = 0x820F6C64; return (uint32)regs.CTR; }
		/* 820F6C60h case   69:*/		return 0x820F6C64;
		  /* 820F6C64h */ case   70:  		/* cmpwi CR0, R3, 0 */
		/* 820F6C64h case   70:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6C64h case   70:*/		return 0x820F6C68;
		  /* 820F6C68h */ case   71:  		/* bc 12, CR0_LT, 92 */
		/* 820F6C68h case   71:*/		if ( regs.CR[0].lt ) { return 0x820F6CC4;  }
		/* 820F6C68h case   71:*/		return 0x820F6C6C;
		  /* 820F6C6Ch */ case   72:  		/* lwz R11, <#[R31]> */
		/* 820F6C6Ch case   72:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6C6Ch case   72:*/		return 0x820F6C70;
		  /* 820F6C70h */ case   73:  		/* mr R3, R31 */
		/* 820F6C70h case   73:*/		regs.R3 = regs.R31;
		/* 820F6C70h case   73:*/		return 0x820F6C74;
		  /* 820F6C74h */ case   74:  		/* lwz R6, <#[R1 + 80]> */
		/* 820F6C74h case   74:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 820F6C74h case   74:*/		return 0x820F6C78;
		  /* 820F6C78h */ case   75:  		/* lwz R5, <#[R1 + 84]> */
		/* 820F6C78h case   75:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 820F6C78h case   75:*/		return 0x820F6C7C;
		  /* 820F6C7Ch */ case   76:  		/* lwz R4, <#[R1 + 88]> */
		/* 820F6C7Ch case   76:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000058) );
		/* 820F6C7Ch case   76:*/		return 0x820F6C80;
		  /* 820F6C80h */ case   77:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F6C80h case   77:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F6C80h case   77:*/		return 0x820F6C84;
		  /* 820F6C84h */ case   78:  		/* mtspr CTR, R11 */
		/* 820F6C84h case   78:*/		regs.CTR = regs.R11;
		/* 820F6C84h case   78:*/		return 0x820F6C88;
		  /* 820F6C88h */ case   79:  		/* bcctrl 20, CR0_LT */
		/* 820F6C88h case   79:*/		if ( 1 ) { regs.LR = 0x820F6C8C; return (uint32)regs.CTR; }
		/* 820F6C88h case   79:*/		return 0x820F6C8C;
		  /* 820F6C8Ch */ case   80:  		/* cmpwi CR0, R3, 0 */
		/* 820F6C8Ch case   80:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6C8Ch case   80:*/		return 0x820F6C90;
		  /* 820F6C90h */ case   81:  		/* bc 12, CR0_LT, 52 */
		/* 820F6C90h case   81:*/		if ( regs.CR[0].lt ) { return 0x820F6CC4;  }
		/* 820F6C90h case   81:*/		return 0x820F6C94;
		  /* 820F6C94h */ case   82:  		/* lwz R11, <#[R31]> */
		/* 820F6C94h case   82:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6C94h case   82:*/		return 0x820F6C98;
		  /* 820F6C98h */ case   83:  		/* mr R3, R31 */
		/* 820F6C98h case   83:*/		regs.R3 = regs.R31;
		/* 820F6C98h case   83:*/		return 0x820F6C9C;
		  /* 820F6C9Ch */ case   84:  		/* lwz R11, <#[R11 + 308]> */
		/* 820F6C9Ch case   84:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000134) );
		/* 820F6C9Ch case   84:*/		return 0x820F6CA0;
		  /* 820F6CA0h */ case   85:  		/* mtspr CTR, R11 */
		/* 820F6CA0h case   85:*/		regs.CTR = regs.R11;
		/* 820F6CA0h case   85:*/		return 0x820F6CA4;
		  /* 820F6CA4h */ case   86:  		/* bcctrl 20, CR0_LT */
		/* 820F6CA4h case   86:*/		if ( 1 ) { regs.LR = 0x820F6CA8; return (uint32)regs.CTR; }
		/* 820F6CA4h case   86:*/		return 0x820F6CA8;
		  /* 820F6CA8h */ case   87:  		/* cmpwi CR0, R3, 0 */
		/* 820F6CA8h case   87:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6CA8h case   87:*/		return 0x820F6CAC;
		  /* 820F6CACh */ case   88:  		/* bc 12, CR0_LT, 24 */
		/* 820F6CACh case   88:*/		if ( regs.CR[0].lt ) { return 0x820F6CC4;  }
		/* 820F6CACh case   88:*/		return 0x820F6CB0;
		  /* 820F6CB0h */ case   89:  		/* mr R3, R31 */
		/* 820F6CB0h case   89:*/		regs.R3 = regs.R31;
		/* 820F6CB0h case   89:*/		return 0x820F6CB4;
		  /* 820F6CB4h */ case   90:  		/* bl -37804 */
		/* 820F6CB4h case   90:*/		regs.LR = 0x820F6CB8; return 0x820ED908;
		/* 820F6CB4h case   90:*/		return 0x820F6CB8;
		  /* 820F6CB8h */ case   91:  		/* cmpwi CR0, R3, 0 */
		/* 820F6CB8h case   91:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6CB8h case   91:*/		return 0x820F6CBC;
		  /* 820F6CBCh */ case   92:  		/* bc 12, CR0_LT, 8 */
		/* 820F6CBCh case   92:*/		if ( regs.CR[0].lt ) { return 0x820F6CC4;  }
		/* 820F6CBCh case   92:*/		return 0x820F6CC0;
		  /* 820F6CC0h */ case   93:  		/* li R3, 0 */
		/* 820F6CC0h case   93:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F6CC0h case   93:*/		return 0x820F6CC4;
	}
	return 0x820F6CC4;
} // Block from 820F6B4Ch-820F6CC4h (94 instructions)

//////////////////////////////////////////////////////
// Block at 820F6CC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6CC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6CC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6CC4);
		  /* 820F6CC4h */ case    0:  		/* addi R1, R1, 128 */
		/* 820F6CC4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820F6CC4h case    0:*/		return 0x820F6CC8;
		  /* 820F6CC8h */ case    1:  		/* b -416284 */
		/* 820F6CC8h case    1:*/		return 0x820912AC;
		/* 820F6CC8h case    1:*/		return 0x820F6CCC;
	}
	return 0x820F6CCC;
} // Block from 820F6CC4h-820F6CCCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F6CCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6CCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6CCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6CCC);
		  /* 820F6CCCh */ case    0:  		/* li R4, 44 */
		/* 820F6CCCh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x2C);
		/* 820F6CCCh case    0:*/		return 0x820F6CD0;
		  /* 820F6CD0h */ case    1:  		/* mr R3, R31 */
		/* 820F6CD0h case    1:*/		regs.R3 = regs.R31;
		/* 820F6CD0h case    1:*/		return 0x820F6CD4;
		  /* 820F6CD4h */ case    2:  		/* bl -3044 */
		/* 820F6CD4h case    2:*/		regs.LR = 0x820F6CD8; return 0x820F60F0;
		/* 820F6CD4h case    2:*/		return 0x820F6CD8;
		  /* 820F6CD8h */ case    3:  		/* b -76 */
		/* 820F6CD8h case    3:*/		return 0x820F6C8C;
		/* 820F6CD8h case    3:*/		return 0x820F6CDC;
		  /* 820F6CDCh */ case    4:  		/* nop */
		/* 820F6CDCh case    4:*/		cpu::op::nop();
		/* 820F6CDCh case    4:*/		return 0x820F6CE0;
	}
	return 0x820F6CE0;
} // Block from 820F6CCCh-820F6CE0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F6CE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6CE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6CE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6CE0);
		  /* 820F6CE0h */ case    0:  		/* mfspr R12, LR */
		/* 820F6CE0h case    0:*/		regs.R12 = regs.LR;
		/* 820F6CE0h case    0:*/		return 0x820F6CE4;
		  /* 820F6CE4h */ case    1:  		/* bl -416396 */
		/* 820F6CE4h case    1:*/		regs.LR = 0x820F6CE8; return 0x82091258;
		/* 820F6CE4h case    1:*/		return 0x820F6CE8;
		  /* 820F6CE8h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820F6CE8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820F6CE8h case    2:*/		return 0x820F6CEC;
		  /* 820F6CECh */ case    3:  		/* mr R31, R3 */
		/* 820F6CECh case    3:*/		regs.R31 = regs.R3;
		/* 820F6CECh case    3:*/		return 0x820F6CF0;
		  /* 820F6CF0h */ case    4:  		/* lwz R3, <#[R3 + 260]> */
		/* 820F6CF0h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000104) );
		/* 820F6CF0h case    4:*/		return 0x820F6CF4;
		  /* 820F6CF4h */ case    5:  		/* addi R5, R1, 112 */
		/* 820F6CF4h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820F6CF4h case    5:*/		return 0x820F6CF8;
		  /* 820F6CF8h */ case    6:  		/* li R4, 0 */
		/* 820F6CF8h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F6CF8h case    6:*/		return 0x820F6CFC;
		  /* 820F6CFCh */ case    7:  		/* lwz R11, <#[R3]> */
		/* 820F6CFCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F6CFCh case    7:*/		return 0x820F6D00;
		  /* 820F6D00h */ case    8:  		/* lwz R30, <#[R3 + 12]> */
		/* 820F6D00h case    8:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x0000000C) );
		/* 820F6D00h case    8:*/		return 0x820F6D04;
		  /* 820F6D04h */ case    9:  		/* lwz R29, <#[R3 + 16]> */
		/* 820F6D04h case    9:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000010) );
		/* 820F6D04h case    9:*/		return 0x820F6D08;
		  /* 820F6D08h */ case   10:  		/* rlwinm R28, R11, 0, 12, 31 */
		/* 820F6D08h case   10:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R28,regs.R11);
		/* 820F6D08h case   10:*/		return 0x820F6D0C;
		  /* 820F6D0Ch */ case   11:  		/* bl 21004 */
		/* 820F6D0Ch case   11:*/		regs.LR = 0x820F6D10; return 0x820FBF18;
		/* 820F6D0Ch case   11:*/		return 0x820F6D10;
		  /* 820F6D10h */ case   12:  		/* addi R5, R1, 116 */
		/* 820F6D10h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x74);
		/* 820F6D10h case   12:*/		return 0x820F6D14;
		  /* 820F6D14h */ case   13:  		/* li R4, 1 */
		/* 820F6D14h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820F6D14h case   13:*/		return 0x820F6D18;
		  /* 820F6D18h */ case   14:  		/* lwz R3, <#[R31 + 260]> */
		/* 820F6D18h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000104) );
		/* 820F6D18h case   14:*/		return 0x820F6D1C;
		  /* 820F6D1Ch */ case   15:  		/* bl 20988 */
		/* 820F6D1Ch case   15:*/		regs.LR = 0x820F6D20; return 0x820FBF18;
		/* 820F6D1Ch case   15:*/		return 0x820F6D20;
		  /* 820F6D20h */ case   16:  		/* li R11, 0 */
		/* 820F6D20h case   16:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F6D20h case   16:*/		return 0x820F6D24;
		  /* 820F6D24h */ case   17:  		/* mr R10, R28 */
		/* 820F6D24h case   17:*/		regs.R10 = regs.R28;
		/* 820F6D24h case   17:*/		return 0x820F6D28;
		  /* 820F6D28h */ case   18:  		/* lwz R8, <#[R1 + 112]> */
		/* 820F6D28h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000070) );
		/* 820F6D28h case   18:*/		return 0x820F6D2C;
		  /* 820F6D2Ch */ case   19:  		/* li R9, 0 */
		/* 820F6D2Ch case   19:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F6D2Ch case   19:*/		return 0x820F6D30;
		  /* 820F6D30h */ case   20:  		/* lwz R7, <#[R1 + 116]> */
		/* 820F6D30h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000074) );
		/* 820F6D30h case   20:*/		return 0x820F6D34;
		  /* 820F6D34h */ case   21:  		/* mr R6, R30 */
		/* 820F6D34h case   21:*/		regs.R6 = regs.R30;
		/* 820F6D34h case   21:*/		return 0x820F6D38;
		  /* 820F6D38h */ case   22:  		/* stw R11, <#[R1 + 108]> */
		/* 820F6D38h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 820F6D38h case   22:*/		return 0x820F6D3C;
		  /* 820F6D3Ch */ case   23:  		/* mr R5, R29 */
		/* 820F6D3Ch case   23:*/		regs.R5 = regs.R29;
		/* 820F6D3Ch case   23:*/		return 0x820F6D40;
		  /* 820F6D40h */ case   24:  		/* stw R11, <#[R1 + 100]> */
		/* 820F6D40h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 820F6D40h case   24:*/		return 0x820F6D44;
		  /* 820F6D44h */ case   25:  		/* li R4, 66 */
		/* 820F6D44h case   25:*/		cpu::op::li<0>(regs,&regs.R4,0x42);
		/* 820F6D44h case   25:*/		return 0x820F6D48;
		  /* 820F6D48h */ case   26:  		/* stw R11, <#[R1 + 92]> */
		/* 820F6D48h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F6D48h case   26:*/		return 0x820F6D4C;
		  /* 820F6D4Ch */ case   27:  		/* mr R3, R31 */
		/* 820F6D4Ch case   27:*/		regs.R3 = regs.R31;
		/* 820F6D4Ch case   27:*/		return 0x820F6D50;
		  /* 820F6D50h */ case   28:  		/* stw R11, <#[R1 + 84]> */
		/* 820F6D50h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820F6D50h case   28:*/		return 0x820F6D54;
		  /* 820F6D54h */ case   29:  		/* bl -2548 */
		/* 820F6D54h case   29:*/		regs.LR = 0x820F6D58; return 0x820F6360;
		/* 820F6D54h case   29:*/		return 0x820F6D58;
		  /* 820F6D58h */ case   30:  		/* addi R1, R1, 160 */
		/* 820F6D58h case   30:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820F6D58h case   30:*/		return 0x820F6D5C;
		  /* 820F6D5Ch */ case   31:  		/* b -416436 */
		/* 820F6D5Ch case   31:*/		return 0x820912A8;
		/* 820F6D5Ch case   31:*/		return 0x820F6D60;
	}
	return 0x820F6D60;
} // Block from 820F6CE0h-820F6D60h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820F6D60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6D60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6D60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6D60);
		  /* 820F6D60h */ case    0:  		/* mfspr R12, LR */
		/* 820F6D60h case    0:*/		regs.R12 = regs.LR;
		/* 820F6D60h case    0:*/		return 0x820F6D64;
		  /* 820F6D64h */ case    1:  		/* bl -416524 */
		/* 820F6D64h case    1:*/		regs.LR = 0x820F6D68; return 0x82091258;
		/* 820F6D64h case    1:*/		return 0x820F6D68;
		  /* 820F6D68h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820F6D68h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820F6D68h case    2:*/		return 0x820F6D6C;
		  /* 820F6D6Ch */ case    3:  		/* mr R31, R3 */
		/* 820F6D6Ch case    3:*/		regs.R31 = regs.R3;
		/* 820F6D6Ch case    3:*/		return 0x820F6D70;
		  /* 820F6D70h */ case    4:  		/* lwz R3, <#[R3 + 260]> */
		/* 820F6D70h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000104) );
		/* 820F6D70h case    4:*/		return 0x820F6D74;
		  /* 820F6D74h */ case    5:  		/* addi R5, R1, 100 */
		/* 820F6D74h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x64);
		/* 820F6D74h case    5:*/		return 0x820F6D78;
		  /* 820F6D78h */ case    6:  		/* li R4, 0 */
		/* 820F6D78h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F6D78h case    6:*/		return 0x820F6D7C;
		  /* 820F6D7Ch */ case    7:  		/* lwz R11, <#[R3]> */
		/* 820F6D7Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F6D7Ch case    7:*/		return 0x820F6D80;
		  /* 820F6D80h */ case    8:  		/* lwz R29, <#[R3 + 12]> */
		/* 820F6D80h case    8:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x0000000C) );
		/* 820F6D80h case    8:*/		return 0x820F6D84;
		  /* 820F6D84h */ case    9:  		/* rlwinm R28, R11, 0, 12, 31 */
		/* 820F6D84h case    9:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R28,regs.R11);
		/* 820F6D84h case    9:*/		return 0x820F6D88;
		  /* 820F6D88h */ case   10:  		/* bl 20880 */
		/* 820F6D88h case   10:*/		regs.LR = 0x820F6D8C; return 0x820FBF18;
		/* 820F6D88h case   10:*/		return 0x820F6D8C;
		  /* 820F6D8Ch */ case   11:  		/* addi R5, R1, 96 */
		/* 820F6D8Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 820F6D8Ch case   11:*/		return 0x820F6D90;
		  /* 820F6D90h */ case   12:  		/* lwz R3, <#[R31 + 260]> */
		/* 820F6D90h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000104) );
		/* 820F6D90h case   12:*/		return 0x820F6D94;
		  /* 820F6D94h */ case   13:  		/* li R4, 1 */
		/* 820F6D94h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820F6D94h case   13:*/		return 0x820F6D98;
		  /* 820F6D98h */ case   14:  		/* bl 20864 */
		/* 820F6D98h case   14:*/		regs.LR = 0x820F6D9C; return 0x820FBF18;
		/* 820F6D98h case   14:*/		return 0x820F6D9C;
		  /* 820F6D9Ch */ case   15:  		/* addi R5, R1, 104 */
		/* 820F6D9Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x68);
		/* 820F6D9Ch case   15:*/		return 0x820F6DA0;
		  /* 820F6DA0h */ case   16:  		/* li R4, 2 */
		/* 820F6DA0h case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 820F6DA0h case   16:*/		return 0x820F6DA4;
		  /* 820F6DA4h */ case   17:  		/* lwz R3, <#[R31 + 260]> */
		/* 820F6DA4h case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000104) );
		/* 820F6DA4h case   17:*/		return 0x820F6DA8;
		  /* 820F6DA8h */ case   18:  		/* bl 20848 */
		/* 820F6DA8h case   18:*/		regs.LR = 0x820F6DAC; return 0x820FBF18;
		/* 820F6DA8h case   18:*/		return 0x820F6DAC;
		  /* 820F6DACh */ case   19:  		/* addi R5, R1, 108 */
		/* 820F6DACh case   19:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x6C);
		/* 820F6DACh case   19:*/		return 0x820F6DB0;
		  /* 820F6DB0h */ case   20:  		/* li R4, 3 */
		/* 820F6DB0h case   20:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 820F6DB0h case   20:*/		return 0x820F6DB4;
		  /* 820F6DB4h */ case   21:  		/* lwz R3, <#[R31 + 260]> */
		/* 820F6DB4h case   21:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000104) );
		/* 820F6DB4h case   21:*/		return 0x820F6DB8;
		  /* 820F6DB8h */ case   22:  		/* bl 20832 */
		/* 820F6DB8h case   22:*/		regs.LR = 0x820F6DBC; return 0x820FBF18;
		/* 820F6DB8h case   22:*/		return 0x820F6DBC;
		  /* 820F6DBCh */ case   23:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F6DBCh case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F6DBCh case   23:*/		return 0x820F6DC0;
		  /* 820F6DC0h */ case   24:  		/* lwz R10, <#[R1 + 96]> */
		/* 820F6DC0h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 820F6DC0h case   24:*/		return 0x820F6DC4;
		  /* 820F6DC4h */ case   25:  		/* cmplwi CR6, R10, 0 */
		/* 820F6DC4h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F6DC4h case   25:*/		return 0x820F6DC8;
		  /* 820F6DC8h */ case   26:  		/* lwz R30, <#[R11 + 16]> */
		/* 820F6DC8h case   26:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000010) );
		/* 820F6DC8h case   26:*/		return 0x820F6DCC;
		  /* 820F6DCCh */ case   27:  		/* bc 12, CR6_EQ, 836 */
		/* 820F6DCCh case   27:*/		if ( regs.CR[6].eq ) { return 0x820F7110;  }
		/* 820F6DCCh case   27:*/		return 0x820F6DD0;
		  /* 820F6DD0h */ case   28:  		/* lwz R11, <#[R1 + 100]> */
		/* 820F6DD0h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 820F6DD0h case   28:*/		return 0x820F6DD4;
		  /* 820F6DD4h */ case   29:  		/* cmplwi CR6, R11, 0 */
		/* 820F6DD4h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F6DD4h case   29:*/		return 0x820F6DD8;
		  /* 820F6DD8h */ case   30:  		/* bc 12, CR6_EQ, 824 */
		/* 820F6DD8h case   30:*/		if ( regs.CR[6].eq ) { return 0x820F7110;  }
		/* 820F6DD8h case   30:*/		return 0x820F6DDC;
		  /* 820F6DDCh */ case   31:  		/* lwz R11, <#[R1 + 104]> */
		/* 820F6DDCh case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 820F6DDCh case   31:*/		return 0x820F6DE0;
		  /* 820F6DE0h */ case   32:  		/* cmplwi CR6, R11, 0 */
		/* 820F6DE0h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F6DE0h case   32:*/		return 0x820F6DE4;
		  /* 820F6DE4h */ case   33:  		/* bc 12, CR6_EQ, 812 */
		/* 820F6DE4h case   33:*/		if ( regs.CR[6].eq ) { return 0x820F7110;  }
		/* 820F6DE4h case   33:*/		return 0x820F6DE8;
		  /* 820F6DE8h */ case   34:  		/* lwz R11, <#[R1 + 108]> */
		/* 820F6DE8h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 820F6DE8h case   34:*/		return 0x820F6DEC;
		  /* 820F6DECh */ case   35:  		/* cmplwi CR6, R11, 0 */
		/* 820F6DECh case   35:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F6DECh case   35:*/		return 0x820F6DF0;
		  /* 820F6DF0h */ case   36:  		/* bc 12, CR6_EQ, 800 */
		/* 820F6DF0h case   36:*/		if ( regs.CR[6].eq ) { return 0x820F7110;  }
		/* 820F6DF0h case   36:*/		return 0x820F6DF4;
		  /* 820F6DF4h */ case   37:  		/* lwz R11, <#[R31]> */
		/* 820F6DF4h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6DF4h case   37:*/		return 0x820F6DF8;
		  /* 820F6DF8h */ case   38:  		/* li R4, 93 */
		/* 820F6DF8h case   38:*/		cpu::op::li<0>(regs,&regs.R4,0x5D);
		/* 820F6DF8h case   38:*/		return 0x820F6DFC;
		  /* 820F6DFCh */ case   39:  		/* mr R3, R31 */
		/* 820F6DFCh case   39:*/		regs.R3 = regs.R31;
		/* 820F6DFCh case   39:*/		return 0x820F6E00;
		  /* 820F6E00h */ case   40:  		/* lwz R11, <#[R11 + 304]> */
		/* 820F6E00h case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000130) );
		/* 820F6E00h case   40:*/		return 0x820F6E04;
		  /* 820F6E04h */ case   41:  		/* mtspr CTR, R11 */
		/* 820F6E04h case   41:*/		regs.CTR = regs.R11;
		/* 820F6E04h case   41:*/		return 0x820F6E08;
		  /* 820F6E08h */ case   42:  		/* bcctrl 20, CR0_LT */
		/* 820F6E08h case   42:*/		if ( 1 ) { regs.LR = 0x820F6E0C; return (uint32)regs.CTR; }
		/* 820F6E08h case   42:*/		return 0x820F6E0C;
		  /* 820F6E0Ch */ case   43:  		/* mr R4, R3 */
		/* 820F6E0Ch case   43:*/		regs.R4 = regs.R3;
		/* 820F6E0Ch case   43:*/		return 0x820F6E10;
		  /* 820F6E10h */ case   44:  		/* mr R3, R31 */
		/* 820F6E10h case   44:*/		regs.R3 = regs.R31;
		/* 820F6E10h case   44:*/		return 0x820F6E14;
		  /* 820F6E14h */ case   45:  		/* bl -3364 */
		/* 820F6E14h case   45:*/		regs.LR = 0x820F6E18; return 0x820F60F0;
		/* 820F6E14h case   45:*/		return 0x820F6E18;
		  /* 820F6E18h */ case   46:  		/* cmpwi CR0, R3, 0 */
		/* 820F6E18h case   46:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6E18h case   46:*/		return 0x820F6E1C;
		  /* 820F6E1Ch */ case   47:  		/* bc 12, CR0_LT, 764 */
		/* 820F6E1Ch case   47:*/		if ( regs.CR[0].lt ) { return 0x820F7118;  }
		/* 820F6E1Ch case   47:*/		return 0x820F6E20;
		  /* 820F6E20h */ case   48:  		/* lwz R11, <#[R31]> */
		/* 820F6E20h case   48:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6E20h case   48:*/		return 0x820F6E24;
		  /* 820F6E24h */ case   49:  		/* addi R7, R1, 112 */
		/* 820F6E24h case   49:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x70);
		/* 820F6E24h case   49:*/		return 0x820F6E28;
		  /* 820F6E28h */ case   50:  		/* lwz R10, <#[R30]> */
		/* 820F6E28h case   50:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820F6E28h case   50:*/		return 0x820F6E2C;
		  /* 820F6E2Ch */ case   51:  		/* addi R6, R1, 116 */
		/* 820F6E2Ch case   51:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x74);
		/* 820F6E2Ch case   51:*/		return 0x820F6E30;
		  /* 820F6E30h */ case   52:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F6E30h case   52:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F6E30h case   52:*/		return 0x820F6E34;
		  /* 820F6E34h */ case   53:  		/* addi R5, R1, 80 */
		/* 820F6E34h case   53:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820F6E34h case   53:*/		return 0x820F6E38;
		  /* 820F6E38h */ case   54:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F6E38h case   54:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F6E38h case   54:*/		return 0x820F6E3C;
		  /* 820F6E3Ch */ case   55:  		/* mr R3, R31 */
		/* 820F6E3Ch case   55:*/		regs.R3 = regs.R31;
		/* 820F6E3Ch case   55:*/		return 0x820F6E40;
		  /* 820F6E40h */ case   56:  		/* lwz R11, <#[R11 + 320]> */
		/* 820F6E40h case   56:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000140) );
		/* 820F6E40h case   56:*/		return 0x820F6E44;
		  /* 820F6E44h */ case   57:  		/* lwzx R4, <#[R10 + R9]> */
		/* 820F6E44h case   57:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820F6E44h case   57:*/		return 0x820F6E48;
		  /* 820F6E48h */ case   58:  		/* mtspr CTR, R11 */
		/* 820F6E48h case   58:*/		regs.CTR = regs.R11;
		/* 820F6E48h case   58:*/		return 0x820F6E4C;
		  /* 820F6E4Ch */ case   59:  		/* bcctrl 20, CR0_LT */
		/* 820F6E4Ch case   59:*/		if ( 1 ) { regs.LR = 0x820F6E50; return (uint32)regs.CTR; }
		/* 820F6E4Ch case   59:*/		return 0x820F6E50;
		  /* 820F6E50h */ case   60:  		/* cmpwi CR0, R3, 0 */
		/* 820F6E50h case   60:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6E50h case   60:*/		return 0x820F6E54;
		  /* 820F6E54h */ case   61:  		/* bc 12, CR0_LT, 708 */
		/* 820F6E54h case   61:*/		if ( regs.CR[0].lt ) { return 0x820F7118;  }
		/* 820F6E54h case   61:*/		return 0x820F6E58;
		  /* 820F6E58h */ case   62:  		/* lwz R11, <#[R31]> */
		/* 820F6E58h case   62:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6E58h case   62:*/		return 0x820F6E5C;
		  /* 820F6E5Ch */ case   63:  		/* addi R6, R1, 92 */
		/* 820F6E5Ch case   63:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x5C);
		/* 820F6E5Ch case   63:*/		return 0x820F6E60;
		  /* 820F6E60h */ case   64:  		/* mr R5, R29 */
		/* 820F6E60h case   64:*/		regs.R5 = regs.R29;
		/* 820F6E60h case   64:*/		return 0x820F6E64;
		  /* 820F6E64h */ case   65:  		/* lwz R7, <#[R1 + 112]> */
		/* 820F6E64h case   65:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000070) );
		/* 820F6E64h case   65:*/		return 0x820F6E68;
		  /* 820F6E68h */ case   66:  		/* mr R4, R30 */
		/* 820F6E68h case   66:*/		regs.R4 = regs.R30;
		/* 820F6E68h case   66:*/		return 0x820F6E6C;
		  /* 820F6E6Ch */ case   67:  		/* mr R3, R31 */
		/* 820F6E6Ch case   67:*/		regs.R3 = regs.R31;
		/* 820F6E6Ch case   67:*/		return 0x820F6E70;
		  /* 820F6E70h */ case   68:  		/* lwz R11, <#[R11 + 324]> */
		/* 820F6E70h case   68:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000144) );
		/* 820F6E70h case   68:*/		return 0x820F6E74;
		  /* 820F6E74h */ case   69:  		/* mtspr CTR, R11 */
		/* 820F6E74h case   69:*/		regs.CTR = regs.R11;
		/* 820F6E74h case   69:*/		return 0x820F6E78;
		  /* 820F6E78h */ case   70:  		/* bcctrl 20, CR0_LT */
		/* 820F6E78h case   70:*/		if ( 1 ) { regs.LR = 0x820F6E7C; return (uint32)regs.CTR; }
		/* 820F6E78h case   70:*/		return 0x820F6E7C;
		  /* 820F6E7Ch */ case   71:  		/* cmpwi CR0, R3, 0 */
		/* 820F6E7Ch case   71:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6E7Ch case   71:*/		return 0x820F6E80;
		  /* 820F6E80h */ case   72:  		/* bc 12, CR0_LT, 664 */
		/* 820F6E80h case   72:*/		if ( regs.CR[0].lt ) { return 0x820F7118;  }
		/* 820F6E80h case   72:*/		return 0x820F6E84;
		  /* 820F6E84h */ case   73:  		/* lwz R11, <#[R31]> */
		/* 820F6E84h case   73:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6E84h case   73:*/		return 0x820F6E88;
		  /* 820F6E88h */ case   74:  		/* mr R3, R31 */
		/* 820F6E88h case   74:*/		regs.R3 = regs.R31;
		/* 820F6E88h case   74:*/		return 0x820F6E8C;
		  /* 820F6E8Ch */ case   75:  		/* lwz R6, <#[R1 + 116]> */
		/* 820F6E8Ch case   75:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000074) );
		/* 820F6E8Ch case   75:*/		return 0x820F6E90;
	}
	return 0x820F6E90;
} // Block from 820F6D60h-820F6E90h (76 instructions)

//////////////////////////////////////////////////////
// Block at 820F6E90h
// Function '?EmitDEF@CShaderProgram@D3DXShader@@MAAJIPAM@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F6E90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F6E90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F6E90);
		  /* 820F6E90h */ case    0:  		/* lwz R5, <#[R1 + 92]> */
		/* 820F6E90h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F6E90h case    0:*/		return 0x820F6E94;
		  /* 820F6E94h */ case    1:  		/* lwz R4, <#[R1 + 80]> */
		/* 820F6E94h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 820F6E94h case    1:*/		return 0x820F6E98;
		  /* 820F6E98h */ case    2:  		/* lwz R11, <#[R11 + 312]> */
		/* 820F6E98h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000138) );
		/* 820F6E98h case    2:*/		return 0x820F6E9C;
		  /* 820F6E9Ch */ case    3:  		/* mtspr CTR, R11 */
		/* 820F6E9Ch case    3:*/		regs.CTR = regs.R11;
		/* 820F6E9Ch case    3:*/		return 0x820F6EA0;
		  /* 820F6EA0h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 820F6EA0h case    4:*/		if ( 1 ) { regs.LR = 0x820F6EA4; return (uint32)regs.CTR; }
		/* 820F6EA0h case    4:*/		return 0x820F6EA4;
		  /* 820F6EA4h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820F6EA4h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6EA4h case    5:*/		return 0x820F6EA8;
		  /* 820F6EA8h */ case    6:  		/* bc 12, CR0_LT, 624 */
		/* 820F6EA8h case    6:*/		if ( regs.CR[0].lt ) { return 0x820F7118;  }
		/* 820F6EA8h case    6:*/		return 0x820F6EAC;
		  /* 820F6EACh */ case    7:  		/* lwz R11, <#[R1 + 96]> */
		/* 820F6EACh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820F6EACh case    7:*/		return 0x820F6EB0;
		  /* 820F6EB0h */ case    8:  		/* addi R6, R1, 84 */
		/* 820F6EB0h case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 820F6EB0h case    8:*/		return 0x820F6EB4;
		  /* 820F6EB4h */ case    9:  		/* lwz R10, <#[R31]> */
		/* 820F6EB4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6EB4h case    9:*/		return 0x820F6EB8;
		  /* 820F6EB8h */ case   10:  		/* addi R5, R1, 80 */
		/* 820F6EB8h case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820F6EB8h case   10:*/		return 0x820F6EBC;
		  /* 820F6EBCh */ case   11:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F6EBCh case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F6EBCh case   11:*/		return 0x820F6EC0;
		  /* 820F6EC0h */ case   12:  		/* mr R3, R31 */
		/* 820F6EC0h case   12:*/		regs.R3 = regs.R31;
		/* 820F6EC0h case   12:*/		return 0x820F6EC4;
		  /* 820F6EC4h */ case   13:  		/* lwz R11, <#[R11]> */
		/* 820F6EC4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F6EC4h case   13:*/		return 0x820F6EC8;
		  /* 820F6EC8h */ case   14:  		/* lwz R10, <#[R10 + 328]> */
		/* 820F6EC8h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000148) );
		/* 820F6EC8h case   14:*/		return 0x820F6ECC;
		  /* 820F6ECCh */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F6ECCh case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F6ECCh case   15:*/		return 0x820F6ED0;
		  /* 820F6ED0h */ case   16:  		/* mtspr CTR, R10 */
		/* 820F6ED0h case   16:*/		regs.CTR = regs.R10;
		/* 820F6ED0h case   16:*/		return 0x820F6ED4;
		  /* 820F6ED4h */ case   17:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F6ED4h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F6ED4h case   17:*/		return 0x820F6ED8;
		  /* 820F6ED8h */ case   18:  		/* bcctrl 20, CR0_LT */
		/* 820F6ED8h case   18:*/		if ( 1 ) { regs.LR = 0x820F6EDC; return (uint32)regs.CTR; }
		/* 820F6ED8h case   18:*/		return 0x820F6EDC;
		  /* 820F6EDCh */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 820F6EDCh case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6EDCh case   19:*/		return 0x820F6EE0;
		  /* 820F6EE0h */ case   20:  		/* bc 12, CR0_LT, 568 */
		/* 820F6EE0h case   20:*/		if ( regs.CR[0].lt ) { return 0x820F7118;  }
		/* 820F6EE0h case   20:*/		return 0x820F6EE4;
		  /* 820F6EE4h */ case   21:  		/* lwz R11, <#[R31]> */
		/* 820F6EE4h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6EE4h case   21:*/		return 0x820F6EE8;
		  /* 820F6EE8h */ case   22:  		/* addi R7, R1, 88 */
		/* 820F6EE8h case   22:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x58);
		/* 820F6EE8h case   22:*/		return 0x820F6EEC;
		  /* 820F6EECh */ case   23:  		/* mr R5, R28 */
		/* 820F6EECh case   23:*/		regs.R5 = regs.R28;
		/* 820F6EECh case   23:*/		return 0x820F6EF0;
		  /* 820F6EF0h */ case   24:  		/* lwz R6, <#[R1 + 92]> */
		/* 820F6EF0h case   24:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F6EF0h case   24:*/		return 0x820F6EF4;
		  /* 820F6EF4h */ case   25:  		/* mr R3, R31 */
		/* 820F6EF4h case   25:*/		regs.R3 = regs.R31;
		/* 820F6EF4h case   25:*/		return 0x820F6EF8;
		  /* 820F6EF8h */ case   26:  		/* lwz R4, <#[R1 + 96]> */
		/* 820F6EF8h case   26:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000060) );
		/* 820F6EF8h case   26:*/		return 0x820F6EFC;
		  /* 820F6EFCh */ case   27:  		/* lwz R11, <#[R11 + 332]> */
		/* 820F6EFCh case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000014C) );
		/* 820F6EFCh case   27:*/		return 0x820F6F00;
		  /* 820F6F00h */ case   28:  		/* mtspr CTR, R11 */
		/* 820F6F00h case   28:*/		regs.CTR = regs.R11;
		/* 820F6F00h case   28:*/		return 0x820F6F04;
		  /* 820F6F04h */ case   29:  		/* bcctrl 20, CR0_LT */
		/* 820F6F04h case   29:*/		if ( 1 ) { regs.LR = 0x820F6F08; return (uint32)regs.CTR; }
		/* 820F6F04h case   29:*/		return 0x820F6F08;
		  /* 820F6F08h */ case   30:  		/* cmpwi CR0, R3, 0 */
		/* 820F6F08h case   30:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6F08h case   30:*/		return 0x820F6F0C;
		  /* 820F6F0Ch */ case   31:  		/* bc 12, CR0_LT, 524 */
		/* 820F6F0Ch case   31:*/		if ( regs.CR[0].lt ) { return 0x820F7118;  }
		/* 820F6F0Ch case   31:*/		return 0x820F6F10;
		  /* 820F6F10h */ case   32:  		/* lwz R11, <#[R31]> */
		/* 820F6F10h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6F10h case   32:*/		return 0x820F6F14;
		  /* 820F6F14h */ case   33:  		/* mr R3, R31 */
		/* 820F6F14h case   33:*/		regs.R3 = regs.R31;
		/* 820F6F14h case   33:*/		return 0x820F6F18;
		  /* 820F6F18h */ case   34:  		/* lwz R6, <#[R1 + 84]> */
		/* 820F6F18h case   34:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 820F6F18h case   34:*/		return 0x820F6F1C;
		  /* 820F6F1Ch */ case   35:  		/* lwz R5, <#[R1 + 88]> */
		/* 820F6F1Ch case   35:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000058) );
		/* 820F6F1Ch case   35:*/		return 0x820F6F20;
		  /* 820F6F20h */ case   36:  		/* lwz R4, <#[R1 + 80]> */
		/* 820F6F20h case   36:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 820F6F20h case   36:*/		return 0x820F6F24;
		  /* 820F6F24h */ case   37:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F6F24h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F6F24h case   37:*/		return 0x820F6F28;
		  /* 820F6F28h */ case   38:  		/* mtspr CTR, R11 */
		/* 820F6F28h case   38:*/		regs.CTR = regs.R11;
		/* 820F6F28h case   38:*/		return 0x820F6F2C;
		  /* 820F6F2Ch */ case   39:  		/* bcctrl 20, CR0_LT */
		/* 820F6F2Ch case   39:*/		if ( 1 ) { regs.LR = 0x820F6F30; return (uint32)regs.CTR; }
		/* 820F6F2Ch case   39:*/		return 0x820F6F30;
		  /* 820F6F30h */ case   40:  		/* cmpwi CR0, R3, 0 */
		/* 820F6F30h case   40:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6F30h case   40:*/		return 0x820F6F34;
		  /* 820F6F34h */ case   41:  		/* bc 12, CR0_LT, 484 */
		/* 820F6F34h case   41:*/		if ( regs.CR[0].lt ) { return 0x820F7118;  }
		/* 820F6F34h case   41:*/		return 0x820F6F38;
		  /* 820F6F38h */ case   42:  		/* lwz R11, <#[R1 + 100]> */
		/* 820F6F38h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 820F6F38h case   42:*/		return 0x820F6F3C;
		  /* 820F6F3Ch */ case   43:  		/* addi R6, R1, 84 */
		/* 820F6F3Ch case   43:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 820F6F3Ch case   43:*/		return 0x820F6F40;
		  /* 820F6F40h */ case   44:  		/* lwz R10, <#[R31]> */
		/* 820F6F40h case   44:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6F40h case   44:*/		return 0x820F6F44;
		  /* 820F6F44h */ case   45:  		/* addi R5, R1, 80 */
		/* 820F6F44h case   45:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820F6F44h case   45:*/		return 0x820F6F48;
		  /* 820F6F48h */ case   46:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F6F48h case   46:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F6F48h case   46:*/		return 0x820F6F4C;
		  /* 820F6F4Ch */ case   47:  		/* mr R3, R31 */
		/* 820F6F4Ch case   47:*/		regs.R3 = regs.R31;
		/* 820F6F4Ch case   47:*/		return 0x820F6F50;
		  /* 820F6F50h */ case   48:  		/* lwz R11, <#[R11]> */
		/* 820F6F50h case   48:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F6F50h case   48:*/		return 0x820F6F54;
		  /* 820F6F54h */ case   49:  		/* lwz R10, <#[R10 + 328]> */
		/* 820F6F54h case   49:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000148) );
		/* 820F6F54h case   49:*/		return 0x820F6F58;
		  /* 820F6F58h */ case   50:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F6F58h case   50:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F6F58h case   50:*/		return 0x820F6F5C;
		  /* 820F6F5Ch */ case   51:  		/* mtspr CTR, R10 */
		/* 820F6F5Ch case   51:*/		regs.CTR = regs.R10;
		/* 820F6F5Ch case   51:*/		return 0x820F6F60;
		  /* 820F6F60h */ case   52:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F6F60h case   52:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F6F60h case   52:*/		return 0x820F6F64;
		  /* 820F6F64h */ case   53:  		/* bcctrl 20, CR0_LT */
		/* 820F6F64h case   53:*/		if ( 1 ) { regs.LR = 0x820F6F68; return (uint32)regs.CTR; }
		/* 820F6F64h case   53:*/		return 0x820F6F68;
		  /* 820F6F68h */ case   54:  		/* cmpwi CR0, R3, 0 */
		/* 820F6F68h case   54:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6F68h case   54:*/		return 0x820F6F6C;
		  /* 820F6F6Ch */ case   55:  		/* bc 12, CR0_LT, 428 */
		/* 820F6F6Ch case   55:*/		if ( regs.CR[0].lt ) { return 0x820F7118;  }
		/* 820F6F6Ch case   55:*/		return 0x820F6F70;
		  /* 820F6F70h */ case   56:  		/* lwz R11, <#[R31]> */
		/* 820F6F70h case   56:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6F70h case   56:*/		return 0x820F6F74;
		  /* 820F6F74h */ case   57:  		/* addi R7, R1, 88 */
		/* 820F6F74h case   57:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x58);
		/* 820F6F74h case   57:*/		return 0x820F6F78;
		  /* 820F6F78h */ case   58:  		/* mr R5, R28 */
		/* 820F6F78h case   58:*/		regs.R5 = regs.R28;
		/* 820F6F78h case   58:*/		return 0x820F6F7C;
		  /* 820F6F7Ch */ case   59:  		/* lwz R6, <#[R1 + 92]> */
		/* 820F6F7Ch case   59:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F6F7Ch case   59:*/		return 0x820F6F80;
		  /* 820F6F80h */ case   60:  		/* mr R3, R31 */
		/* 820F6F80h case   60:*/		regs.R3 = regs.R31;
		/* 820F6F80h case   60:*/		return 0x820F6F84;
		  /* 820F6F84h */ case   61:  		/* lwz R4, <#[R1 + 100]> */
		/* 820F6F84h case   61:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000064) );
		/* 820F6F84h case   61:*/		return 0x820F6F88;
		  /* 820F6F88h */ case   62:  		/* lwz R11, <#[R11 + 332]> */
		/* 820F6F88h case   62:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000014C) );
		/* 820F6F88h case   62:*/		return 0x820F6F8C;
		  /* 820F6F8Ch */ case   63:  		/* mtspr CTR, R11 */
		/* 820F6F8Ch case   63:*/		regs.CTR = regs.R11;
		/* 820F6F8Ch case   63:*/		return 0x820F6F90;
		  /* 820F6F90h */ case   64:  		/* bcctrl 20, CR0_LT */
		/* 820F6F90h case   64:*/		if ( 1 ) { regs.LR = 0x820F6F94; return (uint32)regs.CTR; }
		/* 820F6F90h case   64:*/		return 0x820F6F94;
		  /* 820F6F94h */ case   65:  		/* cmpwi CR0, R3, 0 */
		/* 820F6F94h case   65:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6F94h case   65:*/		return 0x820F6F98;
		  /* 820F6F98h */ case   66:  		/* bc 12, CR0_LT, 384 */
		/* 820F6F98h case   66:*/		if ( regs.CR[0].lt ) { return 0x820F7118;  }
		/* 820F6F98h case   66:*/		return 0x820F6F9C;
		  /* 820F6F9Ch */ case   67:  		/* lwz R11, <#[R31]> */
		/* 820F6F9Ch case   67:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6F9Ch case   67:*/		return 0x820F6FA0;
		  /* 820F6FA0h */ case   68:  		/* mr R3, R31 */
		/* 820F6FA0h case   68:*/		regs.R3 = regs.R31;
		/* 820F6FA0h case   68:*/		return 0x820F6FA4;
		  /* 820F6FA4h */ case   69:  		/* lwz R6, <#[R1 + 84]> */
		/* 820F6FA4h case   69:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 820F6FA4h case   69:*/		return 0x820F6FA8;
		  /* 820F6FA8h */ case   70:  		/* lwz R5, <#[R1 + 88]> */
		/* 820F6FA8h case   70:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000058) );
		/* 820F6FA8h case   70:*/		return 0x820F6FAC;
		  /* 820F6FACh */ case   71:  		/* lwz R4, <#[R1 + 80]> */
		/* 820F6FACh case   71:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 820F6FACh case   71:*/		return 0x820F6FB0;
		  /* 820F6FB0h */ case   72:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F6FB0h case   72:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F6FB0h case   72:*/		return 0x820F6FB4;
		  /* 820F6FB4h */ case   73:  		/* mtspr CTR, R11 */
		/* 820F6FB4h case   73:*/		regs.CTR = regs.R11;
		/* 820F6FB4h case   73:*/		return 0x820F6FB8;
		  /* 820F6FB8h */ case   74:  		/* bcctrl 20, CR0_LT */
		/* 820F6FB8h case   74:*/		if ( 1 ) { regs.LR = 0x820F6FBC; return (uint32)regs.CTR; }
		/* 820F6FB8h case   74:*/		return 0x820F6FBC;
		  /* 820F6FBCh */ case   75:  		/* cmpwi CR0, R3, 0 */
		/* 820F6FBCh case   75:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6FBCh case   75:*/		return 0x820F6FC0;
		  /* 820F6FC0h */ case   76:  		/* bc 12, CR0_LT, 344 */
		/* 820F6FC0h case   76:*/		if ( regs.CR[0].lt ) { return 0x820F7118;  }
		/* 820F6FC0h case   76:*/		return 0x820F6FC4;
		  /* 820F6FC4h */ case   77:  		/* lwz R11, <#[R1 + 104]> */
		/* 820F6FC4h case   77:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 820F6FC4h case   77:*/		return 0x820F6FC8;
		  /* 820F6FC8h */ case   78:  		/* addi R6, R1, 84 */
		/* 820F6FC8h case   78:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 820F6FC8h case   78:*/		return 0x820F6FCC;
		  /* 820F6FCCh */ case   79:  		/* lwz R10, <#[R31]> */
		/* 820F6FCCh case   79:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6FCCh case   79:*/		return 0x820F6FD0;
		  /* 820F6FD0h */ case   80:  		/* addi R5, R1, 80 */
		/* 820F6FD0h case   80:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820F6FD0h case   80:*/		return 0x820F6FD4;
		  /* 820F6FD4h */ case   81:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F6FD4h case   81:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F6FD4h case   81:*/		return 0x820F6FD8;
		  /* 820F6FD8h */ case   82:  		/* mr R3, R31 */
		/* 820F6FD8h case   82:*/		regs.R3 = regs.R31;
		/* 820F6FD8h case   82:*/		return 0x820F6FDC;
		  /* 820F6FDCh */ case   83:  		/* lwz R11, <#[R11]> */
		/* 820F6FDCh case   83:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F6FDCh case   83:*/		return 0x820F6FE0;
		  /* 820F6FE0h */ case   84:  		/* lwz R10, <#[R10 + 328]> */
		/* 820F6FE0h case   84:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000148) );
		/* 820F6FE0h case   84:*/		return 0x820F6FE4;
		  /* 820F6FE4h */ case   85:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F6FE4h case   85:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F6FE4h case   85:*/		return 0x820F6FE8;
		  /* 820F6FE8h */ case   86:  		/* mtspr CTR, R10 */
		/* 820F6FE8h case   86:*/		regs.CTR = regs.R10;
		/* 820F6FE8h case   86:*/		return 0x820F6FEC;
		  /* 820F6FECh */ case   87:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F6FECh case   87:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F6FECh case   87:*/		return 0x820F6FF0;
		  /* 820F6FF0h */ case   88:  		/* bcctrl 20, CR0_LT */
		/* 820F6FF0h case   88:*/		if ( 1 ) { regs.LR = 0x820F6FF4; return (uint32)regs.CTR; }
		/* 820F6FF0h case   88:*/		return 0x820F6FF4;
		  /* 820F6FF4h */ case   89:  		/* cmpwi CR0, R3, 0 */
		/* 820F6FF4h case   89:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F6FF4h case   89:*/		return 0x820F6FF8;
		  /* 820F6FF8h */ case   90:  		/* bc 12, CR0_LT, 288 */
		/* 820F6FF8h case   90:*/		if ( regs.CR[0].lt ) { return 0x820F7118;  }
		/* 820F6FF8h case   90:*/		return 0x820F6FFC;
		  /* 820F6FFCh */ case   91:  		/* lwz R11, <#[R31]> */
		/* 820F6FFCh case   91:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F6FFCh case   91:*/		return 0x820F7000;
		  /* 820F7000h */ case   92:  		/* addi R7, R1, 88 */
		/* 820F7000h case   92:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x58);
		/* 820F7000h case   92:*/		return 0x820F7004;
		  /* 820F7004h */ case   93:  		/* mr R5, R28 */
		/* 820F7004h case   93:*/		regs.R5 = regs.R28;
		/* 820F7004h case   93:*/		return 0x820F7008;
		  /* 820F7008h */ case   94:  		/* lwz R6, <#[R1 + 92]> */
		/* 820F7008h case   94:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F7008h case   94:*/		return 0x820F700C;
		  /* 820F700Ch */ case   95:  		/* mr R3, R31 */
		/* 820F700Ch case   95:*/		regs.R3 = regs.R31;
		/* 820F700Ch case   95:*/		return 0x820F7010;
		  /* 820F7010h */ case   96:  		/* lwz R4, <#[R1 + 104]> */
		/* 820F7010h case   96:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000068) );
		/* 820F7010h case   96:*/		return 0x820F7014;
		  /* 820F7014h */ case   97:  		/* lwz R11, <#[R11 + 332]> */
		/* 820F7014h case   97:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000014C) );
		/* 820F7014h case   97:*/		return 0x820F7018;
		  /* 820F7018h */ case   98:  		/* mtspr CTR, R11 */
		/* 820F7018h case   98:*/		regs.CTR = regs.R11;
		/* 820F7018h case   98:*/		return 0x820F701C;
		  /* 820F701Ch */ case   99:  		/* bcctrl 20, CR0_LT */
		/* 820F701Ch case   99:*/		if ( 1 ) { regs.LR = 0x820F7020; return (uint32)regs.CTR; }
		/* 820F701Ch case   99:*/		return 0x820F7020;
		  /* 820F7020h */ case  100:  		/* cmpwi CR0, R3, 0 */
		/* 820F7020h case  100:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7020h case  100:*/		return 0x820F7024;
		  /* 820F7024h */ case  101:  		/* bc 12, CR0_LT, 244 */
		/* 820F7024h case  101:*/		if ( regs.CR[0].lt ) { return 0x820F7118;  }
		/* 820F7024h case  101:*/		return 0x820F7028;
		  /* 820F7028h */ case  102:  		/* lwz R11, <#[R31]> */
		/* 820F7028h case  102:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7028h case  102:*/		return 0x820F702C;
		  /* 820F702Ch */ case  103:  		/* mr R3, R31 */
		/* 820F702Ch case  103:*/		regs.R3 = regs.R31;
		/* 820F702Ch case  103:*/		return 0x820F7030;
	}
	return 0x820F7030;
} // Block from 820F6E90h-820F7030h (104 instructions)

//////////////////////////////////////////////////////
// Block at 820F7030h
// Function '?EmitDEFi@CShaderProgram@D3DXShader@@MAAJIPAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7030);
		  /* 820F7030h */ case    0:  		/* lwz R6, <#[R1 + 84]> */
		/* 820F7030h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 820F7030h case    0:*/		return 0x820F7034;
		  /* 820F7034h */ case    1:  		/* lwz R5, <#[R1 + 88]> */
		/* 820F7034h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000058) );
		/* 820F7034h case    1:*/		return 0x820F7038;
		  /* 820F7038h */ case    2:  		/* lwz R4, <#[R1 + 80]> */
		/* 820F7038h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 820F7038h case    2:*/		return 0x820F703C;
		  /* 820F703Ch */ case    3:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F703Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F703Ch case    3:*/		return 0x820F7040;
		  /* 820F7040h */ case    4:  		/* mtspr CTR, R11 */
		/* 820F7040h case    4:*/		regs.CTR = regs.R11;
		/* 820F7040h case    4:*/		return 0x820F7044;
		  /* 820F7044h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 820F7044h case    5:*/		if ( 1 ) { regs.LR = 0x820F7048; return (uint32)regs.CTR; }
		/* 820F7044h case    5:*/		return 0x820F7048;
		  /* 820F7048h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820F7048h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7048h case    6:*/		return 0x820F704C;
		  /* 820F704Ch */ case    7:  		/* bc 12, CR0_LT, 204 */
		/* 820F704Ch case    7:*/		if ( regs.CR[0].lt ) { return 0x820F7118;  }
		/* 820F704Ch case    7:*/		return 0x820F7050;
		  /* 820F7050h */ case    8:  		/* lwz R11, <#[R1 + 108]> */
		/* 820F7050h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 820F7050h case    8:*/		return 0x820F7054;
		  /* 820F7054h */ case    9:  		/* addi R6, R1, 84 */
		/* 820F7054h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 820F7054h case    9:*/		return 0x820F7058;
		  /* 820F7058h */ case   10:  		/* lwz R10, <#[R31]> */
		/* 820F7058h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7058h case   10:*/		return 0x820F705C;
		  /* 820F705Ch */ case   11:  		/* addi R5, R1, 80 */
		/* 820F705Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820F705Ch case   11:*/		return 0x820F7060;
		  /* 820F7060h */ case   12:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F7060h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F7060h case   12:*/		return 0x820F7064;
		  /* 820F7064h */ case   13:  		/* mr R3, R31 */
		/* 820F7064h case   13:*/		regs.R3 = regs.R31;
		/* 820F7064h case   13:*/		return 0x820F7068;
		  /* 820F7068h */ case   14:  		/* lwz R11, <#[R11]> */
		/* 820F7068h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F7068h case   14:*/		return 0x820F706C;
		  /* 820F706Ch */ case   15:  		/* lwz R10, <#[R10 + 328]> */
		/* 820F706Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000148) );
		/* 820F706Ch case   15:*/		return 0x820F7070;
		  /* 820F7070h */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F7070h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F7070h case   16:*/		return 0x820F7074;
		  /* 820F7074h */ case   17:  		/* mtspr CTR, R10 */
		/* 820F7074h case   17:*/		regs.CTR = regs.R10;
		/* 820F7074h case   17:*/		return 0x820F7078;
		  /* 820F7078h */ case   18:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F7078h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F7078h case   18:*/		return 0x820F707C;
		  /* 820F707Ch */ case   19:  		/* bcctrl 20, CR0_LT */
		/* 820F707Ch case   19:*/		if ( 1 ) { regs.LR = 0x820F7080; return (uint32)regs.CTR; }
		/* 820F707Ch case   19:*/		return 0x820F7080;
		  /* 820F7080h */ case   20:  		/* cmpwi CR0, R3, 0 */
		/* 820F7080h case   20:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7080h case   20:*/		return 0x820F7084;
		  /* 820F7084h */ case   21:  		/* bc 12, CR0_LT, 148 */
		/* 820F7084h case   21:*/		if ( regs.CR[0].lt ) { return 0x820F7118;  }
		/* 820F7084h case   21:*/		return 0x820F7088;
		  /* 820F7088h */ case   22:  		/* lwz R11, <#[R31]> */
		/* 820F7088h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7088h case   22:*/		return 0x820F708C;
		  /* 820F708Ch */ case   23:  		/* addi R7, R1, 88 */
		/* 820F708Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x58);
		/* 820F708Ch case   23:*/		return 0x820F7090;
		  /* 820F7090h */ case   24:  		/* mr R5, R28 */
		/* 820F7090h case   24:*/		regs.R5 = regs.R28;
		/* 820F7090h case   24:*/		return 0x820F7094;
		  /* 820F7094h */ case   25:  		/* lwz R6, <#[R1 + 92]> */
		/* 820F7094h case   25:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F7094h case   25:*/		return 0x820F7098;
		  /* 820F7098h */ case   26:  		/* mr R3, R31 */
		/* 820F7098h case   26:*/		regs.R3 = regs.R31;
		/* 820F7098h case   26:*/		return 0x820F709C;
		  /* 820F709Ch */ case   27:  		/* lwz R4, <#[R1 + 108]> */
		/* 820F709Ch case   27:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000006C) );
		/* 820F709Ch case   27:*/		return 0x820F70A0;
		  /* 820F70A0h */ case   28:  		/* lwz R11, <#[R11 + 332]> */
		/* 820F70A0h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000014C) );
		/* 820F70A0h case   28:*/		return 0x820F70A4;
		  /* 820F70A4h */ case   29:  		/* mtspr CTR, R11 */
		/* 820F70A4h case   29:*/		regs.CTR = regs.R11;
		/* 820F70A4h case   29:*/		return 0x820F70A8;
		  /* 820F70A8h */ case   30:  		/* bcctrl 20, CR0_LT */
		/* 820F70A8h case   30:*/		if ( 1 ) { regs.LR = 0x820F70AC; return (uint32)regs.CTR; }
		/* 820F70A8h case   30:*/		return 0x820F70AC;
		  /* 820F70ACh */ case   31:  		/* cmpwi CR0, R3, 0 */
		/* 820F70ACh case   31:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F70ACh case   31:*/		return 0x820F70B0;
		  /* 820F70B0h */ case   32:  		/* bc 12, CR0_LT, 104 */
		/* 820F70B0h case   32:*/		if ( regs.CR[0].lt ) { return 0x820F7118;  }
		/* 820F70B0h case   32:*/		return 0x820F70B4;
		  /* 820F70B4h */ case   33:  		/* lwz R11, <#[R31]> */
		/* 820F70B4h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F70B4h case   33:*/		return 0x820F70B8;
		  /* 820F70B8h */ case   34:  		/* mr R3, R31 */
		/* 820F70B8h case   34:*/		regs.R3 = regs.R31;
		/* 820F70B8h case   34:*/		return 0x820F70BC;
		  /* 820F70BCh */ case   35:  		/* lwz R6, <#[R1 + 84]> */
		/* 820F70BCh case   35:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 820F70BCh case   35:*/		return 0x820F70C0;
		  /* 820F70C0h */ case   36:  		/* lwz R5, <#[R1 + 88]> */
		/* 820F70C0h case   36:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000058) );
		/* 820F70C0h case   36:*/		return 0x820F70C4;
		  /* 820F70C4h */ case   37:  		/* lwz R4, <#[R1 + 80]> */
		/* 820F70C4h case   37:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 820F70C4h case   37:*/		return 0x820F70C8;
		  /* 820F70C8h */ case   38:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F70C8h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F70C8h case   38:*/		return 0x820F70CC;
		  /* 820F70CCh */ case   39:  		/* mtspr CTR, R11 */
		/* 820F70CCh case   39:*/		regs.CTR = regs.R11;
		/* 820F70CCh case   39:*/		return 0x820F70D0;
		  /* 820F70D0h */ case   40:  		/* bcctrl 20, CR0_LT */
		/* 820F70D0h case   40:*/		if ( 1 ) { regs.LR = 0x820F70D4; return (uint32)regs.CTR; }
		/* 820F70D0h case   40:*/		return 0x820F70D4;
		  /* 820F70D4h */ case   41:  		/* cmpwi CR0, R3, 0 */
		/* 820F70D4h case   41:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F70D4h case   41:*/		return 0x820F70D8;
		  /* 820F70D8h */ case   42:  		/* bc 12, CR0_LT, 64 */
		/* 820F70D8h case   42:*/		if ( regs.CR[0].lt ) { return 0x820F7118;  }
		/* 820F70D8h case   42:*/		return 0x820F70DC;
		  /* 820F70DCh */ case   43:  		/* lwz R11, <#[R31]> */
		/* 820F70DCh case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F70DCh case   43:*/		return 0x820F70E0;
		  /* 820F70E0h */ case   44:  		/* mr R3, R31 */
		/* 820F70E0h case   44:*/		regs.R3 = regs.R31;
		/* 820F70E0h case   44:*/		return 0x820F70E4;
		  /* 820F70E4h */ case   45:  		/* lwz R11, <#[R11 + 308]> */
		/* 820F70E4h case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000134) );
		/* 820F70E4h case   45:*/		return 0x820F70E8;
		  /* 820F70E8h */ case   46:  		/* mtspr CTR, R11 */
		/* 820F70E8h case   46:*/		regs.CTR = regs.R11;
		/* 820F70E8h case   46:*/		return 0x820F70EC;
		  /* 820F70ECh */ case   47:  		/* bcctrl 20, CR0_LT */
		/* 820F70ECh case   47:*/		if ( 1 ) { regs.LR = 0x820F70F0; return (uint32)regs.CTR; }
		/* 820F70ECh case   47:*/		return 0x820F70F0;
		  /* 820F70F0h */ case   48:  		/* cmpwi CR0, R3, 0 */
		/* 820F70F0h case   48:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F70F0h case   48:*/		return 0x820F70F4;
		  /* 820F70F4h */ case   49:  		/* bc 12, CR0_LT, 36 */
		/* 820F70F4h case   49:*/		if ( regs.CR[0].lt ) { return 0x820F7118;  }
		/* 820F70F4h case   49:*/		return 0x820F70F8;
		  /* 820F70F8h */ case   50:  		/* mr R3, R31 */
		/* 820F70F8h case   50:*/		regs.R3 = regs.R31;
		/* 820F70F8h case   50:*/		return 0x820F70FC;
		  /* 820F70FCh */ case   51:  		/* bl -38900 */
		/* 820F70FCh case   51:*/		regs.LR = 0x820F7100; return 0x820ED908;
		/* 820F70FCh case   51:*/		return 0x820F7100;
		  /* 820F7100h */ case   52:  		/* cmpwi CR0, R3, 0 */
		/* 820F7100h case   52:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7100h case   52:*/		return 0x820F7104;
		  /* 820F7104h */ case   53:  		/* bc 12, CR0_LT, 20 */
		/* 820F7104h case   53:*/		if ( regs.CR[0].lt ) { return 0x820F7118;  }
		/* 820F7104h case   53:*/		return 0x820F7108;
		  /* 820F7108h */ case   54:  		/* li R3, 0 */
		/* 820F7108h case   54:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F7108h case   54:*/		return 0x820F710C;
		  /* 820F710Ch */ case   55:  		/* b 12 */
		/* 820F710Ch case   55:*/		return 0x820F7118;
		/* 820F710Ch case   55:*/		return 0x820F7110;
	}
	return 0x820F7110;
} // Block from 820F7030h-820F7110h (56 instructions)

//////////////////////////////////////////////////////
// Block at 820F7110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7110);
		  /* 820F7110h */ case    0:  		/* lis R3, -32768 */
		/* 820F7110h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820F7110h case    0:*/		return 0x820F7114;
		  /* 820F7114h */ case    1:  		/* ori R3, R3, 16389 */
		/* 820F7114h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820F7114h case    1:*/		return 0x820F7118;
	}
	return 0x820F7118;
} // Block from 820F7110h-820F7118h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F7118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7118);
		  /* 820F7118h */ case    0:  		/* addi R1, R1, 160 */
		/* 820F7118h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820F7118h case    0:*/		return 0x820F711C;
		  /* 820F711Ch */ case    1:  		/* b -417396 */
		/* 820F711Ch case    1:*/		return 0x820912A8;
		/* 820F711Ch case    1:*/		return 0x820F7120;
	}
	return 0x820F7120;
} // Block from 820F7118h-820F7120h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F7120h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7120);
		  /* 820F7120h */ case    0:  		/* mfspr R12, LR */
		/* 820F7120h case    0:*/		regs.R12 = regs.LR;
		/* 820F7120h case    0:*/		return 0x820F7124;
		  /* 820F7124h */ case    1:  		/* bl -417484 */
		/* 820F7124h case    1:*/		regs.LR = 0x820F7128; return 0x82091258;
		/* 820F7124h case    1:*/		return 0x820F7128;
		  /* 820F7128h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820F7128h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820F7128h case    2:*/		return 0x820F712C;
		  /* 820F712Ch */ case    3:  		/* mr R31, R3 */
		/* 820F712Ch case    3:*/		regs.R31 = regs.R3;
		/* 820F712Ch case    3:*/		return 0x820F7130;
		  /* 820F7130h */ case    4:  		/* lwz R3, <#[R3 + 260]> */
		/* 820F7130h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000104) );
		/* 820F7130h case    4:*/		return 0x820F7134;
		  /* 820F7134h */ case    5:  		/* addi R5, R1, 112 */
		/* 820F7134h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820F7134h case    5:*/		return 0x820F7138;
		  /* 820F7138h */ case    6:  		/* li R4, 0 */
		/* 820F7138h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F7138h case    6:*/		return 0x820F713C;
		  /* 820F713Ch */ case    7:  		/* lwz R11, <#[R3]> */
		/* 820F713Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F713Ch case    7:*/		return 0x820F7140;
		  /* 820F7140h */ case    8:  		/* lwz R30, <#[R3 + 12]> */
		/* 820F7140h case    8:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x0000000C) );
		/* 820F7140h case    8:*/		return 0x820F7144;
		  /* 820F7144h */ case    9:  		/* lwz R29, <#[R3 + 16]> */
		/* 820F7144h case    9:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000010) );
		/* 820F7144h case    9:*/		return 0x820F7148;
		  /* 820F7148h */ case   10:  		/* rlwinm R28, R11, 0, 12, 31 */
		/* 820F7148h case   10:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R28,regs.R11);
		/* 820F7148h case   10:*/		return 0x820F714C;
		  /* 820F714Ch */ case   11:  		/* bl 19916 */
		/* 820F714Ch case   11:*/		regs.LR = 0x820F7150; return 0x820FBF18;
		/* 820F714Ch case   11:*/		return 0x820F7150;
		  /* 820F7150h */ case   12:  		/* addi R5, R1, 116 */
		/* 820F7150h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x74);
		/* 820F7150h case   12:*/		return 0x820F7154;
		  /* 820F7154h */ case   13:  		/* li R4, 1 */
		/* 820F7154h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820F7154h case   13:*/		return 0x820F7158;
		  /* 820F7158h */ case   14:  		/* lwz R3, <#[R31 + 260]> */
		/* 820F7158h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000104) );
		/* 820F7158h case   14:*/		return 0x820F715C;
		  /* 820F715Ch */ case   15:  		/* bl 19900 */
		/* 820F715Ch case   15:*/		regs.LR = 0x820F7160; return 0x820FBF18;
		/* 820F715Ch case   15:*/		return 0x820F7160;
		  /* 820F7160h */ case   16:  		/* lis R4, 1 */
		/* 820F7160h case   16:*/		cpu::op::lis<0>(regs,&regs.R4,0x1);
		/* 820F7160h case   16:*/		return 0x820F7164;
		  /* 820F7164h */ case   17:  		/* li R11, 0 */
		/* 820F7164h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F7164h case   17:*/		return 0x820F7168;
		  /* 820F7168h */ case   18:  		/* lwz R8, <#[R1 + 112]> */
		/* 820F7168h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000070) );
		/* 820F7168h case   18:*/		return 0x820F716C;
		  /* 820F716Ch */ case   19:  		/* mr R10, R28 */
		/* 820F716Ch case   19:*/		regs.R10 = regs.R28;
		/* 820F716Ch case   19:*/		return 0x820F7170;
		  /* 820F7170h */ case   20:  		/* lwz R7, <#[R1 + 116]> */
		/* 820F7170h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000074) );
		/* 820F7170h case   20:*/		return 0x820F7174;
		  /* 820F7174h */ case   21:  		/* li R9, 0 */
		/* 820F7174h case   21:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F7174h case   21:*/		return 0x820F7178;
		  /* 820F7178h */ case   22:  		/* stw R11, <#[R1 + 108]> */
		/* 820F7178h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 820F7178h case   22:*/		return 0x820F717C;
		  /* 820F717Ch */ case   23:  		/* mr R6, R30 */
		/* 820F717Ch case   23:*/		regs.R6 = regs.R30;
		/* 820F717Ch case   23:*/		return 0x820F7180;
		  /* 820F7180h */ case   24:  		/* stw R11, <#[R1 + 100]> */
		/* 820F7180h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 820F7180h case   24:*/		return 0x820F7184;
		  /* 820F7184h */ case   25:  		/* mr R5, R29 */
		/* 820F7184h case   25:*/		regs.R5 = regs.R29;
		/* 820F7184h case   25:*/		return 0x820F7188;
		  /* 820F7188h */ case   26:  		/* stw R11, <#[R1 + 92]> */
		/* 820F7188h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F7188h case   26:*/		return 0x820F718C;
		  /* 820F718Ch */ case   27:  		/* ori R4, R4, 66 */
		/* 820F718Ch case   27:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x42);
		/* 820F718Ch case   27:*/		return 0x820F7190;
		  /* 820F7190h */ case   28:  		/* stw R11, <#[R1 + 84]> */
		/* 820F7190h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820F7190h case   28:*/		return 0x820F7194;
		  /* 820F7194h */ case   29:  		/* mr R3, R31 */
		/* 820F7194h case   29:*/		regs.R3 = regs.R31;
		/* 820F7194h case   29:*/		return 0x820F7198;
		  /* 820F7198h */ case   30:  		/* bl -3640 */
		/* 820F7198h case   30:*/		regs.LR = 0x820F719C; return 0x820F6360;
		/* 820F7198h case   30:*/		return 0x820F719C;
		  /* 820F719Ch */ case   31:  		/* addi R1, R1, 160 */
		/* 820F719Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820F719Ch case   31:*/		return 0x820F71A0;
	}
	return 0x820F71A0;
} // Block from 820F7120h-820F71A0h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820F71A0h
// Function '?EmitENDLOOP@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F71A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F71A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F71A0);
		  /* 820F71A0h */ case    0:  		/* b -417528 */
		/* 820F71A0h case    0:*/		return 0x820912A8;
		/* 820F71A0h case    0:*/		return 0x820F71A4;
		  /* 820F71A4h */ case    1:  		/* nop */
		/* 820F71A4h case    1:*/		cpu::op::nop();
		/* 820F71A4h case    1:*/		return 0x820F71A8;
	}
	return 0x820F71A8;
} // Block from 820F71A0h-820F71A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F71A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F71A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F71A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F71A8);
		  /* 820F71A8h */ case    0:  		/* mfspr R12, LR */
		/* 820F71A8h case    0:*/		regs.R12 = regs.LR;
		/* 820F71A8h case    0:*/		return 0x820F71AC;
		  /* 820F71ACh */ case    1:  		/* bl -417620 */
		/* 820F71ACh case    1:*/		regs.LR = 0x820F71B0; return 0x82091258;
		/* 820F71ACh case    1:*/		return 0x820F71B0;
		  /* 820F71B0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820F71B0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820F71B0h case    2:*/		return 0x820F71B4;
		  /* 820F71B4h */ case    3:  		/* mr R31, R3 */
		/* 820F71B4h case    3:*/		regs.R31 = regs.R3;
		/* 820F71B4h case    3:*/		return 0x820F71B8;
		  /* 820F71B8h */ case    4:  		/* lwz R3, <#[R3 + 260]> */
		/* 820F71B8h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000104) );
		/* 820F71B8h case    4:*/		return 0x820F71BC;
		  /* 820F71BCh */ case    5:  		/* addi R5, R1, 112 */
		/* 820F71BCh case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820F71BCh case    5:*/		return 0x820F71C0;
		  /* 820F71C0h */ case    6:  		/* li R4, 0 */
		/* 820F71C0h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F71C0h case    6:*/		return 0x820F71C4;
		  /* 820F71C4h */ case    7:  		/* lwz R11, <#[R3]> */
		/* 820F71C4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F71C4h case    7:*/		return 0x820F71C8;
		  /* 820F71C8h */ case    8:  		/* lwz R30, <#[R3 + 12]> */
		/* 820F71C8h case    8:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x0000000C) );
		/* 820F71C8h case    8:*/		return 0x820F71CC;
		  /* 820F71CCh */ case    9:  		/* lwz R29, <#[R3 + 16]> */
		/* 820F71CCh case    9:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000010) );
		/* 820F71CCh case    9:*/		return 0x820F71D0;
		  /* 820F71D0h */ case   10:  		/* rlwinm R28, R11, 0, 12, 31 */
		/* 820F71D0h case   10:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R28,regs.R11);
		/* 820F71D0h case   10:*/		return 0x820F71D4;
		  /* 820F71D4h */ case   11:  		/* bl 19780 */
		/* 820F71D4h case   11:*/		regs.LR = 0x820F71D8; return 0x820FBF18;
		/* 820F71D4h case   11:*/		return 0x820F71D8;
		  /* 820F71D8h */ case   12:  		/* addi R5, R1, 116 */
		/* 820F71D8h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x74);
		/* 820F71D8h case   12:*/		return 0x820F71DC;
		  /* 820F71DCh */ case   13:  		/* li R4, 1 */
		/* 820F71DCh case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820F71DCh case   13:*/		return 0x820F71E0;
		  /* 820F71E0h */ case   14:  		/* lwz R3, <#[R31 + 260]> */
		/* 820F71E0h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000104) );
		/* 820F71E0h case   14:*/		return 0x820F71E4;
		  /* 820F71E4h */ case   15:  		/* bl 19764 */
		/* 820F71E4h case   15:*/		regs.LR = 0x820F71E8; return 0x820FBF18;
		/* 820F71E4h case   15:*/		return 0x820F71E8;
		  /* 820F71E8h */ case   16:  		/* lis R4, 2 */
		/* 820F71E8h case   16:*/		cpu::op::lis<0>(regs,&regs.R4,0x2);
		/* 820F71E8h case   16:*/		return 0x820F71EC;
		  /* 820F71ECh */ case   17:  		/* li R11, 0 */
		/* 820F71ECh case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F71ECh case   17:*/		return 0x820F71F0;
		  /* 820F71F0h */ case   18:  		/* lwz R8, <#[R1 + 112]> */
		/* 820F71F0h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000070) );
		/* 820F71F0h case   18:*/		return 0x820F71F4;
		  /* 820F71F4h */ case   19:  		/* mr R10, R28 */
		/* 820F71F4h case   19:*/		regs.R10 = regs.R28;
		/* 820F71F4h case   19:*/		return 0x820F71F8;
		  /* 820F71F8h */ case   20:  		/* lwz R7, <#[R1 + 116]> */
		/* 820F71F8h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000074) );
		/* 820F71F8h case   20:*/		return 0x820F71FC;
		  /* 820F71FCh */ case   21:  		/* li R9, 0 */
		/* 820F71FCh case   21:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F71FCh case   21:*/		return 0x820F7200;
		  /* 820F7200h */ case   22:  		/* stw R11, <#[R1 + 108]> */
		/* 820F7200h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 820F7200h case   22:*/		return 0x820F7204;
		  /* 820F7204h */ case   23:  		/* mr R6, R30 */
		/* 820F7204h case   23:*/		regs.R6 = regs.R30;
		/* 820F7204h case   23:*/		return 0x820F7208;
	}
	return 0x820F7208;
} // Block from 820F71A8h-820F7208h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820F7208h
// Function '?EmitENDLOOP_INC@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7208);
		  /* 820F7208h */ case    0:  		/* stw R11, <#[R1 + 100]> */
		/* 820F7208h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 820F7208h case    0:*/		return 0x820F720C;
		  /* 820F720Ch */ case    1:  		/* mr R5, R29 */
		/* 820F720Ch case    1:*/		regs.R5 = regs.R29;
		/* 820F720Ch case    1:*/		return 0x820F7210;
		  /* 820F7210h */ case    2:  		/* stw R11, <#[R1 + 92]> */
		/* 820F7210h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F7210h case    2:*/		return 0x820F7214;
		  /* 820F7214h */ case    3:  		/* ori R4, R4, 66 */
		/* 820F7214h case    3:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x42);
		/* 820F7214h case    3:*/		return 0x820F7218;
		  /* 820F7218h */ case    4:  		/* stw R11, <#[R1 + 84]> */
		/* 820F7218h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820F7218h case    4:*/		return 0x820F721C;
		  /* 820F721Ch */ case    5:  		/* mr R3, R31 */
		/* 820F721Ch case    5:*/		regs.R3 = regs.R31;
		/* 820F721Ch case    5:*/		return 0x820F7220;
		  /* 820F7220h */ case    6:  		/* bl -3776 */
		/* 820F7220h case    6:*/		regs.LR = 0x820F7224; return 0x820F6360;
		/* 820F7220h case    6:*/		return 0x820F7224;
		  /* 820F7224h */ case    7:  		/* addi R1, R1, 160 */
		/* 820F7224h case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820F7224h case    7:*/		return 0x820F7228;
		  /* 820F7228h */ case    8:  		/* b -417664 */
		/* 820F7228h case    8:*/		return 0x820912A8;
		/* 820F7228h case    8:*/		return 0x820F722C;
		  /* 820F722Ch */ case    9:  		/* nop */
		/* 820F722Ch case    9:*/		cpu::op::nop();
		/* 820F722Ch case    9:*/		return 0x820F7230;
	}
	return 0x820F7230;
} // Block from 820F7208h-820F7230h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F7230h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7230);
		  /* 820F7230h */ case    0:  		/* mfspr R12, LR */
		/* 820F7230h case    0:*/		regs.R12 = regs.LR;
		/* 820F7230h case    0:*/		return 0x820F7234;
		  /* 820F7234h */ case    1:  		/* bl -417756 */
		/* 820F7234h case    1:*/		regs.LR = 0x820F7238; return 0x82091258;
		/* 820F7234h case    1:*/		return 0x820F7238;
		  /* 820F7238h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820F7238h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820F7238h case    2:*/		return 0x820F723C;
		  /* 820F723Ch */ case    3:  		/* mr R31, R3 */
		/* 820F723Ch case    3:*/		regs.R31 = regs.R3;
		/* 820F723Ch case    3:*/		return 0x820F7240;
		  /* 820F7240h */ case    4:  		/* lwz R3, <#[R3 + 260]> */
		/* 820F7240h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000104) );
		/* 820F7240h case    4:*/		return 0x820F7244;
		  /* 820F7244h */ case    5:  		/* addi R5, R1, 112 */
		/* 820F7244h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820F7244h case    5:*/		return 0x820F7248;
		  /* 820F7248h */ case    6:  		/* li R4, 0 */
		/* 820F7248h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F7248h case    6:*/		return 0x820F724C;
		  /* 820F724Ch */ case    7:  		/* lwz R11, <#[R3]> */
		/* 820F724Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F724Ch case    7:*/		return 0x820F7250;
		  /* 820F7250h */ case    8:  		/* lwz R30, <#[R3 + 12]> */
		/* 820F7250h case    8:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x0000000C) );
		/* 820F7250h case    8:*/		return 0x820F7254;
		  /* 820F7254h */ case    9:  		/* lwz R29, <#[R3 + 16]> */
		/* 820F7254h case    9:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000010) );
		/* 820F7254h case    9:*/		return 0x820F7258;
		  /* 820F7258h */ case   10:  		/* rlwinm R28, R11, 0, 12, 31 */
		/* 820F7258h case   10:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R28,regs.R11);
		/* 820F7258h case   10:*/		return 0x820F725C;
		  /* 820F725Ch */ case   11:  		/* bl 19644 */
		/* 820F725Ch case   11:*/		regs.LR = 0x820F7260; return 0x820FBF18;
		/* 820F725Ch case   11:*/		return 0x820F7260;
		  /* 820F7260h */ case   12:  		/* addi R5, R1, 116 */
		/* 820F7260h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x74);
		/* 820F7260h case   12:*/		return 0x820F7264;
		  /* 820F7264h */ case   13:  		/* li R4, 1 */
		/* 820F7264h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820F7264h case   13:*/		return 0x820F7268;
		  /* 820F7268h */ case   14:  		/* lwz R3, <#[R31 + 260]> */
		/* 820F7268h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000104) );
		/* 820F7268h case   14:*/		return 0x820F726C;
		  /* 820F726Ch */ case   15:  		/* bl 19628 */
		/* 820F726Ch case   15:*/		regs.LR = 0x820F7270; return 0x820FBF18;
		/* 820F726Ch case   15:*/		return 0x820F7270;
	}
	return 0x820F7270;
} // Block from 820F7230h-820F7270h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820F7270h
// Function '?EmitBREAK@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7270);
		  /* 820F7270h */ case    0:  		/* li R11, 0 */
		/* 820F7270h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F7270h case    0:*/		return 0x820F7274;
		  /* 820F7274h */ case    1:  		/* mr R10, R28 */
		/* 820F7274h case    1:*/		regs.R10 = regs.R28;
		/* 820F7274h case    1:*/		return 0x820F7278;
		  /* 820F7278h */ case    2:  		/* lwz R8, <#[R1 + 112]> */
		/* 820F7278h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000070) );
		/* 820F7278h case    2:*/		return 0x820F727C;
		  /* 820F727Ch */ case    3:  		/* li R9, 0 */
		/* 820F727Ch case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F727Ch case    3:*/		return 0x820F7280;
		  /* 820F7280h */ case    4:  		/* lwz R7, <#[R1 + 116]> */
		/* 820F7280h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000074) );
		/* 820F7280h case    4:*/		return 0x820F7284;
		  /* 820F7284h */ case    5:  		/* mr R6, R30 */
		/* 820F7284h case    5:*/		regs.R6 = regs.R30;
		/* 820F7284h case    5:*/		return 0x820F7288;
		  /* 820F7288h */ case    6:  		/* stw R11, <#[R1 + 108]> */
		/* 820F7288h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 820F7288h case    6:*/		return 0x820F728C;
		  /* 820F728Ch */ case    7:  		/* mr R5, R29 */
		/* 820F728Ch case    7:*/		regs.R5 = regs.R29;
		/* 820F728Ch case    7:*/		return 0x820F7290;
		  /* 820F7290h */ case    8:  		/* stw R11, <#[R1 + 100]> */
		/* 820F7290h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 820F7290h case    8:*/		return 0x820F7294;
		  /* 820F7294h */ case    9:  		/* li R4, 95 */
		/* 820F7294h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x5F);
		/* 820F7294h case    9:*/		return 0x820F7298;
		  /* 820F7298h */ case   10:  		/* stw R11, <#[R1 + 92]> */
		/* 820F7298h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F7298h case   10:*/		return 0x820F729C;
		  /* 820F729Ch */ case   11:  		/* mr R3, R31 */
		/* 820F729Ch case   11:*/		regs.R3 = regs.R31;
		/* 820F729Ch case   11:*/		return 0x820F72A0;
		  /* 820F72A0h */ case   12:  		/* stw R11, <#[R1 + 84]> */
		/* 820F72A0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820F72A0h case   12:*/		return 0x820F72A4;
		  /* 820F72A4h */ case   13:  		/* bl -3908 */
		/* 820F72A4h case   13:*/		regs.LR = 0x820F72A8; return 0x820F6360;
		/* 820F72A4h case   13:*/		return 0x820F72A8;
		  /* 820F72A8h */ case   14:  		/* addi R1, R1, 160 */
		/* 820F72A8h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820F72A8h case   14:*/		return 0x820F72AC;
		  /* 820F72ACh */ case   15:  		/* b -417796 */
		/* 820F72ACh case   15:*/		return 0x820912A8;
		/* 820F72ACh case   15:*/		return 0x820F72B0;
	}
	return 0x820F72B0;
} // Block from 820F7270h-820F72B0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820F72B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F72B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F72B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F72B0);
		  /* 820F72B0h */ case    0:  		/* mfspr R12, LR */
		/* 820F72B0h case    0:*/		regs.R12 = regs.LR;
		/* 820F72B0h case    0:*/		return 0x820F72B4;
		  /* 820F72B4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820F72B4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F72B4h case    1:*/		return 0x820F72B8;
		  /* 820F72B8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820F72B8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F72B8h case    2:*/		return 0x820F72BC;
		  /* 820F72BCh */ case    3:  		/* stwu R1, <#[R1 - 128]> */
		/* 820F72BCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820F72BCh case    3:*/		return 0x820F72C0;
		  /* 820F72C0h */ case    4:  		/* lwz R10, <#[R3 + 260]> */
		/* 820F72C0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000104) );
		/* 820F72C0h case    4:*/		return 0x820F72C4;
		  /* 820F72C4h */ case    5:  		/* li R11, 0 */
		/* 820F72C4h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F72C4h case    5:*/		return 0x820F72C8;
		  /* 820F72C8h */ case    6:  		/* li R4, 90 */
		/* 820F72C8h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x5A);
		/* 820F72C8h case    6:*/		return 0x820F72CC;
		  /* 820F72CCh */ case    7:  		/* stw R11, <#[R1 + 108]> */
		/* 820F72CCh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 820F72CCh case    7:*/		return 0x820F72D0;
		  /* 820F72D0h */ case    8:  		/* stw R11, <#[R1 + 100]> */
		/* 820F72D0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 820F72D0h case    8:*/		return 0x820F72D4;
		  /* 820F72D4h */ case    9:  		/* stw R11, <#[R1 + 92]> */
		/* 820F72D4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F72D4h case    9:*/		return 0x820F72D8;
		  /* 820F72D8h */ case   10:  		/* lwz R9, <#[R10]> */
		/* 820F72D8h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820F72D8h case   10:*/		return 0x820F72DC;
		  /* 820F72DCh */ case   11:  		/* lwz R7, <#[R10 + 8]> */
		/* 820F72DCh case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000008) );
		/* 820F72DCh case   11:*/		return 0x820F72E0;
		  /* 820F72E0h */ case   12:  		/* rlwinm R31, R9, 0, 12, 31 */
		/* 820F72E0h case   12:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R31,regs.R9);
		/* 820F72E0h case   12:*/		return 0x820F72E4;
		  /* 820F72E4h */ case   13:  		/* lwz R6, <#[R10 + 12]> */
		/* 820F72E4h case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x0000000C) );
		/* 820F72E4h case   13:*/		return 0x820F72E8;
		  /* 820F72E8h */ case   14:  		/* lwz R5, <#[R10 + 16]> */
		/* 820F72E8h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000010) );
		/* 820F72E8h case   14:*/		return 0x820F72EC;
		  /* 820F72ECh */ case   15:  		/* stw R11, <#[R1 + 84]> */
		/* 820F72ECh case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820F72ECh case   15:*/		return 0x820F72F0;
		  /* 820F72F0h */ case   16:  		/* rlwinm R10, R31, 3, 0, 28 */
		/* 820F72F0h case   16:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R31);
		/* 820F72F0h case   16:*/		return 0x820F72F4;
		  /* 820F72F4h */ case   17:  		/* rlwinm R11, R31, 2, 0, 29 */
		/* 820F72F4h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R31);
		/* 820F72F4h case   17:*/		return 0x820F72F8;
		  /* 820F72F8h */ case   18:  		/* add R9, R10, R7 */
		/* 820F72F8h case   18:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R7);
		/* 820F72F8h case   18:*/		return 0x820F72FC;
		  /* 820F72FCh */ case   19:  		/* add R8, R11, R7 */
		/* 820F72FCh case   19:*/		cpu::op::add<0>(regs,&regs.R8,regs.R11,regs.R7);
		/* 820F72FCh case   19:*/		return 0x820F7300;
		  /* 820F7300h */ case   20:  		/* mr R10, R31 */
		/* 820F7300h case   20:*/		regs.R10 = regs.R31;
		/* 820F7300h case   20:*/		return 0x820F7304;
		  /* 820F7304h */ case   21:  		/* bl -4004 */
		/* 820F7304h case   21:*/		regs.LR = 0x820F7308; return 0x820F6360;
		/* 820F7304h case   21:*/		return 0x820F7308;
		  /* 820F7308h */ case   22:  		/* addi R1, R1, 128 */
		/* 820F7308h case   22:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820F7308h case   22:*/		return 0x820F730C;
		  /* 820F730Ch */ case   23:  		/* lwz R12, <#[R1 - 8]> */
		/* 820F730Ch case   23:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F730Ch case   23:*/		return 0x820F7310;
		  /* 820F7310h */ case   24:  		/* mtspr LR, R12 */
		/* 820F7310h case   24:*/		regs.LR = regs.R12;
		/* 820F7310h case   24:*/		return 0x820F7314;
		  /* 820F7314h */ case   25:  		/* ld R31, <#[R1 - 16]> */
		/* 820F7314h case   25:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F7314h case   25:*/		return 0x820F7318;
		  /* 820F7318h */ case   26:  		/* bclr 20, CR0_LT */
		/* 820F7318h case   26:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F7318h case   26:*/		return 0x820F731C;
	}
	return 0x820F731C;
} // Block from 820F72B0h-820F731Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 820F731Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F731C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F731C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F731C);
		  /* 820F731Ch */ case    0:  		/* nop */
		/* 820F731Ch case    0:*/		cpu::op::nop();
		/* 820F731Ch case    0:*/		return 0x820F7320;
	}
	return 0x820F7320;
} // Block from 820F731Ch-820F7320h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F7320h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7320);
		  /* 820F7320h */ case    0:  		/* mfspr R12, LR */
		/* 820F7320h case    0:*/		regs.R12 = regs.LR;
		/* 820F7320h case    0:*/		return 0x820F7324;
		  /* 820F7324h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820F7324h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F7324h case    1:*/		return 0x820F7328;
		  /* 820F7328h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820F7328h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820F7328h case    2:*/		return 0x820F732C;
		  /* 820F732Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820F732Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F732Ch case    3:*/		return 0x820F7330;
		  /* 820F7330h */ case    4:  		/* stwu R1, <#[R1 - 128]> */
		/* 820F7330h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820F7330h case    4:*/		return 0x820F7334;
		  /* 820F7334h */ case    5:  		/* lwz R11, <#[R3 + 108]> */
		/* 820F7334h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000006C) );
		/* 820F7334h case    5:*/		return 0x820F7338;
		  /* 820F7338h */ case    6:  		/* mr R31, R3 */
		/* 820F7338h case    6:*/		regs.R31 = regs.R3;
		/* 820F7338h case    6:*/		return 0x820F733C;
		  /* 820F733Ch */ case    7:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 820F733Ch case    7:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 820F733Ch case    7:*/		return 0x820F7340;
		  /* 820F7340h */ case    8:  		/* lwz R11, <#[R3 + 260]> */
		/* 820F7340h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000104) );
		/* 820F7340h case    8:*/		return 0x820F7344;
		  /* 820F7344h */ case    9:  		/* bc 12, CR0_EQ, 104 */
		/* 820F7344h case    9:*/		if ( regs.CR[0].eq ) { return 0x820F73AC;  }
		/* 820F7344h case    9:*/		return 0x820F7348;
		  /* 820F7348h */ case   10:  		/* lwz R8, <#[R11 + 4]> */
		/* 820F7348h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 820F7348h case   10:*/		return 0x820F734C;
		  /* 820F734Ch */ case   11:  		/* li R10, 0 */
		/* 820F734Ch case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820F734Ch case   11:*/		return 0x820F7350;
		  /* 820F7350h */ case   12:  		/* cmplwi CR6, R8, 0 */
		/* 820F7350h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820F7350h case   12:*/		return 0x820F7354;
		  /* 820F7354h */ case   13:  		/* bc 12, CR6_EQ, 56 */
		/* 820F7354h case   13:*/		if ( regs.CR[6].eq ) { return 0x820F738C;  }
		/* 820F7354h case   13:*/		return 0x820F7358;
		  /* 820F7358h */ case   14:  		/* lwz R7, <#[R3 + 20]> */
		/* 820F7358h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000014) );
		/* 820F7358h case   14:*/		return 0x820F735C;
		  /* 820F735Ch */ case   15:  		/* li R9, 0 */
		/* 820F735Ch case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F735Ch case   15:*/		return 0x820F7360;
		  /* 820F7360h */ case   16:  		/* lwz R6, <#[R11 + 8]> */
		/* 820F7360h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000008) );
		/* 820F7360h case   16:*/		return 0x820F7364;
		  /* 820F7364h */ case   17:  		/* lwzx R6, <#[R6 + R9]> */
		/* 820F7364h case   17:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R9 + 0x00000000) );
		/* 820F7364h case   17:*/		return 0x820F7368;
		  /* 820F7368h */ case   18:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820F7368h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820F7368h case   18:*/		return 0x820F736C;
		  /* 820F736Ch */ case   19:  		/* lwzx R6, <#[R6 + R7]> */
		/* 820F736Ch case   19:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R7 + 0x00000000) );
		/* 820F736Ch case   19:*/		return 0x820F7370;
		  /* 820F7370h */ case   20:  		/* lwz R6, <#[R6 + 16]> */
		/* 820F7370h case   20:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000010) );
		/* 820F7370h case   20:*/		return 0x820F7374;
		  /* 820F7374h */ case   21:  		/* cmplw CR6, R6, R10 */
		/* 820F7374h case   21:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 820F7374h case   21:*/		return 0x820F7378;
		  /* 820F7378h */ case   22:  		/* bc 4, CR6_EQ, 40 */
		/* 820F7378h case   22:*/		if ( !regs.CR[6].eq ) { return 0x820F73A0;  }
		/* 820F7378h case   22:*/		return 0x820F737C;
		  /* 820F737Ch */ case   23:  		/* addi R10, R10, 1 */
		/* 820F737Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820F737Ch case   23:*/		return 0x820F7380;
		  /* 820F7380h */ case   24:  		/* addi R9, R9, 4 */
		/* 820F7380h case   24:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820F7380h case   24:*/		return 0x820F7384;
		  /* 820F7384h */ case   25:  		/* cmplw CR6, R10, R8 */
		/* 820F7384h case   25:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 820F7384h case   25:*/		return 0x820F7388;
		  /* 820F7388h */ case   26:  		/* bc 12, CR6_LT, -40 */
		/* 820F7388h case   26:*/		if ( regs.CR[6].lt ) { return 0x820F7360;  }
		/* 820F7388h case   26:*/		return 0x820F738C;
	}
	return 0x820F738C;
} // Block from 820F7320h-820F738Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 820F738Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F738C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F738C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F738C);
		  /* 820F738Ch */ case    0:  		/* cmplwi CR6, R8, 3 */
		/* 820F738Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000003);
		/* 820F738Ch case    0:*/		return 0x820F7390;
		  /* 820F7390h */ case    1:  		/* bc 12, CR6_EQ, 52 */
		/* 820F7390h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F73C4;  }
		/* 820F7390h case    1:*/		return 0x820F7394;
		  /* 820F7394h */ case    2:  		/* lis R10, -32254 */
		/* 820F7394h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820F7394h case    2:*/		return 0x820F7398;
		  /* 820F7398h */ case    3:  		/* addi R6, R10, -15360 */
		/* 820F7398h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFC400);
		/* 820F7398h case    3:*/		return 0x820F739C;
		  /* 820F739Ch */ case    4:  		/* b 372 */
		/* 820F739Ch case    4:*/		return 0x820F7510;
		/* 820F739Ch case    4:*/		return 0x820F73A0;
	}
	return 0x820F73A0;
} // Block from 820F738Ch-820F73A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F73A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F73A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F73A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F73A0);
		  /* 820F73A0h */ case    0:  		/* lis R10, -32254 */
		/* 820F73A0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820F73A0h case    0:*/		return 0x820F73A4;
		  /* 820F73A4h */ case    1:  		/* addi R6, R10, -15396 */
		/* 820F73A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFC3DC);
		/* 820F73A4h case    1:*/		return 0x820F73A8;
		  /* 820F73A8h */ case    2:  		/* b 360 */
		/* 820F73A8h case    2:*/		return 0x820F7510;
		/* 820F73A8h case    2:*/		return 0x820F73AC;
	}
	return 0x820F73AC;
} // Block from 820F73A0h-820F73ACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F73ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F73AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F73AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F73AC);
		  /* 820F73ACh */ case    0:  		/* lwz R10, <#[R11 + 4]> */
		/* 820F73ACh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820F73ACh case    0:*/		return 0x820F73B0;
		  /* 820F73B0h */ case    1:  		/* cmplwi CR6, R10, 4 */
		/* 820F73B0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 820F73B0h case    1:*/		return 0x820F73B4;
		  /* 820F73B4h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 820F73B4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F73C4;  }
		/* 820F73B4h case    2:*/		return 0x820F73B8;
		  /* 820F73B8h */ case    3:  		/* lis R10, -32254 */
		/* 820F73B8h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820F73B8h case    3:*/		return 0x820F73BC;
		  /* 820F73BCh */ case    4:  		/* addi R6, R10, -15460 */
		/* 820F73BCh case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFC39C);
		/* 820F73BCh case    4:*/		return 0x820F73C0;
		  /* 820F73C0h */ case    5:  		/* b 336 */
		/* 820F73C0h case    5:*/		return 0x820F7510;
		/* 820F73C0h case    5:*/		return 0x820F73C4;
	}
	return 0x820F73C4;
} // Block from 820F73ACh-820F73C4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F73C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F73C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F73C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F73C4);
		  /* 820F73C4h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 820F73C4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820F73C4h case    0:*/		return 0x820F73C8;
		  /* 820F73C8h */ case    1:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F73C8h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F73C8h case    1:*/		return 0x820F73CC;
		  /* 820F73CCh */ case    2:  		/* lwz R8, <#[R31 + 128]> */
		/* 820F73CCh case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000080) );
		/* 820F73CCh case    2:*/		return 0x820F73D0;
		  /* 820F73D0h */ case    3:  		/* lwz R10, <#[R10]> */
		/* 820F73D0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820F73D0h case    3:*/		return 0x820F73D4;
		  /* 820F73D4h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F73D4h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F73D4h case    4:*/		return 0x820F73D8;
		  /* 820F73D8h */ case    5:  		/* lwzx R4, <#[R10 + R9]> */
		/* 820F73D8h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820F73D8h case    5:*/		return 0x820F73DC;
		  /* 820F73DCh */ case    6:  		/* lwz R10, <#[R4 + 4]> */
		/* 820F73DCh case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 820F73DCh case    6:*/		return 0x820F73E0;
		  /* 820F73E0h */ case    7:  		/* cmplw CR6, R10, R8 */
		/* 820F73E0h case    7:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 820F73E0h case    7:*/		return 0x820F73E4;
		  /* 820F73E4h */ case    8:  		/* bc 4, CR6_EQ, 56 */
		/* 820F73E4h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820F741C;  }
		/* 820F73E4h case    8:*/		return 0x820F73E8;
		  /* 820F73E8h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 820F73E8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F73E8h case    9:*/		return 0x820F73EC;
		  /* 820F73ECh */ case   10:  		/* addi R6, R1, 80 */
		/* 820F73ECh case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 820F73ECh case   10:*/		return 0x820F73F0;
		  /* 820F73F0h */ case   11:  		/* addi R5, R1, 84 */
		/* 820F73F0h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 820F73F0h case   11:*/		return 0x820F73F4;
		  /* 820F73F4h */ case   12:  		/* mr R3, R31 */
		/* 820F73F4h case   12:*/		regs.R3 = regs.R31;
		/* 820F73F4h case   12:*/		return 0x820F73F8;
		  /* 820F73F8h */ case   13:  		/* lwz R11, <#[R11 + 348]> */
		/* 820F73F8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000015C) );
		/* 820F73F8h case   13:*/		return 0x820F73FC;
		  /* 820F73FCh */ case   14:  		/* mtspr CTR, R11 */
		/* 820F73FCh case   14:*/		regs.CTR = regs.R11;
		/* 820F73FCh case   14:*/		return 0x820F7400;
		  /* 820F7400h */ case   15:  		/* bcctrl 20, CR0_LT */
		/* 820F7400h case   15:*/		if ( 1 ) { regs.LR = 0x820F7404; return (uint32)regs.CTR; }
		/* 820F7400h case   15:*/		return 0x820F7404;
		  /* 820F7404h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 820F7404h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7404h case   16:*/		return 0x820F7408;
		  /* 820F7408h */ case   17:  		/* bc 4, CR0_LT, 52 */
		/* 820F7408h case   17:*/		if ( !regs.CR[0].lt ) { return 0x820F743C;  }
		/* 820F7408h case   17:*/		return 0x820F740C;
		  /* 820F740Ch */ case   18:  		/* lis R11, -32254 */
		/* 820F740Ch case   18:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F740Ch case   18:*/		return 0x820F7410;
		  /* 820F7410h */ case   19:  		/* li R4, 0 */
		/* 820F7410h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F7410h case   19:*/		return 0x820F7414;
		  /* 820F7414h */ case   20:  		/* addi R6, R11, -17728 */
		/* 820F7414h case   20:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFBAC0);
		/* 820F7414h case   20:*/		return 0x820F7418;
		  /* 820F7418h */ case   21:  		/* b 252 */
		/* 820F7418h case   21:*/		return 0x820F7514;
		/* 820F7418h case   21:*/		return 0x820F741C;
	}
	return 0x820F741C;
} // Block from 820F73C4h-820F741Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 820F741Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F741C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F741C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F741C);
		  /* 820F741Ch */ case    0:  		/* lwz R9, <#[R31 + 136]> */
		/* 820F741Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000088) );
		/* 820F741Ch case    0:*/		return 0x820F7420;
		  /* 820F7420h */ case    1:  		/* cmplw CR6, R10, R9 */
		/* 820F7420h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820F7420h case    1:*/		return 0x820F7424;
		  /* 820F7424h */ case    2:  		/* bc 4, CR6_EQ, 228 */
		/* 820F7424h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820F7508;  }
		/* 820F7424h case    2:*/		return 0x820F7428;
		  /* 820F7428h */ case    3:  		/* li R11, 0 */
		/* 820F7428h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F7428h case    3:*/		return 0x820F742C;
		  /* 820F742Ch */ case    4:  		/* stw R11, <#[R1 + 80]> */
		/* 820F742Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820F742Ch case    4:*/		return 0x820F7430;
		  /* 820F7430h */ case    5:  		/* lwz R10, <#[R4 + 12]> */
		/* 820F7430h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000000C) );
		/* 820F7430h case    5:*/		return 0x820F7434;
		  /* 820F7434h */ case    6:  		/* stw R10, <#[R1 + 84]> */
		/* 820F7434h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 820F7434h case    6:*/		return 0x820F7438;
		  /* 820F7438h */ case    7:  		/* b 8 */
		/* 820F7438h case    7:*/		return 0x820F7440;
		/* 820F7438h case    7:*/		return 0x820F743C;
	}
	return 0x820F743C;
} // Block from 820F741Ch-820F743Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820F743Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F743C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F743C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F743C);
		  /* 820F743Ch */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 820F743Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820F743Ch case    0:*/		return 0x820F7440;
	}
	return 0x820F7440;
} // Block from 820F743Ch-820F7440h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F7440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7440);
		  /* 820F7440h */ case    0:  		/* lis R10, -128 */
		/* 820F7440h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFF80);
		/* 820F7440h case    0:*/		return 0x820F7444;
		  /* 820F7444h */ case    1:  		/* lwz R9, <#[R1 + 84]> */
		/* 820F7444h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 820F7444h case    1:*/		return 0x820F7448;
		  /* 820F7448h */ case    2:  		/* rlwinm R8, R11, 0, 27, 28 */
		/* 820F7448h case    2:*/		cpu::op::rlwinm<0,0,27,28>(regs,&regs.R8,regs.R11);
		/* 820F7448h case    2:*/		return 0x820F744C;
		  /* 820F744Ch */ case    3:  		/* rlwimi R10, R11, 20, 9, 11 */
		/* 820F744Ch case    3:*/		cpu::op::rlwimi<0,20,9,11>(regs,&regs.R10,regs.R11);
		/* 820F744Ch case    3:*/		return 0x820F7450;
		  /* 820F7450h */ case    4:  		/* rlwinm R11, R9, 0, 21, 31 */
		/* 820F7450h case    4:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R11,regs.R9);
		/* 820F7450h case    4:*/		return 0x820F7454;
		  /* 820F7454h */ case    5:  		/* or R10, R10, R8 */
		/* 820F7454h case    5:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 820F7454h case    5:*/		return 0x820F7458;
		  /* 820F7458h */ case    6:  		/* li R4, 65 */
		/* 820F7458h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x41);
		/* 820F7458h case    6:*/		return 0x820F745C;
		  /* 820F745Ch */ case    7:  		/* rlwinm R10, R10, 8, 0, 23 */
		/* 820F745Ch case    7:*/		cpu::op::rlwinm<0,8,0,23>(regs,&regs.R10,regs.R10);
		/* 820F745Ch case    7:*/		return 0x820F7460;
		  /* 820F7460h */ case    8:  		/* mr R3, R31 */
		/* 820F7460h case    8:*/		regs.R3 = regs.R31;
		/* 820F7460h case    8:*/		return 0x820F7464;
		  /* 820F7464h */ case    9:  		/* or R30, R10, R11 */
		/* 820F7464h case    9:*/		cpu::op::or<0>(regs,&regs.R30,regs.R10,regs.R11);
		/* 820F7464h case    9:*/		return 0x820F7468;
		  /* 820F7468h */ case   10:  		/* bl -4984 */
		/* 820F7468h case   10:*/		regs.LR = 0x820F746C; return 0x820F60F0;
		/* 820F7468h case   10:*/		return 0x820F746C;
		  /* 820F746Ch */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820F746Ch case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F746Ch case   11:*/		return 0x820F7470;
		  /* 820F7470h */ case   12:  		/* bc 12, CR0_LT, 184 */
		/* 820F7470h case   12:*/		if ( regs.CR[0].lt ) { return 0x820F7528;  }
		/* 820F7470h case   12:*/		return 0x820F7474;
		  /* 820F7474h */ case   13:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F7474h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F7474h case   13:*/		return 0x820F7478;
		  /* 820F7478h */ case   14:  		/* addi R5, R1, 88 */
		/* 820F7478h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 820F7478h case   14:*/		return 0x820F747C;
		  /* 820F747Ch */ case   15:  		/* lwz R10, <#[R31]> */
		/* 820F747Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F747Ch case   15:*/		return 0x820F7480;
	}
	return 0x820F7480;
} // Block from 820F7440h-820F7480h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820F7480h
// Function '?EmitTEX@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7480);
		  /* 820F7480h */ case    0:  		/* mr R3, R31 */
		/* 820F7480h case    0:*/		regs.R3 = regs.R31;
		/* 820F7480h case    0:*/		return 0x820F7484;
		  /* 820F7484h */ case    1:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F7484h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F7484h case    1:*/		return 0x820F7488;
		  /* 820F7488h */ case    2:  		/* lwz R11, <#[R11 + 16]> */
		/* 820F7488h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820F7488h case    2:*/		return 0x820F748C;
		  /* 820F748Ch */ case    3:  		/* lwz R10, <#[R10 + 336]> */
		/* 820F748Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000150) );
		/* 820F748Ch case    3:*/		return 0x820F7490;
		  /* 820F7490h */ case    4:  		/* lwz R11, <#[R11]> */
		/* 820F7490h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F7490h case    4:*/		return 0x820F7494;
		  /* 820F7494h */ case    5:  		/* mtspr CTR, R10 */
		/* 820F7494h case    5:*/		regs.CTR = regs.R10;
		/* 820F7494h case    5:*/		return 0x820F7498;
		  /* 820F7498h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F7498h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F7498h case    6:*/		return 0x820F749C;
		  /* 820F749Ch */ case    7:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F749Ch case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F749Ch case    7:*/		return 0x820F74A0;
		  /* 820F74A0h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 820F74A0h case    8:*/		if ( 1 ) { regs.LR = 0x820F74A4; return (uint32)regs.CTR; }
		/* 820F74A0h case    8:*/		return 0x820F74A4;
		  /* 820F74A4h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820F74A4h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F74A4h case    9:*/		return 0x820F74A8;
		  /* 820F74A8h */ case   10:  		/* bc 12, CR0_LT, 128 */
		/* 820F74A8h case   10:*/		if ( regs.CR[0].lt ) { return 0x820F7528;  }
		/* 820F74A8h case   10:*/		return 0x820F74AC;
		  /* 820F74ACh */ case   11:  		/* lwz R11, <#[R31]> */
		/* 820F74ACh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F74ACh case   11:*/		return 0x820F74B0;
		  /* 820F74B0h */ case   12:  		/* lis R5, 15 */
		/* 820F74B0h case   12:*/		cpu::op::lis<0>(regs,&regs.R5,0xF);
		/* 820F74B0h case   12:*/		return 0x820F74B4;
		  /* 820F74B4h */ case   13:  		/* mr R4, R30 */
		/* 820F74B4h case   13:*/		regs.R4 = regs.R30;
		/* 820F74B4h case   13:*/		return 0x820F74B8;
		  /* 820F74B8h */ case   14:  		/* lwz R6, <#[R1 + 88]> */
		/* 820F74B8h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000058) );
		/* 820F74B8h case   14:*/		return 0x820F74BC;
		  /* 820F74BCh */ case   15:  		/* mr R3, R31 */
		/* 820F74BCh case   15:*/		regs.R3 = regs.R31;
		/* 820F74BCh case   15:*/		return 0x820F74C0;
		  /* 820F74C0h */ case   16:  		/* lwz R11, <#[R11 + 312]> */
		/* 820F74C0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000138) );
		/* 820F74C0h case   16:*/		return 0x820F74C4;
		  /* 820F74C4h */ case   17:  		/* mtspr CTR, R11 */
		/* 820F74C4h case   17:*/		regs.CTR = regs.R11;
		/* 820F74C4h case   17:*/		return 0x820F74C8;
		  /* 820F74C8h */ case   18:  		/* bcctrl 20, CR0_LT */
		/* 820F74C8h case   18:*/		if ( 1 ) { regs.LR = 0x820F74CC; return (uint32)regs.CTR; }
		/* 820F74C8h case   18:*/		return 0x820F74CC;
		  /* 820F74CCh */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 820F74CCh case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F74CCh case   19:*/		return 0x820F74D0;
		  /* 820F74D0h */ case   20:  		/* bc 12, CR0_LT, 88 */
		/* 820F74D0h case   20:*/		if ( regs.CR[0].lt ) { return 0x820F7528;  }
		/* 820F74D0h case   20:*/		return 0x820F74D4;
		  /* 820F74D4h */ case   21:  		/* lwz R11, <#[R31]> */
		/* 820F74D4h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F74D4h case   21:*/		return 0x820F74D8;
		  /* 820F74D8h */ case   22:  		/* mr R3, R31 */
		/* 820F74D8h case   22:*/		regs.R3 = regs.R31;
		/* 820F74D8h case   22:*/		return 0x820F74DC;
		  /* 820F74DCh */ case   23:  		/* lwz R11, <#[R11 + 308]> */
		/* 820F74DCh case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000134) );
		/* 820F74DCh case   23:*/		return 0x820F74E0;
		  /* 820F74E0h */ case   24:  		/* mtspr CTR, R11 */
		/* 820F74E0h case   24:*/		regs.CTR = regs.R11;
		/* 820F74E0h case   24:*/		return 0x820F74E4;
		  /* 820F74E4h */ case   25:  		/* bcctrl 20, CR0_LT */
		/* 820F74E4h case   25:*/		if ( 1 ) { regs.LR = 0x820F74E8; return (uint32)regs.CTR; }
		/* 820F74E4h case   25:*/		return 0x820F74E8;
		  /* 820F74E8h */ case   26:  		/* cmpwi CR0, R3, 0 */
		/* 820F74E8h case   26:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F74E8h case   26:*/		return 0x820F74EC;
		  /* 820F74ECh */ case   27:  		/* bc 12, CR0_LT, 60 */
		/* 820F74ECh case   27:*/		if ( regs.CR[0].lt ) { return 0x820F7528;  }
		/* 820F74ECh case   27:*/		return 0x820F74F0;
		  /* 820F74F0h */ case   28:  		/* mr R3, R31 */
		/* 820F74F0h case   28:*/		regs.R3 = regs.R31;
		/* 820F74F0h case   28:*/		return 0x820F74F4;
		  /* 820F74F4h */ case   29:  		/* bl -39916 */
		/* 820F74F4h case   29:*/		regs.LR = 0x820F74F8; return 0x820ED908;
		/* 820F74F4h case   29:*/		return 0x820F74F8;
		  /* 820F74F8h */ case   30:  		/* cmpwi CR0, R3, 0 */
		/* 820F74F8h case   30:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F74F8h case   30:*/		return 0x820F74FC;
		  /* 820F74FCh */ case   31:  		/* bc 12, CR0_LT, 44 */
		/* 820F74FCh case   31:*/		if ( regs.CR[0].lt ) { return 0x820F7528;  }
		/* 820F74FCh case   31:*/		return 0x820F7500;
	}
	return 0x820F7500;
} // Block from 820F7480h-820F7500h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820F7500h
// Function '?EmitTEXDD@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7500);
		  /* 820F7500h */ case    0:  		/* li R3, 0 */
		/* 820F7500h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F7500h case    0:*/		return 0x820F7504;
		  /* 820F7504h */ case    1:  		/* b 36 */
		/* 820F7504h case    1:*/		return 0x820F7528;
		/* 820F7504h case    1:*/		return 0x820F7508;
	}
	return 0x820F7508;
} // Block from 820F7500h-820F7508h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F7508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7508);
		  /* 820F7508h */ case    0:  		/* lis R10, -32254 */
		/* 820F7508h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820F7508h case    0:*/		return 0x820F750C;
		  /* 820F750Ch */ case    1:  		/* addi R6, R10, -15512 */
		/* 820F750Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFC368);
		/* 820F750Ch case    1:*/		return 0x820F7510;
	}
	return 0x820F7510;
} // Block from 820F7508h-820F7510h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F7510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7510);
		  /* 820F7510h */ case    0:  		/* lwz R4, <#[R11 + 60]> */
		/* 820F7510h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000003C) );
		/* 820F7510h case    0:*/		return 0x820F7514;
	}
	return 0x820F7514;
} // Block from 820F7510h-820F7514h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F7514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7514);
		  /* 820F7514h */ case    0:  		/* li R5, 4500 */
		/* 820F7514h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x1194);
		/* 820F7514h case    0:*/		return 0x820F7518;
		  /* 820F7518h */ case    1:  		/* mr R3, R31 */
		/* 820F7518h case    1:*/		regs.R3 = regs.R31;
		/* 820F7518h case    1:*/		return 0x820F751C;
		  /* 820F751Ch */ case    2:  		/* bl 94740 */
		/* 820F751Ch case    2:*/		regs.LR = 0x820F7520; return 0x8210E730;
		/* 820F751Ch case    2:*/		return 0x820F7520;
		  /* 820F7520h */ case    3:  		/* lis R3, -32768 */
		/* 820F7520h case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820F7520h case    3:*/		return 0x820F7524;
		  /* 820F7524h */ case    4:  		/* ori R3, R3, 16389 */
		/* 820F7524h case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820F7524h case    4:*/		return 0x820F7528;
	}
	return 0x820F7528;
} // Block from 820F7514h-820F7528h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F7528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7528);
		  /* 820F7528h */ case    0:  		/* addi R1, R1, 128 */
		/* 820F7528h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820F7528h case    0:*/		return 0x820F752C;
		  /* 820F752Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820F752Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F752Ch case    1:*/		return 0x820F7530;
		  /* 820F7530h */ case    2:  		/* mtspr LR, R12 */
		/* 820F7530h case    2:*/		regs.LR = regs.R12;
		/* 820F7530h case    2:*/		return 0x820F7534;
		  /* 820F7534h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820F7534h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820F7534h case    3:*/		return 0x820F7538;
		  /* 820F7538h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820F7538h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F7538h case    4:*/		return 0x820F753C;
		  /* 820F753Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 820F753Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F753Ch case    5:*/		return 0x820F7540;
	}
	return 0x820F7540;
} // Block from 820F7528h-820F7540h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F7540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7540);
		  /* 820F7540h */ case    0:  		/* mfspr R12, LR */
		/* 820F7540h case    0:*/		regs.R12 = regs.LR;
		/* 820F7540h case    0:*/		return 0x820F7544;
		  /* 820F7544h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820F7544h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F7544h case    1:*/		return 0x820F7548;
		  /* 820F7548h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820F7548h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820F7548h case    2:*/		return 0x820F754C;
		  /* 820F754Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820F754Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F754Ch case    3:*/		return 0x820F7550;
		  /* 820F7550h */ case    4:  		/* stwu R1, <#[R1 - 144]> */
		/* 820F7550h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820F7550h case    4:*/		return 0x820F7554;
		  /* 820F7554h */ case    5:  		/* li R11, 2 */
		/* 820F7554h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820F7554h case    5:*/		return 0x820F7558;
		  /* 820F7558h */ case    6:  		/* lwz R8, <#[R3 + 260]> */
		/* 820F7558h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000104) );
		/* 820F7558h case    6:*/		return 0x820F755C;
		  /* 820F755Ch */ case    7:  		/* li R31, 0 */
		/* 820F755Ch case    7:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820F755Ch case    7:*/		return 0x820F7560;
		  /* 820F7560h */ case    8:  		/* lwz R7, <#[R3 + 20]> */
		/* 820F7560h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000014) );
		/* 820F7560h case    8:*/		return 0x820F7564;
		  /* 820F7564h */ case    9:  		/* addi R10, R1, 112 */
		/* 820F7564h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 820F7564h case    9:*/		return 0x820F7568;
		  /* 820F7568h */ case   10:  		/* lwz R5, <#[R3 + 16]> */
		/* 820F7568h case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000010) );
		/* 820F7568h case   10:*/		return 0x820F756C;
		  /* 820F756Ch */ case   11:  		/* mr R6, R31 */
		/* 820F756Ch case   11:*/		regs.R6 = regs.R31;
		/* 820F756Ch case   11:*/		return 0x820F7570;
		  /* 820F7570h */ case   12:  		/* mr R9, R31 */
		/* 820F7570h case   12:*/		regs.R9 = regs.R31;
		/* 820F7570h case   12:*/		return 0x820F7574;
		  /* 820F7574h */ case   13:  		/* addi R4, R10, -4 */
		/* 820F7574h case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0xFFFFFFFC);
		/* 820F7574h case   13:*/		return 0x820F7578;
		  /* 820F7578h */ case   14:  		/* mtspr CTR, R11 */
		/* 820F7578h case   14:*/		regs.CTR = regs.R11;
		/* 820F7578h case   14:*/		return 0x820F757C;
		  /* 820F757Ch */ case   15:  		/* lwz R11, <#[R8 + 16]> */
		/* 820F757Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000010) );
		/* 820F757Ch case   15:*/		return 0x820F7580;
		  /* 820F7580h */ case   16:  		/* lwzx R11, <#[R9 + R11]> */
		/* 820F7580h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820F7580h case   16:*/		return 0x820F7584;
		  /* 820F7584h */ case   17:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 820F7584h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 820F7584h case   17:*/		return 0x820F7588;
		  /* 820F7588h */ case   18:  		/* lwzx R10, <#[R10 + R7]> */
		/* 820F7588h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 820F7588h case   18:*/		return 0x820F758C;
		  /* 820F758Ch */ case   19:  		/* lwz R30, <#[R10 + 4]> */
		/* 820F758Ch case   19:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + 0x00000004) );
		/* 820F758Ch case   19:*/		return 0x820F7590;
		  /* 820F7590h */ case   20:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820F7590h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820F7590h case   20:*/		return 0x820F7594;
		  /* 820F7594h */ case   21:  		/* lwzx R30, <#[R30 + R5]> */
		/* 820F7594h case   21:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + regs.R5 + 0x00000000) );
		/* 820F7594h case   21:*/		return 0x820F7598;
		  /* 820F7598h */ case   22:  		/* lwz R30, <#[R30 + 4]> */
		/* 820F7598h case   22:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 820F7598h case   22:*/		return 0x820F759C;
		  /* 820F759Ch */ case   23:  		/* rlwinm. R30, R30, 0, 31, 31 */
		/* 820F759Ch case   23:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R30,regs.R30);
		/* 820F759Ch case   23:*/		return 0x820F75A0;
		  /* 820F75A0h */ case   24:  		/* bc 12, CR0_EQ, 16 */
		/* 820F75A0h case   24:*/		if ( regs.CR[0].eq ) { return 0x820F75B0;  }
		/* 820F75A0h case   24:*/		return 0x820F75A4;
		  /* 820F75A4h */ case   25:  		/* lwz R10, <#[R10 + 92]> */
		/* 820F75A4h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000005C) );
		/* 820F75A4h case   25:*/		return 0x820F75A8;
		  /* 820F75A8h */ case   26:  		/* cmplwi CR6, R10, 0 */
		/* 820F75A8h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F75A8h case   26:*/		return 0x820F75AC;
		  /* 820F75ACh */ case   27:  		/* bc 12, CR6_EQ, 12 */
		/* 820F75ACh case   27:*/		if ( regs.CR[6].eq ) { return 0x820F75B8;  }
		/* 820F75ACh case   27:*/		return 0x820F75B0;
	}
	return 0x820F75B0;
} // Block from 820F7540h-820F75B0h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820F75B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F75B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F75B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F75B0);
		  /* 820F75B0h */ case    0:  		/* stwu R11, <#[R4 + 4]> */
		/* 820F75B0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000004) );
		regs.R4 = (uint32)(regs.R4 + 0x00000004);
		/* 820F75B0h case    0:*/		return 0x820F75B4;
		  /* 820F75B4h */ case    1:  		/* addi R6, R6, 1 */
		/* 820F75B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820F75B4h case    1:*/		return 0x820F75B8;
	}
	return 0x820F75B8;
} // Block from 820F75B0h-820F75B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F75B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F75B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F75B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F75B8);
		  /* 820F75B8h */ case    0:  		/* addi R9, R9, 4 */
		/* 820F75B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820F75B8h case    0:*/		return 0x820F75BC;
		  /* 820F75BCh */ case    1:  		/* bc 16, CR0_LT, -64 */
		/* 820F75BCh case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F757C;  }
		/* 820F75BCh case    1:*/		return 0x820F75C0;
		  /* 820F75C0h */ case    2:  		/* cmplwi CR6, R6, 0 */
		/* 820F75C0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820F75C0h case    2:*/		return 0x820F75C4;
		  /* 820F75C4h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 820F75C4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820F75D0;  }
		/* 820F75C4h case    3:*/		return 0x820F75C8;
		  /* 820F75C8h */ case    4:  		/* li R3, 0 */
		/* 820F75C8h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F75C8h case    4:*/		return 0x820F75CC;
		  /* 820F75CCh */ case    5:  		/* b 76 */
		/* 820F75CCh case    5:*/		return 0x820F7618;
		/* 820F75CCh case    5:*/		return 0x820F75D0;
	}
	return 0x820F75D0;
} // Block from 820F75B8h-820F75D0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F75D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F75D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F75D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F75D0);
		  /* 820F75D0h */ case    0:  		/* lwz R11, <#[R3 + 400]> */
		/* 820F75D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000190) );
		/* 820F75D0h case    0:*/		return 0x820F75D4;
		  /* 820F75D4h */ case    1:  		/* lwz R7, <#[R8 + 8]> */
		/* 820F75D4h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x00000008) );
		/* 820F75D4h case    1:*/		return 0x820F75D8;
		  /* 820F75D8h */ case    2:  		/* addi R8, R3, 404 */
		/* 820F75D8h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R3,0x194);
		/* 820F75D8h case    2:*/		return 0x820F75DC;
		  /* 820F75DCh */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 820F75DCh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820F75DCh case    3:*/		return 0x820F75E0;
		  /* 820F75E0h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 820F75E0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820F75EC;  }
		/* 820F75E0h case    4:*/		return 0x820F75E4;
		  /* 820F75E4h */ case    5:  		/* mr R8, R31 */
		/* 820F75E4h case    5:*/		regs.R8 = regs.R31;
		/* 820F75E4h case    5:*/		return 0x820F75E8;
		  /* 820F75E8h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 820F75E8h case    6:*/		if ( regs.CR[6].eq ) { return 0x820F75F4;  }
		/* 820F75E8h case    6:*/		return 0x820F75EC;
	}
	return 0x820F75EC;
} // Block from 820F75D0h-820F75ECh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F75ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F75EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F75EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F75EC);
		  /* 820F75ECh */ case    0:  		/* addi R9, R3, 420 */
		/* 820F75ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x1A4);
		/* 820F75ECh case    0:*/		return 0x820F75F0;
		  /* 820F75F0h */ case    1:  		/* b 8 */
		/* 820F75F0h case    1:*/		return 0x820F75F8;
		/* 820F75F0h case    1:*/		return 0x820F75F4;
	}
	return 0x820F75F4;
} // Block from 820F75ECh-820F75F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F75F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F75F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F75F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F75F4);
		  /* 820F75F4h */ case    0:  		/* mr R9, R31 */
		/* 820F75F4h case    0:*/		regs.R9 = regs.R31;
		/* 820F75F4h case    0:*/		return 0x820F75F8;
	}
	return 0x820F75F8;
} // Block from 820F75F4h-820F75F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F75F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F75F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F75F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F75F8);
		  /* 820F75F8h */ case    0:  		/* li R10, 4 */
		/* 820F75F8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 820F75F8h case    0:*/		return 0x820F75FC;
		  /* 820F75FCh */ case    1:  		/* stw R31, <#[R1 + 108]> */
		/* 820F75FCh case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x0000006C) );
		/* 820F75FCh case    1:*/		return 0x820F7600;
		  /* 820F7600h */ case    2:  		/* addi R5, R1, 112 */
		/* 820F7600h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820F7600h case    2:*/		return 0x820F7604;
		  /* 820F7604h */ case    3:  		/* stw R31, <#[R1 + 100]> */
		/* 820F7604h case    3:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000064) );
		/* 820F7604h case    3:*/		return 0x820F7608;
		  /* 820F7608h */ case    4:  		/* li R4, 37 */
		/* 820F7608h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x25);
		/* 820F7608h case    4:*/		return 0x820F760C;
		  /* 820F760Ch */ case    5:  		/* stw R31, <#[R1 + 92]> */
		/* 820F760Ch case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F760Ch case    5:*/		return 0x820F7610;
		  /* 820F7610h */ case    6:  		/* stw R31, <#[R1 + 84]> */
		/* 820F7610h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 820F7610h case    6:*/		return 0x820F7614;
		  /* 820F7614h */ case    7:  		/* bl -4788 */
		/* 820F7614h case    7:*/		regs.LR = 0x820F7618; return 0x820F6360;
		/* 820F7614h case    7:*/		return 0x820F7618;
	}
	return 0x820F7618;
} // Block from 820F75F8h-820F7618h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820F7618h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7618);
		  /* 820F7618h */ case    0:  		/* addi R1, R1, 144 */
		/* 820F7618h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820F7618h case    0:*/		return 0x820F761C;
		  /* 820F761Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820F761Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F761Ch case    1:*/		return 0x820F7620;
		  /* 820F7620h */ case    2:  		/* mtspr LR, R12 */
		/* 820F7620h case    2:*/		regs.LR = regs.R12;
		/* 820F7620h case    2:*/		return 0x820F7624;
		  /* 820F7624h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820F7624h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820F7624h case    3:*/		return 0x820F7628;
		  /* 820F7628h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820F7628h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F7628h case    4:*/		return 0x820F762C;
		  /* 820F762Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 820F762Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F762Ch case    5:*/		return 0x820F7630;
	}
	return 0x820F7630;
} // Block from 820F7618h-820F7630h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F7630h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7630);
		  /* 820F7630h */ case    0:  		/* mfspr R12, LR */
		/* 820F7630h case    0:*/		regs.R12 = regs.LR;
		/* 820F7630h case    0:*/		return 0x820F7634;
		  /* 820F7634h */ case    1:  		/* bl -418776 */
		/* 820F7634h case    1:*/		regs.LR = 0x820F7638; return 0x8209125C;
		/* 820F7634h case    1:*/		return 0x820F7638;
		  /* 820F7638h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820F7638h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820F7638h case    2:*/		return 0x820F763C;
		  /* 820F763Ch */ case    3:  		/* lwz R11, <#[R3 + 52]> */
		/* 820F763Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000034) );
		/* 820F763Ch case    3:*/		return 0x820F7640;
		  /* 820F7640h */ case    4:  		/* mr R31, R3 */
		/* 820F7640h case    4:*/		regs.R31 = regs.R3;
		/* 820F7640h case    4:*/		return 0x820F7644;
		  /* 820F7644h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820F7644h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F7644h case    5:*/		return 0x820F7648;
		  /* 820F7648h */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 820F7648h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820F7658;  }
		/* 820F7648h case    6:*/		return 0x820F764C;
		  /* 820F764Ch */ case    7:  		/* lis R3, -32768 */
		/* 820F764Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820F764Ch case    7:*/		return 0x820F7650;
		  /* 820F7650h */ case    8:  		/* ori R3, R3, 16385 */
		/* 820F7650h case    8:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4001);
		/* 820F7650h case    8:*/		return 0x820F7654;
		  /* 820F7654h */ case    9:  		/* b 544 */
		/* 820F7654h case    9:*/		return 0x820F7874;
		/* 820F7654h case    9:*/		return 0x820F7658;
	}
	return 0x820F7658;
} // Block from 820F7630h-820F7658h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F7658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7658);
		  /* 820F7658h */ case    0:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F7658h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F7658h case    0:*/		return 0x820F765C;
		  /* 820F765Ch */ case    1:  		/* lis R30, 4336 */
		/* 820F765Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R30,0x10F0);
		/* 820F765Ch case    1:*/		return 0x820F7660;
		  /* 820F7660h */ case    2:  		/* li R10, 0 */
		/* 820F7660h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820F7660h case    2:*/		return 0x820F7664;
		  /* 820F7664h */ case    3:  		/* lwz R9, <#[R11]> */
		/* 820F7664h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820F7664h case    3:*/		return 0x820F7668;
		  /* 820F7668h */ case    4:  		/* rlwinm R11, R9, 0, 0, 11 */
		/* 820F7668h case    4:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R9);
		/* 820F7668h case    4:*/		return 0x820F766C;
		  /* 820F766Ch */ case    5:  		/* rlwinm R29, R9, 0, 12, 31 */
		/* 820F766Ch case    5:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R29,regs.R9);
		/* 820F766Ch case    5:*/		return 0x820F7670;
		  /* 820F7670h */ case    6:  		/* cmplw CR6, R11, R30 */
		/* 820F7670h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 820F7670h case    6:*/		return 0x820F7674;
		  /* 820F7674h */ case    7:  		/* bc 12, CR6_EQ, 76 */
		/* 820F7674h case    7:*/		if ( regs.CR[6].eq ) { return 0x820F76C0;  }
		/* 820F7674h case    7:*/		return 0x820F7678;
		  /* 820F7678h */ case    8:  		/* lis R9, 29520 */
		/* 820F7678h case    8:*/		cpu::op::lis<0>(regs,&regs.R9,0x7350);
		/* 820F7678h case    8:*/		return 0x820F767C;
		  /* 820F767Ch */ case    9:  		/* cmplw CR6, R11, R9 */
		/* 820F767Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F767Ch case    9:*/		return 0x820F7680;
		  /* 820F7680h */ case   10:  		/* bc 12, CR6_EQ, 56 */
		/* 820F7680h case   10:*/		if ( regs.CR[6].eq ) { return 0x820F76B8;  }
		/* 820F7680h case   10:*/		return 0x820F7684;
		  /* 820F7684h */ case   11:  		/* lis R9, 29536 */
		/* 820F7684h case   11:*/		cpu::op::lis<0>(regs,&regs.R9,0x7360);
		/* 820F7684h case   11:*/		return 0x820F7688;
		  /* 820F7688h */ case   12:  		/* cmplw CR6, R11, R9 */
		/* 820F7688h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F7688h case   12:*/		return 0x820F768C;
		  /* 820F768Ch */ case   13:  		/* bc 12, CR6_EQ, 36 */
		/* 820F768Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x820F76B0;  }
		/* 820F768Ch case   13:*/		return 0x820F7690;
		  /* 820F7690h */ case   14:  		/* lis R9, 29552 */
		/* 820F7690h case   14:*/		cpu::op::lis<0>(regs,&regs.R9,0x7370);
		/* 820F7690h case   14:*/		return 0x820F7694;
		  /* 820F7694h */ case   15:  		/* cmplw CR6, R11, R9 */
		/* 820F7694h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F7694h case   15:*/		return 0x820F7698;
		  /* 820F7698h */ case   16:  		/* bc 12, CR6_EQ, 40 */
		/* 820F7698h case   16:*/		if ( regs.CR[6].eq ) { return 0x820F76C0;  }
		/* 820F7698h case   16:*/		return 0x820F769C;
		  /* 820F769Ch */ case   17:  		/* lis R9, 29568 */
		/* 820F769Ch case   17:*/		cpu::op::lis<0>(regs,&regs.R9,0x7380);
		/* 820F769Ch case   17:*/		return 0x820F76A0;
		  /* 820F76A0h */ case   18:  		/* cmplw CR6, R11, R9 */
		/* 820F76A0h case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F76A0h case   18:*/		return 0x820F76A4;
		  /* 820F76A4h */ case   19:  		/* bc 4, CR6_EQ, 32 */
		/* 820F76A4h case   19:*/		if ( !regs.CR[6].eq ) { return 0x820F76C4;  }
		/* 820F76A4h case   19:*/		return 0x820F76A8;
		  /* 820F76A8h */ case   20:  		/* li R10, 2 */
		/* 820F76A8h case   20:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 820F76A8h case   20:*/		return 0x820F76AC;
		  /* 820F76ACh */ case   21:  		/* b 24 */
		/* 820F76ACh case   21:*/		return 0x820F76C4;
		/* 820F76ACh case   21:*/		return 0x820F76B0;
	}
	return 0x820F76B0;
} // Block from 820F7658h-820F76B0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820F76B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F76B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F76B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F76B0);
		  /* 820F76B0h */ case    0:  		/* li R10, 4 */
		/* 820F76B0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 820F76B0h case    0:*/		return 0x820F76B4;
		  /* 820F76B4h */ case    1:  		/* b 16 */
		/* 820F76B4h case    1:*/		return 0x820F76C4;
		/* 820F76B4h case    1:*/		return 0x820F76B8;
	}
	return 0x820F76B8;
} // Block from 820F76B0h-820F76B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F76B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F76B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F76B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F76B8);
		  /* 820F76B8h */ case    0:  		/* li R10, 3 */
		/* 820F76B8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 820F76B8h case    0:*/		return 0x820F76BC;
		  /* 820F76BCh */ case    1:  		/* b 8 */
		/* 820F76BCh case    1:*/		return 0x820F76C4;
		/* 820F76BCh case    1:*/		return 0x820F76C0;
	}
	return 0x820F76C0;
} // Block from 820F76B8h-820F76C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F76C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F76C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F76C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F76C0);
		  /* 820F76C0h */ case    0:  		/* li R10, 5 */
		/* 820F76C0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 820F76C0h case    0:*/		return 0x820F76C4;
	}
	return 0x820F76C4;
} // Block from 820F76C0h-820F76C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F76C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F76C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F76C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F76C4);
		  /* 820F76C4h */ case    0:  		/* li R4, 94 */
		/* 820F76C4h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x5E);
		/* 820F76C4h case    0:*/		return 0x820F76C8;
		  /* 820F76C8h */ case    1:  		/* mr R3, R31 */
		/* 820F76C8h case    1:*/		regs.R3 = regs.R31;
		/* 820F76C8h case    1:*/		return 0x820F76CC;
		  /* 820F76CCh */ case    2:  		/* rlwimi R4, R10, 16, 0, 15 */
		/* 820F76CCh case    2:*/		cpu::op::rlwimi<0,16,0,15>(regs,&regs.R4,regs.R10);
		/* 820F76CCh case    2:*/		return 0x820F76D0;
		  /* 820F76D0h */ case    3:  		/* bl -5600 */
		/* 820F76D0h case    3:*/		regs.LR = 0x820F76D4; return 0x820F60F0;
		/* 820F76D0h case    3:*/		return 0x820F76D4;
		  /* 820F76D4h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820F76D4h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F76D4h case    4:*/		return 0x820F76D8;
		  /* 820F76D8h */ case    5:  		/* bc 12, CR0_LT, 412 */
		/* 820F76D8h case    5:*/		if ( regs.CR[0].lt ) { return 0x820F7874;  }
		/* 820F76D8h case    5:*/		return 0x820F76DC;
		  /* 820F76DCh */ case    6:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F76DCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F76DCh case    6:*/		return 0x820F76E0;
		  /* 820F76E0h */ case    7:  		/* addi R7, R1, 96 */
		/* 820F76E0h case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820F76E0h case    7:*/		return 0x820F76E4;
		  /* 820F76E4h */ case    8:  		/* lwz R10, <#[R31]> */
		/* 820F76E4h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F76E4h case    8:*/		return 0x820F76E8;
		  /* 820F76E8h */ case    9:  		/* li R6, 0 */
		/* 820F76E8h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820F76E8h case    9:*/		return 0x820F76EC;
		  /* 820F76ECh */ case   10:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F76ECh case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F76ECh case   10:*/		return 0x820F76F0;
		  /* 820F76F0h */ case   11:  		/* addi R5, R1, 80 */
		/* 820F76F0h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820F76F0h case   11:*/		return 0x820F76F4;
		  /* 820F76F4h */ case   12:  		/* mr R3, R31 */
		/* 820F76F4h case   12:*/		regs.R3 = regs.R31;
		/* 820F76F4h case   12:*/		return 0x820F76F8;
		  /* 820F76F8h */ case   13:  		/* lwz R11, <#[R11 + 16]> */
		/* 820F76F8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820F76F8h case   13:*/		return 0x820F76FC;
		  /* 820F76FCh */ case   14:  		/* lwz R10, <#[R10 + 320]> */
		/* 820F76FCh case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000140) );
		/* 820F76FCh case   14:*/		return 0x820F7700;
		  /* 820F7700h */ case   15:  		/* lwz R11, <#[R11]> */
		/* 820F7700h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F7700h case   15:*/		return 0x820F7704;
		  /* 820F7704h */ case   16:  		/* mtspr CTR, R10 */
		/* 820F7704h case   16:*/		regs.CTR = regs.R10;
		/* 820F7704h case   16:*/		return 0x820F7708;
		  /* 820F7708h */ case   17:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F7708h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F7708h case   17:*/		return 0x820F770C;
		  /* 820F770Ch */ case   18:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F770Ch case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F770Ch case   18:*/		return 0x820F7710;
		  /* 820F7710h */ case   19:  		/* bcctrl 20, CR0_LT */
		/* 820F7710h case   19:*/		if ( 1 ) { regs.LR = 0x820F7714; return (uint32)regs.CTR; }
		/* 820F7710h case   19:*/		return 0x820F7714;
		  /* 820F7714h */ case   20:  		/* cmpwi CR0, R3, 0 */
		/* 820F7714h case   20:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7714h case   20:*/		return 0x820F7718;
		  /* 820F7718h */ case   21:  		/* bc 12, CR0_LT, 348 */
		/* 820F7718h case   21:*/		if ( regs.CR[0].lt ) { return 0x820F7874;  }
		/* 820F7718h case   21:*/		return 0x820F771C;
		  /* 820F771Ch */ case   22:  		/* lwz R11, <#[R31]> */
		/* 820F771Ch case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F771Ch case   22:*/		return 0x820F7720;
		  /* 820F7720h */ case   23:  		/* addi R6, R1, 92 */
		/* 820F7720h case   23:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x5C);
		/* 820F7720h case   23:*/		return 0x820F7724;
		  /* 820F7724h */ case   24:  		/* lwz R10, <#[R31 + 260]> */
		/* 820F7724h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000104) );
		/* 820F7724h case   24:*/		return 0x820F7728;
		  /* 820F7728h */ case   25:  		/* mr R3, R31 */
		/* 820F7728h case   25:*/		regs.R3 = regs.R31;
		/* 820F7728h case   25:*/		return 0x820F772C;
		  /* 820F772Ch */ case   26:  		/* lwz R7, <#[R1 + 96]> */
		/* 820F772Ch case   26:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000060) );
		/* 820F772Ch case   26:*/		return 0x820F7730;
		  /* 820F7730h */ case   27:  		/* lwz R11, <#[R11 + 324]> */
		/* 820F7730h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000144) );
		/* 820F7730h case   27:*/		return 0x820F7734;
		  /* 820F7734h */ case   28:  		/* lwz R5, <#[R10 + 12]> */
		/* 820F7734h case   28:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x0000000C) );
		/* 820F7734h case   28:*/		return 0x820F7738;
		  /* 820F7738h */ case   29:  		/* lwz R4, <#[R10 + 16]> */
		/* 820F7738h case   29:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000010) );
		/* 820F7738h case   29:*/		return 0x820F773C;
		  /* 820F773Ch */ case   30:  		/* mtspr CTR, R11 */
		/* 820F773Ch case   30:*/		regs.CTR = regs.R11;
		/* 820F773Ch case   30:*/		return 0x820F7740;
		  /* 820F7740h */ case   31:  		/* bcctrl 20, CR0_LT */
		/* 820F7740h case   31:*/		if ( 1 ) { regs.LR = 0x820F7744; return (uint32)regs.CTR; }
		/* 820F7740h case   31:*/		return 0x820F7744;
		  /* 820F7744h */ case   32:  		/* cmpwi CR0, R3, 0 */
		/* 820F7744h case   32:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7744h case   32:*/		return 0x820F7748;
		  /* 820F7748h */ case   33:  		/* bc 12, CR0_LT, 300 */
		/* 820F7748h case   33:*/		if ( regs.CR[0].lt ) { return 0x820F7874;  }
		/* 820F7748h case   33:*/		return 0x820F774C;
		  /* 820F774Ch */ case   34:  		/* lwz R11, <#[R31]> */
		/* 820F774Ch case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F774Ch case   34:*/		return 0x820F7750;
		  /* 820F7750h */ case   35:  		/* li R6, 0 */
		/* 820F7750h case   35:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820F7750h case   35:*/		return 0x820F7754;
		  /* 820F7754h */ case   36:  		/* mr R3, R31 */
		/* 820F7754h case   36:*/		regs.R3 = regs.R31;
		/* 820F7754h case   36:*/		return 0x820F7758;
		  /* 820F7758h */ case   37:  		/* lwz R5, <#[R1 + 92]> */
		/* 820F7758h case   37:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F7758h case   37:*/		return 0x820F775C;
		  /* 820F775Ch */ case   38:  		/* lwz R4, <#[R1 + 80]> */
		/* 820F775Ch case   38:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 820F775Ch case   38:*/		return 0x820F7760;
		  /* 820F7760h */ case   39:  		/* lwz R11, <#[R11 + 312]> */
		/* 820F7760h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000138) );
		/* 820F7760h case   39:*/		return 0x820F7764;
		  /* 820F7764h */ case   40:  		/* mtspr CTR, R11 */
		/* 820F7764h case   40:*/		regs.CTR = regs.R11;
		/* 820F7764h case   40:*/		return 0x820F7768;
		  /* 820F7768h */ case   41:  		/* bcctrl 20, CR0_LT */
		/* 820F7768h case   41:*/		if ( 1 ) { regs.LR = 0x820F776C; return (uint32)regs.CTR; }
		/* 820F7768h case   41:*/		return 0x820F776C;
		  /* 820F776Ch */ case   42:  		/* cmpwi CR0, R3, 0 */
		/* 820F776Ch case   42:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F776Ch case   42:*/		return 0x820F7770;
		  /* 820F7770h */ case   43:  		/* bc 12, CR0_LT, 260 */
		/* 820F7770h case   43:*/		if ( regs.CR[0].lt ) { return 0x820F7874;  }
		/* 820F7770h case   43:*/		return 0x820F7774;
		  /* 820F7774h */ case   44:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F7774h case   44:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F7774h case   44:*/		return 0x820F7778;
		  /* 820F7778h */ case   45:  		/* addi R6, R1, 84 */
		/* 820F7778h case   45:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 820F7778h case   45:*/		return 0x820F777C;
		  /* 820F777Ch */ case   46:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F777Ch case   46:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F777Ch case   46:*/		return 0x820F7780;
		  /* 820F7780h */ case   47:  		/* addi R5, R1, 80 */
		/* 820F7780h case   47:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820F7780h case   47:*/		return 0x820F7784;
		  /* 820F7784h */ case   48:  		/* mr R3, R31 */
		/* 820F7784h case   48:*/		regs.R3 = regs.R31;
		/* 820F7784h case   48:*/		return 0x820F7788;
		  /* 820F7788h */ case   49:  		/* lwz R10, <#[R11]> */
		/* 820F7788h case   49:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820F7788h case   49:*/		return 0x820F778C;
		  /* 820F778Ch */ case   50:  		/* lwz R11, <#[R11 + 8]> */
		/* 820F778Ch case   50:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820F778Ch case   50:*/		return 0x820F7790;
		  /* 820F7790h */ case   51:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 820F7790h case   51:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 820F7790h case   51:*/		return 0x820F7794;
		  /* 820F7794h */ case   52:  		/* cmplw CR6, R10, R30 */
		/* 820F7794h case   52:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R30);
		/* 820F7794h case   52:*/		return 0x820F7798;
		  /* 820F7798h */ case   53:  		/* lwz R10, <#[R31]> */
		/* 820F7798h case   53:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7798h case   53:*/		return 0x820F779C;
		  /* 820F779Ch */ case   54:  		/* lwz R11, <#[R11]> */
		/* 820F779Ch case   54:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F779Ch case   54:*/		return 0x820F77A0;
		  /* 820F77A0h */ case   55:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F77A0h case   55:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F77A0h case   55:*/		return 0x820F77A4;
		  /* 820F77A4h */ case   56:  		/* lwz R10, <#[R10 + 328]> */
		/* 820F77A4h case   56:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000148) );
		/* 820F77A4h case   56:*/		return 0x820F77A8;
		  /* 820F77A8h */ case   57:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F77A8h case   57:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F77A8h case   57:*/		return 0x820F77AC;
		  /* 820F77ACh */ case   58:  		/* mtspr CTR, R10 */
		/* 820F77ACh case   58:*/		regs.CTR = regs.R10;
		/* 820F77ACh case   58:*/		return 0x820F77B0;
		  /* 820F77B0h */ case   59:  		/* bc 4, CR6_EQ, 204 */
		/* 820F77B0h case   59:*/		if ( !regs.CR[6].eq ) { return 0x820F787C;  }
		/* 820F77B0h case   59:*/		return 0x820F77B4;
		  /* 820F77B4h */ case   60:  		/* bcctrl 20, CR0_LT */
		/* 820F77B4h case   60:*/		if ( 1 ) { regs.LR = 0x820F77B8; return (uint32)regs.CTR; }
		/* 820F77B4h case   60:*/		return 0x820F77B8;
		  /* 820F77B8h */ case   61:  		/* cmpwi CR0, R3, 0 */
		/* 820F77B8h case   61:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F77B8h case   61:*/		return 0x820F77BC;
		  /* 820F77BCh */ case   62:  		/* bc 12, CR0_LT, 184 */
		/* 820F77BCh case   62:*/		if ( regs.CR[0].lt ) { return 0x820F7874;  }
		/* 820F77BCh case   62:*/		return 0x820F77C0;
		  /* 820F77C0h */ case   63:  		/* lwz R11, <#[R31]> */
		/* 820F77C0h case   63:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F77C0h case   63:*/		return 0x820F77C4;
		  /* 820F77C4h */ case   64:  		/* addi R7, R1, 88 */
		/* 820F77C4h case   64:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x58);
		/* 820F77C4h case   64:*/		return 0x820F77C8;
		  /* 820F77C8h */ case   65:  		/* lwz R10, <#[R31 + 260]> */
		/* 820F77C8h case   65:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000104) );
		/* 820F77C8h case   65:*/		return 0x820F77CC;
		  /* 820F77CCh */ case   66:  		/* mr R3, R31 */
		/* 820F77CCh case   66:*/		regs.R3 = regs.R31;
		/* 820F77CCh case   66:*/		return 0x820F77D0;
		  /* 820F77D0h */ case   67:  		/* lwz R6, <#[R1 + 92]> */
		/* 820F77D0h case   67:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F77D0h case   67:*/		return 0x820F77D4;
		  /* 820F77D4h */ case   68:  		/* lwz R11, <#[R11 + 332]> */
		/* 820F77D4h case   68:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000014C) );
		/* 820F77D4h case   68:*/		return 0x820F77D8;
		  /* 820F77D8h */ case   69:  		/* lwz R5, <#[R10 + 12]> */
		/* 820F77D8h case   69:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x0000000C) );
		/* 820F77D8h case   69:*/		return 0x820F77DC;
		  /* 820F77DCh */ case   70:  		/* lwz R4, <#[R10 + 8]> */
		/* 820F77DCh case   70:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000008) );
		/* 820F77DCh case   70:*/		return 0x820F77E0;
		  /* 820F77E0h */ case   71:  		/* mtspr CTR, R11 */
		/* 820F77E0h case   71:*/		regs.CTR = regs.R11;
		/* 820F77E0h case   71:*/		return 0x820F77E4;
		  /* 820F77E4h */ case   72:  		/* bcctrl 20, CR0_LT */
		/* 820F77E4h case   72:*/		if ( 1 ) { regs.LR = 0x820F77E8; return (uint32)regs.CTR; }
		/* 820F77E4h case   72:*/		return 0x820F77E8;
		  /* 820F77E8h */ case   73:  		/* cmpwi CR0, R3, 0 */
		/* 820F77E8h case   73:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F77E8h case   73:*/		return 0x820F77EC;
		  /* 820F77ECh */ case   74:  		/* bc 12, CR0_LT, 136 */
		/* 820F77ECh case   74:*/		if ( regs.CR[0].lt ) { return 0x820F7874;  }
		/* 820F77ECh case   74:*/		return 0x820F77F0;
		  /* 820F77F0h */ case   75:  		/* lwz R11, <#[R31]> */
		/* 820F77F0h case   75:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F77F0h case   75:*/		return 0x820F77F4;
		  /* 820F77F4h */ case   76:  		/* mr R3, R31 */
		/* 820F77F4h case   76:*/		regs.R3 = regs.R31;
		/* 820F77F4h case   76:*/		return 0x820F77F8;
		  /* 820F77F8h */ case   77:  		/* lwz R6, <#[R1 + 84]> */
		/* 820F77F8h case   77:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 820F77F8h case   77:*/		return 0x820F77FC;
		  /* 820F77FCh */ case   78:  		/* lwz R5, <#[R1 + 88]> */
		/* 820F77FCh case   78:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000058) );
		/* 820F77FCh case   78:*/		return 0x820F7800;
		  /* 820F7800h */ case   79:  		/* lwz R4, <#[R1 + 80]> */
		/* 820F7800h case   79:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 820F7800h case   79:*/		return 0x820F7804;
		  /* 820F7804h */ case   80:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F7804h case   80:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F7804h case   80:*/		return 0x820F7808;
		  /* 820F7808h */ case   81:  		/* mtspr CTR, R11 */
		/* 820F7808h case   81:*/		regs.CTR = regs.R11;
		/* 820F7808h case   81:*/		return 0x820F780C;
		  /* 820F780Ch */ case   82:  		/* bcctrl 20, CR0_LT */
		/* 820F780Ch case   82:*/		if ( 1 ) { regs.LR = 0x820F7810; return (uint32)regs.CTR; }
		/* 820F780Ch case   82:*/		return 0x820F7810;
		  /* 820F7810h */ case   83:  		/* cmpwi CR0, R3, 0 */
		/* 820F7810h case   83:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7810h case   83:*/		return 0x820F7814;
		  /* 820F7814h */ case   84:  		/* bc 12, CR0_LT, 96 */
		/* 820F7814h case   84:*/		if ( regs.CR[0].lt ) { return 0x820F7874;  }
		/* 820F7814h case   84:*/		return 0x820F7818;
		  /* 820F7818h */ case   85:  		/* lwz R10, <#[R1 + 88]> */
		/* 820F7818h case   85:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 820F7818h case   85:*/		return 0x820F781C;
		  /* 820F781Ch */ case   86:  		/* xoris R5, R10, 256 */
		/* 820F781Ch case   86:*/		cpu::op::xoris<0>(regs,&regs.R5,regs.R10,0x100);
		/* 820F781Ch case   86:*/		return 0x820F7820;
		  /* 820F7820h */ case   87:  		/* lwz R11, <#[R31]> */
		/* 820F7820h case   87:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7820h case   87:*/		return 0x820F7824;
		  /* 820F7824h */ case   88:  		/* mr R3, R31 */
		/* 820F7824h case   88:*/		regs.R3 = regs.R31;
		/* 820F7824h case   88:*/		return 0x820F7828;
		  /* 820F7828h */ case   89:  		/* lwz R6, <#[R1 + 84]> */
		/* 820F7828h case   89:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 820F7828h case   89:*/		return 0x820F782C;
		  /* 820F782Ch */ case   90:  		/* lwz R4, <#[R1 + 80]> */
		/* 820F782Ch case   90:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 820F782Ch case   90:*/		return 0x820F7830;
		  /* 820F7830h */ case   91:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F7830h case   91:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F7830h case   91:*/		return 0x820F7834;
		  /* 820F7834h */ case   92:  		/* mtspr CTR, R11 */
		/* 820F7834h case   92:*/		regs.CTR = regs.R11;
		/* 820F7834h case   92:*/		return 0x820F7838;
		  /* 820F7838h */ case   93:  		/* bcctrl 20, CR0_LT */
		/* 820F7838h case   93:*/		if ( 1 ) { regs.LR = 0x820F783C; return (uint32)regs.CTR; }
		/* 820F7838h case   93:*/		return 0x820F783C;
		  /* 820F783Ch */ case   94:  		/* cmpwi CR0, R3, 0 */
		/* 820F783Ch case   94:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F783Ch case   94:*/		return 0x820F7840;
		  /* 820F7840h */ case   95:  		/* bc 12, CR0_LT, 52 */
		/* 820F7840h case   95:*/		if ( regs.CR[0].lt ) { return 0x820F7874;  }
		/* 820F7840h case   95:*/		return 0x820F7844;
		  /* 820F7844h */ case   96:  		/* lwz R11, <#[R31]> */
		/* 820F7844h case   96:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7844h case   96:*/		return 0x820F7848;
		  /* 820F7848h */ case   97:  		/* mr R3, R31 */
		/* 820F7848h case   97:*/		regs.R3 = regs.R31;
		/* 820F7848h case   97:*/		return 0x820F784C;
		  /* 820F784Ch */ case   98:  		/* lwz R11, <#[R11 + 308]> */
		/* 820F784Ch case   98:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000134) );
		/* 820F784Ch case   98:*/		return 0x820F7850;
		  /* 820F7850h */ case   99:  		/* mtspr CTR, R11 */
		/* 820F7850h case   99:*/		regs.CTR = regs.R11;
		/* 820F7850h case   99:*/		return 0x820F7854;
		  /* 820F7854h */ case  100:  		/* bcctrl 20, CR0_LT */
		/* 820F7854h case  100:*/		if ( 1 ) { regs.LR = 0x820F7858; return (uint32)regs.CTR; }
		/* 820F7854h case  100:*/		return 0x820F7858;
		  /* 820F7858h */ case  101:  		/* cmpwi CR0, R3, 0 */
		/* 820F7858h case  101:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7858h case  101:*/		return 0x820F785C;
		  /* 820F785Ch */ case  102:  		/* bc 12, CR0_LT, 24 */
		/* 820F785Ch case  102:*/		if ( regs.CR[0].lt ) { return 0x820F7874;  }
		/* 820F785Ch case  102:*/		return 0x820F7860;
		  /* 820F7860h */ case  103:  		/* mr R3, R31 */
		/* 820F7860h case  103:*/		regs.R3 = regs.R31;
		/* 820F7860h case  103:*/		return 0x820F7864;
		  /* 820F7864h */ case  104:  		/* bl -40796 */
		/* 820F7864h case  104:*/		regs.LR = 0x820F7868; return 0x820ED908;
		/* 820F7864h case  104:*/		return 0x820F7868;
		  /* 820F7868h */ case  105:  		/* cmpwi CR0, R3, 0 */
		/* 820F7868h case  105:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7868h case  105:*/		return 0x820F786C;
		  /* 820F786Ch */ case  106:  		/* bc 12, CR0_LT, 8 */
		/* 820F786Ch case  106:*/		if ( regs.CR[0].lt ) { return 0x820F7874;  }
		/* 820F786Ch case  106:*/		return 0x820F7870;
		  /* 820F7870h */ case  107:  		/* li R3, 0 */
		/* 820F7870h case  107:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F7870h case  107:*/		return 0x820F7874;
	}
	return 0x820F7874;
} // Block from 820F76C4h-820F7874h (108 instructions)

//////////////////////////////////////////////////////
// Block at 820F7874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7874);
		  /* 820F7874h */ case    0:  		/* addi R1, R1, 144 */
		/* 820F7874h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820F7874h case    0:*/		return 0x820F7878;
		  /* 820F7878h */ case    1:  		/* b -419276 */
		/* 820F7878h case    1:*/		return 0x820912AC;
		/* 820F7878h case    1:*/		return 0x820F787C;
	}
	return 0x820F787C;
} // Block from 820F7874h-820F787Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F787Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F787C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F787C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F787C);
		  /* 820F787Ch */ case    0:  		/* bcctrl 20, CR0_LT */
		/* 820F787Ch case    0:*/		if ( 1 ) { regs.LR = 0x820F7880; return (uint32)regs.CTR; }
		/* 820F787Ch case    0:*/		return 0x820F7880;
		  /* 820F7880h */ case    1:  		/* cmpwi CR0, R3, 0 */
		/* 820F7880h case    1:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7880h case    1:*/		return 0x820F7884;
		  /* 820F7884h */ case    2:  		/* bc 12, CR0_LT, -16 */
		/* 820F7884h case    2:*/		if ( regs.CR[0].lt ) { return 0x820F7874;  }
		/* 820F7884h case    2:*/		return 0x820F7888;
		  /* 820F7888h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 820F7888h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7888h case    3:*/		return 0x820F788C;
		  /* 820F788Ch */ case    4:  		/* addi R7, R1, 88 */
		/* 820F788Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x58);
		/* 820F788Ch case    4:*/		return 0x820F7890;
		  /* 820F7890h */ case    5:  		/* lwz R10, <#[R31 + 260]> */
		/* 820F7890h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000104) );
		/* 820F7890h case    5:*/		return 0x820F7894;
		  /* 820F7894h */ case    6:  		/* mr R5, R29 */
		/* 820F7894h case    6:*/		regs.R5 = regs.R29;
		/* 820F7894h case    6:*/		return 0x820F7898;
		  /* 820F7898h */ case    7:  		/* mr R3, R31 */
		/* 820F7898h case    7:*/		regs.R3 = regs.R31;
		/* 820F7898h case    7:*/		return 0x820F789C;
		  /* 820F789Ch */ case    8:  		/* lwz R6, <#[R1 + 92]> */
		/* 820F789Ch case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F789Ch case    8:*/		return 0x820F78A0;
		  /* 820F78A0h */ case    9:  		/* lwz R11, <#[R11 + 332]> */
		/* 820F78A0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000014C) );
		/* 820F78A0h case    9:*/		return 0x820F78A4;
		  /* 820F78A4h */ case   10:  		/* lwz R4, <#[R10 + 8]> */
		/* 820F78A4h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000008) );
		/* 820F78A4h case   10:*/		return 0x820F78A8;
		  /* 820F78A8h */ case   11:  		/* mtspr CTR, R11 */
		/* 820F78A8h case   11:*/		regs.CTR = regs.R11;
		/* 820F78A8h case   11:*/		return 0x820F78AC;
		  /* 820F78ACh */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 820F78ACh case   12:*/		if ( 1 ) { regs.LR = 0x820F78B0; return (uint32)regs.CTR; }
		/* 820F78ACh case   12:*/		return 0x820F78B0;
		  /* 820F78B0h */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 820F78B0h case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F78B0h case   13:*/		return 0x820F78B4;
		  /* 820F78B4h */ case   14:  		/* bc 12, CR0_LT, -64 */
		/* 820F78B4h case   14:*/		if ( regs.CR[0].lt ) { return 0x820F7874;  }
		/* 820F78B4h case   14:*/		return 0x820F78B8;
		  /* 820F78B8h */ case   15:  		/* lwz R11, <#[R31]> */
		/* 820F78B8h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F78B8h case   15:*/		return 0x820F78BC;
		  /* 820F78BCh */ case   16:  		/* mr R3, R31 */
		/* 820F78BCh case   16:*/		regs.R3 = regs.R31;
		/* 820F78BCh case   16:*/		return 0x820F78C0;
	}
	return 0x820F78C0;
} // Block from 820F787Ch-820F78C0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820F78C0h
// Function '?EmitTEXProj@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F78C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F78C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F78C0);
		  /* 820F78C0h */ case    0:  		/* lwz R6, <#[R1 + 84]> */
		/* 820F78C0h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 820F78C0h case    0:*/		return 0x820F78C4;
		  /* 820F78C4h */ case    1:  		/* lwz R5, <#[R1 + 88]> */
		/* 820F78C4h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000058) );
		/* 820F78C4h case    1:*/		return 0x820F78C8;
		  /* 820F78C8h */ case    2:  		/* lwz R4, <#[R1 + 80]> */
		/* 820F78C8h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 820F78C8h case    2:*/		return 0x820F78CC;
		  /* 820F78CCh */ case    3:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F78CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F78CCh case    3:*/		return 0x820F78D0;
		  /* 820F78D0h */ case    4:  		/* mtspr CTR, R11 */
		/* 820F78D0h case    4:*/		regs.CTR = regs.R11;
		/* 820F78D0h case    4:*/		return 0x820F78D4;
		  /* 820F78D4h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 820F78D4h case    5:*/		if ( 1 ) { regs.LR = 0x820F78D8; return (uint32)regs.CTR; }
		/* 820F78D4h case    5:*/		return 0x820F78D8;
		  /* 820F78D8h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820F78D8h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F78D8h case    6:*/		return 0x820F78DC;
		  /* 820F78DCh */ case    7:  		/* bc 12, CR0_LT, -104 */
		/* 820F78DCh case    7:*/		if ( regs.CR[0].lt ) { return 0x820F7874;  }
		/* 820F78DCh case    7:*/		return 0x820F78E0;
		  /* 820F78E0h */ case    8:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F78E0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F78E0h case    8:*/		return 0x820F78E4;
		  /* 820F78E4h */ case    9:  		/* rlwinm R30, R29, 2, 0, 29 */
		/* 820F78E4h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R29);
		/* 820F78E4h case    9:*/		return 0x820F78E8;
		  /* 820F78E8h */ case   10:  		/* lwz R10, <#[R31]> */
		/* 820F78E8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F78E8h case   10:*/		return 0x820F78EC;
		  /* 820F78ECh */ case   11:  		/* addi R6, R1, 84 */
		/* 820F78ECh case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 820F78ECh case   11:*/		return 0x820F78F0;
		  /* 820F78F0h */ case   12:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F78F0h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F78F0h case   12:*/		return 0x820F78F4;
		  /* 820F78F4h */ case   13:  		/* addi R5, R1, 80 */
		/* 820F78F4h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820F78F4h case   13:*/		return 0x820F78F8;
		  /* 820F78F8h */ case   14:  		/* mr R3, R31 */
		/* 820F78F8h case   14:*/		regs.R3 = regs.R31;
		/* 820F78F8h case   14:*/		return 0x820F78FC;
		  /* 820F78FCh */ case   15:  		/* lwz R11, <#[R11 + 8]> */
		/* 820F78FCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820F78FCh case   15:*/		return 0x820F7900;
		  /* 820F7900h */ case   16:  		/* lwz R10, <#[R10 + 328]> */
		/* 820F7900h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000148) );
		/* 820F7900h case   16:*/		return 0x820F7904;
		  /* 820F7904h */ case   17:  		/* lwzx R11, <#[R11 + R30]> */
		/* 820F7904h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820F7904h case   17:*/		return 0x820F7908;
		  /* 820F7908h */ case   18:  		/* mtspr CTR, R10 */
		/* 820F7908h case   18:*/		regs.CTR = regs.R10;
		/* 820F7908h case   18:*/		return 0x820F790C;
		  /* 820F790Ch */ case   19:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F790Ch case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F790Ch case   19:*/		return 0x820F7910;
		  /* 820F7910h */ case   20:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F7910h case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F7910h case   20:*/		return 0x820F7914;
		  /* 820F7914h */ case   21:  		/* bcctrl 20, CR0_LT */
		/* 820F7914h case   21:*/		if ( 1 ) { regs.LR = 0x820F7918; return (uint32)regs.CTR; }
		/* 820F7914h case   21:*/		return 0x820F7918;
		  /* 820F7918h */ case   22:  		/* cmpwi CR0, R3, 0 */
		/* 820F7918h case   22:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7918h case   22:*/		return 0x820F791C;
		  /* 820F791Ch */ case   23:  		/* bc 12, CR0_LT, -168 */
		/* 820F791Ch case   23:*/		if ( regs.CR[0].lt ) { return 0x820F7874;  }
		/* 820F791Ch case   23:*/		return 0x820F7920;
		  /* 820F7920h */ case   24:  		/* lwz R11, <#[R31]> */
		/* 820F7920h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7920h case   24:*/		return 0x820F7924;
		  /* 820F7924h */ case   25:  		/* addi R7, R1, 88 */
		/* 820F7924h case   25:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x58);
		/* 820F7924h case   25:*/		return 0x820F7928;
		  /* 820F7928h */ case   26:  		/* lwz R10, <#[R31 + 260]> */
		/* 820F7928h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000104) );
		/* 820F7928h case   26:*/		return 0x820F792C;
		  /* 820F792Ch */ case   27:  		/* mr R5, R29 */
		/* 820F792Ch case   27:*/		regs.R5 = regs.R29;
		/* 820F792Ch case   27:*/		return 0x820F7930;
		  /* 820F7930h */ case   28:  		/* mr R3, R31 */
		/* 820F7930h case   28:*/		regs.R3 = regs.R31;
		/* 820F7930h case   28:*/		return 0x820F7934;
		  /* 820F7934h */ case   29:  		/* lwz R6, <#[R1 + 92]> */
		/* 820F7934h case   29:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F7934h case   29:*/		return 0x820F7938;
		  /* 820F7938h */ case   30:  		/* lwz R9, <#[R11 + 332]> */
		/* 820F7938h case   30:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000014C) );
		/* 820F7938h case   30:*/		return 0x820F793C;
		  /* 820F793Ch */ case   31:  		/* lwz R11, <#[R10 + 8]> */
		/* 820F793Ch case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 820F793Ch case   31:*/		return 0x820F7940;
		  /* 820F7940h */ case   32:  		/* add R4, R11, R30 */
		/* 820F7940h case   32:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R30);
		/* 820F7940h case   32:*/		return 0x820F7944;
		  /* 820F7944h */ case   33:  		/* mtspr CTR, R9 */
		/* 820F7944h case   33:*/		regs.CTR = regs.R9;
		/* 820F7944h case   33:*/		return 0x820F7948;
	}
	return 0x820F7948;
} // Block from 820F78C0h-820F7948h (34 instructions)

//////////////////////////////////////////////////////
// Block at 820F7948h
// Function '?EmitTEXBias@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7948( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7948) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7948);
		  /* 820F7948h */ case    0:  		/* bcctrl 20, CR0_LT */
		/* 820F7948h case    0:*/		if ( 1 ) { regs.LR = 0x820F794C; return (uint32)regs.CTR; }
		/* 820F7948h case    0:*/		return 0x820F794C;
		  /* 820F794Ch */ case    1:  		/* cmpwi CR0, R3, 0 */
		/* 820F794Ch case    1:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F794Ch case    1:*/		return 0x820F7950;
		  /* 820F7950h */ case    2:  		/* bc 12, CR0_LT, -220 */
		/* 820F7950h case    2:*/		if ( regs.CR[0].lt ) { return 0x820F7874;  }
		/* 820F7950h case    2:*/		return 0x820F7954;
		  /* 820F7954h */ case    3:  		/* lwz R5, <#[R1 + 88]> */
		/* 820F7954h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000058) );
		/* 820F7954h case    3:*/		return 0x820F7958;
		  /* 820F7958h */ case    4:  		/* b -312 */
		/* 820F7958h case    4:*/		return 0x820F7820;
		/* 820F7958h case    4:*/		return 0x820F795C;
		  /* 820F795Ch */ case    5:  		/* nop */
		/* 820F795Ch case    5:*/		cpu::op::nop();
		/* 820F795Ch case    5:*/		return 0x820F7960;
	}
	return 0x820F7960;
} // Block from 820F7948h-820F7960h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F7960h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7960);
		  /* 820F7960h */ case    0:  		/* mfspr R12, LR */
		/* 820F7960h case    0:*/		regs.R12 = regs.LR;
		/* 820F7960h case    0:*/		return 0x820F7964;
		  /* 820F7964h */ case    1:  		/* bl -419600 */
		/* 820F7964h case    1:*/		regs.LR = 0x820F7968; return 0x82091254;
		/* 820F7964h case    1:*/		return 0x820F7968;
		  /* 820F7968h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820F7968h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820F7968h case    2:*/		return 0x820F796C;
		  /* 820F796Ch */ case    3:  		/* lwz R11, <#[R3 + 52]> */
		/* 820F796Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000034) );
		/* 820F796Ch case    3:*/		return 0x820F7970;
		  /* 820F7970h */ case    4:  		/* mr R31, R3 */
		/* 820F7970h case    4:*/		regs.R31 = regs.R3;
		/* 820F7970h case    4:*/		return 0x820F7974;
		  /* 820F7974h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820F7974h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F7974h case    5:*/		return 0x820F7978;
		  /* 820F7978h */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 820F7978h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820F7988;  }
		/* 820F7978h case    6:*/		return 0x820F797C;
		  /* 820F797Ch */ case    7:  		/* lis R3, -32768 */
		/* 820F797Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820F797Ch case    7:*/		return 0x820F7980;
		  /* 820F7980h */ case    8:  		/* ori R3, R3, 16385 */
		/* 820F7980h case    8:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4001);
		/* 820F7980h case    8:*/		return 0x820F7984;
		  /* 820F7984h */ case    9:  		/* b 644 */
		/* 820F7984h case    9:*/		return 0x820F7C08;
		/* 820F7984h case    9:*/		return 0x820F7988;
	}
	return 0x820F7988;
} // Block from 820F7960h-820F7988h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F7988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7988);
		  /* 820F7988h */ case    0:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F7988h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F7988h case    0:*/		return 0x820F798C;
		  /* 820F798Ch */ case    1:  		/* lwz R10, <#[R11 + 12]> */
		/* 820F798Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F798Ch case    1:*/		return 0x820F7990;
		  /* 820F7990h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 820F7990h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F7990h case    2:*/		return 0x820F7994;
		  /* 820F7994h */ case    3:  		/* bc 12, CR6_EQ, 624 */
		/* 820F7994h case    3:*/		if ( regs.CR[6].eq ) { return 0x820F7C04;  }
		/* 820F7994h case    3:*/		return 0x820F7998;
		  /* 820F7998h */ case    4:  		/* lwz R11, <#[R11 + 16]> */
		/* 820F7998h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820F7998h case    4:*/		return 0x820F799C;
		  /* 820F799Ch */ case    5:  		/* li R28, 0 */
		/* 820F799Ch case    5:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820F799Ch case    5:*/		return 0x820F79A0;
		  /* 820F79A0h */ case    6:  		/* lwz R10, <#[R31 + 20]> */
		/* 820F79A0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820F79A0h case    6:*/		return 0x820F79A4;
		  /* 820F79A4h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820F79A4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F79A4h case    7:*/		return 0x820F79A8;
		  /* 820F79A8h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F79A8h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F79A8h case    8:*/		return 0x820F79AC;
		  /* 820F79ACh */ case    9:  		/* lwzx R27, <#[R11 + R10]> */
		/* 820F79ACh case    9:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F79ACh case    9:*/		return 0x820F79B0;
		  /* 820F79B0h */ case   10:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F79B0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F79B0h case   10:*/		return 0x820F79B4;
		  /* 820F79B4h */ case   11:  		/* lwz R10, <#[R31 + 20]> */
		/* 820F79B4h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820F79B4h case   11:*/		return 0x820F79B8;
		  /* 820F79B8h */ case   12:  		/* lwz R9, <#[R27 + 4]> */
		/* 820F79B8h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000004) );
		/* 820F79B8h case   12:*/		return 0x820F79BC;
		  /* 820F79BCh */ case   13:  		/* lwz R8, <#[R11 + 12]> */
		/* 820F79BCh case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F79BCh case   13:*/		return 0x820F79C0;
		  /* 820F79C0h */ case   14:  		/* lwz R11, <#[R11 + 8]> */
		/* 820F79C0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820F79C0h case   14:*/		return 0x820F79C4;
		  /* 820F79C4h */ case   15:  		/* mullw R8, R8, R28 */
		/* 820F79C4h case   15:*/		cpu::op::mullw<0>(regs,&regs.R8,regs.R8,regs.R28);
		/* 820F79C4h case   15:*/		return 0x820F79C8;
		  /* 820F79C8h */ case   16:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820F79C8h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820F79C8h case   16:*/		return 0x820F79CC;
		  /* 820F79CCh */ case   17:  		/* lwzx R11, <#[R8 + R11]> */
		/* 820F79CCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 820F79CCh case   17:*/		return 0x820F79D0;
	}
	return 0x820F79D0;
} // Block from 820F7988h-820F79D0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820F79D0h
// Function '?EmitTEXLOD@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F79D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F79D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F79D0);
		  /* 820F79D0h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F79D0h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F79D0h case    0:*/		return 0x820F79D4;
		  /* 820F79D4h */ case    1:  		/* lwzx R30, <#[R11 + R10]> */
		/* 820F79D4h case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F79D4h case    1:*/		return 0x820F79D8;
		  /* 820F79D8h */ case    2:  		/* lwz R11, <#[R30 + 4]> */
		/* 820F79D8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 820F79D8h case    2:*/		return 0x820F79DC;
		  /* 820F79DCh */ case    3:  		/* cmplw CR6, R11, R9 */
		/* 820F79DCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F79DCh case    3:*/		return 0x820F79E0;
		  /* 820F79E0h */ case    4:  		/* bc 4, CR6_EQ, 52 */
		/* 820F79E0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820F7A14;  }
		/* 820F79E0h case    4:*/		return 0x820F79E4;
		  /* 820F79E4h */ case    5:  		/* lwz R11, <#[R30 + 8]> */
		/* 820F79E4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820F79E4h case    5:*/		return 0x820F79E8;
		  /* 820F79E8h */ case    6:  		/* lwz R10, <#[R27 + 8]> */
		/* 820F79E8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000008) );
		/* 820F79E8h case    6:*/		return 0x820F79EC;
		  /* 820F79ECh */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820F79ECh case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F79ECh case    7:*/		return 0x820F79F0;
		  /* 820F79F0h */ case    8:  		/* bc 4, CR6_EQ, 36 */
		/* 820F79F0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820F7A14;  }
		/* 820F79F0h case    8:*/		return 0x820F79F4;
		  /* 820F79F4h */ case    9:  		/* lwz R11, <#[R30 + 12]> */
		/* 820F79F4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 820F79F4h case    9:*/		return 0x820F79F8;
		  /* 820F79F8h */ case   10:  		/* lwz R10, <#[R27 + 12]> */
		/* 820F79F8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x0000000C) );
		/* 820F79F8h case   10:*/		return 0x820F79FC;
		  /* 820F79FCh */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 820F79FCh case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F79FCh case   11:*/		return 0x820F7A00;
		  /* 820F7A00h */ case   12:  		/* bc 4, CR6_EQ, 20 */
		/* 820F7A00h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820F7A14;  }
		/* 820F7A00h case   12:*/		return 0x820F7A04;
		  /* 820F7A04h */ case   13:  		/* lwz R11, <#[R30 + 16]> */
		/* 820F7A04h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820F7A04h case   13:*/		return 0x820F7A08;
		  /* 820F7A08h */ case   14:  		/* lwz R10, <#[R27 + 16]> */
		/* 820F7A08h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000010) );
		/* 820F7A08h case   14:*/		return 0x820F7A0C;
		  /* 820F7A0Ch */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 820F7A0Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F7A0Ch case   15:*/		return 0x820F7A10;
		  /* 820F7A10h */ case   16:  		/* bc 12, CR6_EQ, 488 */
		/* 820F7A10h case   16:*/		if ( regs.CR[6].eq ) { return 0x820F7BF8;  }
		/* 820F7A10h case   16:*/		return 0x820F7A14;
	}
	return 0x820F7A14;
} // Block from 820F79D0h-820F7A14h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820F7A14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7A14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7A14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7A14);
		  /* 820F7A14h */ case    0:  		/* li R4, 1 */
		/* 820F7A14h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820F7A14h case    0:*/		return 0x820F7A18;
		  /* 820F7A18h */ case    1:  		/* mr R3, R31 */
		/* 820F7A18h case    1:*/		regs.R3 = regs.R31;
		/* 820F7A18h case    1:*/		return 0x820F7A1C;
		  /* 820F7A1Ch */ case    2:  		/* bl -6444 */
		/* 820F7A1Ch case    2:*/		regs.LR = 0x820F7A20; return 0x820F60F0;
		/* 820F7A1Ch case    2:*/		return 0x820F7A20;
		  /* 820F7A20h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820F7A20h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7A20h case    3:*/		return 0x820F7A24;
		  /* 820F7A24h */ case    4:  		/* bc 12, CR0_LT, 484 */
		/* 820F7A24h case    4:*/		if ( regs.CR[0].lt ) { return 0x820F7C08;  }
		/* 820F7A24h case    4:*/		return 0x820F7A28;
		  /* 820F7A28h */ case    5:  		/* lwz R11, <#[R30 + 20]> */
		/* 820F7A28h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820F7A28h case    5:*/		return 0x820F7A2C;
		  /* 820F7A2Ch */ case    6:  		/* lwz R10, <#[R31 + 20]> */
		/* 820F7A2Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820F7A2Ch case    6:*/		return 0x820F7A30;
		  /* 820F7A30h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F7A30h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F7A30h case    7:*/		return 0x820F7A34;
		  /* 820F7A34h */ case    8:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820F7A34h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F7A34h case    8:*/		return 0x820F7A38;
		  /* 820F7A38h */ case    9:  		/* lwz R10, <#[R11 + 12]> */
		/* 820F7A38h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F7A38h case    9:*/		return 0x820F7A3C;
		  /* 820F7A3Ch */ case   10:  		/* lwz R11, <#[R11 + 16]> */
		/* 820F7A3Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820F7A3Ch case   10:*/		return 0x820F7A40;
		  /* 820F7A40h */ case   11:  		/* rlwinm R10, R10, 0, 21, 31 */
		/* 820F7A40h case   11:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R10,regs.R10);
		/* 820F7A40h case   11:*/		return 0x820F7A44;
		  /* 820F7A44h */ case   12:  		/* cmplwi CR6, R11, 1 */
		/* 820F7A44h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820F7A44h case   12:*/		return 0x820F7A48;
		  /* 820F7A48h */ case   13:  		/* oris R29, R10, 45056 */
		/* 820F7A48h case   13:*/		cpu::op::oris<0>(regs,&regs.R29,regs.R10,0xB000);
		/* 820F7A48h case   13:*/		return 0x820F7A4C;
		  /* 820F7A4Ch */ case   14:  		/* ori R29, R29, 4096 */
		/* 820F7A4Ch case   14:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R29,0x1000);
		/* 820F7A4Ch case   14:*/		return 0x820F7A50;
	}
	return 0x820F7A50;
} // Block from 820F7A14h-820F7A50h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820F7A50h
// Function '?EmitDP2ADD@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7A50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7A50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7A50);
		  /* 820F7A50h */ case    0:  		/* bc 12, CR6_LT, 40 */
		/* 820F7A50h case    0:*/		if ( regs.CR[6].lt ) { return 0x820F7A78;  }
		/* 820F7A50h case    0:*/		return 0x820F7A54;
		  /* 820F7A54h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 820F7A54h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F7A74;  }
		/* 820F7A54h case    1:*/		return 0x820F7A58;
		  /* 820F7A58h */ case    2:  		/* cmplwi CR6, R11, 3 */
		/* 820F7A58h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820F7A58h case    2:*/		return 0x820F7A5C;
		  /* 820F7A5Ch */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 820F7A5Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x820F7A6C;  }
		/* 820F7A5Ch case    3:*/		return 0x820F7A60;
		  /* 820F7A60h */ case    4:  		/* bc 4, CR6_EQ, 24 */
		/* 820F7A60h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820F7A78;  }
		/* 820F7A60h case    4:*/		return 0x820F7A64;
		  /* 820F7A64h */ case    5:  		/* oris R29, R29, 255 */
		/* 820F7A64h case    5:*/		cpu::op::oris<0>(regs,&regs.R29,regs.R29,0xFF);
		/* 820F7A64h case    5:*/		return 0x820F7A68;
		  /* 820F7A68h */ case    6:  		/* b 16 */
		/* 820F7A68h case    6:*/		return 0x820F7A78;
		/* 820F7A68h case    6:*/		return 0x820F7A6C;
	}
	return 0x820F7A6C;
} // Block from 820F7A50h-820F7A6Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F7A6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7A6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7A6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7A6C);
		  /* 820F7A6Ch */ case    0:  		/* oris R29, R29, 170 */
		/* 820F7A6Ch case    0:*/		cpu::op::oris<0>(regs,&regs.R29,regs.R29,0xAA);
		/* 820F7A6Ch case    0:*/		return 0x820F7A70;
		  /* 820F7A70h */ case    1:  		/* b 8 */
		/* 820F7A70h case    1:*/		return 0x820F7A78;
		/* 820F7A70h case    1:*/		return 0x820F7A74;
	}
	return 0x820F7A74;
} // Block from 820F7A6Ch-820F7A74h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F7A74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7A74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7A74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7A74);
		  /* 820F7A74h */ case    0:  		/* oris R29, R29, 85 */
		/* 820F7A74h case    0:*/		cpu::op::oris<0>(regs,&regs.R29,regs.R29,0x55);
		/* 820F7A74h case    0:*/		return 0x820F7A78;
	}
	return 0x820F7A78;
} // Block from 820F7A74h-820F7A78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F7A78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7A78);
		  /* 820F7A78h */ case    0:  		/* lwz R11, <#[R30 + 24]> */
		/* 820F7A78h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820F7A78h case    0:*/		return 0x820F7A7C;
		  /* 820F7A7Ch */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820F7A7Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820F7A7Ch case    1:*/		return 0x820F7A80;
		  /* 820F7A80h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820F7A80h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820F7A88;  }
		/* 820F7A80h case    2:*/		return 0x820F7A84;
		  /* 820F7A84h */ case    3:  		/* oris R29, R29, 3328 */
		/* 820F7A84h case    3:*/		cpu::op::oris<0>(regs,&regs.R29,regs.R29,0xD00);
		/* 820F7A84h case    3:*/		return 0x820F7A88;
	}
	return 0x820F7A88;
} // Block from 820F7A78h-820F7A88h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F7A88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7A88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7A88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7A88);
		  /* 820F7A88h */ case    0:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F7A88h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F7A88h case    0:*/		return 0x820F7A8C;
		  /* 820F7A8Ch */ case    1:  		/* addi R7, R1, 88 */
		/* 820F7A8Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x58);
		/* 820F7A8Ch case    1:*/		return 0x820F7A90;
		  /* 820F7A90h */ case    2:  		/* lwz R10, <#[R31]> */
		/* 820F7A90h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7A90h case    2:*/		return 0x820F7A94;
		  /* 820F7A94h */ case    3:  		/* li R6, 0 */
		/* 820F7A94h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820F7A94h case    3:*/		return 0x820F7A98;
		  /* 820F7A98h */ case    4:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F7A98h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F7A98h case    4:*/		return 0x820F7A9C;
		  /* 820F7A9Ch */ case    5:  		/* addi R5, R1, 80 */
		/* 820F7A9Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820F7A9Ch case    5:*/		return 0x820F7AA0;
		  /* 820F7AA0h */ case    6:  		/* mr R3, R31 */
		/* 820F7AA0h case    6:*/		regs.R3 = regs.R31;
		/* 820F7AA0h case    6:*/		return 0x820F7AA4;
		  /* 820F7AA4h */ case    7:  		/* lwz R11, <#[R11 + 16]> */
		/* 820F7AA4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820F7AA4h case    7:*/		return 0x820F7AA8;
		  /* 820F7AA8h */ case    8:  		/* lwz R10, <#[R10 + 320]> */
		/* 820F7AA8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000140) );
		/* 820F7AA8h case    8:*/		return 0x820F7AAC;
		  /* 820F7AACh */ case    9:  		/* lwz R11, <#[R11]> */
		/* 820F7AACh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F7AACh case    9:*/		return 0x820F7AB0;
		  /* 820F7AB0h */ case   10:  		/* mtspr CTR, R10 */
		/* 820F7AB0h case   10:*/		regs.CTR = regs.R10;
		/* 820F7AB0h case   10:*/		return 0x820F7AB4;
		  /* 820F7AB4h */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F7AB4h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F7AB4h case   11:*/		return 0x820F7AB8;
		  /* 820F7AB8h */ case   12:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F7AB8h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F7AB8h case   12:*/		return 0x820F7ABC;
		  /* 820F7ABCh */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 820F7ABCh case   13:*/		if ( 1 ) { regs.LR = 0x820F7AC0; return (uint32)regs.CTR; }
		/* 820F7ABCh case   13:*/		return 0x820F7AC0;
	}
	return 0x820F7AC0;
} // Block from 820F7A88h-820F7AC0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820F7AC0h
// Function '?EmitCLIP@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7AC0);
		  /* 820F7AC0h */ case    0:  		/* cmpwi CR0, R3, 0 */
		/* 820F7AC0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7AC0h case    0:*/		return 0x820F7AC4;
		  /* 820F7AC4h */ case    1:  		/* bc 12, CR0_LT, 324 */
		/* 820F7AC4h case    1:*/		if ( regs.CR[0].lt ) { return 0x820F7C08;  }
		/* 820F7AC4h case    1:*/		return 0x820F7AC8;
		  /* 820F7AC8h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 820F7AC8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7AC8h case    2:*/		return 0x820F7ACC;
		  /* 820F7ACCh */ case    3:  		/* addi R6, R1, 84 */
		/* 820F7ACCh case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 820F7ACCh case    3:*/		return 0x820F7AD0;
		  /* 820F7AD0h */ case    4:  		/* lwz R10, <#[R31 + 260]> */
		/* 820F7AD0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000104) );
		/* 820F7AD0h case    4:*/		return 0x820F7AD4;
		  /* 820F7AD4h */ case    5:  		/* mr R3, R31 */
		/* 820F7AD4h case    5:*/		regs.R3 = regs.R31;
		/* 820F7AD4h case    5:*/		return 0x820F7AD8;
		  /* 820F7AD8h */ case    6:  		/* lwz R7, <#[R1 + 88]> */
		/* 820F7AD8h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000058) );
		/* 820F7AD8h case    6:*/		return 0x820F7ADC;
		  /* 820F7ADCh */ case    7:  		/* lwz R11, <#[R11 + 324]> */
		/* 820F7ADCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000144) );
		/* 820F7ADCh case    7:*/		return 0x820F7AE0;
		  /* 820F7AE0h */ case    8:  		/* lwz R5, <#[R10 + 12]> */
		/* 820F7AE0h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x0000000C) );
		/* 820F7AE0h case    8:*/		return 0x820F7AE4;
		  /* 820F7AE4h */ case    9:  		/* lwz R4, <#[R10 + 16]> */
		/* 820F7AE4h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000010) );
		/* 820F7AE4h case    9:*/		return 0x820F7AE8;
		  /* 820F7AE8h */ case   10:  		/* mtspr CTR, R11 */
		/* 820F7AE8h case   10:*/		regs.CTR = regs.R11;
		/* 820F7AE8h case   10:*/		return 0x820F7AEC;
		  /* 820F7AECh */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 820F7AECh case   11:*/		if ( 1 ) { regs.LR = 0x820F7AF0; return (uint32)regs.CTR; }
		/* 820F7AECh case   11:*/		return 0x820F7AF0;
		  /* 820F7AF0h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820F7AF0h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7AF0h case   12:*/		return 0x820F7AF4;
		  /* 820F7AF4h */ case   13:  		/* bc 12, CR0_LT, 276 */
		/* 820F7AF4h case   13:*/		if ( regs.CR[0].lt ) { return 0x820F7C08;  }
		/* 820F7AF4h case   13:*/		return 0x820F7AF8;
		  /* 820F7AF8h */ case   14:  		/* lwz R11, <#[R31]> */
		/* 820F7AF8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7AF8h case   14:*/		return 0x820F7AFC;
		  /* 820F7AFCh */ case   15:  		/* mr R6, R29 */
		/* 820F7AFCh case   15:*/		regs.R6 = regs.R29;
		/* 820F7AFCh case   15:*/		return 0x820F7B00;
		  /* 820F7B00h */ case   16:  		/* mr R3, R31 */
		/* 820F7B00h case   16:*/		regs.R3 = regs.R31;
		/* 820F7B00h case   16:*/		return 0x820F7B04;
		  /* 820F7B04h */ case   17:  		/* lwz R5, <#[R1 + 84]> */
		/* 820F7B04h case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 820F7B04h case   17:*/		return 0x820F7B08;
		  /* 820F7B08h */ case   18:  		/* lwz R4, <#[R1 + 80]> */
		/* 820F7B08h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 820F7B08h case   18:*/		return 0x820F7B0C;
		  /* 820F7B0Ch */ case   19:  		/* lwz R11, <#[R11 + 312]> */
		/* 820F7B0Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000138) );
		/* 820F7B0Ch case   19:*/		return 0x820F7B10;
		  /* 820F7B10h */ case   20:  		/* mtspr CTR, R11 */
		/* 820F7B10h case   20:*/		regs.CTR = regs.R11;
		/* 820F7B10h case   20:*/		return 0x820F7B14;
		  /* 820F7B14h */ case   21:  		/* bcctrl 20, CR0_LT */
		/* 820F7B14h case   21:*/		if ( 1 ) { regs.LR = 0x820F7B18; return (uint32)regs.CTR; }
		/* 820F7B14h case   21:*/		return 0x820F7B18;
		  /* 820F7B18h */ case   22:  		/* cmpwi CR0, R3, 0 */
		/* 820F7B18h case   22:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7B18h case   22:*/		return 0x820F7B1C;
		  /* 820F7B1Ch */ case   23:  		/* bc 12, CR0_LT, 236 */
		/* 820F7B1Ch case   23:*/		if ( regs.CR[0].lt ) { return 0x820F7C08;  }
		/* 820F7B1Ch case   23:*/		return 0x820F7B20;
		  /* 820F7B20h */ case   24:  		/* lwz R10, <#[R31]> */
		/* 820F7B20h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7B20h case   24:*/		return 0x820F7B24;
		  /* 820F7B24h */ case   25:  		/* addi R6, R1, 92 */
		/* 820F7B24h case   25:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x5C);
		/* 820F7B24h case   25:*/		return 0x820F7B28;
		  /* 820F7B28h */ case   26:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F7B28h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F7B28h case   26:*/		return 0x820F7B2C;
		  /* 820F7B2Ch */ case   27:  		/* addi R5, R1, 80 */
		/* 820F7B2Ch case   27:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820F7B2Ch case   27:*/		return 0x820F7B30;
		  /* 820F7B30h */ case   28:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F7B30h case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F7B30h case   28:*/		return 0x820F7B34;
		  /* 820F7B34h */ case   29:  		/* mr R3, R31 */
		/* 820F7B34h case   29:*/		regs.R3 = regs.R31;
		/* 820F7B34h case   29:*/		return 0x820F7B38;
		  /* 820F7B38h */ case   30:  		/* lwz R10, <#[R10 + 328]> */
		/* 820F7B38h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000148) );
		/* 820F7B38h case   30:*/		return 0x820F7B3C;
		  /* 820F7B3Ch */ case   31:  		/* lwz R8, <#[R11 + 12]> */
		/* 820F7B3Ch case   31:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F7B3Ch case   31:*/		return 0x820F7B40;
		  /* 820F7B40h */ case   32:  		/* lwz R11, <#[R11 + 8]> */
		/* 820F7B40h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820F7B40h case   32:*/		return 0x820F7B44;
		  /* 820F7B44h */ case   33:  		/* mullw R8, R8, R28 */
		/* 820F7B44h case   33:*/		cpu::op::mullw<0>(regs,&regs.R8,regs.R8,regs.R28);
		/* 820F7B44h case   33:*/		return 0x820F7B48;
		  /* 820F7B48h */ case   34:  		/* mtspr CTR, R10 */
		/* 820F7B48h case   34:*/		regs.CTR = regs.R10;
		/* 820F7B48h case   34:*/		return 0x820F7B4C;
		  /* 820F7B4Ch */ case   35:  		/* rlwinm R10, R8, 2, 0, 29 */
		/* 820F7B4Ch case   35:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R8);
		/* 820F7B4Ch case   35:*/		return 0x820F7B50;
		  /* 820F7B50h */ case   36:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820F7B50h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820F7B50h case   36:*/		return 0x820F7B54;
		  /* 820F7B54h */ case   37:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F7B54h case   37:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F7B54h case   37:*/		return 0x820F7B58;
		  /* 820F7B58h */ case   38:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F7B58h case   38:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F7B58h case   38:*/		return 0x820F7B5C;
		  /* 820F7B5Ch */ case   39:  		/* bcctrl 20, CR0_LT */
		/* 820F7B5Ch case   39:*/		if ( 1 ) { regs.LR = 0x820F7B60; return (uint32)regs.CTR; }
		/* 820F7B5Ch case   39:*/		return 0x820F7B60;
		  /* 820F7B60h */ case   40:  		/* cmpwi CR0, R3, 0 */
		/* 820F7B60h case   40:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7B60h case   40:*/		return 0x820F7B64;
		  /* 820F7B64h */ case   41:  		/* bc 12, CR0_LT, 164 */
		/* 820F7B64h case   41:*/		if ( regs.CR[0].lt ) { return 0x820F7C08;  }
		/* 820F7B64h case   41:*/		return 0x820F7B68;
		  /* 820F7B68h */ case   42:  		/* lwz R10, <#[R31]> */
		/* 820F7B68h case   42:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7B68h case   42:*/		return 0x820F7B6C;
		  /* 820F7B6Ch */ case   43:  		/* addi R7, R1, 96 */
		/* 820F7B6Ch case   43:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820F7B6Ch case   43:*/		return 0x820F7B70;
		  /* 820F7B70h */ case   44:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F7B70h case   44:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F7B70h case   44:*/		return 0x820F7B74;
		  /* 820F7B74h */ case   45:  		/* mr R3, R31 */
		/* 820F7B74h case   45:*/		regs.R3 = regs.R31;
		/* 820F7B74h case   45:*/		return 0x820F7B78;
		  /* 820F7B78h */ case   46:  		/* lwz R6, <#[R1 + 84]> */
		/* 820F7B78h case   46:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 820F7B78h case   46:*/		return 0x820F7B7C;
		  /* 820F7B7Ch */ case   47:  		/* lwz R10, <#[R10 + 332]> */
		/* 820F7B7Ch case   47:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000014C) );
		/* 820F7B7Ch case   47:*/		return 0x820F7B80;
		  /* 820F7B80h */ case   48:  		/* lwz R5, <#[R11 + 12]> */
		/* 820F7B80h case   48:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F7B80h case   48:*/		return 0x820F7B84;
		  /* 820F7B84h */ case   49:  		/* lwz R11, <#[R11 + 8]> */
		/* 820F7B84h case   49:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820F7B84h case   49:*/		return 0x820F7B88;
		  /* 820F7B88h */ case   50:  		/* mullw R9, R5, R28 */
		/* 820F7B88h case   50:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R5,regs.R28);
		/* 820F7B88h case   50:*/		return 0x820F7B8C;
		  /* 820F7B8Ch */ case   51:  		/* mtspr CTR, R10 */
		/* 820F7B8Ch case   51:*/		regs.CTR = regs.R10;
		/* 820F7B8Ch case   51:*/		return 0x820F7B90;
		  /* 820F7B90h */ case   52:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 820F7B90h case   52:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 820F7B90h case   52:*/		return 0x820F7B94;
		  /* 820F7B94h */ case   53:  		/* add R4, R10, R11 */
		/* 820F7B94h case   53:*/		cpu::op::add<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 820F7B94h case   53:*/		return 0x820F7B98;
		  /* 820F7B98h */ case   54:  		/* bcctrl 20, CR0_LT */
		/* 820F7B98h case   54:*/		if ( 1 ) { regs.LR = 0x820F7B9C; return (uint32)regs.CTR; }
		/* 820F7B98h case   54:*/		return 0x820F7B9C;
		  /* 820F7B9Ch */ case   55:  		/* cmpwi CR0, R3, 0 */
		/* 820F7B9Ch case   55:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7B9Ch case   55:*/		return 0x820F7BA0;
		  /* 820F7BA0h */ case   56:  		/* bc 12, CR0_LT, 104 */
		/* 820F7BA0h case   56:*/		if ( regs.CR[0].lt ) { return 0x820F7C08;  }
		/* 820F7BA0h case   56:*/		return 0x820F7BA4;
		  /* 820F7BA4h */ case   57:  		/* lwz R11, <#[R31]> */
		/* 820F7BA4h case   57:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7BA4h case   57:*/		return 0x820F7BA8;
		  /* 820F7BA8h */ case   58:  		/* mr R3, R31 */
		/* 820F7BA8h case   58:*/		regs.R3 = regs.R31;
		/* 820F7BA8h case   58:*/		return 0x820F7BAC;
		  /* 820F7BACh */ case   59:  		/* lwz R6, <#[R1 + 92]> */
		/* 820F7BACh case   59:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F7BACh case   59:*/		return 0x820F7BB0;
		  /* 820F7BB0h */ case   60:  		/* lwz R5, <#[R1 + 96]> */
		/* 820F7BB0h case   60:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000060) );
		/* 820F7BB0h case   60:*/		return 0x820F7BB4;
		  /* 820F7BB4h */ case   61:  		/* lwz R4, <#[R1 + 80]> */
		/* 820F7BB4h case   61:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 820F7BB4h case   61:*/		return 0x820F7BB8;
		  /* 820F7BB8h */ case   62:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F7BB8h case   62:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F7BB8h case   62:*/		return 0x820F7BBC;
		  /* 820F7BBCh */ case   63:  		/* mtspr CTR, R11 */
		/* 820F7BBCh case   63:*/		regs.CTR = regs.R11;
		/* 820F7BBCh case   63:*/		return 0x820F7BC0;
		  /* 820F7BC0h */ case   64:  		/* bcctrl 20, CR0_LT */
		/* 820F7BC0h case   64:*/		if ( 1 ) { regs.LR = 0x820F7BC4; return (uint32)regs.CTR; }
		/* 820F7BC0h case   64:*/		return 0x820F7BC4;
		  /* 820F7BC4h */ case   65:  		/* cmpwi CR0, R3, 0 */
		/* 820F7BC4h case   65:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7BC4h case   65:*/		return 0x820F7BC8;
		  /* 820F7BC8h */ case   66:  		/* bc 12, CR0_LT, 64 */
		/* 820F7BC8h case   66:*/		if ( regs.CR[0].lt ) { return 0x820F7C08;  }
		/* 820F7BC8h case   66:*/		return 0x820F7BCC;
		  /* 820F7BCCh */ case   67:  		/* lwz R11, <#[R31]> */
		/* 820F7BCCh case   67:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7BCCh case   67:*/		return 0x820F7BD0;
		  /* 820F7BD0h */ case   68:  		/* mr R3, R31 */
		/* 820F7BD0h case   68:*/		regs.R3 = regs.R31;
		/* 820F7BD0h case   68:*/		return 0x820F7BD4;
		  /* 820F7BD4h */ case   69:  		/* lwz R11, <#[R11 + 308]> */
		/* 820F7BD4h case   69:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000134) );
		/* 820F7BD4h case   69:*/		return 0x820F7BD8;
		  /* 820F7BD8h */ case   70:  		/* mtspr CTR, R11 */
		/* 820F7BD8h case   70:*/		regs.CTR = regs.R11;
		/* 820F7BD8h case   70:*/		return 0x820F7BDC;
		  /* 820F7BDCh */ case   71:  		/* bcctrl 20, CR0_LT */
		/* 820F7BDCh case   71:*/		if ( 1 ) { regs.LR = 0x820F7BE0; return (uint32)regs.CTR; }
		/* 820F7BDCh case   71:*/		return 0x820F7BE0;
		  /* 820F7BE0h */ case   72:  		/* cmpwi CR0, R3, 0 */
		/* 820F7BE0h case   72:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7BE0h case   72:*/		return 0x820F7BE4;
		  /* 820F7BE4h */ case   73:  		/* bc 12, CR0_LT, 36 */
		/* 820F7BE4h case   73:*/		if ( regs.CR[0].lt ) { return 0x820F7C08;  }
		/* 820F7BE4h case   73:*/		return 0x820F7BE8;
		  /* 820F7BE8h */ case   74:  		/* mr R3, R31 */
		/* 820F7BE8h case   74:*/		regs.R3 = regs.R31;
		/* 820F7BE8h case   74:*/		return 0x820F7BEC;
		  /* 820F7BECh */ case   75:  		/* bl -41700 */
		/* 820F7BECh case   75:*/		regs.LR = 0x820F7BF0; return 0x820ED908;
		/* 820F7BECh case   75:*/		return 0x820F7BF0;
		  /* 820F7BF0h */ case   76:  		/* cmpwi CR0, R3, 0 */
		/* 820F7BF0h case   76:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7BF0h case   76:*/		return 0x820F7BF4;
		  /* 820F7BF4h */ case   77:  		/* bc 12, CR0_LT, 20 */
		/* 820F7BF4h case   77:*/		if ( regs.CR[0].lt ) { return 0x820F7C08;  }
		/* 820F7BF4h case   77:*/		return 0x820F7BF8;
	}
	return 0x820F7BF8;
} // Block from 820F7AC0h-820F7BF8h (78 instructions)

//////////////////////////////////////////////////////
// Block at 820F7BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7BF8);
		  /* 820F7BF8h */ case    0:  		/* addi R28, R28, 1 */
		/* 820F7BF8h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820F7BF8h case    0:*/		return 0x820F7BFC;
		  /* 820F7BFCh */ case    1:  		/* cmplwi CR6, R28, 2 */
		/* 820F7BFCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000002);
		/* 820F7BFCh case    1:*/		return 0x820F7C00;
		  /* 820F7C00h */ case    2:  		/* bc 12, CR6_LT, -592 */
		/* 820F7C00h case    2:*/		if ( regs.CR[6].lt ) { return 0x820F79B0;  }
		/* 820F7C00h case    2:*/		return 0x820F7C04;
	}
	return 0x820F7C04;
} // Block from 820F7BF8h-820F7C04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F7C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7C04);
		  /* 820F7C04h */ case    0:  		/* li R3, 0 */
		/* 820F7C04h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F7C04h case    0:*/		return 0x820F7C08;
	}
	return 0x820F7C08;
} // Block from 820F7C04h-820F7C08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F7C08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7C08);
		  /* 820F7C08h */ case    0:  		/* addi R1, R1, 160 */
		/* 820F7C08h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820F7C08h case    0:*/		return 0x820F7C0C;
		  /* 820F7C0Ch */ case    1:  		/* b -420200 */
		/* 820F7C0Ch case    1:*/		return 0x820912A4;
		/* 820F7C0Ch case    1:*/		return 0x820F7C10;
	}
	return 0x820F7C10;
} // Block from 820F7C08h-820F7C10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F7C10h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7C10);
		  /* 820F7C10h */ case    0:  		/* mfspr R12, LR */
		/* 820F7C10h case    0:*/		regs.R12 = regs.LR;
		/* 820F7C10h case    0:*/		return 0x820F7C14;
		  /* 820F7C14h */ case    1:  		/* bl -420280 */
		/* 820F7C14h case    1:*/		regs.LR = 0x820F7C18; return 0x8209125C;
		/* 820F7C14h case    1:*/		return 0x820F7C18;
		  /* 820F7C18h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820F7C18h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820F7C18h case    2:*/		return 0x820F7C1C;
		  /* 820F7C1Ch */ case    3:  		/* lwz R11, <#[R3 + 260]> */
		/* 820F7C1Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000104) );
		/* 820F7C1Ch case    3:*/		return 0x820F7C20;
		  /* 820F7C20h */ case    4:  		/* lis R9, 29440 */
		/* 820F7C20h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0x7300);
		/* 820F7C20h case    4:*/		return 0x820F7C24;
		  /* 820F7C24h */ case    5:  		/* mr R31, R3 */
		/* 820F7C24h case    5:*/		regs.R31 = regs.R3;
		/* 820F7C24h case    5:*/		return 0x820F7C28;
		  /* 820F7C28h */ case    6:  		/* li R10, 0 */
		/* 820F7C28h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820F7C28h case    6:*/		return 0x820F7C2C;
		  /* 820F7C2Ch */ case    7:  		/* lwz R8, <#[R11]> */
		/* 820F7C2Ch case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820F7C2Ch case    7:*/		return 0x820F7C30;
		  /* 820F7C30h */ case    8:  		/* rlwinm R11, R8, 0, 0, 11 */
		/* 820F7C30h case    8:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R8);
		/* 820F7C30h case    8:*/		return 0x820F7C34;
		  /* 820F7C34h */ case    9:  		/* rlwinm R29, R8, 0, 12, 31 */
		/* 820F7C34h case    9:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R29,regs.R8);
		/* 820F7C34h case    9:*/		return 0x820F7C38;
		  /* 820F7C38h */ case   10:  		/* cmplw CR6, R11, R9 */
		/* 820F7C38h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F7C38h case   10:*/		return 0x820F7C3C;
		  /* 820F7C3Ch */ case   11:  		/* bc 12, CR6_EQ, 52 */
		/* 820F7C3Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820F7C70;  }
		/* 820F7C3Ch case   11:*/		return 0x820F7C40;
		  /* 820F7C40h */ case   12:  		/* lis R9, 29584 */
		/* 820F7C40h case   12:*/		cpu::op::lis<0>(regs,&regs.R9,0x7390);
		/* 820F7C40h case   12:*/		return 0x820F7C44;
		  /* 820F7C44h */ case   13:  		/* cmplw CR6, R11, R9 */
		/* 820F7C44h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F7C44h case   13:*/		return 0x820F7C48;
		  /* 820F7C48h */ case   14:  		/* bc 12, CR6_EQ, 444 */
		/* 820F7C48h case   14:*/		if ( regs.CR[6].eq ) { return 0x820F7E04;  }
		/* 820F7C48h case   14:*/		return 0x820F7C4C;
		  /* 820F7C4Ch */ case   15:  		/* lis R9, 29600 */
		/* 820F7C4Ch case   15:*/		cpu::op::lis<0>(regs,&regs.R9,0x73A0);
		/* 820F7C4Ch case   15:*/		return 0x820F7C50;
		  /* 820F7C50h */ case   16:  		/* cmplw CR6, R11, R9 */
		/* 820F7C50h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F7C50h case   16:*/		return 0x820F7C54;
		  /* 820F7C54h */ case   17:  		/* bc 12, CR6_EQ, 424 */
		/* 820F7C54h case   17:*/		if ( regs.CR[6].eq ) { return 0x820F7DFC;  }
		/* 820F7C54h case   17:*/		return 0x820F7C58;
		  /* 820F7C58h */ case   18:  		/* lis R9, 29616 */
		/* 820F7C58h case   18:*/		cpu::op::lis<0>(regs,&regs.R9,0x73B0);
		/* 820F7C58h case   18:*/		return 0x820F7C5C;
		  /* 820F7C5Ch */ case   19:  		/* cmplw CR6, R11, R9 */
		/* 820F7C5Ch case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F7C5Ch case   19:*/		return 0x820F7C60;
		  /* 820F7C60h */ case   20:  		/* bc 12, CR6_EQ, 404 */
		/* 820F7C60h case   20:*/		if ( regs.CR[6].eq ) { return 0x820F7DF4;  }
		/* 820F7C60h case   20:*/		return 0x820F7C64;
		  /* 820F7C64h */ case   21:  		/* lis R9, 29632 */
		/* 820F7C64h case   21:*/		cpu::op::lis<0>(regs,&regs.R9,0x73C0);
		/* 820F7C64h case   21:*/		return 0x820F7C68;
		  /* 820F7C68h */ case   22:  		/* cmplw CR6, R11, R9 */
		/* 820F7C68h case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F7C68h case   22:*/		return 0x820F7C6C;
		  /* 820F7C6Ch */ case   23:  		/* bc 4, CR6_EQ, 8 */
		/* 820F7C6Ch case   23:*/		if ( !regs.CR[6].eq ) { return 0x820F7C74;  }
		/* 820F7C6Ch case   23:*/		return 0x820F7C70;
	}
	return 0x820F7C70;
} // Block from 820F7C10h-820F7C70h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820F7C70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7C70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7C70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7C70);
		  /* 820F7C70h */ case    0:  		/* li R10, 2 */
		/* 820F7C70h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 820F7C70h case    0:*/		return 0x820F7C74;
	}
	return 0x820F7C74;
} // Block from 820F7C70h-820F7C74h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F7C74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7C74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7C74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7C74);
		  /* 820F7C74h */ case    0:  		/* li R4, 41 */
		/* 820F7C74h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x29);
		/* 820F7C74h case    0:*/		return 0x820F7C78;
		  /* 820F7C78h */ case    1:  		/* mr R3, R31 */
		/* 820F7C78h case    1:*/		regs.R3 = regs.R31;
		/* 820F7C78h case    1:*/		return 0x820F7C7C;
		  /* 820F7C7Ch */ case    2:  		/* rlwimi R4, R10, 16, 0, 15 */
		/* 820F7C7Ch case    2:*/		cpu::op::rlwimi<0,16,0,15>(regs,&regs.R4,regs.R10);
		/* 820F7C7Ch case    2:*/		return 0x820F7C80;
		  /* 820F7C80h */ case    3:  		/* bl -7056 */
		/* 820F7C80h case    3:*/		regs.LR = 0x820F7C84; return 0x820F60F0;
		/* 820F7C80h case    3:*/		return 0x820F7C84;
		  /* 820F7C84h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820F7C84h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7C84h case    4:*/		return 0x820F7C88;
		  /* 820F7C88h */ case    5:  		/* bc 12, CR0_LT, 356 */
		/* 820F7C88h case    5:*/		if ( regs.CR[0].lt ) { return 0x820F7DEC;  }
		/* 820F7C88h case    5:*/		return 0x820F7C8C;
		  /* 820F7C8Ch */ case    6:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F7C8Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F7C8Ch case    6:*/		return 0x820F7C90;
		  /* 820F7C90h */ case    7:  		/* addi R6, R1, 80 */
		/* 820F7C90h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 820F7C90h case    7:*/		return 0x820F7C94;
		  /* 820F7C94h */ case    8:  		/* lwz R10, <#[R31]> */
		/* 820F7C94h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7C94h case    8:*/		return 0x820F7C98;
		  /* 820F7C98h */ case    9:  		/* addi R5, R1, 88 */
		/* 820F7C98h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 820F7C98h case    9:*/		return 0x820F7C9C;
		  /* 820F7C9Ch */ case   10:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F7C9Ch case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F7C9Ch case   10:*/		return 0x820F7CA0;
		  /* 820F7CA0h */ case   11:  		/* mr R3, R31 */
		/* 820F7CA0h case   11:*/		regs.R3 = regs.R31;
		/* 820F7CA0h case   11:*/		return 0x820F7CA4;
		  /* 820F7CA4h */ case   12:  		/* lwz R11, <#[R11 + 8]> */
		/* 820F7CA4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820F7CA4h case   12:*/		return 0x820F7CA8;
		  /* 820F7CA8h */ case   13:  		/* lwz R10, <#[R10 + 328]> */
		/* 820F7CA8h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000148) );
		/* 820F7CA8h case   13:*/		return 0x820F7CAC;
		  /* 820F7CACh */ case   14:  		/* lwz R11, <#[R11]> */
		/* 820F7CACh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F7CACh case   14:*/		return 0x820F7CB0;
		  /* 820F7CB0h */ case   15:  		/* mtspr CTR, R10 */
		/* 820F7CB0h case   15:*/		regs.CTR = regs.R10;
		/* 820F7CB0h case   15:*/		return 0x820F7CB4;
		  /* 820F7CB4h */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F7CB4h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F7CB4h case   16:*/		return 0x820F7CB8;
		  /* 820F7CB8h */ case   17:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F7CB8h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F7CB8h case   17:*/		return 0x820F7CBC;
		  /* 820F7CBCh */ case   18:  		/* bcctrl 20, CR0_LT */
		/* 820F7CBCh case   18:*/		if ( 1 ) { regs.LR = 0x820F7CC0; return (uint32)regs.CTR; }
		/* 820F7CBCh case   18:*/		return 0x820F7CC0;
		  /* 820F7CC0h */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 820F7CC0h case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7CC0h case   19:*/		return 0x820F7CC4;
		  /* 820F7CC4h */ case   20:  		/* bc 12, CR0_LT, 296 */
		/* 820F7CC4h case   20:*/		if ( regs.CR[0].lt ) { return 0x820F7DEC;  }
		/* 820F7CC4h case   20:*/		return 0x820F7CC8;
		  /* 820F7CC8h */ case   21:  		/* lwz R11, <#[R31]> */
		/* 820F7CC8h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7CC8h case   21:*/		return 0x820F7CCC;
		  /* 820F7CCCh */ case   22:  		/* addi R7, R1, 84 */
		/* 820F7CCCh case   22:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x54);
		/* 820F7CCCh case   22:*/		return 0x820F7CD0;
		  /* 820F7CD0h */ case   23:  		/* lwz R10, <#[R31 + 260]> */
		/* 820F7CD0h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000104) );
		/* 820F7CD0h case   23:*/		return 0x820F7CD4;
		  /* 820F7CD4h */ case   24:  		/* lis R6, 15 */
		/* 820F7CD4h case   24:*/		cpu::op::lis<0>(regs,&regs.R6,0xF);
		/* 820F7CD4h case   24:*/		return 0x820F7CD8;
		  /* 820F7CD8h */ case   25:  		/* mr R5, R29 */
		/* 820F7CD8h case   25:*/		regs.R5 = regs.R29;
		/* 820F7CD8h case   25:*/		return 0x820F7CDC;
		  /* 820F7CDCh */ case   26:  		/* mr R3, R31 */
		/* 820F7CDCh case   26:*/		regs.R3 = regs.R31;
		/* 820F7CDCh case   26:*/		return 0x820F7CE0;
	}
	return 0x820F7CE0;
} // Block from 820F7C74h-820F7CE0h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820F7CE0h
// Function '?EmitSINCOS@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7CE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7CE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7CE0);
		  /* 820F7CE0h */ case    0:  		/* lwz R11, <#[R11 + 332]> */
		/* 820F7CE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000014C) );
		/* 820F7CE0h case    0:*/		return 0x820F7CE4;
		  /* 820F7CE4h */ case    1:  		/* lwz R4, <#[R10 + 8]> */
		/* 820F7CE4h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000008) );
		/* 820F7CE4h case    1:*/		return 0x820F7CE8;
		  /* 820F7CE8h */ case    2:  		/* mtspr CTR, R11 */
		/* 820F7CE8h case    2:*/		regs.CTR = regs.R11;
		/* 820F7CE8h case    2:*/		return 0x820F7CEC;
		  /* 820F7CECh */ case    3:  		/* bcctrl 20, CR0_LT */
		/* 820F7CECh case    3:*/		if ( 1 ) { regs.LR = 0x820F7CF0; return (uint32)regs.CTR; }
		/* 820F7CECh case    3:*/		return 0x820F7CF0;
		  /* 820F7CF0h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820F7CF0h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7CF0h case    4:*/		return 0x820F7CF4;
		  /* 820F7CF4h */ case    5:  		/* bc 12, CR0_LT, 248 */
		/* 820F7CF4h case    5:*/		if ( regs.CR[0].lt ) { return 0x820F7DEC;  }
		/* 820F7CF4h case    5:*/		return 0x820F7CF8;
		  /* 820F7CF8h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 820F7CF8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7CF8h case    6:*/		return 0x820F7CFC;
		  /* 820F7CFCh */ case    7:  		/* mr R3, R31 */
		/* 820F7CFCh case    7:*/		regs.R3 = regs.R31;
		/* 820F7CFCh case    7:*/		return 0x820F7D00;
		  /* 820F7D00h */ case    8:  		/* lwz R6, <#[R1 + 80]> */
		/* 820F7D00h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 820F7D00h case    8:*/		return 0x820F7D04;
		  /* 820F7D04h */ case    9:  		/* lwz R5, <#[R1 + 84]> */
		/* 820F7D04h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 820F7D04h case    9:*/		return 0x820F7D08;
		  /* 820F7D08h */ case   10:  		/* lwz R4, <#[R1 + 88]> */
		/* 820F7D08h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000058) );
		/* 820F7D08h case   10:*/		return 0x820F7D0C;
		  /* 820F7D0Ch */ case   11:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F7D0Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F7D0Ch case   11:*/		return 0x820F7D10;
		  /* 820F7D10h */ case   12:  		/* mtspr CTR, R11 */
		/* 820F7D10h case   12:*/		regs.CTR = regs.R11;
		/* 820F7D10h case   12:*/		return 0x820F7D14;
		  /* 820F7D14h */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 820F7D14h case   13:*/		if ( 1 ) { regs.LR = 0x820F7D18; return (uint32)regs.CTR; }
		/* 820F7D14h case   13:*/		return 0x820F7D18;
		  /* 820F7D18h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 820F7D18h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7D18h case   14:*/		return 0x820F7D1C;
		  /* 820F7D1Ch */ case   15:  		/* bc 12, CR0_LT, 208 */
		/* 820F7D1Ch case   15:*/		if ( regs.CR[0].lt ) { return 0x820F7DEC;  }
		/* 820F7D1Ch case   15:*/		return 0x820F7D20;
		  /* 820F7D20h */ case   16:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F7D20h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F7D20h case   16:*/		return 0x820F7D24;
		  /* 820F7D24h */ case   17:  		/* rlwinm R30, R29, 2, 0, 29 */
		/* 820F7D24h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R29);
		/* 820F7D24h case   17:*/		return 0x820F7D28;
		  /* 820F7D28h */ case   18:  		/* lwz R10, <#[R31]> */
		/* 820F7D28h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7D28h case   18:*/		return 0x820F7D2C;
		  /* 820F7D2Ch */ case   19:  		/* addi R6, R1, 80 */
		/* 820F7D2Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 820F7D2Ch case   19:*/		return 0x820F7D30;
		  /* 820F7D30h */ case   20:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F7D30h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F7D30h case   20:*/		return 0x820F7D34;
		  /* 820F7D34h */ case   21:  		/* addi R5, R1, 88 */
		/* 820F7D34h case   21:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 820F7D34h case   21:*/		return 0x820F7D38;
		  /* 820F7D38h */ case   22:  		/* mr R3, R31 */
		/* 820F7D38h case   22:*/		regs.R3 = regs.R31;
		/* 820F7D38h case   22:*/		return 0x820F7D3C;
		  /* 820F7D3Ch */ case   23:  		/* lwz R11, <#[R11 + 8]> */
		/* 820F7D3Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820F7D3Ch case   23:*/		return 0x820F7D40;
		  /* 820F7D40h */ case   24:  		/* lwz R10, <#[R10 + 328]> */
		/* 820F7D40h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000148) );
		/* 820F7D40h case   24:*/		return 0x820F7D44;
		  /* 820F7D44h */ case   25:  		/* lwzx R11, <#[R11 + R30]> */
		/* 820F7D44h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820F7D44h case   25:*/		return 0x820F7D48;
		  /* 820F7D48h */ case   26:  		/* mtspr CTR, R10 */
		/* 820F7D48h case   26:*/		regs.CTR = regs.R10;
		/* 820F7D48h case   26:*/		return 0x820F7D4C;
		  /* 820F7D4Ch */ case   27:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F7D4Ch case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F7D4Ch case   27:*/		return 0x820F7D50;
		  /* 820F7D50h */ case   28:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F7D50h case   28:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F7D50h case   28:*/		return 0x820F7D54;
		  /* 820F7D54h */ case   29:  		/* bcctrl 20, CR0_LT */
		/* 820F7D54h case   29:*/		if ( 1 ) { regs.LR = 0x820F7D58; return (uint32)regs.CTR; }
		/* 820F7D54h case   29:*/		return 0x820F7D58;
		  /* 820F7D58h */ case   30:  		/* cmpwi CR0, R3, 0 */
		/* 820F7D58h case   30:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7D58h case   30:*/		return 0x820F7D5C;
		  /* 820F7D5Ch */ case   31:  		/* bc 12, CR0_LT, 144 */
		/* 820F7D5Ch case   31:*/		if ( regs.CR[0].lt ) { return 0x820F7DEC;  }
		/* 820F7D5Ch case   31:*/		return 0x820F7D60;
		  /* 820F7D60h */ case   32:  		/* lwz R11, <#[R31]> */
		/* 820F7D60h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7D60h case   32:*/		return 0x820F7D64;
		  /* 820F7D64h */ case   33:  		/* addi R7, R1, 84 */
		/* 820F7D64h case   33:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x54);
		/* 820F7D64h case   33:*/		return 0x820F7D68;
		  /* 820F7D68h */ case   34:  		/* lwz R10, <#[R31 + 260]> */
		/* 820F7D68h case   34:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000104) );
		/* 820F7D68h case   34:*/		return 0x820F7D6C;
		  /* 820F7D6Ch */ case   35:  		/* lis R6, 15 */
		/* 820F7D6Ch case   35:*/		cpu::op::lis<0>(regs,&regs.R6,0xF);
		/* 820F7D6Ch case   35:*/		return 0x820F7D70;
		  /* 820F7D70h */ case   36:  		/* mr R5, R29 */
		/* 820F7D70h case   36:*/		regs.R5 = regs.R29;
		/* 820F7D70h case   36:*/		return 0x820F7D74;
		  /* 820F7D74h */ case   37:  		/* mr R3, R31 */
		/* 820F7D74h case   37:*/		regs.R3 = regs.R31;
		/* 820F7D74h case   37:*/		return 0x820F7D78;
		  /* 820F7D78h */ case   38:  		/* lwz R9, <#[R11 + 332]> */
		/* 820F7D78h case   38:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000014C) );
		/* 820F7D78h case   38:*/		return 0x820F7D7C;
		  /* 820F7D7Ch */ case   39:  		/* lwz R11, <#[R10 + 8]> */
		/* 820F7D7Ch case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 820F7D7Ch case   39:*/		return 0x820F7D80;
		  /* 820F7D80h */ case   40:  		/* add R4, R11, R30 */
		/* 820F7D80h case   40:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R30);
		/* 820F7D80h case   40:*/		return 0x820F7D84;
		  /* 820F7D84h */ case   41:  		/* mtspr CTR, R9 */
		/* 820F7D84h case   41:*/		regs.CTR = regs.R9;
		/* 820F7D84h case   41:*/		return 0x820F7D88;
		  /* 820F7D88h */ case   42:  		/* bcctrl 20, CR0_LT */
		/* 820F7D88h case   42:*/		if ( 1 ) { regs.LR = 0x820F7D8C; return (uint32)regs.CTR; }
		/* 820F7D88h case   42:*/		return 0x820F7D8C;
		  /* 820F7D8Ch */ case   43:  		/* cmpwi CR0, R3, 0 */
		/* 820F7D8Ch case   43:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7D8Ch case   43:*/		return 0x820F7D90;
		  /* 820F7D90h */ case   44:  		/* bc 12, CR0_LT, 92 */
		/* 820F7D90h case   44:*/		if ( regs.CR[0].lt ) { return 0x820F7DEC;  }
		/* 820F7D90h case   44:*/		return 0x820F7D94;
		  /* 820F7D94h */ case   45:  		/* lwz R11, <#[R31]> */
		/* 820F7D94h case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7D94h case   45:*/		return 0x820F7D98;
		  /* 820F7D98h */ case   46:  		/* mr R3, R31 */
		/* 820F7D98h case   46:*/		regs.R3 = regs.R31;
		/* 820F7D98h case   46:*/		return 0x820F7D9C;
		  /* 820F7D9Ch */ case   47:  		/* lwz R6, <#[R1 + 80]> */
		/* 820F7D9Ch case   47:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 820F7D9Ch case   47:*/		return 0x820F7DA0;
		  /* 820F7DA0h */ case   48:  		/* lwz R5, <#[R1 + 84]> */
		/* 820F7DA0h case   48:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 820F7DA0h case   48:*/		return 0x820F7DA4;
		  /* 820F7DA4h */ case   49:  		/* lwz R4, <#[R1 + 88]> */
		/* 820F7DA4h case   49:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000058) );
		/* 820F7DA4h case   49:*/		return 0x820F7DA8;
		  /* 820F7DA8h */ case   50:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F7DA8h case   50:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F7DA8h case   50:*/		return 0x820F7DAC;
		  /* 820F7DACh */ case   51:  		/* mtspr CTR, R11 */
		/* 820F7DACh case   51:*/		regs.CTR = regs.R11;
		/* 820F7DACh case   51:*/		return 0x820F7DB0;
		  /* 820F7DB0h */ case   52:  		/* bcctrl 20, CR0_LT */
		/* 820F7DB0h case   52:*/		if ( 1 ) { regs.LR = 0x820F7DB4; return (uint32)regs.CTR; }
		/* 820F7DB0h case   52:*/		return 0x820F7DB4;
		  /* 820F7DB4h */ case   53:  		/* cmpwi CR0, R3, 0 */
		/* 820F7DB4h case   53:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7DB4h case   53:*/		return 0x820F7DB8;
		  /* 820F7DB8h */ case   54:  		/* bc 12, CR0_LT, 52 */
		/* 820F7DB8h case   54:*/		if ( regs.CR[0].lt ) { return 0x820F7DEC;  }
		/* 820F7DB8h case   54:*/		return 0x820F7DBC;
		  /* 820F7DBCh */ case   55:  		/* lwz R11, <#[R31]> */
		/* 820F7DBCh case   55:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7DBCh case   55:*/		return 0x820F7DC0;
		  /* 820F7DC0h */ case   56:  		/* mr R3, R31 */
		/* 820F7DC0h case   56:*/		regs.R3 = regs.R31;
		/* 820F7DC0h case   56:*/		return 0x820F7DC4;
		  /* 820F7DC4h */ case   57:  		/* lwz R11, <#[R11 + 308]> */
		/* 820F7DC4h case   57:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000134) );
		/* 820F7DC4h case   57:*/		return 0x820F7DC8;
		  /* 820F7DC8h */ case   58:  		/* mtspr CTR, R11 */
		/* 820F7DC8h case   58:*/		regs.CTR = regs.R11;
		/* 820F7DC8h case   58:*/		return 0x820F7DCC;
		  /* 820F7DCCh */ case   59:  		/* bcctrl 20, CR0_LT */
		/* 820F7DCCh case   59:*/		if ( 1 ) { regs.LR = 0x820F7DD0; return (uint32)regs.CTR; }
		/* 820F7DCCh case   59:*/		return 0x820F7DD0;
	}
	return 0x820F7DD0;
} // Block from 820F7CE0h-820F7DD0h (60 instructions)

//////////////////////////////////////////////////////
// Block at 820F7DD0h
// Function '?EmitIF@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7DD0);
		  /* 820F7DD0h */ case    0:  		/* cmpwi CR0, R3, 0 */
		/* 820F7DD0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7DD0h case    0:*/		return 0x820F7DD4;
		  /* 820F7DD4h */ case    1:  		/* bc 12, CR0_LT, 24 */
		/* 820F7DD4h case    1:*/		if ( regs.CR[0].lt ) { return 0x820F7DEC;  }
		/* 820F7DD4h case    1:*/		return 0x820F7DD8;
		  /* 820F7DD8h */ case    2:  		/* mr R3, R31 */
		/* 820F7DD8h case    2:*/		regs.R3 = regs.R31;
		/* 820F7DD8h case    2:*/		return 0x820F7DDC;
		  /* 820F7DDCh */ case    3:  		/* bl -42196 */
		/* 820F7DDCh case    3:*/		regs.LR = 0x820F7DE0; return 0x820ED908;
		/* 820F7DDCh case    3:*/		return 0x820F7DE0;
		  /* 820F7DE0h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820F7DE0h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7DE0h case    4:*/		return 0x820F7DE4;
		  /* 820F7DE4h */ case    5:  		/* bc 12, CR0_LT, 8 */
		/* 820F7DE4h case    5:*/		if ( regs.CR[0].lt ) { return 0x820F7DEC;  }
		/* 820F7DE4h case    5:*/		return 0x820F7DE8;
		  /* 820F7DE8h */ case    6:  		/* li R3, 0 */
		/* 820F7DE8h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F7DE8h case    6:*/		return 0x820F7DEC;
	}
	return 0x820F7DEC;
} // Block from 820F7DD0h-820F7DECh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F7DECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7DEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7DEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7DEC);
		  /* 820F7DECh */ case    0:  		/* addi R1, R1, 128 */
		/* 820F7DECh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820F7DECh case    0:*/		return 0x820F7DF0;
		  /* 820F7DF0h */ case    1:  		/* b -420676 */
		/* 820F7DF0h case    1:*/		return 0x820912AC;
		/* 820F7DF0h case    1:*/		return 0x820F7DF4;
	}
	return 0x820F7DF4;
} // Block from 820F7DECh-820F7DF4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F7DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7DF4);
		  /* 820F7DF4h */ case    0:  		/* li R10, 5 */
		/* 820F7DF4h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 820F7DF4h case    0:*/		return 0x820F7DF8;
		  /* 820F7DF8h */ case    1:  		/* b -388 */
		/* 820F7DF8h case    1:*/		return 0x820F7C74;
		/* 820F7DF8h case    1:*/		return 0x820F7DFC;
	}
	return 0x820F7DFC;
} // Block from 820F7DF4h-820F7DFCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F7DFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7DFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7DFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7DFC);
		  /* 820F7DFCh */ case    0:  		/* li R10, 4 */
		/* 820F7DFCh case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 820F7DFCh case    0:*/		return 0x820F7E00;
		  /* 820F7E00h */ case    1:  		/* b -396 */
		/* 820F7E00h case    1:*/		return 0x820F7C74;
		/* 820F7E00h case    1:*/		return 0x820F7E04;
	}
	return 0x820F7E04;
} // Block from 820F7DFCh-820F7E04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F7E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7E04);
		  /* 820F7E04h */ case    0:  		/* li R10, 3 */
		/* 820F7E04h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 820F7E04h case    0:*/		return 0x820F7E08;
		  /* 820F7E08h */ case    1:  		/* b -404 */
		/* 820F7E08h case    1:*/		return 0x820F7C74;
		/* 820F7E08h case    1:*/		return 0x820F7E0C;
		  /* 820F7E0Ch */ case    2:  		/* nop */
		/* 820F7E0Ch case    2:*/		cpu::op::nop();
		/* 820F7E0Ch case    2:*/		return 0x820F7E10;
	}
	return 0x820F7E10;
} // Block from 820F7E04h-820F7E10h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F7E10h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7E10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7E10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7E10);
		  /* 820F7E10h */ case    0:  		/* mfspr R12, LR */
		/* 820F7E10h case    0:*/		regs.R12 = regs.LR;
		/* 820F7E10h case    0:*/		return 0x820F7E14;
		  /* 820F7E14h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820F7E14h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F7E14h case    1:*/		return 0x820F7E18;
		  /* 820F7E18h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820F7E18h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820F7E18h case    2:*/		return 0x820F7E1C;
		  /* 820F7E1Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820F7E1Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F7E1Ch case    3:*/		return 0x820F7E20;
		  /* 820F7E20h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820F7E20h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820F7E20h case    4:*/		return 0x820F7E24;
		  /* 820F7E24h */ case    5:  		/* mr R30, R4 */
		/* 820F7E24h case    5:*/		regs.R30 = regs.R4;
		/* 820F7E24h case    5:*/		return 0x820F7E28;
		  /* 820F7E28h */ case    6:  		/* li R4, 40 */
		/* 820F7E28h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x28);
		/* 820F7E28h case    6:*/		return 0x820F7E2C;
		  /* 820F7E2Ch */ case    7:  		/* mr R31, R3 */
		/* 820F7E2Ch case    7:*/		regs.R31 = regs.R3;
		/* 820F7E2Ch case    7:*/		return 0x820F7E30;
		  /* 820F7E30h */ case    8:  		/* bl -7488 */
		/* 820F7E30h case    8:*/		regs.LR = 0x820F7E34; return 0x820F60F0;
		/* 820F7E30h case    8:*/		return 0x820F7E34;
		  /* 820F7E34h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820F7E34h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7E34h case    9:*/		return 0x820F7E38;
		  /* 820F7E38h */ case   10:  		/* bc 12, CR0_LT, 172 */
		/* 820F7E38h case   10:*/		if ( regs.CR[0].lt ) { return 0x820F7EE4;  }
		/* 820F7E38h case   10:*/		return 0x820F7E3C;
		  /* 820F7E3Ch */ case   11:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F7E3Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F7E3Ch case   11:*/		return 0x820F7E40;
		  /* 820F7E40h */ case   12:  		/* subfic R10, R30, 0 */
		/* 820F7E40h case   12:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R30,0x0);
		/* 820F7E40h case   12:*/		return 0x820F7E44;
		  /* 820F7E44h */ case   13:  		/* lwz R9, <#[R31]> */
		/* 820F7E44h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7E44h case   13:*/		return 0x820F7E48;
		  /* 820F7E48h */ case   14:  		/* lis R8, 3328 */
		/* 820F7E48h case   14:*/		cpu::op::lis<0>(regs,&regs.R8,0xD00);
		/* 820F7E48h case   14:*/		return 0x820F7E4C;
		  /* 820F7E4Ch */ case   15:  		/* lwz R7, <#[R31 + 20]> */
		/* 820F7E4Ch case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000014) );
		/* 820F7E4Ch case   15:*/		return 0x820F7E50;
		  /* 820F7E50h */ case   16:  		/* subfe R10, R10, R10 */
		/* 820F7E50h case   16:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 820F7E50h case   16:*/		return 0x820F7E54;
		  /* 820F7E54h */ case   17:  		/* addi R6, R1, 84 */
		/* 820F7E54h case   17:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 820F7E54h case   17:*/		return 0x820F7E58;
		  /* 820F7E58h */ case   18:  		/* addi R5, R1, 80 */
		/* 820F7E58h case   18:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820F7E58h case   18:*/		return 0x820F7E5C;
		  /* 820F7E5Ch */ case   19:  		/* lwz R11, <#[R11 + 8]> */
		/* 820F7E5Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820F7E5Ch case   19:*/		return 0x820F7E60;
		  /* 820F7E60h */ case   20:  		/* mr R3, R31 */
		/* 820F7E60h case   20:*/		regs.R3 = regs.R31;
		/* 820F7E60h case   20:*/		return 0x820F7E64;
		  /* 820F7E64h */ case   21:  		/* lwz R9, <#[R9 + 328]> */
		/* 820F7E64h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000148) );
		/* 820F7E64h case   21:*/		return 0x820F7E68;
		  /* 820F7E68h */ case   22:  		/* and R30, R10, R8 */
		/* 820F7E68h case   22:*/		cpu::op::and<0>(regs,&regs.R30,regs.R10,regs.R8);
		/* 820F7E68h case   22:*/		return 0x820F7E6C;
		  /* 820F7E6Ch */ case   23:  		/* lwz R11, <#[R11]> */
		/* 820F7E6Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F7E6Ch case   23:*/		return 0x820F7E70;
		  /* 820F7E70h */ case   24:  		/* mtspr CTR, R9 */
		/* 820F7E70h case   24:*/		regs.CTR = regs.R9;
		/* 820F7E70h case   24:*/		return 0x820F7E74;
		  /* 820F7E74h */ case   25:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F7E74h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F7E74h case   25:*/		return 0x820F7E78;
		  /* 820F7E78h */ case   26:  		/* lwzx R4, <#[R11 + R7]> */
		/* 820F7E78h case   26:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820F7E78h case   26:*/		return 0x820F7E7C;
		  /* 820F7E7Ch */ case   27:  		/* bcctrl 20, CR0_LT */
		/* 820F7E7Ch case   27:*/		if ( 1 ) { regs.LR = 0x820F7E80; return (uint32)regs.CTR; }
		/* 820F7E7Ch case   27:*/		return 0x820F7E80;
		  /* 820F7E80h */ case   28:  		/* cmpwi CR0, R3, 0 */
		/* 820F7E80h case   28:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7E80h case   28:*/		return 0x820F7E84;
		  /* 820F7E84h */ case   29:  		/* bc 12, CR0_LT, 96 */
		/* 820F7E84h case   29:*/		if ( regs.CR[0].lt ) { return 0x820F7EE4;  }
		/* 820F7E84h case   29:*/		return 0x820F7E88;
		  /* 820F7E88h */ case   30:  		/* lwz R11, <#[R31]> */
		/* 820F7E88h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7E88h case   30:*/		return 0x820F7E8C;
		  /* 820F7E8Ch */ case   31:  		/* lis R5, 228 */
		/* 820F7E8Ch case   31:*/		cpu::op::lis<0>(regs,&regs.R5,0xE4);
		/* 820F7E8Ch case   31:*/		return 0x820F7E90;
		  /* 820F7E90h */ case   32:  		/* lwz R10, <#[R1 + 80]> */
		/* 820F7E90h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820F7E90h case   32:*/		return 0x820F7E94;
		  /* 820F7E94h */ case   33:  		/* mr R3, R31 */
		/* 820F7E94h case   33:*/		regs.R3 = regs.R31;
		/* 820F7E94h case   33:*/		return 0x820F7E98;
		  /* 820F7E98h */ case   34:  		/* lwz R6, <#[R1 + 84]> */
		/* 820F7E98h case   34:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 820F7E98h case   34:*/		return 0x820F7E9C;
		  /* 820F7E9Ch */ case   35:  		/* or R4, R10, R30 */
		/* 820F7E9Ch case   35:*/		cpu::op::or<0>(regs,&regs.R4,regs.R10,regs.R30);
		/* 820F7E9Ch case   35:*/		return 0x820F7EA0;
		  /* 820F7EA0h */ case   36:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F7EA0h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F7EA0h case   36:*/		return 0x820F7EA4;
		  /* 820F7EA4h */ case   37:  		/* mtspr CTR, R11 */
		/* 820F7EA4h case   37:*/		regs.CTR = regs.R11;
		/* 820F7EA4h case   37:*/		return 0x820F7EA8;
		  /* 820F7EA8h */ case   38:  		/* bcctrl 20, CR0_LT */
		/* 820F7EA8h case   38:*/		if ( 1 ) { regs.LR = 0x820F7EAC; return (uint32)regs.CTR; }
		/* 820F7EA8h case   38:*/		return 0x820F7EAC;
		  /* 820F7EACh */ case   39:  		/* cmpwi CR0, R3, 0 */
		/* 820F7EACh case   39:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7EACh case   39:*/		return 0x820F7EB0;
		  /* 820F7EB0h */ case   40:  		/* bc 12, CR0_LT, 52 */
		/* 820F7EB0h case   40:*/		if ( regs.CR[0].lt ) { return 0x820F7EE4;  }
		/* 820F7EB0h case   40:*/		return 0x820F7EB4;
		  /* 820F7EB4h */ case   41:  		/* lwz R11, <#[R31]> */
		/* 820F7EB4h case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7EB4h case   41:*/		return 0x820F7EB8;
		  /* 820F7EB8h */ case   42:  		/* mr R3, R31 */
		/* 820F7EB8h case   42:*/		regs.R3 = regs.R31;
		/* 820F7EB8h case   42:*/		return 0x820F7EBC;
		  /* 820F7EBCh */ case   43:  		/* lwz R11, <#[R11 + 308]> */
		/* 820F7EBCh case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000134) );
		/* 820F7EBCh case   43:*/		return 0x820F7EC0;
		  /* 820F7EC0h */ case   44:  		/* mtspr CTR, R11 */
		/* 820F7EC0h case   44:*/		regs.CTR = regs.R11;
		/* 820F7EC0h case   44:*/		return 0x820F7EC4;
		  /* 820F7EC4h */ case   45:  		/* bcctrl 20, CR0_LT */
		/* 820F7EC4h case   45:*/		if ( 1 ) { regs.LR = 0x820F7EC8; return (uint32)regs.CTR; }
		/* 820F7EC4h case   45:*/		return 0x820F7EC8;
		  /* 820F7EC8h */ case   46:  		/* cmpwi CR0, R3, 0 */
		/* 820F7EC8h case   46:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7EC8h case   46:*/		return 0x820F7ECC;
		  /* 820F7ECCh */ case   47:  		/* bc 12, CR0_LT, 24 */
		/* 820F7ECCh case   47:*/		if ( regs.CR[0].lt ) { return 0x820F7EE4;  }
		/* 820F7ECCh case   47:*/		return 0x820F7ED0;
		  /* 820F7ED0h */ case   48:  		/* mr R3, R31 */
		/* 820F7ED0h case   48:*/		regs.R3 = regs.R31;
		/* 820F7ED0h case   48:*/		return 0x820F7ED4;
		  /* 820F7ED4h */ case   49:  		/* bl -42444 */
		/* 820F7ED4h case   49:*/		regs.LR = 0x820F7ED8; return 0x820ED908;
		/* 820F7ED4h case   49:*/		return 0x820F7ED8;
		  /* 820F7ED8h */ case   50:  		/* cmpwi CR0, R3, 0 */
		/* 820F7ED8h case   50:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7ED8h case   50:*/		return 0x820F7EDC;
		  /* 820F7EDCh */ case   51:  		/* bc 12, CR0_LT, 8 */
		/* 820F7EDCh case   51:*/		if ( regs.CR[0].lt ) { return 0x820F7EE4;  }
		/* 820F7EDCh case   51:*/		return 0x820F7EE0;
		  /* 820F7EE0h */ case   52:  		/* li R3, 0 */
		/* 820F7EE0h case   52:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F7EE0h case   52:*/		return 0x820F7EE4;
	}
	return 0x820F7EE4;
} // Block from 820F7E10h-820F7EE4h (53 instructions)

//////////////////////////////////////////////////////
// Block at 820F7EE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7EE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7EE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7EE4);
		  /* 820F7EE4h */ case    0:  		/* addi R1, R1, 112 */
		/* 820F7EE4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820F7EE4h case    0:*/		return 0x820F7EE8;
		  /* 820F7EE8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820F7EE8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F7EE8h case    1:*/		return 0x820F7EEC;
		  /* 820F7EECh */ case    2:  		/* mtspr LR, R12 */
		/* 820F7EECh case    2:*/		regs.LR = regs.R12;
		/* 820F7EECh case    2:*/		return 0x820F7EF0;
		  /* 820F7EF0h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820F7EF0h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820F7EF0h case    3:*/		return 0x820F7EF4;
		  /* 820F7EF4h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820F7EF4h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F7EF4h case    4:*/		return 0x820F7EF8;
		  /* 820F7EF8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820F7EF8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F7EF8h case    5:*/		return 0x820F7EFC;
	}
	return 0x820F7EFC;
} // Block from 820F7EE4h-820F7EFCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F7EFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7EFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7EFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7EFC);
		  /* 820F7EFCh */ case    0:  		/* nop */
		/* 820F7EFCh case    0:*/		cpu::op::nop();
		/* 820F7EFCh case    0:*/		return 0x820F7F00;
	}
	return 0x820F7F00;
} // Block from 820F7EFCh-820F7F00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F7F00h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7F00);
		  /* 820F7F00h */ case    0:  		/* mfspr R12, LR */
		/* 820F7F00h case    0:*/		regs.R12 = regs.LR;
		/* 820F7F00h case    0:*/		return 0x820F7F04;
		  /* 820F7F04h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820F7F04h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F7F04h case    1:*/		return 0x820F7F08;
		  /* 820F7F08h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820F7F08h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F7F08h case    2:*/		return 0x820F7F0C;
		  /* 820F7F0Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820F7F0Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820F7F0Ch case    3:*/		return 0x820F7F10;
		  /* 820F7F10h */ case    4:  		/* li R4, 42 */
		/* 820F7F10h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x2A);
		/* 820F7F10h case    4:*/		return 0x820F7F14;
		  /* 820F7F14h */ case    5:  		/* mr R31, R3 */
		/* 820F7F14h case    5:*/		regs.R31 = regs.R3;
		/* 820F7F14h case    5:*/		return 0x820F7F18;
		  /* 820F7F18h */ case    6:  		/* bl -7720 */
		/* 820F7F18h case    6:*/		regs.LR = 0x820F7F1C; return 0x820F60F0;
		/* 820F7F18h case    6:*/		return 0x820F7F1C;
		  /* 820F7F1Ch */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820F7F1Ch case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7F1Ch case    7:*/		return 0x820F7F20;
		  /* 820F7F20h */ case    8:  		/* bc 12, CR0_LT, 52 */
		/* 820F7F20h case    8:*/		if ( regs.CR[0].lt ) { return 0x820F7F54;  }
		/* 820F7F20h case    8:*/		return 0x820F7F24;
		  /* 820F7F24h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 820F7F24h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7F24h case    9:*/		return 0x820F7F28;
		  /* 820F7F28h */ case   10:  		/* mr R3, R31 */
		/* 820F7F28h case   10:*/		regs.R3 = regs.R31;
		/* 820F7F28h case   10:*/		return 0x820F7F2C;
		  /* 820F7F2Ch */ case   11:  		/* lwz R11, <#[R11 + 308]> */
		/* 820F7F2Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000134) );
		/* 820F7F2Ch case   11:*/		return 0x820F7F30;
		  /* 820F7F30h */ case   12:  		/* mtspr CTR, R11 */
		/* 820F7F30h case   12:*/		regs.CTR = regs.R11;
		/* 820F7F30h case   12:*/		return 0x820F7F34;
		  /* 820F7F34h */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 820F7F34h case   13:*/		if ( 1 ) { regs.LR = 0x820F7F38; return (uint32)regs.CTR; }
		/* 820F7F34h case   13:*/		return 0x820F7F38;
		  /* 820F7F38h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 820F7F38h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7F38h case   14:*/		return 0x820F7F3C;
		  /* 820F7F3Ch */ case   15:  		/* bc 12, CR0_LT, 24 */
		/* 820F7F3Ch case   15:*/		if ( regs.CR[0].lt ) { return 0x820F7F54;  }
		/* 820F7F3Ch case   15:*/		return 0x820F7F40;
		  /* 820F7F40h */ case   16:  		/* mr R3, R31 */
		/* 820F7F40h case   16:*/		regs.R3 = regs.R31;
		/* 820F7F40h case   16:*/		return 0x820F7F44;
		  /* 820F7F44h */ case   17:  		/* bl -42556 */
		/* 820F7F44h case   17:*/		regs.LR = 0x820F7F48; return 0x820ED908;
		/* 820F7F44h case   17:*/		return 0x820F7F48;
		  /* 820F7F48h */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 820F7F48h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7F48h case   18:*/		return 0x820F7F4C;
		  /* 820F7F4Ch */ case   19:  		/* bc 12, CR0_LT, 8 */
		/* 820F7F4Ch case   19:*/		if ( regs.CR[0].lt ) { return 0x820F7F54;  }
		/* 820F7F4Ch case   19:*/		return 0x820F7F50;
		  /* 820F7F50h */ case   20:  		/* li R3, 0 */
		/* 820F7F50h case   20:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F7F50h case   20:*/		return 0x820F7F54;
	}
	return 0x820F7F54;
} // Block from 820F7F00h-820F7F54h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820F7F54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7F54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7F54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7F54);
		  /* 820F7F54h */ case    0:  		/* addi R1, R1, 96 */
		/* 820F7F54h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820F7F54h case    0:*/		return 0x820F7F58;
		  /* 820F7F58h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820F7F58h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F7F58h case    1:*/		return 0x820F7F5C;
		  /* 820F7F5Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820F7F5Ch case    2:*/		regs.LR = regs.R12;
		/* 820F7F5Ch case    2:*/		return 0x820F7F60;
		  /* 820F7F60h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820F7F60h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F7F60h case    3:*/		return 0x820F7F64;
		  /* 820F7F64h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820F7F64h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F7F64h case    4:*/		return 0x820F7F68;
	}
	return 0x820F7F68;
} // Block from 820F7F54h-820F7F68h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F7F68h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7F68);
		  /* 820F7F68h */ case    0:  		/* mfspr R12, LR */
		/* 820F7F68h case    0:*/		regs.R12 = regs.LR;
		/* 820F7F68h case    0:*/		return 0x820F7F6C;
		  /* 820F7F6Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820F7F6Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F7F6Ch case    1:*/		return 0x820F7F70;
		  /* 820F7F70h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820F7F70h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F7F70h case    2:*/		return 0x820F7F74;
		  /* 820F7F74h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820F7F74h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820F7F74h case    3:*/		return 0x820F7F78;
		  /* 820F7F78h */ case    4:  		/* li R4, 43 */
		/* 820F7F78h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x2B);
		/* 820F7F78h case    4:*/		return 0x820F7F7C;
		  /* 820F7F7Ch */ case    5:  		/* mr R31, R3 */
		/* 820F7F7Ch case    5:*/		regs.R31 = regs.R3;
		/* 820F7F7Ch case    5:*/		return 0x820F7F80;
		  /* 820F7F80h */ case    6:  		/* bl -7824 */
		/* 820F7F80h case    6:*/		regs.LR = 0x820F7F84; return 0x820F60F0;
		/* 820F7F80h case    6:*/		return 0x820F7F84;
		  /* 820F7F84h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820F7F84h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7F84h case    7:*/		return 0x820F7F88;
		  /* 820F7F88h */ case    8:  		/* bc 12, CR0_LT, 52 */
		/* 820F7F88h case    8:*/		if ( regs.CR[0].lt ) { return 0x820F7FBC;  }
		/* 820F7F88h case    8:*/		return 0x820F7F8C;
		  /* 820F7F8Ch */ case    9:  		/* lwz R11, <#[R31]> */
		/* 820F7F8Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7F8Ch case    9:*/		return 0x820F7F90;
		  /* 820F7F90h */ case   10:  		/* mr R3, R31 */
		/* 820F7F90h case   10:*/		regs.R3 = regs.R31;
		/* 820F7F90h case   10:*/		return 0x820F7F94;
		  /* 820F7F94h */ case   11:  		/* lwz R11, <#[R11 + 308]> */
		/* 820F7F94h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000134) );
		/* 820F7F94h case   11:*/		return 0x820F7F98;
		  /* 820F7F98h */ case   12:  		/* mtspr CTR, R11 */
		/* 820F7F98h case   12:*/		regs.CTR = regs.R11;
		/* 820F7F98h case   12:*/		return 0x820F7F9C;
		  /* 820F7F9Ch */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 820F7F9Ch case   13:*/		if ( 1 ) { regs.LR = 0x820F7FA0; return (uint32)regs.CTR; }
		/* 820F7F9Ch case   13:*/		return 0x820F7FA0;
		  /* 820F7FA0h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 820F7FA0h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7FA0h case   14:*/		return 0x820F7FA4;
		  /* 820F7FA4h */ case   15:  		/* bc 12, CR0_LT, 24 */
		/* 820F7FA4h case   15:*/		if ( regs.CR[0].lt ) { return 0x820F7FBC;  }
		/* 820F7FA4h case   15:*/		return 0x820F7FA8;
		  /* 820F7FA8h */ case   16:  		/* mr R3, R31 */
		/* 820F7FA8h case   16:*/		regs.R3 = regs.R31;
		/* 820F7FA8h case   16:*/		return 0x820F7FAC;
		  /* 820F7FACh */ case   17:  		/* bl -42660 */
		/* 820F7FACh case   17:*/		regs.LR = 0x820F7FB0; return 0x820ED908;
		/* 820F7FACh case   17:*/		return 0x820F7FB0;
		  /* 820F7FB0h */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 820F7FB0h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7FB0h case   18:*/		return 0x820F7FB4;
		  /* 820F7FB4h */ case   19:  		/* bc 12, CR0_LT, 8 */
		/* 820F7FB4h case   19:*/		if ( regs.CR[0].lt ) { return 0x820F7FBC;  }
		/* 820F7FB4h case   19:*/		return 0x820F7FB8;
		  /* 820F7FB8h */ case   20:  		/* li R3, 0 */
		/* 820F7FB8h case   20:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F7FB8h case   20:*/		return 0x820F7FBC;
	}
	return 0x820F7FBC;
} // Block from 820F7F68h-820F7FBCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 820F7FBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7FBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7FBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7FBC);
		  /* 820F7FBCh */ case    0:  		/* addi R1, R1, 96 */
		/* 820F7FBCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820F7FBCh case    0:*/		return 0x820F7FC0;
		  /* 820F7FC0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820F7FC0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F7FC0h case    1:*/		return 0x820F7FC4;
		  /* 820F7FC4h */ case    2:  		/* mtspr LR, R12 */
		/* 820F7FC4h case    2:*/		regs.LR = regs.R12;
		/* 820F7FC4h case    2:*/		return 0x820F7FC8;
		  /* 820F7FC8h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820F7FC8h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F7FC8h case    3:*/		return 0x820F7FCC;
		  /* 820F7FCCh */ case    4:  		/* bclr 20, CR0_LT */
		/* 820F7FCCh case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F7FCCh case    4:*/		return 0x820F7FD0;
	}
	return 0x820F7FD0;
} // Block from 820F7FBCh-820F7FD0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F7FD0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F7FD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F7FD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F7FD0);
		  /* 820F7FD0h */ case    0:  		/* mfspr R12, LR */
		/* 820F7FD0h case    0:*/		regs.R12 = regs.LR;
		/* 820F7FD0h case    0:*/		return 0x820F7FD4;
		  /* 820F7FD4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820F7FD4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F7FD4h case    1:*/		return 0x820F7FD8;
		  /* 820F7FD8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820F7FD8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F7FD8h case    2:*/		return 0x820F7FDC;
		  /* 820F7FDCh */ case    3:  		/* stwu R1, <#[R1 - 128]> */
		/* 820F7FDCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820F7FDCh case    3:*/		return 0x820F7FE0;
		  /* 820F7FE0h */ case    4:  		/* li R4, 1 */
		/* 820F7FE0h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820F7FE0h case    4:*/		return 0x820F7FE4;
		  /* 820F7FE4h */ case    5:  		/* mr R31, R3 */
		/* 820F7FE4h case    5:*/		regs.R31 = regs.R3;
		/* 820F7FE4h case    5:*/		return 0x820F7FE8;
		  /* 820F7FE8h */ case    6:  		/* bl -7928 */
		/* 820F7FE8h case    6:*/		regs.LR = 0x820F7FEC; return 0x820F60F0;
		/* 820F7FE8h case    6:*/		return 0x820F7FEC;
		  /* 820F7FECh */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820F7FECh case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F7FECh case    7:*/		return 0x820F7FF0;
		  /* 820F7FF0h */ case    8:  		/* bc 12, CR0_LT, 388 */
		/* 820F7FF0h case    8:*/		if ( regs.CR[0].lt ) { return 0x820F8174;  }
		/* 820F7FF0h case    8:*/		return 0x820F7FF4;
		  /* 820F7FF4h */ case    9:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F7FF4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F7FF4h case    9:*/		return 0x820F7FF8;
		  /* 820F7FF8h */ case   10:  		/* addi R7, R1, 96 */
		/* 820F7FF8h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820F7FF8h case   10:*/		return 0x820F7FFC;
		  /* 820F7FFCh */ case   11:  		/* lwz R10, <#[R31]> */
		/* 820F7FFCh case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F7FFCh case   11:*/		return 0x820F8000;
		  /* 820F8000h */ case   12:  		/* addi R6, R1, 100 */
		/* 820F8000h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x64);
		/* 820F8000h case   12:*/		return 0x820F8004;
		  /* 820F8004h */ case   13:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F8004h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F8004h case   13:*/		return 0x820F8008;
		  /* 820F8008h */ case   14:  		/* addi R5, R1, 80 */
		/* 820F8008h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820F8008h case   14:*/		return 0x820F800C;
		  /* 820F800Ch */ case   15:  		/* mr R3, R31 */
		/* 820F800Ch case   15:*/		regs.R3 = regs.R31;
		/* 820F800Ch case   15:*/		return 0x820F8010;
		  /* 820F8010h */ case   16:  		/* lwz R11, <#[R11 + 16]> */
		/* 820F8010h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820F8010h case   16:*/		return 0x820F8014;
		  /* 820F8014h */ case   17:  		/* lwz R10, <#[R10 + 320]> */
		/* 820F8014h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000140) );
		/* 820F8014h case   17:*/		return 0x820F8018;
		  /* 820F8018h */ case   18:  		/* lwz R11, <#[R11]> */
		/* 820F8018h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F8018h case   18:*/		return 0x820F801C;
		  /* 820F801Ch */ case   19:  		/* mtspr CTR, R10 */
		/* 820F801Ch case   19:*/		regs.CTR = regs.R10;
		/* 820F801Ch case   19:*/		return 0x820F8020;
		  /* 820F8020h */ case   20:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F8020h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F8020h case   20:*/		return 0x820F8024;
		  /* 820F8024h */ case   21:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F8024h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F8024h case   21:*/		return 0x820F8028;
		  /* 820F8028h */ case   22:  		/* bcctrl 20, CR0_LT */
		/* 820F8028h case   22:*/		if ( 1 ) { regs.LR = 0x820F802C; return (uint32)regs.CTR; }
		/* 820F8028h case   22:*/		return 0x820F802C;
		  /* 820F802Ch */ case   23:  		/* cmpwi CR0, R3, 0 */
		/* 820F802Ch case   23:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F802Ch case   23:*/		return 0x820F8030;
		  /* 820F8030h */ case   24:  		/* bc 12, CR0_LT, 324 */
		/* 820F8030h case   24:*/		if ( regs.CR[0].lt ) { return 0x820F8174;  }
		/* 820F8030h case   24:*/		return 0x820F8034;
		  /* 820F8034h */ case   25:  		/* lwz R11, <#[R31]> */
		/* 820F8034h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F8034h case   25:*/		return 0x820F8038;
		  /* 820F8038h */ case   26:  		/* addi R6, R1, 84 */
		/* 820F8038h case   26:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 820F8038h case   26:*/		return 0x820F803C;
		  /* 820F803Ch */ case   27:  		/* lwz R10, <#[R31 + 260]> */
		/* 820F803Ch case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000104) );
		/* 820F803Ch case   27:*/		return 0x820F8040;
		  /* 820F8040h */ case   28:  		/* mr R3, R31 */
		/* 820F8040h case   28:*/		regs.R3 = regs.R31;
		/* 820F8040h case   28:*/		return 0x820F8044;
		  /* 820F8044h */ case   29:  		/* lwz R7, <#[R1 + 96]> */
		/* 820F8044h case   29:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000060) );
		/* 820F8044h case   29:*/		return 0x820F8048;
		  /* 820F8048h */ case   30:  		/* lwz R11, <#[R11 + 324]> */
		/* 820F8048h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000144) );
		/* 820F8048h case   30:*/		return 0x820F804C;
		  /* 820F804Ch */ case   31:  		/* lwz R5, <#[R10 + 12]> */
		/* 820F804Ch case   31:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x0000000C) );
		/* 820F804Ch case   31:*/		return 0x820F8050;
		  /* 820F8050h */ case   32:  		/* lwz R4, <#[R10 + 16]> */
		/* 820F8050h case   32:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000010) );
		/* 820F8050h case   32:*/		return 0x820F8054;
		  /* 820F8054h */ case   33:  		/* mtspr CTR, R11 */
		/* 820F8054h case   33:*/		regs.CTR = regs.R11;
		/* 820F8054h case   33:*/		return 0x820F8058;
		  /* 820F8058h */ case   34:  		/* bcctrl 20, CR0_LT */
		/* 820F8058h case   34:*/		if ( 1 ) { regs.LR = 0x820F805C; return (uint32)regs.CTR; }
		/* 820F8058h case   34:*/		return 0x820F805C;
		  /* 820F805Ch */ case   35:  		/* cmpwi CR0, R3, 0 */
		/* 820F805Ch case   35:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F805Ch case   35:*/		return 0x820F8060;
		  /* 820F8060h */ case   36:  		/* bc 12, CR0_LT, 276 */
		/* 820F8060h case   36:*/		if ( regs.CR[0].lt ) { return 0x820F8174;  }
		/* 820F8060h case   36:*/		return 0x820F8064;
		  /* 820F8064h */ case   37:  		/* lwz R11, <#[R31]> */
		/* 820F8064h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F8064h case   37:*/		return 0x820F8068;
		  /* 820F8068h */ case   38:  		/* mr R3, R31 */
		/* 820F8068h case   38:*/		regs.R3 = regs.R31;
		/* 820F8068h case   38:*/		return 0x820F806C;
		  /* 820F806Ch */ case   39:  		/* lwz R6, <#[R1 + 100]> */
		/* 820F806Ch case   39:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000064) );
		/* 820F806Ch case   39:*/		return 0x820F8070;
		  /* 820F8070h */ case   40:  		/* lwz R5, <#[R1 + 84]> */
		/* 820F8070h case   40:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 820F8070h case   40:*/		return 0x820F8074;
		  /* 820F8074h */ case   41:  		/* lwz R4, <#[R1 + 80]> */
		/* 820F8074h case   41:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 820F8074h case   41:*/		return 0x820F8078;
		  /* 820F8078h */ case   42:  		/* lwz R11, <#[R11 + 312]> */
		/* 820F8078h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000138) );
		/* 820F8078h case   42:*/		return 0x820F807C;
		  /* 820F807Ch */ case   43:  		/* mtspr CTR, R11 */
		/* 820F807Ch case   43:*/		regs.CTR = regs.R11;
		/* 820F807Ch case   43:*/		return 0x820F8080;
		  /* 820F8080h */ case   44:  		/* bcctrl 20, CR0_LT */
		/* 820F8080h case   44:*/		if ( 1 ) { regs.LR = 0x820F8084; return (uint32)regs.CTR; }
		/* 820F8080h case   44:*/		return 0x820F8084;
		  /* 820F8084h */ case   45:  		/* cmpwi CR0, R3, 0 */
		/* 820F8084h case   45:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8084h case   45:*/		return 0x820F8088;
		  /* 820F8088h */ case   46:  		/* bc 12, CR0_LT, 236 */
		/* 820F8088h case   46:*/		if ( regs.CR[0].lt ) { return 0x820F8174;  }
		/* 820F8088h case   46:*/		return 0x820F808C;
		  /* 820F808Ch */ case   47:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F808Ch case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F808Ch case   47:*/		return 0x820F8090;
		  /* 820F8090h */ case   48:  		/* addi R6, R1, 92 */
		/* 820F8090h case   48:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x5C);
		/* 820F8090h case   48:*/		return 0x820F8094;
		  /* 820F8094h */ case   49:  		/* lwz R10, <#[R31]> */
		/* 820F8094h case   49:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F8094h case   49:*/		return 0x820F8098;
		  /* 820F8098h */ case   50:  		/* addi R5, R1, 80 */
		/* 820F8098h case   50:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820F8098h case   50:*/		return 0x820F809C;
		  /* 820F809Ch */ case   51:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F809Ch case   51:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F809Ch case   51:*/		return 0x820F80A0;
		  /* 820F80A0h */ case   52:  		/* mr R3, R31 */
		/* 820F80A0h case   52:*/		regs.R3 = regs.R31;
		/* 820F80A0h case   52:*/		return 0x820F80A4;
		  /* 820F80A4h */ case   53:  		/* lwz R11, <#[R11 + 8]> */
		/* 820F80A4h case   53:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820F80A4h case   53:*/		return 0x820F80A8;
		  /* 820F80A8h */ case   54:  		/* lwz R10, <#[R10 + 328]> */
		/* 820F80A8h case   54:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000148) );
		/* 820F80A8h case   54:*/		return 0x820F80AC;
		  /* 820F80ACh */ case   55:  		/* lwz R11, <#[R11]> */
		/* 820F80ACh case   55:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F80ACh case   55:*/		return 0x820F80B0;
		  /* 820F80B0h */ case   56:  		/* mtspr CTR, R10 */
		/* 820F80B0h case   56:*/		regs.CTR = regs.R10;
		/* 820F80B0h case   56:*/		return 0x820F80B4;
		  /* 820F80B4h */ case   57:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F80B4h case   57:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F80B4h case   57:*/		return 0x820F80B8;
		  /* 820F80B8h */ case   58:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F80B8h case   58:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F80B8h case   58:*/		return 0x820F80BC;
		  /* 820F80BCh */ case   59:  		/* bcctrl 20, CR0_LT */
		/* 820F80BCh case   59:*/		if ( 1 ) { regs.LR = 0x820F80C0; return (uint32)regs.CTR; }
		/* 820F80BCh case   59:*/		return 0x820F80C0;
		  /* 820F80C0h */ case   60:  		/* cmpwi CR0, R3, 0 */
		/* 820F80C0h case   60:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F80C0h case   60:*/		return 0x820F80C4;
		  /* 820F80C4h */ case   61:  		/* bc 12, CR0_LT, 176 */
		/* 820F80C4h case   61:*/		if ( regs.CR[0].lt ) { return 0x820F8174;  }
		/* 820F80C4h case   61:*/		return 0x820F80C8;
		  /* 820F80C8h */ case   62:  		/* lwz R11, <#[R31]> */
		/* 820F80C8h case   62:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F80C8h case   62:*/		return 0x820F80CC;
		  /* 820F80CCh */ case   63:  		/* addi R7, R1, 88 */
		/* 820F80CCh case   63:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x58);
		/* 820F80CCh case   63:*/		return 0x820F80D0;
		  /* 820F80D0h */ case   64:  		/* lwz R10, <#[R31 + 260]> */
		/* 820F80D0h case   64:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000104) );
		/* 820F80D0h case   64:*/		return 0x820F80D4;
		  /* 820F80D4h */ case   65:  		/* mr R3, R31 */
		/* 820F80D4h case   65:*/		regs.R3 = regs.R31;
		/* 820F80D4h case   65:*/		return 0x820F80D8;
		  /* 820F80D8h */ case   66:  		/* lwz R6, <#[R1 + 84]> */
		/* 820F80D8h case   66:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 820F80D8h case   66:*/		return 0x820F80DC;
		  /* 820F80DCh */ case   67:  		/* lwz R11, <#[R11 + 332]> */
		/* 820F80DCh case   67:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000014C) );
		/* 820F80DCh case   67:*/		return 0x820F80E0;
		  /* 820F80E0h */ case   68:  		/* lwz R5, <#[R10 + 12]> */
		/* 820F80E0h case   68:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x0000000C) );
		/* 820F80E0h case   68:*/		return 0x820F80E4;
		  /* 820F80E4h */ case   69:  		/* lwz R4, <#[R10 + 8]> */
		/* 820F80E4h case   69:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000008) );
		/* 820F80E4h case   69:*/		return 0x820F80E8;
		  /* 820F80E8h */ case   70:  		/* mtspr CTR, R11 */
		/* 820F80E8h case   70:*/		regs.CTR = regs.R11;
		/* 820F80E8h case   70:*/		return 0x820F80EC;
		  /* 820F80ECh */ case   71:  		/* bcctrl 20, CR0_LT */
		/* 820F80ECh case   71:*/		if ( 1 ) { regs.LR = 0x820F80F0; return (uint32)regs.CTR; }
		/* 820F80ECh case   71:*/		return 0x820F80F0;
		  /* 820F80F0h */ case   72:  		/* cmpwi CR0, R3, 0 */
		/* 820F80F0h case   72:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F80F0h case   72:*/		return 0x820F80F4;
		  /* 820F80F4h */ case   73:  		/* bc 12, CR0_LT, 128 */
		/* 820F80F4h case   73:*/		if ( regs.CR[0].lt ) { return 0x820F8174;  }
		/* 820F80F4h case   73:*/		return 0x820F80F8;
		  /* 820F80F8h */ case   74:  		/* lwz R4, <#[R1 + 80]> */
		/* 820F80F8h case   74:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 820F80F8h case   74:*/		return 0x820F80FC;
		  /* 820F80FCh */ case   75:  		/* lis R11, 2816 */
		/* 820F80FCh case   75:*/		cpu::op::lis<0>(regs,&regs.R11,0xB00);
		/* 820F80FCh case   75:*/		return 0x820F8100;
	}
	return 0x820F8100;
} // Block from 820F7FD0h-820F8100h (76 instructions)

//////////////////////////////////////////////////////
// Block at 820F8100h
// Function '?EmitENDIF@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8100);
		  /* 820F8100h */ case    0:  		/* lwz R6, <#[R1 + 92]> */
		/* 820F8100h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F8100h case    0:*/		return 0x820F8104;
		  /* 820F8104h */ case    1:  		/* mr R3, R31 */
		/* 820F8104h case    1:*/		regs.R3 = regs.R31;
		/* 820F8104h case    1:*/		return 0x820F8108;
		  /* 820F8108h */ case    2:  		/* rlwinm R10, R4, 0, 4, 7 */
		/* 820F8108h case    2:*/		cpu::op::rlwinm<0,0,4,7>(regs,&regs.R10,regs.R4);
		/* 820F8108h case    2:*/		return 0x820F810C;
		  /* 820F810Ch */ case    3:  		/* cmplw CR6, R10, R11 */
		/* 820F810Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820F810Ch case    3:*/		return 0x820F8110;
		  /* 820F8110h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 820F8110h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F8110h case    4:*/		return 0x820F8114;
		  /* 820F8114h */ case    5:  		/* lwz R10, <#[R1 + 88]> */
		/* 820F8114h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 820F8114h case    5:*/		return 0x820F8118;
		  /* 820F8118h */ case    6:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F8118h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F8118h case    6:*/		return 0x820F811C;
		  /* 820F811Ch */ case    7:  		/* mtspr CTR, R11 */
		/* 820F811Ch case    7:*/		regs.CTR = regs.R11;
		/* 820F811Ch case    7:*/		return 0x820F8120;
		  /* 820F8120h */ case    8:  		/* bc 4, CR6_EQ, 20 */
		/* 820F8120h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820F8134;  }
		/* 820F8120h case    8:*/		return 0x820F8124;
		  /* 820F8124h */ case    9:  		/* rlwinm R4, R4, 0, 8, 5 */
		/* 820F8124h case    9:*/		cpu::op::rlwinm<0,0,8,5>(regs,&regs.R4,regs.R4);
		/* 820F8124h case    9:*/		return 0x820F8128;
		  /* 820F8128h */ case   10:  		/* oris R5, R10, 3072 */
		/* 820F8128h case   10:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R10,0xC00);
		/* 820F8128h case   10:*/		return 0x820F812C;
		  /* 820F812Ch */ case   11:  		/* rlwinm R4, R4, 0, 5, 3 */
		/* 820F812Ch case   11:*/		cpu::op::rlwinm<0,0,5,3>(regs,&regs.R4,regs.R4);
		/* 820F812Ch case   11:*/		return 0x820F8130;
		  /* 820F8130h */ case   12:  		/* b 8 */
		/* 820F8130h case   12:*/		return 0x820F8138;
		/* 820F8130h case   12:*/		return 0x820F8134;
	}
	return 0x820F8134;
} // Block from 820F8100h-820F8134h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820F8134h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8134( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8134) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8134);
		  /* 820F8134h */ case    0:  		/* oris R5, R10, 256 */
		/* 820F8134h case    0:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R10,0x100);
		/* 820F8134h case    0:*/		return 0x820F8138;
	}
	return 0x820F8138;
} // Block from 820F8134h-820F8138h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F8138h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8138);
		  /* 820F8138h */ case    0:  		/* bcctrl 20, CR0_LT */
		/* 820F8138h case    0:*/		if ( 1 ) { regs.LR = 0x820F813C; return (uint32)regs.CTR; }
		/* 820F8138h case    0:*/		return 0x820F813C;
		  /* 820F813Ch */ case    1:  		/* cmpwi CR6, R3, 0 */
		/* 820F813Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820F813Ch case    1:*/		return 0x820F8140;
		  /* 820F8140h */ case    2:  		/* bc 12, CR6_LT, 52 */
		/* 820F8140h case    2:*/		if ( regs.CR[6].lt ) { return 0x820F8174;  }
		/* 820F8140h case    2:*/		return 0x820F8144;
		  /* 820F8144h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 820F8144h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F8144h case    3:*/		return 0x820F8148;
		  /* 820F8148h */ case    4:  		/* mr R3, R31 */
		/* 820F8148h case    4:*/		regs.R3 = regs.R31;
		/* 820F8148h case    4:*/		return 0x820F814C;
		  /* 820F814Ch */ case    5:  		/* lwz R11, <#[R11 + 308]> */
		/* 820F814Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000134) );
		/* 820F814Ch case    5:*/		return 0x820F8150;
		  /* 820F8150h */ case    6:  		/* mtspr CTR, R11 */
		/* 820F8150h case    6:*/		regs.CTR = regs.R11;
		/* 820F8150h case    6:*/		return 0x820F8154;
		  /* 820F8154h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820F8154h case    7:*/		if ( 1 ) { regs.LR = 0x820F8158; return (uint32)regs.CTR; }
		/* 820F8154h case    7:*/		return 0x820F8158;
		  /* 820F8158h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 820F8158h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8158h case    8:*/		return 0x820F815C;
		  /* 820F815Ch */ case    9:  		/* bc 12, CR0_LT, 24 */
		/* 820F815Ch case    9:*/		if ( regs.CR[0].lt ) { return 0x820F8174;  }
		/* 820F815Ch case    9:*/		return 0x820F8160;
		  /* 820F8160h */ case   10:  		/* mr R3, R31 */
		/* 820F8160h case   10:*/		regs.R3 = regs.R31;
		/* 820F8160h case   10:*/		return 0x820F8164;
		  /* 820F8164h */ case   11:  		/* bl -43100 */
		/* 820F8164h case   11:*/		regs.LR = 0x820F8168; return 0x820ED908;
		/* 820F8164h case   11:*/		return 0x820F8168;
		  /* 820F8168h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820F8168h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8168h case   12:*/		return 0x820F816C;
		  /* 820F816Ch */ case   13:  		/* bc 12, CR0_LT, 8 */
		/* 820F816Ch case   13:*/		if ( regs.CR[0].lt ) { return 0x820F8174;  }
		/* 820F816Ch case   13:*/		return 0x820F8170;
		  /* 820F8170h */ case   14:  		/* li R3, 0 */
		/* 820F8170h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F8170h case   14:*/		return 0x820F8174;
	}
	return 0x820F8174;
} // Block from 820F8138h-820F8174h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820F8174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8174);
		  /* 820F8174h */ case    0:  		/* addi R1, R1, 128 */
		/* 820F8174h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820F8174h case    0:*/		return 0x820F8178;
		  /* 820F8178h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820F8178h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F8178h case    1:*/		return 0x820F817C;
		  /* 820F817Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820F817Ch case    2:*/		regs.LR = regs.R12;
		/* 820F817Ch case    2:*/		return 0x820F8180;
		  /* 820F8180h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820F8180h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F8180h case    3:*/		return 0x820F8184;
		  /* 820F8184h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820F8184h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F8184h case    4:*/		return 0x820F8188;
	}
	return 0x820F8188;
} // Block from 820F8174h-820F8188h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F8188h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8188);
		  /* 820F8188h */ case    0:  		/* mfspr R12, LR */
		/* 820F8188h case    0:*/		regs.R12 = regs.LR;
		/* 820F8188h case    0:*/		return 0x820F818C;
		  /* 820F818Ch */ case    1:  		/* bl -421692 */
		/* 820F818Ch case    1:*/		regs.LR = 0x820F8190; return 0x82091250;
		/* 820F818Ch case    1:*/		return 0x820F8190;
		  /* 820F8190h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820F8190h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820F8190h case    2:*/		return 0x820F8194;
		  /* 820F8194h */ case    3:  		/* lwz R11, <#[R3 + 260]> */
		/* 820F8194h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000104) );
		/* 820F8194h case    3:*/		return 0x820F8198;
		  /* 820F8198h */ case    4:  		/* li R30, 0 */
		/* 820F8198h case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820F8198h case    4:*/		return 0x820F819C;
		  /* 820F819Ch */ case    5:  		/* mr R27, R3 */
		/* 820F819Ch case    5:*/		regs.R27 = regs.R3;
		/* 820F819Ch case    5:*/		return 0x820F81A0;
		  /* 820F81A0h */ case    6:  		/* mr R26, R30 */
		/* 820F81A0h case    6:*/		regs.R26 = regs.R30;
		/* 820F81A0h case    6:*/		return 0x820F81A4;
		  /* 820F81A4h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820F81A4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F81A4h case    7:*/		return 0x820F81A8;
		  /* 820F81A8h */ case    8:  		/* rlwinm. R29, R11, 0, 12, 31 */
		/* 820F81A8h case    8:*/		cpu::op::rlwinm<1,0,12,31>(regs,&regs.R29,regs.R11);
		/* 820F81A8h case    8:*/		return 0x820F81AC;
		  /* 820F81ACh */ case    9:  		/* bc 12, CR0_EQ, 104 */
		/* 820F81ACh case    9:*/		if ( regs.CR[0].eq ) { return 0x820F8214;  }
		/* 820F81ACh case    9:*/		return 0x820F81B0;
		  /* 820F81B0h */ case   10:  		/* mr R31, R30 */
		/* 820F81B0h case   10:*/		regs.R31 = regs.R30;
		/* 820F81B0h case   10:*/		return 0x820F81B4;
		  /* 820F81B4h */ case   11:  		/* rlwinm R28, R29, 2, 0, 29 */
		/* 820F81B4h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R29);
		/* 820F81B4h case   11:*/		return 0x820F81B8;
		  /* 820F81B8h */ case   12:  		/* lwz R8, <#[R27 + 260]> */
		/* 820F81B8h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000104) );
		/* 820F81B8h case   12:*/		return 0x820F81BC;
		  /* 820F81BCh */ case   13:  		/* mr R10, R29 */
		/* 820F81BCh case   13:*/		regs.R10 = regs.R29;
		/* 820F81BCh case   13:*/		return 0x820F81C0;
		  /* 820F81C0h */ case   14:  		/* li R9, 0 */
		/* 820F81C0h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F81C0h case   14:*/		return 0x820F81C4;
		  /* 820F81C4h */ case   15:  		/* stw R30, <#[R1 + 108]> */
		/* 820F81C4h case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000006C) );
		/* 820F81C4h case   15:*/		return 0x820F81C8;
		  /* 820F81C8h */ case   16:  		/* li R6, 1 */
		/* 820F81C8h case   16:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820F81C8h case   16:*/		return 0x820F81CC;
		  /* 820F81CCh */ case   17:  		/* stw R30, <#[R1 + 100]> */
		/* 820F81CCh case   17:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000064) );
		/* 820F81CCh case   17:*/		return 0x820F81D0;
		  /* 820F81D0h */ case   18:  		/* li R4, 32 */
		/* 820F81D0h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x20);
		/* 820F81D0h case   18:*/		return 0x820F81D4;
		  /* 820F81D4h */ case   19:  		/* stw R30, <#[R1 + 92]> */
		/* 820F81D4h case   19:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F81D4h case   19:*/		return 0x820F81D8;
		  /* 820F81D8h */ case   20:  		/* mr R3, R27 */
		/* 820F81D8h case   20:*/		regs.R3 = regs.R27;
		/* 820F81D8h case   20:*/		return 0x820F81DC;
		  /* 820F81DCh */ case   21:  		/* stw R30, <#[R1 + 84]> */
		/* 820F81DCh case   21:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 820F81DCh case   21:*/		return 0x820F81E0;
		  /* 820F81E0h */ case   22:  		/* lwz R11, <#[R8 + 8]> */
		/* 820F81E0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000008) );
		/* 820F81E0h case   22:*/		return 0x820F81E4;
		  /* 820F81E4h */ case   23:  		/* lwz R5, <#[R8 + 16]> */
		/* 820F81E4h case   23:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R8 + 0x00000010) );
		/* 820F81E4h case   23:*/		return 0x820F81E8;
		  /* 820F81E8h */ case   24:  		/* add R8, R28, R11 */
		/* 820F81E8h case   24:*/		cpu::op::add<0>(regs,&regs.R8,regs.R28,regs.R11);
		/* 820F81E8h case   24:*/		return 0x820F81EC;
		  /* 820F81ECh */ case   25:  		/* add R7, R31, R11 */
		/* 820F81ECh case   25:*/		cpu::op::add<0>(regs,&regs.R7,regs.R31,regs.R11);
		/* 820F81ECh case   25:*/		return 0x820F81F0;
		  /* 820F81F0h */ case   26:  		/* add R5, R5, R31 */
		/* 820F81F0h case   26:*/		cpu::op::add<0>(regs,&regs.R5,regs.R5,regs.R31);
		/* 820F81F0h case   26:*/		return 0x820F81F4;
		  /* 820F81F4h */ case   27:  		/* bl -7828 */
		/* 820F81F4h case   27:*/		regs.LR = 0x820F81F8; return 0x820F6360;
		/* 820F81F4h case   27:*/		return 0x820F81F8;
		  /* 820F81F8h */ case   28:  		/* cmpwi CR0, R3, 0 */
		/* 820F81F8h case   28:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F81F8h case   28:*/		return 0x820F81FC;
		  /* 820F81FCh */ case   29:  		/* bc 12, CR0_LT, 28 */
		/* 820F81FCh case   29:*/		if ( regs.CR[0].lt ) { return 0x820F8218;  }
		/* 820F81FCh case   29:*/		return 0x820F8200;
		  /* 820F8200h */ case   30:  		/* addi R26, R26, 1 */
		/* 820F8200h case   30:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820F8200h case   30:*/		return 0x820F8204;
		  /* 820F8204h */ case   31:  		/* addi R31, R31, 4 */
		/* 820F8204h case   31:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820F8204h case   31:*/		return 0x820F8208;
		  /* 820F8208h */ case   32:  		/* addi R28, R28, 4 */
		/* 820F8208h case   32:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820F8208h case   32:*/		return 0x820F820C;
		  /* 820F820Ch */ case   33:  		/* cmplw CR6, R26, R29 */
		/* 820F820Ch case   33:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R29);
		/* 820F820Ch case   33:*/		return 0x820F8210;
		  /* 820F8210h */ case   34:  		/* bc 12, CR6_LT, -88 */
		/* 820F8210h case   34:*/		if ( regs.CR[6].lt ) { return 0x820F81B8;  }
		/* 820F8210h case   34:*/		return 0x820F8214;
	}
	return 0x820F8214;
} // Block from 820F8188h-820F8214h (35 instructions)

//////////////////////////////////////////////////////
// Block at 820F8214h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8214( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8214) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8214);
		  /* 820F8214h */ case    0:  		/* li R3, 0 */
		/* 820F8214h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F8214h case    0:*/		return 0x820F8218;
	}
	return 0x820F8218;
} // Block from 820F8214h-820F8218h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F8218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8218);
		  /* 820F8218h */ case    0:  		/* addi R1, R1, 176 */
		/* 820F8218h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820F8218h case    0:*/		return 0x820F821C;
		  /* 820F821Ch */ case    1:  		/* b -421756 */
		/* 820F821Ch case    1:*/		return 0x820912A0;
		/* 820F821Ch case    1:*/		return 0x820F8220;
	}
	return 0x820F8220;
} // Block from 820F8218h-820F8220h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F8220h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8220);
		  /* 820F8220h */ case    0:  		/* mfspr R12, LR */
		/* 820F8220h case    0:*/		regs.R12 = regs.LR;
		/* 820F8220h case    0:*/		return 0x820F8224;
		  /* 820F8224h */ case    1:  		/* bl -421844 */
		/* 820F8224h case    1:*/		regs.LR = 0x820F8228; return 0x82091250;
		/* 820F8224h case    1:*/		return 0x820F8228;
		  /* 820F8228h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820F8228h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820F8228h case    2:*/		return 0x820F822C;
		  /* 820F822Ch */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820F822Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F822Ch case    3:*/		return 0x820F8230;
		  /* 820F8230h */ case    4:  		/* li R4, 18 */
		/* 820F8230h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x12);
		/* 820F8230h case    4:*/		return 0x820F8234;
		  /* 820F8234h */ case    5:  		/* lwz R10, <#[R3 + 260]> */
		/* 820F8234h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000104) );
		/* 820F8234h case    5:*/		return 0x820F8238;
		  /* 820F8238h */ case    6:  		/* mr R31, R3 */
		/* 820F8238h case    6:*/		regs.R31 = regs.R3;
		/* 820F8238h case    6:*/		return 0x820F823C;
		  /* 820F823Ch */ case    7:  		/* lwz R11, <#[R11 + 304]> */
		/* 820F823Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000130) );
		/* 820F823Ch case    7:*/		return 0x820F8240;
		  /* 820F8240h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 820F8240h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820F8240h case    8:*/		return 0x820F8244;
		  /* 820F8244h */ case    9:  		/* rlwinm R27, R10, 0, 12, 31 */
		/* 820F8244h case    9:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R27,regs.R10);
		/* 820F8244h case    9:*/		return 0x820F8248;
		  /* 820F8248h */ case   10:  		/* mtspr CTR, R11 */
		/* 820F8248h case   10:*/		regs.CTR = regs.R11;
		/* 820F8248h case   10:*/		return 0x820F824C;
		  /* 820F824Ch */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 820F824Ch case   11:*/		if ( 1 ) { regs.LR = 0x820F8250; return (uint32)regs.CTR; }
		/* 820F824Ch case   11:*/		return 0x820F8250;
		  /* 820F8250h */ case   12:  		/* mr R4, R3 */
		/* 820F8250h case   12:*/		regs.R4 = regs.R3;
		/* 820F8250h case   12:*/		return 0x820F8254;
		  /* 820F8254h */ case   13:  		/* mr R3, R31 */
		/* 820F8254h case   13:*/		regs.R3 = regs.R31;
		/* 820F8254h case   13:*/		return 0x820F8258;
		  /* 820F8258h */ case   14:  		/* bl -8552 */
		/* 820F8258h case   14:*/		regs.LR = 0x820F825C; return 0x820F60F0;
		/* 820F8258h case   14:*/		return 0x820F825C;
		  /* 820F825Ch */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 820F825Ch case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F825Ch case   15:*/		return 0x820F8260;
		  /* 820F8260h */ case   16:  		/* bc 12, CR0_LT, 380 */
		/* 820F8260h case   16:*/		if ( regs.CR[0].lt ) { return 0x820F83DC;  }
		/* 820F8260h case   16:*/		return 0x820F8264;
		  /* 820F8264h */ case   17:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F8264h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F8264h case   17:*/		return 0x820F8268;
		  /* 820F8268h */ case   18:  		/* addi R7, R1, 88 */
		/* 820F8268h case   18:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x58);
		/* 820F8268h case   18:*/		return 0x820F826C;
		  /* 820F826Ch */ case   19:  		/* lwz R10, <#[R31]> */
		/* 820F826Ch case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F826Ch case   19:*/		return 0x820F8270;
		  /* 820F8270h */ case   20:  		/* addi R6, R1, 92 */
		/* 820F8270h case   20:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x5C);
		/* 820F8270h case   20:*/		return 0x820F8274;
		  /* 820F8274h */ case   21:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F8274h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F8274h case   21:*/		return 0x820F8278;
		  /* 820F8278h */ case   22:  		/* addi R5, R1, 80 */
		/* 820F8278h case   22:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820F8278h case   22:*/		return 0x820F827C;
		  /* 820F827Ch */ case   23:  		/* mr R3, R31 */
		/* 820F827Ch case   23:*/		regs.R3 = regs.R31;
		/* 820F827Ch case   23:*/		return 0x820F8280;
		  /* 820F8280h */ case   24:  		/* lwz R11, <#[R11 + 16]> */
		/* 820F8280h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820F8280h case   24:*/		return 0x820F8284;
		  /* 820F8284h */ case   25:  		/* lwz R10, <#[R10 + 320]> */
		/* 820F8284h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000140) );
		/* 820F8284h case   25:*/		return 0x820F8288;
		  /* 820F8288h */ case   26:  		/* lwz R11, <#[R11]> */
		/* 820F8288h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F8288h case   26:*/		return 0x820F828C;
		  /* 820F828Ch */ case   27:  		/* mtspr CTR, R10 */
		/* 820F828Ch case   27:*/		regs.CTR = regs.R10;
		/* 820F828Ch case   27:*/		return 0x820F8290;
		  /* 820F8290h */ case   28:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F8290h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F8290h case   28:*/		return 0x820F8294;
		  /* 820F8294h */ case   29:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F8294h case   29:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F8294h case   29:*/		return 0x820F8298;
		  /* 820F8298h */ case   30:  		/* bcctrl 20, CR0_LT */
		/* 820F8298h case   30:*/		if ( 1 ) { regs.LR = 0x820F829C; return (uint32)regs.CTR; }
		/* 820F8298h case   30:*/		return 0x820F829C;
		  /* 820F829Ch */ case   31:  		/* cmpwi CR0, R3, 0 */
		/* 820F829Ch case   31:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F829Ch case   31:*/		return 0x820F82A0;
		  /* 820F82A0h */ case   32:  		/* bc 12, CR0_LT, 316 */
		/* 820F82A0h case   32:*/		if ( regs.CR[0].lt ) { return 0x820F83DC;  }
		/* 820F82A0h case   32:*/		return 0x820F82A4;
		  /* 820F82A4h */ case   33:  		/* lwz R11, <#[R31]> */
		/* 820F82A4h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F82A4h case   33:*/		return 0x820F82A8;
		  /* 820F82A8h */ case   34:  		/* addi R6, R1, 84 */
		/* 820F82A8h case   34:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 820F82A8h case   34:*/		return 0x820F82AC;
		  /* 820F82ACh */ case   35:  		/* lwz R10, <#[R31 + 260]> */
		/* 820F82ACh case   35:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000104) );
		/* 820F82ACh case   35:*/		return 0x820F82B0;
		  /* 820F82B0h */ case   36:  		/* mr R5, R27 */
		/* 820F82B0h case   36:*/		regs.R5 = regs.R27;
		/* 820F82B0h case   36:*/		return 0x820F82B4;
		  /* 820F82B4h */ case   37:  		/* mr R3, R31 */
		/* 820F82B4h case   37:*/		regs.R3 = regs.R31;
		/* 820F82B4h case   37:*/		return 0x820F82B8;
		  /* 820F82B8h */ case   38:  		/* lwz R7, <#[R1 + 88]> */
		/* 820F82B8h case   38:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000058) );
		/* 820F82B8h case   38:*/		return 0x820F82BC;
		  /* 820F82BCh */ case   39:  		/* lwz R11, <#[R11 + 324]> */
		/* 820F82BCh case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000144) );
		/* 820F82BCh case   39:*/		return 0x820F82C0;
		  /* 820F82C0h */ case   40:  		/* lwz R4, <#[R10 + 16]> */
		/* 820F82C0h case   40:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000010) );
		/* 820F82C0h case   40:*/		return 0x820F82C4;
		  /* 820F82C4h */ case   41:  		/* mtspr CTR, R11 */
		/* 820F82C4h case   41:*/		regs.CTR = regs.R11;
		/* 820F82C4h case   41:*/		return 0x820F82C8;
		  /* 820F82C8h */ case   42:  		/* bcctrl 20, CR0_LT */
		/* 820F82C8h case   42:*/		if ( 1 ) { regs.LR = 0x820F82CC; return (uint32)regs.CTR; }
		/* 820F82C8h case   42:*/		return 0x820F82CC;
		  /* 820F82CCh */ case   43:  		/* cmpwi CR0, R3, 0 */
		/* 820F82CCh case   43:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F82CCh case   43:*/		return 0x820F82D0;
		  /* 820F82D0h */ case   44:  		/* bc 12, CR0_LT, 268 */
		/* 820F82D0h case   44:*/		if ( regs.CR[0].lt ) { return 0x820F83DC;  }
		/* 820F82D0h case   44:*/		return 0x820F82D4;
		  /* 820F82D4h */ case   45:  		/* lwz R11, <#[R31]> */
		/* 820F82D4h case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F82D4h case   45:*/		return 0x820F82D8;
		  /* 820F82D8h */ case   46:  		/* mr R3, R31 */
		/* 820F82D8h case   46:*/		regs.R3 = regs.R31;
		/* 820F82D8h case   46:*/		return 0x820F82DC;
		  /* 820F82DCh */ case   47:  		/* lwz R6, <#[R1 + 92]> */
		/* 820F82DCh case   47:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F82DCh case   47:*/		return 0x820F82E0;
		  /* 820F82E0h */ case   48:  		/* lwz R5, <#[R1 + 84]> */
		/* 820F82E0h case   48:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 820F82E0h case   48:*/		return 0x820F82E4;
		  /* 820F82E4h */ case   49:  		/* lwz R4, <#[R1 + 80]> */
		/* 820F82E4h case   49:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 820F82E4h case   49:*/		return 0x820F82E8;
		  /* 820F82E8h */ case   50:  		/* lwz R11, <#[R11 + 312]> */
		/* 820F82E8h case   50:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000138) );
		/* 820F82E8h case   50:*/		return 0x820F82EC;
		  /* 820F82ECh */ case   51:  		/* mtspr CTR, R11 */
		/* 820F82ECh case   51:*/		regs.CTR = regs.R11;
		/* 820F82ECh case   51:*/		return 0x820F82F0;
		  /* 820F82F0h */ case   52:  		/* bcctrl 20, CR0_LT */
		/* 820F82F0h case   52:*/		if ( 1 ) { regs.LR = 0x820F82F4; return (uint32)regs.CTR; }
		/* 820F82F0h case   52:*/		return 0x820F82F4;
		  /* 820F82F4h */ case   53:  		/* cmpwi CR0, R3, 0 */
		/* 820F82F4h case   53:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F82F4h case   53:*/		return 0x820F82F8;
		  /* 820F82F8h */ case   54:  		/* bc 12, CR0_LT, 228 */
		/* 820F82F8h case   54:*/		if ( regs.CR[0].lt ) { return 0x820F83DC;  }
		/* 820F82F8h case   54:*/		return 0x820F82FC;
		  /* 820F82FCh */ case   55:  		/* li R28, 0 */
		/* 820F82FCh case   55:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820F82FCh case   55:*/		return 0x820F8300;
		  /* 820F8300h */ case   56:  		/* li R29, 0 */
		/* 820F8300h case   56:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820F8300h case   56:*/		return 0x820F8304;
		  /* 820F8304h */ case   57:  		/* rlwinm R26, R27, 2, 0, 29 */
		/* 820F8304h case   57:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R26,regs.R27);
		/* 820F8304h case   57:*/		return 0x820F8308;
		  /* 820F8308h */ case   58:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F8308h case   58:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F8308h case   58:*/		return 0x820F830C;
		  /* 820F830Ch */ case   59:  		/* addi R6, R1, 96 */
		/* 820F830Ch case   59:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x60);
		/* 820F830Ch case   59:*/		return 0x820F8310;
		  /* 820F8310h */ case   60:  		/* lwz R10, <#[R31]> */
		/* 820F8310h case   60:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F8310h case   60:*/		return 0x820F8314;
		  /* 820F8314h */ case   61:  		/* addi R5, R1, 80 */
		/* 820F8314h case   61:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820F8314h case   61:*/		return 0x820F8318;
		  /* 820F8318h */ case   62:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F8318h case   62:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F8318h case   62:*/		return 0x820F831C;
		  /* 820F831Ch */ case   63:  		/* mr R3, R31 */
		/* 820F831Ch case   63:*/		regs.R3 = regs.R31;
		/* 820F831Ch case   63:*/		return 0x820F8320;
		  /* 820F8320h */ case   64:  		/* lwz R11, <#[R11 + 8]> */
		/* 820F8320h case   64:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820F8320h case   64:*/		return 0x820F8324;
		  /* 820F8324h */ case   65:  		/* lwz R10, <#[R10 + 328]> */
		/* 820F8324h case   65:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000148) );
		/* 820F8324h case   65:*/		return 0x820F8328;
		  /* 820F8328h */ case   66:  		/* add R30, R11, R29 */
		/* 820F8328h case   66:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R29);
		/* 820F8328h case   66:*/		return 0x820F832C;
		  /* 820F832Ch */ case   67:  		/* lwzx R11, <#[R11 + R29]> */
		/* 820F832Ch case   67:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 820F832Ch case   67:*/		return 0x820F8330;
		  /* 820F8330h */ case   68:  		/* mtspr CTR, R10 */
		/* 820F8330h case   68:*/		regs.CTR = regs.R10;
		/* 820F8330h case   68:*/		return 0x820F8334;
		  /* 820F8334h */ case   69:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F8334h case   69:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F8334h case   69:*/		return 0x820F8338;
		  /* 820F8338h */ case   70:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F8338h case   70:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F8338h case   70:*/		return 0x820F833C;
		  /* 820F833Ch */ case   71:  		/* bcctrl 20, CR0_LT */
		/* 820F833Ch case   71:*/		if ( 1 ) { regs.LR = 0x820F8340; return (uint32)regs.CTR; }
		/* 820F833Ch case   71:*/		return 0x820F8340;
		  /* 820F8340h */ case   72:  		/* cmpwi CR0, R3, 0 */
		/* 820F8340h case   72:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8340h case   72:*/		return 0x820F8344;
		  /* 820F8344h */ case   73:  		/* bc 12, CR0_LT, 152 */
		/* 820F8344h case   73:*/		if ( regs.CR[0].lt ) { return 0x820F83DC;  }
		/* 820F8344h case   73:*/		return 0x820F8348;
		  /* 820F8348h */ case   74:  		/* lwz R11, <#[R31]> */
		/* 820F8348h case   74:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F8348h case   74:*/		return 0x820F834C;
		  /* 820F834Ch */ case   75:  		/* addi R7, R1, 100 */
		/* 820F834Ch case   75:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x64);
		/* 820F834Ch case   75:*/		return 0x820F8350;
		  /* 820F8350h */ case   76:  		/* mr R5, R27 */
		/* 820F8350h case   76:*/		regs.R5 = regs.R27;
		/* 820F8350h case   76:*/		return 0x820F8354;
		  /* 820F8354h */ case   77:  		/* lwz R6, <#[R1 + 84]> */
		/* 820F8354h case   77:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 820F8354h case   77:*/		return 0x820F8358;
		  /* 820F8358h */ case   78:  		/* mr R4, R30 */
		/* 820F8358h case   78:*/		regs.R4 = regs.R30;
		/* 820F8358h case   78:*/		return 0x820F835C;
		  /* 820F835Ch */ case   79:  		/* mr R3, R31 */
		/* 820F835Ch case   79:*/		regs.R3 = regs.R31;
		/* 820F835Ch case   79:*/		return 0x820F8360;
		  /* 820F8360h */ case   80:  		/* lwz R11, <#[R11 + 332]> */
		/* 820F8360h case   80:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000014C) );
		/* 820F8360h case   80:*/		return 0x820F8364;
		  /* 820F8364h */ case   81:  		/* mtspr CTR, R11 */
		/* 820F8364h case   81:*/		regs.CTR = regs.R11;
		/* 820F8364h case   81:*/		return 0x820F8368;
		  /* 820F8368h */ case   82:  		/* bcctrl 20, CR0_LT */
		/* 820F8368h case   82:*/		if ( 1 ) { regs.LR = 0x820F836C; return (uint32)regs.CTR; }
		/* 820F8368h case   82:*/		return 0x820F836C;
		  /* 820F836Ch */ case   83:  		/* cmpwi CR0, R3, 0 */
		/* 820F836Ch case   83:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F836Ch case   83:*/		return 0x820F8370;
		  /* 820F8370h */ case   84:  		/* bc 12, CR0_LT, 108 */
		/* 820F8370h case   84:*/		if ( regs.CR[0].lt ) { return 0x820F83DC;  }
		/* 820F8370h case   84:*/		return 0x820F8374;
		  /* 820F8374h */ case   85:  		/* lwz R11, <#[R31]> */
		/* 820F8374h case   85:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F8374h case   85:*/		return 0x820F8378;
		  /* 820F8378h */ case   86:  		/* mr R3, R31 */
		/* 820F8378h case   86:*/		regs.R3 = regs.R31;
		/* 820F8378h case   86:*/		return 0x820F837C;
		  /* 820F837Ch */ case   87:  		/* lwz R6, <#[R1 + 96]> */
		/* 820F837Ch case   87:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000060) );
		/* 820F837Ch case   87:*/		return 0x820F8380;
		  /* 820F8380h */ case   88:  		/* lwz R5, <#[R1 + 100]> */
		/* 820F8380h case   88:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000064) );
		/* 820F8380h case   88:*/		return 0x820F8384;
		  /* 820F8384h */ case   89:  		/* lwz R4, <#[R1 + 80]> */
		/* 820F8384h case   89:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 820F8384h case   89:*/		return 0x820F8388;
		  /* 820F8388h */ case   90:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F8388h case   90:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F8388h case   90:*/		return 0x820F838C;
		  /* 820F838Ch */ case   91:  		/* mtspr CTR, R11 */
		/* 820F838Ch case   91:*/		regs.CTR = regs.R11;
		/* 820F838Ch case   91:*/		return 0x820F8390;
		  /* 820F8390h */ case   92:  		/* bcctrl 20, CR0_LT */
		/* 820F8390h case   92:*/		if ( 1 ) { regs.LR = 0x820F8394; return (uint32)regs.CTR; }
		/* 820F8390h case   92:*/		return 0x820F8394;
		  /* 820F8394h */ case   93:  		/* cmpwi CR0, R3, 0 */
		/* 820F8394h case   93:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8394h case   93:*/		return 0x820F8398;
		  /* 820F8398h */ case   94:  		/* bc 12, CR0_LT, 68 */
		/* 820F8398h case   94:*/		if ( regs.CR[0].lt ) { return 0x820F83DC;  }
		/* 820F8398h case   94:*/		return 0x820F839C;
		  /* 820F839Ch */ case   95:  		/* addi R28, R28, 1 */
		/* 820F839Ch case   95:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820F839Ch case   95:*/		return 0x820F83A0;
		  /* 820F83A0h */ case   96:  		/* add R29, R26, R29 */
		/* 820F83A0h case   96:*/		cpu::op::add<0>(regs,&regs.R29,regs.R26,regs.R29);
		/* 820F83A0h case   96:*/		return 0x820F83A4;
		  /* 820F83A4h */ case   97:  		/* cmplwi CR6, R28, 3 */
		/* 820F83A4h case   97:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000003);
		/* 820F83A4h case   97:*/		return 0x820F83A8;
		  /* 820F83A8h */ case   98:  		/* bc 12, CR6_LT, -160 */
		/* 820F83A8h case   98:*/		if ( regs.CR[6].lt ) { return 0x820F8308;  }
		/* 820F83A8h case   98:*/		return 0x820F83AC;
		  /* 820F83ACh */ case   99:  		/* lwz R11, <#[R31]> */
		/* 820F83ACh case   99:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F83ACh case   99:*/		return 0x820F83B0;
	}
	return 0x820F83B0;
} // Block from 820F8220h-820F83B0h (100 instructions)

//////////////////////////////////////////////////////
// Block at 820F83B0h
// Function '?EmitANDIF@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F83B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F83B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F83B0);
		  /* 820F83B0h */ case    0:  		/* mr R3, R31 */
		/* 820F83B0h case    0:*/		regs.R3 = regs.R31;
		/* 820F83B0h case    0:*/		return 0x820F83B4;
		  /* 820F83B4h */ case    1:  		/* lwz R11, <#[R11 + 308]> */
		/* 820F83B4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000134) );
		/* 820F83B4h case    1:*/		return 0x820F83B8;
		  /* 820F83B8h */ case    2:  		/* mtspr CTR, R11 */
		/* 820F83B8h case    2:*/		regs.CTR = regs.R11;
		/* 820F83B8h case    2:*/		return 0x820F83BC;
		  /* 820F83BCh */ case    3:  		/* bcctrl 20, CR0_LT */
		/* 820F83BCh case    3:*/		if ( 1 ) { regs.LR = 0x820F83C0; return (uint32)regs.CTR; }
		/* 820F83BCh case    3:*/		return 0x820F83C0;
		  /* 820F83C0h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820F83C0h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F83C0h case    4:*/		return 0x820F83C4;
		  /* 820F83C4h */ case    5:  		/* bc 12, CR0_LT, 24 */
		/* 820F83C4h case    5:*/		if ( regs.CR[0].lt ) { return 0x820F83DC;  }
		/* 820F83C4h case    5:*/		return 0x820F83C8;
		  /* 820F83C8h */ case    6:  		/* mr R3, R31 */
		/* 820F83C8h case    6:*/		regs.R3 = regs.R31;
		/* 820F83C8h case    6:*/		return 0x820F83CC;
		  /* 820F83CCh */ case    7:  		/* bl -43716 */
		/* 820F83CCh case    7:*/		regs.LR = 0x820F83D0; return 0x820ED908;
		/* 820F83CCh case    7:*/		return 0x820F83D0;
		  /* 820F83D0h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 820F83D0h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F83D0h case    8:*/		return 0x820F83D4;
		  /* 820F83D4h */ case    9:  		/* bc 12, CR0_LT, 8 */
		/* 820F83D4h case    9:*/		if ( regs.CR[0].lt ) { return 0x820F83DC;  }
		/* 820F83D4h case    9:*/		return 0x820F83D8;
		  /* 820F83D8h */ case   10:  		/* li R3, 0 */
		/* 820F83D8h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F83D8h case   10:*/		return 0x820F83DC;
	}
	return 0x820F83DC;
} // Block from 820F83B0h-820F83DCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820F83DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F83DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F83DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F83DC);
		  /* 820F83DCh */ case    0:  		/* addi R1, R1, 160 */
		/* 820F83DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820F83DCh case    0:*/		return 0x820F83E0;
		  /* 820F83E0h */ case    1:  		/* b -422208 */
		/* 820F83E0h case    1:*/		return 0x820912A0;
		/* 820F83E0h case    1:*/		return 0x820F83E4;
		  /* 820F83E4h */ case    2:  		/* nop */
		/* 820F83E4h case    2:*/		cpu::op::nop();
		/* 820F83E4h case    2:*/		return 0x820F83E8;
	}
	return 0x820F83E8;
} // Block from 820F83DCh-820F83E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F83E8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F83E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F83E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F83E8);
		  /* 820F83E8h */ case    0:  		/* mfspr R12, LR */
		/* 820F83E8h case    0:*/		regs.R12 = regs.LR;
		/* 820F83E8h case    0:*/		return 0x820F83EC;
		  /* 820F83ECh */ case    1:  		/* bl -422292 */
		/* 820F83ECh case    1:*/		regs.LR = 0x820F83F0; return 0x82091258;
		/* 820F83ECh case    1:*/		return 0x820F83F0;
		  /* 820F83F0h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820F83F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820F83F0h case    2:*/		return 0x820F83F4;
		  /* 820F83F4h */ case    3:  		/* lwz R10, <#[R3 + 260]> */
		/* 820F83F4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000104) );
		/* 820F83F4h case    3:*/		return 0x820F83F8;
		  /* 820F83F8h */ case    4:  		/* mr R31, R3 */
		/* 820F83F8h case    4:*/		regs.R31 = regs.R3;
		/* 820F83F8h case    4:*/		return 0x820F83FC;
		  /* 820F83FCh */ case    5:  		/* lwz R9, <#[R3 + 20]> */
		/* 820F83FCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 820F83FCh case    5:*/		return 0x820F8400;
		  /* 820F8400h */ case    6:  		/* lwz R8, <#[R3 + 136]> */
		/* 820F8400h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000088) );
		/* 820F8400h case    6:*/		return 0x820F8404;
		  /* 820F8404h */ case    7:  		/* lwz R11, <#[R10 + 16]> */
		/* 820F8404h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 820F8404h case    7:*/		return 0x820F8408;
		  /* 820F8408h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 820F8408h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820F8408h case    8:*/		return 0x820F840C;
		  /* 820F840Ch */ case    9:  		/* mr R28, R11 */
		/* 820F840Ch case    9:*/		regs.R28 = regs.R11;
		/* 820F840Ch case    9:*/		return 0x820F8410;
		  /* 820F8410h */ case   10:  		/* rlwinm R29, R10, 0, 12, 31 */
		/* 820F8410h case   10:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R29,regs.R10);
		/* 820F8410h case   10:*/		return 0x820F8414;
		  /* 820F8414h */ case   11:  		/* lwz R11, <#[R11]> */
		/* 820F8414h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F8414h case   11:*/		return 0x820F8418;
		  /* 820F8418h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F8418h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F8418h case   12:*/		return 0x820F841C;
		  /* 820F841Ch */ case   13:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820F841Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F841Ch case   13:*/		return 0x820F8420;
		  /* 820F8420h */ case   14:  		/* lwz R11, <#[R11 + 4]> */
		/* 820F8420h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820F8420h case   14:*/		return 0x820F8424;
		  /* 820F8424h */ case   15:  		/* cmplw CR6, R8, R11 */
		/* 820F8424h case   15:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 820F8424h case   15:*/		return 0x820F8428;
		  /* 820F8428h */ case   16:  		/* bc 12, CR6_EQ, 52 */
		/* 820F8428h case   16:*/		if ( regs.CR[6].eq ) { return 0x820F845C;  }
		/* 820F8428h case   16:*/		return 0x820F842C;
		  /* 820F842Ch */ case   17:  		/* lwz R11, <#[R3]> */
		/* 820F842Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F842Ch case   17:*/		return 0x820F8430;
		  /* 820F8430h */ case   18:  		/* li R8, 0 */
		/* 820F8430h case   18:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F8430h case   18:*/		return 0x820F8434;
		  /* 820F8434h */ case   19:  		/* li R7, 0 */
		/* 820F8434h case   19:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820F8434h case   19:*/		return 0x820F8438;
		  /* 820F8438h */ case   20:  		/* lwz R4, <#[R3 + 256]> */
		/* 820F8438h case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000100) );
		/* 820F8438h case   20:*/		return 0x820F843C;
		  /* 820F843Ch */ case   21:  		/* mr R6, R29 */
		/* 820F843Ch case   21:*/		regs.R6 = regs.R29;
		/* 820F843Ch case   21:*/		return 0x820F8440;
		  /* 820F8440h */ case   22:  		/* addi R5, R1, 112 */
		/* 820F8440h case   22:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820F8440h case   22:*/		return 0x820F8444;
		  /* 820F8444h */ case   23:  		/* lwz R11, <#[R11 + 340]> */
		/* 820F8444h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000154) );
		/* 820F8444h case   23:*/		return 0x820F8448;
		  /* 820F8448h */ case   24:  		/* mtspr CTR, R11 */
		/* 820F8448h case   24:*/		regs.CTR = regs.R11;
		/* 820F8448h case   24:*/		return 0x820F844C;
		  /* 820F844Ch */ case   25:  		/* bcctrl 20, CR0_LT */
		/* 820F844Ch case   25:*/		if ( 1 ) { regs.LR = 0x820F8450; return (uint32)regs.CTR; }
		/* 820F844Ch case   25:*/		return 0x820F8450;
		  /* 820F8450h */ case   26:  		/* cmpwi CR0, R3, 0 */
		/* 820F8450h case   26:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8450h case   26:*/		return 0x820F8454;
		  /* 820F8454h */ case   27:  		/* bc 12, CR0_LT, 156 */
		/* 820F8454h case   27:*/		if ( regs.CR[0].lt ) { return 0x820F84F0;  }
		/* 820F8454h case   27:*/		return 0x820F8458;
		  /* 820F8458h */ case   28:  		/* addi R28, R1, 112 */
		/* 820F8458h case   28:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0x70);
		/* 820F8458h case   28:*/		return 0x820F845C;
	}
	return 0x820F845C;
} // Block from 820F83E8h-820F845Ch (29 instructions)

//////////////////////////////////////////////////////
// Block at 820F845Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F845C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F845C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F845C);
		  /* 820F845Ch */ case    0:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F845Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F845Ch case    0:*/		return 0x820F8460;
		  /* 820F8460h */ case    1:  		/* li R30, 0 */
		/* 820F8460h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820F8460h case    1:*/		return 0x820F8464;
		  /* 820F8464h */ case    2:  		/* mr R10, R29 */
		/* 820F8464h case    2:*/		regs.R10 = regs.R29;
		/* 820F8464h case    2:*/		return 0x820F8468;
		  /* 820F8468h */ case    3:  		/* li R9, 0 */
		/* 820F8468h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F8468h case    3:*/		return 0x820F846C;
		  /* 820F846Ch */ case    4:  		/* stw R30, <#[R1 + 108]> */
		/* 820F846Ch case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000006C) );
		/* 820F846Ch case    4:*/		return 0x820F8470;
		  /* 820F8470h */ case    5:  		/* li R8, 0 */
		/* 820F8470h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F8470h case    5:*/		return 0x820F8474;
		  /* 820F8474h */ case    6:  		/* stw R30, <#[R1 + 100]> */
		/* 820F8474h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000064) );
		/* 820F8474h case    6:*/		return 0x820F8478;
		  /* 820F8478h */ case    7:  		/* mr R6, R29 */
		/* 820F8478h case    7:*/		regs.R6 = regs.R29;
		/* 820F8478h case    7:*/		return 0x820F847C;
		  /* 820F847Ch */ case    8:  		/* stw R30, <#[R1 + 92]> */
		/* 820F847Ch case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F847Ch case    8:*/		return 0x820F8480;
		  /* 820F8480h */ case    9:  		/* mr R5, R28 */
		/* 820F8480h case    9:*/		regs.R5 = regs.R28;
		/* 820F8480h case    9:*/		return 0x820F8484;
		  /* 820F8484h */ case   10:  		/* lwz R7, <#[R11 + 8]> */
		/* 820F8484h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000008) );
		/* 820F8484h case   10:*/		return 0x820F8488;
		  /* 820F8488h */ case   11:  		/* li R4, 36 */
		/* 820F8488h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x24);
		/* 820F8488h case   11:*/		return 0x820F848C;
		  /* 820F848Ch */ case   12:  		/* stw R30, <#[R1 + 84]> */
		/* 820F848Ch case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 820F848Ch case   12:*/		return 0x820F8490;
		  /* 820F8490h */ case   13:  		/* mr R3, R31 */
		/* 820F8490h case   13:*/		regs.R3 = regs.R31;
		/* 820F8490h case   13:*/		return 0x820F8494;
		  /* 820F8494h */ case   14:  		/* bl -8500 */
		/* 820F8494h case   14:*/		regs.LR = 0x820F8498; return 0x820F6360;
		/* 820F8494h case   14:*/		return 0x820F8498;
		  /* 820F8498h */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 820F8498h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8498h case   15:*/		return 0x820F849C;
		  /* 820F849Ch */ case   16:  		/* bc 12, CR0_LT, 84 */
		/* 820F849Ch case   16:*/		if ( regs.CR[0].lt ) { return 0x820F84F0;  }
		/* 820F849Ch case   16:*/		return 0x820F84A0;
		  /* 820F84A0h */ case   17:  		/* addi R11, R1, 112 */
		/* 820F84A0h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820F84A0h case   17:*/		return 0x820F84A4;
		  /* 820F84A4h */ case   18:  		/* cmplw CR6, R28, R11 */
		/* 820F84A4h case   18:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820F84A4h case   18:*/		return 0x820F84A8;
		  /* 820F84A8h */ case   19:  		/* bc 4, CR6_EQ, 68 */
		/* 820F84A8h case   19:*/		if ( !regs.CR[6].eq ) { return 0x820F84EC;  }
		/* 820F84A8h case   19:*/		return 0x820F84AC;
		  /* 820F84ACh */ case   20:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F84ACh case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F84ACh case   20:*/		return 0x820F84B0;
		  /* 820F84B0h */ case   21:  		/* mr R10, R29 */
		/* 820F84B0h case   21:*/		regs.R10 = regs.R29;
		/* 820F84B0h case   21:*/		return 0x820F84B4;
		  /* 820F84B4h */ case   22:  		/* li R9, 0 */
		/* 820F84B4h case   22:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F84B4h case   22:*/		return 0x820F84B8;
		  /* 820F84B8h */ case   23:  		/* stw R30, <#[R1 + 108]> */
		/* 820F84B8h case   23:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000006C) );
		/* 820F84B8h case   23:*/		return 0x820F84BC;
		  /* 820F84BCh */ case   24:  		/* li R8, 0 */
		/* 820F84BCh case   24:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F84BCh case   24:*/		return 0x820F84C0;
		  /* 820F84C0h */ case   25:  		/* stw R30, <#[R1 + 100]> */
		/* 820F84C0h case   25:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000064) );
		/* 820F84C0h case   25:*/		return 0x820F84C4;
		  /* 820F84C4h */ case   26:  		/* addi R7, R1, 112 */
		/* 820F84C4h case   26:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x70);
		/* 820F84C4h case   26:*/		return 0x820F84C8;
		  /* 820F84C8h */ case   27:  		/* stw R30, <#[R1 + 92]> */
		/* 820F84C8h case   27:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F84C8h case   27:*/		return 0x820F84CC;
		  /* 820F84CCh */ case   28:  		/* mr R6, R29 */
		/* 820F84CCh case   28:*/		regs.R6 = regs.R29;
		/* 820F84CCh case   28:*/		return 0x820F84D0;
		  /* 820F84D0h */ case   29:  		/* stw R30, <#[R1 + 84]> */
		/* 820F84D0h case   29:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 820F84D0h case   29:*/		return 0x820F84D4;
		  /* 820F84D4h */ case   30:  		/* li R4, 1 */
		/* 820F84D4h case   30:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820F84D4h case   30:*/		return 0x820F84D8;
		  /* 820F84D8h */ case   31:  		/* lwz R5, <#[R11 + 16]> */
		/* 820F84D8h case   31:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000010) );
		/* 820F84D8h case   31:*/		return 0x820F84DC;
		  /* 820F84DCh */ case   32:  		/* mr R3, R31 */
		/* 820F84DCh case   32:*/		regs.R3 = regs.R31;
		/* 820F84DCh case   32:*/		return 0x820F84E0;
		  /* 820F84E0h */ case   33:  		/* bl -8576 */
		/* 820F84E0h case   33:*/		regs.LR = 0x820F84E4; return 0x820F6360;
		/* 820F84E0h case   33:*/		return 0x820F84E4;
		  /* 820F84E4h */ case   34:  		/* cmpwi CR0, R3, 0 */
		/* 820F84E4h case   34:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F84E4h case   34:*/		return 0x820F84E8;
		  /* 820F84E8h */ case   35:  		/* bc 12, CR0_LT, 8 */
		/* 820F84E8h case   35:*/		if ( regs.CR[0].lt ) { return 0x820F84F0;  }
		/* 820F84E8h case   35:*/		return 0x820F84EC;
	}
	return 0x820F84EC;
} // Block from 820F845Ch-820F84ECh (36 instructions)

//////////////////////////////////////////////////////
// Block at 820F84ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F84EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F84EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F84EC);
		  /* 820F84ECh */ case    0:  		/* li R3, 0 */
		/* 820F84ECh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F84ECh case    0:*/		return 0x820F84F0;
	}
	return 0x820F84F0;
} // Block from 820F84ECh-820F84F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F84F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F84F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F84F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F84F0);
		  /* 820F84F0h */ case    0:  		/* addi R1, R1, 176 */
		/* 820F84F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820F84F0h case    0:*/		return 0x820F84F4;
		  /* 820F84F4h */ case    1:  		/* b -422476 */
		/* 820F84F4h case    1:*/		return 0x820912A8;
		/* 820F84F4h case    1:*/		return 0x820F84F8;
	}
	return 0x820F84F8;
} // Block from 820F84F0h-820F84F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F84F8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F84F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F84F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F84F8);
		  /* 820F84F8h */ case    0:  		/* mfspr R12, LR */
		/* 820F84F8h case    0:*/		regs.R12 = regs.LR;
		/* 820F84F8h case    0:*/		return 0x820F84FC;
		  /* 820F84FCh */ case    1:  		/* bl -422568 */
		/* 820F84FCh case    1:*/		regs.LR = 0x820F8500; return 0x82091254;
		/* 820F84FCh case    1:*/		return 0x820F8500;
		  /* 820F8500h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820F8500h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820F8500h case    2:*/		return 0x820F8504;
		  /* 820F8504h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820F8504h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F8504h case    3:*/		return 0x820F8508;
		  /* 820F8508h */ case    4:  		/* li R4, 4 */
		/* 820F8508h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 820F8508h case    4:*/		return 0x820F850C;
		  /* 820F850Ch */ case    5:  		/* lwz R10, <#[R3 + 260]> */
		/* 820F850Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000104) );
		/* 820F850Ch case    5:*/		return 0x820F8510;
		  /* 820F8510h */ case    6:  		/* mr R31, R3 */
		/* 820F8510h case    6:*/		regs.R31 = regs.R3;
		/* 820F8510h case    6:*/		return 0x820F8514;
		  /* 820F8514h */ case    7:  		/* lwz R11, <#[R11 + 304]> */
		/* 820F8514h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000130) );
		/* 820F8514h case    7:*/		return 0x820F8518;
		  /* 820F8518h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 820F8518h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820F8518h case    8:*/		return 0x820F851C;
		  /* 820F851Ch */ case    9:  		/* rlwinm R27, R10, 0, 12, 31 */
		/* 820F851Ch case    9:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R27,regs.R10);
		/* 820F851Ch case    9:*/		return 0x820F8520;
		  /* 820F8520h */ case   10:  		/* mtspr CTR, R11 */
		/* 820F8520h case   10:*/		regs.CTR = regs.R11;
		/* 820F8520h case   10:*/		return 0x820F8524;
		  /* 820F8524h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 820F8524h case   11:*/		if ( 1 ) { regs.LR = 0x820F8528; return (uint32)regs.CTR; }
		/* 820F8524h case   11:*/		return 0x820F8528;
		  /* 820F8528h */ case   12:  		/* mr R4, R3 */
		/* 820F8528h case   12:*/		regs.R4 = regs.R3;
		/* 820F8528h case   12:*/		return 0x820F852C;
		  /* 820F852Ch */ case   13:  		/* mr R3, R31 */
		/* 820F852Ch case   13:*/		regs.R3 = regs.R31;
		/* 820F852Ch case   13:*/		return 0x820F8530;
		  /* 820F8530h */ case   14:  		/* bl -9280 */
		/* 820F8530h case   14:*/		regs.LR = 0x820F8534; return 0x820F60F0;
		/* 820F8530h case   14:*/		return 0x820F8534;
		  /* 820F8534h */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 820F8534h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8534h case   15:*/		return 0x820F8538;
		  /* 820F8538h */ case   16:  		/* bc 12, CR0_LT, 436 */
		/* 820F8538h case   16:*/		if ( regs.CR[0].lt ) { return 0x820F86EC;  }
		/* 820F8538h case   16:*/		return 0x820F853C;
		  /* 820F853Ch */ case   17:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F853Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F853Ch case   17:*/		return 0x820F8540;
		  /* 820F8540h */ case   18:  		/* addi R7, R1, 88 */
		/* 820F8540h case   18:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x58);
		/* 820F8540h case   18:*/		return 0x820F8544;
		  /* 820F8544h */ case   19:  		/* lwz R10, <#[R31]> */
		/* 820F8544h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F8544h case   19:*/		return 0x820F8548;
		  /* 820F8548h */ case   20:  		/* addi R6, R1, 92 */
		/* 820F8548h case   20:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x5C);
		/* 820F8548h case   20:*/		return 0x820F854C;
		  /* 820F854Ch */ case   21:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F854Ch case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F854Ch case   21:*/		return 0x820F8550;
		  /* 820F8550h */ case   22:  		/* addi R5, R1, 80 */
		/* 820F8550h case   22:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820F8550h case   22:*/		return 0x820F8554;
		  /* 820F8554h */ case   23:  		/* mr R3, R31 */
		/* 820F8554h case   23:*/		regs.R3 = regs.R31;
		/* 820F8554h case   23:*/		return 0x820F8558;
		  /* 820F8558h */ case   24:  		/* lwz R11, <#[R11 + 16]> */
		/* 820F8558h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820F8558h case   24:*/		return 0x820F855C;
		  /* 820F855Ch */ case   25:  		/* lwz R10, <#[R10 + 320]> */
		/* 820F855Ch case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000140) );
		/* 820F855Ch case   25:*/		return 0x820F8560;
		  /* 820F8560h */ case   26:  		/* lwz R11, <#[R11]> */
		/* 820F8560h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F8560h case   26:*/		return 0x820F8564;
		  /* 820F8564h */ case   27:  		/* mtspr CTR, R10 */
		/* 820F8564h case   27:*/		regs.CTR = regs.R10;
		/* 820F8564h case   27:*/		return 0x820F8568;
		  /* 820F8568h */ case   28:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F8568h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F8568h case   28:*/		return 0x820F856C;
		  /* 820F856Ch */ case   29:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F856Ch case   29:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F856Ch case   29:*/		return 0x820F8570;
		  /* 820F8570h */ case   30:  		/* bcctrl 20, CR0_LT */
		/* 820F8570h case   30:*/		if ( 1 ) { regs.LR = 0x820F8574; return (uint32)regs.CTR; }
		/* 820F8570h case   30:*/		return 0x820F8574;
		  /* 820F8574h */ case   31:  		/* cmpwi CR0, R3, 0 */
		/* 820F8574h case   31:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8574h case   31:*/		return 0x820F8578;
		  /* 820F8578h */ case   32:  		/* bc 12, CR0_LT, 372 */
		/* 820F8578h case   32:*/		if ( regs.CR[0].lt ) { return 0x820F86EC;  }
		/* 820F8578h case   32:*/		return 0x820F857C;
		  /* 820F857Ch */ case   33:  		/* lwz R11, <#[R31]> */
		/* 820F857Ch case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F857Ch case   33:*/		return 0x820F8580;
		  /* 820F8580h */ case   34:  		/* addi R6, R1, 84 */
		/* 820F8580h case   34:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 820F8580h case   34:*/		return 0x820F8584;
		  /* 820F8584h */ case   35:  		/* lwz R10, <#[R31 + 260]> */
		/* 820F8584h case   35:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000104) );
		/* 820F8584h case   35:*/		return 0x820F8588;
		  /* 820F8588h */ case   36:  		/* mr R5, R27 */
		/* 820F8588h case   36:*/		regs.R5 = regs.R27;
		/* 820F8588h case   36:*/		return 0x820F858C;
		  /* 820F858Ch */ case   37:  		/* mr R3, R31 */
		/* 820F858Ch case   37:*/		regs.R3 = regs.R31;
		/* 820F858Ch case   37:*/		return 0x820F8590;
		  /* 820F8590h */ case   38:  		/* lwz R7, <#[R1 + 88]> */
		/* 820F8590h case   38:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000058) );
		/* 820F8590h case   38:*/		return 0x820F8594;
		  /* 820F8594h */ case   39:  		/* lwz R11, <#[R11 + 324]> */
		/* 820F8594h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000144) );
		/* 820F8594h case   39:*/		return 0x820F8598;
		  /* 820F8598h */ case   40:  		/* lwz R4, <#[R10 + 16]> */
		/* 820F8598h case   40:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000010) );
		/* 820F8598h case   40:*/		return 0x820F859C;
		  /* 820F859Ch */ case   41:  		/* mtspr CTR, R11 */
		/* 820F859Ch case   41:*/		regs.CTR = regs.R11;
		/* 820F859Ch case   41:*/		return 0x820F85A0;
		  /* 820F85A0h */ case   42:  		/* bcctrl 20, CR0_LT */
		/* 820F85A0h case   42:*/		if ( 1 ) { regs.LR = 0x820F85A4; return (uint32)regs.CTR; }
		/* 820F85A0h case   42:*/		return 0x820F85A4;
		  /* 820F85A4h */ case   43:  		/* cmpwi CR0, R3, 0 */
		/* 820F85A4h case   43:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F85A4h case   43:*/		return 0x820F85A8;
		  /* 820F85A8h */ case   44:  		/* bc 12, CR0_LT, 324 */
		/* 820F85A8h case   44:*/		if ( regs.CR[0].lt ) { return 0x820F86EC;  }
		/* 820F85A8h case   44:*/		return 0x820F85AC;
		  /* 820F85ACh */ case   45:  		/* lwz R11, <#[R31]> */
		/* 820F85ACh case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F85ACh case   45:*/		return 0x820F85B0;
	}
	return 0x820F85B0;
} // Block from 820F84F8h-820F85B0h (46 instructions)

//////////////////////////////////////////////////////
// Block at 820F85B0h
// Function '?EmitANDIFBOOL@CShaderProgram@D3DXShader@@MAAJH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F85B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F85B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F85B0);
		  /* 820F85B0h */ case    0:  		/* mr R3, R31 */
		/* 820F85B0h case    0:*/		regs.R3 = regs.R31;
		/* 820F85B0h case    0:*/		return 0x820F85B4;
		  /* 820F85B4h */ case    1:  		/* lwz R6, <#[R1 + 92]> */
		/* 820F85B4h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F85B4h case    1:*/		return 0x820F85B8;
		  /* 820F85B8h */ case    2:  		/* lwz R5, <#[R1 + 84]> */
		/* 820F85B8h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 820F85B8h case    2:*/		return 0x820F85BC;
		  /* 820F85BCh */ case    3:  		/* lwz R4, <#[R1 + 80]> */
		/* 820F85BCh case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 820F85BCh case    3:*/		return 0x820F85C0;
		  /* 820F85C0h */ case    4:  		/* lwz R11, <#[R11 + 312]> */
		/* 820F85C0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000138) );
		/* 820F85C0h case    4:*/		return 0x820F85C4;
		  /* 820F85C4h */ case    5:  		/* mtspr CTR, R11 */
		/* 820F85C4h case    5:*/		regs.CTR = regs.R11;
		/* 820F85C4h case    5:*/		return 0x820F85C8;
		  /* 820F85C8h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 820F85C8h case    6:*/		if ( 1 ) { regs.LR = 0x820F85CC; return (uint32)regs.CTR; }
		/* 820F85C8h case    6:*/		return 0x820F85CC;
		  /* 820F85CCh */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820F85CCh case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F85CCh case    7:*/		return 0x820F85D0;
		  /* 820F85D0h */ case    8:  		/* bc 12, CR0_LT, 284 */
		/* 820F85D0h case    8:*/		if ( regs.CR[0].lt ) { return 0x820F86EC;  }
		/* 820F85D0h case    8:*/		return 0x820F85D4;
		  /* 820F85D4h */ case    9:  		/* li R29, 0 */
		/* 820F85D4h case    9:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820F85D4h case    9:*/		return 0x820F85D8;
		  /* 820F85D8h */ case   10:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F85D8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F85D8h case   10:*/		return 0x820F85DC;
		  /* 820F85DCh */ case   11:  		/* mullw R10, R29, R27 */
		/* 820F85DCh case   11:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R29,regs.R27);
		/* 820F85DCh case   11:*/		return 0x820F85E0;
		  /* 820F85E0h */ case   12:  		/* lwz R9, <#[R11 + 8]> */
		/* 820F85E0h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 820F85E0h case   12:*/		return 0x820F85E4;
		  /* 820F85E4h */ case   13:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F85E4h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F85E4h case   13:*/		return 0x820F85E8;
		  /* 820F85E8h */ case   14:  		/* cmplwi CR6, R29, 1 */
		/* 820F85E8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000001);
		/* 820F85E8h case   14:*/		return 0x820F85EC;
		  /* 820F85ECh */ case   15:  		/* add R30, R10, R9 */
		/* 820F85ECh case   15:*/		cpu::op::add<0>(regs,&regs.R30,regs.R10,regs.R9);
		/* 820F85ECh case   15:*/		return 0x820F85F0;
		  /* 820F85F0h */ case   16:  		/* bc 4, CR6_EQ, 28 */
		/* 820F85F0h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820F860C;  }
		/* 820F85F0h case   16:*/		return 0x820F85F4;
		  /* 820F85F4h */ case   17:  		/* lwz R11, <#[R11]> */
		/* 820F85F4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F85F4h case   17:*/		return 0x820F85F8;
		  /* 820F85F8h */ case   18:  		/* lis R10, 28736 */
		/* 820F85F8h case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0x7040);
		/* 820F85F8h case   18:*/		return 0x820F85FC;
		  /* 820F85FCh */ case   19:  		/* li R28, 1 */
		/* 820F85FCh case   19:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 820F85FCh case   19:*/		return 0x820F8600;
		  /* 820F8600h */ case   20:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820F8600h case   20:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820F8600h case   20:*/		return 0x820F8604;
		  /* 820F8604h */ case   21:  		/* cmplw CR6, R11, R10 */
		/* 820F8604h case   21:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F8604h case   21:*/		return 0x820F8608;
		  /* 820F8608h */ case   22:  		/* bc 12, CR6_EQ, 8 */
		/* 820F8608h case   22:*/		if ( regs.CR[6].eq ) { return 0x820F8610;  }
		/* 820F8608h case   22:*/		return 0x820F860C;
	}
	return 0x820F860C;
} // Block from 820F85B0h-820F860Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 820F860Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F860C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F860C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F860C);
		  /* 820F860Ch */ case    0:  		/* li R28, 0 */
		/* 820F860Ch case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820F860Ch case    0:*/		return 0x820F8610;
	}
	return 0x820F8610;
} // Block from 820F860Ch-820F8610h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F8610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8610);
		  /* 820F8610h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820F8610h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F8610h case    0:*/		return 0x820F8614;
		  /* 820F8614h */ case    1:  		/* addi R6, R1, 96 */
		/* 820F8614h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x60);
		/* 820F8614h case    1:*/		return 0x820F8618;
		  /* 820F8618h */ case    2:  		/* lwz R10, <#[R30]> */
		/* 820F8618h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820F8618h case    2:*/		return 0x820F861C;
		  /* 820F861Ch */ case    3:  		/* addi R5, R1, 80 */
		/* 820F861Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820F861Ch case    3:*/		return 0x820F8620;
		  /* 820F8620h */ case    4:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F8620h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F8620h case    4:*/		return 0x820F8624;
		  /* 820F8624h */ case    5:  		/* mr R3, R31 */
		/* 820F8624h case    5:*/		regs.R3 = regs.R31;
		/* 820F8624h case    5:*/		return 0x820F8628;
		  /* 820F8628h */ case    6:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F8628h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F8628h case    6:*/		return 0x820F862C;
		  /* 820F862Ch */ case    7:  		/* lwz R11, <#[R11 + 328]> */
		/* 820F862Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000148) );
		/* 820F862Ch case    7:*/		return 0x820F8630;
		  /* 820F8630h */ case    8:  		/* lwzx R4, <#[R10 + R9]> */
		/* 820F8630h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820F8630h case    8:*/		return 0x820F8634;
		  /* 820F8634h */ case    9:  		/* mtspr CTR, R11 */
		/* 820F8634h case    9:*/		regs.CTR = regs.R11;
		/* 820F8634h case    9:*/		return 0x820F8638;
		  /* 820F8638h */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 820F8638h case   10:*/		if ( 1 ) { regs.LR = 0x820F863C; return (uint32)regs.CTR; }
		/* 820F8638h case   10:*/		return 0x820F863C;
		  /* 820F863Ch */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820F863Ch case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F863Ch case   11:*/		return 0x820F8640;
		  /* 820F8640h */ case   12:  		/* bc 12, CR0_LT, 172 */
		/* 820F8640h case   12:*/		if ( regs.CR[0].lt ) { return 0x820F86EC;  }
		/* 820F8640h case   12:*/		return 0x820F8644;
		  /* 820F8644h */ case   13:  		/* lwz R11, <#[R31]> */
		/* 820F8644h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F8644h case   13:*/		return 0x820F8648;
		  /* 820F8648h */ case   14:  		/* addi R7, R1, 100 */
		/* 820F8648h case   14:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x64);
		/* 820F8648h case   14:*/		return 0x820F864C;
		  /* 820F864Ch */ case   15:  		/* mr R5, R27 */
		/* 820F864Ch case   15:*/		regs.R5 = regs.R27;
		/* 820F864Ch case   15:*/		return 0x820F8650;
		  /* 820F8650h */ case   16:  		/* lwz R6, <#[R1 + 84]> */
		/* 820F8650h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 820F8650h case   16:*/		return 0x820F8654;
		  /* 820F8654h */ case   17:  		/* mr R4, R30 */
		/* 820F8654h case   17:*/		regs.R4 = regs.R30;
		/* 820F8654h case   17:*/		return 0x820F8658;
		  /* 820F8658h */ case   18:  		/* mr R3, R31 */
		/* 820F8658h case   18:*/		regs.R3 = regs.R31;
		/* 820F8658h case   18:*/		return 0x820F865C;
		  /* 820F865Ch */ case   19:  		/* lwz R11, <#[R11 + 332]> */
		/* 820F865Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000014C) );
		/* 820F865Ch case   19:*/		return 0x820F8660;
		  /* 820F8660h */ case   20:  		/* mtspr CTR, R11 */
		/* 820F8660h case   20:*/		regs.CTR = regs.R11;
		/* 820F8660h case   20:*/		return 0x820F8664;
		  /* 820F8664h */ case   21:  		/* bcctrl 20, CR0_LT */
		/* 820F8664h case   21:*/		if ( 1 ) { regs.LR = 0x820F8668; return (uint32)regs.CTR; }
		/* 820F8664h case   21:*/		return 0x820F8668;
		  /* 820F8668h */ case   22:  		/* cmpwi CR0, R3, 0 */
		/* 820F8668h case   22:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8668h case   22:*/		return 0x820F866C;
		  /* 820F866Ch */ case   23:  		/* bc 12, CR0_LT, 128 */
		/* 820F866Ch case   23:*/		if ( regs.CR[0].lt ) { return 0x820F86EC;  }
		/* 820F866Ch case   23:*/		return 0x820F8670;
		  /* 820F8670h */ case   24:  		/* cmplwi CR6, R28, 0 */
		/* 820F8670h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820F8670h case   24:*/		return 0x820F8674;
		  /* 820F8674h */ case   25:  		/* bc 12, CR6_EQ, 20 */
		/* 820F8674h case   25:*/		if ( regs.CR[6].eq ) { return 0x820F8688;  }
		/* 820F8674h case   25:*/		return 0x820F8678;
		  /* 820F8678h */ case   26:  		/* lwz R3, <#[R1 + 80]> */
		/* 820F8678h case   26:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 820F8678h case   26:*/		return 0x820F867C;
		  /* 820F867Ch */ case   27:  		/* bl -47916 */
		/* 820F867Ch case   27:*/		regs.LR = 0x820F8680; return 0x820ECB50;
		/* 820F867Ch case   27:*/		return 0x820F8680;
		  /* 820F8680h */ case   28:  		/* mr R4, R3 */
		/* 820F8680h case   28:*/		regs.R4 = regs.R3;
		/* 820F8680h case   28:*/		return 0x820F8684;
		  /* 820F8684h */ case   29:  		/* b 8 */
		/* 820F8684h case   29:*/		return 0x820F868C;
		/* 820F8684h case   29:*/		return 0x820F8688;
	}
	return 0x820F8688;
} // Block from 820F8610h-820F8688h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820F8688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8688);
		  /* 820F8688h */ case    0:  		/* lwz R4, <#[R1 + 80]> */
		/* 820F8688h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 820F8688h case    0:*/		return 0x820F868C;
	}
	return 0x820F868C;
} // Block from 820F8688h-820F868Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F868Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F868C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F868C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F868C);
		  /* 820F868Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820F868Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F868Ch case    0:*/		return 0x820F8690;
		  /* 820F8690h */ case    1:  		/* mr R3, R31 */
		/* 820F8690h case    1:*/		regs.R3 = regs.R31;
		/* 820F8690h case    1:*/		return 0x820F8694;
		  /* 820F8694h */ case    2:  		/* lwz R6, <#[R1 + 96]> */
		/* 820F8694h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000060) );
		/* 820F8694h case    2:*/		return 0x820F8698;
		  /* 820F8698h */ case    3:  		/* lwz R5, <#[R1 + 100]> */
		/* 820F8698h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000064) );
		/* 820F8698h case    3:*/		return 0x820F869C;
		  /* 820F869Ch */ case    4:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F869Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F869Ch case    4:*/		return 0x820F86A0;
	}
	return 0x820F86A0;
} // Block from 820F868Ch-820F86A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F86A0h
// Function '?EmitANDELSE@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F86A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F86A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F86A0);
		  /* 820F86A0h */ case    0:  		/* mtspr CTR, R11 */
		/* 820F86A0h case    0:*/		regs.CTR = regs.R11;
		/* 820F86A0h case    0:*/		return 0x820F86A4;
		  /* 820F86A4h */ case    1:  		/* bcctrl 20, CR0_LT */
		/* 820F86A4h case    1:*/		if ( 1 ) { regs.LR = 0x820F86A8; return (uint32)regs.CTR; }
		/* 820F86A4h case    1:*/		return 0x820F86A8;
		  /* 820F86A8h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820F86A8h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F86A8h case    2:*/		return 0x820F86AC;
		  /* 820F86ACh */ case    3:  		/* bc 12, CR0_LT, 64 */
		/* 820F86ACh case    3:*/		if ( regs.CR[0].lt ) { return 0x820F86EC;  }
		/* 820F86ACh case    3:*/		return 0x820F86B0;
		  /* 820F86B0h */ case    4:  		/* addi R29, R29, 1 */
		/* 820F86B0h case    4:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820F86B0h case    4:*/		return 0x820F86B4;
		  /* 820F86B4h */ case    5:  		/* cmplwi CR6, R29, 3 */
		/* 820F86B4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000003);
		/* 820F86B4h case    5:*/		return 0x820F86B8;
		  /* 820F86B8h */ case    6:  		/* bc 12, CR6_LT, -224 */
		/* 820F86B8h case    6:*/		if ( regs.CR[6].lt ) { return 0x820F85D8;  }
		/* 820F86B8h case    6:*/		return 0x820F86BC;
		  /* 820F86BCh */ case    7:  		/* lwz R11, <#[R31]> */
		/* 820F86BCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F86BCh case    7:*/		return 0x820F86C0;
		  /* 820F86C0h */ case    8:  		/* mr R3, R31 */
		/* 820F86C0h case    8:*/		regs.R3 = regs.R31;
		/* 820F86C0h case    8:*/		return 0x820F86C4;
		  /* 820F86C4h */ case    9:  		/* lwz R11, <#[R11 + 308]> */
		/* 820F86C4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000134) );
		/* 820F86C4h case    9:*/		return 0x820F86C8;
		  /* 820F86C8h */ case   10:  		/* mtspr CTR, R11 */
		/* 820F86C8h case   10:*/		regs.CTR = regs.R11;
		/* 820F86C8h case   10:*/		return 0x820F86CC;
		  /* 820F86CCh */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 820F86CCh case   11:*/		if ( 1 ) { regs.LR = 0x820F86D0; return (uint32)regs.CTR; }
		/* 820F86CCh case   11:*/		return 0x820F86D0;
		  /* 820F86D0h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820F86D0h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F86D0h case   12:*/		return 0x820F86D4;
		  /* 820F86D4h */ case   13:  		/* bc 12, CR0_LT, 24 */
		/* 820F86D4h case   13:*/		if ( regs.CR[0].lt ) { return 0x820F86EC;  }
		/* 820F86D4h case   13:*/		return 0x820F86D8;
		  /* 820F86D8h */ case   14:  		/* mr R3, R31 */
		/* 820F86D8h case   14:*/		regs.R3 = regs.R31;
		/* 820F86D8h case   14:*/		return 0x820F86DC;
		  /* 820F86DCh */ case   15:  		/* bl -44500 */
		/* 820F86DCh case   15:*/		regs.LR = 0x820F86E0; return 0x820ED908;
		/* 820F86DCh case   15:*/		return 0x820F86E0;
		  /* 820F86E0h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 820F86E0h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F86E0h case   16:*/		return 0x820F86E4;
		  /* 820F86E4h */ case   17:  		/* bc 12, CR0_LT, 8 */
		/* 820F86E4h case   17:*/		if ( regs.CR[0].lt ) { return 0x820F86EC;  }
		/* 820F86E4h case   17:*/		return 0x820F86E8;
		  /* 820F86E8h */ case   18:  		/* li R3, 0 */
		/* 820F86E8h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F86E8h case   18:*/		return 0x820F86EC;
	}
	return 0x820F86EC;
} // Block from 820F86A0h-820F86ECh (19 instructions)

//////////////////////////////////////////////////////
// Block at 820F86ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F86EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F86EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F86EC);
		  /* 820F86ECh */ case    0:  		/* addi R1, R1, 160 */
		/* 820F86ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820F86ECh case    0:*/		return 0x820F86F0;
		  /* 820F86F0h */ case    1:  		/* b -422988 */
		/* 820F86F0h case    1:*/		return 0x820912A4;
		/* 820F86F0h case    1:*/		return 0x820F86F4;
		  /* 820F86F4h */ case    2:  		/* nop */
		/* 820F86F4h case    2:*/		cpu::op::nop();
		/* 820F86F4h case    2:*/		return 0x820F86F8;
	}
	return 0x820F86F8;
} // Block from 820F86ECh-820F86F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F86F8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F86F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F86F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F86F8);
		  /* 820F86F8h */ case    0:  		/* mfspr R12, LR */
		/* 820F86F8h case    0:*/		regs.R12 = regs.LR;
		/* 820F86F8h case    0:*/		return 0x820F86FC;
		  /* 820F86FCh */ case    1:  		/* bl -423072 */
		/* 820F86FCh case    1:*/		regs.LR = 0x820F8700; return 0x8209125C;
		/* 820F86FCh case    1:*/		return 0x820F8700;
		  /* 820F8700h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820F8700h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820F8700h case    2:*/		return 0x820F8704;
		  /* 820F8704h */ case    3:  		/* lwz R11, <#[R3 + 260]> */
		/* 820F8704h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000104) );
		/* 820F8704h case    3:*/		return 0x820F8708;
	}
	return 0x820F8708;
} // Block from 820F86F8h-820F8708h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F8708h
// Function '?EmitANDENDIF@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8708);
		  /* 820F8708h */ case    0:  		/* lis R10, 28752 */
		/* 820F8708h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x7050);
		/* 820F8708h case    0:*/		return 0x820F870C;
		  /* 820F870Ch */ case    1:  		/* mr R31, R3 */
		/* 820F870Ch case    1:*/		regs.R31 = regs.R3;
		/* 820F870Ch case    1:*/		return 0x820F8710;
		  /* 820F8710h */ case    2:  		/* ori R10, R10, 3 */
		/* 820F8710h case    2:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x3);
		/* 820F8710h case    2:*/		return 0x820F8714;
		  /* 820F8714h */ case    3:  		/* li R4, 0 */
		/* 820F8714h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F8714h case    3:*/		return 0x820F8718;
		  /* 820F8718h */ case    4:  		/* lwz R11, <#[R11]> */
		/* 820F8718h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F8718h case    4:*/		return 0x820F871C;
		  /* 820F871Ch */ case    5:  		/* rlwinm R29, R11, 0, 12, 31 */
		/* 820F871Ch case    5:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R29,regs.R11);
		/* 820F871Ch case    5:*/		return 0x820F8720;
		  /* 820F8720h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 820F8720h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F8720h case    6:*/		return 0x820F8724;
		  /* 820F8724h */ case    7:  		/* bc 12, CR6_EQ, 76 */
		/* 820F8724h case    7:*/		if ( regs.CR[6].eq ) { return 0x820F8770;  }
		/* 820F8724h case    7:*/		return 0x820F8728;
		  /* 820F8728h */ case    8:  		/* addis R11, R11, -28768 */
		/* 820F8728h case    8:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R11,0xFFFF8FA0);
		/* 820F8728h case    8:*/		return 0x820F872C;
		  /* 820F872Ch */ case    9:  		/* addic. R11, R11, -3 */
		/* 820F872Ch case    9:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFD);
		/* 820F872Ch case    9:*/		return 0x820F8730;
		  /* 820F8730h */ case   10:  		/* bc 12, CR0_EQ, 56 */
		/* 820F8730h case   10:*/		if ( regs.CR[0].eq ) { return 0x820F8768;  }
		/* 820F8730h case   10:*/		return 0x820F8734;
		  /* 820F8734h */ case   11:  		/* cmplwi CR6, R11, 1 */
		/* 820F8734h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820F8734h case   11:*/		return 0x820F8738;
		  /* 820F8738h */ case   12:  		/* bc 12, CR6_EQ, 40 */
		/* 820F8738h case   12:*/		if ( regs.CR[6].eq ) { return 0x820F8760;  }
		/* 820F8738h case   12:*/		return 0x820F873C;
		  /* 820F873Ch */ case   13:  		/* addis R11, R11, -16 */
		/* 820F873Ch case   13:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R11,0xFFFFFFF0);
		/* 820F873Ch case   13:*/		return 0x820F8740;
		  /* 820F8740h */ case   14:  		/* cmplwi CR0, R11, 0 */
		/* 820F8740h case   14:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820F8740h case   14:*/		return 0x820F8744;
		  /* 820F8744h */ case   15:  		/* bc 12, CR0_EQ, 20 */
		/* 820F8744h case   15:*/		if ( regs.CR[0].eq ) { return 0x820F8758;  }
		/* 820F8744h case   15:*/		return 0x820F8748;
		  /* 820F8748h */ case   16:  		/* cmplwi CR6, R11, 1 */
		/* 820F8748h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820F8748h case   16:*/		return 0x820F874C;
		  /* 820F874Ch */ case   17:  		/* bc 4, CR6_EQ, 40 */
		/* 820F874Ch case   17:*/		if ( !regs.CR[6].eq ) { return 0x820F8774;  }
		/* 820F874Ch case   17:*/		return 0x820F8750;
		  /* 820F8750h */ case   18:  		/* li R4, 20 */
		/* 820F8750h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 820F8750h case   18:*/		return 0x820F8754;
		  /* 820F8754h */ case   19:  		/* b 32 */
		/* 820F8754h case   19:*/		return 0x820F8774;
		/* 820F8754h case   19:*/		return 0x820F8758;
	}
	return 0x820F8758;
} // Block from 820F8708h-820F8758h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820F8758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8758);
		  /* 820F8758h */ case    0:  		/* li R4, 22 */
		/* 820F8758h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x16);
		/* 820F8758h case    0:*/		return 0x820F875C;
		  /* 820F875Ch */ case    1:  		/* b 24 */
		/* 820F875Ch case    1:*/		return 0x820F8774;
		/* 820F875Ch case    1:*/		return 0x820F8760;
	}
	return 0x820F8760;
} // Block from 820F8758h-820F8760h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F8760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8760);
		  /* 820F8760h */ case    0:  		/* li R4, 21 */
		/* 820F8760h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x15);
		/* 820F8760h case    0:*/		return 0x820F8764;
		  /* 820F8764h */ case    1:  		/* b 16 */
		/* 820F8764h case    1:*/		return 0x820F8774;
		/* 820F8764h case    1:*/		return 0x820F8768;
	}
	return 0x820F8768;
} // Block from 820F8760h-820F8768h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F8768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8768);
		  /* 820F8768h */ case    0:  		/* li R4, 23 */
		/* 820F8768h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x17);
		/* 820F8768h case    0:*/		return 0x820F876C;
		  /* 820F876Ch */ case    1:  		/* b 8 */
		/* 820F876Ch case    1:*/		return 0x820F8774;
		/* 820F876Ch case    1:*/		return 0x820F8770;
	}
	return 0x820F8770;
} // Block from 820F8768h-820F8770h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F8770h
// Function '?EmitNEG@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8770);
		  /* 820F8770h */ case    0:  		/* li R4, 24 */
		/* 820F8770h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 820F8770h case    0:*/		return 0x820F8774;
	}
	return 0x820F8774;
} // Block from 820F8770h-820F8774h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F8774h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8774( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8774) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8774);
		  /* 820F8774h */ case    0:  		/* mr R3, R31 */
		/* 820F8774h case    0:*/		regs.R3 = regs.R31;
		/* 820F8774h case    0:*/		return 0x820F8778;
		  /* 820F8778h */ case    1:  		/* bl -9864 */
		/* 820F8778h case    1:*/		regs.LR = 0x820F877C; return 0x820F60F0;
		/* 820F8778h case    1:*/		return 0x820F877C;
		  /* 820F877Ch */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820F877Ch case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F877Ch case    2:*/		return 0x820F8780;
		  /* 820F8780h */ case    3:  		/* bc 12, CR0_LT, 528 */
		/* 820F8780h case    3:*/		if ( regs.CR[0].lt ) { return 0x820F8990;  }
		/* 820F8780h case    3:*/		return 0x820F8784;
		  /* 820F8784h */ case    4:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F8784h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F8784h case    4:*/		return 0x820F8788;
		  /* 820F8788h */ case    5:  		/* addi R7, R1, 96 */
		/* 820F8788h case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820F8788h case    5:*/		return 0x820F878C;
		  /* 820F878Ch */ case    6:  		/* lwz R10, <#[R31]> */
		/* 820F878Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F878Ch case    6:*/		return 0x820F8790;
		  /* 820F8790h */ case    7:  		/* addi R6, R1, 100 */
		/* 820F8790h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x64);
		/* 820F8790h case    7:*/		return 0x820F8794;
		  /* 820F8794h */ case    8:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F8794h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F8794h case    8:*/		return 0x820F8798;
		  /* 820F8798h */ case    9:  		/* addi R5, R1, 84 */
		/* 820F8798h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 820F8798h case    9:*/		return 0x820F879C;
		  /* 820F879Ch */ case   10:  		/* mr R3, R31 */
		/* 820F879Ch case   10:*/		regs.R3 = regs.R31;
		/* 820F879Ch case   10:*/		return 0x820F87A0;
		  /* 820F87A0h */ case   11:  		/* lwz R11, <#[R11 + 16]> */
		/* 820F87A0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820F87A0h case   11:*/		return 0x820F87A4;
		  /* 820F87A4h */ case   12:  		/* lwz R10, <#[R10 + 320]> */
		/* 820F87A4h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000140) );
		/* 820F87A4h case   12:*/		return 0x820F87A8;
		  /* 820F87A8h */ case   13:  		/* lwz R11, <#[R11]> */
		/* 820F87A8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F87A8h case   13:*/		return 0x820F87AC;
		  /* 820F87ACh */ case   14:  		/* mtspr CTR, R10 */
		/* 820F87ACh case   14:*/		regs.CTR = regs.R10;
		/* 820F87ACh case   14:*/		return 0x820F87B0;
		  /* 820F87B0h */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F87B0h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F87B0h case   15:*/		return 0x820F87B4;
		  /* 820F87B4h */ case   16:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F87B4h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F87B4h case   16:*/		return 0x820F87B8;
		  /* 820F87B8h */ case   17:  		/* bcctrl 20, CR0_LT */
		/* 820F87B8h case   17:*/		if ( 1 ) { regs.LR = 0x820F87BC; return (uint32)regs.CTR; }
		/* 820F87B8h case   17:*/		return 0x820F87BC;
		  /* 820F87BCh */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 820F87BCh case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F87BCh case   18:*/		return 0x820F87C0;
		  /* 820F87C0h */ case   19:  		/* bc 12, CR0_LT, 464 */
		/* 820F87C0h case   19:*/		if ( regs.CR[0].lt ) { return 0x820F8990;  }
		/* 820F87C0h case   19:*/		return 0x820F87C4;
		  /* 820F87C4h */ case   20:  		/* lwz R11, <#[R31]> */
		/* 820F87C4h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F87C4h case   20:*/		return 0x820F87C8;
		  /* 820F87C8h */ case   21:  		/* addi R6, R1, 80 */
		/* 820F87C8h case   21:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 820F87C8h case   21:*/		return 0x820F87CC;
		  /* 820F87CCh */ case   22:  		/* lwz R10, <#[R31 + 260]> */
		/* 820F87CCh case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000104) );
		/* 820F87CCh case   22:*/		return 0x820F87D0;
		  /* 820F87D0h */ case   23:  		/* mr R3, R31 */
		/* 820F87D0h case   23:*/		regs.R3 = regs.R31;
		/* 820F87D0h case   23:*/		return 0x820F87D4;
		  /* 820F87D4h */ case   24:  		/* lwz R7, <#[R1 + 96]> */
		/* 820F87D4h case   24:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000060) );
		/* 820F87D4h case   24:*/		return 0x820F87D8;
		  /* 820F87D8h */ case   25:  		/* lwz R11, <#[R11 + 324]> */
		/* 820F87D8h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000144) );
		/* 820F87D8h case   25:*/		return 0x820F87DC;
		  /* 820F87DCh */ case   26:  		/* lwz R5, <#[R10 + 12]> */
		/* 820F87DCh case   26:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x0000000C) );
		/* 820F87DCh case   26:*/		return 0x820F87E0;
		  /* 820F87E0h */ case   27:  		/* lwz R4, <#[R10 + 16]> */
		/* 820F87E0h case   27:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000010) );
		/* 820F87E0h case   27:*/		return 0x820F87E4;
		  /* 820F87E4h */ case   28:  		/* mtspr CTR, R11 */
		/* 820F87E4h case   28:*/		regs.CTR = regs.R11;
		/* 820F87E4h case   28:*/		return 0x820F87E8;
		  /* 820F87E8h */ case   29:  		/* bcctrl 20, CR0_LT */
		/* 820F87E8h case   29:*/		if ( 1 ) { regs.LR = 0x820F87EC; return (uint32)regs.CTR; }
		/* 820F87E8h case   29:*/		return 0x820F87EC;
		  /* 820F87ECh */ case   30:  		/* cmpwi CR0, R3, 0 */
		/* 820F87ECh case   30:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F87ECh case   30:*/		return 0x820F87F0;
		  /* 820F87F0h */ case   31:  		/* bc 12, CR0_LT, 416 */
		/* 820F87F0h case   31:*/		if ( regs.CR[0].lt ) { return 0x820F8990;  }
		/* 820F87F0h case   31:*/		return 0x820F87F4;
		  /* 820F87F4h */ case   32:  		/* lwz R11, <#[R31]> */
		/* 820F87F4h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F87F4h case   32:*/		return 0x820F87F8;
		  /* 820F87F8h */ case   33:  		/* mr R3, R31 */
		/* 820F87F8h case   33:*/		regs.R3 = regs.R31;
		/* 820F87F8h case   33:*/		return 0x820F87FC;
		  /* 820F87FCh */ case   34:  		/* lwz R6, <#[R1 + 100]> */
		/* 820F87FCh case   34:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000064) );
		/* 820F87FCh case   34:*/		return 0x820F8800;
		  /* 820F8800h */ case   35:  		/* lwz R5, <#[R1 + 80]> */
		/* 820F8800h case   35:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 820F8800h case   35:*/		return 0x820F8804;
		  /* 820F8804h */ case   36:  		/* lwz R4, <#[R1 + 84]> */
		/* 820F8804h case   36:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 820F8804h case   36:*/		return 0x820F8808;
		  /* 820F8808h */ case   37:  		/* lwz R11, <#[R11 + 312]> */
		/* 820F8808h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000138) );
		/* 820F8808h case   37:*/		return 0x820F880C;
		  /* 820F880Ch */ case   38:  		/* mtspr CTR, R11 */
		/* 820F880Ch case   38:*/		regs.CTR = regs.R11;
		/* 820F880Ch case   38:*/		return 0x820F8810;
		  /* 820F8810h */ case   39:  		/* bcctrl 20, CR0_LT */
		/* 820F8810h case   39:*/		if ( 1 ) { regs.LR = 0x820F8814; return (uint32)regs.CTR; }
		/* 820F8810h case   39:*/		return 0x820F8814;
		  /* 820F8814h */ case   40:  		/* cmpwi CR0, R3, 0 */
		/* 820F8814h case   40:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8814h case   40:*/		return 0x820F8818;
		  /* 820F8818h */ case   41:  		/* bc 12, CR0_LT, 376 */
		/* 820F8818h case   41:*/		if ( regs.CR[0].lt ) { return 0x820F8990;  }
		/* 820F8818h case   41:*/		return 0x820F881C;
		  /* 820F881Ch */ case   42:  		/* cmplwi CR6, R29, 3 */
		/* 820F881Ch case   42:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000003);
		/* 820F881Ch case   42:*/		return 0x820F8820;
		  /* 820F8820h */ case   43:  		/* lis R11, 7 */
		/* 820F8820h case   43:*/		cpu::op::lis<0>(regs,&regs.R11,0x7);
		/* 820F8820h case   43:*/		return 0x820F8824;
		  /* 820F8824h */ case   44:  		/* bc 12, CR6_EQ, 8 */
		/* 820F8824h case   44:*/		if ( regs.CR[6].eq ) { return 0x820F882C;  }
		/* 820F8824h case   44:*/		return 0x820F8828;
		  /* 820F8828h */ case   45:  		/* lis R11, 15 */
		/* 820F8828h case   45:*/		cpu::op::lis<0>(regs,&regs.R11,0xF);
		/* 820F8828h case   45:*/		return 0x820F882C;
	}
	return 0x820F882C;
} // Block from 820F8774h-820F882Ch (46 instructions)

//////////////////////////////////////////////////////
// Block at 820F882Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F882C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F882C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F882C);
		  /* 820F882Ch */ case    0:  		/* stw R11, <#[R1 + 80]> */
		/* 820F882Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820F882Ch case    0:*/		return 0x820F8830;
		  /* 820F8830h */ case    1:  		/* addi R6, R1, 88 */
		/* 820F8830h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x58);
		/* 820F8830h case    1:*/		return 0x820F8834;
		  /* 820F8834h */ case    2:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F8834h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F8834h case    2:*/		return 0x820F8838;
		  /* 820F8838h */ case    3:  		/* addi R5, R1, 84 */
		/* 820F8838h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 820F8838h case    3:*/		return 0x820F883C;
		  /* 820F883Ch */ case    4:  		/* lwz R10, <#[R31]> */
		/* 820F883Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F883Ch case    4:*/		return 0x820F8840;
		  /* 820F8840h */ case    5:  		/* mr R3, R31 */
		/* 820F8840h case    5:*/		regs.R3 = regs.R31;
		/* 820F8840h case    5:*/		return 0x820F8844;
		  /* 820F8844h */ case    6:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F8844h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F8844h case    6:*/		return 0x820F8848;
		  /* 820F8848h */ case    7:  		/* lwz R11, <#[R11 + 8]> */
		/* 820F8848h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820F8848h case    7:*/		return 0x820F884C;
		  /* 820F884Ch */ case    8:  		/* lwz R11, <#[R11]> */
		/* 820F884Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F884Ch case    8:*/		return 0x820F8850;
		  /* 820F8850h */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F8850h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F8850h case    9:*/		return 0x820F8854;
		  /* 820F8854h */ case   10:  		/* lwz R10, <#[R10 + 328]> */
		/* 820F8854h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000148) );
		/* 820F8854h case   10:*/		return 0x820F8858;
		  /* 820F8858h */ case   11:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F8858h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F8858h case   11:*/		return 0x820F885C;
		  /* 820F885Ch */ case   12:  		/* mtspr CTR, R10 */
		/* 820F885Ch case   12:*/		regs.CTR = regs.R10;
		/* 820F885Ch case   12:*/		return 0x820F8860;
		  /* 820F8860h */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 820F8860h case   13:*/		if ( 1 ) { regs.LR = 0x820F8864; return (uint32)regs.CTR; }
		/* 820F8860h case   13:*/		return 0x820F8864;
		  /* 820F8864h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 820F8864h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8864h case   14:*/		return 0x820F8868;
		  /* 820F8868h */ case   15:  		/* bc 12, CR0_LT, 296 */
		/* 820F8868h case   15:*/		if ( regs.CR[0].lt ) { return 0x820F8990;  }
		/* 820F8868h case   15:*/		return 0x820F886C;
		  /* 820F886Ch */ case   16:  		/* lwz R11, <#[R31]> */
		/* 820F886Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F886Ch case   16:*/		return 0x820F8870;
		  /* 820F8870h */ case   17:  		/* addi R7, R1, 92 */
		/* 820F8870h case   17:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x5C);
		/* 820F8870h case   17:*/		return 0x820F8874;
		  /* 820F8874h */ case   18:  		/* lwz R10, <#[R31 + 260]> */
		/* 820F8874h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000104) );
		/* 820F8874h case   18:*/		return 0x820F8878;
		  /* 820F8878h */ case   19:  		/* mr R5, R29 */
		/* 820F8878h case   19:*/		regs.R5 = regs.R29;
		/* 820F8878h case   19:*/		return 0x820F887C;
		  /* 820F887Ch */ case   20:  		/* mr R3, R31 */
		/* 820F887Ch case   20:*/		regs.R3 = regs.R31;
		/* 820F887Ch case   20:*/		return 0x820F8880;
		  /* 820F8880h */ case   21:  		/* lwz R6, <#[R1 + 80]> */
		/* 820F8880h case   21:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 820F8880h case   21:*/		return 0x820F8884;
		  /* 820F8884h */ case   22:  		/* lwz R11, <#[R11 + 332]> */
		/* 820F8884h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000014C) );
		/* 820F8884h case   22:*/		return 0x820F8888;
		  /* 820F8888h */ case   23:  		/* lwz R4, <#[R10 + 8]> */
		/* 820F8888h case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000008) );
		/* 820F8888h case   23:*/		return 0x820F888C;
		  /* 820F888Ch */ case   24:  		/* mtspr CTR, R11 */
		/* 820F888Ch case   24:*/		regs.CTR = regs.R11;
		/* 820F888Ch case   24:*/		return 0x820F8890;
		  /* 820F8890h */ case   25:  		/* bcctrl 20, CR0_LT */
		/* 820F8890h case   25:*/		if ( 1 ) { regs.LR = 0x820F8894; return (uint32)regs.CTR; }
		/* 820F8890h case   25:*/		return 0x820F8894;
		  /* 820F8894h */ case   26:  		/* cmpwi CR0, R3, 0 */
		/* 820F8894h case   26:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8894h case   26:*/		return 0x820F8898;
		  /* 820F8898h */ case   27:  		/* bc 12, CR0_LT, 248 */
		/* 820F8898h case   27:*/		if ( regs.CR[0].lt ) { return 0x820F8990;  }
		/* 820F8898h case   27:*/		return 0x820F889C;
		  /* 820F889Ch */ case   28:  		/* lwz R11, <#[R31]> */
		/* 820F889Ch case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F889Ch case   28:*/		return 0x820F88A0;
		  /* 820F88A0h */ case   29:  		/* mr R3, R31 */
		/* 820F88A0h case   29:*/		regs.R3 = regs.R31;
		/* 820F88A0h case   29:*/		return 0x820F88A4;
		  /* 820F88A4h */ case   30:  		/* lwz R6, <#[R1 + 88]> */
		/* 820F88A4h case   30:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000058) );
		/* 820F88A4h case   30:*/		return 0x820F88A8;
		  /* 820F88A8h */ case   31:  		/* lwz R5, <#[R1 + 92]> */
		/* 820F88A8h case   31:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F88A8h case   31:*/		return 0x820F88AC;
		  /* 820F88ACh */ case   32:  		/* lwz R4, <#[R1 + 84]> */
		/* 820F88ACh case   32:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 820F88ACh case   32:*/		return 0x820F88B0;
		  /* 820F88B0h */ case   33:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F88B0h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F88B0h case   33:*/		return 0x820F88B4;
		  /* 820F88B4h */ case   34:  		/* mtspr CTR, R11 */
		/* 820F88B4h case   34:*/		regs.CTR = regs.R11;
		/* 820F88B4h case   34:*/		return 0x820F88B8;
		  /* 820F88B8h */ case   35:  		/* bcctrl 20, CR0_LT */
		/* 820F88B8h case   35:*/		if ( 1 ) { regs.LR = 0x820F88BC; return (uint32)regs.CTR; }
		/* 820F88B8h case   35:*/		return 0x820F88BC;
		  /* 820F88BCh */ case   36:  		/* cmpwi CR0, R3, 0 */
		/* 820F88BCh case   36:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F88BCh case   36:*/		return 0x820F88C0;
		  /* 820F88C0h */ case   37:  		/* bc 12, CR0_LT, 208 */
		/* 820F88C0h case   37:*/		if ( regs.CR[0].lt ) { return 0x820F8990;  }
		/* 820F88C0h case   37:*/		return 0x820F88C4;
		  /* 820F88C4h */ case   38:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F88C4h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F88C4h case   38:*/		return 0x820F88C8;
		  /* 820F88C8h */ case   39:  		/* rlwinm R30, R29, 2, 0, 29 */
		/* 820F88C8h case   39:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R29);
		/* 820F88C8h case   39:*/		return 0x820F88CC;
		  /* 820F88CCh */ case   40:  		/* lwz R10, <#[R31]> */
		/* 820F88CCh case   40:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F88CCh case   40:*/		return 0x820F88D0;
		  /* 820F88D0h */ case   41:  		/* addi R6, R1, 88 */
		/* 820F88D0h case   41:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x58);
		/* 820F88D0h case   41:*/		return 0x820F88D4;
		  /* 820F88D4h */ case   42:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F88D4h case   42:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F88D4h case   42:*/		return 0x820F88D8;
		  /* 820F88D8h */ case   43:  		/* addi R5, R1, 84 */
		/* 820F88D8h case   43:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 820F88D8h case   43:*/		return 0x820F88DC;
		  /* 820F88DCh */ case   44:  		/* mr R3, R31 */
		/* 820F88DCh case   44:*/		regs.R3 = regs.R31;
		/* 820F88DCh case   44:*/		return 0x820F88E0;
		  /* 820F88E0h */ case   45:  		/* lwz R11, <#[R11 + 8]> */
		/* 820F88E0h case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820F88E0h case   45:*/		return 0x820F88E4;
		  /* 820F88E4h */ case   46:  		/* lwz R10, <#[R10 + 328]> */
		/* 820F88E4h case   46:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000148) );
		/* 820F88E4h case   46:*/		return 0x820F88E8;
		  /* 820F88E8h */ case   47:  		/* lwzx R11, <#[R11 + R30]> */
		/* 820F88E8h case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820F88E8h case   47:*/		return 0x820F88EC;
		  /* 820F88ECh */ case   48:  		/* mtspr CTR, R10 */
		/* 820F88ECh case   48:*/		regs.CTR = regs.R10;
		/* 820F88ECh case   48:*/		return 0x820F88F0;
		  /* 820F88F0h */ case   49:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F88F0h case   49:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F88F0h case   49:*/		return 0x820F88F4;
		  /* 820F88F4h */ case   50:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F88F4h case   50:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F88F4h case   50:*/		return 0x820F88F8;
		  /* 820F88F8h */ case   51:  		/* bcctrl 20, CR0_LT */
		/* 820F88F8h case   51:*/		if ( 1 ) { regs.LR = 0x820F88FC; return (uint32)regs.CTR; }
		/* 820F88F8h case   51:*/		return 0x820F88FC;
		  /* 820F88FCh */ case   52:  		/* cmpwi CR0, R3, 0 */
		/* 820F88FCh case   52:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F88FCh case   52:*/		return 0x820F8900;
		  /* 820F8900h */ case   53:  		/* bc 12, CR0_LT, 144 */
		/* 820F8900h case   53:*/		if ( regs.CR[0].lt ) { return 0x820F8990;  }
		/* 820F8900h case   53:*/		return 0x820F8904;
		  /* 820F8904h */ case   54:  		/* lwz R11, <#[R31]> */
		/* 820F8904h case   54:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F8904h case   54:*/		return 0x820F8908;
		  /* 820F8908h */ case   55:  		/* addi R7, R1, 92 */
		/* 820F8908h case   55:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x5C);
		/* 820F8908h case   55:*/		return 0x820F890C;
		  /* 820F890Ch */ case   56:  		/* lwz R10, <#[R31 + 260]> */
		/* 820F890Ch case   56:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000104) );
		/* 820F890Ch case   56:*/		return 0x820F8910;
		  /* 820F8910h */ case   57:  		/* mr R5, R29 */
		/* 820F8910h case   57:*/		regs.R5 = regs.R29;
		/* 820F8910h case   57:*/		return 0x820F8914;
		  /* 820F8914h */ case   58:  		/* mr R3, R31 */
		/* 820F8914h case   58:*/		regs.R3 = regs.R31;
		/* 820F8914h case   58:*/		return 0x820F8918;
		  /* 820F8918h */ case   59:  		/* lwz R6, <#[R1 + 80]> */
		/* 820F8918h case   59:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 820F8918h case   59:*/		return 0x820F891C;
		  /* 820F891Ch */ case   60:  		/* lwz R9, <#[R11 + 332]> */
		/* 820F891Ch case   60:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000014C) );
		/* 820F891Ch case   60:*/		return 0x820F8920;
		  /* 820F8920h */ case   61:  		/* lwz R11, <#[R10 + 8]> */
		/* 820F8920h case   61:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 820F8920h case   61:*/		return 0x820F8924;
		  /* 820F8924h */ case   62:  		/* add R4, R11, R30 */
		/* 820F8924h case   62:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R30);
		/* 820F8924h case   62:*/		return 0x820F8928;
	}
	return 0x820F8928;
} // Block from 820F882Ch-820F8928h (63 instructions)

//////////////////////////////////////////////////////
// Block at 820F8928h
// Function '?EmitPOW@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8928);
		  /* 820F8928h */ case    0:  		/* mtspr CTR, R9 */
		/* 820F8928h case    0:*/		regs.CTR = regs.R9;
		/* 820F8928h case    0:*/		return 0x820F892C;
		  /* 820F892Ch */ case    1:  		/* bcctrl 20, CR0_LT */
		/* 820F892Ch case    1:*/		if ( 1 ) { regs.LR = 0x820F8930; return (uint32)regs.CTR; }
		/* 820F892Ch case    1:*/		return 0x820F8930;
		  /* 820F8930h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820F8930h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8930h case    2:*/		return 0x820F8934;
		  /* 820F8934h */ case    3:  		/* bc 12, CR0_LT, 92 */
		/* 820F8934h case    3:*/		if ( regs.CR[0].lt ) { return 0x820F8990;  }
		/* 820F8934h case    3:*/		return 0x820F8938;
		  /* 820F8938h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 820F8938h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F8938h case    4:*/		return 0x820F893C;
		  /* 820F893Ch */ case    5:  		/* mr R3, R31 */
		/* 820F893Ch case    5:*/		regs.R3 = regs.R31;
		/* 820F893Ch case    5:*/		return 0x820F8940;
		  /* 820F8940h */ case    6:  		/* lwz R6, <#[R1 + 88]> */
		/* 820F8940h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000058) );
		/* 820F8940h case    6:*/		return 0x820F8944;
		  /* 820F8944h */ case    7:  		/* lwz R5, <#[R1 + 92]> */
		/* 820F8944h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F8944h case    7:*/		return 0x820F8948;
		  /* 820F8948h */ case    8:  		/* lwz R4, <#[R1 + 84]> */
		/* 820F8948h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 820F8948h case    8:*/		return 0x820F894C;
		  /* 820F894Ch */ case    9:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F894Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F894Ch case    9:*/		return 0x820F8950;
		  /* 820F8950h */ case   10:  		/* mtspr CTR, R11 */
		/* 820F8950h case   10:*/		regs.CTR = regs.R11;
		/* 820F8950h case   10:*/		return 0x820F8954;
		  /* 820F8954h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 820F8954h case   11:*/		if ( 1 ) { regs.LR = 0x820F8958; return (uint32)regs.CTR; }
		/* 820F8954h case   11:*/		return 0x820F8958;
		  /* 820F8958h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820F8958h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8958h case   12:*/		return 0x820F895C;
		  /* 820F895Ch */ case   13:  		/* bc 12, CR0_LT, 52 */
		/* 820F895Ch case   13:*/		if ( regs.CR[0].lt ) { return 0x820F8990;  }
		/* 820F895Ch case   13:*/		return 0x820F8960;
		  /* 820F8960h */ case   14:  		/* lwz R11, <#[R31]> */
		/* 820F8960h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F8960h case   14:*/		return 0x820F8964;
		  /* 820F8964h */ case   15:  		/* mr R3, R31 */
		/* 820F8964h case   15:*/		regs.R3 = regs.R31;
		/* 820F8964h case   15:*/		return 0x820F8968;
		  /* 820F8968h */ case   16:  		/* lwz R11, <#[R11 + 308]> */
		/* 820F8968h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000134) );
		/* 820F8968h case   16:*/		return 0x820F896C;
		  /* 820F896Ch */ case   17:  		/* mtspr CTR, R11 */
		/* 820F896Ch case   17:*/		regs.CTR = regs.R11;
		/* 820F896Ch case   17:*/		return 0x820F8970;
		  /* 820F8970h */ case   18:  		/* bcctrl 20, CR0_LT */
		/* 820F8970h case   18:*/		if ( 1 ) { regs.LR = 0x820F8974; return (uint32)regs.CTR; }
		/* 820F8970h case   18:*/		return 0x820F8974;
		  /* 820F8974h */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 820F8974h case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8974h case   19:*/		return 0x820F8978;
		  /* 820F8978h */ case   20:  		/* bc 12, CR0_LT, 24 */
		/* 820F8978h case   20:*/		if ( regs.CR[0].lt ) { return 0x820F8990;  }
		/* 820F8978h case   20:*/		return 0x820F897C;
		  /* 820F897Ch */ case   21:  		/* mr R3, R31 */
		/* 820F897Ch case   21:*/		regs.R3 = regs.R31;
		/* 820F897Ch case   21:*/		return 0x820F8980;
		  /* 820F8980h */ case   22:  		/* bl -45176 */
		/* 820F8980h case   22:*/		regs.LR = 0x820F8984; return 0x820ED908;
		/* 820F8980h case   22:*/		return 0x820F8984;
		  /* 820F8984h */ case   23:  		/* cmpwi CR0, R3, 0 */
		/* 820F8984h case   23:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8984h case   23:*/		return 0x820F8988;
		  /* 820F8988h */ case   24:  		/* bc 12, CR0_LT, 8 */
		/* 820F8988h case   24:*/		if ( regs.CR[0].lt ) { return 0x820F8990;  }
		/* 820F8988h case   24:*/		return 0x820F898C;
		  /* 820F898Ch */ case   25:  		/* li R3, 0 */
		/* 820F898Ch case   25:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F898Ch case   25:*/		return 0x820F8990;
	}
	return 0x820F8990;
} // Block from 820F8928h-820F8990h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820F8990h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8990);
		  /* 820F8990h */ case    0:  		/* addi R1, R1, 144 */
		/* 820F8990h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820F8990h case    0:*/		return 0x820F8994;
		  /* 820F8994h */ case    1:  		/* b -423656 */
		/* 820F8994h case    1:*/		return 0x820912AC;
		/* 820F8994h case    1:*/		return 0x820F8998;
	}
	return 0x820F8998;
} // Block from 820F8990h-820F8998h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F8998h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8998);
		  /* 820F8998h */ case    0:  		/* mfspr R12, LR */
		/* 820F8998h case    0:*/		regs.R12 = regs.LR;
		/* 820F8998h case    0:*/		return 0x820F899C;
		  /* 820F899Ch */ case    1:  		/* bl -423756 */
		/* 820F899Ch case    1:*/		regs.LR = 0x820F89A0; return 0x82091250;
		/* 820F899Ch case    1:*/		return 0x820F89A0;
		  /* 820F89A0h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 820F89A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 820F89A0h case    2:*/		return 0x820F89A4;
		  /* 820F89A4h */ case    3:  		/* mr R31, R3 */
		/* 820F89A4h case    3:*/		regs.R31 = regs.R3;
		/* 820F89A4h case    3:*/		return 0x820F89A8;
		  /* 820F89A8h */ case    4:  		/* lwz R3, <#[R3 + 260]> */
		/* 820F89A8h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000104) );
		/* 820F89A8h case    4:*/		return 0x820F89AC;
		  /* 820F89ACh */ case    5:  		/* mr R29, R4 */
		/* 820F89ACh case    5:*/		regs.R29 = regs.R4;
		/* 820F89ACh case    5:*/		return 0x820F89B0;
		  /* 820F89B0h */ case    6:  		/* mr R26, R5 */
		/* 820F89B0h case    6:*/		regs.R26 = regs.R5;
		/* 820F89B0h case    6:*/		return 0x820F89B4;
		  /* 820F89B4h */ case    7:  		/* addi R5, R1, 112 */
		/* 820F89B4h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820F89B4h case    7:*/		return 0x820F89B8;
		  /* 820F89B8h */ case    8:  		/* li R4, 0 */
		/* 820F89B8h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F89B8h case    8:*/		return 0x820F89BC;
		  /* 820F89BCh */ case    9:  		/* lwz R11, <#[R3]> */
		/* 820F89BCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F89BCh case    9:*/		return 0x820F89C0;
	}
	return 0x820F89C0;
} // Block from 820F8998h-820F89C0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F89C0h
// Function '?EmitLRP@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F89C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F89C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F89C0);
		  /* 820F89C0h */ case    0:  		/* lwz R28, <#[R3 + 12]> */
		/* 820F89C0h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R3 + 0x0000000C) );
		/* 820F89C0h case    0:*/		return 0x820F89C4;
		  /* 820F89C4h */ case    1:  		/* lwz R27, <#[R3 + 16]> */
		/* 820F89C4h case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R3 + 0x00000010) );
		/* 820F89C4h case    1:*/		return 0x820F89C8;
		  /* 820F89C8h */ case    2:  		/* rlwinm R30, R11, 0, 12, 31 */
		/* 820F89C8h case    2:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R30,regs.R11);
		/* 820F89C8h case    2:*/		return 0x820F89CC;
		  /* 820F89CCh */ case    3:  		/* bl 13644 */
		/* 820F89CCh case    3:*/		regs.LR = 0x820F89D0; return 0x820FBF18;
		/* 820F89CCh case    3:*/		return 0x820F89D0;
		  /* 820F89D0h */ case    4:  		/* addi R5, R1, 116 */
		/* 820F89D0h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x74);
		/* 820F89D0h case    4:*/		return 0x820F89D4;
		  /* 820F89D4h */ case    5:  		/* li R4, 1 */
		/* 820F89D4h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820F89D4h case    5:*/		return 0x820F89D8;
		  /* 820F89D8h */ case    6:  		/* lwz R3, <#[R31 + 260]> */
		/* 820F89D8h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000104) );
		/* 820F89D8h case    6:*/		return 0x820F89DC;
		  /* 820F89DCh */ case    7:  		/* bl 13628 */
		/* 820F89DCh case    7:*/		regs.LR = 0x820F89E0; return 0x820FBF18;
		/* 820F89DCh case    7:*/		return 0x820F89E0;
		  /* 820F89E0h */ case    8:  		/* addi R5, R1, 120 */
		/* 820F89E0h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x78);
		/* 820F89E0h case    8:*/		return 0x820F89E4;
		  /* 820F89E4h */ case    9:  		/* li R4, 2 */
		/* 820F89E4h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 820F89E4h case    9:*/		return 0x820F89E8;
		  /* 820F89E8h */ case   10:  		/* lwz R3, <#[R31 + 260]> */
		/* 820F89E8h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000104) );
		/* 820F89E8h case   10:*/		return 0x820F89EC;
		  /* 820F89ECh */ case   11:  		/* bl 13612 */
		/* 820F89ECh case   11:*/		regs.LR = 0x820F89F0; return 0x820FBF18;
		/* 820F89ECh case   11:*/		return 0x820F89F0;
		  /* 820F89F0h */ case   12:  		/* li R3, 0 */
		/* 820F89F0h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F89F0h case   12:*/		return 0x820F89F4;
		  /* 820F89F4h */ case   13:  		/* cmpwi CR6, R26, 0 */
		/* 820F89F4h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 820F89F4h case   13:*/		return 0x820F89F8;
		  /* 820F89F8h */ case   14:  		/* mr R6, R3 */
		/* 820F89F8h case   14:*/		regs.R6 = regs.R3;
		/* 820F89F8h case   14:*/		return 0x820F89FC;
		  /* 820F89FCh */ case   15:  		/* bc 12, CR6_EQ, 124 */
		/* 820F89FCh case   15:*/		if ( regs.CR[6].eq ) { return 0x820F8A78;  }
		/* 820F89FCh case   15:*/		return 0x820F8A00;
		  /* 820F8A00h */ case   16:  		/* mr R4, R3 */
		/* 820F8A00h case   16:*/		regs.R4 = regs.R3;
		/* 820F8A00h case   16:*/		return 0x820F8A04;
		  /* 820F8A04h */ case   17:  		/* addi R5, R1, 112 */
		/* 820F8A04h case   17:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820F8A04h case   17:*/		return 0x820F8A08;
		  /* 820F8A08h */ case   18:  		/* cmpwi CR6, R6, 0 */
		/* 820F8A08h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 820F8A08h case   18:*/		return 0x820F8A0C;
		  /* 820F8A0Ch */ case   19:  		/* bc 4, CR6_EQ, 108 */
		/* 820F8A0Ch case   19:*/		if ( !regs.CR[6].eq ) { return 0x820F8A78;  }
		/* 820F8A0Ch case   19:*/		return 0x820F8A10;
		  /* 820F8A10h */ case   20:  		/* lwz R7, <#[R5]> */
		/* 820F8A10h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R5 + 0x00000000) );
		/* 820F8A10h case   20:*/		return 0x820F8A14;
		  /* 820F8A14h */ case   21:  		/* cmplwi CR6, R7, 0 */
		/* 820F8A14h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820F8A14h case   21:*/		return 0x820F8A18;
		  /* 820F8A18h */ case   22:  		/* bc 12, CR6_EQ, 80 */
		/* 820F8A18h case   22:*/		if ( regs.CR[6].eq ) { return 0x820F8A68;  }
		/* 820F8A18h case   22:*/		return 0x820F8A1C;
		  /* 820F8A1Ch */ case   23:  		/* mr R9, R3 */
		/* 820F8A1Ch case   23:*/		regs.R9 = regs.R3;
		/* 820F8A1Ch case   23:*/		return 0x820F8A20;
		  /* 820F8A20h */ case   24:  		/* cmplwi CR6, R30, 0 */
		/* 820F8A20h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820F8A20h case   24:*/		return 0x820F8A24;
		  /* 820F8A24h */ case   25:  		/* bc 12, CR6_EQ, 68 */
		/* 820F8A24h case   25:*/		if ( regs.CR[6].eq ) { return 0x820F8A68;  }
		/* 820F8A24h case   25:*/		return 0x820F8A28;
		  /* 820F8A28h */ case   26:  		/* lwz R8, <#[R31 + 20]> */
		/* 820F8A28h case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000014) );
		/* 820F8A28h case   26:*/		return 0x820F8A2C;
		  /* 820F8A2Ch */ case   27:  		/* mr R10, R3 */
		/* 820F8A2Ch case   27:*/		regs.R10 = regs.R3;
		/* 820F8A2Ch case   27:*/		return 0x820F8A30;
		  /* 820F8A30h */ case   28:  		/* mr R11, R3 */
		/* 820F8A30h case   28:*/		regs.R11 = regs.R3;
		/* 820F8A30h case   28:*/		return 0x820F8A34;
		  /* 820F8A34h */ case   29:  		/* lwzx R26, <#[R7 + R11]> */
		/* 820F8A34h case   29:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 820F8A34h case   29:*/		return 0x820F8A38;
		  /* 820F8A38h */ case   30:  		/* rlwinm R26, R26, 2, 0, 29 */
		/* 820F8A38h case   30:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R26,regs.R26);
		/* 820F8A38h case   30:*/		return 0x820F8A3C;
		  /* 820F8A3Ch */ case   31:  		/* lwzx R26, <#[R26 + R8]> */
		/* 820F8A3Ch case   31:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R26 + regs.R8 + 0x00000000) );
		/* 820F8A3Ch case   31:*/		return 0x820F8A40;
		  /* 820F8A40h */ case   32:  		/* lwzx R26, <#[R26 + R10]> */
		/* 820F8A40h case   32:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R26 + regs.R10 + 0x00000000) );
		/* 820F8A40h case   32:*/		return 0x820F8A44;
		  /* 820F8A44h */ case   33:  		/* rlwinm. R26, R26, 0, 7, 7 */
		/* 820F8A44h case   33:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R26,regs.R26);
		/* 820F8A44h case   33:*/		return 0x820F8A48;
		  /* 820F8A48h */ case   34:  		/* bc 4, CR0_EQ, 28 */
		/* 820F8A48h case   34:*/		if ( !regs.CR[0].eq ) { return 0x820F8A64;  }
		/* 820F8A48h case   34:*/		return 0x820F8A4C;
		  /* 820F8A4Ch */ case   35:  		/* addi R9, R9, 1 */
		/* 820F8A4Ch case   35:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820F8A4Ch case   35:*/		return 0x820F8A50;
		  /* 820F8A50h */ case   36:  		/* addi R11, R11, 4 */
		/* 820F8A50h case   36:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F8A50h case   36:*/		return 0x820F8A54;
		  /* 820F8A54h */ case   37:  		/* addi R10, R10, 128 */
		/* 820F8A54h case   37:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x80);
		/* 820F8A54h case   37:*/		return 0x820F8A58;
		  /* 820F8A58h */ case   38:  		/* cmplw CR6, R9, R30 */
		/* 820F8A58h case   38:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R30);
		/* 820F8A58h case   38:*/		return 0x820F8A5C;
		  /* 820F8A5Ch */ case   39:  		/* bc 12, CR6_LT, -40 */
		/* 820F8A5Ch case   39:*/		if ( regs.CR[6].lt ) { return 0x820F8A34;  }
		/* 820F8A5Ch case   39:*/		return 0x820F8A60;
		  /* 820F8A60h */ case   40:  		/* b 8 */
		/* 820F8A60h case   40:*/		return 0x820F8A68;
		/* 820F8A60h case   40:*/		return 0x820F8A64;
	}
	return 0x820F8A64;
} // Block from 820F89C0h-820F8A64h (41 instructions)

//////////////////////////////////////////////////////
// Block at 820F8A64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8A64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8A64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8A64);
		  /* 820F8A64h */ case    0:  		/* li R6, 1 */
		/* 820F8A64h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820F8A64h case    0:*/		return 0x820F8A68;
	}
	return 0x820F8A68;
} // Block from 820F8A64h-820F8A68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F8A68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8A68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8A68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8A68);
		  /* 820F8A68h */ case    0:  		/* addi R4, R4, 1 */
		/* 820F8A68h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820F8A68h case    0:*/		return 0x820F8A6C;
		  /* 820F8A6Ch */ case    1:  		/* addi R5, R5, 4 */
		/* 820F8A6Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 820F8A6Ch case    1:*/		return 0x820F8A70;
		  /* 820F8A70h */ case    2:  		/* cmplwi CR6, R4, 3 */
		/* 820F8A70h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000003);
		/* 820F8A70h case    2:*/		return 0x820F8A74;
		  /* 820F8A74h */ case    3:  		/* bc 12, CR6_LT, -108 */
		/* 820F8A74h case    3:*/		if ( regs.CR[6].lt ) { return 0x820F8A08;  }
		/* 820F8A74h case    3:*/		return 0x820F8A78;
	}
	return 0x820F8A78;
} // Block from 820F8A68h-820F8A78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F8A78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8A78);
		  /* 820F8A78h */ case    0:  		/* stw R6, <#[R1 + 108]> */
		/* 820F8A78h case    0:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x0000006C) );
		/* 820F8A78h case    0:*/		return 0x820F8A7C;
		  /* 820F8A7Ch */ case    1:  		/* mr R10, R30 */
		/* 820F8A7Ch case    1:*/		regs.R10 = regs.R30;
		/* 820F8A7Ch case    1:*/		return 0x820F8A80;
		  /* 820F8A80h */ case    2:  		/* stw R3, <#[R1 + 100]> */
		/* 820F8A80h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000064) );
		/* 820F8A80h case    2:*/		return 0x820F8A84;
		  /* 820F8A84h */ case    3:  		/* mr R6, R28 */
		/* 820F8A84h case    3:*/		regs.R6 = regs.R28;
		/* 820F8A84h case    3:*/		return 0x820F8A88;
		  /* 820F8A88h */ case    4:  		/* stw R3, <#[R1 + 92]> */
		/* 820F8A88h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F8A88h case    4:*/		return 0x820F8A8C;
		  /* 820F8A8Ch */ case    5:  		/* mr R5, R27 */
		/* 820F8A8Ch case    5:*/		regs.R5 = regs.R27;
		/* 820F8A8Ch case    5:*/		return 0x820F8A90;
		  /* 820F8A90h */ case    6:  		/* stw R3, <#[R1 + 84]> */
		/* 820F8A90h case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 820F8A90h case    6:*/		return 0x820F8A94;
		  /* 820F8A94h */ case    7:  		/* mr R4, R29 */
		/* 820F8A94h case    7:*/		regs.R4 = regs.R29;
		/* 820F8A94h case    7:*/		return 0x820F8A98;
		  /* 820F8A98h */ case    8:  		/* mr R3, R31 */
		/* 820F8A98h case    8:*/		regs.R3 = regs.R31;
		/* 820F8A98h case    8:*/		return 0x820F8A9C;
		  /* 820F8A9Ch */ case    9:  		/* lwz R9, <#[R1 + 120]> */
		/* 820F8A9Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000078) );
		/* 820F8A9Ch case    9:*/		return 0x820F8AA0;
		  /* 820F8AA0h */ case   10:  		/* lwz R8, <#[R1 + 116]> */
		/* 820F8AA0h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000074) );
		/* 820F8AA0h case   10:*/		return 0x820F8AA4;
		  /* 820F8AA4h */ case   11:  		/* lwz R7, <#[R1 + 112]> */
		/* 820F8AA4h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000070) );
		/* 820F8AA4h case   11:*/		return 0x820F8AA8;
		  /* 820F8AA8h */ case   12:  		/* bl -10056 */
		/* 820F8AA8h case   12:*/		regs.LR = 0x820F8AAC; return 0x820F6360;
		/* 820F8AA8h case   12:*/		return 0x820F8AAC;
		  /* 820F8AACh */ case   13:  		/* addi R1, R1, 192 */
		/* 820F8AACh case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 820F8AACh case   13:*/		return 0x820F8AB0;
		  /* 820F8AB0h */ case   14:  		/* b -423952 */
		/* 820F8AB0h case   14:*/		return 0x820912A0;
		/* 820F8AB0h case   14:*/		return 0x820F8AB4;
		  /* 820F8AB4h */ case   15:  		/* nop */
		/* 820F8AB4h case   15:*/		cpu::op::nop();
		/* 820F8AB4h case   15:*/		return 0x820F8AB8;
	}
	return 0x820F8AB8;
} // Block from 820F8A78h-820F8AB8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820F8AB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8AB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8AB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8AB8);
		  /* 820F8AB8h */ case    0:  		/* mfspr R12, LR */
		/* 820F8AB8h case    0:*/		regs.R12 = regs.LR;
		/* 820F8AB8h case    0:*/		return 0x820F8ABC;
		  /* 820F8ABCh */ case    1:  		/* bl -424064 */
		/* 820F8ABCh case    1:*/		regs.LR = 0x820F8AC0; return 0x8209123C;
		/* 820F8ABCh case    1:*/		return 0x820F8AC0;
		  /* 820F8AC0h */ case    2:  		/* stwu R1, <#[R1 - 240]> */
		/* 820F8AC0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 820F8AC0h case    2:*/		return 0x820F8AC4;
		  /* 820F8AC4h */ case    3:  		/* mr R29, R3 */
		/* 820F8AC4h case    3:*/		regs.R29 = regs.R3;
		/* 820F8AC4h case    3:*/		return 0x820F8AC8;
		  /* 820F8AC8h */ case    4:  		/* mr R21, R4 */
		/* 820F8AC8h case    4:*/		regs.R21 = regs.R4;
		/* 820F8AC8h case    4:*/		return 0x820F8ACC;
		  /* 820F8ACCh */ case    5:  		/* mr R26, R5 */
		/* 820F8ACCh case    5:*/		regs.R26 = regs.R5;
		/* 820F8ACCh case    5:*/		return 0x820F8AD0;
		  /* 820F8AD0h */ case    6:  		/* mr R24, R6 */
		/* 820F8AD0h case    6:*/		regs.R24 = regs.R6;
		/* 820F8AD0h case    6:*/		return 0x820F8AD4;
		  /* 820F8AD4h */ case    7:  		/* mr R28, R7 */
		/* 820F8AD4h case    7:*/		regs.R28 = regs.R7;
		/* 820F8AD4h case    7:*/		return 0x820F8AD8;
		  /* 820F8AD8h */ case    8:  		/* mr R22, R9 */
		/* 820F8AD8h case    8:*/		regs.R22 = regs.R9;
		/* 820F8AD8h case    8:*/		return 0x820F8ADC;
		  /* 820F8ADCh */ case    9:  		/* cmplw CR6, R7, R8 */
		/* 820F8ADCh case    9:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 820F8ADCh case    9:*/		return 0x820F8AE0;
		  /* 820F8AE0h */ case   10:  		/* bc 4, CR6_GT, 48 */
		/* 820F8AE0h case   10:*/		if ( !regs.CR[6].gt ) { return 0x820F8B10;  }
		/* 820F8AE0h case   10:*/		return 0x820F8AE4;
		  /* 820F8AE4h */ case   11:  		/* cmplwi CR6, R8, 1 */
		/* 820F8AE4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000001);
		/* 820F8AE4h case   11:*/		return 0x820F8AE8;
		  /* 820F8AE8h */ case   12:  		/* bc 4, CR6_EQ, 40 */
		/* 820F8AE8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820F8B10;  }
		/* 820F8AE8h case   12:*/		return 0x820F8AEC;
		  /* 820F8AECh */ case   13:  		/* lwz R11, <#[R3 + 260]> */
		/* 820F8AECh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000104) );
		/* 820F8AECh case   13:*/		return 0x820F8AF0;
		  /* 820F8AF0h */ case   14:  		/* lwz R10, <#[R6]> */
		/* 820F8AF0h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000000) );
		/* 820F8AF0h case   14:*/		return 0x820F8AF4;
		  /* 820F8AF4h */ case   15:  		/* lwz R11, <#[R11 + 8]> */
		/* 820F8AF4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820F8AF4h case   15:*/		return 0x820F8AF8;
		  /* 820F8AF8h */ case   16:  		/* lwz R11, <#[R11]> */
		/* 820F8AF8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F8AF8h case   16:*/		return 0x820F8AFC;
		  /* 820F8AFCh */ case   17:  		/* cmplw CR6, R11, R10 */
		/* 820F8AFCh case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F8AFCh case   17:*/		return 0x820F8B00;
		  /* 820F8B00h */ case   18:  		/* bc 4, CR6_EQ, 16 */
		/* 820F8B00h case   18:*/		if ( !regs.CR[6].eq ) { return 0x820F8B10;  }
		/* 820F8B00h case   18:*/		return 0x820F8B04;
		  /* 820F8B04h */ case   19:  		/* li R5, 0 */
		/* 820F8B04h case   19:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F8B04h case   19:*/		return 0x820F8B08;
		  /* 820F8B08h */ case   20:  		/* bl -368 */
		/* 820F8B08h case   20:*/		regs.LR = 0x820F8B0C; return 0x820F8998;
		/* 820F8B08h case   20:*/		return 0x820F8B0C;
		  /* 820F8B0Ch */ case   21:  		/* b 692 */
		/* 820F8B0Ch case   21:*/		return 0x820F8DC0;
		/* 820F8B0Ch case   21:*/		return 0x820F8B10;
	}
	return 0x820F8B10;
} // Block from 820F8AB8h-820F8B10h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820F8B10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8B10);
		  /* 820F8B10h */ case    0:  		/* lwz R11, <#[R26]> */
		/* 820F8B10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820F8B10h case    0:*/		return 0x820F8B14;
		  /* 820F8B14h */ case    1:  		/* lwz R10, <#[R24]> */
		/* 820F8B14h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000000) );
		/* 820F8B14h case    1:*/		return 0x820F8B18;
		  /* 820F8B18h */ case    2:  		/* lwz R9, <#[R29 + 20]> */
		/* 820F8B18h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000014) );
		/* 820F8B18h case    2:*/		return 0x820F8B1C;
		  /* 820F8B1Ch */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F8B1Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F8B1Ch case    3:*/		return 0x820F8B20;
		  /* 820F8B20h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F8B20h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F8B20h case    4:*/		return 0x820F8B24;
		  /* 820F8B24h */ case    5:  		/* lwzx R8, <#[R9 + R11]> */
		/* 820F8B24h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820F8B24h case    5:*/		return 0x820F8B28;
		  /* 820F8B28h */ case    6:  		/* lwzx R9, <#[R10 + R9]> */
		/* 820F8B28h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820F8B28h case    6:*/		return 0x820F8B2C;
		  /* 820F8B2Ch */ case    7:  		/* lwz R8, <#[R8 + 4]> */
		/* 820F8B2Ch case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 820F8B2Ch case    7:*/		return 0x820F8B30;
		  /* 820F8B30h */ case    8:  		/* lwz R9, <#[R9 + 4]> */
		/* 820F8B30h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 820F8B30h case    8:*/		return 0x820F8B34;
		  /* 820F8B34h */ case    9:  		/* cmplw CR6, R8, R9 */
		/* 820F8B34h case    9:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 820F8B34h case    9:*/		return 0x820F8B38;
		  /* 820F8B38h */ case   10:  		/* bc 4, CR6_EQ, 60 */
		/* 820F8B38h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820F8B74;  }
		/* 820F8B38h case   10:*/		return 0x820F8B3C;
		  /* 820F8B3Ch */ case   11:  		/* lwz R9, <#[R29 + 20]> */
		/* 820F8B3Ch case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000014) );
		/* 820F8B3Ch case   11:*/		return 0x820F8B40;
		  /* 820F8B40h */ case   12:  		/* lwzx R8, <#[R9 + R10]> */
		/* 820F8B40h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820F8B40h case   12:*/		return 0x820F8B44;
		  /* 820F8B44h */ case   13:  		/* lwzx R9, <#[R9 + R11]> */
		/* 820F8B44h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820F8B44h case   13:*/		return 0x820F8B48;
		  /* 820F8B48h */ case   14:  		/* lwz R8, <#[R8 + 8]> */
		/* 820F8B48h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000008) );
		/* 820F8B48h case   14:*/		return 0x820F8B4C;
		  /* 820F8B4Ch */ case   15:  		/* lwz R9, <#[R9 + 8]> */
		/* 820F8B4Ch case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 820F8B4Ch case   15:*/		return 0x820F8B50;
		  /* 820F8B50h */ case   16:  		/* cmplw CR6, R9, R8 */
		/* 820F8B50h case   16:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820F8B50h case   16:*/		return 0x820F8B54;
		  /* 820F8B54h */ case   17:  		/* bc 4, CR6_EQ, 32 */
		/* 820F8B54h case   17:*/		if ( !regs.CR[6].eq ) { return 0x820F8B74;  }
		/* 820F8B54h case   17:*/		return 0x820F8B58;
		  /* 820F8B58h */ case   18:  		/* lwz R9, <#[R29 + 20]> */
		/* 820F8B58h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000014) );
		/* 820F8B58h case   18:*/		return 0x820F8B5C;
		  /* 820F8B5Ch */ case   19:  		/* lwzx R10, <#[R9 + R10]> */
		/* 820F8B5Ch case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820F8B5Ch case   19:*/		return 0x820F8B60;
		  /* 820F8B60h */ case   20:  		/* lwzx R11, <#[R9 + R11]> */
		/* 820F8B60h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820F8B60h case   20:*/		return 0x820F8B64;
		  /* 820F8B64h */ case   21:  		/* lwz R10, <#[R10 + 12]> */
		/* 820F8B64h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 820F8B64h case   21:*/		return 0x820F8B68;
		  /* 820F8B68h */ case   22:  		/* lwz R11, <#[R11 + 12]> */
		/* 820F8B68h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F8B68h case   22:*/		return 0x820F8B6C;
		  /* 820F8B6Ch */ case   23:  		/* cmplw CR6, R11, R10 */
		/* 820F8B6Ch case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F8B6Ch case   23:*/		return 0x820F8B70;
		  /* 820F8B70h */ case   24:  		/* bc 12, CR6_EQ, 16 */
		/* 820F8B70h case   24:*/		if ( regs.CR[6].eq ) { return 0x820F8B80;  }
		/* 820F8B70h case   24:*/		return 0x820F8B74;
	}
	return 0x820F8B74;
} // Block from 820F8B10h-820F8B74h (25 instructions)

//////////////////////////////////////////////////////
// Block at 820F8B74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8B74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8B74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8B74);
		  /* 820F8B74h */ case    0:  		/* li R25, 0 */
		/* 820F8B74h case    0:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 820F8B74h case    0:*/		return 0x820F8B78;
		  /* 820F8B78h */ case    1:  		/* mr R23, R25 */
		/* 820F8B78h case    1:*/		regs.R23 = regs.R25;
		/* 820F8B78h case    1:*/		return 0x820F8B7C;
		  /* 820F8B7Ch */ case    2:  		/* b 136 */
		/* 820F8B7Ch case    2:*/		return 0x820F8C04;
		/* 820F8B7Ch case    2:*/		return 0x820F8B80;
	}
	return 0x820F8B80;
} // Block from 820F8B74h-820F8B80h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F8B80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8B80);
		  /* 820F8B80h */ case    0:  		/* li R25, 0 */
		/* 820F8B80h case    0:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 820F8B80h case    0:*/		return 0x820F8B84;
		  /* 820F8B84h */ case    1:  		/* cmplwi CR6, R28, 0 */
		/* 820F8B84h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820F8B84h case    1:*/		return 0x820F8B88;
	}
	return 0x820F8B88;
} // Block from 820F8B80h-820F8B88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F8B88h
// Function '?EmitNRM@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8B88);
		  /* 820F8B88h */ case    0:  		/* mr R10, R25 */
		/* 820F8B88h case    0:*/		regs.R10 = regs.R25;
		/* 820F8B88h case    0:*/		return 0x820F8B8C;
		  /* 820F8B8Ch */ case    1:  		/* bc 12, CR6_EQ, 108 */
		/* 820F8B8Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820F8BF8;  }
		/* 820F8B8Ch case    1:*/		return 0x820F8B90;
		  /* 820F8B90h */ case    2:  		/* mr R6, R24 */
		/* 820F8B90h case    2:*/		regs.R6 = regs.R24;
		/* 820F8B90h case    2:*/		return 0x820F8B94;
		  /* 820F8B94h */ case    3:  		/* mr R7, R25 */
		/* 820F8B94h case    3:*/		regs.R7 = regs.R25;
		/* 820F8B94h case    3:*/		return 0x820F8B98;
		  /* 820F8B98h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 820F8B98h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F8B98h case    4:*/		return 0x820F8B9C;
		  /* 820F8B9Ch */ case    5:  		/* bc 12, CR6_EQ, 76 */
		/* 820F8B9Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820F8BE8;  }
		/* 820F8B9Ch case    5:*/		return 0x820F8BA0;
		  /* 820F8BA0h */ case    6:  		/* lwz R8, <#[R6]> */
		/* 820F8BA0h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + 0x00000000) );
		/* 820F8BA0h case    6:*/		return 0x820F8BA4;
		  /* 820F8BA4h */ case    7:  		/* mr R11, R26 */
		/* 820F8BA4h case    7:*/		regs.R11 = regs.R26;
		/* 820F8BA4h case    7:*/		return 0x820F8BA8;
		  /* 820F8BA8h */ case    8:  		/* lwz R9, <#[R29 + 20]> */
		/* 820F8BA8h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000014) );
		/* 820F8BA8h case    8:*/		return 0x820F8BAC;
		  /* 820F8BACh */ case    9:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820F8BACh case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820F8BACh case    9:*/		return 0x820F8BB0;
		  /* 820F8BB0h */ case   10:  		/* lwzx R8, <#[R8 + R9]> */
		/* 820F8BB0h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 820F8BB0h case   10:*/		return 0x820F8BB4;
		  /* 820F8BB4h */ case   11:  		/* lwz R8, <#[R8 + 16]> */
		/* 820F8BB4h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000010) );
		/* 820F8BB4h case   11:*/		return 0x820F8BB8;
		  /* 820F8BB8h */ case   12:  		/* lwz R5, <#[R11]> */
		/* 820F8BB8h case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000000) );
		/* 820F8BB8h case   12:*/		return 0x820F8BBC;
		  /* 820F8BBCh */ case   13:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 820F8BBCh case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 820F8BBCh case   13:*/		return 0x820F8BC0;
		  /* 820F8BC0h */ case   14:  		/* lwzx R5, <#[R5 + R9]> */
		/* 820F8BC0h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R9 + 0x00000000) );
		/* 820F8BC0h case   14:*/		return 0x820F8BC4;
		  /* 820F8BC4h */ case   15:  		/* lwz R5, <#[R5 + 16]> */
		/* 820F8BC4h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000010) );
		/* 820F8BC4h case   15:*/		return 0x820F8BC8;
		  /* 820F8BC8h */ case   16:  		/* cmplw CR6, R8, R5 */
		/* 820F8BC8h case   16:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R5);
		/* 820F8BC8h case   16:*/		return 0x820F8BCC;
		  /* 820F8BCCh */ case   17:  		/* bc 12, CR6_EQ, 20 */
		/* 820F8BCCh case   17:*/		if ( regs.CR[6].eq ) { return 0x820F8BE0;  }
		/* 820F8BCCh case   17:*/		return 0x820F8BD0;
		  /* 820F8BD0h */ case   18:  		/* addi R7, R7, 1 */
		/* 820F8BD0h case   18:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820F8BD0h case   18:*/		return 0x820F8BD4;
		  /* 820F8BD4h */ case   19:  		/* addi R11, R11, 4 */
		/* 820F8BD4h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F8BD4h case   19:*/		return 0x820F8BD8;
		  /* 820F8BD8h */ case   20:  		/* cmplw CR6, R7, R10 */
		/* 820F8BD8h case   20:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 820F8BD8h case   20:*/		return 0x820F8BDC;
		  /* 820F8BDCh */ case   21:  		/* bc 12, CR6_LT, -36 */
		/* 820F8BDCh case   21:*/		if ( regs.CR[6].lt ) { return 0x820F8BB8;  }
		/* 820F8BDCh case   21:*/		return 0x820F8BE0;
	}
	return 0x820F8BE0;
} // Block from 820F8B88h-820F8BE0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820F8BE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8BE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8BE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8BE0);
		  /* 820F8BE0h */ case    0:  		/* cmplw CR6, R7, R10 */
		/* 820F8BE0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 820F8BE0h case    0:*/		return 0x820F8BE4;
		  /* 820F8BE4h */ case    1:  		/* bc 12, CR6_LT, 20 */
		/* 820F8BE4h case    1:*/		if ( regs.CR[6].lt ) { return 0x820F8BF8;  }
		/* 820F8BE4h case    1:*/		return 0x820F8BE8;
	}
	return 0x820F8BE8;
} // Block from 820F8BE0h-820F8BE8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F8BE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8BE8);
		  /* 820F8BE8h */ case    0:  		/* addi R10, R10, 1 */
		/* 820F8BE8h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820F8BE8h case    0:*/		return 0x820F8BEC;
		  /* 820F8BECh */ case    1:  		/* addi R6, R6, 4 */
		/* 820F8BECh case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x4);
		/* 820F8BECh case    1:*/		return 0x820F8BF0;
		  /* 820F8BF0h */ case    2:  		/* cmplw CR6, R10, R28 */
		/* 820F8BF0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R28);
		/* 820F8BF0h case    2:*/		return 0x820F8BF4;
		  /* 820F8BF4h */ case    3:  		/* bc 12, CR6_LT, -96 */
		/* 820F8BF4h case    3:*/		if ( regs.CR[6].lt ) { return 0x820F8B94;  }
		/* 820F8BF4h case    3:*/		return 0x820F8BF8;
	}
	return 0x820F8BF8;
} // Block from 820F8BE8h-820F8BF8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F8BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8BF8);
		  /* 820F8BF8h */ case    0:  		/* subfc R11, R28, R10 */
		/* 820F8BF8h case    0:*/		cpu::op::subfc<0>(regs,&regs.R11,regs.R28,regs.R10);
		/* 820F8BF8h case    0:*/		return 0x820F8BFC;
		  /* 820F8BFCh */ case    1:  		/* subfe R11, R11, R11 */
		/* 820F8BFCh case    1:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820F8BFCh case    1:*/		return 0x820F8C00;
		  /* 820F8C00h */ case    2:  		/* rlwinm R23, R11, 0, 31, 31 */
		/* 820F8C00h case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R23,regs.R11);
		/* 820F8C00h case    2:*/		return 0x820F8C04;
	}
	return 0x820F8C04;
} // Block from 820F8BF8h-820F8C04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F8C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8C04);
		  /* 820F8C04h */ case    0:  		/* mr R27, R25 */
		/* 820F8C04h case    0:*/		regs.R27 = regs.R25;
		/* 820F8C04h case    0:*/		return 0x820F8C08;
		  /* 820F8C08h */ case    1:  		/* cmpwi CR6, R23, 0 */
		/* 820F8C08h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 820F8C08h case    1:*/		return 0x820F8C0C;
		  /* 820F8C0Ch */ case    2:  		/* bc 12, CR6_EQ, 184 */
		/* 820F8C0Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820F8CC4;  }
		/* 820F8C0Ch case    2:*/		return 0x820F8C10;
		  /* 820F8C10h */ case    3:  		/* mr R6, R25 */
		/* 820F8C10h case    3:*/		regs.R6 = regs.R25;
		/* 820F8C10h case    3:*/		return 0x820F8C14;
		  /* 820F8C14h */ case    4:  		/* cmplwi CR6, R28, 0 */
		/* 820F8C14h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820F8C14h case    4:*/		return 0x820F8C18;
		  /* 820F8C18h */ case    5:  		/* bc 12, CR6_EQ, 52 */
		/* 820F8C18h case    5:*/		if ( regs.CR[6].eq ) { return 0x820F8C4C;  }
		/* 820F8C18h case    5:*/		return 0x820F8C1C;
		  /* 820F8C1Ch */ case    6:  		/* lwz R9, <#[R29 + 20]> */
		/* 820F8C1Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000014) );
		/* 820F8C1Ch case    6:*/		return 0x820F8C20;
		  /* 820F8C20h */ case    7:  		/* mr R10, R26 */
		/* 820F8C20h case    7:*/		regs.R10 = regs.R26;
		/* 820F8C20h case    7:*/		return 0x820F8C24;
		  /* 820F8C24h */ case    8:  		/* mtspr CTR, R28 */
		/* 820F8C24h case    8:*/		regs.CTR = regs.R28;
		/* 820F8C24h case    8:*/		return 0x820F8C28;
		  /* 820F8C28h */ case    9:  		/* lwz R11, <#[R10]> */
		/* 820F8C28h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820F8C28h case    9:*/		return 0x820F8C2C;
		  /* 820F8C2Ch */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F8C2Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F8C2Ch case   10:*/		return 0x820F8C30;
		  /* 820F8C30h */ case   11:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820F8C30h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F8C30h case   11:*/		return 0x820F8C34;
		  /* 820F8C34h */ case   12:  		/* lwz R11, <#[R11 + 16]> */
		/* 820F8C34h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820F8C34h case   12:*/		return 0x820F8C38;
		  /* 820F8C38h */ case   13:  		/* cmplw CR6, R6, R11 */
		/* 820F8C38h case   13:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 820F8C38h case   13:*/		return 0x820F8C3C;
		  /* 820F8C3Ch */ case   14:  		/* bc 12, CR6_GT, 8 */
		/* 820F8C3Ch case   14:*/		if ( regs.CR[6].gt ) { return 0x820F8C44;  }
		/* 820F8C3Ch case   14:*/		return 0x820F8C40;
		  /* 820F8C40h */ case   15:  		/* addi R6, R11, 1 */
		/* 820F8C40h case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1);
		/* 820F8C40h case   15:*/		return 0x820F8C44;
	}
	return 0x820F8C44;
} // Block from 820F8C04h-820F8C44h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820F8C44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8C44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8C44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8C44);
		  /* 820F8C44h */ case    0:  		/* addi R10, R10, 4 */
		/* 820F8C44h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F8C44h case    0:*/		return 0x820F8C48;
		  /* 820F8C48h */ case    1:  		/* bc 16, CR0_LT, -32 */
		/* 820F8C48h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F8C28;  }
		/* 820F8C48h case    1:*/		return 0x820F8C4C;
	}
	return 0x820F8C4C;
} // Block from 820F8C44h-820F8C4Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F8C4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8C4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8C4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8C4C);
		  /* 820F8C4Ch */ case    0:  		/* lwz R11, <#[R29]> */
		/* 820F8C4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820F8C4Ch case    0:*/		return 0x820F8C50;
		  /* 820F8C50h */ case    1:  		/* li R8, 0 */
		/* 820F8C50h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F8C50h case    1:*/		return 0x820F8C54;
		  /* 820F8C54h */ case    2:  		/* li R7, 0 */
		/* 820F8C54h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820F8C54h case    2:*/		return 0x820F8C58;
		  /* 820F8C58h */ case    3:  		/* lwz R4, <#[R29 + 256]> */
		/* 820F8C58h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000100) );
		/* 820F8C58h case    3:*/		return 0x820F8C5C;
		  /* 820F8C5Ch */ case    4:  		/* addi R5, R1, 128 */
		/* 820F8C5Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x80);
		/* 820F8C5Ch case    4:*/		return 0x820F8C60;
		  /* 820F8C60h */ case    5:  		/* mr R3, R29 */
		/* 820F8C60h case    5:*/		regs.R3 = regs.R29;
		/* 820F8C60h case    5:*/		return 0x820F8C64;
		  /* 820F8C64h */ case    6:  		/* lwz R11, <#[R11 + 340]> */
		/* 820F8C64h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000154) );
		/* 820F8C64h case    6:*/		return 0x820F8C68;
		  /* 820F8C68h */ case    7:  		/* mtspr CTR, R11 */
		/* 820F8C68h case    7:*/		regs.CTR = regs.R11;
		/* 820F8C68h case    7:*/		return 0x820F8C6C;
		  /* 820F8C6Ch */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 820F8C6Ch case    8:*/		if ( 1 ) { regs.LR = 0x820F8C70; return (uint32)regs.CTR; }
		/* 820F8C6Ch case    8:*/		return 0x820F8C70;
		  /* 820F8C70h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820F8C70h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8C70h case    9:*/		return 0x820F8C74;
		  /* 820F8C74h */ case   10:  		/* bc 12, CR0_LT, 332 */
		/* 820F8C74h case   10:*/		if ( regs.CR[0].lt ) { return 0x820F8DC0;  }
		/* 820F8C74h case   10:*/		return 0x820F8C78;
		  /* 820F8C78h */ case   11:  		/* cmplwi CR6, R28, 0 */
		/* 820F8C78h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820F8C78h case   11:*/		return 0x820F8C7C;
		  /* 820F8C7Ch */ case   12:  		/* bc 12, CR6_EQ, 64 */
		/* 820F8C7Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x820F8CBC;  }
		/* 820F8C7Ch case   12:*/		return 0x820F8C80;
		  /* 820F8C80h */ case   13:  		/* addi R9, R1, 112 */
		/* 820F8C80h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 820F8C80h case   13:*/		return 0x820F8C84;
		  /* 820F8C84h */ case   14:  		/* lwz R10, <#[R29 + 20]> */
		/* 820F8C84h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000014) );
		/* 820F8C84h case   14:*/		return 0x820F8C88;
		  /* 820F8C88h */ case   15:  		/* addi R11, R1, 112 */
		/* 820F8C88h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820F8C88h case   15:*/		return 0x820F8C8C;
		  /* 820F8C8Ch */ case   16:  		/* mtspr CTR, R28 */
		/* 820F8C8Ch case   16:*/		regs.CTR = regs.R28;
		/* 820F8C8Ch case   16:*/		return 0x820F8C90;
		  /* 820F8C90h */ case   17:  		/* subf R9, R9, R26 */
		/* 820F8C90h case   17:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R9,regs.R26);
		/* 820F8C90h case   17:*/		return 0x820F8C94;
		  /* 820F8C94h */ case   18:  		/* lwzx R8, <#[R9 + R11]> */
		/* 820F8C94h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820F8C94h case   18:*/		return 0x820F8C98;
	}
	return 0x820F8C98;
} // Block from 820F8C4Ch-820F8C98h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820F8C98h
// Function '?EmitMAD@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8C98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8C98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8C98);
		  /* 820F8C98h */ case    0:  		/* addi R7, R1, 128 */
		/* 820F8C98h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x80);
		/* 820F8C98h case    0:*/		return 0x820F8C9C;
		  /* 820F8C9Ch */ case    1:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820F8C9Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820F8C9Ch case    1:*/		return 0x820F8CA0;
		  /* 820F8CA0h */ case    2:  		/* lwzx R8, <#[R8 + R10]> */
		/* 820F8CA0h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 820F8CA0h case    2:*/		return 0x820F8CA4;
		  /* 820F8CA4h */ case    3:  		/* lwz R8, <#[R8 + 16]> */
		/* 820F8CA4h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000010) );
		/* 820F8CA4h case    3:*/		return 0x820F8CA8;
		  /* 820F8CA8h */ case    4:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820F8CA8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820F8CA8h case    4:*/		return 0x820F8CAC;
		  /* 820F8CACh */ case    5:  		/* lwzx R8, <#[R8 + R7]> */
		/* 820F8CACh case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 820F8CACh case    5:*/		return 0x820F8CB0;
		  /* 820F8CB0h */ case    6:  		/* stw R8, <#[R11]> */
		/* 820F8CB0h case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820F8CB0h case    6:*/		return 0x820F8CB4;
		  /* 820F8CB4h */ case    7:  		/* addi R11, R11, 4 */
		/* 820F8CB4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F8CB4h case    7:*/		return 0x820F8CB8;
		  /* 820F8CB8h */ case    8:  		/* bc 16, CR0_LT, -36 */
		/* 820F8CB8h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F8C94;  }
		/* 820F8CB8h case    8:*/		return 0x820F8CBC;
	}
	return 0x820F8CBC;
} // Block from 820F8C98h-820F8CBCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F8CBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8CBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8CBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8CBC);
		  /* 820F8CBCh */ case    0:  		/* mr R27, R26 */
		/* 820F8CBCh case    0:*/		regs.R27 = regs.R26;
		/* 820F8CBCh case    0:*/		return 0x820F8CC0;
		  /* 820F8CC0h */ case    1:  		/* addi R26, R1, 112 */
		/* 820F8CC0h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R1,0x70);
		/* 820F8CC0h case    1:*/		return 0x820F8CC4;
	}
	return 0x820F8CC4;
} // Block from 820F8CBCh-820F8CC4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F8CC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8CC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8CC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8CC4);
		  /* 820F8CC4h */ case    0:  		/* mr R31, R25 */
		/* 820F8CC4h case    0:*/		regs.R31 = regs.R25;
		/* 820F8CC4h case    0:*/		return 0x820F8CC8;
		  /* 820F8CC8h */ case    1:  		/* cmplwi CR6, R28, 0 */
		/* 820F8CC8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820F8CC8h case    1:*/		return 0x820F8CCC;
		  /* 820F8CCCh */ case    2:  		/* bc 12, CR6_EQ, 172 */
		/* 820F8CCCh case    2:*/		if ( regs.CR[6].eq ) { return 0x820F8D78;  }
		/* 820F8CCCh case    2:*/		return 0x820F8CD0;
		  /* 820F8CD0h */ case    3:  		/* addi R9, R31, 1 */
		/* 820F8CD0h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x1);
		/* 820F8CD0h case    3:*/		return 0x820F8CD4;
		  /* 820F8CD4h */ case    4:  		/* li R30, 1 */
		/* 820F8CD4h case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820F8CD4h case    4:*/		return 0x820F8CD8;
		  /* 820F8CD8h */ case    5:  		/* cmplw CR6, R9, R28 */
		/* 820F8CD8h case    5:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R28);
		/* 820F8CD8h case    5:*/		return 0x820F8CDC;
		  /* 820F8CDCh */ case    6:  		/* bc 4, CR6_LT, 80 */
		/* 820F8CDCh case    6:*/		if ( !regs.CR[6].lt ) { return 0x820F8D2C;  }
		/* 820F8CDCh case    6:*/		return 0x820F8CE0;
		  /* 820F8CE0h */ case    7:  		/* rlwinm R11, R31, 2, 0, 29 */
		/* 820F8CE0h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R31);
		/* 820F8CE0h case    7:*/		return 0x820F8CE4;
		  /* 820F8CE4h */ case    8:  		/* lwz R8, <#[R29 + 20]> */
		/* 820F8CE4h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000014) );
		/* 820F8CE4h case    8:*/		return 0x820F8CE8;
		  /* 820F8CE8h */ case    9:  		/* add R11, R11, R24 */
		/* 820F8CE8h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R24);
		/* 820F8CE8h case    9:*/		return 0x820F8CEC;
		  /* 820F8CECh */ case   10:  		/* addi R10, R11, 4 */
		/* 820F8CECh case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 820F8CECh case   10:*/		return 0x820F8CF0;
		  /* 820F8CF0h */ case   11:  		/* lwz R11, <#[R11]> */
		/* 820F8CF0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F8CF0h case   11:*/		return 0x820F8CF4;
		  /* 820F8CF4h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F8CF4h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F8CF4h case   12:*/		return 0x820F8CF8;
		  /* 820F8CF8h */ case   13:  		/* lwzx R11, <#[R11 + R8]> */
		/* 820F8CF8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820F8CF8h case   13:*/		return 0x820F8CFC;
		  /* 820F8CFCh */ case   14:  		/* lwz R11, <#[R11 + 16]> */
		/* 820F8CFCh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820F8CFCh case   14:*/		return 0x820F8D00;
		  /* 820F8D00h */ case   15:  		/* lwz R7, <#[R10]> */
		/* 820F8D00h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820F8D00h case   15:*/		return 0x820F8D04;
		  /* 820F8D04h */ case   16:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 820F8D04h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 820F8D04h case   16:*/		return 0x820F8D08;
		  /* 820F8D08h */ case   17:  		/* lwzx R7, <#[R7 + R8]> */
		/* 820F8D08h case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 820F8D08h case   17:*/		return 0x820F8D0C;
		  /* 820F8D0Ch */ case   18:  		/* lwz R7, <#[R7 + 16]> */
		/* 820F8D0Ch case   18:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000010) );
		/* 820F8D0Ch case   18:*/		return 0x820F8D10;
		  /* 820F8D10h */ case   19:  		/* cmplw CR6, R7, R11 */
		/* 820F8D10h case   19:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820F8D10h case   19:*/		return 0x820F8D14;
		  /* 820F8D14h */ case   20:  		/* bc 4, CR6_EQ, 24 */
		/* 820F8D14h case   20:*/		if ( !regs.CR[6].eq ) { return 0x820F8D2C;  }
		/* 820F8D14h case   20:*/		return 0x820F8D18;
		  /* 820F8D18h */ case   21:  		/* addi R9, R9, 1 */
		/* 820F8D18h case   21:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820F8D18h case   21:*/		return 0x820F8D1C;
		  /* 820F8D1Ch */ case   22:  		/* addi R30, R30, 1 */
		/* 820F8D1Ch case   22:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820F8D1Ch case   22:*/		return 0x820F8D20;
		  /* 820F8D20h */ case   23:  		/* addi R10, R10, 4 */
		/* 820F8D20h case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F8D20h case   23:*/		return 0x820F8D24;
		  /* 820F8D24h */ case   24:  		/* cmplw CR6, R9, R28 */
		/* 820F8D24h case   24:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R28);
		/* 820F8D24h case   24:*/		return 0x820F8D28;
		  /* 820F8D28h */ case   25:  		/* bc 12, CR6_LT, -40 */
		/* 820F8D28h case   25:*/		if ( regs.CR[6].lt ) { return 0x820F8D00;  }
		/* 820F8D28h case   25:*/		return 0x820F8D2C;
	}
	return 0x820F8D2C;
} // Block from 820F8CC4h-820F8D2Ch (26 instructions)

//////////////////////////////////////////////////////
// Block at 820F8D2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8D2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8D2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8D2C);
		  /* 820F8D2Ch */ case    0:  		/* rlwinm R11, R31, 2, 0, 29 */
		/* 820F8D2Ch case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R31);
		/* 820F8D2Ch case    0:*/		return 0x820F8D30;
		  /* 820F8D30h */ case    1:  		/* stw R22, <#[R1 + 100]> */
		/* 820F8D30h case    1:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000064) );
		/* 820F8D30h case    1:*/		return 0x820F8D34;
		  /* 820F8D34h */ case    2:  		/* mr R10, R30 */
		/* 820F8D34h case    2:*/		regs.R10 = regs.R30;
		/* 820F8D34h case    2:*/		return 0x820F8D38;
		  /* 820F8D38h */ case    3:  		/* stw R22, <#[R1 + 92]> */
		/* 820F8D38h case    3:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F8D38h case    3:*/		return 0x820F8D3C;
		  /* 820F8D3Ch */ case    4:  		/* li R9, 0 */
		/* 820F8D3Ch case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F8D3Ch case    4:*/		return 0x820F8D40;
		  /* 820F8D40h */ case    5:  		/* stw R22, <#[R1 + 84]> */
		/* 820F8D40h case    5:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000054) );
		/* 820F8D40h case    5:*/		return 0x820F8D44;
		  /* 820F8D44h */ case    6:  		/* li R8, 0 */
		/* 820F8D44h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F8D44h case    6:*/		return 0x820F8D48;
		  /* 820F8D48h */ case    7:  		/* stw R25, <#[R1 + 108]> */
		/* 820F8D48h case    7:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x0000006C) );
		/* 820F8D48h case    7:*/		return 0x820F8D4C;
		  /* 820F8D4Ch */ case    8:  		/* add R7, R11, R24 */
		/* 820F8D4Ch case    8:*/		cpu::op::add<0>(regs,&regs.R7,regs.R11,regs.R24);
		/* 820F8D4Ch case    8:*/		return 0x820F8D50;
		  /* 820F8D50h */ case    9:  		/* mr R6, R30 */
		/* 820F8D50h case    9:*/		regs.R6 = regs.R30;
		/* 820F8D50h case    9:*/		return 0x820F8D54;
		  /* 820F8D54h */ case   10:  		/* add R5, R11, R26 */
		/* 820F8D54h case   10:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R26);
		/* 820F8D54h case   10:*/		return 0x820F8D58;
		  /* 820F8D58h */ case   11:  		/* mr R4, R21 */
		/* 820F8D58h case   11:*/		regs.R4 = regs.R21;
		/* 820F8D58h case   11:*/		return 0x820F8D5C;
		  /* 820F8D5Ch */ case   12:  		/* mr R3, R29 */
		/* 820F8D5Ch case   12:*/		regs.R3 = regs.R29;
		/* 820F8D5Ch case   12:*/		return 0x820F8D60;
		  /* 820F8D60h */ case   13:  		/* bl -10752 */
		/* 820F8D60h case   13:*/		regs.LR = 0x820F8D64; return 0x820F6360;
		/* 820F8D60h case   13:*/		return 0x820F8D64;
		  /* 820F8D64h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 820F8D64h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8D64h case   14:*/		return 0x820F8D68;
		  /* 820F8D68h */ case   15:  		/* bc 12, CR0_LT, 88 */
		/* 820F8D68h case   15:*/		if ( regs.CR[0].lt ) { return 0x820F8DC0;  }
		/* 820F8D68h case   15:*/		return 0x820F8D6C;
		  /* 820F8D6Ch */ case   16:  		/* add R31, R30, R31 */
		/* 820F8D6Ch case   16:*/		cpu::op::add<0>(regs,&regs.R31,regs.R30,regs.R31);
		/* 820F8D6Ch case   16:*/		return 0x820F8D70;
		  /* 820F8D70h */ case   17:  		/* cmplw CR6, R31, R28 */
		/* 820F8D70h case   17:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R28);
		/* 820F8D70h case   17:*/		return 0x820F8D74;
		  /* 820F8D74h */ case   18:  		/* bc 12, CR6_LT, -164 */
		/* 820F8D74h case   18:*/		if ( regs.CR[6].lt ) { return 0x820F8CD0;  }
		/* 820F8D74h case   18:*/		return 0x820F8D78;
	}
	return 0x820F8D78;
} // Block from 820F8D2Ch-820F8D78h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820F8D78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8D78);
		  /* 820F8D78h */ case    0:  		/* cmpwi CR6, R23, 0 */
		/* 820F8D78h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 820F8D78h case    0:*/		return 0x820F8D7C;
		  /* 820F8D7Ch */ case    1:  		/* bc 12, CR6_EQ, 64 */
		/* 820F8D7Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820F8DBC;  }
		/* 820F8D7Ch case    1:*/		return 0x820F8D80;
		  /* 820F8D80h */ case    2:  		/* mr R10, R28 */
		/* 820F8D80h case    2:*/		regs.R10 = regs.R28;
		/* 820F8D80h case    2:*/		return 0x820F8D84;
		  /* 820F8D84h */ case    3:  		/* stw R25, <#[R1 + 108]> */
		/* 820F8D84h case    3:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x0000006C) );
		/* 820F8D84h case    3:*/		return 0x820F8D88;
		  /* 820F8D88h */ case    4:  		/* li R9, 0 */
		/* 820F8D88h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F8D88h case    4:*/		return 0x820F8D8C;
		  /* 820F8D8Ch */ case    5:  		/* stw R25, <#[R1 + 100]> */
		/* 820F8D8Ch case    5:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000064) );
		/* 820F8D8Ch case    5:*/		return 0x820F8D90;
		  /* 820F8D90h */ case    6:  		/* li R8, 0 */
		/* 820F8D90h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F8D90h case    6:*/		return 0x820F8D94;
		  /* 820F8D94h */ case    7:  		/* stw R25, <#[R1 + 92]> */
		/* 820F8D94h case    7:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F8D94h case    7:*/		return 0x820F8D98;
		  /* 820F8D98h */ case    8:  		/* mr R7, R26 */
		/* 820F8D98h case    8:*/		regs.R7 = regs.R26;
		/* 820F8D98h case    8:*/		return 0x820F8D9C;
		  /* 820F8D9Ch */ case    9:  		/* stw R25, <#[R1 + 84]> */
		/* 820F8D9Ch case    9:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000054) );
		/* 820F8D9Ch case    9:*/		return 0x820F8DA0;
		  /* 820F8DA0h */ case   10:  		/* mr R6, R28 */
		/* 820F8DA0h case   10:*/		regs.R6 = regs.R28;
		/* 820F8DA0h case   10:*/		return 0x820F8DA4;
		  /* 820F8DA4h */ case   11:  		/* mr R5, R27 */
		/* 820F8DA4h case   11:*/		regs.R5 = regs.R27;
		/* 820F8DA4h case   11:*/		return 0x820F8DA8;
		  /* 820F8DA8h */ case   12:  		/* li R4, 1 */
		/* 820F8DA8h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820F8DA8h case   12:*/		return 0x820F8DAC;
		  /* 820F8DACh */ case   13:  		/* mr R3, R29 */
		/* 820F8DACh case   13:*/		regs.R3 = regs.R29;
		/* 820F8DACh case   13:*/		return 0x820F8DB0;
		  /* 820F8DB0h */ case   14:  		/* bl -10832 */
		/* 820F8DB0h case   14:*/		regs.LR = 0x820F8DB4; return 0x820F6360;
		/* 820F8DB0h case   14:*/		return 0x820F8DB4;
		  /* 820F8DB4h */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 820F8DB4h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8DB4h case   15:*/		return 0x820F8DB8;
		  /* 820F8DB8h */ case   16:  		/* bc 12, CR0_LT, 8 */
		/* 820F8DB8h case   16:*/		if ( regs.CR[0].lt ) { return 0x820F8DC0;  }
		/* 820F8DB8h case   16:*/		return 0x820F8DBC;
	}
	return 0x820F8DBC;
} // Block from 820F8D78h-820F8DBCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 820F8DBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8DBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8DBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8DBC);
		  /* 820F8DBCh */ case    0:  		/* li R3, 0 */
		/* 820F8DBCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F8DBCh case    0:*/		return 0x820F8DC0;
	}
	return 0x820F8DC0;
} // Block from 820F8DBCh-820F8DC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F8DC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8DC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8DC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8DC0);
		  /* 820F8DC0h */ case    0:  		/* addi R1, R1, 240 */
		/* 820F8DC0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 820F8DC0h case    0:*/		return 0x820F8DC4;
		  /* 820F8DC4h */ case    1:  		/* b -424760 */
		/* 820F8DC4h case    1:*/		return 0x8209128C;
		/* 820F8DC4h case    1:*/		return 0x820F8DC8;
	}
	return 0x820F8DC8;
} // Block from 820F8DC0h-820F8DC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F8DC8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8DC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8DC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8DC8);
		  /* 820F8DC8h */ case    0:  		/* mfspr R12, LR */
		/* 820F8DC8h case    0:*/		regs.R12 = regs.LR;
		/* 820F8DC8h case    0:*/		return 0x820F8DCC;
		  /* 820F8DCCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820F8DCCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F8DCCh case    1:*/		return 0x820F8DD0;
		  /* 820F8DD0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820F8DD0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F8DD0h case    2:*/		return 0x820F8DD4;
		  /* 820F8DD4h */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 820F8DD4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820F8DD4h case    3:*/		return 0x820F8DD8;
		  /* 820F8DD8h */ case    4:  		/* li R4, 38 */
		/* 820F8DD8h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x26);
		/* 820F8DD8h case    4:*/		return 0x820F8DDC;
		  /* 820F8DDCh */ case    5:  		/* mr R31, R3 */
		/* 820F8DDCh case    5:*/		regs.R31 = regs.R3;
		/* 820F8DDCh case    5:*/		return 0x820F8DE0;
		  /* 820F8DE0h */ case    6:  		/* bl -11504 */
		/* 820F8DE0h case    6:*/		regs.LR = 0x820F8DE4; return 0x820F60F0;
		/* 820F8DE0h case    6:*/		return 0x820F8DE4;
		  /* 820F8DE4h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820F8DE4h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8DE4h case    7:*/		return 0x820F8DE8;
		  /* 820F8DE8h */ case    8:  		/* bc 12, CR0_LT, 152 */
		/* 820F8DE8h case    8:*/		if ( regs.CR[0].lt ) { return 0x820F8E80;  }
		/* 820F8DE8h case    8:*/		return 0x820F8DEC;
		  /* 820F8DECh */ case    9:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F8DECh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F8DECh case    9:*/		return 0x820F8DF0;
		  /* 820F8DF0h */ case   10:  		/* addi R6, R1, 80 */
		/* 820F8DF0h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 820F8DF0h case   10:*/		return 0x820F8DF4;
		  /* 820F8DF4h */ case   11:  		/* lwz R10, <#[R31]> */
		/* 820F8DF4h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F8DF4h case   11:*/		return 0x820F8DF8;
		  /* 820F8DF8h */ case   12:  		/* addi R5, R1, 84 */
		/* 820F8DF8h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 820F8DF8h case   12:*/		return 0x820F8DFC;
		  /* 820F8DFCh */ case   13:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F8DFCh case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F8DFCh case   13:*/		return 0x820F8E00;
		  /* 820F8E00h */ case   14:  		/* mr R3, R31 */
		/* 820F8E00h case   14:*/		regs.R3 = regs.R31;
		/* 820F8E00h case   14:*/		return 0x820F8E04;
		  /* 820F8E04h */ case   15:  		/* lwz R11, <#[R11 + 8]> */
		/* 820F8E04h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820F8E04h case   15:*/		return 0x820F8E08;
		  /* 820F8E08h */ case   16:  		/* lwz R10, <#[R10 + 328]> */
		/* 820F8E08h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000148) );
		/* 820F8E08h case   16:*/		return 0x820F8E0C;
		  /* 820F8E0Ch */ case   17:  		/* lwz R11, <#[R11]> */
		/* 820F8E0Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F8E0Ch case   17:*/		return 0x820F8E10;
		  /* 820F8E10h */ case   18:  		/* mtspr CTR, R10 */
		/* 820F8E10h case   18:*/		regs.CTR = regs.R10;
		/* 820F8E10h case   18:*/		return 0x820F8E14;
		  /* 820F8E14h */ case   19:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F8E14h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F8E14h case   19:*/		return 0x820F8E18;
		  /* 820F8E18h */ case   20:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F8E18h case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F8E18h case   20:*/		return 0x820F8E1C;
		  /* 820F8E1Ch */ case   21:  		/* bcctrl 20, CR0_LT */
		/* 820F8E1Ch case   21:*/		if ( 1 ) { regs.LR = 0x820F8E20; return (uint32)regs.CTR; }
		/* 820F8E1Ch case   21:*/		return 0x820F8E20;
		  /* 820F8E20h */ case   22:  		/* cmpwi CR0, R3, 0 */
		/* 820F8E20h case   22:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8E20h case   22:*/		return 0x820F8E24;
		  /* 820F8E24h */ case   23:  		/* bc 12, CR0_LT, 92 */
		/* 820F8E24h case   23:*/		if ( regs.CR[0].lt ) { return 0x820F8E80;  }
		/* 820F8E24h case   23:*/		return 0x820F8E28;
		  /* 820F8E28h */ case   24:  		/* lwz R11, <#[R31]> */
		/* 820F8E28h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F8E28h case   24:*/		return 0x820F8E2C;
		  /* 820F8E2Ch */ case   25:  		/* lis R5, 228 */
		/* 820F8E2Ch case   25:*/		cpu::op::lis<0>(regs,&regs.R5,0xE4);
		/* 820F8E2Ch case   25:*/		return 0x820F8E30;
		  /* 820F8E30h */ case   26:  		/* mr R3, R31 */
		/* 820F8E30h case   26:*/		regs.R3 = regs.R31;
		/* 820F8E30h case   26:*/		return 0x820F8E34;
		  /* 820F8E34h */ case   27:  		/* lwz R6, <#[R1 + 80]> */
		/* 820F8E34h case   27:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 820F8E34h case   27:*/		return 0x820F8E38;
		  /* 820F8E38h */ case   28:  		/* lwz R4, <#[R1 + 84]> */
		/* 820F8E38h case   28:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 820F8E38h case   28:*/		return 0x820F8E3C;
		  /* 820F8E3Ch */ case   29:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F8E3Ch case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F8E3Ch case   29:*/		return 0x820F8E40;
		  /* 820F8E40h */ case   30:  		/* mtspr CTR, R11 */
		/* 820F8E40h case   30:*/		regs.CTR = regs.R11;
		/* 820F8E40h case   30:*/		return 0x820F8E44;
		  /* 820F8E44h */ case   31:  		/* bcctrl 20, CR0_LT */
		/* 820F8E44h case   31:*/		if ( 1 ) { regs.LR = 0x820F8E48; return (uint32)regs.CTR; }
		/* 820F8E44h case   31:*/		return 0x820F8E48;
		  /* 820F8E48h */ case   32:  		/* cmpwi CR0, R3, 0 */
		/* 820F8E48h case   32:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8E48h case   32:*/		return 0x820F8E4C;
		  /* 820F8E4Ch */ case   33:  		/* bc 12, CR0_LT, 52 */
		/* 820F8E4Ch case   33:*/		if ( regs.CR[0].lt ) { return 0x820F8E80;  }
		/* 820F8E4Ch case   33:*/		return 0x820F8E50;
		  /* 820F8E50h */ case   34:  		/* lwz R11, <#[R31]> */
		/* 820F8E50h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F8E50h case   34:*/		return 0x820F8E54;
		  /* 820F8E54h */ case   35:  		/* mr R3, R31 */
		/* 820F8E54h case   35:*/		regs.R3 = regs.R31;
		/* 820F8E54h case   35:*/		return 0x820F8E58;
		  /* 820F8E58h */ case   36:  		/* lwz R11, <#[R11 + 308]> */
		/* 820F8E58h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000134) );
		/* 820F8E58h case   36:*/		return 0x820F8E5C;
		  /* 820F8E5Ch */ case   37:  		/* mtspr CTR, R11 */
		/* 820F8E5Ch case   37:*/		regs.CTR = regs.R11;
		/* 820F8E5Ch case   37:*/		return 0x820F8E60;
		  /* 820F8E60h */ case   38:  		/* bcctrl 20, CR0_LT */
		/* 820F8E60h case   38:*/		if ( 1 ) { regs.LR = 0x820F8E64; return (uint32)regs.CTR; }
		/* 820F8E60h case   38:*/		return 0x820F8E64;
		  /* 820F8E64h */ case   39:  		/* cmpwi CR0, R3, 0 */
		/* 820F8E64h case   39:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8E64h case   39:*/		return 0x820F8E68;
		  /* 820F8E68h */ case   40:  		/* bc 12, CR0_LT, 24 */
		/* 820F8E68h case   40:*/		if ( regs.CR[0].lt ) { return 0x820F8E80;  }
		/* 820F8E68h case   40:*/		return 0x820F8E6C;
		  /* 820F8E6Ch */ case   41:  		/* mr R3, R31 */
		/* 820F8E6Ch case   41:*/		regs.R3 = regs.R31;
		/* 820F8E6Ch case   41:*/		return 0x820F8E70;
		  /* 820F8E70h */ case   42:  		/* bl -46440 */
		/* 820F8E70h case   42:*/		regs.LR = 0x820F8E74; return 0x820ED908;
		/* 820F8E70h case   42:*/		return 0x820F8E74;
		  /* 820F8E74h */ case   43:  		/* cmpwi CR0, R3, 0 */
		/* 820F8E74h case   43:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8E74h case   43:*/		return 0x820F8E78;
		  /* 820F8E78h */ case   44:  		/* bc 12, CR0_LT, 8 */
		/* 820F8E78h case   44:*/		if ( regs.CR[0].lt ) { return 0x820F8E80;  }
		/* 820F8E78h case   44:*/		return 0x820F8E7C;
		  /* 820F8E7Ch */ case   45:  		/* li R3, 0 */
		/* 820F8E7Ch case   45:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F8E7Ch case   45:*/		return 0x820F8E80;
	}
	return 0x820F8E80;
} // Block from 820F8DC8h-820F8E80h (46 instructions)

//////////////////////////////////////////////////////
// Block at 820F8E80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8E80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8E80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8E80);
		  /* 820F8E80h */ case    0:  		/* addi R1, R1, 112 */
		/* 820F8E80h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820F8E80h case    0:*/		return 0x820F8E84;
		  /* 820F8E84h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820F8E84h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F8E84h case    1:*/		return 0x820F8E88;
		  /* 820F8E88h */ case    2:  		/* mtspr LR, R12 */
		/* 820F8E88h case    2:*/		regs.LR = regs.R12;
		/* 820F8E88h case    2:*/		return 0x820F8E8C;
		  /* 820F8E8Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820F8E8Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F8E8Ch case    3:*/		return 0x820F8E90;
		  /* 820F8E90h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820F8E90h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F8E90h case    4:*/		return 0x820F8E94;
	}
	return 0x820F8E94;
} // Block from 820F8E80h-820F8E94h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F8E94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8E94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8E94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8E94);
		  /* 820F8E94h */ case    0:  		/* nop */
		/* 820F8E94h case    0:*/		cpu::op::nop();
		/* 820F8E94h case    0:*/		return 0x820F8E98;
	}
	return 0x820F8E98;
} // Block from 820F8E94h-820F8E98h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F8E98h
// Function '?EmitMAT@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8E98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8E98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8E98);
		  /* 820F8E98h */ case    0:  		/* mfspr R12, LR */
		/* 820F8E98h case    0:*/		regs.R12 = regs.LR;
		/* 820F8E98h case    0:*/		return 0x820F8E9C;
		  /* 820F8E9Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820F8E9Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F8E9Ch case    1:*/		return 0x820F8EA0;
		  /* 820F8EA0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820F8EA0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F8EA0h case    2:*/		return 0x820F8EA4;
		  /* 820F8EA4h */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 820F8EA4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820F8EA4h case    3:*/		return 0x820F8EA8;
		  /* 820F8EA8h */ case    4:  		/* li R4, 27 */
		/* 820F8EA8h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1B);
		/* 820F8EA8h case    4:*/		return 0x820F8EAC;
		  /* 820F8EACh */ case    5:  		/* mr R31, R3 */
		/* 820F8EACh case    5:*/		regs.R31 = regs.R3;
		/* 820F8EACh case    5:*/		return 0x820F8EB0;
		  /* 820F8EB0h */ case    6:  		/* bl -11712 */
		/* 820F8EB0h case    6:*/		regs.LR = 0x820F8EB4; return 0x820F60F0;
		/* 820F8EB0h case    6:*/		return 0x820F8EB4;
		  /* 820F8EB4h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820F8EB4h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8EB4h case    7:*/		return 0x820F8EB8;
		  /* 820F8EB8h */ case    8:  		/* bc 12, CR0_LT, 204 */
		/* 820F8EB8h case    8:*/		if ( regs.CR[0].lt ) { return 0x820F8F84;  }
		/* 820F8EB8h case    8:*/		return 0x820F8EBC;
		  /* 820F8EBCh */ case    9:  		/* li R11, 0 */
		/* 820F8EBCh case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F8EBCh case    9:*/		return 0x820F8EC0;
		  /* 820F8EC0h */ case   10:  		/* lwz R10, <#[R31]> */
		/* 820F8EC0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F8EC0h case   10:*/		return 0x820F8EC4;
		  /* 820F8EC4h */ case   11:  		/* lis R4, -4096 */
		/* 820F8EC4h case   11:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFF000);
		/* 820F8EC4h case   11:*/		return 0x820F8EC8;
		  /* 820F8EC8h */ case   12:  		/* stw R11, <#[R1 + 80]> */
		/* 820F8EC8h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820F8EC8h case   12:*/		return 0x820F8ECC;
		  /* 820F8ECCh */ case   13:  		/* li R6, 0 */
		/* 820F8ECCh case   13:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820F8ECCh case   13:*/		return 0x820F8ED0;
		  /* 820F8ED0h */ case   14:  		/* lis R5, 228 */
		/* 820F8ED0h case   14:*/		cpu::op::lis<0>(regs,&regs.R5,0xE4);
		/* 820F8ED0h case   14:*/		return 0x820F8ED4;
		  /* 820F8ED4h */ case   15:  		/* ori R4, R4, 2048 */
		/* 820F8ED4h case   15:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x800);
		/* 820F8ED4h case   15:*/		return 0x820F8ED8;
		  /* 820F8ED8h */ case   16:  		/* lwz R11, <#[R10 + 316]> */
		/* 820F8ED8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000013C) );
		/* 820F8ED8h case   16:*/		return 0x820F8EDC;
		  /* 820F8EDCh */ case   17:  		/* mr R3, R31 */
		/* 820F8EDCh case   17:*/		regs.R3 = regs.R31;
		/* 820F8EDCh case   17:*/		return 0x820F8EE0;
		  /* 820F8EE0h */ case   18:  		/* mtspr CTR, R11 */
		/* 820F8EE0h case   18:*/		regs.CTR = regs.R11;
		/* 820F8EE0h case   18:*/		return 0x820F8EE4;
		  /* 820F8EE4h */ case   19:  		/* bcctrl 20, CR0_LT */
		/* 820F8EE4h case   19:*/		if ( 1 ) { regs.LR = 0x820F8EE8; return (uint32)regs.CTR; }
		/* 820F8EE4h case   19:*/		return 0x820F8EE8;
		  /* 820F8EE8h */ case   20:  		/* cmpwi CR0, R3, 0 */
		/* 820F8EE8h case   20:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8EE8h case   20:*/		return 0x820F8EEC;
		  /* 820F8EECh */ case   21:  		/* bc 12, CR0_LT, 152 */
		/* 820F8EECh case   21:*/		if ( regs.CR[0].lt ) { return 0x820F8F84;  }
		/* 820F8EECh case   21:*/		return 0x820F8EF0;
		  /* 820F8EF0h */ case   22:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F8EF0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F8EF0h case   22:*/		return 0x820F8EF4;
		  /* 820F8EF4h */ case   23:  		/* addi R6, R1, 84 */
		/* 820F8EF4h case   23:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 820F8EF4h case   23:*/		return 0x820F8EF8;
		  /* 820F8EF8h */ case   24:  		/* lwz R10, <#[R31]> */
		/* 820F8EF8h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F8EF8h case   24:*/		return 0x820F8EFC;
		  /* 820F8EFCh */ case   25:  		/* addi R5, R1, 80 */
		/* 820F8EFCh case   25:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820F8EFCh case   25:*/		return 0x820F8F00;
		  /* 820F8F00h */ case   26:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F8F00h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F8F00h case   26:*/		return 0x820F8F04;
		  /* 820F8F04h */ case   27:  		/* mr R3, R31 */
		/* 820F8F04h case   27:*/		regs.R3 = regs.R31;
		/* 820F8F04h case   27:*/		return 0x820F8F08;
		  /* 820F8F08h */ case   28:  		/* lwz R11, <#[R11 + 8]> */
		/* 820F8F08h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820F8F08h case   28:*/		return 0x820F8F0C;
		  /* 820F8F0Ch */ case   29:  		/* lwz R10, <#[R10 + 328]> */
		/* 820F8F0Ch case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000148) );
		/* 820F8F0Ch case   29:*/		return 0x820F8F10;
		  /* 820F8F10h */ case   30:  		/* lwz R11, <#[R11]> */
		/* 820F8F10h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F8F10h case   30:*/		return 0x820F8F14;
		  /* 820F8F14h */ case   31:  		/* mtspr CTR, R10 */
		/* 820F8F14h case   31:*/		regs.CTR = regs.R10;
		/* 820F8F14h case   31:*/		return 0x820F8F18;
		  /* 820F8F18h */ case   32:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F8F18h case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F8F18h case   32:*/		return 0x820F8F1C;
		  /* 820F8F1Ch */ case   33:  		/* lwzx R4, <#[R11 + R9]> */
		/* 820F8F1Ch case   33:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F8F1Ch case   33:*/		return 0x820F8F20;
		  /* 820F8F20h */ case   34:  		/* bcctrl 20, CR0_LT */
		/* 820F8F20h case   34:*/		if ( 1 ) { regs.LR = 0x820F8F24; return (uint32)regs.CTR; }
		/* 820F8F20h case   34:*/		return 0x820F8F24;
		  /* 820F8F24h */ case   35:  		/* cmpwi CR0, R3, 0 */
		/* 820F8F24h case   35:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8F24h case   35:*/		return 0x820F8F28;
		  /* 820F8F28h */ case   36:  		/* bc 12, CR0_LT, 92 */
		/* 820F8F28h case   36:*/		if ( regs.CR[0].lt ) { return 0x820F8F84;  }
		/* 820F8F28h case   36:*/		return 0x820F8F2C;
		  /* 820F8F2Ch */ case   37:  		/* lwz R11, <#[R31]> */
		/* 820F8F2Ch case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F8F2Ch case   37:*/		return 0x820F8F30;
		  /* 820F8F30h */ case   38:  		/* lis R5, 228 */
		/* 820F8F30h case   38:*/		cpu::op::lis<0>(regs,&regs.R5,0xE4);
		/* 820F8F30h case   38:*/		return 0x820F8F34;
		  /* 820F8F34h */ case   39:  		/* mr R3, R31 */
		/* 820F8F34h case   39:*/		regs.R3 = regs.R31;
		/* 820F8F34h case   39:*/		return 0x820F8F38;
		  /* 820F8F38h */ case   40:  		/* lwz R6, <#[R1 + 84]> */
		/* 820F8F38h case   40:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 820F8F38h case   40:*/		return 0x820F8F3C;
		  /* 820F8F3Ch */ case   41:  		/* lwz R4, <#[R1 + 80]> */
		/* 820F8F3Ch case   41:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 820F8F3Ch case   41:*/		return 0x820F8F40;
		  /* 820F8F40h */ case   42:  		/* lwz R11, <#[R11 + 316]> */
		/* 820F8F40h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000013C) );
		/* 820F8F40h case   42:*/		return 0x820F8F44;
		  /* 820F8F44h */ case   43:  		/* mtspr CTR, R11 */
		/* 820F8F44h case   43:*/		regs.CTR = regs.R11;
		/* 820F8F44h case   43:*/		return 0x820F8F48;
		  /* 820F8F48h */ case   44:  		/* bcctrl 20, CR0_LT */
		/* 820F8F48h case   44:*/		if ( 1 ) { regs.LR = 0x820F8F4C; return (uint32)regs.CTR; }
		/* 820F8F48h case   44:*/		return 0x820F8F4C;
		  /* 820F8F4Ch */ case   45:  		/* cmpwi CR0, R3, 0 */
		/* 820F8F4Ch case   45:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8F4Ch case   45:*/		return 0x820F8F50;
		  /* 820F8F50h */ case   46:  		/* bc 12, CR0_LT, 52 */
		/* 820F8F50h case   46:*/		if ( regs.CR[0].lt ) { return 0x820F8F84;  }
		/* 820F8F50h case   46:*/		return 0x820F8F54;
		  /* 820F8F54h */ case   47:  		/* lwz R11, <#[R31]> */
		/* 820F8F54h case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F8F54h case   47:*/		return 0x820F8F58;
		  /* 820F8F58h */ case   48:  		/* mr R3, R31 */
		/* 820F8F58h case   48:*/		regs.R3 = regs.R31;
		/* 820F8F58h case   48:*/		return 0x820F8F5C;
		  /* 820F8F5Ch */ case   49:  		/* lwz R11, <#[R11 + 308]> */
		/* 820F8F5Ch case   49:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000134) );
		/* 820F8F5Ch case   49:*/		return 0x820F8F60;
		  /* 820F8F60h */ case   50:  		/* mtspr CTR, R11 */
		/* 820F8F60h case   50:*/		regs.CTR = regs.R11;
		/* 820F8F60h case   50:*/		return 0x820F8F64;
		  /* 820F8F64h */ case   51:  		/* bcctrl 20, CR0_LT */
		/* 820F8F64h case   51:*/		if ( 1 ) { regs.LR = 0x820F8F68; return (uint32)regs.CTR; }
		/* 820F8F64h case   51:*/		return 0x820F8F68;
		  /* 820F8F68h */ case   52:  		/* cmpwi CR0, R3, 0 */
		/* 820F8F68h case   52:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8F68h case   52:*/		return 0x820F8F6C;
		  /* 820F8F6Ch */ case   53:  		/* bc 12, CR0_LT, 24 */
		/* 820F8F6Ch case   53:*/		if ( regs.CR[0].lt ) { return 0x820F8F84;  }
		/* 820F8F6Ch case   53:*/		return 0x820F8F70;
		  /* 820F8F70h */ case   54:  		/* mr R3, R31 */
		/* 820F8F70h case   54:*/		regs.R3 = regs.R31;
		/* 820F8F70h case   54:*/		return 0x820F8F74;
		  /* 820F8F74h */ case   55:  		/* bl -46700 */
		/* 820F8F74h case   55:*/		regs.LR = 0x820F8F78; return 0x820ED908;
		/* 820F8F74h case   55:*/		return 0x820F8F78;
		  /* 820F8F78h */ case   56:  		/* cmpwi CR0, R3, 0 */
		/* 820F8F78h case   56:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F8F78h case   56:*/		return 0x820F8F7C;
		  /* 820F8F7Ch */ case   57:  		/* bc 12, CR0_LT, 8 */
		/* 820F8F7Ch case   57:*/		if ( regs.CR[0].lt ) { return 0x820F8F84;  }
		/* 820F8F7Ch case   57:*/		return 0x820F8F80;
		  /* 820F8F80h */ case   58:  		/* li R3, 0 */
		/* 820F8F80h case   58:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F8F80h case   58:*/		return 0x820F8F84;
	}
	return 0x820F8F84;
} // Block from 820F8E98h-820F8F84h (59 instructions)

//////////////////////////////////////////////////////
// Block at 820F8F84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8F84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8F84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8F84);
		  /* 820F8F84h */ case    0:  		/* addi R1, R1, 112 */
		/* 820F8F84h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820F8F84h case    0:*/		return 0x820F8F88;
		  /* 820F8F88h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820F8F88h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F8F88h case    1:*/		return 0x820F8F8C;
		  /* 820F8F8Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820F8F8Ch case    2:*/		regs.LR = regs.R12;
		/* 820F8F8Ch case    2:*/		return 0x820F8F90;
		  /* 820F8F90h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820F8F90h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F8F90h case    3:*/		return 0x820F8F94;
		  /* 820F8F94h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820F8F94h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F8F94h case    4:*/		return 0x820F8F98;
	}
	return 0x820F8F98;
} // Block from 820F8F84h-820F8F98h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F8F98h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8F98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8F98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8F98);
		  /* 820F8F98h */ case    0:  		/* mfspr R12, LR */
		/* 820F8F98h case    0:*/		regs.R12 = regs.LR;
		/* 820F8F98h case    0:*/		return 0x820F8F9C;
		  /* 820F8F9Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820F8F9Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F8F9Ch case    1:*/		return 0x820F8FA0;
		  /* 820F8FA0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820F8FA0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820F8FA0h case    2:*/		return 0x820F8FA4;
		  /* 820F8FA4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820F8FA4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F8FA4h case    3:*/		return 0x820F8FA8;
		  /* 820F8FA8h */ case    4:  		/* stwu R1, <#[R1 - 144]> */
		/* 820F8FA8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820F8FA8h case    4:*/		return 0x820F8FAC;
		  /* 820F8FACh */ case    5:  		/* lwz R5, <#[R3 + 260]> */
		/* 820F8FACh case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000104) );
		/* 820F8FACh case    5:*/		return 0x820F8FB0;
		  /* 820F8FB0h */ case    6:  		/* lwz R11, <#[R3 + 20]> */
		/* 820F8FB0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820F8FB0h case    6:*/		return 0x820F8FB4;
		  /* 820F8FB4h */ case    7:  		/* lwz R10, <#[R3 + 140]> */
		/* 820F8FB4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000008C) );
		/* 820F8FB4h case    7:*/		return 0x820F8FB8;
		  /* 820F8FB8h */ case    8:  		/* lwz R9, <#[R5 + 16]> */
		/* 820F8FB8h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000010) );
		/* 820F8FB8h case    8:*/		return 0x820F8FBC;
		  /* 820F8FBCh */ case    9:  		/* lwz R9, <#[R9]> */
		/* 820F8FBCh case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 820F8FBCh case    9:*/		return 0x820F8FC0;
		  /* 820F8FC0h */ case   10:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820F8FC0h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820F8FC0h case   10:*/		return 0x820F8FC4;
		  /* 820F8FC4h */ case   11:  		/* lwzx R11, <#[R9 + R11]> */
		/* 820F8FC4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820F8FC4h case   11:*/		return 0x820F8FC8;
		  /* 820F8FC8h */ case   12:  		/* lwz R11, <#[R11 + 4]> */
		/* 820F8FC8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820F8FC8h case   12:*/		return 0x820F8FCC;
		  /* 820F8FCCh */ case   13:  		/* cmplw CR6, R10, R11 */
		/* 820F8FCCh case   13:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820F8FCCh case   13:*/		return 0x820F8FD0;
		  /* 820F8FD0h */ case   14:  		/* bc 4, CR6_EQ, 20 */
		/* 820F8FD0h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820F8FE4;  }
		/* 820F8FD0h case   14:*/		return 0x820F8FD4;
		  /* 820F8FD4h */ case   15:  		/* li R5, 0 */
		/* 820F8FD4h case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F8FD4h case   15:*/		return 0x820F8FD8;
		  /* 820F8FD8h */ case   16:  		/* li R4, 46 */
		/* 820F8FD8h case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x2E);
		/* 820F8FD8h case   16:*/		return 0x820F8FDC;
		  /* 820F8FDCh */ case   17:  		/* bl -1604 */
		/* 820F8FDCh case   17:*/		regs.LR = 0x820F8FE0; return 0x820F8998;
		/* 820F8FDCh case   17:*/		return 0x820F8FE0;
		  /* 820F8FE0h */ case   18:  		/* b 380 */
		/* 820F8FE0h case   18:*/		return 0x820F915C;
		/* 820F8FE0h case   18:*/		return 0x820F8FE4;
	}
	return 0x820F8FE4;
} // Block from 820F8F98h-820F8FE4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820F8FE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F8FE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F8FE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F8FE4);
		  /* 820F8FE4h */ case    0:  		/* lwz R11, <#[R3 + 108]> */
		/* 820F8FE4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000006C) );
		/* 820F8FE4h case    0:*/		return 0x820F8FE8;
		  /* 820F8FE8h */ case    1:  		/* li R31, 0 */
		/* 820F8FE8h case    1:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820F8FE8h case    1:*/		return 0x820F8FEC;
		  /* 820F8FECh */ case    2:  		/* rlwinm. R11, R11, 0, 21, 21 */
		/* 820F8FECh case    2:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R11,regs.R11);
		/* 820F8FECh case    2:*/		return 0x820F8FF0;
		  /* 820F8FF0h */ case    3:  		/* bc 4, CR0_EQ, 200 */
		/* 820F8FF0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820F90B8;  }
		/* 820F8FF0h case    3:*/		return 0x820F8FF4;
		  /* 820F8FF4h */ case    4:  		/* lwz R6, <#[R5 + 12]> */
		/* 820F8FF4h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R5 + 0x0000000C) );
		/* 820F8FF4h case    4:*/		return 0x820F8FF8;
		  /* 820F8FF8h */ case    5:  		/* mr R7, R31 */
		/* 820F8FF8h case    5:*/		regs.R7 = regs.R31;
		/* 820F8FF8h case    5:*/		return 0x820F8FFC;
		  /* 820F8FFCh */ case    6:  		/* cmplwi CR6, R6, 0 */
		/* 820F8FFCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820F8FFCh case    6:*/		return 0x820F9000;
		  /* 820F9000h */ case    7:  		/* bc 12, CR6_EQ, 168 */
		/* 820F9000h case    7:*/		if ( regs.CR[6].eq ) { return 0x820F90A8;  }
		/* 820F9000h case    7:*/		return 0x820F9004;
		  /* 820F9004h */ case    8:  		/* lwz R8, <#[R3 + 20]> */
		/* 820F9004h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000014) );
		/* 820F9004h case    8:*/		return 0x820F9008;
		  /* 820F9008h */ case    9:  		/* mr R9, R31 */
		/* 820F9008h case    9:*/		regs.R9 = regs.R31;
		/* 820F9008h case    9:*/		return 0x820F900C;
		  /* 820F900Ch */ case   10:  		/* lwz R11, <#[R3 + 260]> */
		/* 820F900Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000104) );
		/* 820F900Ch case   10:*/		return 0x820F9010;
		  /* 820F9010h */ case   11:  		/* lwz R10, <#[R11 + 8]> */
		/* 820F9010h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820F9010h case   11:*/		return 0x820F9014;
		  /* 820F9014h */ case   12:  		/* lwz R11, <#[R11 + 16]> */
		/* 820F9014h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820F9014h case   12:*/		return 0x820F9018;
		  /* 820F9018h */ case   13:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820F9018h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820F9018h case   13:*/		return 0x820F901C;
		  /* 820F901Ch */ case   14:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820F901Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F901Ch case   14:*/		return 0x820F9020;
		  /* 820F9020h */ case   15:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F9020h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F9020h case   15:*/		return 0x820F9024;
		  /* 820F9024h */ case   16:  		/* rlwinm R4, R11, 2, 0, 29 */
		/* 820F9024h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R11);
		/* 820F9024h case   16:*/		return 0x820F9028;
		  /* 820F9028h */ case   17:  		/* lwzx R11, <#[R10 + R8]> */
		/* 820F9028h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820F9028h case   17:*/		return 0x820F902C;
		  /* 820F902Ch */ case   18:  		/* lwzx R10, <#[R4 + R8]> */
		/* 820F902Ch case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + regs.R8 + 0x00000000) );
		/* 820F902Ch case   18:*/		return 0x820F9030;
		  /* 820F9030h */ case   19:  		/* lwz R4, <#[R11 + 4]> */
		/* 820F9030h case   19:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 820F9030h case   19:*/		return 0x820F9034;
		  /* 820F9034h */ case   20:  		/* lwz R30, <#[R10 + 4]> */
		/* 820F9034h case   20:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + 0x00000004) );
		/* 820F9034h case   20:*/		return 0x820F9038;
		  /* 820F9038h */ case   21:  		/* cmplw CR6, R30, R4 */
		/* 820F9038h case   21:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R4);
		/* 820F9038h case   21:*/		return 0x820F903C;
		  /* 820F903Ch */ case   22:  		/* bc 4, CR6_EQ, 108 */
		/* 820F903Ch case   22:*/		if ( !regs.CR[6].eq ) { return 0x820F90A8;  }
		/* 820F903Ch case   22:*/		return 0x820F9040;
		  /* 820F9040h */ case   23:  		/* lwz R4, <#[R10 + 8]> */
		/* 820F9040h case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000008) );
		/* 820F9040h case   23:*/		return 0x820F9044;
		  /* 820F9044h */ case   24:  		/* lwz R30, <#[R11 + 8]> */
		/* 820F9044h case   24:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000008) );
		/* 820F9044h case   24:*/		return 0x820F9048;
		  /* 820F9048h */ case   25:  		/* cmplw CR6, R4, R30 */
		/* 820F9048h case   25:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R30);
		/* 820F9048h case   25:*/		return 0x820F904C;
		  /* 820F904Ch */ case   26:  		/* bc 4, CR6_EQ, 92 */
		/* 820F904Ch case   26:*/		if ( !regs.CR[6].eq ) { return 0x820F90A8;  }
		/* 820F904Ch case   26:*/		return 0x820F9050;
		  /* 820F9050h */ case   27:  		/* lwz R4, <#[R10 + 12]> */
		/* 820F9050h case   27:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x0000000C) );
		/* 820F9050h case   27:*/		return 0x820F9054;
		  /* 820F9054h */ case   28:  		/* lwz R30, <#[R11 + 12]> */
		/* 820F9054h case   28:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F9054h case   28:*/		return 0x820F9058;
		  /* 820F9058h */ case   29:  		/* cmplw CR6, R4, R30 */
		/* 820F9058h case   29:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R30);
		/* 820F9058h case   29:*/		return 0x820F905C;
		  /* 820F905Ch */ case   30:  		/* bc 4, CR6_EQ, 76 */
		/* 820F905Ch case   30:*/		if ( !regs.CR[6].eq ) { return 0x820F90A8;  }
		/* 820F905Ch case   30:*/		return 0x820F9060;
		  /* 820F9060h */ case   31:  		/* lwz R4, <#[R10 + 16]> */
		/* 820F9060h case   31:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000010) );
		/* 820F9060h case   31:*/		return 0x820F9064;
		  /* 820F9064h */ case   32:  		/* lwz R30, <#[R11 + 16]> */
		/* 820F9064h case   32:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000010) );
		/* 820F9064h case   32:*/		return 0x820F9068;
		  /* 820F9068h */ case   33:  		/* cmplw CR6, R4, R30 */
		/* 820F9068h case   33:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R30);
		/* 820F9068h case   33:*/		return 0x820F906C;
		  /* 820F906Ch */ case   34:  		/* bc 4, CR6_EQ, 60 */
		/* 820F906Ch case   34:*/		if ( !regs.CR[6].eq ) { return 0x820F90A8;  }
		/* 820F906Ch case   34:*/		return 0x820F9070;
		  /* 820F9070h */ case   35:  		/* lwz R4, <#[R10 + 60]> */
		/* 820F9070h case   35:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x0000003C) );
		/* 820F9070h case   35:*/		return 0x820F9074;
		  /* 820F9074h */ case   36:  		/* lwz R11, <#[R11 + 60]> */
		/* 820F9074h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000003C) );
		/* 820F9074h case   36:*/		return 0x820F9078;
		  /* 820F9078h */ case   37:  		/* cmplw CR6, R4, R11 */
		/* 820F9078h case   37:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 820F9078h case   37:*/		return 0x820F907C;
		  /* 820F907Ch */ case   38:  		/* bc 4, CR6_EQ, 44 */
		/* 820F907Ch case   38:*/		if ( !regs.CR[6].eq ) { return 0x820F90A8;  }
		/* 820F907Ch case   38:*/		return 0x820F9080;
		  /* 820F9080h */ case   39:  		/* lwz R11, <#[R3 + 204]> */
		/* 820F9080h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000CC) );
		/* 820F9080h case   39:*/		return 0x820F9084;
		  /* 820F9084h */ case   40:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 820F9084h case   40:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 820F9084h case   40:*/		return 0x820F9088;
		  /* 820F9088h */ case   41:  		/* bc 12, CR0_EQ, 16 */
		/* 820F9088h case   41:*/		if ( regs.CR[0].eq ) { return 0x820F9098;  }
		/* 820F9088h case   41:*/		return 0x820F908C;
		  /* 820F908Ch */ case   42:  		/* lwz R11, <#[R10 + 96]> */
		/* 820F908Ch case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000060) );
		/* 820F908Ch case   42:*/		return 0x820F9090;
		  /* 820F9090h */ case   43:  		/* cmplwi CR6, R11, 0 */
		/* 820F9090h case   43:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F9090h case   43:*/		return 0x820F9094;
		  /* 820F9094h */ case   44:  		/* bc 4, CR6_EQ, 20 */
		/* 820F9094h case   44:*/		if ( !regs.CR[6].eq ) { return 0x820F90A8;  }
		/* 820F9094h case   44:*/		return 0x820F9098;
	}
	return 0x820F9098;
} // Block from 820F8FE4h-820F9098h (45 instructions)

//////////////////////////////////////////////////////
// Block at 820F9098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9098);
		  /* 820F9098h */ case    0:  		/* addi R7, R7, 1 */
		/* 820F9098h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820F9098h case    0:*/		return 0x820F909C;
		  /* 820F909Ch */ case    1:  		/* addi R9, R9, 4 */
		/* 820F909Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820F909Ch case    1:*/		return 0x820F90A0;
		  /* 820F90A0h */ case    2:  		/* cmplw CR6, R7, R6 */
		/* 820F90A0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 820F90A0h case    2:*/		return 0x820F90A4;
		  /* 820F90A4h */ case    3:  		/* bc 12, CR6_LT, -152 */
		/* 820F90A4h case    3:*/		if ( regs.CR[6].lt ) { return 0x820F900C;  }
		/* 820F90A4h case    3:*/		return 0x820F90A8;
	}
	return 0x820F90A8;
} // Block from 820F9098h-820F90A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F90A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F90A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F90A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F90A8);
		  /* 820F90A8h */ case    0:  		/* cmplw CR6, R7, R6 */
		/* 820F90A8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 820F90A8h case    0:*/		return 0x820F90AC;
		  /* 820F90ACh */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820F90ACh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F90B8;  }
		/* 820F90ACh case    1:*/		return 0x820F90B0;
		  /* 820F90B0h */ case    2:  		/* li R3, 0 */
		/* 820F90B0h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F90B0h case    2:*/		return 0x820F90B4;
		  /* 820F90B4h */ case    3:  		/* b 168 */
		/* 820F90B4h case    3:*/		return 0x820F915C;
		/* 820F90B4h case    3:*/		return 0x820F90B8;
	}
	return 0x820F90B8;
} // Block from 820F90A8h-820F90B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F90B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F90B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F90B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F90B8);
		  /* 820F90B8h */ case    0:  		/* lwz R11, <#[R5 + 12]> */
		/* 820F90B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x0000000C) );
		/* 820F90B8h case    0:*/		return 0x820F90BC;
		  /* 820F90BCh */ case    1:  		/* mr R6, R31 */
		/* 820F90BCh case    1:*/		regs.R6 = regs.R31;
		/* 820F90BCh case    1:*/		return 0x820F90C0;
		  /* 820F90C0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820F90C0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F90C0h case    2:*/		return 0x820F90C4;
		  /* 820F90C4h */ case    3:  		/* bc 4, CR6_GT, 100 */
		/* 820F90C4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820F9128;  }
		/* 820F90C4h case    3:*/		return 0x820F90C8;
		  /* 820F90C8h */ case    4:  		/* mr R11, R31 */
		/* 820F90C8h case    4:*/		regs.R11 = regs.R31;
		/* 820F90C8h case    4:*/		return 0x820F90CC;
		  /* 820F90CCh */ case    5:  		/* lwz R10, <#[R3 + 260]> */
		/* 820F90CCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000104) );
		/* 820F90CCh case    5:*/		return 0x820F90D0;
		  /* 820F90D0h */ case    6:  		/* lwz R9, <#[R3 + 20]> */
		/* 820F90D0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 820F90D0h case    6:*/		return 0x820F90D4;
		  /* 820F90D4h */ case    7:  		/* lwz R8, <#[R10 + 16]> */
		/* 820F90D4h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000010) );
		/* 820F90D4h case    7:*/		return 0x820F90D8;
		  /* 820F90D8h */ case    8:  		/* lwzx R8, <#[R8 + R11]> */
		/* 820F90D8h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 820F90D8h case    8:*/		return 0x820F90DC;
		  /* 820F90DCh */ case    9:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820F90DCh case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820F90DCh case    9:*/		return 0x820F90E0;
		  /* 820F90E0h */ case   10:  		/* lwzx R8, <#[R8 + R9]> */
		/* 820F90E0h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 820F90E0h case   10:*/		return 0x820F90E4;
		  /* 820F90E4h */ case   11:  		/* lwz R7, <#[R8]> */
		/* 820F90E4h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x00000000) );
		/* 820F90E4h case   11:*/		return 0x820F90E8;
		  /* 820F90E8h */ case   12:  		/* rlwinm. R5, R7, 0, 4, 6 */
		/* 820F90E8h case   12:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R5,regs.R7);
		/* 820F90E8h case   12:*/		return 0x820F90EC;
		  /* 820F90ECh */ case   13:  		/* bc 4, CR0_EQ, 36 */
		/* 820F90ECh case   13:*/		if ( !regs.CR[0].eq ) { return 0x820F9110;  }
		/* 820F90ECh case   13:*/		return 0x820F90F0;
		  /* 820F90F0h */ case   14:  		/* lwz R10, <#[R10 + 8]> */
		/* 820F90F0h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820F90F0h case   14:*/		return 0x820F90F4;
		  /* 820F90F4h */ case   15:  		/* lwzx R10, <#[R10 + R11]> */
		/* 820F90F4h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820F90F4h case   15:*/		return 0x820F90F8;
		  /* 820F90F8h */ case   16:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F90F8h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F90F8h case   16:*/		return 0x820F90FC;
		  /* 820F90FCh */ case   17:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820F90FCh case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820F90FCh case   17:*/		return 0x820F9100;
		  /* 820F9100h */ case   18:  		/* lwz R10, <#[R10]> */
		/* 820F9100h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820F9100h case   18:*/		return 0x820F9104;
		  /* 820F9104h */ case   19:  		/* rlwinm R10, R10, 0, 4, 6 */
		/* 820F9104h case   19:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R10,regs.R10);
		/* 820F9104h case   19:*/		return 0x820F9108;
		  /* 820F9108h */ case   20:  		/* or R10, R10, R7 */
		/* 820F9108h case   20:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 820F9108h case   20:*/		return 0x820F910C;
		  /* 820F910Ch */ case   21:  		/* stw R10, <#[R8]> */
		/* 820F910Ch case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 820F910Ch case   21:*/		return 0x820F9110;
	}
	return 0x820F9110;
} // Block from 820F90B8h-820F9110h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820F9110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9110);
		  /* 820F9110h */ case    0:  		/* lwz R10, <#[R3 + 260]> */
		/* 820F9110h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000104) );
		/* 820F9110h case    0:*/		return 0x820F9114;
		  /* 820F9114h */ case    1:  		/* addi R6, R6, 1 */
		/* 820F9114h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820F9114h case    1:*/		return 0x820F9118;
		  /* 820F9118h */ case    2:  		/* addi R11, R11, 4 */
		/* 820F9118h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F9118h case    2:*/		return 0x820F911C;
		  /* 820F911Ch */ case    3:  		/* lwz R10, <#[R10 + 12]> */
		/* 820F911Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 820F911Ch case    3:*/		return 0x820F9120;
		  /* 820F9120h */ case    4:  		/* cmplw CR6, R6, R10 */
		/* 820F9120h case    4:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 820F9120h case    4:*/		return 0x820F9124;
		  /* 820F9124h */ case    5:  		/* bc 12, CR6_LT, -88 */
		/* 820F9124h case    5:*/		if ( regs.CR[6].lt ) { return 0x820F90CC;  }
		/* 820F9124h case    5:*/		return 0x820F9128;
	}
	return 0x820F9128;
} // Block from 820F9110h-820F9128h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F9128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9128);
		  /* 820F9128h */ case    0:  		/* lwz R11, <#[R3 + 260]> */
		/* 820F9128h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000104) );
		/* 820F9128h case    0:*/		return 0x820F912C;
		  /* 820F912Ch */ case    1:  		/* li R9, 0 */
		/* 820F912Ch case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F912Ch case    1:*/		return 0x820F9130;
		  /* 820F9130h */ case    2:  		/* li R8, 0 */
		/* 820F9130h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F9130h case    2:*/		return 0x820F9134;
		  /* 820F9134h */ case    3:  		/* stw R31, <#[R1 + 108]> */
		/* 820F9134h case    3:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x0000006C) );
		/* 820F9134h case    3:*/		return 0x820F9138;
	}
	return 0x820F9138;
} // Block from 820F9128h-820F9138h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F9138h
// Function '?EmitInstSimple@CShaderProgram@D3DXShader@@IAAJKH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9138);
		  /* 820F9138h */ case    0:  		/* li R4, 1 */
		/* 820F9138h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820F9138h case    0:*/		return 0x820F913C;
		  /* 820F913Ch */ case    1:  		/* stw R31, <#[R1 + 100]> */
		/* 820F913Ch case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000064) );
		/* 820F913Ch case    1:*/		return 0x820F9140;
		  /* 820F9140h */ case    2:  		/* stw R31, <#[R1 + 92]> */
		/* 820F9140h case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F9140h case    2:*/		return 0x820F9144;
		  /* 820F9144h */ case    3:  		/* stw R31, <#[R1 + 84]> */
		/* 820F9144h case    3:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 820F9144h case    3:*/		return 0x820F9148;
		  /* 820F9148h */ case    4:  		/* lwz R6, <#[R11 + 12]> */
		/* 820F9148h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F9148h case    4:*/		return 0x820F914C;
		  /* 820F914Ch */ case    5:  		/* lwz R7, <#[R11 + 8]> */
		/* 820F914Ch case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000008) );
		/* 820F914Ch case    5:*/		return 0x820F9150;
		  /* 820F9150h */ case    6:  		/* mr R10, R6 */
		/* 820F9150h case    6:*/		regs.R10 = regs.R6;
		/* 820F9150h case    6:*/		return 0x820F9154;
		  /* 820F9154h */ case    7:  		/* lwz R5, <#[R11 + 16]> */
		/* 820F9154h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000010) );
		/* 820F9154h case    7:*/		return 0x820F9158;
		  /* 820F9158h */ case    8:  		/* bl -11768 */
		/* 820F9158h case    8:*/		regs.LR = 0x820F915C; return 0x820F6360;
		/* 820F9158h case    8:*/		return 0x820F915C;
	}
	return 0x820F915C;
} // Block from 820F9138h-820F915Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F915Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F915C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F915C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F915C);
		  /* 820F915Ch */ case    0:  		/* addi R1, R1, 144 */
		/* 820F915Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820F915Ch case    0:*/		return 0x820F9160;
		  /* 820F9160h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820F9160h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F9160h case    1:*/		return 0x820F9164;
		  /* 820F9164h */ case    2:  		/* mtspr LR, R12 */
		/* 820F9164h case    2:*/		regs.LR = regs.R12;
		/* 820F9164h case    2:*/		return 0x820F9168;
		  /* 820F9168h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820F9168h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820F9168h case    3:*/		return 0x820F916C;
		  /* 820F916Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820F916Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F916Ch case    4:*/		return 0x820F9170;
		  /* 820F9170h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820F9170h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F9170h case    5:*/		return 0x820F9174;
	}
	return 0x820F9174;
} // Block from 820F915Ch-820F9174h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F9174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9174);
		  /* 820F9174h */ case    0:  		/* nop */
		/* 820F9174h case    0:*/		cpu::op::nop();
		/* 820F9174h case    0:*/		return 0x820F9178;
	}
	return 0x820F9178;
} // Block from 820F9174h-820F9178h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F9178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9178);
		  /* 820F9178h */ case    0:  		/* li R5, 0 */
		/* 820F9178h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F9178h case    0:*/		return 0x820F917C;
		  /* 820F917Ch */ case    1:  		/* li R4, 91 */
		/* 820F917Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x5B);
		/* 820F917Ch case    1:*/		return 0x820F9180;
		  /* 820F9180h */ case    2:  		/* b -2024 */
		/* 820F9180h case    2:*/		return 0x820F8998;
		/* 820F9180h case    2:*/		return 0x820F9184;
		  /* 820F9184h */ case    3:  		/* nop */
		/* 820F9184h case    3:*/		cpu::op::nop();
		/* 820F9184h case    3:*/		return 0x820F9188;
	}
	return 0x820F9188;
} // Block from 820F9178h-820F9188h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F9188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9188);
		  /* 820F9188h */ case    0:  		/* li R5, 0 */
		/* 820F9188h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F9188h case    0:*/		return 0x820F918C;
		  /* 820F918Ch */ case    1:  		/* li R4, 92 */
		/* 820F918Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x5C);
		/* 820F918Ch case    1:*/		return 0x820F9190;
		  /* 820F9190h */ case    2:  		/* b -2040 */
		/* 820F9190h case    2:*/		return 0x820F8998;
		/* 820F9190h case    2:*/		return 0x820F9194;
		  /* 820F9194h */ case    3:  		/* nop */
		/* 820F9194h case    3:*/		cpu::op::nop();
		/* 820F9194h case    3:*/		return 0x820F9198;
	}
	return 0x820F9198;
} // Block from 820F9188h-820F9198h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F9198h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9198);
		  /* 820F9198h */ case    0:  		/* lwz R11, <#[R3 + 260]> */
		/* 820F9198h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000104) );
		/* 820F9198h case    0:*/		return 0x820F919C;
		  /* 820F919Ch */ case    1:  		/* li R10, 0 */
		/* 820F919Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820F919Ch case    1:*/		return 0x820F91A0;
		  /* 820F91A0h */ case    2:  		/* li R9, 0 */
		/* 820F91A0h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F91A0h case    2:*/		return 0x820F91A4;
		  /* 820F91A4h */ case    3:  		/* li R4, 6 */
		/* 820F91A4h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x6);
		/* 820F91A4h case    3:*/		return 0x820F91A8;
		  /* 820F91A8h */ case    4:  		/* lwz R8, <#[R11 + 4]> */
		/* 820F91A8h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 820F91A8h case    4:*/		return 0x820F91AC;
		  /* 820F91ACh */ case    5:  		/* lwz R7, <#[R11 + 12]> */
		/* 820F91ACh case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F91ACh case    5:*/		return 0x820F91B0;
		  /* 820F91B0h */ case    6:  		/* lwz R6, <#[R11 + 8]> */
		/* 820F91B0h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000008) );
		/* 820F91B0h case    6:*/		return 0x820F91B4;
		  /* 820F91B4h */ case    7:  		/* lwz R5, <#[R11 + 16]> */
		/* 820F91B4h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000010) );
		/* 820F91B4h case    7:*/		return 0x820F91B8;
		  /* 820F91B8h */ case    8:  		/* b -1792 */
		/* 820F91B8h case    8:*/		return 0x820F8AB8;
		/* 820F91B8h case    8:*/		return 0x820F91BC;
		  /* 820F91BCh */ case    9:  		/* nop */
		/* 820F91BCh case    9:*/		cpu::op::nop();
		/* 820F91BCh case    9:*/		return 0x820F91C0;
	}
	return 0x820F91C0;
} // Block from 820F9198h-820F91C0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F91C0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F91C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F91C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F91C0);
		  /* 820F91C0h */ case    0:  		/* li R5, 0 */
		/* 820F91C0h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F91C0h case    0:*/		return 0x820F91C4;
		  /* 820F91C4h */ case    1:  		/* li R4, 19 */
		/* 820F91C4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x13);
		/* 820F91C4h case    1:*/		return 0x820F91C8;
		  /* 820F91C8h */ case    2:  		/* b -2096 */
		/* 820F91C8h case    2:*/		return 0x820F8998;
		/* 820F91C8h case    2:*/		return 0x820F91CC;
		  /* 820F91CCh */ case    3:  		/* nop */
		/* 820F91CCh case    3:*/		cpu::op::nop();
		/* 820F91CCh case    3:*/		return 0x820F91D0;
	}
	return 0x820F91D0;
} // Block from 820F91C0h-820F91D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F91D0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F91D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F91D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F91D0);
		  /* 820F91D0h */ case    0:  		/* lwz R11, <#[R3 + 260]> */
		/* 820F91D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000104) );
		/* 820F91D0h case    0:*/		return 0x820F91D4;
		  /* 820F91D4h */ case    1:  		/* li R10, 0 */
		/* 820F91D4h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820F91D4h case    1:*/		return 0x820F91D8;
		  /* 820F91D8h */ case    2:  		/* li R9, 0 */
		/* 820F91D8h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F91D8h case    2:*/		return 0x820F91DC;
		  /* 820F91DCh */ case    3:  		/* li R4, 14 */
		/* 820F91DCh case    3:*/		cpu::op::li<0>(regs,&regs.R4,0xE);
		/* 820F91DCh case    3:*/		return 0x820F91E0;
		  /* 820F91E0h */ case    4:  		/* lwz R8, <#[R11 + 4]> */
		/* 820F91E0h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 820F91E0h case    4:*/		return 0x820F91E4;
		  /* 820F91E4h */ case    5:  		/* lwz R7, <#[R11 + 12]> */
		/* 820F91E4h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F91E4h case    5:*/		return 0x820F91E8;
		  /* 820F91E8h */ case    6:  		/* lwz R6, <#[R11 + 8]> */
		/* 820F91E8h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000008) );
		/* 820F91E8h case    6:*/		return 0x820F91EC;
		  /* 820F91ECh */ case    7:  		/* lwz R5, <#[R11 + 16]> */
		/* 820F91ECh case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000010) );
		/* 820F91ECh case    7:*/		return 0x820F91F0;
		  /* 820F91F0h */ case    8:  		/* b -1848 */
		/* 820F91F0h case    8:*/		return 0x820F8AB8;
		/* 820F91F0h case    8:*/		return 0x820F91F4;
		  /* 820F91F4h */ case    9:  		/* nop */
		/* 820F91F4h case    9:*/		cpu::op::nop();
		/* 820F91F4h case    9:*/		return 0x820F91F8;
	}
	return 0x820F91F8;
} // Block from 820F91D0h-820F91F8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F91F8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F91F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F91F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F91F8);
		  /* 820F91F8h */ case    0:  		/* lwz R11, <#[R3 + 260]> */
		/* 820F91F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000104) );
		/* 820F91F8h case    0:*/		return 0x820F91FC;
		  /* 820F91FCh */ case    1:  		/* li R10, 0 */
		/* 820F91FCh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820F91FCh case    1:*/		return 0x820F9200;
		  /* 820F9200h */ case    2:  		/* li R9, 0 */
		/* 820F9200h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F9200h case    2:*/		return 0x820F9204;
		  /* 820F9204h */ case    3:  		/* li R4, 15 */
		/* 820F9204h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0xF);
		/* 820F9204h case    3:*/		return 0x820F9208;
		  /* 820F9208h */ case    4:  		/* lwz R8, <#[R11 + 4]> */
		/* 820F9208h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 820F9208h case    4:*/		return 0x820F920C;
		  /* 820F920Ch */ case    5:  		/* lwz R7, <#[R11 + 12]> */
		/* 820F920Ch case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F920Ch case    5:*/		return 0x820F9210;
		  /* 820F9210h */ case    6:  		/* lwz R6, <#[R11 + 8]> */
		/* 820F9210h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000008) );
		/* 820F9210h case    6:*/		return 0x820F9214;
		  /* 820F9214h */ case    7:  		/* lwz R5, <#[R11 + 16]> */
		/* 820F9214h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000010) );
		/* 820F9214h case    7:*/		return 0x820F9218;
		  /* 820F9218h */ case    8:  		/* b -1888 */
		/* 820F9218h case    8:*/		return 0x820F8AB8;
		/* 820F9218h case    8:*/		return 0x820F921C;
		  /* 820F921Ch */ case    9:  		/* nop */
		/* 820F921Ch case    9:*/		cpu::op::nop();
		/* 820F921Ch case    9:*/		return 0x820F9220;
	}
	return 0x820F9220;
} // Block from 820F91F8h-820F9220h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F9220h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9220);
		  /* 820F9220h */ case    0:  		/* lwz R11, <#[R3 + 260]> */
		/* 820F9220h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000104) );
		/* 820F9220h case    0:*/		return 0x820F9224;
		  /* 820F9224h */ case    1:  		/* li R10, 0 */
		/* 820F9224h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820F9224h case    1:*/		return 0x820F9228;
		  /* 820F9228h */ case    2:  		/* li R9, 0 */
		/* 820F9228h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F9228h case    2:*/		return 0x820F922C;
		  /* 820F922Ch */ case    3:  		/* li R4, 7 */
		/* 820F922Ch case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x7);
		/* 820F922Ch case    3:*/		return 0x820F9230;
		  /* 820F9230h */ case    4:  		/* lwz R8, <#[R11 + 4]> */
		/* 820F9230h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 820F9230h case    4:*/		return 0x820F9234;
		  /* 820F9234h */ case    5:  		/* lwz R7, <#[R11 + 12]> */
		/* 820F9234h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F9234h case    5:*/		return 0x820F9238;
		  /* 820F9238h */ case    6:  		/* lwz R6, <#[R11 + 8]> */
		/* 820F9238h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000008) );
		/* 820F9238h case    6:*/		return 0x820F923C;
		  /* 820F923Ch */ case    7:  		/* lwz R5, <#[R11 + 16]> */
		/* 820F923Ch case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000010) );
		/* 820F923Ch case    7:*/		return 0x820F9240;
		  /* 820F9240h */ case    8:  		/* b -1928 */
		/* 820F9240h case    8:*/		return 0x820F8AB8;
		/* 820F9240h case    8:*/		return 0x820F9244;
		  /* 820F9244h */ case    9:  		/* nop */
		/* 820F9244h case    9:*/		cpu::op::nop();
		/* 820F9244h case    9:*/		return 0x820F9248;
	}
	return 0x820F9248;
} // Block from 820F9220h-820F9248h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F9248h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9248);
		  /* 820F9248h */ case    0:  		/* li R5, 0 */
		/* 820F9248h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F9248h case    0:*/		return 0x820F924C;
		  /* 820F924Ch */ case    1:  		/* li R4, 10 */
		/* 820F924Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xA);
		/* 820F924Ch case    1:*/		return 0x820F9250;
		  /* 820F9250h */ case    2:  		/* b -2232 */
		/* 820F9250h case    2:*/		return 0x820F8998;
		/* 820F9250h case    2:*/		return 0x820F9254;
		  /* 820F9254h */ case    3:  		/* nop */
		/* 820F9254h case    3:*/		cpu::op::nop();
		/* 820F9254h case    3:*/		return 0x820F9258;
	}
	return 0x820F9258;
} // Block from 820F9248h-820F9258h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F9258h
// Function '?EmitInstScalar@CShaderProgram@D3DXShader@@IAAJKPAI0IIKH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9258);
		  /* 820F9258h */ case    0:  		/* li R5, 0 */
		/* 820F9258h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F9258h case    0:*/		return 0x820F925C;
		  /* 820F925Ch */ case    1:  		/* li R4, 11 */
		/* 820F925Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xB);
		/* 820F925Ch case    1:*/		return 0x820F9260;
		  /* 820F9260h */ case    2:  		/* b -2248 */
		/* 820F9260h case    2:*/		return 0x820F8998;
		/* 820F9260h case    2:*/		return 0x820F9264;
		  /* 820F9264h */ case    3:  		/* nop */
		/* 820F9264h case    3:*/		cpu::op::nop();
		/* 820F9264h case    3:*/		return 0x820F9268;
	}
	return 0x820F9268;
} // Block from 820F9258h-820F9268h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F9268h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9268);
		  /* 820F9268h */ case    0:  		/* li R5, 0 */
		/* 820F9268h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F9268h case    0:*/		return 0x820F926C;
		  /* 820F926Ch */ case    1:  		/* li R4, 12 */
		/* 820F926Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xC);
		/* 820F926Ch case    1:*/		return 0x820F9270;
		  /* 820F9270h */ case    2:  		/* b -2264 */
		/* 820F9270h case    2:*/		return 0x820F8998;
		/* 820F9270h case    2:*/		return 0x820F9274;
		  /* 820F9274h */ case    3:  		/* nop */
		/* 820F9274h case    3:*/		cpu::op::nop();
		/* 820F9274h case    3:*/		return 0x820F9278;
	}
	return 0x820F9278;
} // Block from 820F9268h-820F9278h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F9278h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9278);
		  /* 820F9278h */ case    0:  		/* li R5, 0 */
		/* 820F9278h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F9278h case    0:*/		return 0x820F927C;
		  /* 820F927Ch */ case    1:  		/* li R4, 13 */
		/* 820F927Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xD);
		/* 820F927Ch case    1:*/		return 0x820F9280;
		  /* 820F9280h */ case    2:  		/* b -2280 */
		/* 820F9280h case    2:*/		return 0x820F8998;
		/* 820F9280h case    2:*/		return 0x820F9284;
		  /* 820F9284h */ case    3:  		/* nop */
		/* 820F9284h case    3:*/		cpu::op::nop();
		/* 820F9284h case    3:*/		return 0x820F9288;
	}
	return 0x820F9288;
} // Block from 820F9278h-820F9288h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F9288h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9288);
		  /* 820F9288h */ case    0:  		/* li R5, 0 */
		/* 820F9288h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F9288h case    0:*/		return 0x820F928C;
		  /* 820F928Ch */ case    1:  		/* li R4, 2 */
		/* 820F928Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 820F928Ch case    1:*/		return 0x820F9290;
		  /* 820F9290h */ case    2:  		/* b -2296 */
		/* 820F9290h case    2:*/		return 0x820F8998;
		/* 820F9290h case    2:*/		return 0x820F9294;
		  /* 820F9294h */ case    3:  		/* nop */
		/* 820F9294h case    3:*/		cpu::op::nop();
		/* 820F9294h case    3:*/		return 0x820F9298;
	}
	return 0x820F9298;
} // Block from 820F9288h-820F9298h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F9298h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9298);
		  /* 820F9298h */ case    0:  		/* li R5, 0 */
		/* 820F9298h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F9298h case    0:*/		return 0x820F929C;
		  /* 820F929Ch */ case    1:  		/* li R4, 5 */
		/* 820F929Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x5);
		/* 820F929Ch case    1:*/		return 0x820F92A0;
		  /* 820F92A0h */ case    2:  		/* b -2312 */
		/* 820F92A0h case    2:*/		return 0x820F8998;
		/* 820F92A0h case    2:*/		return 0x820F92A4;
		  /* 820F92A4h */ case    3:  		/* nop */
		/* 820F92A4h case    3:*/		cpu::op::nop();
		/* 820F92A4h case    3:*/		return 0x820F92A8;
	}
	return 0x820F92A8;
} // Block from 820F9298h-820F92A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F92A8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F92A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F92A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F92A8);
		  /* 820F92A8h */ case    0:  		/* li R5, 0 */
		/* 820F92A8h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F92A8h case    0:*/		return 0x820F92AC;
		  /* 820F92ACh */ case    1:  		/* li R4, 17 */
		/* 820F92ACh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x11);
		/* 820F92ACh case    1:*/		return 0x820F92B0;
		  /* 820F92B0h */ case    2:  		/* b -2328 */
		/* 820F92B0h case    2:*/		return 0x820F8998;
		/* 820F92B0h case    2:*/		return 0x820F92B4;
		  /* 820F92B4h */ case    3:  		/* nop */
		/* 820F92B4h case    3:*/		cpu::op::nop();
		/* 820F92B4h case    3:*/		return 0x820F92B8;
	}
	return 0x820F92B8;
} // Block from 820F92A8h-820F92B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F92B8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F92B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F92B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F92B8);
		  /* 820F92B8h */ case    0:  		/* mfspr R12, LR */
		/* 820F92B8h case    0:*/		regs.R12 = regs.LR;
		/* 820F92B8h case    0:*/		return 0x820F92BC;
		  /* 820F92BCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820F92BCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F92BCh case    1:*/		return 0x820F92C0;
		  /* 820F92C0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820F92C0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820F92C0h case    2:*/		return 0x820F92C4;
		  /* 820F92C4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820F92C4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F92C4h case    3:*/		return 0x820F92C8;
		  /* 820F92C8h */ case    4:  		/* stwu R1, <#[R1 - 144]> */
		/* 820F92C8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820F92C8h case    4:*/		return 0x820F92CC;
		  /* 820F92CCh */ case    5:  		/* lwz R11, <#[R3 + 260]> */
		/* 820F92CCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000104) );
		/* 820F92CCh case    5:*/		return 0x820F92D0;
		  /* 820F92D0h */ case    6:  		/* mr R30, R3 */
		/* 820F92D0h case    6:*/		regs.R30 = regs.R3;
		/* 820F92D0h case    6:*/		return 0x820F92D4;
		  /* 820F92D4h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820F92D4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F92D4h case    7:*/		return 0x820F92D8;
		  /* 820F92D8h */ case    8:  		/* rlwinm R11, R11, 0, 12, 31 */
		/* 820F92D8h case    8:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R11);
		/* 820F92D8h case    8:*/		return 0x820F92DC;
		  /* 820F92DCh */ case    9:  		/* cmplwi CR6, R11, 1 */
		/* 820F92DCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820F92DCh case    9:*/		return 0x820F92E0;
		  /* 820F92E0h */ case   10:  		/* bc 12, CR6_EQ, 220 */
		/* 820F92E0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820F93BC;  }
		/* 820F92E0h case   10:*/		return 0x820F92E4;
		  /* 820F92E4h */ case   11:  		/* cmplwi CR6, R11, 3 */
		/* 820F92E4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820F92E4h case   11:*/		return 0x820F92E8;
		  /* 820F92E8h */ case   12:  		/* bc 12, CR6_EQ, 204 */
		/* 820F92E8h case   12:*/		if ( regs.CR[6].eq ) { return 0x820F93B4;  }
		/* 820F92E8h case   12:*/		return 0x820F92EC;
		  /* 820F92ECh */ case   13:  		/* cmplwi CR6, R11, 4 */
		/* 820F92ECh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 820F92ECh case   13:*/		return 0x820F92F0;
		  /* 820F92F0h */ case   14:  		/* bc 12, CR6_EQ, 188 */
		/* 820F92F0h case   14:*/		if ( regs.CR[6].eq ) { return 0x820F93AC;  }
		/* 820F92F0h case   14:*/		return 0x820F92F4;
		  /* 820F92F4h */ case   15:  		/* lwz R11, <#[R3]> */
		/* 820F92F4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F92F4h case   15:*/		return 0x820F92F8;
		  /* 820F92F8h */ case   16:  		/* li R8, 0 */
		/* 820F92F8h case   16:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F92F8h case   16:*/		return 0x820F92FC;
		  /* 820F92FCh */ case   17:  		/* li R7, 0 */
		/* 820F92FCh case   17:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820F92FCh case   17:*/		return 0x820F9300;
		  /* 820F9300h */ case   18:  		/* lwz R4, <#[R3 + 256]> */
		/* 820F9300h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000100) );
		/* 820F9300h case   18:*/		return 0x820F9304;
		  /* 820F9304h */ case   19:  		/* li R6, 2 */
		/* 820F9304h case   19:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 820F9304h case   19:*/		return 0x820F9308;
		  /* 820F9308h */ case   20:  		/* addi R5, R1, 112 */
		/* 820F9308h case   20:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820F9308h case   20:*/		return 0x820F930C;
		  /* 820F930Ch */ case   21:  		/* lwz R11, <#[R11 + 340]> */
		/* 820F930Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000154) );
		/* 820F930Ch case   21:*/		return 0x820F9310;
		  /* 820F9310h */ case   22:  		/* mtspr CTR, R11 */
		/* 820F9310h case   22:*/		regs.CTR = regs.R11;
		/* 820F9310h case   22:*/		return 0x820F9314;
		  /* 820F9314h */ case   23:  		/* bcctrl 20, CR0_LT */
		/* 820F9314h case   23:*/		if ( 1 ) { regs.LR = 0x820F9318; return (uint32)regs.CTR; }
		/* 820F9314h case   23:*/		return 0x820F9318;
		  /* 820F9318h */ case   24:  		/* cmpwi CR0, R3, 0 */
		/* 820F9318h case   24:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F9318h case   24:*/		return 0x820F931C;
		  /* 820F931Ch */ case   25:  		/* bc 12, CR0_LT, 176 */
		/* 820F931Ch case   25:*/		if ( regs.CR[0].lt ) { return 0x820F93CC;  }
		/* 820F931Ch case   25:*/		return 0x820F9320;
		  /* 820F9320h */ case   26:  		/* lwz R11, <#[R30 + 260]> */
		/* 820F9320h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000104) );
		/* 820F9320h case   26:*/		return 0x820F9324;
		  /* 820F9324h */ case   27:  		/* li R31, 0 */
		/* 820F9324h case   27:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820F9324h case   27:*/		return 0x820F9328;
		  /* 820F9328h */ case   28:  		/* li R10, 2 */
		/* 820F9328h case   28:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 820F9328h case   28:*/		return 0x820F932C;
		  /* 820F932Ch */ case   29:  		/* li R9, 0 */
		/* 820F932Ch case   29:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F932Ch case   29:*/		return 0x820F9330;
		  /* 820F9330h */ case   30:  		/* stw R31, <#[R1 + 108]> */
		/* 820F9330h case   30:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x0000006C) );
		/* 820F9330h case   30:*/		return 0x820F9334;
		  /* 820F9334h */ case   31:  		/* li R6, 2 */
		/* 820F9334h case   31:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 820F9334h case   31:*/		return 0x820F9338;
		  /* 820F9338h */ case   32:  		/* stw R31, <#[R1 + 100]> */
		/* 820F9338h case   32:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000064) );
		/* 820F9338h case   32:*/		return 0x820F933C;
		  /* 820F933Ch */ case   33:  		/* addi R5, R1, 112 */
		/* 820F933Ch case   33:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820F933Ch case   33:*/		return 0x820F9340;
		  /* 820F9340h */ case   34:  		/* stw R31, <#[R1 + 92]> */
		/* 820F9340h case   34:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F9340h case   34:*/		return 0x820F9344;
		  /* 820F9344h */ case   35:  		/* lwz R7, <#[R11 + 8]> */
		/* 820F9344h case   35:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000008) );
		/* 820F9344h case   35:*/		return 0x820F9348;
		  /* 820F9348h */ case   36:  		/* li R4, 5 */
		/* 820F9348h case   36:*/		cpu::op::li<0>(regs,&regs.R4,0x5);
		/* 820F9348h case   36:*/		return 0x820F934C;
		  /* 820F934Ch */ case   37:  		/* mr R3, R30 */
		/* 820F934Ch case   37:*/		regs.R3 = regs.R30;
		/* 820F934Ch case   37:*/		return 0x820F9350;
		  /* 820F9350h */ case   38:  		/* stw R31, <#[R1 + 84]> */
		/* 820F9350h case   38:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 820F9350h case   38:*/		return 0x820F9354;
		  /* 820F9354h */ case   39:  		/* addi R8, R7, 8 */
		/* 820F9354h case   39:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R7,0x8);
		/* 820F9354h case   39:*/		return 0x820F9358;
		  /* 820F9358h */ case   40:  		/* bl -12280 */
		/* 820F9358h case   40:*/		regs.LR = 0x820F935C; return 0x820F6360;
		/* 820F9358h case   40:*/		return 0x820F935C;
		  /* 820F935Ch */ case   41:  		/* cmpwi CR0, R3, 0 */
		/* 820F935Ch case   41:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F935Ch case   41:*/		return 0x820F9360;
		  /* 820F9360h */ case   42:  		/* bc 12, CR0_LT, 108 */
		/* 820F9360h case   42:*/		if ( regs.CR[0].lt ) { return 0x820F93CC;  }
		/* 820F9360h case   42:*/		return 0x820F9364;
		  /* 820F9364h */ case   43:  		/* lwz R11, <#[R30 + 260]> */
		/* 820F9364h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000104) );
		/* 820F9364h case   43:*/		return 0x820F9368;
		  /* 820F9368h */ case   44:  		/* li R10, 1 */
		/* 820F9368h case   44:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820F9368h case   44:*/		return 0x820F936C;
		  /* 820F936Ch */ case   45:  		/* li R9, 0 */
		/* 820F936Ch case   45:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F936Ch case   45:*/		return 0x820F9370;
		  /* 820F9370h */ case   46:  		/* stw R31, <#[R1 + 108]> */
		/* 820F9370h case   46:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x0000006C) );
		/* 820F9370h case   46:*/		return 0x820F9374;
		  /* 820F9374h */ case   47:  		/* addi R8, R1, 116 */
		/* 820F9374h case   47:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x74);
		/* 820F9374h case   47:*/		return 0x820F9378;
		  /* 820F9378h */ case   48:  		/* stw R31, <#[R1 + 100]> */
		/* 820F9378h case   48:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000064) );
		/* 820F9378h case   48:*/		return 0x820F937C;
		  /* 820F937Ch */ case   49:  		/* addi R7, R1, 112 */
		/* 820F937Ch case   49:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x70);
		/* 820F937Ch case   49:*/		return 0x820F9380;
		  /* 820F9380h */ case   50:  		/* stw R31, <#[R1 + 92]> */
		/* 820F9380h case   50:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F9380h case   50:*/		return 0x820F9384;
		  /* 820F9384h */ case   51:  		/* li R4, 2 */
		/* 820F9384h case   51:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 820F9384h case   51:*/		return 0x820F9388;
		  /* 820F9388h */ case   52:  		/* stw R31, <#[R1 + 84]> */
		/* 820F9388h case   52:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 820F9388h case   52:*/		return 0x820F938C;
		  /* 820F938Ch */ case   53:  		/* mr R3, R30 */
		/* 820F938Ch case   53:*/		regs.R3 = regs.R30;
		/* 820F938Ch case   53:*/		return 0x820F9390;
		  /* 820F9390h */ case   54:  		/* lwz R6, <#[R11 + 12]> */
		/* 820F9390h case   54:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F9390h case   54:*/		return 0x820F9394;
		  /* 820F9394h */ case   55:  		/* lwz R5, <#[R11 + 16]> */
		/* 820F9394h case   55:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000010) );
		/* 820F9394h case   55:*/		return 0x820F9398;
		  /* 820F9398h */ case   56:  		/* bl -12344 */
		/* 820F9398h case   56:*/		regs.LR = 0x820F939C; return 0x820F6360;
		/* 820F9398h case   56:*/		return 0x820F939C;
		  /* 820F939Ch */ case   57:  		/* cmpwi CR0, R3, 0 */
		/* 820F939Ch case   57:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F939Ch case   57:*/		return 0x820F93A0;
		  /* 820F93A0h */ case   58:  		/* bc 12, CR0_LT, 44 */
		/* 820F93A0h case   58:*/		if ( regs.CR[0].lt ) { return 0x820F93CC;  }
		/* 820F93A0h case   58:*/		return 0x820F93A4;
		  /* 820F93A4h */ case   59:  		/* li R3, 0 */
		/* 820F93A4h case   59:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F93A4h case   59:*/		return 0x820F93A8;
		  /* 820F93A8h */ case   60:  		/* b 36 */
		/* 820F93A8h case   60:*/		return 0x820F93CC;
		/* 820F93A8h case   60:*/		return 0x820F93AC;
	}
	return 0x820F93AC;
} // Block from 820F92B8h-820F93ACh (61 instructions)

//////////////////////////////////////////////////////
// Block at 820F93ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F93AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F93AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F93AC);
		  /* 820F93ACh */ case    0:  		/* li R4, 9 */
		/* 820F93ACh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x9);
		/* 820F93ACh case    0:*/		return 0x820F93B0;
		  /* 820F93B0h */ case    1:  		/* b 16 */
		/* 820F93B0h case    1:*/		return 0x820F93C0;
		/* 820F93B0h case    1:*/		return 0x820F93B4;
	}
	return 0x820F93B4;
} // Block from 820F93ACh-820F93B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F93B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F93B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F93B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F93B4);
		  /* 820F93B4h */ case    0:  		/* li R4, 8 */
		/* 820F93B4h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 820F93B4h case    0:*/		return 0x820F93B8;
		  /* 820F93B8h */ case    1:  		/* b 8 */
		/* 820F93B8h case    1:*/		return 0x820F93C0;
		/* 820F93B8h case    1:*/		return 0x820F93BC;
	}
	return 0x820F93BC;
} // Block from 820F93B4h-820F93BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F93BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F93BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F93BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F93BC);
		  /* 820F93BCh */ case    0:  		/* li R4, 5 */
		/* 820F93BCh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x5);
		/* 820F93BCh case    0:*/		return 0x820F93C0;
	}
	return 0x820F93C0;
} // Block from 820F93BCh-820F93C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F93C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F93C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F93C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F93C0);
		  /* 820F93C0h */ case    0:  		/* li R5, 0 */
		/* 820F93C0h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F93C0h case    0:*/		return 0x820F93C4;
		  /* 820F93C4h */ case    1:  		/* mr R3, R30 */
		/* 820F93C4h case    1:*/		regs.R3 = regs.R30;
		/* 820F93C4h case    1:*/		return 0x820F93C8;
		  /* 820F93C8h */ case    2:  		/* bl -2608 */
		/* 820F93C8h case    2:*/		regs.LR = 0x820F93CC; return 0x820F8998;
		/* 820F93C8h case    2:*/		return 0x820F93CC;
	}
	return 0x820F93CC;
} // Block from 820F93C0h-820F93CCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F93CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F93CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F93CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F93CC);
		  /* 820F93CCh */ case    0:  		/* addi R1, R1, 144 */
		/* 820F93CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820F93CCh case    0:*/		return 0x820F93D0;
		  /* 820F93D0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820F93D0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F93D0h case    1:*/		return 0x820F93D4;
		  /* 820F93D4h */ case    2:  		/* mtspr LR, R12 */
		/* 820F93D4h case    2:*/		regs.LR = regs.R12;
		/* 820F93D4h case    2:*/		return 0x820F93D8;
		  /* 820F93D8h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820F93D8h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820F93D8h case    3:*/		return 0x820F93DC;
		  /* 820F93DCh */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820F93DCh case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F93DCh case    4:*/		return 0x820F93E0;
		  /* 820F93E0h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820F93E0h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F93E0h case    5:*/		return 0x820F93E4;
	}
	return 0x820F93E4;
} // Block from 820F93CCh-820F93E4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F93E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F93E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F93E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F93E4);
		  /* 820F93E4h */ case    0:  		/* nop */
		/* 820F93E4h case    0:*/		cpu::op::nop();
		/* 820F93E4h case    0:*/		return 0x820F93E8;
	}
	return 0x820F93E8;
} // Block from 820F93E4h-820F93E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F93E8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F93E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F93E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F93E8);
		  /* 820F93E8h */ case    0:  		/* li R5, 0 */
		/* 820F93E8h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F93E8h case    0:*/		return 0x820F93EC;
		  /* 820F93ECh */ case    1:  		/* li R4, 16 */
		/* 820F93ECh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x10);
		/* 820F93ECh case    1:*/		return 0x820F93F0;
		  /* 820F93F0h */ case    2:  		/* b -2648 */
		/* 820F93F0h case    2:*/		return 0x820F8998;
		/* 820F93F0h case    2:*/		return 0x820F93F4;
		  /* 820F93F4h */ case    3:  		/* nop */
		/* 820F93F4h case    3:*/		cpu::op::nop();
		/* 820F93F4h case    3:*/		return 0x820F93F8;
	}
	return 0x820F93F8;
} // Block from 820F93E8h-820F93F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F93F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F93F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F93F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F93F8);
		  /* 820F93F8h */ case    0:  		/* li R5, 0 */
		/* 820F93F8h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F93F8h case    0:*/		return 0x820F93FC;
		  /* 820F93FCh */ case    1:  		/* li R4, 88 */
		/* 820F93FCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x58);
		/* 820F93FCh case    1:*/		return 0x820F9400;
		  /* 820F9400h */ case    2:  		/* b -2664 */
		/* 820F9400h case    2:*/		return 0x820F8998;
		/* 820F9400h case    2:*/		return 0x820F9404;
		  /* 820F9404h */ case    3:  		/* nop */
		/* 820F9404h case    3:*/		cpu::op::nop();
		/* 820F9404h case    3:*/		return 0x820F9408;
	}
	return 0x820F9408;
} // Block from 820F93F8h-820F9408h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F9408h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9408);
		  /* 820F9408h */ case    0:  		/* li R5, 0 */
		/* 820F9408h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F9408h case    0:*/		return 0x820F940C;
		  /* 820F940Ch */ case    1:  		/* li R4, 80 */
		/* 820F940Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x50);
		/* 820F940Ch case    1:*/		return 0x820F9410;
		  /* 820F9410h */ case    2:  		/* b -2680 */
		/* 820F9410h case    2:*/		return 0x820F8998;
		/* 820F9410h case    2:*/		return 0x820F9414;
		  /* 820F9414h */ case    3:  		/* nop */
		/* 820F9414h case    3:*/		cpu::op::nop();
		/* 820F9414h case    3:*/		return 0x820F9418;
	}
	return 0x820F9418;
} // Block from 820F9408h-820F9418h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F9418h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9418);
		  /* 820F9418h */ case    0:  		/* li R5, 0 */
		/* 820F9418h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F9418h case    0:*/		return 0x820F941C;
		  /* 820F941Ch */ case    1:  		/* li R4, 35 */
		/* 820F941Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x23);
		/* 820F941Ch case    1:*/		return 0x820F9420;
		  /* 820F9420h */ case    2:  		/* b -2696 */
		/* 820F9420h case    2:*/		return 0x820F8998;
		/* 820F9420h case    2:*/		return 0x820F9424;
		  /* 820F9424h */ case    3:  		/* nop */
		/* 820F9424h case    3:*/		cpu::op::nop();
		/* 820F9424h case    3:*/		return 0x820F9428;
	}
	return 0x820F9428;
} // Block from 820F9418h-820F9428h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F9428h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9428);
		  /* 820F9428h */ case    0:  		/* mfspr R12, LR */
		/* 820F9428h case    0:*/		regs.R12 = regs.LR;
		/* 820F9428h case    0:*/		return 0x820F942C;
		  /* 820F942Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820F942Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F942Ch case    1:*/		return 0x820F9430;
		  /* 820F9430h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820F9430h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820F9430h case    2:*/		return 0x820F9434;
		  /* 820F9434h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820F9434h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F9434h case    3:*/		return 0x820F9438;
		  /* 820F9438h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820F9438h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820F9438h case    4:*/		return 0x820F943C;
		  /* 820F943Ch */ case    5:  		/* mr R30, R4 */
		/* 820F943Ch case    5:*/		regs.R30 = regs.R4;
		/* 820F943Ch case    5:*/		return 0x820F9440;
		  /* 820F9440h */ case    6:  		/* mr R4, R5 */
		/* 820F9440h case    6:*/		regs.R4 = regs.R5;
		/* 820F9440h case    6:*/		return 0x820F9444;
		  /* 820F9444h */ case    7:  		/* mr R31, R3 */
		/* 820F9444h case    7:*/		regs.R31 = regs.R3;
		/* 820F9444h case    7:*/		return 0x820F9448;
		  /* 820F9448h */ case    8:  		/* bl -47160 */
		/* 820F9448h case    8:*/		regs.LR = 0x820F944C; return 0x820EDC10;
		/* 820F9448h case    8:*/		return 0x820F944C;
		  /* 820F944Ch */ case    9:  		/* lis R11, -32254 */
		/* 820F944Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F944Ch case    9:*/		return 0x820F9450;
		  /* 820F9450h */ case   10:  		/* lis R10, -32217 */
		/* 820F9450h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 820F9450h case   10:*/		return 0x820F9454;
		  /* 820F9454h */ case   11:  		/* stw R30, <#[R31 + 348]> */
		/* 820F9454h case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000015C) );
		/* 820F9454h case   11:*/		return 0x820F9458;
		  /* 820F9458h */ case   12:  		/* addi R11, R11, -15256 */
		/* 820F9458h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFC468);
		/* 820F9458h case   12:*/		return 0x820F945C;
		  /* 820F945Ch */ case   13:  		/* lis R9, -32217 */
		/* 820F945Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8227);
		/* 820F945Ch case   13:*/		return 0x820F9460;
		  /* 820F9460h */ case   14:  		/* lis R8, -32217 */
		/* 820F9460h case   14:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8227);
		/* 820F9460h case   14:*/		return 0x820F9464;
		  /* 820F9464h */ case   15:  		/* stw R11, <#[R31]> */
		/* 820F9464h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F9464h case   15:*/		return 0x820F9468;
		  /* 820F9468h */ case   16:  		/* addi R10, R10, 13832 */
		/* 820F9468h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x3608);
		/* 820F9468h case   16:*/		return 0x820F946C;
		  /* 820F946Ch */ case   17:  		/* addi R9, R9, 14408 */
		/* 820F946Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x3848);
		/* 820F946Ch case   17:*/		return 0x820F9470;
		  /* 820F9470h */ case   18:  		/* addi R11, R8, 15096 */
		/* 820F9470h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0x3AF8);
		/* 820F9470h case   18:*/		return 0x820F9474;
		  /* 820F9474h */ case   19:  		/* stw R10, <#[R31 + 244]> */
		/* 820F9474h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x000000F4) );
		/* 820F9474h case   19:*/		return 0x820F9478;
		  /* 820F9478h */ case   20:  		/* stw R9, <#[R31 + 248]> */
		/* 820F9478h case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x000000F8) );
		/* 820F9478h case   20:*/		return 0x820F947C;
		  /* 820F947Ch */ case   21:  		/* mr R3, R31 */
		/* 820F947Ch case   21:*/		regs.R3 = regs.R31;
		/* 820F947Ch case   21:*/		return 0x820F9480;
		  /* 820F9480h */ case   22:  		/* stw R11, <#[R31 + 252]> */
		/* 820F9480h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000FC) );
		/* 820F9480h case   22:*/		return 0x820F9484;
		  /* 820F9484h */ case   23:  		/* addi R1, R1, 112 */
		/* 820F9484h case   23:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820F9484h case   23:*/		return 0x820F9488;
		  /* 820F9488h */ case   24:  		/* lwz R12, <#[R1 - 8]> */
		/* 820F9488h case   24:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F9488h case   24:*/		return 0x820F948C;
		  /* 820F948Ch */ case   25:  		/* mtspr LR, R12 */
		/* 820F948Ch case   25:*/		regs.LR = regs.R12;
		/* 820F948Ch case   25:*/		return 0x820F9490;
		  /* 820F9490h */ case   26:  		/* ld R30, <#[R1 - 24]> */
		/* 820F9490h case   26:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820F9490h case   26:*/		return 0x820F9494;
		  /* 820F9494h */ case   27:  		/* ld R31, <#[R1 - 16]> */
		/* 820F9494h case   27:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F9494h case   27:*/		return 0x820F9498;
		  /* 820F9498h */ case   28:  		/* bclr 20, CR0_LT */
		/* 820F9498h case   28:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F9498h case   28:*/		return 0x820F949C;
	}
	return 0x820F949C;
} // Block from 820F9428h-820F949Ch (29 instructions)

//////////////////////////////////////////////////////
// Block at 820F949Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F949C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F949C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F949C);
		  /* 820F949Ch */ case    0:  		/* nop */
		/* 820F949Ch case    0:*/		cpu::op::nop();
		/* 820F949Ch case    0:*/		return 0x820F94A0;
	}
	return 0x820F94A0;
} // Block from 820F949Ch-820F94A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F94A0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F94A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F94A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F94A0);
		  /* 820F94A0h */ case    0:  		/* lis R11, -32254 */
		/* 820F94A0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F94A0h case    0:*/		return 0x820F94A4;
		  /* 820F94A4h */ case    1:  		/* addi R11, R11, -15256 */
		/* 820F94A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFC468);
		/* 820F94A4h case    1:*/		return 0x820F94A8;
		  /* 820F94A8h */ case    2:  		/* stw R11, <#[R3]> */
		/* 820F94A8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F94A8h case    2:*/		return 0x820F94AC;
		  /* 820F94ACh */ case    3:  		/* b -47020 */
		/* 820F94ACh case    3:*/		return 0x820EDD00;
		/* 820F94ACh case    3:*/		return 0x820F94B0;
	}
	return 0x820F94B0;
} // Block from 820F94A0h-820F94B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F94B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F94B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F94B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F94B0);
		  /* 820F94B0h */ case    0:  		/* mfspr R12, LR */
		/* 820F94B0h case    0:*/		regs.R12 = regs.LR;
		/* 820F94B0h case    0:*/		return 0x820F94B4;
		  /* 820F94B4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820F94B4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F94B4h case    1:*/		return 0x820F94B8;
		  /* 820F94B8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820F94B8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F94B8h case    2:*/		return 0x820F94BC;
		  /* 820F94BCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820F94BCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820F94BCh case    3:*/		return 0x820F94C0;
		  /* 820F94C0h */ case    4:  		/* lwz R9, <#[R3 + 200]> */
		/* 820F94C0h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x000000C8) );
		/* 820F94C0h case    4:*/		return 0x820F94C4;
		  /* 820F94C4h */ case    5:  		/* lis R10, -2 */
		/* 820F94C4h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFE);
		/* 820F94C4h case    5:*/		return 0x820F94C8;
		  /* 820F94C8h */ case    6:  		/* mr R11, R3 */
		/* 820F94C8h case    6:*/		regs.R11 = regs.R3;
		/* 820F94C8h case    6:*/		return 0x820F94CC;
		  /* 820F94CCh */ case    7:  		/* ori R10, R10, 768 */
		/* 820F94CCh case    7:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x300);
		/* 820F94CCh case    7:*/		return 0x820F94D0;
		  /* 820F94D0h */ case    8:  		/* subf. R10, R10, R9 */
		/* 820F94D0h case    8:*/		cpu::op::subf<1>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820F94D0h case    8:*/		return 0x820F94D4;
		  /* 820F94D4h */ case    9:  		/* stw R9, <#[R3 + 268]> */
		/* 820F94D4h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x0000010C) );
		/* 820F94D4h case    9:*/		return 0x820F94D8;
		  /* 820F94D8h */ case   10:  		/* bc 12, CR0_EQ, 312 */
		/* 820F94D8h case   10:*/		if ( regs.CR[0].eq ) { return 0x820F9610;  }
		/* 820F94D8h case   10:*/		return 0x820F94DC;
		  /* 820F94DCh */ case   11:  		/* cmplwi CR6, R10, 255 */
		/* 820F94DCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x000000FF);
		/* 820F94DCh case   11:*/		return 0x820F94E0;
		  /* 820F94E0h */ case   12:  		/* bc 12, CR6_EQ, 204 */
		/* 820F94E0h case   12:*/		if ( regs.CR[6].eq ) { return 0x820F95AC;  }
		/* 820F94E0h case   12:*/		return 0x820F94E4;
		  /* 820F94E4h */ case   13:  		/* addis R10, R10, -1 */
		/* 820F94E4h case   13:*/		cpu::op::addis<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820F94E4h case   13:*/		return 0x820F94E8;
		  /* 820F94E8h */ case   14:  		/* cmplwi CR0, R10, 0 */
		/* 820F94E8h case   14:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 820F94E8h case   14:*/		return 0x820F94EC;
		  /* 820F94ECh */ case   15:  		/* bc 12, CR0_EQ, 140 */
		/* 820F94ECh case   15:*/		if ( regs.CR[0].eq ) { return 0x820F9578;  }
		/* 820F94ECh case   15:*/		return 0x820F94F0;
		  /* 820F94F0h */ case   16:  		/* cmplwi CR6, R10, 255 */
		/* 820F94F0h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x000000FF);
		/* 820F94F0h case   16:*/		return 0x820F94F4;
		  /* 820F94F4h */ case   17:  		/* li R4, 0 */
		/* 820F94F4h case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F94F4h case   17:*/		return 0x820F94F8;
		  /* 820F94F8h */ case   18:  		/* bc 12, CR6_EQ, 32 */
		/* 820F94F8h case   18:*/		if ( regs.CR[6].eq ) { return 0x820F9518;  }
		/* 820F94F8h case   18:*/		return 0x820F94FC;
		  /* 820F94FCh */ case   19:  		/* lis R10, -32254 */
		/* 820F94FCh case   19:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820F94FCh case   19:*/		return 0x820F9500;
		  /* 820F9500h */ case   20:  		/* li R5, 0 */
		/* 820F9500h case   20:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F9500h case   20:*/		return 0x820F9504;
		  /* 820F9504h */ case   21:  		/* addi R6, R10, -14880 */
		/* 820F9504h case   21:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFC5E0);
		/* 820F9504h case   21:*/		return 0x820F9508;
		  /* 820F9508h */ case   22:  		/* bl 86568 */
		/* 820F9508h case   22:*/		regs.LR = 0x820F950C; return 0x8210E730;
		/* 820F9508h case   22:*/		return 0x820F950C;
		  /* 820F950Ch */ case   23:  		/* lis R3, -32768 */
		/* 820F950Ch case   23:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820F950Ch case   23:*/		return 0x820F9510;
		  /* 820F9510h */ case   24:  		/* ori R3, R3, 16389 */
		/* 820F9510h case   24:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820F9510h case   24:*/		return 0x820F9514;
		  /* 820F9514h */ case   25:  		/* b 404 */
		/* 820F9514h case   25:*/		return 0x820F96A8;
		/* 820F9514h case   25:*/		return 0x820F9518;
	}
	return 0x820F9518;
} // Block from 820F94B0h-820F9518h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820F9518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9518);
		  /* 820F9518h */ case    0:  		/* li R10, 16 */
		/* 820F9518h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x10);
		/* 820F9518h case    0:*/		return 0x820F951C;
		  /* 820F951Ch */ case    1:  		/* stw R4, <#[R11 + 48]> */
		/* 820F951Ch case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000030) );
		/* 820F951Ch case    1:*/		return 0x820F9520;
		  /* 820F9520h */ case    2:  		/* li R3, 8192 */
		/* 820F9520h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x2000);
		/* 820F9520h case    2:*/		return 0x820F9524;
		  /* 820F9524h */ case    3:  		/* li R31, 255 */
		/* 820F9524h case    3:*/		cpu::op::li<0>(regs,&regs.R31,0xFF);
		/* 820F9524h case    3:*/		return 0x820F9528;
		  /* 820F9528h */ case    4:  		/* stw R10, <#[R11 + 40]> */
		/* 820F9528h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000028) );
		/* 820F9528h case    4:*/		return 0x820F952C;
		  /* 820F952Ch */ case    5:  		/* stw R10, <#[R11 + 96]> */
		/* 820F952Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000060) );
		/* 820F952Ch case    5:*/		return 0x820F9530;
		  /* 820F9530h */ case    6:  		/* stw R10, <#[R11 + 64]> */
		/* 820F9530h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000040) );
		/* 820F9530h case    6:*/		return 0x820F9534;
		  /* 820F9534h */ case    7:  		/* stw R3, <#[R11 + 56]> */
		/* 820F9534h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000038) );
		/* 820F9534h case    7:*/		return 0x820F9538;
		  /* 820F9538h */ case    8:  		/* stw R31, <#[R11 + 104]> */
		/* 820F9538h case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000068) );
		/* 820F9538h case    8:*/		return 0x820F953C;
		  /* 820F953Ch */ case    9:  		/* lwz R6, <#[R11 + 108]> */
		/* 820F953Ch case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x0000006C) );
		/* 820F953Ch case    9:*/		return 0x820F9540;
		  /* 820F9540h */ case   10:  		/* li R7, 4 */
		/* 820F9540h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 820F9540h case   10:*/		return 0x820F9544;
		  /* 820F9544h */ case   11:  		/* lwz R5, <#[R11 + 112]> */
		/* 820F9544h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000070) );
		/* 820F9544h case   11:*/		return 0x820F9548;
		  /* 820F9548h */ case   12:  		/* li R3, 24 */
		/* 820F9548h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x18);
		/* 820F9548h case   12:*/		return 0x820F954C;
		  /* 820F954Ch */ case   13:  		/* oris R6, R6, 33472 */
		/* 820F954Ch case   13:*/		cpu::op::oris<0>(regs,&regs.R6,regs.R6,0x82C0);
		/* 820F954Ch case   13:*/		return 0x820F9550;
		  /* 820F9550h */ case   14:  		/* stw R7, <#[R11 + 92]> */
		/* 820F9550h case   14:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x0000005C) );
		/* 820F9550h case   14:*/		return 0x820F9554;
		  /* 820F9554h */ case   15:  		/* oris R5, R5, 5712 */
		/* 820F9554h case   15:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R5,0x1650);
		/* 820F9554h case   15:*/		return 0x820F9558;
		  /* 820F9558h */ case   16:  		/* stw R3, <#[R11 + 88]> */
		/* 820F9558h case   16:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000058) );
		/* 820F9558h case   16:*/		return 0x820F955C;
		  /* 820F955Ch */ case   17:  		/* ori R6, R6, 513 */
		/* 820F955Ch case   17:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x201);
		/* 820F955Ch case   17:*/		return 0x820F9560;
		  /* 820F9560h */ case   18:  		/* stw R7, <#[R11 + 72]> */
		/* 820F9560h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000048) );
		/* 820F9560h case   18:*/		return 0x820F9564;
		  /* 820F9564h */ case   19:  		/* li R9, 1 */
		/* 820F9564h case   19:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820F9564h case   19:*/		return 0x820F9568;
	}
	return 0x820F9568;
} // Block from 820F9518h-820F9568h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820F9568h
// Function '?EmitLOOP@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9568);
		  /* 820F9568h */ case    0:  		/* stw R10, <#[R11 + 76]> */
		/* 820F9568h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000004C) );
		/* 820F9568h case    0:*/		return 0x820F956C;
		  /* 820F956Ch */ case    1:  		/* stw R6, <#[R11 + 108]> */
		/* 820F956Ch case    1:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x0000006C) );
		/* 820F956Ch case    1:*/		return 0x820F9570;
		  /* 820F9570h */ case    2:  		/* stw R5, <#[R11 + 112]> */
		/* 820F9570h case    2:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x00000070) );
		/* 820F9570h case    2:*/		return 0x820F9574;
		  /* 820F9574h */ case    3:  		/* b 256 */
		/* 820F9574h case    3:*/		return 0x820F9674;
		/* 820F9574h case    3:*/		return 0x820F9578;
	}
	return 0x820F9578;
} // Block from 820F9568h-820F9578h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F9578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9578);
		  /* 820F9578h */ case    0:  		/* li R10, 16 */
		/* 820F9578h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x10);
		/* 820F9578h case    0:*/		return 0x820F957C;
		  /* 820F957Ch */ case    1:  		/* li R4, 256 */
		/* 820F957Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x100);
		/* 820F957Ch case    1:*/		return 0x820F9580;
		  /* 820F9580h */ case    2:  		/* stw R10, <#[R11 + 40]> */
		/* 820F9580h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000028) );
		/* 820F9580h case    2:*/		return 0x820F9584;
		  /* 820F9584h */ case    3:  		/* li R3, 128 */
		/* 820F9584h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x80);
		/* 820F9584h case    3:*/		return 0x820F9588;
		  /* 820F9588h */ case    4:  		/* stw R10, <#[R11 + 64]> */
		/* 820F9588h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000040) );
		/* 820F9588h case    4:*/		return 0x820F958C;
		  /* 820F958Ch */ case    5:  		/* li R10, 0 */
		/* 820F958Ch case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820F958Ch case    5:*/		return 0x820F9590;
		  /* 820F9590h */ case    6:  		/* stw R4, <#[R11 + 56]> */
		/* 820F9590h case    6:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000038) );
		/* 820F9590h case    6:*/		return 0x820F9594;
		  /* 820F9594h */ case    7:  		/* stw R10, <#[R11 + 48]> */
		/* 820F9594h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 820F9594h case    7:*/		return 0x820F9598;
		  /* 820F9598h */ case    8:  		/* li R10, 255 */
		/* 820F9598h case    8:*/		cpu::op::li<0>(regs,&regs.R10,0xFF);
		/* 820F9598h case    8:*/		return 0x820F959C;
		  /* 820F959Ch */ case    9:  		/* stw R3, <#[R11 + 96]> */
		/* 820F959Ch case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000060) );
		/* 820F959Ch case    9:*/		return 0x820F95A0;
		  /* 820F95A0h */ case   10:  		/* stw R10, <#[R11 + 104]> */
		/* 820F95A0h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000068) );
		/* 820F95A0h case   10:*/		return 0x820F95A4;
		  /* 820F95A4h */ case   11:  		/* li R10, 26 */
		/* 820F95A4h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x1A);
		/* 820F95A4h case   11:*/		return 0x820F95A8;
		  /* 820F95A8h */ case   12:  		/* b -108 */
		/* 820F95A8h case   12:*/		return 0x820F953C;
		/* 820F95A8h case   12:*/		return 0x820F95AC;
	}
	return 0x820F95AC;
} // Block from 820F9578h-820F95ACh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820F95ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F95AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F95AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F95AC);
		  /* 820F95ACh */ case    0:  		/* li R7, 2048 */
		/* 820F95ACh case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x800);
		/* 820F95ACh case    0:*/		return 0x820F95B0;
		  /* 820F95B0h */ case    1:  		/* lwz R5, <#[R11 + 108]> */
		/* 820F95B0h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x0000006C) );
		/* 820F95B0h case    1:*/		return 0x820F95B4;
		  /* 820F95B4h */ case    2:  		/* li R4, 8192 */
		/* 820F95B4h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x2000);
		/* 820F95B4h case    2:*/		return 0x820F95B8;
		  /* 820F95B8h */ case    3:  		/* lwz R6, <#[R11 + 112]> */
		/* 820F95B8h case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000070) );
		/* 820F95B8h case    3:*/		return 0x820F95BC;
		  /* 820F95BCh */ case    4:  		/* stw R7, <#[R11 + 96]> */
		/* 820F95BCh case    4:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000060) );
		/* 820F95BCh case    4:*/		return 0x820F95C0;
		  /* 820F95C0h */ case    5:  		/* li R10, 16 */
		/* 820F95C0h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x10);
		/* 820F95C0h case    5:*/		return 0x820F95C4;
		  /* 820F95C4h */ case    6:  		/* stw R7, <#[R11 + 64]> */
		/* 820F95C4h case    6:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000040) );
		/* 820F95C4h case    6:*/		return 0x820F95C8;
		  /* 820F95C8h */ case    7:  		/* oris R7, R5, 64 */
		/* 820F95C8h case    7:*/		cpu::op::oris<0>(regs,&regs.R7,regs.R5,0x40);
		/* 820F95C8h case    7:*/		return 0x820F95CC;
		  /* 820F95CCh */ case    8:  		/* stw R4, <#[R11 + 56]> */
		/* 820F95CCh case    8:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000038) );
		/* 820F95CCh case    8:*/		return 0x820F95D0;
		  /* 820F95D0h */ case    9:  		/* li R9, 1 */
		/* 820F95D0h case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820F95D0h case    9:*/		return 0x820F95D4;
		  /* 820F95D4h */ case   10:  		/* li R3, 255 */
		/* 820F95D4h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0xFF);
		/* 820F95D4h case   10:*/		return 0x820F95D8;
		  /* 820F95D8h */ case   11:  		/* stw R10, <#[R11 + 40]> */
		/* 820F95D8h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000028) );
		/* 820F95D8h case   11:*/		return 0x820F95DC;
		  /* 820F95DCh */ case   12:  		/* li R31, 24 */
		/* 820F95DCh case   12:*/		cpu::op::li<0>(regs,&regs.R31,0x18);
		/* 820F95DCh case   12:*/		return 0x820F95E0;
		  /* 820F95E0h */ case   13:  		/* stw R9, <#[R11 + 48]> */
		/* 820F95E0h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000030) );
		/* 820F95E0h case   13:*/		return 0x820F95E4;
		  /* 820F95E4h */ case   14:  		/* li R4, 4 */
		/* 820F95E4h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 820F95E4h case   14:*/		return 0x820F95E8;
		  /* 820F95E8h */ case   15:  		/* stw R3, <#[R11 + 104]> */
		/* 820F95E8h case   15:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000068) );
		/* 820F95E8h case   15:*/		return 0x820F95EC;
		  /* 820F95ECh */ case   16:  		/* ori R7, R7, 513 */
		/* 820F95ECh case   16:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R7,0x201);
		/* 820F95ECh case   16:*/		return 0x820F95F0;
		  /* 820F95F0h */ case   17:  		/* stw R10, <#[R11 + 84]> */
		/* 820F95F0h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000054) );
		/* 820F95F0h case   17:*/		return 0x820F95F4;
		  /* 820F95F4h */ case   18:  		/* oris R6, R6, 5112 */
		/* 820F95F4h case   18:*/		cpu::op::oris<0>(regs,&regs.R6,regs.R6,0x13F8);
		/* 820F95F4h case   18:*/		return 0x820F95F8;
		  /* 820F95F8h */ case   19:  		/* stw R31, <#[R11 + 88]> */
		/* 820F95F8h case   19:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000058) );
		/* 820F95F8h case   19:*/		return 0x820F95FC;
		  /* 820F95FCh */ case   20:  		/* stw R4, <#[R11 + 92]> */
		/* 820F95FCh case   20:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x0000005C) );
		/* 820F95FCh case   20:*/		return 0x820F9600;
		  /* 820F9600h */ case   21:  		/* stw R10, <#[R11 + 76]> */
		/* 820F9600h case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000004C) );
		/* 820F9600h case   21:*/		return 0x820F9604;
		  /* 820F9604h */ case   22:  		/* stw R7, <#[R11 + 108]> */
		/* 820F9604h case   22:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x0000006C) );
		/* 820F9604h case   22:*/		return 0x820F9608;
		  /* 820F9608h */ case   23:  		/* stw R6, <#[R11 + 112]> */
		/* 820F9608h case   23:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000070) );
		/* 820F9608h case   23:*/		return 0x820F960C;
		  /* 820F960Ch */ case   24:  		/* b 112 */
		/* 820F960Ch case   24:*/		return 0x820F967C;
		/* 820F960Ch case   24:*/		return 0x820F9610;
	}
	return 0x820F9610;
} // Block from 820F95ACh-820F9610h (25 instructions)

//////////////////////////////////////////////////////
// Block at 820F9610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9610);
		  /* 820F9610h */ case    0:  		/* li R6, 96 */
		/* 820F9610h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x60);
		/* 820F9610h case    0:*/		return 0x820F9614;
		  /* 820F9614h */ case    1:  		/* lwz R7, <#[R11 + 108]> */
		/* 820F9614h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000006C) );
		/* 820F9614h case    1:*/		return 0x820F9618;
		  /* 820F9618h */ case    2:  		/* li R5, 256 */
		/* 820F9618h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x100);
		/* 820F9618h case    2:*/		return 0x820F961C;
		  /* 820F961Ch */ case    3:  		/* lwz R10, <#[R11 + 112]> */
		/* 820F961Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000070) );
		/* 820F961Ch case    3:*/		return 0x820F9620;
		  /* 820F9620h */ case    4:  		/* stw R6, <#[R11 + 40]> */
		/* 820F9620h case    4:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000028) );
		/* 820F9620h case    4:*/		return 0x820F9624;
		  /* 820F9624h */ case    5:  		/* li R6, 16 */
		/* 820F9624h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x10);
		/* 820F9624h case    5:*/		return 0x820F9628;
		  /* 820F9628h */ case    6:  		/* stw R5, <#[R11 + 56]> */
		/* 820F9628h case    6:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x00000038) );
		/* 820F9628h case    6:*/		return 0x820F962C;
		  /* 820F962Ch */ case    7:  		/* li R5, 255 */
		/* 820F962Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0xFF);
		/* 820F962Ch case    7:*/		return 0x820F9630;
		  /* 820F9630h */ case    8:  		/* oris R7, R7, 16448 */
		/* 820F9630h case    8:*/		cpu::op::oris<0>(regs,&regs.R7,regs.R7,0x4040);
		/* 820F9630h case    8:*/		return 0x820F9634;
		  /* 820F9634h */ case    9:  		/* stw R6, <#[R11 + 64]> */
		/* 820F9634h case    9:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000040) );
		/* 820F9634h case    9:*/		return 0x820F9638;
	}
	return 0x820F9638;
} // Block from 820F9610h-820F9638h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F9638h
// Function '?EmitLOOP_INC@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9638);
		  /* 820F9638h */ case    0:  		/* stw R5, <#[R11 + 104]> */
		/* 820F9638h case    0:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x00000068) );
		/* 820F9638h case    0:*/		return 0x820F963C;
		  /* 820F963Ch */ case    1:  		/* li R9, 1 */
		/* 820F963Ch case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820F963Ch case    1:*/		return 0x820F9640;
		  /* 820F9640h */ case    2:  		/* li R4, 128 */
		/* 820F9640h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x80);
		/* 820F9640h case    2:*/		return 0x820F9644;
		  /* 820F9644h */ case    3:  		/* li R6, 24 */
		/* 820F9644h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x18);
		/* 820F9644h case    3:*/		return 0x820F9648;
		  /* 820F9648h */ case    4:  		/* stw R9, <#[R11 + 48]> */
		/* 820F9648h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000030) );
		/* 820F9648h case    4:*/		return 0x820F964C;
		  /* 820F964Ch */ case    5:  		/* li R5, 4 */
		/* 820F964Ch case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 820F964Ch case    5:*/		return 0x820F9650;
		  /* 820F9650h */ case    6:  		/* stw R4, <#[R11 + 96]> */
		/* 820F9650h case    6:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000060) );
		/* 820F9650h case    6:*/		return 0x820F9654;
		  /* 820F9654h */ case    7:  		/* li R3, 10 */
		/* 820F9654h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0xA);
		/* 820F9654h case    7:*/		return 0x820F9658;
		  /* 820F9658h */ case    8:  		/* stw R6, <#[R11 + 88]> */
		/* 820F9658h case    8:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000058) );
		/* 820F9658h case    8:*/		return 0x820F965C;
		  /* 820F965Ch */ case    9:  		/* oris R10, R10, 5112 */
		/* 820F965Ch case    9:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x13F8);
		/* 820F965Ch case    9:*/		return 0x820F9660;
		  /* 820F9660h */ case   10:  		/* stw R5, <#[R11 + 92]> */
		/* 820F9660h case   10:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x0000005C) );
		/* 820F9660h case   10:*/		return 0x820F9664;
		  /* 820F9664h */ case   11:  		/* ori R7, R7, 513 */
		/* 820F9664h case   11:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R7,0x201);
		/* 820F9664h case   11:*/		return 0x820F9668;
		  /* 820F9668h */ case   12:  		/* stw R3, <#[R11 + 76]> */
		/* 820F9668h case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x0000004C) );
		/* 820F9668h case   12:*/		return 0x820F966C;
		  /* 820F966Ch */ case   13:  		/* stw R10, <#[R11 + 112]> */
		/* 820F966Ch case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000070) );
		/* 820F966Ch case   13:*/		return 0x820F9670;
		  /* 820F9670h */ case   14:  		/* stw R7, <#[R11 + 108]> */
		/* 820F9670h case   14:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x0000006C) );
		/* 820F9670h case   14:*/		return 0x820F9674;
	}
	return 0x820F9674;
} // Block from 820F9638h-820F9674h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820F9674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9674);
		  /* 820F9674h */ case    0:  		/* li R4, 8 */
		/* 820F9674h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 820F9674h case    0:*/		return 0x820F9678;
		  /* 820F9678h */ case    1:  		/* stw R4, <#[R11 + 84]> */
		/* 820F9678h case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000054) );
		/* 820F9678h case    1:*/		return 0x820F967C;
	}
	return 0x820F967C;
} // Block from 820F9674h-820F967Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F967Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F967C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F967C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F967C);
		  /* 820F967Ch */ case    0:  		/* lwz R10, <#[R11 + 112]> */
		/* 820F967Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000070) );
		/* 820F967Ch case    0:*/		return 0x820F9680;
		  /* 820F9680h */ case    1:  		/* li R8, 32 */
		/* 820F9680h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x20);
		/* 820F9680h case    1:*/		return 0x820F9684;
		  /* 820F9684h */ case    2:  		/* lwz R7, <#[R11 + 40]> */
		/* 820F9684h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000028) );
		/* 820F9684h case    2:*/		return 0x820F9688;
		  /* 820F9688h */ case    3:  		/* li R3, 0 */
		/* 820F9688h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F9688h case    3:*/		return 0x820F968C;
		  /* 820F968Ch */ case    4:  		/* oris R10, R10, 4 */
		/* 820F968Ch case    4:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F968Ch case    4:*/		return 0x820F9690;
		  /* 820F9690h */ case    5:  		/* stw R9, <#[R11 + 100]> */
		/* 820F9690h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000064) );
		/* 820F9690h case    5:*/		return 0x820F9694;
		  /* 820F9694h */ case    6:  		/* stw R8, <#[R11 + 44]> */
		/* 820F9694h case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x0000002C) );
		/* 820F9694h case    6:*/		return 0x820F9698;
		  /* 820F9698h */ case    7:  		/* stw R8, <#[R11 + 468]> */
		/* 820F9698h case    7:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x000001D4) );
		/* 820F9698h case    7:*/		return 0x820F969C;
		  /* 820F969Ch */ case    8:  		/* stw R9, <#[R11 + 344]> */
		/* 820F969Ch case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000158) );
		/* 820F969Ch case    8:*/		return 0x820F96A0;
		  /* 820F96A0h */ case    9:  		/* stw R10, <#[R11 + 112]> */
		/* 820F96A0h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000070) );
		/* 820F96A0h case    9:*/		return 0x820F96A4;
		  /* 820F96A4h */ case   10:  		/* stw R7, <#[R11 + 68]> */
		/* 820F96A4h case   10:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000044) );
		/* 820F96A4h case   10:*/		return 0x820F96A8;
	}
	return 0x820F96A8;
} // Block from 820F967Ch-820F96A8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820F96A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F96A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F96A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F96A8);
		  /* 820F96A8h */ case    0:  		/* addi R1, R1, 96 */
		/* 820F96A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820F96A8h case    0:*/		return 0x820F96AC;
		  /* 820F96ACh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820F96ACh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F96ACh case    1:*/		return 0x820F96B0;
		  /* 820F96B0h */ case    2:  		/* mtspr LR, R12 */
		/* 820F96B0h case    2:*/		regs.LR = regs.R12;
		/* 820F96B0h case    2:*/		return 0x820F96B4;
		  /* 820F96B4h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820F96B4h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F96B4h case    3:*/		return 0x820F96B8;
		  /* 820F96B8h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820F96B8h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F96B8h case    4:*/		return 0x820F96BC;
	}
	return 0x820F96BC;
} // Block from 820F96A8h-820F96BCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F96BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F96BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F96BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F96BC);
		  /* 820F96BCh */ case    0:  		/* nop */
		/* 820F96BCh case    0:*/		cpu::op::nop();
		/* 820F96BCh case    0:*/		return 0x820F96C0;
	}
	return 0x820F96C0;
} // Block from 820F96BCh-820F96C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F96C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F96C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F96C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F96C0);
		  /* 820F96C0h */ case    0:  		/* mfspr R12, LR */
		/* 820F96C0h case    0:*/		regs.R12 = regs.LR;
		/* 820F96C0h case    0:*/		return 0x820F96C4;
		  /* 820F96C4h */ case    1:  		/* bl -427140 */
		/* 820F96C4h case    1:*/		regs.LR = 0x820F96C8; return 0x82091240;
		/* 820F96C4h case    1:*/		return 0x820F96C8;
		  /* 820F96C8h */ case    2:  		/* stwu R1, <#[R1 - 256]> */
		/* 820F96C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 820F96C8h case    2:*/		return 0x820F96CC;
		  /* 820F96CCh */ case    3:  		/* lwz R11, <#[R3 + 348]> */
		/* 820F96CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000015C) );
		/* 820F96CCh case    3:*/		return 0x820F96D0;
		  /* 820F96D0h */ case    4:  		/* mr R30, R3 */
		/* 820F96D0h case    4:*/		regs.R30 = regs.R3;
		/* 820F96D0h case    4:*/		return 0x820F96D4;
		  /* 820F96D4h */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 820F96D4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820F96D4h case    5:*/		return 0x820F96D8;
		  /* 820F96D8h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 820F96D8h case    6:*/		if ( regs.CR[6].eq ) { return 0x820F96E4;  }
		/* 820F96D8h case    6:*/		return 0x820F96DC;
		  /* 820F96DCh */ case    7:  		/* li R3, 0 */
		/* 820F96DCh case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F96DCh case    7:*/		return 0x820F96E0;
		  /* 820F96E0h */ case    8:  		/* b 852 */
		/* 820F96E0h case    8:*/		return 0x820F9A34;
		/* 820F96E0h case    8:*/		return 0x820F96E4;
	}
	return 0x820F96E4;
} // Block from 820F96C0h-820F96E4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F96E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F96E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F96E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F96E4);
		  /* 820F96E4h */ case    0:  		/* lwz R11, <#[R30 + 112]> */
		/* 820F96E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000070) );
		/* 820F96E4h case    0:*/		return 0x820F96E8;
		  /* 820F96E8h */ case    1:  		/* li R23, 0 */
		/* 820F96E8h case    1:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 820F96E8h case    1:*/		return 0x820F96EC;
		  /* 820F96ECh */ case    2:  		/* rlwinm. R11, R11, 0, 7, 7 */
		/* 820F96ECh case    2:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R11,regs.R11);
		/* 820F96ECh case    2:*/		return 0x820F96F0;
		  /* 820F96F0h */ case    3:  		/* mr R22, R23 */
		/* 820F96F0h case    3:*/		regs.R22 = regs.R23;
		/* 820F96F0h case    3:*/		return 0x820F96F4;
		  /* 820F96F4h */ case    4:  		/* bc 12, CR0_EQ, 336 */
		/* 820F96F4h case    4:*/		if ( regs.CR[0].eq ) { return 0x820F9844;  }
		/* 820F96F4h case    4:*/		return 0x820F96F8;
		  /* 820F96F8h */ case    5:  		/* addi R11, R1, 80 */
		/* 820F96F8h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820F96F8h case    5:*/		return 0x820F96FC;
		  /* 820F96FCh */ case    6:  		/* lwz R10, <#[R30 + 8]> */
		/* 820F96FCh case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 820F96FCh case    6:*/		return 0x820F9700;
		  /* 820F9700h */ case    7:  		/* mr R28, R23 */
		/* 820F9700h case    7:*/		regs.R28 = regs.R23;
		/* 820F9700h case    7:*/		return 0x820F9704;
		  /* 820F9704h */ case    8:  		/* mr R24, R23 */
		/* 820F9704h case    8:*/		regs.R24 = regs.R23;
		/* 820F9704h case    8:*/		return 0x820F9708;
		  /* 820F9708h */ case    9:  		/* mr R26, R23 */
		/* 820F9708h case    9:*/		regs.R26 = regs.R23;
		/* 820F9708h case    9:*/		return 0x820F970C;
		  /* 820F970Ch */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 820F970Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F970Ch case   10:*/		return 0x820F9710;
		  /* 820F9710h */ case   11:  		/* std R23, <#[R11]> */
		/* 820F9710h case   11:*/		cpu::mem::store64( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 820F9710h case   11:*/		return 0x820F9714;
		  /* 820F9714h */ case   12:  		/* std R23, <#[R11 + 8]> */
		/* 820F9714h case   12:*/		cpu::mem::store64( regs, regs.R23, (uint32)(regs.R11 + 0x00000008) );
		/* 820F9714h case   12:*/		return 0x820F9718;
		  /* 820F9718h */ case   13:  		/* bc 4, CR6_GT, 232 */
		/* 820F9718h case   13:*/		if ( !regs.CR[6].gt ) { return 0x820F9800;  }
		/* 820F9718h case   13:*/		return 0x820F971C;
		  /* 820F971Ch */ case   14:  		/* lis R11, -32254 */
		/* 820F971Ch case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F971Ch case   14:*/		return 0x820F9720;
		  /* 820F9720h */ case   15:  		/* mr R27, R23 */
		/* 820F9720h case   15:*/		regs.R27 = regs.R23;
		/* 820F9720h case   15:*/		return 0x820F9724;
		  /* 820F9724h */ case   16:  		/* addi R25, R11, -14564 */
		/* 820F9724h case   16:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R11,0xFFFFC71C);
		/* 820F9724h case   16:*/		return 0x820F9728;
		  /* 820F9728h */ case   17:  		/* lwz R11, <#[R30 + 20]> */
		/* 820F9728h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820F9728h case   17:*/		return 0x820F972C;
		  /* 820F972Ch */ case   18:  		/* lwz R10, <#[R30 + 16]> */
		/* 820F972Ch case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 820F972Ch case   18:*/		return 0x820F9730;
		  /* 820F9730h */ case   19:  		/* lwzx R31, <#[R11 + R27]> */
		/* 820F9730h case   19:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 820F9730h case   19:*/		return 0x820F9734;
		  /* 820F9734h */ case   20:  		/* lwz R11, <#[R31 + 4]> */
		/* 820F9734h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820F9734h case   20:*/		return 0x820F9738;
	}
	return 0x820F9738;
} // Block from 820F96E4h-820F9738h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820F9738h
// Function '?EmitMOV@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9738);
		  /* 820F9738h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F9738h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F9738h case    0:*/		return 0x820F973C;
		  /* 820F973Ch */ case    1:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820F973Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F973Ch case    1:*/		return 0x820F9740;
		  /* 820F9740h */ case    2:  		/* lwz R11, <#[R11 + 4]> */
		/* 820F9740h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820F9740h case    2:*/		return 0x820F9744;
		  /* 820F9744h */ case    3:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 820F9744h case    3:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 820F9744h case    3:*/		return 0x820F9748;
		  /* 820F9748h */ case    4:  		/* bc 12, CR0_EQ, 164 */
		/* 820F9748h case    4:*/		if ( regs.CR[0].eq ) { return 0x820F97EC;  }
		/* 820F9748h case    4:*/		return 0x820F974C;
		  /* 820F974Ch */ case    5:  		/* lwz R11, <#[R30]> */
		/* 820F974Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820F974Ch case    5:*/		return 0x820F9750;
		  /* 820F9750h */ case    6:  		/* mr R3, R30 */
		/* 820F9750h case    6:*/		regs.R3 = regs.R30;
		/* 820F9750h case    6:*/		return 0x820F9754;
		  /* 820F9754h */ case    7:  		/* lwz R4, <#[R31 + 108]> */
		/* 820F9754h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000006C) );
		/* 820F9754h case    7:*/		return 0x820F9758;
		  /* 820F9758h */ case    8:  		/* lwz R11, <#[R11 + 112]> */
		/* 820F9758h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000070) );
		/* 820F9758h case    8:*/		return 0x820F975C;
		  /* 820F975Ch */ case    9:  		/* mtspr CTR, R11 */
		/* 820F975Ch case    9:*/		regs.CTR = regs.R11;
		/* 820F975Ch case    9:*/		return 0x820F9760;
		  /* 820F9760h */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 820F9760h case   10:*/		if ( 1 ) { regs.LR = 0x820F9764; return (uint32)regs.CTR; }
		/* 820F9760h case   10:*/		return 0x820F9764;
		  /* 820F9764h */ case   11:  		/* lwz R11, <#[R30]> */
		/* 820F9764h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820F9764h case   11:*/		return 0x820F9768;
		  /* 820F9768h */ case   12:  		/* mr R29, R3 */
		/* 820F9768h case   12:*/		regs.R29 = regs.R3;
		/* 820F9768h case   12:*/		return 0x820F976C;
		  /* 820F976Ch */ case   13:  		/* mr R3, R30 */
		/* 820F976Ch case   13:*/		regs.R3 = regs.R30;
		/* 820F976Ch case   13:*/		return 0x820F9770;
		  /* 820F9770h */ case   14:  		/* lwz R4, <#[R31 + 108]> */
		/* 820F9770h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000006C) );
		/* 820F9770h case   14:*/		return 0x820F9774;
		  /* 820F9774h */ case   15:  		/* lwz R11, <#[R11 + 116]> */
		/* 820F9774h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000074) );
		/* 820F9774h case   15:*/		return 0x820F9778;
		  /* 820F9778h */ case   16:  		/* mtspr CTR, R11 */
		/* 820F9778h case   16:*/		regs.CTR = regs.R11;
		/* 820F9778h case   16:*/		return 0x820F977C;
		  /* 820F977Ch */ case   17:  		/* bcctrl 20, CR0_LT */
		/* 820F977Ch case   17:*/		if ( 1 ) { regs.LR = 0x820F9780; return (uint32)regs.CTR; }
		/* 820F977Ch case   17:*/		return 0x820F9780;
		  /* 820F9780h */ case   18:  		/* cmplwi CR6, R29, 1 */
		/* 820F9780h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000001);
		/* 820F9780h case   18:*/		return 0x820F9784;
		  /* 820F9784h */ case   19:  		/* bc 12, CR6_EQ, 72 */
		/* 820F9784h case   19:*/		if ( regs.CR[6].eq ) { return 0x820F97CC;  }
		/* 820F9784h case   19:*/		return 0x820F9788;
		  /* 820F9788h */ case   20:  		/* cmplwi CR6, R29, 5 */
		/* 820F9788h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000005);
		/* 820F9788h case   20:*/		return 0x820F978C;
		  /* 820F978Ch */ case   21:  		/* bc 4, CR6_EQ, 96 */
		/* 820F978Ch case   21:*/		if ( !regs.CR[6].eq ) { return 0x820F97EC;  }
		/* 820F978Ch case   21:*/		return 0x820F9790;
		  /* 820F9790h */ case   22:  		/* cmplwi CR6, R3, 0 */
		/* 820F9790h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820F9790h case   22:*/		return 0x820F9794;
		  /* 820F9794h */ case   23:  		/* bc 4, CR6_EQ, 88 */
		/* 820F9794h case   23:*/		if ( !regs.CR[6].eq ) { return 0x820F97EC;  }
		/* 820F9794h case   23:*/		return 0x820F9798;
		  /* 820F9798h */ case   24:  		/* lwz R11, <#[R31 + 16]> */
		/* 820F9798h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820F9798h case   24:*/		return 0x820F979C;
		  /* 820F979Ch */ case   25:  		/* cmplwi CR6, R11, 0 */
		/* 820F979Ch case   25:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F979Ch case   25:*/		return 0x820F97A0;
		  /* 820F97A0h */ case   26:  		/* bc 4, CR6_GT, 76 */
		/* 820F97A0h case   26:*/		if ( !regs.CR[6].gt ) { return 0x820F97EC;  }
		/* 820F97A0h case   26:*/		return 0x820F97A4;
		  /* 820F97A4h */ case   27:  		/* cmpwi CR6, R28, 0 */
		/* 820F97A4h case   27:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 820F97A4h case   27:*/		return 0x820F97A8;
		  /* 820F97A8h */ case   28:  		/* bc 4, CR6_EQ, 68 */
		/* 820F97A8h case   28:*/		if ( !regs.CR[6].eq ) { return 0x820F97EC;  }
		/* 820F97A8h case   28:*/		return 0x820F97AC;
		  /* 820F97ACh */ case   29:  		/* mr R6, R25 */
		/* 820F97ACh case   29:*/		regs.R6 = regs.R25;
		/* 820F97ACh case   29:*/		return 0x820F97B0;
		  /* 820F97B0h */ case   30:  		/* lwz R4, <#[R31 + 96]> */
		/* 820F97B0h case   30:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000060) );
		/* 820F97B0h case   30:*/		return 0x820F97B4;
		  /* 820F97B4h */ case   31:  		/* li R5, 4540 */
		/* 820F97B4h case   31:*/		cpu::op::li<0>(regs,&regs.R5,0x11BC);
		/* 820F97B4h case   31:*/		return 0x820F97B8;
		  /* 820F97B8h */ case   32:  		/* mr R3, R30 */
		/* 820F97B8h case   32:*/		regs.R3 = regs.R30;
		/* 820F97B8h case   32:*/		return 0x820F97BC;
		  /* 820F97BCh */ case   33:  		/* bl 85876 */
		/* 820F97BCh case   33:*/		regs.LR = 0x820F97C0; return 0x8210E730;
		/* 820F97BCh case   33:*/		return 0x820F97C0;
		  /* 820F97C0h */ case   34:  		/* li R28, 1 */
		/* 820F97C0h case   34:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 820F97C0h case   34:*/		return 0x820F97C4;
		  /* 820F97C4h */ case   35:  		/* li R22, 1 */
		/* 820F97C4h case   35:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 820F97C4h case   35:*/		return 0x820F97C8;
		  /* 820F97C8h */ case   36:  		/* b 36 */
		/* 820F97C8h case   36:*/		return 0x820F97EC;
		/* 820F97C8h case   36:*/		return 0x820F97CC;
	}
	return 0x820F97CC;
} // Block from 820F9738h-820F97CCh (37 instructions)

//////////////////////////////////////////////////////
// Block at 820F97CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F97CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F97CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F97CC);
		  /* 820F97CCh */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 820F97CCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820F97CCh case    0:*/		return 0x820F97D0;
		  /* 820F97D0h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 820F97D0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F97EC;  }
		/* 820F97D0h case    1:*/		return 0x820F97D4;
		  /* 820F97D4h */ case    2:  		/* lwz R11, <#[R31 + 16]> */
		/* 820F97D4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820F97D4h case    2:*/		return 0x820F97D8;
		  /* 820F97D8h */ case    3:  		/* addi R10, R1, 80 */
		/* 820F97D8h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 820F97D8h case    3:*/		return 0x820F97DC;
		  /* 820F97DCh */ case    4:  		/* li R9, 1 */
		/* 820F97DCh case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820F97DCh case    4:*/		return 0x820F97E0;
		  /* 820F97E0h */ case    5:  		/* lwz R24, <#[R31 + 96]> */
		/* 820F97E0h case    5:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R31 + 0x00000060) );
		/* 820F97E0h case    5:*/		return 0x820F97E4;
		  /* 820F97E4h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F97E4h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F97E4h case    6:*/		return 0x820F97E8;
		  /* 820F97E8h */ case    7:  		/* stwx R9, <#[R11 + R10]> */
		/* 820F97E8h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F97E8h case    7:*/		return 0x820F97EC;
	}
	return 0x820F97EC;
} // Block from 820F97CCh-820F97ECh (8 instructions)

//////////////////////////////////////////////////////
// Block at 820F97ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F97EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F97EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F97EC);
		  /* 820F97ECh */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 820F97ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820F97ECh case    0:*/		return 0x820F97F0;
		  /* 820F97F0h */ case    1:  		/* addi R26, R26, 1 */
		/* 820F97F0h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820F97F0h case    1:*/		return 0x820F97F4;
		  /* 820F97F4h */ case    2:  		/* addi R27, R27, 4 */
		/* 820F97F4h case    2:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 820F97F4h case    2:*/		return 0x820F97F8;
		  /* 820F97F8h */ case    3:  		/* cmplw CR6, R26, R11 */
		/* 820F97F8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 820F97F8h case    3:*/		return 0x820F97FC;
		  /* 820F97FCh */ case    4:  		/* bc 12, CR6_LT, -212 */
		/* 820F97FCh case    4:*/		if ( regs.CR[6].lt ) { return 0x820F9728;  }
		/* 820F97FCh case    4:*/		return 0x820F9800;
	}
	return 0x820F9800;
} // Block from 820F97ECh-820F9800h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F9800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9800);
		  /* 820F9800h */ case    0:  		/* li R11, 4 */
		/* 820F9800h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 820F9800h case    0:*/		return 0x820F9804;
		  /* 820F9804h */ case    1:  		/* mr R9, R23 */
		/* 820F9804h case    1:*/		regs.R9 = regs.R23;
		/* 820F9804h case    1:*/		return 0x820F9808;
		  /* 820F9808h */ case    2:  		/* addi R10, R1, 80 */
		/* 820F9808h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 820F9808h case    2:*/		return 0x820F980C;
		  /* 820F980Ch */ case    3:  		/* mtspr CTR, R11 */
		/* 820F980Ch case    3:*/		regs.CTR = regs.R11;
		/* 820F980Ch case    3:*/		return 0x820F9810;
		  /* 820F9810h */ case    4:  		/* lwz R11, <#[R10]> */
		/* 820F9810h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820F9810h case    4:*/		return 0x820F9814;
		  /* 820F9814h */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 820F9814h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820F9814h case    5:*/		return 0x820F9818;
		  /* 820F9818h */ case    6:  		/* bc 12, CR6_EQ, 8 */
		/* 820F9818h case    6:*/		if ( regs.CR[6].eq ) { return 0x820F9820;  }
		/* 820F9818h case    6:*/		return 0x820F981C;
		  /* 820F981Ch */ case    7:  		/* addi R9, R9, 1 */
		/* 820F981Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820F981Ch case    7:*/		return 0x820F9820;
	}
	return 0x820F9820;
} // Block from 820F9800h-820F9820h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820F9820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9820);
		  /* 820F9820h */ case    0:  		/* addi R10, R10, 4 */
		/* 820F9820h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F9820h case    0:*/		return 0x820F9824;
		  /* 820F9824h */ case    1:  		/* bc 16, CR0_LT, -20 */
		/* 820F9824h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F9810;  }
		/* 820F9824h case    1:*/		return 0x820F9828;
		  /* 820F9828h */ case    2:  		/* cmplwi CR6, R9, 4 */
		/* 820F9828h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000004);
		/* 820F9828h case    2:*/		return 0x820F982C;
		  /* 820F982Ch */ case    3:  		/* bc 12, CR6_EQ, 500 */
		/* 820F982Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820F9A20;  }
		/* 820F982Ch case    3:*/		return 0x820F9830;
		  /* 820F9830h */ case    4:  		/* lis R11, -32254 */
		/* 820F9830h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F9830h case    4:*/		return 0x820F9834;
		  /* 820F9834h */ case    5:  		/* li R5, 4541 */
		/* 820F9834h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x11BD);
		/* 820F9834h case    5:*/		return 0x820F9838;
		  /* 820F9838h */ case    6:  		/* addi R6, R11, -14632 */
		/* 820F9838h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFC6D8);
		/* 820F9838h case    6:*/		return 0x820F983C;
		  /* 820F983Ch */ case    7:  		/* mr R4, R24 */
		/* 820F983Ch case    7:*/		regs.R4 = regs.R24;
		/* 820F983Ch case    7:*/		return 0x820F9840;
		  /* 820F9840h */ case    8:  		/* b 468 */
		/* 820F9840h case    8:*/		return 0x820F9A14;
		/* 820F9840h case    8:*/		return 0x820F9844;
	}
	return 0x820F9844;
} // Block from 820F9820h-820F9844h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F9844h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9844( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9844) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9844);
		  /* 820F9844h */ case    0:  		/* li R11, 8 */
		/* 820F9844h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x8);
		/* 820F9844h case    0:*/		return 0x820F9848;
		  /* 820F9848h */ case    1:  		/* addi R10, R1, 88 */
		/* 820F9848h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x58);
		/* 820F9848h case    1:*/		return 0x820F984C;
		  /* 820F984Ch */ case    2:  		/* mr R25, R23 */
		/* 820F984Ch case    2:*/		regs.R25 = regs.R23;
		/* 820F984Ch case    2:*/		return 0x820F9850;
		  /* 820F9850h */ case    3:  		/* mr R9, R23 */
		/* 820F9850h case    3:*/		regs.R9 = regs.R23;
		/* 820F9850h case    3:*/		return 0x820F9854;
		  /* 820F9854h */ case    4:  		/* mtspr CTR, R11 */
		/* 820F9854h case    4:*/		regs.CTR = regs.R11;
		/* 820F9854h case    4:*/		return 0x820F9858;
		  /* 820F9858h */ case    5:  		/* stdu R9, <#[R10 + 8]> */
		/* 820F9858h case    5:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 820F9858h case    5:*/		return 0x820F985C;
		  /* 820F985Ch */ case    6:  		/* bc 16, CR0_LT, -4 */
		/* 820F985Ch case    6:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F9858;  }
		/* 820F985Ch case    6:*/		return 0x820F9860;
		  /* 820F9860h */ case    7:  		/* addi R11, R1, 80 */
		/* 820F9860h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820F9860h case    7:*/		return 0x820F9864;
		  /* 820F9864h */ case    8:  		/* lwz R10, <#[R30 + 8]> */
		/* 820F9864h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 820F9864h case    8:*/		return 0x820F9868;
		  /* 820F9868h */ case    9:  		/* mr R26, R23 */
		/* 820F9868h case    9:*/		regs.R26 = regs.R23;
		/* 820F9868h case    9:*/		return 0x820F986C;
		  /* 820F986Ch */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 820F986Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F986Ch case   10:*/		return 0x820F9870;
		  /* 820F9870h */ case   11:  		/* std R23, <#[R11]> */
		/* 820F9870h case   11:*/		cpu::mem::store64( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 820F9870h case   11:*/		return 0x820F9874;
		  /* 820F9874h */ case   12:  		/* std R23, <#[R11 + 8]> */
		/* 820F9874h case   12:*/		cpu::mem::store64( regs, regs.R23, (uint32)(regs.R11 + 0x00000008) );
		/* 820F9874h case   12:*/		return 0x820F9878;
		  /* 820F9878h */ case   13:  		/* bc 4, CR6_GT, 248 */
		/* 820F9878h case   13:*/		if ( !regs.CR[6].gt ) { return 0x820F9970;  }
		/* 820F9878h case   13:*/		return 0x820F987C;
		  /* 820F987Ch */ case   14:  		/* lis R11, -32254 */
		/* 820F987Ch case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F987Ch case   14:*/		return 0x820F9880;
		  /* 820F9880h */ case   15:  		/* mr R28, R23 */
		/* 820F9880h case   15:*/		regs.R28 = regs.R23;
		/* 820F9880h case   15:*/		return 0x820F9884;
		  /* 820F9884h */ case   16:  		/* addi R27, R11, -14656 */
		/* 820F9884h case   16:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xFFFFC6C0);
		/* 820F9884h case   16:*/		return 0x820F9888;
		  /* 820F9888h */ case   17:  		/* lwz R11, <#[R30 + 20]> */
		/* 820F9888h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820F9888h case   17:*/		return 0x820F988C;
		  /* 820F988Ch */ case   18:  		/* lwz R10, <#[R30 + 16]> */
		/* 820F988Ch case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 820F988Ch case   18:*/		return 0x820F9890;
		  /* 820F9890h */ case   19:  		/* lwzx R31, <#[R11 + R28]> */
		/* 820F9890h case   19:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 820F9890h case   19:*/		return 0x820F9894;
		  /* 820F9894h */ case   20:  		/* lwz R11, <#[R31 + 4]> */
		/* 820F9894h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820F9894h case   20:*/		return 0x820F9898;
		  /* 820F9898h */ case   21:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F9898h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F9898h case   21:*/		return 0x820F989C;
		  /* 820F989Ch */ case   22:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820F989Ch case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F989Ch case   22:*/		return 0x820F98A0;
		  /* 820F98A0h */ case   23:  		/* lwz R11, <#[R11 + 4]> */
		/* 820F98A0h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820F98A0h case   23:*/		return 0x820F98A4;
		  /* 820F98A4h */ case   24:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 820F98A4h case   24:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 820F98A4h case   24:*/		return 0x820F98A8;
		  /* 820F98A8h */ case   25:  		/* bc 12, CR0_EQ, 180 */
		/* 820F98A8h case   25:*/		if ( regs.CR[0].eq ) { return 0x820F995C;  }
		/* 820F98A8h case   25:*/		return 0x820F98AC;
		  /* 820F98ACh */ case   26:  		/* lwz R11, <#[R30]> */
		/* 820F98ACh case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820F98ACh case   26:*/		return 0x820F98B0;
		  /* 820F98B0h */ case   27:  		/* mr R3, R30 */
		/* 820F98B0h case   27:*/		regs.R3 = regs.R30;
		/* 820F98B0h case   27:*/		return 0x820F98B4;
		  /* 820F98B4h */ case   28:  		/* lwz R4, <#[R31 + 108]> */
		/* 820F98B4h case   28:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000006C) );
		/* 820F98B4h case   28:*/		return 0x820F98B8;
		  /* 820F98B8h */ case   29:  		/* lwz R11, <#[R11 + 112]> */
		/* 820F98B8h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000070) );
		/* 820F98B8h case   29:*/		return 0x820F98BC;
		  /* 820F98BCh */ case   30:  		/* mtspr CTR, R11 */
		/* 820F98BCh case   30:*/		regs.CTR = regs.R11;
		/* 820F98BCh case   30:*/		return 0x820F98C0;
		  /* 820F98C0h */ case   31:  		/* bcctrl 20, CR0_LT */
		/* 820F98C0h case   31:*/		if ( 1 ) { regs.LR = 0x820F98C4; return (uint32)regs.CTR; }
		/* 820F98C0h case   31:*/		return 0x820F98C4;
		  /* 820F98C4h */ case   32:  		/* lwz R11, <#[R30]> */
		/* 820F98C4h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820F98C4h case   32:*/		return 0x820F98C8;
		  /* 820F98C8h */ case   33:  		/* mr R29, R3 */
		/* 820F98C8h case   33:*/		regs.R29 = regs.R3;
		/* 820F98C8h case   33:*/		return 0x820F98CC;
		  /* 820F98CCh */ case   34:  		/* mr R3, R30 */
		/* 820F98CCh case   34:*/		regs.R3 = regs.R30;
		/* 820F98CCh case   34:*/		return 0x820F98D0;
		  /* 820F98D0h */ case   35:  		/* lwz R4, <#[R31 + 108]> */
		/* 820F98D0h case   35:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000006C) );
		/* 820F98D0h case   35:*/		return 0x820F98D4;
		  /* 820F98D4h */ case   36:  		/* lwz R11, <#[R11 + 116]> */
		/* 820F98D4h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000074) );
		/* 820F98D4h case   36:*/		return 0x820F98D8;
		  /* 820F98D8h */ case   37:  		/* mtspr CTR, R11 */
		/* 820F98D8h case   37:*/		regs.CTR = regs.R11;
		/* 820F98D8h case   37:*/		return 0x820F98DC;
		  /* 820F98DCh */ case   38:  		/* bcctrl 20, CR0_LT */
		/* 820F98DCh case   38:*/		if ( 1 ) { regs.LR = 0x820F98E0; return (uint32)regs.CTR; }
		/* 820F98DCh case   38:*/		return 0x820F98E0;
		  /* 820F98E0h */ case   39:  		/* cmplwi CR6, R29, 11 */
		/* 820F98E0h case   39:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x0000000B);
		/* 820F98E0h case   39:*/		return 0x820F98E4;
		  /* 820F98E4h */ case   40:  		/* bc 12, CR6_EQ, 72 */
		/* 820F98E4h case   40:*/		if ( regs.CR[6].eq ) { return 0x820F992C;  }
		/* 820F98E4h case   40:*/		return 0x820F98E8;
		  /* 820F98E8h */ case   41:  		/* cmplwi CR6, R29, 13 */
		/* 820F98E8h case   41:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x0000000D);
		/* 820F98E8h case   41:*/		return 0x820F98EC;
		  /* 820F98ECh */ case   42:  		/* bc 4, CR6_EQ, 112 */
		/* 820F98ECh case   42:*/		if ( !regs.CR[6].eq ) { return 0x820F995C;  }
		/* 820F98ECh case   42:*/		return 0x820F98F0;
		  /* 820F98F0h */ case   43:  		/* cmplwi CR6, R3, 0 */
		/* 820F98F0h case   43:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820F98F0h case   43:*/		return 0x820F98F4;
		  /* 820F98F4h */ case   44:  		/* bc 4, CR6_EQ, 104 */
		/* 820F98F4h case   44:*/		if ( !regs.CR[6].eq ) { return 0x820F995C;  }
		/* 820F98F4h case   44:*/		return 0x820F98F8;
		  /* 820F98F8h */ case   45:  		/* lwz R11, <#[R31 + 16]> */
		/* 820F98F8h case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820F98F8h case   45:*/		return 0x820F98FC;
		  /* 820F98FCh */ case   46:  		/* cmplwi CR6, R11, 0 */
		/* 820F98FCh case   46:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F98FCh case   46:*/		return 0x820F9900;
		  /* 820F9900h */ case   47:  		/* bc 12, CR6_EQ, 92 */
		/* 820F9900h case   47:*/		if ( regs.CR[6].eq ) { return 0x820F995C;  }
		/* 820F9900h case   47:*/		return 0x820F9904;
		  /* 820F9904h */ case   48:  		/* cmpwi CR6, R25, 0 */
		/* 820F9904h case   48:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 820F9904h case   48:*/		return 0x820F9908;
		  /* 820F9908h */ case   49:  		/* bc 4, CR6_EQ, 84 */
		/* 820F9908h case   49:*/		if ( !regs.CR[6].eq ) { return 0x820F995C;  }
		/* 820F9908h case   49:*/		return 0x820F990C;
		  /* 820F990Ch */ case   50:  		/* mr R6, R27 */
		/* 820F990Ch case   50:*/		regs.R6 = regs.R27;
		/* 820F990Ch case   50:*/		return 0x820F9910;
		  /* 820F9910h */ case   51:  		/* lwz R4, <#[R31 + 96]> */
		/* 820F9910h case   51:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000060) );
		/* 820F9910h case   51:*/		return 0x820F9914;
		  /* 820F9914h */ case   52:  		/* li R5, 4528 */
		/* 820F9914h case   52:*/		cpu::op::li<0>(regs,&regs.R5,0x11B0);
		/* 820F9914h case   52:*/		return 0x820F9918;
	}
	return 0x820F9918;
} // Block from 820F9844h-820F9918h (53 instructions)

//////////////////////////////////////////////////////
// Block at 820F9918h
// Function '?EmitDSX@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9918);
		  /* 820F9918h */ case    0:  		/* mr R3, R30 */
		/* 820F9918h case    0:*/		regs.R3 = regs.R30;
		/* 820F9918h case    0:*/		return 0x820F991C;
		  /* 820F991Ch */ case    1:  		/* bl 85524 */
		/* 820F991Ch case    1:*/		regs.LR = 0x820F9920; return 0x8210E730;
		/* 820F991Ch case    1:*/		return 0x820F9920;
		  /* 820F9920h */ case    2:  		/* li R25, 1 */
		/* 820F9920h case    2:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 820F9920h case    2:*/		return 0x820F9924;
		  /* 820F9924h */ case    3:  		/* li R22, 1 */
		/* 820F9924h case    3:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 820F9924h case    3:*/		return 0x820F9928;
	}
	return 0x820F9928;
} // Block from 820F9918h-820F9928h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F9928h
// Function '?EmitDSY@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9928);
		  /* 820F9928h */ case    0:  		/* b 52 */
		/* 820F9928h case    0:*/		return 0x820F995C;
		/* 820F9928h case    0:*/		return 0x820F992C;
	}
	return 0x820F992C;
} // Block from 820F9928h-820F992Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F992Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F992C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F992C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F992C);
		  /* 820F992Ch */ case    0:  		/* cmplwi CR6, R3, 4 */
		/* 820F992Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000004);
		/* 820F992Ch case    0:*/		return 0x820F9930;
		  /* 820F9930h */ case    1:  		/* bc 4, CR6_LT, 44 */
		/* 820F9930h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820F995C;  }
		/* 820F9930h case    1:*/		return 0x820F9934;
		  /* 820F9934h */ case    2:  		/* lwz R10, <#[R31 + 16]> */
		/* 820F9934h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820F9934h case    2:*/		return 0x820F9938;
	}
	return 0x820F9938;
} // Block from 820F992Ch-820F9938h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F9938h
// Function '?EmitRCP@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9938);
		  /* 820F9938h */ case    0:  		/* rlwinm R11, R3, 2, 0, 29 */
		/* 820F9938h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R3);
		/* 820F9938h case    0:*/		return 0x820F993C;
		  /* 820F993Ch */ case    1:  		/* lwz R9, <#[R31 + 96]> */
		/* 820F993Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000060) );
		/* 820F993Ch case    1:*/		return 0x820F9940;
		  /* 820F9940h */ case    2:  		/* addi R8, R1, 96 */
		/* 820F9940h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 820F9940h case    2:*/		return 0x820F9944;
		  /* 820F9944h */ case    3:  		/* add R10, R10, R11 */
		/* 820F9944h case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820F9944h case    3:*/		return 0x820F9948;
		  /* 820F9948h */ case    4:  		/* addi R7, R1, 80 */
		/* 820F9948h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 820F9948h case    4:*/		return 0x820F994C;
		  /* 820F994Ch */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F994Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F994Ch case    5:*/		return 0x820F9950;
		  /* 820F9950h */ case    6:  		/* li R6, 1 */
		/* 820F9950h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820F9950h case    6:*/		return 0x820F9954;
		  /* 820F9954h */ case    7:  		/* stwx R9, <#[R11 + R7]> */
		/* 820F9954h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820F9954h case    7:*/		return 0x820F9958;
		  /* 820F9958h */ case    8:  		/* stwx R6, <#[R10 + R8]> */
		/* 820F9958h case    8:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820F9958h case    8:*/		return 0x820F995C;
	}
	return 0x820F995C;
} // Block from 820F9938h-820F995Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F995Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F995C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F995C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F995C);
		  /* 820F995Ch */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 820F995Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820F995Ch case    0:*/		return 0x820F9960;
	}
	return 0x820F9960;
} // Block from 820F995Ch-820F9960h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F9960h
// Function '?EmitFRC@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9960);
		  /* 820F9960h */ case    0:  		/* addi R26, R26, 1 */
		/* 820F9960h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820F9960h case    0:*/		return 0x820F9964;
		  /* 820F9964h */ case    1:  		/* addi R28, R28, 4 */
		/* 820F9964h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820F9964h case    1:*/		return 0x820F9968;
		  /* 820F9968h */ case    2:  		/* cmplw CR6, R26, R11 */
		/* 820F9968h case    2:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 820F9968h case    2:*/		return 0x820F996C;
		  /* 820F996Ch */ case    3:  		/* bc 12, CR6_LT, -228 */
		/* 820F996Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x820F9888;  }
		/* 820F996Ch case    3:*/		return 0x820F9970;
	}
	return 0x820F9970;
} // Block from 820F9960h-820F9970h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F9970h
// Function '?EmitEXP@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9970);
		  /* 820F9970h */ case    0:  		/* lis R11, -32254 */
		/* 820F9970h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F9970h case    0:*/		return 0x820F9974;
		  /* 820F9974h */ case    1:  		/* lis R10, -32254 */
		/* 820F9974h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820F9974h case    1:*/		return 0x820F9978;
		  /* 820F9978h */ case    2:  		/* mr R27, R23 */
		/* 820F9978h case    2:*/		regs.R27 = regs.R23;
		/* 820F9978h case    2:*/		return 0x820F997C;
		  /* 820F997Ch */ case    3:  		/* li R26, 1 */
		/* 820F997Ch case    3:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 820F997Ch case    3:*/		return 0x820F9980;
		  /* 820F9980h */ case    4:  		/* mr R31, R23 */
		/* 820F9980h case    4:*/		regs.R31 = regs.R23;
		/* 820F9980h case    4:*/		return 0x820F9984;
		  /* 820F9984h */ case    5:  		/* addi R29, R11, -14696 */
		/* 820F9984h case    5:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFFC698);
		/* 820F9984h case    5:*/		return 0x820F9988;
		  /* 820F9988h */ case    6:  		/* addi R28, R10, -14760 */
		/* 820F9988h case    6:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R10,0xFFFFC658);
		/* 820F9988h case    6:*/		return 0x820F998C;
		  /* 820F998Ch */ case    7:  		/* li R8, 4 */
		/* 820F998Ch case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 820F998Ch case    7:*/		return 0x820F9990;
		  /* 820F9990h */ case    8:  		/* mr R10, R23 */
		/* 820F9990h case    8:*/		regs.R10 = regs.R23;
		/* 820F9990h case    8:*/		return 0x820F9994;
		  /* 820F9994h */ case    9:  		/* mr R11, R23 */
		/* 820F9994h case    9:*/		regs.R11 = regs.R23;
		/* 820F9994h case    9:*/		return 0x820F9998;
	}
	return 0x820F9998;
} // Block from 820F9970h-820F9998h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F9998h
// Function '?EmitLOG@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9998);
		  /* 820F9998h */ case    0:  		/* rlwinm R9, R31, 2, 0, 29 */
		/* 820F9998h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R31);
		/* 820F9998h case    0:*/		return 0x820F999C;
		  /* 820F999Ch */ case    1:  		/* mtspr CTR, R8 */
		/* 820F999Ch case    1:*/		regs.CTR = regs.R8;
		/* 820F999Ch case    1:*/		return 0x820F99A0;
		  /* 820F99A0h */ case    2:  		/* add R8, R9, R11 */
		/* 820F99A0h case    2:*/		cpu::op::add<0>(regs,&regs.R8,regs.R9,regs.R11);
		/* 820F99A0h case    2:*/		return 0x820F99A4;
		  /* 820F99A4h */ case    3:  		/* addi R7, R1, 96 */
		/* 820F99A4h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820F99A4h case    3:*/		return 0x820F99A8;
		  /* 820F99A8h */ case    4:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820F99A8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820F99A8h case    4:*/		return 0x820F99AC;
		  /* 820F99ACh */ case    5:  		/* addi R11, R11, 1 */
		/* 820F99ACh case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F99ACh case    5:*/		return 0x820F99B0;
		  /* 820F99B0h */ case    6:  		/* lwzx R8, <#[R8 + R7]> */
		/* 820F99B0h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 820F99B0h case    6:*/		return 0x820F99B4;
		  /* 820F99B4h */ case    7:  		/* addic R7, R8, -1 */
		/* 820F99B4h case    7:*/		cpu::op::addic<0>(regs,&regs.R7,regs.R8,0xFFFFFFFF);
		/* 820F99B4h case    7:*/		return 0x820F99B8;
		  /* 820F99B8h */ case    8:  		/* subfe R8, R7, R8 */
		/* 820F99B8h case    8:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820F99B8h case    8:*/		return 0x820F99BC;
		  /* 820F99BCh */ case    9:  		/* add R10, R8, R10 */
		/* 820F99BCh case    9:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 820F99BCh case    9:*/		return 0x820F99C0;
	}
	return 0x820F99C0;
} // Block from 820F9998h-820F99C0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F99C0h
// Function '?EmitRSQ@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F99C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F99C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F99C0);
		  /* 820F99C0h */ case    0:  		/* bc 16, CR0_LT, -32 */
		/* 820F99C0h case    0:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F99A0;  }
		/* 820F99C0h case    0:*/		return 0x820F99C4;
		  /* 820F99C4h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820F99C4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F99C4h case    1:*/		return 0x820F99C8;
		  /* 820F99C8h */ case    2:  		/* bc 4, CR6_EQ, 116 */
		/* 820F99C8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820F9A3C;  }
		/* 820F99C8h case    2:*/		return 0x820F99CC;
		  /* 820F99CCh */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 820F99CCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820F99CCh case    3:*/		return 0x820F99D0;
		  /* 820F99D0h */ case    4:  		/* bc 4, CR6_EQ, 28 */
		/* 820F99D0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820F99EC;  }
		/* 820F99D0h case    4:*/		return 0x820F99D4;
		  /* 820F99D4h */ case    5:  		/* mr R6, R28 */
		/* 820F99D4h case    5:*/		regs.R6 = regs.R28;
		/* 820F99D4h case    5:*/		return 0x820F99D8;
		  /* 820F99D8h */ case    6:  		/* lwz R4, <#[R1 + 80]> */
		/* 820F99D8h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 820F99D8h case    6:*/		return 0x820F99DC;
		  /* 820F99DCh */ case    7:  		/* li R5, 4530 */
		/* 820F99DCh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x11B2);
		/* 820F99DCh case    7:*/		return 0x820F99E0;
		  /* 820F99E0h */ case    8:  		/* mr R3, R30 */
		/* 820F99E0h case    8:*/		regs.R3 = regs.R30;
		/* 820F99E0h case    8:*/		return 0x820F99E4;
		  /* 820F99E4h */ case    9:  		/* bl 85324 */
		/* 820F99E4h case    9:*/		regs.LR = 0x820F99E8; return 0x8210E730;
		/* 820F99E4h case    9:*/		return 0x820F99E8;
	}
	return 0x820F99E8;
} // Block from 820F99C0h-820F99E8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F99E8h
// Function '?EmitMIN@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F99E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F99E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F99E8);
		  /* 820F99E8h */ case    0:  		/* li R22, 1 */
		/* 820F99E8h case    0:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 820F99E8h case    0:*/		return 0x820F99EC;
	}
	return 0x820F99EC;
} // Block from 820F99E8h-820F99ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F99ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F99EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F99EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F99EC);
		  /* 820F99ECh */ case    0:  		/* li R27, 1 */
		/* 820F99ECh case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 820F99ECh case    0:*/		return 0x820F99F0;
		  /* 820F99F0h */ case    1:  		/* addi R31, R31, 1 */
		/* 820F99F0h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820F99F0h case    1:*/		return 0x820F99F4;
		  /* 820F99F4h */ case    2:  		/* cmplwi CR6, R31, 4 */
		/* 820F99F4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000004);
		/* 820F99F4h case    2:*/		return 0x820F99F8;
	}
	return 0x820F99F8;
} // Block from 820F99ECh-820F99F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F99F8h
// Function '?EmitMAX@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F99F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F99F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F99F8);
		  /* 820F99F8h */ case    0:  		/* bc 12, CR6_LT, -108 */
		/* 820F99F8h case    0:*/		if ( regs.CR[6].lt ) { return 0x820F998C;  }
		/* 820F99F8h case    0:*/		return 0x820F99FC;
		  /* 820F99FCh */ case    1:  		/* cmpwi CR6, R26, 0 */
		/* 820F99FCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 820F99FCh case    1:*/		return 0x820F9A00;
		  /* 820F9A00h */ case    2:  		/* bc 4, CR6_EQ, 32 */
		/* 820F9A00h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820F9A20;  }
		/* 820F9A00h case    2:*/		return 0x820F9A04;
		  /* 820F9A04h */ case    3:  		/* lis R11, -32254 */
		/* 820F9A04h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F9A04h case    3:*/		return 0x820F9A08;
	}
	return 0x820F9A08;
} // Block from 820F99F8h-820F9A08h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F9A08h
// Function '?EmitLT@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9A08);
		  /* 820F9A08h */ case    0:  		/* li R5, 4538 */
		/* 820F9A08h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x11BA);
		/* 820F9A08h case    0:*/		return 0x820F9A0C;
		  /* 820F9A0Ch */ case    1:  		/* addi R6, R11, -14820 */
		/* 820F9A0Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFC61C);
		/* 820F9A0Ch case    1:*/		return 0x820F9A10;
		  /* 820F9A10h */ case    2:  		/* li R4, 0 */
		/* 820F9A10h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F9A10h case    2:*/		return 0x820F9A14;
	}
	return 0x820F9A14;
} // Block from 820F9A08h-820F9A14h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F9A14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9A14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9A14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9A14);
		  /* 820F9A14h */ case    0:  		/* mr R3, R30 */
		/* 820F9A14h case    0:*/		regs.R3 = regs.R30;
		/* 820F9A14h case    0:*/		return 0x820F9A18;
	}
	return 0x820F9A18;
} // Block from 820F9A14h-820F9A18h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F9A18h
// Function '?EmitGE@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9A18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9A18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9A18);
		  /* 820F9A18h */ case    0:  		/* bl 85272 */
		/* 820F9A18h case    0:*/		regs.LR = 0x820F9A1C; return 0x8210E730;
		/* 820F9A18h case    0:*/		return 0x820F9A1C;
		  /* 820F9A1Ch */ case    1:  		/* li R22, 1 */
		/* 820F9A1Ch case    1:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 820F9A1Ch case    1:*/		return 0x820F9A20;
	}
	return 0x820F9A20;
} // Block from 820F9A18h-820F9A20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F9A20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9A20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9A20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9A20);
		  /* 820F9A20h */ case    0:  		/* subfic R11, R22, 0 */
		/* 820F9A20h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R22,0x0);
		/* 820F9A20h case    0:*/		return 0x820F9A24;
		  /* 820F9A24h */ case    1:  		/* lis R10, -32768 */
		/* 820F9A24h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8000);
		/* 820F9A24h case    1:*/		return 0x820F9A28;
	}
	return 0x820F9A28;
} // Block from 820F9A20h-820F9A28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F9A28h
// Function '?EmitADD@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9A28);
		  /* 820F9A28h */ case    0:  		/* subfe R11, R11, R11 */
		/* 820F9A28h case    0:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820F9A28h case    0:*/		return 0x820F9A2C;
		  /* 820F9A2Ch */ case    1:  		/* ori R10, R10, 16389 */
		/* 820F9A2Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x4005);
		/* 820F9A2Ch case    1:*/		return 0x820F9A30;
		  /* 820F9A30h */ case    2:  		/* and R3, R11, R10 */
		/* 820F9A30h case    2:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 820F9A30h case    2:*/		return 0x820F9A34;
	}
	return 0x820F9A34;
} // Block from 820F9A28h-820F9A34h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F9A34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9A34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9A34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9A34);
		  /* 820F9A34h */ case    0:  		/* addi R1, R1, 256 */
		/* 820F9A34h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 820F9A34h case    0:*/		return 0x820F9A38;
	}
	return 0x820F9A38;
} // Block from 820F9A34h-820F9A38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F9A38h
// Function '?EmitMUL@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9A38);
		  /* 820F9A38h */ case    0:  		/* b -427944 */
		/* 820F9A38h case    0:*/		return 0x82091290;
		/* 820F9A38h case    0:*/		return 0x820F9A3C;
	}
	return 0x820F9A3C;
} // Block from 820F9A38h-820F9A3Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F9A3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9A3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9A3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9A3C);
		  /* 820F9A3Ch */ case    0:  		/* cmplwi CR6, R10, 4 */
		/* 820F9A3Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 820F9A3Ch case    0:*/		return 0x820F9A40;
		  /* 820F9A40h */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 820F9A40h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F9A64;  }
		/* 820F9A40h case    1:*/		return 0x820F9A44;
		  /* 820F9A44h */ case    2:  		/* addi R11, R1, 80 */
		/* 820F9A44h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820F9A44h case    2:*/		return 0x820F9A48;
	}
	return 0x820F9A48;
} // Block from 820F9A3Ch-820F9A48h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F9A48h
// Function '?EmitDST@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9A48);
		  /* 820F9A48h */ case    0:  		/* mr R6, R29 */
		/* 820F9A48h case    0:*/		regs.R6 = regs.R29;
		/* 820F9A48h case    0:*/		return 0x820F9A4C;
		  /* 820F9A4Ch */ case    1:  		/* mr R7, R31 */
		/* 820F9A4Ch case    1:*/		regs.R7 = regs.R31;
		/* 820F9A4Ch case    1:*/		return 0x820F9A50;
		  /* 820F9A50h */ case    2:  		/* li R5, 4529 */
		/* 820F9A50h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x11B1);
		/* 820F9A50h case    2:*/		return 0x820F9A54;
		  /* 820F9A54h */ case    3:  		/* mr R3, R30 */
		/* 820F9A54h case    3:*/		regs.R3 = regs.R30;
		/* 820F9A54h case    3:*/		return 0x820F9A58;
	}
	return 0x820F9A58;
} // Block from 820F9A48h-820F9A58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F9A58h
// Function '?EmitDOT@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9A58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9A58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9A58);
		  /* 820F9A58h */ case    0:  		/* lwzx R4, <#[R9 + R11]> */
		/* 820F9A58h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820F9A58h case    0:*/		return 0x820F9A5C;
		  /* 820F9A5Ch */ case    1:  		/* bl 85204 */
		/* 820F9A5Ch case    1:*/		regs.LR = 0x820F9A60; return 0x8210E730;
		/* 820F9A5Ch case    1:*/		return 0x820F9A60;
		  /* 820F9A60h */ case    2:  		/* li R22, 1 */
		/* 820F9A60h case    2:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 820F9A60h case    2:*/		return 0x820F9A64;
	}
	return 0x820F9A64;
} // Block from 820F9A58h-820F9A64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F9A64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9A64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9A64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9A64);
		  /* 820F9A64h */ case    0:  		/* cmpwi CR6, R27, 0 */
		/* 820F9A64h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 820F9A64h case    0:*/		return 0x820F9A68;
		  /* 820F9A68h */ case    1:  		/* bc 12, CR6_EQ, -120 */
		/* 820F9A68h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F99F0;  }
		/* 820F9A68h case    1:*/		return 0x820F9A6C;
		  /* 820F9A6Ch */ case    2:  		/* mr R26, R23 */
		/* 820F9A6Ch case    2:*/		regs.R26 = regs.R23;
		/* 820F9A6Ch case    2:*/		return 0x820F9A70;
		  /* 820F9A70h */ case    3:  		/* b -128 */
		/* 820F9A70h case    3:*/		return 0x820F99F0;
		/* 820F9A70h case    3:*/		return 0x820F9A74;
		  /* 820F9A74h */ case    4:  		/* nop */
		/* 820F9A74h case    4:*/		cpu::op::nop();
		/* 820F9A74h case    4:*/		return 0x820F9A78;
	}
	return 0x820F9A78;
} // Block from 820F9A64h-820F9A78h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F9A78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9A78);
		  /* 820F9A78h */ case    0:  		/* mfspr R12, LR */
		/* 820F9A78h case    0:*/		regs.R12 = regs.LR;
		/* 820F9A78h case    0:*/		return 0x820F9A7C;
		  /* 820F9A7Ch */ case    1:  		/* bl -428076 */
		/* 820F9A7Ch case    1:*/		regs.LR = 0x820F9A80; return 0x82091250;
		/* 820F9A7Ch case    1:*/		return 0x820F9A80;
		  /* 820F9A80h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820F9A80h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820F9A80h case    2:*/		return 0x820F9A84;
		  /* 820F9A84h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820F9A84h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F9A84h case    3:*/		return 0x820F9A88;
		  /* 820F9A88h */ case    4:  		/* mr R31, R4 */
		/* 820F9A88h case    4:*/		regs.R31 = regs.R4;
		/* 820F9A88h case    4:*/		return 0x820F9A8C;
		  /* 820F9A8Ch */ case    5:  		/* lwz R4, <#[R4 + 108]> */
		/* 820F9A8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x0000006C) );
		/* 820F9A8Ch case    5:*/		return 0x820F9A90;
		  /* 820F9A90h */ case    6:  		/* mr R26, R3 */
		/* 820F9A90h case    6:*/		regs.R26 = regs.R3;
		/* 820F9A90h case    6:*/		return 0x820F9A94;
		  /* 820F9A94h */ case    7:  		/* mr R29, R5 */
		/* 820F9A94h case    7:*/		regs.R29 = regs.R5;
		/* 820F9A94h case    7:*/		return 0x820F9A98;
		  /* 820F9A98h */ case    8:  		/* mr R28, R6 */
		/* 820F9A98h case    8:*/		regs.R28 = regs.R6;
		/* 820F9A98h case    8:*/		return 0x820F9A9C;
		  /* 820F9A9Ch */ case    9:  		/* mr R27, R7 */
		/* 820F9A9Ch case    9:*/		regs.R27 = regs.R7;
		/* 820F9A9Ch case    9:*/		return 0x820F9AA0;
		  /* 820F9AA0h */ case   10:  		/* lwz R11, <#[R11 + 112]> */
		/* 820F9AA0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000070) );
		/* 820F9AA0h case   10:*/		return 0x820F9AA4;
		  /* 820F9AA4h */ case   11:  		/* mtspr CTR, R11 */
		/* 820F9AA4h case   11:*/		regs.CTR = regs.R11;
		/* 820F9AA4h case   11:*/		return 0x820F9AA8;
		  /* 820F9AA8h */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 820F9AA8h case   12:*/		if ( 1 ) { regs.LR = 0x820F9AAC; return (uint32)regs.CTR; }
		/* 820F9AA8h case   12:*/		return 0x820F9AAC;
		  /* 820F9AACh */ case   13:  		/* lwz R11, <#[R26]> */
		/* 820F9AACh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820F9AACh case   13:*/		return 0x820F9AB0;
		  /* 820F9AB0h */ case   14:  		/* mr R30, R3 */
		/* 820F9AB0h case   14:*/		regs.R30 = regs.R3;
		/* 820F9AB0h case   14:*/		return 0x820F9AB4;
		  /* 820F9AB4h */ case   15:  		/* mr R3, R26 */
		/* 820F9AB4h case   15:*/		regs.R3 = regs.R26;
		/* 820F9AB4h case   15:*/		return 0x820F9AB8;
		  /* 820F9AB8h */ case   16:  		/* lwz R4, <#[R31 + 108]> */
		/* 820F9AB8h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000006C) );
		/* 820F9AB8h case   16:*/		return 0x820F9ABC;
		  /* 820F9ABCh */ case   17:  		/* lwz R11, <#[R11 + 116]> */
		/* 820F9ABCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000074) );
		/* 820F9ABCh case   17:*/		return 0x820F9AC0;
		  /* 820F9AC0h */ case   18:  		/* mtspr CTR, R11 */
		/* 820F9AC0h case   18:*/		regs.CTR = regs.R11;
		/* 820F9AC0h case   18:*/		return 0x820F9AC4;
		  /* 820F9AC4h */ case   19:  		/* bcctrl 20, CR0_LT */
		/* 820F9AC4h case   19:*/		if ( 1 ) { regs.LR = 0x820F9AC8; return (uint32)regs.CTR; }
		/* 820F9AC4h case   19:*/		return 0x820F9AC8;
		  /* 820F9AC8h */ case   20:  		/* stw R3, <#[R29]> */
		/* 820F9AC8h case   20:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 820F9AC8h case   20:*/		return 0x820F9ACC;
		  /* 820F9ACCh */ case   21:  		/* lwz R11, <#[R26 + 112]> */
		/* 820F9ACCh case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000070) );
		/* 820F9ACCh case   21:*/		return 0x820F9AD0;
		  /* 820F9AD0h */ case   22:  		/* rlwinm. R11, R11, 0, 7, 7 */
		/* 820F9AD0h case   22:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R11,regs.R11);
		/* 820F9AD0h case   22:*/		return 0x820F9AD4;
		  /* 820F9AD4h */ case   23:  		/* li R11, 0 */
		/* 820F9AD4h case   23:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F9AD4h case   23:*/		return 0x820F9AD8;
		  /* 820F9AD8h */ case   24:  		/* bc 12, CR0_EQ, 88 */
		/* 820F9AD8h case   24:*/		if ( regs.CR[0].eq ) { return 0x820F9B30;  }
		/* 820F9AD8h case   24:*/		return 0x820F9ADC;
		  /* 820F9ADCh */ case   25:  		/* cmplwi CR6, R27, 0 */
		/* 820F9ADCh case   25:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820F9ADCh case   25:*/		return 0x820F9AE0;
		  /* 820F9AE0h */ case   26:  		/* bc 12, CR6_EQ, 8 */
		/* 820F9AE0h case   26:*/		if ( regs.CR[6].eq ) { return 0x820F9AE8;  }
		/* 820F9AE0h case   26:*/		return 0x820F9AE4;
		  /* 820F9AE4h */ case   27:  		/* stw R11, <#[R27]> */
		/* 820F9AE4h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820F9AE4h case   27:*/		return 0x820F9AE8;
	}
	return 0x820F9AE8;
} // Block from 820F9A78h-820F9AE8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820F9AE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9AE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9AE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9AE8);
		  /* 820F9AE8h */ case    0:  		/* cmplwi CR6, R30, 5 */
		/* 820F9AE8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000005);
		/* 820F9AE8h case    0:*/		return 0x820F9AEC;
		  /* 820F9AECh */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 820F9AECh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F9B0C;  }
		/* 820F9AECh case    1:*/		return 0x820F9AF0;
		  /* 820F9AF0h */ case    2:  		/* lwz R10, <#[R29]> */
		/* 820F9AF0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 820F9AF0h case    2:*/		return 0x820F9AF4;
		  /* 820F9AF4h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 820F9AF4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F9AF4h case    3:*/		return 0x820F9AF8;
		  /* 820F9AF8h */ case    4:  		/* bc 4, CR6_EQ, 36 */
		/* 820F9AF8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820F9B1C;  }
		/* 820F9AF8h case    4:*/		return 0x820F9AFC;
		  /* 820F9AFCh */ case    5:  		/* cmplwi CR6, R27, 0 */
		/* 820F9AFCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820F9AFCh case    5:*/		return 0x820F9B00;
		  /* 820F9B00h */ case    6:  		/* bc 12, CR6_EQ, 28 */
		/* 820F9B00h case    6:*/		if ( regs.CR[6].eq ) { return 0x820F9B1C;  }
		/* 820F9B00h case    6:*/		return 0x820F9B04;
		  /* 820F9B04h */ case    7:  		/* li R10, 1 */
		/* 820F9B04h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820F9B04h case    7:*/		return 0x820F9B08;
		  /* 820F9B08h */ case    8:  		/* stw R10, <#[R27]> */
		/* 820F9B08h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 820F9B08h case    8:*/		return 0x820F9B0C;
	}
	return 0x820F9B0C;
} // Block from 820F9AE8h-820F9B0Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F9B0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9B0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9B0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9B0C);
		  /* 820F9B0Ch */ case    0:  		/* cmplwi CR6, R30, 65535 */
		/* 820F9B0Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x0000FFFF);
		/* 820F9B0Ch case    0:*/		return 0x820F9B10;
		  /* 820F9B10h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820F9B10h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F9B1C;  }
		/* 820F9B10h case    1:*/		return 0x820F9B14;
		  /* 820F9B14h */ case    2:  		/* stw R11, <#[R28]> */
		/* 820F9B14h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820F9B14h case    2:*/		return 0x820F9B18;
		  /* 820F9B18h */ case    3:  		/* b 172 */
		/* 820F9B18h case    3:*/		return 0x820F9BC4;
		/* 820F9B18h case    3:*/		return 0x820F9B1C;
	}
	return 0x820F9B1C;
} // Block from 820F9B0Ch-820F9B1Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F9B1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9B1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9B1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9B1C);
		  /* 820F9B1Ch */ case    0:  		/* li R11, 6 */
		/* 820F9B1Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x6);
		/* 820F9B1Ch case    0:*/		return 0x820F9B20;
		  /* 820F9B20h */ case    1:  		/* stw R11, <#[R28]> */
		/* 820F9B20h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820F9B20h case    1:*/		return 0x820F9B24;
		  /* 820F9B24h */ case    2:  		/* lwz R11, <#[R31 + 12]> */
		/* 820F9B24h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820F9B24h case    2:*/		return 0x820F9B28;
		  /* 820F9B28h */ case    3:  		/* stw R11, <#[R29]> */
		/* 820F9B28h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820F9B28h case    3:*/		return 0x820F9B2C;
		  /* 820F9B2Ch */ case    4:  		/* b 152 */
		/* 820F9B2Ch case    4:*/		return 0x820F9BC4;
		/* 820F9B2Ch case    4:*/		return 0x820F9B30;
	}
	return 0x820F9B30;
} // Block from 820F9B1Ch-820F9B30h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F9B30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9B30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9B30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9B30);
		  /* 820F9B30h */ case    0:  		/* cmplwi CR6, R30, 11 */
		/* 820F9B30h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x0000000B);
		/* 820F9B30h case    0:*/		return 0x820F9B34;
		  /* 820F9B34h */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 820F9B34h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F9B48;  }
		/* 820F9B34h case    1:*/		return 0x820F9B38;
		  /* 820F9B38h */ case    2:  		/* cmplwi CR6, R3, 4 */
		/* 820F9B38h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000004);
		/* 820F9B38h case    2:*/		return 0x820F9B3C;
		  /* 820F9B3Ch */ case    3:  		/* bc 4, CR6_LT, 144 */
		/* 820F9B3Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x820F9BCC;  }
		/* 820F9B3Ch case    3:*/		return 0x820F9B40;
		  /* 820F9B40h */ case    4:  		/* li R10, 8 */
		/* 820F9B40h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x8);
		/* 820F9B40h case    4:*/		return 0x820F9B44;
		  /* 820F9B44h */ case    5:  		/* b 28 */
		/* 820F9B44h case    5:*/		return 0x820F9B60;
		/* 820F9B44h case    5:*/		return 0x820F9B48;
	}
	return 0x820F9B48;
} // Block from 820F9B30h-820F9B48h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F9B48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9B48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9B48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9B48);
		  /* 820F9B48h */ case    0:  		/* cmplwi CR6, R30, 13 */
		/* 820F9B48h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x0000000D);
		/* 820F9B48h case    0:*/		return 0x820F9B4C;
		  /* 820F9B4Ch */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 820F9B4Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F9B68;  }
		/* 820F9B4Ch case    1:*/		return 0x820F9B50;
		  /* 820F9B50h */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 820F9B50h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820F9B50h case    2:*/		return 0x820F9B54;
		  /* 820F9B54h */ case    3:  		/* bc 4, CR6_EQ, 120 */
		/* 820F9B54h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820F9BCC;  }
		/* 820F9B54h case    3:*/		return 0x820F9B58;
		  /* 820F9B58h */ case    4:  		/* li R10, 9 */
		/* 820F9B58h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x9);
		/* 820F9B58h case    4:*/		return 0x820F9B5C;
		  /* 820F9B5Ch */ case    5:  		/* li R11, 1 */
		/* 820F9B5Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820F9B5Ch case    5:*/		return 0x820F9B60;
	}
	return 0x820F9B60;
} // Block from 820F9B48h-820F9B60h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F9B60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9B60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9B60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9B60);
		  /* 820F9B60h */ case    0:  		/* stw R10, <#[R28]> */
		/* 820F9B60h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 820F9B60h case    0:*/		return 0x820F9B64;
		  /* 820F9B64h */ case    1:  		/* b 84 */
		/* 820F9B64h case    1:*/		return 0x820F9BB8;
		/* 820F9B64h case    1:*/		return 0x820F9B68;
	}
	return 0x820F9B68;
} // Block from 820F9B60h-820F9B68h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F9B68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9B68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9B68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9B68);
		  /* 820F9B68h */ case    0:  		/* cmplwi CR6, R30, 17 */
		/* 820F9B68h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000011);
		/* 820F9B68h case    0:*/		return 0x820F9B6C;
		  /* 820F9B6Ch */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 820F9B6Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F9B8C;  }
		/* 820F9B6Ch case    1:*/		return 0x820F9B70;
		  /* 820F9B70h */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 820F9B70h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820F9B70h case    2:*/		return 0x820F9B74;
		  /* 820F9B74h */ case    3:  		/* bc 4, CR6_EQ, 88 */
		/* 820F9B74h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820F9BCC;  }
		/* 820F9B74h case    3:*/		return 0x820F9B78;
		  /* 820F9B78h */ case    4:  		/* li R10, 17 */
		/* 820F9B78h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x11);
		/* 820F9B78h case    4:*/		return 0x820F9B7C;
		  /* 820F9B7Ch */ case    5:  		/* li R9, 1 */
		/* 820F9B7Ch case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820F9B7Ch case    5:*/		return 0x820F9B80;
		  /* 820F9B80h */ case    6:  		/* stw R10, <#[R28]> */
		/* 820F9B80h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 820F9B80h case    6:*/		return 0x820F9B84;
		  /* 820F9B84h */ case    7:  		/* stw R9, <#[R29]> */
		/* 820F9B84h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R29 + 0x00000000) );
		/* 820F9B84h case    7:*/		return 0x820F9B88;
	}
	return 0x820F9B88;
} // Block from 820F9B68h-820F9B88h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820F9B88h
// Function '?EmitLIT@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9B88);
		  /* 820F9B88h */ case    0:  		/* b 48 */
		/* 820F9B88h case    0:*/		return 0x820F9BB8;
		/* 820F9B88h case    0:*/		return 0x820F9B8C;
	}
	return 0x820F9B8C;
} // Block from 820F9B88h-820F9B8Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F9B8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9B8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9B8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9B8C);
		  /* 820F9B8Ch */ case    0:  		/* cmplwi CR6, R30, 18 */
		/* 820F9B8Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000012);
		/* 820F9B8Ch case    0:*/		return 0x820F9B90;
		  /* 820F9B90h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 820F9B90h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F9BAC;  }
		/* 820F9B90h case    1:*/		return 0x820F9B94;
		  /* 820F9B94h */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 820F9B94h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820F9B94h case    2:*/		return 0x820F9B98;
	}
	return 0x820F9B98;
} // Block from 820F9B8Ch-820F9B98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F9B98h
// Function '?EmitCMP@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9B98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9B98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9B98);
		  /* 820F9B98h */ case    0:  		/* bc 4, CR6_EQ, 52 */
		/* 820F9B98h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820F9BCC;  }
		/* 820F9B98h case    0:*/		return 0x820F9B9C;
		  /* 820F9B9Ch */ case    1:  		/* li R10, 17 */
		/* 820F9B9Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x11);
		/* 820F9B9Ch case    1:*/		return 0x820F9BA0;
		  /* 820F9BA0h */ case    2:  		/* stw R10, <#[R28]> */
		/* 820F9BA0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 820F9BA0h case    2:*/		return 0x820F9BA4;
		  /* 820F9BA4h */ case    3:  		/* stw R11, <#[R29]> */
		/* 820F9BA4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820F9BA4h case    3:*/		return 0x820F9BA8;
	}
	return 0x820F9BA8;
} // Block from 820F9B98h-820F9BA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F9BA8h
// Function '?EmitCND@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9BA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9BA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9BA8);
		  /* 820F9BA8h */ case    0:  		/* b 16 */
		/* 820F9BA8h case    0:*/		return 0x820F9BB8;
		/* 820F9BA8h case    0:*/		return 0x820F9BAC;
	}
	return 0x820F9BAC;
} // Block from 820F9BA8h-820F9BACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F9BACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9BAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9BAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9BAC);
		  /* 820F9BACh */ case    0:  		/* cmplwi CR6, R30, 65535 */
		/* 820F9BACh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x0000FFFF);
		/* 820F9BACh case    0:*/		return 0x820F9BB0;
		  /* 820F9BB0h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 820F9BB0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F9BCC;  }
		/* 820F9BB0h case    1:*/		return 0x820F9BB4;
		  /* 820F9BB4h */ case    2:  		/* stw R11, <#[R28]> */
		/* 820F9BB4h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820F9BB4h case    2:*/		return 0x820F9BB8;
	}
	return 0x820F9BB8;
} // Block from 820F9BACh-820F9BB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F9BB8h
// Function '?EmitABS@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9BB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9BB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9BB8);
		  /* 820F9BB8h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 820F9BB8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820F9BB8h case    0:*/		return 0x820F9BBC;
		  /* 820F9BBCh */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 820F9BBCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820F9BC4;  }
		/* 820F9BBCh case    1:*/		return 0x820F9BC0;
		  /* 820F9BC0h */ case    2:  		/* stw R11, <#[R27]> */
		/* 820F9BC0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820F9BC0h case    2:*/		return 0x820F9BC4;
	}
	return 0x820F9BC4;
} // Block from 820F9BB8h-820F9BC4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F9BC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9BC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9BC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9BC4);
		  /* 820F9BC4h */ case    0:  		/* li R3, 0 */
		/* 820F9BC4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F9BC4h case    0:*/		return 0x820F9BC8;
	}
	return 0x820F9BC8;
} // Block from 820F9BC4h-820F9BC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F9BC8h
// Function '??0C30Program@D3DXShader@@QAA@HH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9BC8);
		  /* 820F9BC8h */ case    0:  		/* b 12 */
		/* 820F9BC8h case    0:*/		return 0x820F9BD4;
		/* 820F9BC8h case    0:*/		return 0x820F9BCC;
	}
	return 0x820F9BCC;
} // Block from 820F9BC8h-820F9BCCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F9BCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9BCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9BCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9BCC);
		  /* 820F9BCCh */ case    0:  		/* lis R3, -32768 */
		/* 820F9BCCh case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820F9BCCh case    0:*/		return 0x820F9BD0;
		  /* 820F9BD0h */ case    1:  		/* ori R3, R3, 16389 */
		/* 820F9BD0h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820F9BD0h case    1:*/		return 0x820F9BD4;
	}
	return 0x820F9BD4;
} // Block from 820F9BCCh-820F9BD4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F9BD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9BD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9BD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9BD4);
		  /* 820F9BD4h */ case    0:  		/* addi R1, R1, 144 */
		/* 820F9BD4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820F9BD4h case    0:*/		return 0x820F9BD8;
		  /* 820F9BD8h */ case    1:  		/* b -428344 */
		/* 820F9BD8h case    1:*/		return 0x820912A0;
		/* 820F9BD8h case    1:*/		return 0x820F9BDC;
		  /* 820F9BDCh */ case    2:  		/* nop */
		/* 820F9BDCh case    2:*/		cpu::op::nop();
		/* 820F9BDCh case    2:*/		return 0x820F9BE0;
	}
	return 0x820F9BE0;
} // Block from 820F9BD4h-820F9BE0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F9BE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9BE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9BE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9BE0);
		  /* 820F9BE0h */ case    0:  		/* mfspr R12, LR */
		/* 820F9BE0h case    0:*/		regs.R12 = regs.LR;
		/* 820F9BE0h case    0:*/		return 0x820F9BE4;
		  /* 820F9BE4h */ case    1:  		/* bl -428428 */
		/* 820F9BE4h case    1:*/		regs.LR = 0x820F9BE8; return 0x82091258;
		/* 820F9BE4h case    1:*/		return 0x820F9BE8;
		  /* 820F9BE8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820F9BE8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820F9BE8h case    2:*/		return 0x820F9BEC;
		  /* 820F9BECh */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820F9BECh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F9BECh case    3:*/		return 0x820F9BF0;
		  /* 820F9BF0h */ case    4:  		/* mr R30, R4 */
		/* 820F9BF0h case    4:*/		regs.R30 = regs.R4;
		/* 820F9BF0h case    4:*/		return 0x820F9BF4;
		  /* 820F9BF4h */ case    5:  		/* lwz R4, <#[R4 + 108]> */
		/* 820F9BF4h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x0000006C) );
		/* 820F9BF4h case    5:*/		return 0x820F9BF8;
		  /* 820F9BF8h */ case    6:  		/* mr R31, R3 */
		/* 820F9BF8h case    6:*/		regs.R31 = regs.R3;
		/* 820F9BF8h case    6:*/		return 0x820F9BFC;
		  /* 820F9BFCh */ case    7:  		/* mr R29, R5 */
		/* 820F9BFCh case    7:*/		regs.R29 = regs.R5;
		/* 820F9BFCh case    7:*/		return 0x820F9C00;
		  /* 820F9C00h */ case    8:  		/* mr R28, R6 */
		/* 820F9C00h case    8:*/		regs.R28 = regs.R6;
		/* 820F9C00h case    8:*/		return 0x820F9C04;
		  /* 820F9C04h */ case    9:  		/* lwz R11, <#[R11 + 112]> */
		/* 820F9C04h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000070) );
		/* 820F9C04h case    9:*/		return 0x820F9C08;
		  /* 820F9C08h */ case   10:  		/* mtspr CTR, R11 */
		/* 820F9C08h case   10:*/		regs.CTR = regs.R11;
		/* 820F9C08h case   10:*/		return 0x820F9C0C;
		  /* 820F9C0Ch */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 820F9C0Ch case   11:*/		if ( 1 ) { regs.LR = 0x820F9C10; return (uint32)regs.CTR; }
		/* 820F9C0Ch case   11:*/		return 0x820F9C10;
		  /* 820F9C10h */ case   12:  		/* cmplwi CR6, R3, 65535 */
		/* 820F9C10h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x0000FFFF);
		/* 820F9C10h case   12:*/		return 0x820F9C14;
		  /* 820F9C14h */ case   13:  		/* bc 4, CR6_EQ, 44 */
		/* 820F9C14h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820F9C40;  }
		/* 820F9C14h case   13:*/		return 0x820F9C18;
		  /* 820F9C18h */ case   14:  		/* li R11, 0 */
		/* 820F9C18h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F9C18h case   14:*/		return 0x820F9C1C;
		  /* 820F9C1Ch */ case   15:  		/* mr R3, R31 */
		/* 820F9C1Ch case   15:*/		regs.R3 = regs.R31;
		/* 820F9C1Ch case   15:*/		return 0x820F9C20;
		  /* 820F9C20h */ case   16:  		/* stw R11, <#[R28]> */
		/* 820F9C20h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820F9C20h case   16:*/		return 0x820F9C24;
		  /* 820F9C24h */ case   17:  		/* lwz R11, <#[R31]> */
		/* 820F9C24h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F9C24h case   17:*/		return 0x820F9C28;
		  /* 820F9C28h */ case   18:  		/* lwz R11, <#[R11 + 116]> */
		/* 820F9C28h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000074) );
		/* 820F9C28h case   18:*/		return 0x820F9C2C;
		  /* 820F9C2Ch */ case   19:  		/* lwz R4, <#[R30 + 108]> */
		/* 820F9C2Ch case   19:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000006C) );
		/* 820F9C2Ch case   19:*/		return 0x820F9C30;
		  /* 820F9C30h */ case   20:  		/* mtspr CTR, R11 */
		/* 820F9C30h case   20:*/		regs.CTR = regs.R11;
		/* 820F9C30h case   20:*/		return 0x820F9C34;
		  /* 820F9C34h */ case   21:  		/* bcctrl 20, CR0_LT */
		/* 820F9C34h case   21:*/		if ( 1 ) { regs.LR = 0x820F9C38; return (uint32)regs.CTR; }
		/* 820F9C34h case   21:*/		return 0x820F9C38;
		  /* 820F9C38h */ case   22:  		/* stw R3, <#[R29]> */
		/* 820F9C38h case   22:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 820F9C38h case   22:*/		return 0x820F9C3C;
		  /* 820F9C3Ch */ case   23:  		/* b 64 */
		/* 820F9C3Ch case   23:*/		return 0x820F9C7C;
		/* 820F9C3Ch case   23:*/		return 0x820F9C40;
	}
	return 0x820F9C40;
} // Block from 820F9BE0h-820F9C40h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820F9C40h
// Function '??1C30Program@D3DXShader@@UAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9C40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9C40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9C40);
		  /* 820F9C40h */ case    0:  		/* cmplwi CR6, R3, 17 */
		/* 820F9C40h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000011);
		/* 820F9C40h case    0:*/		return 0x820F9C44;
		  /* 820F9C44h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820F9C44h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F9C50;  }
		/* 820F9C44h case    1:*/		return 0x820F9C48;
		  /* 820F9C48h */ case    2:  		/* li R10, 1 */
		/* 820F9C48h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820F9C48h case    2:*/		return 0x820F9C4C;
		  /* 820F9C4Ch */ case    3:  		/* b 16 */
		/* 820F9C4Ch case    3:*/		return 0x820F9C5C;
		/* 820F9C4Ch case    3:*/		return 0x820F9C50;
	}
	return 0x820F9C50;
} // Block from 820F9C40h-820F9C50h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F9C50h
// Function '?InitCaps@C30Program@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9C50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9C50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9C50);
		  /* 820F9C50h */ case    0:  		/* cmplwi CR6, R3, 18 */
		/* 820F9C50h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000012);
		/* 820F9C50h case    0:*/		return 0x820F9C54;
		  /* 820F9C54h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 820F9C54h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F9C6C;  }
		/* 820F9C54h case    1:*/		return 0x820F9C58;
		  /* 820F9C58h */ case    2:  		/* li R10, 0 */
		/* 820F9C58h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820F9C58h case    2:*/		return 0x820F9C5C;
	}
	return 0x820F9C5C;
} // Block from 820F9C50h-820F9C5Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F9C5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9C5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9C5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9C5C);
		  /* 820F9C5Ch */ case    0:  		/* li R11, 17 */
		/* 820F9C5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x11);
		/* 820F9C5Ch case    0:*/		return 0x820F9C60;
		  /* 820F9C60h */ case    1:  		/* stw R11, <#[R28]> */
		/* 820F9C60h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820F9C60h case    1:*/		return 0x820F9C64;
		  /* 820F9C64h */ case    2:  		/* stw R10, <#[R29]> */
		/* 820F9C64h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 820F9C64h case    2:*/		return 0x820F9C68;
		  /* 820F9C68h */ case    3:  		/* b 20 */
		/* 820F9C68h case    3:*/		return 0x820F9C7C;
		/* 820F9C68h case    3:*/		return 0x820F9C6C;
	}
	return 0x820F9C6C;
} // Block from 820F9C5Ch-820F9C6Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F9C6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9C6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9C6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9C6C);
		  /* 820F9C6Ch */ case    0:  		/* li R11, 1 */
		/* 820F9C6Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820F9C6Ch case    0:*/		return 0x820F9C70;
		  /* 820F9C70h */ case    1:  		/* stw R11, <#[R28]> */
		/* 820F9C70h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820F9C70h case    1:*/		return 0x820F9C74;
		  /* 820F9C74h */ case    2:  		/* lwz R11, <#[R30 + 12]> */
		/* 820F9C74h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 820F9C74h case    2:*/		return 0x820F9C78;
		  /* 820F9C78h */ case    3:  		/* stw R11, <#[R29]> */
		/* 820F9C78h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820F9C78h case    3:*/		return 0x820F9C7C;
	}
	return 0x820F9C7C;
} // Block from 820F9C6Ch-820F9C7Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F9C7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9C7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9C7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9C7C);
		  /* 820F9C7Ch */ case    0:  		/* li R3, 0 */
		/* 820F9C7Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F9C7Ch case    0:*/		return 0x820F9C80;
		  /* 820F9C80h */ case    1:  		/* addi R1, R1, 128 */
		/* 820F9C80h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820F9C80h case    1:*/		return 0x820F9C84;
		  /* 820F9C84h */ case    2:  		/* b -428508 */
		/* 820F9C84h case    2:*/		return 0x820912A8;
		/* 820F9C84h case    2:*/		return 0x820F9C88;
	}
	return 0x820F9C88;
} // Block from 820F9C7Ch-820F9C88h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F9C88h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9C88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9C88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9C88);
		  /* 820F9C88h */ case    0:  		/* b -20576 */
		/* 820F9C88h case    0:*/		return 0x820F4C28;
		/* 820F9C88h case    0:*/		return 0x820F9C8C;
		  /* 820F9C8Ch */ case    1:  		/* nop */
		/* 820F9C8Ch case    1:*/		cpu::op::nop();
		/* 820F9C8Ch case    1:*/		return 0x820F9C90;
	}
	return 0x820F9C90;
} // Block from 820F9C88h-820F9C90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F9C90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9C90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9C90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9C90);
		  /* 820F9C90h */ case    0:  		/* mfspr R12, LR */
		/* 820F9C90h case    0:*/		regs.R12 = regs.LR;
		/* 820F9C90h case    0:*/		return 0x820F9C94;
		  /* 820F9C94h */ case    1:  		/* bl -428600 */
		/* 820F9C94h case    1:*/		regs.LR = 0x820F9C98; return 0x8209125C;
		/* 820F9C94h case    1:*/		return 0x820F9C98;
		  /* 820F9C98h */ case    2:  		/* lwz R11, <#[R3 + 8]> */
		/* 820F9C98h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820F9C98h case    2:*/		return 0x820F9C9C;
		  /* 820F9C9Ch */ case    3:  		/* li R30, -1 */
		/* 820F9C9Ch case    3:*/		cpu::op::li<0>(regs,&regs.R30,0xFFFFFFFF);
		/* 820F9C9Ch case    3:*/		return 0x820F9CA0;
		  /* 820F9CA0h */ case    4:  		/* li R31, -1 */
		/* 820F9CA0h case    4:*/		cpu::op::li<0>(regs,&regs.R31,0xFFFFFFFF);
		/* 820F9CA0h case    4:*/		return 0x820F9CA4;
		  /* 820F9CA4h */ case    5:  		/* li R4, 0 */
		/* 820F9CA4h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F9CA4h case    5:*/		return 0x820F9CA8;
		  /* 820F9CA8h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820F9CA8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F9CA8h case    6:*/		return 0x820F9CAC;
		  /* 820F9CACh */ case    7:  		/* bc 4, CR6_GT, 364 */
		/* 820F9CACh case    7:*/		if ( !regs.CR[6].gt ) { return 0x820F9E18;  }
		/* 820F9CACh case    7:*/		return 0x820F9CB0;
		  /* 820F9CB0h */ case    8:  		/* li R5, 0 */
		/* 820F9CB0h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F9CB0h case    8:*/		return 0x820F9CB4;
		  /* 820F9CB4h */ case    9:  		/* lwz R11, <#[R3 + 20]> */
		/* 820F9CB4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820F9CB4h case    9:*/		return 0x820F9CB8;
		  /* 820F9CB8h */ case   10:  		/* lwz R10, <#[R3 + 16]> */
		/* 820F9CB8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 820F9CB8h case   10:*/		return 0x820F9CBC;
		  /* 820F9CBCh */ case   11:  		/* lwzx R11, <#[R5 + R11]> */
		/* 820F9CBCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 820F9CBCh case   11:*/		return 0x820F9CC0;
		  /* 820F9CC0h */ case   12:  		/* lwz R9, <#[R11 + 4]> */
		/* 820F9CC0h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820F9CC0h case   12:*/		return 0x820F9CC4;
		  /* 820F9CC4h */ case   13:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820F9CC4h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820F9CC4h case   13:*/		return 0x820F9CC8;
		  /* 820F9CC8h */ case   14:  		/* lwzx R10, <#[R9 + R10]> */
		/* 820F9CC8h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820F9CC8h case   14:*/		return 0x820F9CCC;
		  /* 820F9CCCh */ case   15:  		/* lwz R10, <#[R10 + 4]> */
		/* 820F9CCCh case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820F9CCCh case   15:*/		return 0x820F9CD0;
		  /* 820F9CD0h */ case   16:  		/* rlwinm. R10, R10, 0, 27, 27 */
		/* 820F9CD0h case   16:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R10);
		/* 820F9CD0h case   16:*/		return 0x820F9CD4;
		  /* 820F9CD4h */ case   17:  		/* bc 12, CR0_EQ, 304 */
		/* 820F9CD4h case   17:*/		if ( regs.CR[0].eq ) { return 0x820F9E04;  }
		/* 820F9CD4h case   17:*/		return 0x820F9CD8;
		  /* 820F9CD8h */ case   18:  		/* lwz R11, <#[R11 + 108]> */
		/* 820F9CD8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000006C) );
		/* 820F9CD8h case   18:*/		return 0x820F9CDC;
		  /* 820F9CDCh */ case   19:  		/* cmplwi CR6, R11, 17 */
		/* 820F9CDCh case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000011);
		/* 820F9CDCh case   19:*/		return 0x820F9CE0;
		  /* 820F9CE0h */ case   20:  		/* bc 12, CR6_EQ, 12 */
		/* 820F9CE0h case   20:*/		if ( regs.CR[6].eq ) { return 0x820F9CEC;  }
		/* 820F9CE0h case   20:*/		return 0x820F9CE4;
		  /* 820F9CE4h */ case   21:  		/* cmplwi CR6, R11, 18 */
		/* 820F9CE4h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000012);
		/* 820F9CE4h case   21:*/		return 0x820F9CE8;
		  /* 820F9CE8h */ case   22:  		/* bc 4, CR6_EQ, 284 */
		/* 820F9CE8h case   22:*/		if ( !regs.CR[6].eq ) { return 0x820F9E04;  }
		/* 820F9CE8h case   22:*/		return 0x820F9CEC;
	}
	return 0x820F9CEC;
} // Block from 820F9C90h-820F9CECh (23 instructions)

//////////////////////////////////////////////////////
// Block at 820F9CECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9CEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9CEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9CEC);
		  /* 820F9CECh */ case    0:  		/* lwz R11, <#[R3 + 20]> */
		/* 820F9CECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820F9CECh case    0:*/		return 0x820F9CF0;
		  /* 820F9CF0h */ case    1:  		/* lwzx R11, <#[R5 + R11]> */
		/* 820F9CF0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 820F9CF0h case    1:*/		return 0x820F9CF4;
		  /* 820F9CF4h */ case    2:  		/* lwz R10, <#[R11]> */
		/* 820F9CF4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820F9CF4h case    2:*/		return 0x820F9CF8;
		  /* 820F9CF8h */ case    3:  		/* rlwinm. R10, R10, 0, 1, 1 */
		/* 820F9CF8h case    3:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R10);
		/* 820F9CF8h case    3:*/		return 0x820F9CFC;
		  /* 820F9CFCh */ case    4:  		/* stw R10, <#[R11]> */
		/* 820F9CFCh case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820F9CFCh case    4:*/		return 0x820F9D00;
		  /* 820F9D00h */ case    5:  		/* bc 4, CR0_EQ, 260 */
		/* 820F9D00h case    5:*/		if ( !regs.CR[0].eq ) { return 0x820F9E04;  }
		/* 820F9D00h case    5:*/		return 0x820F9D04;
		  /* 820F9D04h */ case    6:  		/* lwz R11, <#[R3 + 20]> */
		/* 820F9D04h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820F9D04h case    6:*/		return 0x820F9D08;
		  /* 820F9D08h */ case    7:  		/* lwzx R11, <#[R5 + R11]> */
		/* 820F9D08h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 820F9D08h case    7:*/		return 0x820F9D0C;
		  /* 820F9D0Ch */ case    8:  		/* lwz R10, <#[R11 + 108]> */
		/* 820F9D0Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000006C) );
		/* 820F9D0Ch case    8:*/		return 0x820F9D10;
		  /* 820F9D10h */ case    9:  		/* cmplwi CR6, R10, 17 */
		/* 820F9D10h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000011);
		/* 820F9D10h case    9:*/		return 0x820F9D14;
		  /* 820F9D14h */ case   10:  		/* bc 4, CR6_EQ, 16 */
		/* 820F9D14h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820F9D24;  }
		/* 820F9D14h case   10:*/		return 0x820F9D18;
		  /* 820F9D18h */ case   11:  		/* cmpwi CR6, R30, -1 */
		/* 820F9D18h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R30,0xFFFFFFFF);
		/* 820F9D18h case   11:*/		return 0x820F9D1C;
		  /* 820F9D1Ch */ case   12:  		/* bc 4, CR6_EQ, 232 */
		/* 820F9D1Ch case   12:*/		if ( !regs.CR[6].eq ) { return 0x820F9E04;  }
		/* 820F9D1Ch case   12:*/		return 0x820F9D20;
		  /* 820F9D20h */ case   13:  		/* mr R30, R4 */
		/* 820F9D20h case   13:*/		regs.R30 = regs.R4;
		/* 820F9D20h case   13:*/		return 0x820F9D24;
	}
	return 0x820F9D24;
} // Block from 820F9CECh-820F9D24h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820F9D24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9D24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9D24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9D24);
		  /* 820F9D24h */ case    0:  		/* cmplwi CR6, R10, 18 */
		/* 820F9D24h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000012);
		/* 820F9D24h case    0:*/		return 0x820F9D28;
		  /* 820F9D28h */ case    1:  		/* bc 4, CR6_EQ, 44 */
		/* 820F9D28h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F9D54;  }
		/* 820F9D28h case    1:*/		return 0x820F9D2C;
		  /* 820F9D2Ch */ case    2:  		/* cmpwi CR6, R31, -1 */
		/* 820F9D2Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R31,0xFFFFFFFF);
		/* 820F9D2Ch case    2:*/		return 0x820F9D30;
		  /* 820F9D30h */ case    3:  		/* bc 12, CR6_EQ, 32 */
		/* 820F9D30h case    3:*/		if ( regs.CR[6].eq ) { return 0x820F9D50;  }
		/* 820F9D30h case    3:*/		return 0x820F9D34;
		  /* 820F9D34h */ case    4:  		/* lwz R11, <#[R3 + 20]> */
		/* 820F9D34h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820F9D34h case    4:*/		return 0x820F9D38;
		  /* 820F9D38h */ case    5:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 820F9D38h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 820F9D38h case    5:*/		return 0x820F9D3C;
		  /* 820F9D3Ch */ case    6:  		/* lwzx R10, <#[R10 + R11]> */
		/* 820F9D3Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820F9D3Ch case    6:*/		return 0x820F9D40;
		  /* 820F9D40h */ case    7:  		/* lwzx R11, <#[R5 + R11]> */
		/* 820F9D40h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 820F9D40h case    7:*/		return 0x820F9D44;
		  /* 820F9D44h */ case    8:  		/* lwz R10, <#[R10 + 12]> */
		/* 820F9D44h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 820F9D44h case    8:*/		return 0x820F9D48;
		  /* 820F9D48h */ case    9:  		/* stw R10, <#[R11 + 12]> */
		/* 820F9D48h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F9D48h case    9:*/		return 0x820F9D4C;
		  /* 820F9D4Ch */ case   10:  		/* b 184 */
		/* 820F9D4Ch case   10:*/		return 0x820F9E04;
		/* 820F9D4Ch case   10:*/		return 0x820F9D50;
	}
	return 0x820F9D50;
} // Block from 820F9D24h-820F9D50h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820F9D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9D50);
		  /* 820F9D50h */ case    0:  		/* mr R31, R4 */
		/* 820F9D50h case    0:*/		regs.R31 = regs.R4;
		/* 820F9D50h case    0:*/		return 0x820F9D54;
	}
	return 0x820F9D54;
} // Block from 820F9D50h-820F9D54h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F9D54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9D54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9D54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9D54);
		  /* 820F9D54h */ case    0:  		/* lwz R10, <#[R3 + 8]> */
		/* 820F9D54h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820F9D54h case    0:*/		return 0x820F9D58;
		  /* 820F9D58h */ case    1:  		/* li R7, -1 */
		/* 820F9D58h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0xFFFFFFFF);
		/* 820F9D58h case    1:*/		return 0x820F9D5C;
		  /* 820F9D5Ch */ case    2:  		/* lwz R6, <#[R11 + 12]> */
		/* 820F9D5Ch case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F9D5Ch case    2:*/		return 0x820F9D60;
		  /* 820F9D60h */ case    3:  		/* li R8, 0 */
		/* 820F9D60h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F9D60h case    3:*/		return 0x820F9D64;
		  /* 820F9D64h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 820F9D64h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F9D64h case    4:*/		return 0x820F9D68;
		  /* 820F9D68h */ case    5:  		/* bc 4, CR6_GT, 156 */
		/* 820F9D68h case    5:*/		if ( !regs.CR[6].gt ) { return 0x820F9E04;  }
		/* 820F9D68h case    5:*/		return 0x820F9D6C;
		  /* 820F9D6Ch */ case    6:  		/* li R10, 0 */
		/* 820F9D6Ch case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820F9D6Ch case    6:*/		return 0x820F9D70;
		  /* 820F9D70h */ case    7:  		/* lwz R11, <#[R3 + 20]> */
		/* 820F9D70h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820F9D70h case    7:*/		return 0x820F9D74;
		  /* 820F9D74h */ case    8:  		/* lwzx R9, <#[R5 + R11]> */
		/* 820F9D74h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 820F9D74h case    8:*/		return 0x820F9D78;
		  /* 820F9D78h */ case    9:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820F9D78h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820F9D78h case    9:*/		return 0x820F9D7C;
		  /* 820F9D7Ch */ case   10:  		/* lwz R9, <#[R9 + 4]> */
		/* 820F9D7Ch case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 820F9D7Ch case   10:*/		return 0x820F9D80;
		  /* 820F9D80h */ case   11:  		/* lwz R11, <#[R11 + 4]> */
		/* 820F9D80h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820F9D80h case   11:*/		return 0x820F9D84;
		  /* 820F9D84h */ case   12:  		/* cmplw CR6, R9, R11 */
		/* 820F9D84h case   12:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820F9D84h case   12:*/		return 0x820F9D88;
		  /* 820F9D88h */ case   13:  		/* bc 4, CR6_EQ, 84 */
		/* 820F9D88h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820F9DDC;  }
		/* 820F9D88h case   13:*/		return 0x820F9D8C;
		  /* 820F9D8Ch */ case   14:  		/* lwz R11, <#[R3 + 20]> */
		/* 820F9D8Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820F9D8Ch case   14:*/		return 0x820F9D90;
		  /* 820F9D90h */ case   15:  		/* lwz R9, <#[R3 + 16]> */
		/* 820F9D90h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000010) );
		/* 820F9D90h case   15:*/		return 0x820F9D94;
		  /* 820F9D94h */ case   16:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820F9D94h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820F9D94h case   16:*/		return 0x820F9D98;
		  /* 820F9D98h */ case   17:  		/* lwz R29, <#[R11 + 4]> */
		/* 820F9D98h case   17:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000004) );
		/* 820F9D98h case   17:*/		return 0x820F9D9C;
		  /* 820F9D9Ch */ case   18:  		/* rlwinm R29, R29, 2, 0, 29 */
		/* 820F9D9Ch case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R29);
		/* 820F9D9Ch case   18:*/		return 0x820F9DA0;
		  /* 820F9DA0h */ case   19:  		/* lwzx R9, <#[R29 + R9]> */
		/* 820F9DA0h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + regs.R9 + 0x00000000) );
		/* 820F9DA0h case   19:*/		return 0x820F9DA4;
		  /* 820F9DA4h */ case   20:  		/* lwz R9, <#[R9 + 4]> */
		/* 820F9DA4h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 820F9DA4h case   20:*/		return 0x820F9DA8;
		  /* 820F9DA8h */ case   21:  		/* rlwinm. R9, R9, 0, 27, 27 */
		/* 820F9DA8h case   21:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R9,regs.R9);
		/* 820F9DA8h case   21:*/		return 0x820F9DAC;
		  /* 820F9DACh */ case   22:  		/* bc 12, CR0_EQ, 48 */
		/* 820F9DACh case   22:*/		if ( regs.CR[0].eq ) { return 0x820F9DDC;  }
		/* 820F9DACh case   22:*/		return 0x820F9DB0;
		  /* 820F9DB0h */ case   23:  		/* lwz R11, <#[R11 + 12]> */
		/* 820F9DB0h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F9DB0h case   23:*/		return 0x820F9DB4;
		  /* 820F9DB4h */ case   24:  		/* cmplw CR6, R11, R6 */
		/* 820F9DB4h case   24:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820F9DB4h case   24:*/		return 0x820F9DB8;
		  /* 820F9DB8h */ case   25:  		/* bc 4, CR6_GT, 36 */
		/* 820F9DB8h case   25:*/		if ( !regs.CR[6].gt ) { return 0x820F9DDC;  }
		/* 820F9DB8h case   25:*/		return 0x820F9DBC;
		  /* 820F9DBCh */ case   26:  		/* cmpw CR6, R7, R11 */
		/* 820F9DBCh case   26:*/		cpu::op::cmpw<6>(regs,regs.R7,regs.R11);
		/* 820F9DBCh case   26:*/		return 0x820F9DC0;
		  /* 820F9DC0h */ case   27:  		/* bc 12, CR6_GT, 8 */
		/* 820F9DC0h case   27:*/		if ( regs.CR[6].gt ) { return 0x820F9DC8;  }
		/* 820F9DC0h case   27:*/		return 0x820F9DC4;
		  /* 820F9DC4h */ case   28:  		/* mr R7, R11 */
		/* 820F9DC4h case   28:*/		regs.R7 = regs.R11;
		/* 820F9DC4h case   28:*/		return 0x820F9DC8;
	}
	return 0x820F9DC8;
} // Block from 820F9D54h-820F9DC8h (29 instructions)

//////////////////////////////////////////////////////
// Block at 820F9DC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9DC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9DC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9DC8);
		  /* 820F9DC8h */ case    0:  		/* lwz R11, <#[R3 + 20]> */
		/* 820F9DC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820F9DC8h case    0:*/		return 0x820F9DCC;
		  /* 820F9DCCh */ case    1:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820F9DCCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820F9DCCh case    1:*/		return 0x820F9DD0;
		  /* 820F9DD0h */ case    2:  		/* lwz R9, <#[R11 + 12]> */
		/* 820F9DD0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F9DD0h case    2:*/		return 0x820F9DD4;
		  /* 820F9DD4h */ case    3:  		/* addi R9, R9, -1 */
		/* 820F9DD4h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 820F9DD4h case    3:*/		return 0x820F9DD8;
		  /* 820F9DD8h */ case    4:  		/* stw R9, <#[R11 + 12]> */
		/* 820F9DD8h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F9DD8h case    4:*/		return 0x820F9DDC;
	}
	return 0x820F9DDC;
} // Block from 820F9DC8h-820F9DDCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F9DDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9DDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9DDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9DDC);
		  /* 820F9DDCh */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 820F9DDCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820F9DDCh case    0:*/		return 0x820F9DE0;
		  /* 820F9DE0h */ case    1:  		/* addi R8, R8, 1 */
		/* 820F9DE0h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820F9DE0h case    1:*/		return 0x820F9DE4;
		  /* 820F9DE4h */ case    2:  		/* addi R10, R10, 4 */
		/* 820F9DE4h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F9DE4h case    2:*/		return 0x820F9DE8;
		  /* 820F9DE8h */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 820F9DE8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 820F9DE8h case    3:*/		return 0x820F9DEC;
		  /* 820F9DECh */ case    4:  		/* bc 12, CR6_LT, -124 */
		/* 820F9DECh case    4:*/		if ( regs.CR[6].lt ) { return 0x820F9D70;  }
		/* 820F9DECh case    4:*/		return 0x820F9DF0;
		  /* 820F9DF0h */ case    5:  		/* cmpwi CR6, R7, -1 */
		/* 820F9DF0h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R7,0xFFFFFFFF);
		/* 820F9DF0h case    5:*/		return 0x820F9DF4;
		  /* 820F9DF4h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 820F9DF4h case    6:*/		if ( regs.CR[6].eq ) { return 0x820F9E04;  }
		/* 820F9DF4h case    6:*/		return 0x820F9DF8;
		  /* 820F9DF8h */ case    7:  		/* lwz R11, <#[R3 + 20]> */
		/* 820F9DF8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820F9DF8h case    7:*/		return 0x820F9DFC;
		  /* 820F9DFCh */ case    8:  		/* lwzx R11, <#[R5 + R11]> */
		/* 820F9DFCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 820F9DFCh case    8:*/		return 0x820F9E00;
		  /* 820F9E00h */ case    9:  		/* stw R7, <#[R11 + 12]> */
		/* 820F9E00h case    9:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F9E00h case    9:*/		return 0x820F9E04;
	}
	return 0x820F9E04;
} // Block from 820F9DDCh-820F9E04h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F9E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9E04);
		  /* 820F9E04h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 820F9E04h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820F9E04h case    0:*/		return 0x820F9E08;
		  /* 820F9E08h */ case    1:  		/* addi R4, R4, 1 */
		/* 820F9E08h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820F9E08h case    1:*/		return 0x820F9E0C;
		  /* 820F9E0Ch */ case    2:  		/* addi R5, R5, 4 */
		/* 820F9E0Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 820F9E0Ch case    2:*/		return 0x820F9E10;
		  /* 820F9E10h */ case    3:  		/* cmplw CR6, R4, R11 */
		/* 820F9E10h case    3:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 820F9E10h case    3:*/		return 0x820F9E14;
		  /* 820F9E14h */ case    4:  		/* bc 12, CR6_LT, -352 */
		/* 820F9E14h case    4:*/		if ( regs.CR[6].lt ) { return 0x820F9CB4;  }
		/* 820F9E14h case    4:*/		return 0x820F9E18;
	}
	return 0x820F9E18;
} // Block from 820F9E04h-820F9E18h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F9E18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9E18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9E18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9E18);
		  /* 820F9E18h */ case    0:  		/* li R3, 0 */
		/* 820F9E18h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F9E18h case    0:*/		return 0x820F9E1C;
		  /* 820F9E1Ch */ case    1:  		/* b -428912 */
		/* 820F9E1Ch case    1:*/		return 0x820912AC;
		/* 820F9E1Ch case    1:*/		return 0x820F9E20;
	}
	return 0x820F9E20;
} // Block from 820F9E18h-820F9E20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F9E20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9E20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9E20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9E20);
		  /* 820F9E20h */ case    0:  		/* mfspr R12, LR */
		/* 820F9E20h case    0:*/		regs.R12 = regs.LR;
		/* 820F9E20h case    0:*/		return 0x820F9E24;
		  /* 820F9E24h */ case    1:  		/* bl -429016 */
		/* 820F9E24h case    1:*/		regs.LR = 0x820F9E28; return 0x8209124C;
		/* 820F9E24h case    1:*/		return 0x820F9E28;
		  /* 820F9E28h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820F9E28h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820F9E28h case    2:*/		return 0x820F9E2C;
		  /* 820F9E2Ch */ case    3:  		/* lwz R11, <#[R3 + 92]> */
		/* 820F9E2Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000005C) );
		/* 820F9E2Ch case    3:*/		return 0x820F9E30;
		  /* 820F9E30h */ case    4:  		/* mr R31, R3 */
		/* 820F9E30h case    4:*/		regs.R31 = regs.R3;
		/* 820F9E30h case    4:*/		return 0x820F9E34;
		  /* 820F9E34h */ case    5:  		/* li R25, 0 */
		/* 820F9E34h case    5:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 820F9E34h case    5:*/		return 0x820F9E38;
		  /* 820F9E38h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820F9E38h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F9E38h case    6:*/		return 0x820F9E3C;
		  /* 820F9E3Ch */ case    7:  		/* bc 12, CR6_EQ, 140 */
		/* 820F9E3Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x820F9EC8;  }
		/* 820F9E3Ch case    7:*/		return 0x820F9E40;
		  /* 820F9E40h */ case    8:  		/* lwz R11, <#[R3 + 12]> */
		/* 820F9E40h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820F9E40h case    8:*/		return 0x820F9E44;
		  /* 820F9E44h */ case    9:  		/* mr R30, R25 */
		/* 820F9E44h case    9:*/		regs.R30 = regs.R25;
		/* 820F9E44h case    9:*/		return 0x820F9E48;
		  /* 820F9E48h */ case   10:  		/* stw R25, <#[R3 + 256]> */
		/* 820F9E48h case   10:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R3 + 0x00000100) );
		/* 820F9E48h case   10:*/		return 0x820F9E4C;
		  /* 820F9E4Ch */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 820F9E4Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F9E4Ch case   11:*/		return 0x820F9E50;
		  /* 820F9E50h */ case   12:  		/* bc 4, CR6_GT, 120 */
		/* 820F9E50h case   12:*/		if ( !regs.CR[6].gt ) { return 0x820F9EC8;  }
		/* 820F9E50h case   12:*/		return 0x820F9E54;
		  /* 820F9E54h */ case   13:  		/* lwz R11, <#[R31 + 256]> */
		/* 820F9E54h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000100) );
		/* 820F9E54h case   13:*/		return 0x820F9E58;
		  /* 820F9E58h */ case   14:  		/* lis R10, 8320 */
		/* 820F9E58h case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0x2080);
		/* 820F9E58h case   14:*/		return 0x820F9E5C;
		  /* 820F9E5Ch */ case   15:  		/* lwz R9, <#[R31 + 24]> */
		/* 820F9E5Ch case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 820F9E5Ch case   15:*/		return 0x820F9E60;
	}
	return 0x820F9E60;
} // Block from 820F9E20h-820F9E60h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820F9E60h
// Function '?ValidateOutput@C30Program@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9E60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9E60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9E60);
		  /* 820F9E60h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F9E60h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F9E60h case    0:*/		return 0x820F9E64;
		  /* 820F9E64h */ case    1:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820F9E64h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F9E64h case    1:*/		return 0x820F9E68;
		  /* 820F9E68h */ case    2:  		/* stw R11, <#[R31 + 260]> */
		/* 820F9E68h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F9E68h case    2:*/		return 0x820F9E6C;
		  /* 820F9E6Ch */ case    3:  		/* lwz R11, <#[R11]> */
		/* 820F9E6Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F9E6Ch case    3:*/		return 0x820F9E70;
		  /* 820F9E70h */ case    4:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820F9E70h case    4:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820F9E70h case    4:*/		return 0x820F9E74;
		  /* 820F9E74h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 820F9E74h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F9E74h case    5:*/		return 0x820F9E78;
		  /* 820F9E78h */ case    6:  		/* bc 4, CR6_EQ, 36 */
		/* 820F9E78h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820F9E9C;  }
		/* 820F9E78h case    6:*/		return 0x820F9E7C;
		  /* 820F9E7Ch */ case    7:  		/* mr R3, R31 */
		/* 820F9E7Ch case    7:*/		regs.R3 = regs.R31;
		/* 820F9E7Ch case    7:*/		return 0x820F9E80;
		  /* 820F9E80h */ case    8:  		/* bl -86784 */
		/* 820F9E80h case    8:*/		regs.LR = 0x820F9E84; return 0x820E4B80;
		/* 820F9E80h case    8:*/		return 0x820F9E84;
		  /* 820F9E84h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820F9E84h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F9E84h case    9:*/		return 0x820F9E88;
		  /* 820F9E88h */ case   10:  		/* bc 12, CR0_LT, 520 */
		/* 820F9E88h case   10:*/		if ( regs.CR[0].lt ) { return 0x820FA090;  }
		/* 820F9E88h case   10:*/		return 0x820F9E8C;
		  /* 820F9E8Ch */ case   11:  		/* addi R11, R3, 0 */
		/* 820F9E8Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x0);
		/* 820F9E8Ch case   11:*/		return 0x820F9E90;
		  /* 820F9E90h */ case   12:  		/* cntlzw R11, R11 */
		/* 820F9E90h case   12:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820F9E90h case   12:*/		return 0x820F9E94;
		  /* 820F9E94h */ case   13:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 820F9E94h case   13:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 820F9E94h case   13:*/		return 0x820F9E98;
		  /* 820F9E98h */ case   14:  		/* or R30, R11, R30 */
		/* 820F9E98h case   14:*/		cpu::op::or<0>(regs,&regs.R30,regs.R11,regs.R30);
		/* 820F9E98h case   14:*/		return 0x820F9E9C;
	}
	return 0x820F9E9C;
} // Block from 820F9E60h-820F9E9Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 820F9E9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9E9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9E9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9E9C);
		  /* 820F9E9Ch */ case    0:  		/* lwz R11, <#[R31 + 256]> */
		/* 820F9E9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000100) );
		/* 820F9E9Ch case    0:*/		return 0x820F9EA0;
		  /* 820F9EA0h */ case    1:  		/* addi R11, R11, 1 */
		/* 820F9EA0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F9EA0h case    1:*/		return 0x820F9EA4;
		  /* 820F9EA4h */ case    2:  		/* stw R11, <#[R31 + 256]> */
		/* 820F9EA4h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000100) );
		/* 820F9EA4h case    2:*/		return 0x820F9EA8;
		  /* 820F9EA8h */ case    3:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820F9EA8h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820F9EA8h case    3:*/		return 0x820F9EAC;
		  /* 820F9EACh */ case    4:  		/* lwz R10, <#[R31 + 12]> */
		/* 820F9EACh case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 820F9EACh case    4:*/		return 0x820F9EB0;
		  /* 820F9EB0h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 820F9EB0h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F9EB0h case    5:*/		return 0x820F9EB4;
		  /* 820F9EB4h */ case    6:  		/* bc 12, CR6_LT, -96 */
		/* 820F9EB4h case    6:*/		if ( regs.CR[6].lt ) { return 0x820F9E54;  }
		/* 820F9EB4h case    6:*/		return 0x820F9EB8;
		  /* 820F9EB8h */ case    7:  		/* cmpwi CR6, R30, 0 */
		/* 820F9EB8h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820F9EB8h case    7:*/		return 0x820F9EBC;
		  /* 820F9EBCh */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 820F9EBCh case    8:*/		if ( regs.CR[6].eq ) { return 0x820F9EC8;  }
		/* 820F9EBCh case    8:*/		return 0x820F9EC0;
		  /* 820F9EC0h */ case    9:  		/* mr R3, R31 */
		/* 820F9EC0h case    9:*/		regs.R3 = regs.R31;
		/* 820F9EC0h case    9:*/		return 0x820F9EC4;
		  /* 820F9EC4h */ case   10:  		/* bl -87780 */
		/* 820F9EC4h case   10:*/		regs.LR = 0x820F9EC8; return 0x820E47E0;
		/* 820F9EC4h case   10:*/		return 0x820F9EC8;
	}
	return 0x820F9EC8;
} // Block from 820F9E9Ch-820F9EC8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820F9EC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9EC8);
		  /* 820F9EC8h */ case    0:  		/* lwz R11, <#[R31 + 48]> */
		/* 820F9EC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820F9EC8h case    0:*/		return 0x820F9ECC;
		  /* 820F9ECCh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820F9ECCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F9ECCh case    1:*/		return 0x820F9ED0;
		  /* 820F9ED0h */ case    2:  		/* bc 12, CR6_EQ, 336 */
		/* 820F9ED0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FA020;  }
		/* 820F9ED0h case    2:*/		return 0x820F9ED4;
		  /* 820F9ED4h */ case    3:  		/* mr R26, R25 */
		/* 820F9ED4h case    3:*/		regs.R26 = regs.R25;
		/* 820F9ED4h case    3:*/		return 0x820F9ED8;
		  /* 820F9ED8h */ case    4:  		/* cmplwi CR6, R26, 16 */
		/* 820F9ED8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000010);
		/* 820F9ED8h case    4:*/		return 0x820F9EDC;
		  /* 820F9EDCh */ case    5:  		/* bc 4, CR6_LT, 148 */
		/* 820F9EDCh case    5:*/		if ( !regs.CR[6].lt ) { return 0x820F9F70;  }
		/* 820F9EDCh case    5:*/		return 0x820F9EE0;
		  /* 820F9EE0h */ case    6:  		/* lwz R28, <#[R31 + 12]> */
		/* 820F9EE0h case    6:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x0000000C) );
		/* 820F9EE0h case    6:*/		return 0x820F9EE4;
		  /* 820F9EE4h */ case    7:  		/* li R27, 1 */
		/* 820F9EE4h case    7:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 820F9EE4h case    7:*/		return 0x820F9EE8;
		  /* 820F9EE8h */ case    8:  		/* mr R30, R25 */
		/* 820F9EE8h case    8:*/		regs.R30 = regs.R25;
		/* 820F9EE8h case    8:*/		return 0x820F9EEC;
		  /* 820F9EECh */ case    9:  		/* cmplwi CR6, R28, 0 */
		/* 820F9EECh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820F9EECh case    9:*/		return 0x820F9EF0;
		  /* 820F9EF0h */ case   10:  		/* bc 12, CR6_EQ, 92 */
		/* 820F9EF0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820F9F4C;  }
		/* 820F9EF0h case   10:*/		return 0x820F9EF4;
		  /* 820F9EF4h */ case   11:  		/* mr R29, R25 */
		/* 820F9EF4h case   11:*/		regs.R29 = regs.R25;
		/* 820F9EF4h case   11:*/		return 0x820F9EF8;
		  /* 820F9EF8h */ case   12:  		/* lwz R11, <#[R31 + 24]> */
		/* 820F9EF8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820F9EF8h case   12:*/		return 0x820F9EFC;
		  /* 820F9EFCh */ case   13:  		/* mr R3, R31 */
		/* 820F9EFCh case   13:*/		regs.R3 = regs.R31;
		/* 820F9EFCh case   13:*/		return 0x820F9F00;
		  /* 820F9F00h */ case   14:  		/* lwzx R11, <#[R29 + R11]> */
		/* 820F9F00h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820F9F00h case   14:*/		return 0x820F9F04;
		  /* 820F9F04h */ case   15:  		/* stw R11, <#[R31 + 260]> */
		/* 820F9F04h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F9F04h case   15:*/		return 0x820F9F08;
		  /* 820F9F08h */ case   16:  		/* bl -85328 */
		/* 820F9F08h case   16:*/		regs.LR = 0x820F9F0C; return 0x820E51B8;
		/* 820F9F08h case   16:*/		return 0x820F9F0C;
		  /* 820F9F0Ch */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 820F9F0Ch case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F9F0Ch case   17:*/		return 0x820F9F10;
		  /* 820F9F10h */ case   18:  		/* bc 12, CR0_LT, 384 */
		/* 820F9F10h case   18:*/		if ( regs.CR[0].lt ) { return 0x820FA090;  }
		/* 820F9F10h case   18:*/		return 0x820F9F14;
		  /* 820F9F14h */ case   19:  		/* subfic R11, R3, 0 */
		/* 820F9F14h case   19:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R3,0x0);
		/* 820F9F14h case   19:*/		return 0x820F9F18;
		  /* 820F9F18h */ case   20:  		/* lwz R4, <#[R31 + 260]> */
		/* 820F9F18h case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000104) );
		/* 820F9F18h case   20:*/		return 0x820F9F1C;
		  /* 820F9F1Ch */ case   21:  		/* mr R3, R31 */
		/* 820F9F1Ch case   21:*/		regs.R3 = regs.R31;
		/* 820F9F1Ch case   21:*/		return 0x820F9F20;
		  /* 820F9F20h */ case   22:  		/* subfe R11, R11, R11 */
		/* 820F9F20h case   22:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820F9F20h case   22:*/		return 0x820F9F24;
		  /* 820F9F24h */ case   23:  		/* and R27, R11, R27 */
		/* 820F9F24h case   23:*/		cpu::op::and<0>(regs,&regs.R27,regs.R11,regs.R27);
		/* 820F9F24h case   23:*/		return 0x820F9F28;
		  /* 820F9F28h */ case   24:  		/* bl 13632 */
		/* 820F9F28h case   24:*/		regs.LR = 0x820F9F2C; return 0x820FD468;
		/* 820F9F28h case   24:*/		return 0x820F9F2C;
		  /* 820F9F2Ch */ case   25:  		/* cmpwi CR0, R3, 0 */
		/* 820F9F2Ch case   25:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F9F2Ch case   25:*/		return 0x820F9F30;
		  /* 820F9F30h */ case   26:  		/* bc 12, CR0_LT, 352 */
		/* 820F9F30h case   26:*/		if ( regs.CR[0].lt ) { return 0x820FA090;  }
		/* 820F9F30h case   26:*/		return 0x820F9F34;
		  /* 820F9F34h */ case   27:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F9F34h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F9F34h case   27:*/		return 0x820F9F38;
		  /* 820F9F38h */ case   28:  		/* addi R30, R30, 1 */
		/* 820F9F38h case   28:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820F9F38h case   28:*/		return 0x820F9F3C;
		  /* 820F9F3Ch */ case   29:  		/* addi R29, R29, 4 */
		/* 820F9F3Ch case   29:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820F9F3Ch case   29:*/		return 0x820F9F40;
		  /* 820F9F40h */ case   30:  		/* cmplw CR6, R30, R28 */
		/* 820F9F40h case   30:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R28);
		/* 820F9F40h case   30:*/		return 0x820F9F44;
		  /* 820F9F44h */ case   31:  		/* stw R25, <#[R11]> */
		/* 820F9F44h case   31:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x00000000) );
		/* 820F9F44h case   31:*/		return 0x820F9F48;
		  /* 820F9F48h */ case   32:  		/* bc 12, CR6_LT, -80 */
		/* 820F9F48h case   32:*/		if ( regs.CR[6].lt ) { return 0x820F9EF8;  }
		/* 820F9F48h case   32:*/		return 0x820F9F4C;
	}
	return 0x820F9F4C;
} // Block from 820F9EC8h-820F9F4Ch (33 instructions)

//////////////////////////////////////////////////////
// Block at 820F9F4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9F4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9F4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9F4C);
		  /* 820F9F4Ch */ case    0:  		/* mr R3, R31 */
		/* 820F9F4Ch case    0:*/		regs.R3 = regs.R31;
		/* 820F9F4Ch case    0:*/		return 0x820F9F50;
		  /* 820F9F50h */ case    1:  		/* bl 32016 */
		/* 820F9F50h case    1:*/		regs.LR = 0x820F9F54; return 0x82101C60;
		/* 820F9F50h case    1:*/		return 0x820F9F54;
		  /* 820F9F54h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820F9F54h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F9F54h case    2:*/		return 0x820F9F58;
		  /* 820F9F58h */ case    3:  		/* bc 12, CR0_LT, 312 */
		/* 820F9F58h case    3:*/		if ( regs.CR[0].lt ) { return 0x820FA090;  }
		/* 820F9F58h case    3:*/		return 0x820F9F5C;
		  /* 820F9F5Ch */ case    4:  		/* addi R26, R26, 1 */
		/* 820F9F5Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820F9F5Ch case    4:*/		return 0x820F9F60;
		  /* 820F9F60h */ case    5:  		/* cmpwi CR6, R27, 0 */
		/* 820F9F60h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 820F9F60h case    5:*/		return 0x820F9F64;
		  /* 820F9F64h */ case    6:  		/* bc 12, CR6_EQ, -140 */
		/* 820F9F64h case    6:*/		if ( regs.CR[6].eq ) { return 0x820F9ED8;  }
		/* 820F9F64h case    6:*/		return 0x820F9F68;
		  /* 820F9F68h */ case    7:  		/* cmplwi CR6, R26, 16 */
		/* 820F9F68h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000010);
		/* 820F9F68h case    7:*/		return 0x820F9F6C;
		  /* 820F9F6Ch */ case    8:  		/* bc 12, CR6_LT, 180 */
		/* 820F9F6Ch case    8:*/		if ( regs.CR[6].lt ) { return 0x820FA020;  }
		/* 820F9F6Ch case    8:*/		return 0x820F9F70;
	}
	return 0x820F9F70;
} // Block from 820F9F4Ch-820F9F70h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F9F70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9F70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9F70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9F70);
		  /* 820F9F70h */ case    0:  		/* lwz R28, <#[R31 + 12]> */
		/* 820F9F70h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x0000000C) );
		/* 820F9F70h case    0:*/		return 0x820F9F74;
		  /* 820F9F74h */ case    1:  		/* li R26, 1 */
		/* 820F9F74h case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 820F9F74h case    1:*/		return 0x820F9F78;
		  /* 820F9F78h */ case    2:  		/* mr R30, R25 */
		/* 820F9F78h case    2:*/		regs.R30 = regs.R25;
		/* 820F9F78h case    2:*/		return 0x820F9F7C;
		  /* 820F9F7Ch */ case    3:  		/* cmplwi CR6, R28, 0 */
		/* 820F9F7Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820F9F7Ch case    3:*/		return 0x820F9F80;
		  /* 820F9F80h */ case    4:  		/* bc 12, CR6_EQ, 124 */
		/* 820F9F80h case    4:*/		if ( regs.CR[6].eq ) { return 0x820F9FFC;  }
		/* 820F9F80h case    4:*/		return 0x820F9F84;
		  /* 820F9F84h */ case    5:  		/* lis R11, -32254 */
		/* 820F9F84h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F9F84h case    5:*/		return 0x820F9F88;
		  /* 820F9F88h */ case    6:  		/* mr R29, R25 */
		/* 820F9F88h case    6:*/		regs.R29 = regs.R25;
		/* 820F9F88h case    6:*/		return 0x820F9F8C;
		  /* 820F9F8Ch */ case    7:  		/* addi R27, R11, -14540 */
		/* 820F9F8Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xFFFFC734);
		/* 820F9F8Ch case    7:*/		return 0x820F9F90;
		  /* 820F9F90h */ case    8:  		/* lwz R11, <#[R31 + 24]> */
		/* 820F9F90h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820F9F90h case    8:*/		return 0x820F9F94;
		  /* 820F9F94h */ case    9:  		/* mr R3, R31 */
		/* 820F9F94h case    9:*/		regs.R3 = regs.R31;
		/* 820F9F94h case    9:*/		return 0x820F9F98;
		  /* 820F9F98h */ case   10:  		/* lwzx R11, <#[R29 + R11]> */
		/* 820F9F98h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820F9F98h case   10:*/		return 0x820F9F9C;
		  /* 820F9F9Ch */ case   11:  		/* stw R11, <#[R31 + 260]> */
		/* 820F9F9Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F9F9Ch case   11:*/		return 0x820F9FA0;
		  /* 820F9FA0h */ case   12:  		/* bl -85480 */
		/* 820F9FA0h case   12:*/		regs.LR = 0x820F9FA4; return 0x820E51B8;
		/* 820F9FA0h case   12:*/		return 0x820F9FA4;
		  /* 820F9FA4h */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 820F9FA4h case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F9FA4h case   13:*/		return 0x820F9FA8;
		  /* 820F9FA8h */ case   14:  		/* bc 12, CR0_LT, 232 */
		/* 820F9FA8h case   14:*/		if ( regs.CR[0].lt ) { return 0x820FA090;  }
		/* 820F9FA8h case   14:*/		return 0x820F9FAC;
		  /* 820F9FACh */ case   15:  		/* cmpwi CR6, R3, 0 */
		/* 820F9FACh case   15:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820F9FACh case   15:*/		return 0x820F9FB0;
		  /* 820F9FB0h */ case   16:  		/* bc 4, CR6_EQ, 32 */
		/* 820F9FB0h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820F9FD0;  }
		/* 820F9FB0h case   16:*/		return 0x820F9FB4;
		  /* 820F9FB4h */ case   17:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F9FB4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F9FB4h case   17:*/		return 0x820F9FB8;
		  /* 820F9FB8h */ case   18:  		/* mr R6, R27 */
		/* 820F9FB8h case   18:*/		regs.R6 = regs.R27;
		/* 820F9FB8h case   18:*/		return 0x820F9FBC;
		  /* 820F9FBCh */ case   19:  		/* li R5, 4553 */
		/* 820F9FBCh case   19:*/		cpu::op::li<0>(regs,&regs.R5,0x11C9);
		/* 820F9FBCh case   19:*/		return 0x820F9FC0;
		  /* 820F9FC0h */ case   20:  		/* mr R3, R31 */
		/* 820F9FC0h case   20:*/		regs.R3 = regs.R31;
		/* 820F9FC0h case   20:*/		return 0x820F9FC4;
		  /* 820F9FC4h */ case   21:  		/* lwz R4, <#[R11 + 60]> */
		/* 820F9FC4h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000003C) );
		/* 820F9FC4h case   21:*/		return 0x820F9FC8;
		  /* 820F9FC8h */ case   22:  		/* bl 83816 */
		/* 820F9FC8h case   22:*/		regs.LR = 0x820F9FCC; return 0x8210E730;
		/* 820F9FC8h case   22:*/		return 0x820F9FCC;
		  /* 820F9FCCh */ case   23:  		/* mr R26, R25 */
		/* 820F9FCCh case   23:*/		regs.R26 = regs.R25;
		/* 820F9FCCh case   23:*/		return 0x820F9FD0;
	}
	return 0x820F9FD0;
} // Block from 820F9F70h-820F9FD0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820F9FD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9FD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9FD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9FD0);
		  /* 820F9FD0h */ case    0:  		/* mr R3, R31 */
		/* 820F9FD0h case    0:*/		regs.R3 = regs.R31;
		/* 820F9FD0h case    0:*/		return 0x820F9FD4;
		  /* 820F9FD4h */ case    1:  		/* lwz R4, <#[R31 + 260]> */
		/* 820F9FD4h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000104) );
		/* 820F9FD4h case    1:*/		return 0x820F9FD8;
		  /* 820F9FD8h */ case    2:  		/* bl 13456 */
		/* 820F9FD8h case    2:*/		regs.LR = 0x820F9FDC; return 0x820FD468;
		/* 820F9FD8h case    2:*/		return 0x820F9FDC;
		  /* 820F9FDCh */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820F9FDCh case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F9FDCh case    3:*/		return 0x820F9FE0;
		  /* 820F9FE0h */ case    4:  		/* bc 12, CR0_LT, 176 */
		/* 820F9FE0h case    4:*/		if ( regs.CR[0].lt ) { return 0x820FA090;  }
		/* 820F9FE0h case    4:*/		return 0x820F9FE4;
		  /* 820F9FE4h */ case    5:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F9FE4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F9FE4h case    5:*/		return 0x820F9FE8;
		  /* 820F9FE8h */ case    6:  		/* addi R30, R30, 1 */
		/* 820F9FE8h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820F9FE8h case    6:*/		return 0x820F9FEC;
		  /* 820F9FECh */ case    7:  		/* addi R29, R29, 4 */
		/* 820F9FECh case    7:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820F9FECh case    7:*/		return 0x820F9FF0;
		  /* 820F9FF0h */ case    8:  		/* cmplw CR6, R30, R28 */
		/* 820F9FF0h case    8:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R28);
		/* 820F9FF0h case    8:*/		return 0x820F9FF4;
		  /* 820F9FF4h */ case    9:  		/* stw R25, <#[R11]> */
		/* 820F9FF4h case    9:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x00000000) );
		/* 820F9FF4h case    9:*/		return 0x820F9FF8;
		  /* 820F9FF8h */ case   10:  		/* bc 12, CR6_LT, -104 */
		/* 820F9FF8h case   10:*/		if ( regs.CR[6].lt ) { return 0x820F9F90;  }
		/* 820F9FF8h case   10:*/		return 0x820F9FFC;
	}
	return 0x820F9FFC;
} // Block from 820F9FD0h-820F9FFCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820F9FFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F9FFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F9FFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F9FFC);
		  /* 820F9FFCh */ case    0:  		/* mr R3, R31 */
		/* 820F9FFCh case    0:*/		regs.R3 = regs.R31;
		/* 820F9FFCh case    0:*/		return 0x820FA000;
		  /* 820FA000h */ case    1:  		/* bl 31840 */
		/* 820FA000h case    1:*/		regs.LR = 0x820FA004; return 0x82101C60;
		/* 820FA000h case    1:*/		return 0x820FA004;
		  /* 820FA004h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820FA004h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FA004h case    2:*/		return 0x820FA008;
		  /* 820FA008h */ case    3:  		/* bc 12, CR0_LT, 136 */
		/* 820FA008h case    3:*/		if ( regs.CR[0].lt ) { return 0x820FA090;  }
		/* 820FA008h case    3:*/		return 0x820FA00C;
		  /* 820FA00Ch */ case    4:  		/* cmpwi CR6, R26, 0 */
		/* 820FA00Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 820FA00Ch case    4:*/		return 0x820FA010;
		  /* 820FA010h */ case    5:  		/* bc 4, CR6_EQ, 16 */
		/* 820FA010h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820FA020;  }
		/* 820FA010h case    5:*/		return 0x820FA014;
		  /* 820FA014h */ case    6:  		/* lis R3, -32768 */
		/* 820FA014h case    6:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820FA014h case    6:*/		return 0x820FA018;
		  /* 820FA018h */ case    7:  		/* ori R3, R3, 16389 */
		/* 820FA018h case    7:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820FA018h case    7:*/		return 0x820FA01C;
		  /* 820FA01Ch */ case    8:  		/* b 116 */
		/* 820FA01Ch case    8:*/		return 0x820FA090;
		/* 820FA01Ch case    8:*/		return 0x820FA020;
	}
	return 0x820FA020;
} // Block from 820F9FFCh-820FA020h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820FA020h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA020( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA020) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA020);
		  /* 820FA020h */ case    0:  		/* lwz R11, <#[R31 + 112]> */
		/* 820FA020h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820FA020h case    0:*/		return 0x820FA024;
		  /* 820FA024h */ case    1:  		/* rlwinm. R11, R11, 0, 7, 7 */
		/* 820FA024h case    1:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R11,regs.R11);
		/* 820FA024h case    1:*/		return 0x820FA028;
		  /* 820FA028h */ case    2:  		/* bc 4, CR0_EQ, 32 */
		/* 820FA028h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820FA048;  }
		/* 820FA028h case    2:*/		return 0x820FA02C;
		  /* 820FA02Ch */ case    3:  		/* lwz R11, <#[R31]> */
		/* 820FA02Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FA02Ch case    3:*/		return 0x820FA030;
		  /* 820FA030h */ case    4:  		/* mr R3, R31 */
		/* 820FA030h case    4:*/		regs.R3 = regs.R31;
		/* 820FA030h case    4:*/		return 0x820FA034;
		  /* 820FA034h */ case    5:  		/* lwz R11, <#[R11 + 364]> */
		/* 820FA034h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000016C) );
		/* 820FA034h case    5:*/		return 0x820FA038;
		  /* 820FA038h */ case    6:  		/* mtspr CTR, R11 */
		/* 820FA038h case    6:*/		regs.CTR = regs.R11;
		/* 820FA038h case    6:*/		return 0x820FA03C;
		  /* 820FA03Ch */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820FA03Ch case    7:*/		if ( 1 ) { regs.LR = 0x820FA040; return (uint32)regs.CTR; }
		/* 820FA03Ch case    7:*/		return 0x820FA040;
		  /* 820FA040h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 820FA040h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FA040h case    8:*/		return 0x820FA044;
		  /* 820FA044h */ case    9:  		/* bc 12, CR0_LT, 76 */
		/* 820FA044h case    9:*/		if ( regs.CR[0].lt ) { return 0x820FA090;  }
		/* 820FA044h case    9:*/		return 0x820FA048;
	}
	return 0x820FA048;
} // Block from 820FA020h-820FA048h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FA048h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA048( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA048) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA048);
		  /* 820FA048h */ case    0:  		/* lwz R11, <#[R31 + 96]> */
		/* 820FA048h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 820FA048h case    0:*/		return 0x820FA04C;
		  /* 820FA04Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820FA04Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FA04Ch case    1:*/		return 0x820FA050;
		  /* 820FA050h */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 820FA050h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FA08C;  }
		/* 820FA050h case    2:*/		return 0x820FA054;
		  /* 820FA054h */ case    3:  		/* mr R3, R31 */
		/* 820FA054h case    3:*/		regs.R3 = regs.R31;
		/* 820FA054h case    3:*/		return 0x820FA058;
		  /* 820FA058h */ case    4:  		/* bl -36400 */
		/* 820FA058h case    4:*/		regs.LR = 0x820FA05C; return 0x820F1228;
		/* 820FA058h case    4:*/		return 0x820FA05C;
		  /* 820FA05Ch */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820FA05Ch case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FA05Ch case    5:*/		return 0x820FA060;
		  /* 820FA060h */ case    6:  		/* bc 12, CR0_LT, 48 */
		/* 820FA060h case    6:*/		if ( regs.CR[0].lt ) { return 0x820FA090;  }
		/* 820FA060h case    6:*/		return 0x820FA064;
		  /* 820FA064h */ case    7:  		/* mr R3, R31 */
		/* 820FA064h case    7:*/		regs.R3 = regs.R31;
		/* 820FA064h case    7:*/		return 0x820FA068;
		  /* 820FA068h */ case    8:  		/* bl -88200 */
		/* 820FA068h case    8:*/		regs.LR = 0x820FA06C; return 0x820E47E0;
		/* 820FA068h case    8:*/		return 0x820FA06C;
		  /* 820FA06Ch */ case    9:  		/* mr R3, R31 */
		/* 820FA06Ch case    9:*/		regs.R3 = regs.R31;
		/* 820FA06Ch case    9:*/		return 0x820FA070;
		  /* 820FA070h */ case   10:  		/* bl 65856 */
		/* 820FA070h case   10:*/		regs.LR = 0x820FA074; return 0x8210A1B0;
		/* 820FA070h case   10:*/		return 0x820FA074;
		  /* 820FA074h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820FA074h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FA074h case   11:*/		return 0x820FA078;
		  /* 820FA078h */ case   12:  		/* bc 12, CR0_LT, 24 */
		/* 820FA078h case   12:*/		if ( regs.CR[0].lt ) { return 0x820FA090;  }
		/* 820FA078h case   12:*/		return 0x820FA07C;
		  /* 820FA07Ch */ case   13:  		/* mr R3, R31 */
		/* 820FA07Ch case   13:*/		regs.R3 = regs.R31;
		/* 820FA07Ch case   13:*/		return 0x820FA080;
		  /* 820FA080h */ case   14:  		/* bl -60120 */
		/* 820FA080h case   14:*/		regs.LR = 0x820FA084; return 0x820EB5A8;
		/* 820FA080h case   14:*/		return 0x820FA084;
		  /* 820FA084h */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 820FA084h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FA084h case   15:*/		return 0x820FA088;
		  /* 820FA088h */ case   16:  		/* bc 12, CR0_LT, 8 */
		/* 820FA088h case   16:*/		if ( regs.CR[0].lt ) { return 0x820FA090;  }
		/* 820FA088h case   16:*/		return 0x820FA08C;
	}
	return 0x820FA08C;
} // Block from 820FA048h-820FA08Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 820FA08Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA08C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA08C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA08C);
		  /* 820FA08Ch */ case    0:  		/* mr R3, R25 */
		/* 820FA08Ch case    0:*/		regs.R3 = regs.R25;
		/* 820FA08Ch case    0:*/		return 0x820FA090;
	}
	return 0x820FA090;
} // Block from 820FA08Ch-820FA090h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FA090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA090);
		  /* 820FA090h */ case    0:  		/* addi R1, R1, 144 */
		/* 820FA090h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820FA090h case    0:*/		return 0x820FA094;
		  /* 820FA094h */ case    1:  		/* b -429560 */
		/* 820FA094h case    1:*/		return 0x8209129C;
		/* 820FA094h case    1:*/		return 0x820FA098;
	}
	return 0x820FA098;
} // Block from 820FA090h-820FA098h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FA098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA098);
		  /* 820FA098h */ case    0:  		/* mfspr R12, LR */
		/* 820FA098h case    0:*/		regs.R12 = regs.LR;
		/* 820FA098h case    0:*/		return 0x820FA09C;
		  /* 820FA09Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820FA09Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FA09Ch case    1:*/		return 0x820FA0A0;
		  /* 820FA0A0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820FA0A0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FA0A0h case    2:*/		return 0x820FA0A4;
		  /* 820FA0A4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820FA0A4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820FA0A4h case    3:*/		return 0x820FA0A8;
		  /* 820FA0A8h */ case    4:  		/* mr R31, R3 */
		/* 820FA0A8h case    4:*/		regs.R31 = regs.R3;
		/* 820FA0A8h case    4:*/		return 0x820FA0AC;
		  /* 820FA0ACh */ case    5:  		/* bl -47036 */
		/* 820FA0ACh case    5:*/		regs.LR = 0x820FA0B0; return 0x820EE8F0;
		/* 820FA0ACh case    5:*/		return 0x820FA0B0;
		  /* 820FA0B0h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820FA0B0h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FA0B0h case    6:*/		return 0x820FA0B4;
		  /* 820FA0B4h */ case    7:  		/* bc 12, CR0_LT, 64 */
		/* 820FA0B4h case    7:*/		if ( regs.CR[0].lt ) { return 0x820FA0F4;  }
		/* 820FA0B4h case    7:*/		return 0x820FA0B8;
		  /* 820FA0B8h */ case    8:  		/* mr R3, R31 */
		/* 820FA0B8h case    8:*/		regs.R3 = regs.R31;
		/* 820FA0B8h case    8:*/		return 0x820FA0BC;
		  /* 820FA0BCh */ case    9:  		/* bl 53164 */
		/* 820FA0BCh case    9:*/		regs.LR = 0x820FA0C0; return 0x82107068;
		/* 820FA0BCh case    9:*/		return 0x820FA0C0;
		  /* 820FA0C0h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 820FA0C0h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FA0C0h case   10:*/		return 0x820FA0C4;
		  /* 820FA0C4h */ case   11:  		/* bc 12, CR0_LT, 48 */
		/* 820FA0C4h case   11:*/		if ( regs.CR[0].lt ) { return 0x820FA0F4;  }
		/* 820FA0C4h case   11:*/		return 0x820FA0C8;
		  /* 820FA0C8h */ case   12:  		/* mr R3, R31 */
		/* 820FA0C8h case   12:*/		regs.R3 = regs.R31;
		/* 820FA0C8h case   12:*/		return 0x820FA0CC;
		  /* 820FA0CCh */ case   13:  		/* bl 65764 */
		/* 820FA0CCh case   13:*/		regs.LR = 0x820FA0D0; return 0x8210A1B0;
		/* 820FA0CCh case   13:*/		return 0x820FA0D0;
		  /* 820FA0D0h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 820FA0D0h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FA0D0h case   14:*/		return 0x820FA0D4;
		  /* 820FA0D4h */ case   15:  		/* bc 12, CR0_LT, 32 */
		/* 820FA0D4h case   15:*/		if ( regs.CR[0].lt ) { return 0x820FA0F4;  }
		/* 820FA0D4h case   15:*/		return 0x820FA0D8;
		  /* 820FA0D8h */ case   16:  		/* mr R3, R31 */
		/* 820FA0D8h case   16:*/		regs.R3 = regs.R31;
		/* 820FA0D8h case   16:*/		return 0x820FA0DC;
		  /* 820FA0DCh */ case   17:  		/* bl 31620 */
		/* 820FA0DCh case   17:*/		regs.LR = 0x820FA0E0; return 0x82101C60;
		/* 820FA0DCh case   17:*/		return 0x820FA0E0;
		  /* 820FA0E0h */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 820FA0E0h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FA0E0h case   18:*/		return 0x820FA0E4;
		  /* 820FA0E4h */ case   19:  		/* bc 12, CR0_LT, 16 */
		/* 820FA0E4h case   19:*/		if ( regs.CR[0].lt ) { return 0x820FA0F4;  }
		/* 820FA0E4h case   19:*/		return 0x820FA0E8;
		  /* 820FA0E8h */ case   20:  		/* mr R3, R31 */
		/* 820FA0E8h case   20:*/		regs.R3 = regs.R31;
		/* 820FA0E8h case   20:*/		return 0x820FA0EC;
		  /* 820FA0ECh */ case   21:  		/* bl -88332 */
		/* 820FA0ECh case   21:*/		regs.LR = 0x820FA0F0; return 0x820E47E0;
		/* 820FA0ECh case   21:*/		return 0x820FA0F0;
		  /* 820FA0F0h */ case   22:  		/* li R3, 0 */
		/* 820FA0F0h case   22:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FA0F0h case   22:*/		return 0x820FA0F4;
	}
	return 0x820FA0F4;
} // Block from 820FA098h-820FA0F4h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820FA0F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA0F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA0F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA0F4);
		  /* 820FA0F4h */ case    0:  		/* addi R1, R1, 96 */
		/* 820FA0F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820FA0F4h case    0:*/		return 0x820FA0F8;
		  /* 820FA0F8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820FA0F8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FA0F8h case    1:*/		return 0x820FA0FC;
		  /* 820FA0FCh */ case    2:  		/* mtspr LR, R12 */
		/* 820FA0FCh case    2:*/		regs.LR = regs.R12;
		/* 820FA0FCh case    2:*/		return 0x820FA100;
		  /* 820FA100h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820FA100h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FA100h case    3:*/		return 0x820FA104;
		  /* 820FA104h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820FA104h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FA104h case    4:*/		return 0x820FA108;
	}
	return 0x820FA108;
} // Block from 820FA0F4h-820FA108h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FA108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA108);
		  /* 820FA108h */ case    0:  		/* mfspr R12, LR */
		/* 820FA108h case    0:*/		regs.R12 = regs.LR;
		/* 820FA108h case    0:*/		return 0x820FA10C;
		  /* 820FA10Ch */ case    1:  		/* bl -429744 */
		/* 820FA10Ch case    1:*/		regs.LR = 0x820FA110; return 0x8209125C;
		/* 820FA10Ch case    1:*/		return 0x820FA110;
		  /* 820FA110h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820FA110h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820FA110h case    2:*/		return 0x820FA114;
		  /* 820FA114h */ case    3:  		/* or R30, R4, R5 */
		/* 820FA114h case    3:*/		cpu::op::or<0>(regs,&regs.R30,regs.R4,regs.R5);
		/* 820FA114h case    3:*/		return 0x820FA118;
		  /* 820FA118h */ case    4:  		/* mr R31, R3 */
		/* 820FA118h case    4:*/		regs.R31 = regs.R3;
		/* 820FA118h case    4:*/		return 0x820FA11C;
		  /* 820FA11Ch */ case    5:  		/* mr R4, R30 */
		/* 820FA11Ch case    5:*/		regs.R4 = regs.R30;
		/* 820FA11Ch case    5:*/		return 0x820FA120;
		  /* 820FA120h */ case    6:  		/* mr R29, R6 */
		/* 820FA120h case    6:*/		regs.R29 = regs.R6;
		/* 820FA120h case    6:*/		return 0x820FA124;
		  /* 820FA124h */ case    7:  		/* bl -16148 */
		/* 820FA124h case    7:*/		regs.LR = 0x820FA128; return 0x820F6210;
		/* 820FA124h case    7:*/		return 0x820FA128;
		  /* 820FA128h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 820FA128h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FA128h case    8:*/		return 0x820FA12C;
		  /* 820FA12Ch */ case    9:  		/* bc 12, CR0_LT, 156 */
		/* 820FA12Ch case    9:*/		if ( regs.CR[0].lt ) { return 0x820FA1C8;  }
		/* 820FA12Ch case    9:*/		return 0x820FA130;
		  /* 820FA130h */ case   10:  		/* rlwinm. R11, R30, 0, 18, 18 */
		/* 820FA130h case   10:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R11,regs.R30);
		/* 820FA130h case   10:*/		return 0x820FA134;
		  /* 820FA134h */ case   11:  		/* bc 12, CR0_EQ, 144 */
		/* 820FA134h case   11:*/		if ( regs.CR[0].eq ) { return 0x820FA1C4;  }
		/* 820FA134h case   11:*/		return 0x820FA138;
		  /* 820FA138h */ case   12:  		/* lhz R11, <#[R31 + 202]> */
		/* 820FA138h case   12:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000CA) );
		/* 820FA138h case   12:*/		return 0x820FA13C;
		  /* 820FA13Ch */ case   13:  		/* cmplwi CR6, R11, 512 */
		/* 820FA13Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000200);
		/* 820FA13Ch case   13:*/		return 0x820FA140;
		  /* 820FA140h */ case   14:  		/* bc 12, CR6_LT, 132 */
		/* 820FA140h case   14:*/		if ( regs.CR[6].lt ) { return 0x820FA1C4;  }
		/* 820FA140h case   14:*/		return 0x820FA144;
		  /* 820FA144h */ case   15:  		/* lwz R10, <#[R31 + 20]> */
		/* 820FA144h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820FA144h case   15:*/		return 0x820FA148;
		  /* 820FA148h */ case   16:  		/* rlwinm R11, R29, 2, 0, 29 */
		/* 820FA148h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R29);
		/* 820FA148h case   16:*/		return 0x820FA14C;
		  /* 820FA14Ch */ case   17:  		/* lwz R9, <#[R31 + 16]> */
		/* 820FA14Ch case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 820FA14Ch case   17:*/		return 0x820FA150;
		  /* 820FA150h */ case   18:  		/* lwzx R10, <#[R10 + R11]> */
		/* 820FA150h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820FA150h case   18:*/		return 0x820FA154;
		  /* 820FA154h */ case   19:  		/* lwz R10, <#[R10 + 4]> */
		/* 820FA154h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820FA154h case   19:*/		return 0x820FA158;
		  /* 820FA158h */ case   20:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FA158h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FA158h case   20:*/		return 0x820FA15C;
		  /* 820FA15Ch */ case   21:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820FA15Ch case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820FA15Ch case   21:*/		return 0x820FA160;
		  /* 820FA160h */ case   22:  		/* lwz R10, <#[R10 + 4]> */
		/* 820FA160h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820FA160h case   22:*/		return 0x820FA164;
		  /* 820FA164h */ case   23:  		/* rlwinm. R10, R10, 0, 27, 27 */
		/* 820FA164h case   23:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R10);
		/* 820FA164h case   23:*/		return 0x820FA168;
		  /* 820FA168h */ case   24:  		/* bc 12, CR0_EQ, 16 */
		/* 820FA168h case   24:*/		if ( regs.CR[0].eq ) { return 0x820FA178;  }
		/* 820FA168h case   24:*/		return 0x820FA16C;
		  /* 820FA16Ch */ case   25:  		/* lis R4, -3868 */
		/* 820FA16Ch case   25:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFF0E4);
		/* 820FA16Ch case   25:*/		return 0x820FA170;
		  /* 820FA170h */ case   26:  		/* ori R4, R4, 2048 */
		/* 820FA170h case   26:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x800);
		/* 820FA170h case   26:*/		return 0x820FA174;
		  /* 820FA174h */ case   27:  		/* b 72 */
		/* 820FA174h case   27:*/		return 0x820FA1BC;
		/* 820FA174h case   27:*/		return 0x820FA178;
	}
	return 0x820FA178;
} // Block from 820FA108h-820FA178h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820FA178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA178);
		  /* 820FA178h */ case    0:  		/* lwz R10, <#[R31 + 20]> */
		/* 820FA178h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820FA178h case    0:*/		return 0x820FA17C;
		  /* 820FA17Ch */ case    1:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820FA17Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820FA17Ch case    1:*/		return 0x820FA180;
		  /* 820FA180h */ case    2:  		/* lwz R10, <#[R11 + 12]> */
		/* 820FA180h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820FA180h case    2:*/		return 0x820FA184;
		  /* 820FA184h */ case    3:  		/* lwz R11, <#[R11 + 16]> */
		/* 820FA184h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820FA184h case    3:*/		return 0x820FA188;
		  /* 820FA188h */ case    4:  		/* rlwinm R10, R10, 0, 21, 31 */
		/* 820FA188h case    4:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R10,regs.R10);
		/* 820FA188h case    4:*/		return 0x820FA18C;
		  /* 820FA18Ch */ case    5:  		/* cmplwi CR6, R11, 1 */
		/* 820FA18Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820FA18Ch case    5:*/		return 0x820FA190;
		  /* 820FA190h */ case    6:  		/* oris R4, R10, 45056 */
		/* 820FA190h case    6:*/		cpu::op::oris<0>(regs,&regs.R4,regs.R10,0xB000);
		/* 820FA190h case    6:*/		return 0x820FA194;
		  /* 820FA194h */ case    7:  		/* bc 12, CR6_LT, 40 */
		/* 820FA194h case    7:*/		if ( regs.CR[6].lt ) { return 0x820FA1BC;  }
		/* 820FA194h case    7:*/		return 0x820FA198;
		  /* 820FA198h */ case    8:  		/* bc 12, CR6_EQ, 32 */
		/* 820FA198h case    8:*/		if ( regs.CR[6].eq ) { return 0x820FA1B8;  }
		/* 820FA198h case    8:*/		return 0x820FA19C;
		  /* 820FA19Ch */ case    9:  		/* cmplwi CR6, R11, 3 */
		/* 820FA19Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820FA19Ch case    9:*/		return 0x820FA1A0;
		  /* 820FA1A0h */ case   10:  		/* bc 12, CR6_LT, 16 */
		/* 820FA1A0h case   10:*/		if ( regs.CR[6].lt ) { return 0x820FA1B0;  }
		/* 820FA1A0h case   10:*/		return 0x820FA1A4;
		  /* 820FA1A4h */ case   11:  		/* bc 4, CR6_EQ, 24 */
		/* 820FA1A4h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820FA1BC;  }
		/* 820FA1A4h case   11:*/		return 0x820FA1A8;
		  /* 820FA1A8h */ case   12:  		/* oris R4, R4, 255 */
		/* 820FA1A8h case   12:*/		cpu::op::oris<0>(regs,&regs.R4,regs.R4,0xFF);
		/* 820FA1A8h case   12:*/		return 0x820FA1AC;
		  /* 820FA1ACh */ case   13:  		/* b 16 */
		/* 820FA1ACh case   13:*/		return 0x820FA1BC;
		/* 820FA1ACh case   13:*/		return 0x820FA1B0;
	}
	return 0x820FA1B0;
} // Block from 820FA178h-820FA1B0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820FA1B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA1B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA1B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA1B0);
		  /* 820FA1B0h */ case    0:  		/* oris R4, R4, 170 */
		/* 820FA1B0h case    0:*/		cpu::op::oris<0>(regs,&regs.R4,regs.R4,0xAA);
		/* 820FA1B0h case    0:*/		return 0x820FA1B4;
		  /* 820FA1B4h */ case    1:  		/* b 8 */
		/* 820FA1B4h case    1:*/		return 0x820FA1BC;
		/* 820FA1B4h case    1:*/		return 0x820FA1B8;
	}
	return 0x820FA1B8;
} // Block from 820FA1B0h-820FA1B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FA1B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA1B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA1B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA1B8);
		  /* 820FA1B8h */ case    0:  		/* oris R4, R4, 85 */
		/* 820FA1B8h case    0:*/		cpu::op::oris<0>(regs,&regs.R4,regs.R4,0x55);
		/* 820FA1B8h case    0:*/		return 0x820FA1BC;
	}
	return 0x820FA1BC;
} // Block from 820FA1B8h-820FA1BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FA1BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA1BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA1BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA1BC);
		  /* 820FA1BCh */ case    0:  		/* mr R3, R31 */
		/* 820FA1BCh case    0:*/		regs.R3 = regs.R31;
		/* 820FA1BCh case    0:*/		return 0x820FA1C0;
		  /* 820FA1C0h */ case    1:  		/* bl -16304 */
		/* 820FA1C0h case    1:*/		regs.LR = 0x820FA1C4; return 0x820F6210;
		/* 820FA1C0h case    1:*/		return 0x820FA1C4;
	}
	return 0x820FA1C4;
} // Block from 820FA1BCh-820FA1C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FA1C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA1C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA1C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA1C4);
		  /* 820FA1C4h */ case    0:  		/* li R3, 0 */
		/* 820FA1C4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FA1C4h case    0:*/		return 0x820FA1C8;
	}
	return 0x820FA1C8;
} // Block from 820FA1C4h-820FA1C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FA1C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA1C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA1C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA1C8);
		  /* 820FA1C8h */ case    0:  		/* addi R1, R1, 112 */
		/* 820FA1C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820FA1C8h case    0:*/		return 0x820FA1CC;
		  /* 820FA1CCh */ case    1:  		/* b -429856 */
		/* 820FA1CCh case    1:*/		return 0x820912AC;
		/* 820FA1CCh case    1:*/		return 0x820FA1D0;
	}
	return 0x820FA1D0;
} // Block from 820FA1C8h-820FA1D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FA1D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA1D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA1D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA1D0);
		  /* 820FA1D0h */ case    0:  		/* lwz R11, <#[R4]> */
		/* 820FA1D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820FA1D0h case    0:*/		return 0x820FA1D4;
		  /* 820FA1D4h */ case    1:  		/* lwz R10, <#[R4 + 8]> */
		/* 820FA1D4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 820FA1D4h case    1:*/		return 0x820FA1D8;
		  /* 820FA1D8h */ case    2:  		/* rlwinm R9, R11, 0, 12, 31 */
		/* 820FA1D8h case    2:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R9,regs.R11);
		/* 820FA1D8h case    2:*/		return 0x820FA1DC;
		  /* 820FA1DCh */ case    3:  		/* lwz R8, <#[R3 + 20]> */
		/* 820FA1DCh case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000014) );
		/* 820FA1DCh case    3:*/		return 0x820FA1E0;
		  /* 820FA1E0h */ case    4:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FA1E0h case    4:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FA1E0h case    4:*/		return 0x820FA1E4;
		  /* 820FA1E4h */ case    5:  		/* mullw R9, R9, R5 */
		/* 820FA1E4h case    5:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R9,regs.R5);
		/* 820FA1E4h case    5:*/		return 0x820FA1E8;
		  /* 820FA1E8h */ case    6:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820FA1E8h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820FA1E8h case    6:*/		return 0x820FA1EC;
		  /* 820FA1ECh */ case    7:  		/* lwzx R10, <#[R9 + R10]> */
		/* 820FA1ECh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FA1ECh case    7:*/		return 0x820FA1F0;
		  /* 820FA1F0h */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FA1F0h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FA1F0h case    8:*/		return 0x820FA1F4;
		  /* 820FA1F4h */ case    9:  		/* lwzx R10, <#[R10 + R8]> */
		/* 820FA1F4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820FA1F4h case    9:*/		return 0x820FA1F8;
		  /* 820FA1F8h */ case   10:  		/* lwz R10, <#[R10 + 108]> */
		/* 820FA1F8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000006C) );
		/* 820FA1F8h case   10:*/		return 0x820FA1FC;
		  /* 820FA1FCh */ case   11:  		/* cmplwi CR6, R10, 17 */
		/* 820FA1FCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000011);
		/* 820FA1FCh case   11:*/		return 0x820FA200;
		  /* 820FA200h */ case   12:  		/* bc 12, CR6_EQ, 12 */
		/* 820FA200h case   12:*/		if ( regs.CR[6].eq ) { return 0x820FA20C;  }
		/* 820FA200h case   12:*/		return 0x820FA204;
		  /* 820FA204h */ case   13:  		/* li R3, 0 */
		/* 820FA204h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FA204h case   13:*/		return 0x820FA208;
		  /* 820FA208h */ case   14:  		/* bclr 20, CR0_LT */
		/* 820FA208h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FA208h case   14:*/		return 0x820FA20C;
	}
	return 0x820FA20C;
} // Block from 820FA1D0h-820FA20Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 820FA20Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA20C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA20C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA20C);
		  /* 820FA20Ch */ case    0:  		/* lis R10, 12288 */
		/* 820FA20Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x3000);
		/* 820FA20Ch case    0:*/		return 0x820FA210;
		  /* 820FA210h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FA210h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FA210h case    1:*/		return 0x820FA214;
		  /* 820FA214h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 820FA214h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FA220;  }
		/* 820FA214h case    2:*/		return 0x820FA218;
	}
	return 0x820FA218;
} // Block from 820FA20Ch-820FA218h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FA218h
// Function '?FindOutput@C30Program@D3DXShader@@MAAJPAVCArgument@2@AAK1PAH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA218);
		  /* 820FA218h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 820FA218h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820FA218h case    0:*/		return 0x820FA21C;
		  /* 820FA21Ch */ case    1:  		/* b 108 */
		/* 820FA21Ch case    1:*/		return 0x820FA288;
		/* 820FA21Ch case    1:*/		return 0x820FA220;
	}
	return 0x820FA220;
} // Block from 820FA218h-820FA220h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FA220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA220);
		  /* 820FA220h */ case    0:  		/* lis R10, 29568 */
		/* 820FA220h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x7380);
		/* 820FA220h case    0:*/		return 0x820FA224;
		  /* 820FA224h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FA224h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FA224h case    1:*/		return 0x820FA228;
		  /* 820FA228h */ case    2:  		/* bc 12, CR6_GT, 52 */
		/* 820FA228h case    2:*/		if ( regs.CR[6].gt ) { return 0x820FA25C;  }
		/* 820FA228h case    2:*/		return 0x820FA22C;
		  /* 820FA22Ch */ case    3:  		/* bc 12, CR6_EQ, 96 */
		/* 820FA22Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820FA28C;  }
		/* 820FA22Ch case    3:*/		return 0x820FA230;
		  /* 820FA230h */ case    4:  		/* lis R10, 4336 */
		/* 820FA230h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0x10F0);
		/* 820FA230h case    4:*/		return 0x820FA234;
		  /* 820FA234h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 820FA234h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FA234h case    5:*/		return 0x820FA238;
		  /* 820FA238h */ case    6:  		/* bc 12, CR6_EQ, 84 */
		/* 820FA238h case    6:*/		if ( regs.CR[6].eq ) { return 0x820FA28C;  }
		/* 820FA238h case    6:*/		return 0x820FA23C;
		  /* 820FA23Ch */ case    7:  		/* lis R10, 29520 */
		/* 820FA23Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0x7350);
		/* 820FA23Ch case    7:*/		return 0x820FA240;
		  /* 820FA240h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 820FA240h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FA240h case    8:*/		return 0x820FA244;
		  /* 820FA244h */ case    9:  		/* bc 12, CR6_EQ, 72 */
		/* 820FA244h case    9:*/		if ( regs.CR[6].eq ) { return 0x820FA28C;  }
		/* 820FA244h case    9:*/		return 0x820FA248;
		  /* 820FA248h */ case   10:  		/* lis R10, 29536 */
		/* 820FA248h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0x7360);
		/* 820FA248h case   10:*/		return 0x820FA24C;
		  /* 820FA24Ch */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 820FA24Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FA24Ch case   11:*/		return 0x820FA250;
		  /* 820FA250h */ case   12:  		/* bc 12, CR6_EQ, 60 */
		/* 820FA250h case   12:*/		if ( regs.CR[6].eq ) { return 0x820FA28C;  }
		/* 820FA250h case   12:*/		return 0x820FA254;
		  /* 820FA254h */ case   13:  		/* lis R10, 29552 */
		/* 820FA254h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0x7370);
		/* 820FA254h case   13:*/		return 0x820FA258;
		  /* 820FA258h */ case   14:  		/* b 44 */
		/* 820FA258h case   14:*/		return 0x820FA284;
		/* 820FA258h case   14:*/		return 0x820FA25C;
	}
	return 0x820FA25C;
} // Block from 820FA220h-820FA25Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 820FA25Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA25C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA25C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA25C);
		  /* 820FA25Ch */ case    0:  		/* lis R10, 29760 */
		/* 820FA25Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x7440);
		/* 820FA25Ch case    0:*/		return 0x820FA260;
		  /* 820FA260h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FA260h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FA260h case    1:*/		return 0x820FA264;
		  /* 820FA264h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820FA264h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FA28C;  }
		/* 820FA264h case    2:*/		return 0x820FA268;
		  /* 820FA268h */ case    3:  		/* lis R10, 29776 */
		/* 820FA268h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x7450);
		/* 820FA268h case    3:*/		return 0x820FA26C;
		  /* 820FA26Ch */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FA26Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FA26Ch case    4:*/		return 0x820FA270;
		  /* 820FA270h */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 820FA270h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FA28C;  }
		/* 820FA270h case    5:*/		return 0x820FA274;
		  /* 820FA274h */ case    6:  		/* lis R10, 29792 */
		/* 820FA274h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x7460);
		/* 820FA274h case    6:*/		return 0x820FA278;
		  /* 820FA278h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FA278h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FA278h case    7:*/		return 0x820FA27C;
		  /* 820FA27Ch */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 820FA27Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x820FA28C;  }
		/* 820FA27Ch case    8:*/		return 0x820FA280;
		  /* 820FA280h */ case    9:  		/* lis R10, 29808 */
		/* 820FA280h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x7470);
		/* 820FA280h case    9:*/		return 0x820FA284;
	}
	return 0x820FA284;
} // Block from 820FA25Ch-820FA284h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FA284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA284);
		  /* 820FA284h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 820FA284h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FA284h case    0:*/		return 0x820FA288;
	}
	return 0x820FA288;
} // Block from 820FA284h-820FA288h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FA288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA288);
		  /* 820FA288h */ case    0:  		/* bc 4, CR6_EQ, -132 */
		/* 820FA288h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820FA204;  }
		/* 820FA288h case    0:*/		return 0x820FA28C;
	}
	return 0x820FA28C;
} // Block from 820FA288h-820FA28Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FA28Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA28C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA28C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA28C);
		  /* 820FA28Ch */ case    0:  		/* li R3, 1 */
		/* 820FA28Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FA28Ch case    0:*/		return 0x820FA290;
		  /* 820FA290h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820FA290h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FA290h case    1:*/		return 0x820FA294;
	}
	return 0x820FA294;
} // Block from 820FA28Ch-820FA294h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FA294h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA294( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA294) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA294);
		  /* 820FA294h */ case    0:  		/* nop */
		/* 820FA294h case    0:*/		cpu::op::nop();
		/* 820FA294h case    0:*/		return 0x820FA298;
	}
	return 0x820FA298;
} // Block from 820FA294h-820FA298h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FA298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA298);
		  /* 820FA298h */ case    0:  		/* mfspr R12, LR */
		/* 820FA298h case    0:*/		regs.R12 = regs.LR;
		/* 820FA298h case    0:*/		return 0x820FA29C;
		  /* 820FA29Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820FA29Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FA29Ch case    1:*/		return 0x820FA2A0;
		  /* 820FA2A0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820FA2A0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820FA2A0h case    2:*/		return 0x820FA2A4;
		  /* 820FA2A4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820FA2A4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FA2A4h case    3:*/		return 0x820FA2A8;
		  /* 820FA2A8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820FA2A8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820FA2A8h case    4:*/		return 0x820FA2AC;
		  /* 820FA2ACh */ case    5:  		/* lis R11, -32254 */
		/* 820FA2ACh case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820FA2ACh case    5:*/		return 0x820FA2B0;
		  /* 820FA2B0h */ case    6:  		/* mr R31, R3 */
		/* 820FA2B0h case    6:*/		regs.R31 = regs.R3;
		/* 820FA2B0h case    6:*/		return 0x820FA2B4;
		  /* 820FA2B4h */ case    7:  		/* addi R11, R11, -15256 */
		/* 820FA2B4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFC468);
		/* 820FA2B4h case    7:*/		return 0x820FA2B8;
		  /* 820FA2B8h */ case    8:  		/* mr R30, R4 */
		/* 820FA2B8h case    8:*/		regs.R30 = regs.R4;
		/* 820FA2B8h case    8:*/		return 0x820FA2BC;
		  /* 820FA2BCh */ case    9:  		/* stw R11, <#[R3]> */
		/* 820FA2BCh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820FA2BCh case    9:*/		return 0x820FA2C0;
		  /* 820FA2C0h */ case   10:  		/* bl -50624 */
		/* 820FA2C0h case   10:*/		regs.LR = 0x820FA2C4; return 0x820EDD00;
		/* 820FA2C0h case   10:*/		return 0x820FA2C4;
		  /* 820FA2C4h */ case   11:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 820FA2C4h case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 820FA2C4h case   11:*/		return 0x820FA2C8;
		  /* 820FA2C8h */ case   12:  		/* bc 12, CR0_EQ, 16 */
		/* 820FA2C8h case   12:*/		if ( regs.CR[0].eq ) { return 0x820FA2D8;  }
		/* 820FA2C8h case   12:*/		return 0x820FA2CC;
		  /* 820FA2CCh */ case   13:  		/* lis R4, 9345 */
		/* 820FA2CCh case   13:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820FA2CCh case   13:*/		return 0x820FA2D0;
		  /* 820FA2D0h */ case   14:  		/* mr R3, R31 */
		/* 820FA2D0h case   14:*/		regs.R3 = regs.R31;
		/* 820FA2D0h case   14:*/		return 0x820FA2D4;
		  /* 820FA2D4h */ case   15:  		/* bl -466844 */
		/* 820FA2D4h case   15:*/		regs.LR = 0x820FA2D8; return 0x82088338;
		/* 820FA2D4h case   15:*/		return 0x820FA2D8;
	}
	return 0x820FA2D8;
} // Block from 820FA298h-820FA2D8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820FA2D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA2D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA2D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA2D8);
		  /* 820FA2D8h */ case    0:  		/* mr R3, R31 */
		/* 820FA2D8h case    0:*/		regs.R3 = regs.R31;
		/* 820FA2D8h case    0:*/		return 0x820FA2DC;
		  /* 820FA2DCh */ case    1:  		/* addi R1, R1, 112 */
		/* 820FA2DCh case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820FA2DCh case    1:*/		return 0x820FA2E0;
		  /* 820FA2E0h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820FA2E0h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FA2E0h case    2:*/		return 0x820FA2E4;
		  /* 820FA2E4h */ case    3:  		/* mtspr LR, R12 */
		/* 820FA2E4h case    3:*/		regs.LR = regs.R12;
		/* 820FA2E4h case    3:*/		return 0x820FA2E8;
		  /* 820FA2E8h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 820FA2E8h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820FA2E8h case    4:*/		return 0x820FA2EC;
		  /* 820FA2ECh */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 820FA2ECh case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FA2ECh case    5:*/		return 0x820FA2F0;
		  /* 820FA2F0h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820FA2F0h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FA2F0h case    6:*/		return 0x820FA2F4;
	}
	return 0x820FA2F4;
} // Block from 820FA2D8h-820FA2F4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820FA2F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA2F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA2F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA2F4);
		  /* 820FA2F4h */ case    0:  		/* nop */
		/* 820FA2F4h case    0:*/		cpu::op::nop();
		/* 820FA2F4h case    0:*/		return 0x820FA2F8;
	}
	return 0x820FA2F8;
} // Block from 820FA2F4h-820FA2F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FA2F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA2F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA2F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA2F8);
		  /* 820FA2F8h */ case    0:  		/* mfspr R12, LR */
		/* 820FA2F8h case    0:*/		regs.R12 = regs.LR;
		/* 820FA2F8h case    0:*/		return 0x820FA2FC;
		  /* 820FA2FCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820FA2FCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FA2FCh case    1:*/		return 0x820FA300;
		  /* 820FA300h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820FA300h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FA300h case    2:*/		return 0x820FA304;
		  /* 820FA304h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820FA304h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820FA304h case    3:*/		return 0x820FA308;
		  /* 820FA308h */ case    4:  		/* mr R31, R3 */
		/* 820FA308h case    4:*/		regs.R31 = regs.R3;
		/* 820FA308h case    4:*/		return 0x820FA30C;
		  /* 820FA30Ch */ case    5:  		/* bl -90060 */
		/* 820FA30Ch case    5:*/		regs.LR = 0x820FA310; return 0x820E4340;
		/* 820FA30Ch case    5:*/		return 0x820FA310;
		  /* 820FA310h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820FA310h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FA310h case    6:*/		return 0x820FA314;
		  /* 820FA314h */ case    7:  		/* bc 12, CR0_LT, 12 */
		/* 820FA314h case    7:*/		if ( regs.CR[0].lt ) { return 0x820FA320;  }
		/* 820FA314h case    7:*/		return 0x820FA318;
		  /* 820FA318h */ case    8:  		/* mr R3, R31 */
		/* 820FA318h case    8:*/		regs.R3 = regs.R31;
		/* 820FA318h case    8:*/		return 0x820FA31C;
		  /* 820FA31Ch */ case    9:  		/* bl -1676 */
		/* 820FA31Ch case    9:*/		regs.LR = 0x820FA320; return 0x820F9C90;
		/* 820FA31Ch case    9:*/		return 0x820FA320;
	}
	return 0x820FA320;
} // Block from 820FA2F8h-820FA320h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FA320h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA320);
		  /* 820FA320h */ case    0:  		/* addi R1, R1, 96 */
		/* 820FA320h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820FA320h case    0:*/		return 0x820FA324;
		  /* 820FA324h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820FA324h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FA324h case    1:*/		return 0x820FA328;
		  /* 820FA328h */ case    2:  		/* mtspr LR, R12 */
		/* 820FA328h case    2:*/		regs.LR = regs.R12;
		/* 820FA328h case    2:*/		return 0x820FA32C;
		  /* 820FA32Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820FA32Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FA32Ch case    3:*/		return 0x820FA330;
		  /* 820FA330h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820FA330h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FA330h case    4:*/		return 0x820FA334;
	}
	return 0x820FA334;
} // Block from 820FA320h-820FA334h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FA334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA334);
		  /* 820FA334h */ case    0:  		/* nop */
		/* 820FA334h case    0:*/		cpu::op::nop();
		/* 820FA334h case    0:*/		return 0x820FA338;
	}
	return 0x820FA338;
} // Block from 820FA334h-820FA338h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FA338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA338);
		  /* 820FA338h */ case    0:  		/* mfspr R12, LR */
		/* 820FA338h case    0:*/		regs.R12 = regs.LR;
		/* 820FA338h case    0:*/		return 0x820FA33C;
		  /* 820FA33Ch */ case    1:  		/* bl -430340 */
		/* 820FA33Ch case    1:*/		regs.LR = 0x820FA340; return 0x82091238;
		/* 820FA33Ch case    1:*/		return 0x820FA340;
		  /* 820FA340h */ case    2:  		/* stfd FR31, <#[R1 - 112]> */
		/* 820FA340h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF90) );
		/* 820FA340h case    2:*/		return 0x820FA344;
		  /* 820FA344h */ case    3:  		/* stwu R1, <#[R1 - 208]> */
		/* 820FA344h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 820FA344h case    3:*/		return 0x820FA348;
		  /* 820FA348h */ case    4:  		/* lwz R11, <#[R3 + 12]> */
		/* 820FA348h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820FA348h case    4:*/		return 0x820FA34C;
		  /* 820FA34Ch */ case    5:  		/* li R23, -1 */
		/* 820FA34Ch case    5:*/		cpu::op::li<0>(regs,&regs.R23,0xFFFFFFFF);
		/* 820FA34Ch case    5:*/		return 0x820FA350;
		  /* 820FA350h */ case    6:  		/* mr R31, R3 */
		/* 820FA350h case    6:*/		regs.R31 = regs.R3;
		/* 820FA350h case    6:*/		return 0x820FA354;
		  /* 820FA354h */ case    7:  		/* li R27, 0 */
		/* 820FA354h case    7:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820FA354h case    7:*/		return 0x820FA358;
		  /* 820FA358h */ case    8:  		/* mr R28, R23 */
		/* 820FA358h case    8:*/		regs.R28 = regs.R23;
		/* 820FA358h case    8:*/		return 0x820FA35C;
		  /* 820FA35Ch */ case    9:  		/* mr R29, R23 */
		/* 820FA35Ch case    9:*/		regs.R29 = regs.R23;
		/* 820FA35Ch case    9:*/		return 0x820FA360;
		  /* 820FA360h */ case   10:  		/* li R22, 0 */
		/* 820FA360h case   10:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 820FA360h case   10:*/		return 0x820FA364;
		  /* 820FA364h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 820FA364h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FA364h case   11:*/		return 0x820FA368;
		  /* 820FA368h */ case   12:  		/* bc 4, CR6_GT, 704 */
		/* 820FA368h case   12:*/		if ( !regs.CR[6].gt ) { return 0x820FA628;  }
		/* 820FA368h case   12:*/		return 0x820FA36C;
		  /* 820FA36Ch */ case   13:  		/* lis R11, -32256 */
		/* 820FA36Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820FA36Ch case   13:*/		return 0x820FA370;
		  /* 820FA370h */ case   14:  		/* li R20, 0 */
		/* 820FA370h case   14:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 820FA370h case   14:*/		return 0x820FA374;
		  /* 820FA374h */ case   15:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 820FA374h case   15:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 820FA374h case   15:*/		return 0x820FA378;
		  /* 820FA378h */ case   16:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FA378h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FA378h case   16:*/		return 0x820FA37C;
		  /* 820FA37Ch */ case   17:  		/* stw R22, <#[R31 + 256]> */
		/* 820FA37Ch case   17:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000100) );
		/* 820FA37Ch case   17:*/		return 0x820FA380;
	}
	return 0x820FA380;
} // Block from 820FA338h-820FA380h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820FA380h
// Function '?FindInput@C30Program@D3DXShader@@MAAJPAVCArgument@2@AAK1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA380);
		  /* 820FA380h */ case    0:  		/* lwzx R11, <#[R11 + R20]> */
		/* 820FA380h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R20 + 0x00000000) );
		/* 820FA380h case    0:*/		return 0x820FA384;
		  /* 820FA384h */ case    1:  		/* stw R11, <#[R31 + 260]> */
		/* 820FA384h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820FA384h case    1:*/		return 0x820FA388;
		  /* 820FA388h */ case    2:  		/* lwz R10, <#[R11]> */
		/* 820FA388h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820FA388h case    2:*/		return 0x820FA38C;
		  /* 820FA38Ch */ case    3:  		/* rlwinm. R10, R10, 0, 0, 11 */
		/* 820FA38Ch case    3:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R10,regs.R10);
		/* 820FA38Ch case    3:*/		return 0x820FA390;
		  /* 820FA390h */ case    4:  		/* bc 12, CR0_EQ, 404 */
		/* 820FA390h case    4:*/		if ( regs.CR[0].eq ) { return 0x820FA524;  }
		/* 820FA390h case    4:*/		return 0x820FA394;
		  /* 820FA394h */ case    5:  		/* lwz R10, <#[R11]> */
		/* 820FA394h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820FA394h case    5:*/		return 0x820FA398;
		  /* 820FA398h */ case    6:  		/* li R24, 0 */
		/* 820FA398h case    6:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 820FA398h case    6:*/		return 0x820FA39C;
		  /* 820FA39Ch */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 820FA39Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820FA39Ch case    7:*/		return 0x820FA3A0;
		  /* 820FA3A0h */ case    8:  		/* rlwinm R10, R10, 0, 12, 31 */
		/* 820FA3A0h case    8:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R10,regs.R10);
		/* 820FA3A0h case    8:*/		return 0x820FA3A4;
		  /* 820FA3A4h */ case    9:  		/* divwu. R21, R11, R10 */
		/* 820FA3A4h case    9:*/		cpu::op::divwu<1>(regs,&regs.R21,regs.R11,regs.R10);
		/* 820FA3A4h case    9:*/		return 0x820FA3A8;
		  /* 820FA3A8h */ case   10:  		/* twi 6, R10, 0 */
		/* 820FA3A8h case   10:*/		cpu::op::tw<6>(regs, 0x820FA3A8, regs.R10, 0x00000000);
		/* 820FA3A8h case   10:*/		return 0x820FA3AC;
		  /* 820FA3ACh */ case   11:  		/* bc 12, CR0_EQ, 376 */
		/* 820FA3ACh case   11:*/		if ( regs.CR[0].eq ) { return 0x820FA524;  }
		/* 820FA3ACh case   11:*/		return 0x820FA3B0;
		  /* 820FA3B0h */ case   12:  		/* addi R5, R1, 80 */
		/* 820FA3B0h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820FA3B0h case   12:*/		return 0x820FA3B4;
		  /* 820FA3B4h */ case   13:  		/* lwz R3, <#[R31 + 260]> */
		/* 820FA3B4h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000104) );
		/* 820FA3B4h case   13:*/		return 0x820FA3B8;
		  /* 820FA3B8h */ case   14:  		/* mr R4, R24 */
		/* 820FA3B8h case   14:*/		regs.R4 = regs.R24;
		/* 820FA3B8h case   14:*/		return 0x820FA3BC;
		  /* 820FA3BCh */ case   15:  		/* bl 7004 */
		/* 820FA3BCh case   15:*/		regs.LR = 0x820FA3C0; return 0x820FBF18;
		/* 820FA3BCh case   15:*/		return 0x820FA3C0;
		  /* 820FA3C0h */ case   16:  		/* or. R25, R3, R3 */
		/* 820FA3C0h case   16:*/		cpu::op::or<1>(regs,&regs.R25,regs.R3,regs.R3);
		/* 820FA3C0h case   16:*/		return 0x820FA3C4;
		  /* 820FA3C4h */ case   17:  		/* li R26, 0 */
		/* 820FA3C4h case   17:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820FA3C4h case   17:*/		return 0x820FA3C8;
		  /* 820FA3C8h */ case   18:  		/* bc 12, CR0_EQ, 336 */
		/* 820FA3C8h case   18:*/		if ( regs.CR[0].eq ) { return 0x820FA518;  }
		/* 820FA3C8h case   18:*/		return 0x820FA3CC;
		  /* 820FA3CCh */ case   19:  		/* li R30, 0 */
		/* 820FA3CCh case   19:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820FA3CCh case   19:*/		return 0x820FA3D0;
		  /* 820FA3D0h */ case   20:  		/* lwz R11, <#[R1 + 80]> */
		/* 820FA3D0h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820FA3D0h case   20:*/		return 0x820FA3D4;
		  /* 820FA3D4h */ case   21:  		/* lwz R10, <#[R31 + 20]> */
		/* 820FA3D4h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820FA3D4h case   21:*/		return 0x820FA3D8;
		  /* 820FA3D8h */ case   22:  		/* lwz R9, <#[R31 + 16]> */
		/* 820FA3D8h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 820FA3D8h case   22:*/		return 0x820FA3DC;
		  /* 820FA3DCh */ case   23:  		/* lwzx R11, <#[R30 + R11]> */
		/* 820FA3DCh case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820FA3DCh case   23:*/		return 0x820FA3E0;
		  /* 820FA3E0h */ case   24:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FA3E0h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FA3E0h case   24:*/		return 0x820FA3E4;
		  /* 820FA3E4h */ case   25:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820FA3E4h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FA3E4h case   25:*/		return 0x820FA3E8;
		  /* 820FA3E8h */ case   26:  		/* lwz R10, <#[R11 + 4]> */
		/* 820FA3E8h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820FA3E8h case   26:*/		return 0x820FA3EC;
		  /* 820FA3ECh */ case   27:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FA3ECh case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FA3ECh case   27:*/		return 0x820FA3F0;
		  /* 820FA3F0h */ case   28:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820FA3F0h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820FA3F0h case   28:*/		return 0x820FA3F4;
		  /* 820FA3F4h */ case   29:  		/* lwz R10, <#[R10 + 4]> */
		/* 820FA3F4h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820FA3F4h case   29:*/		return 0x820FA3F8;
		  /* 820FA3F8h */ case   30:  		/* rlwinm. R9, R10, 0, 27, 27 */
		/* 820FA3F8h case   30:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R9,regs.R10);
		/* 820FA3F8h case   30:*/		return 0x820FA3FC;
		  /* 820FA3FCh */ case   31:  		/* bc 12, CR0_EQ, 284 */
		/* 820FA3FCh case   31:*/		if ( regs.CR[0].eq ) { return 0x820FA518;  }
		/* 820FA3FCh case   31:*/		return 0x820FA400;
		  /* 820FA400h */ case   32:  		/* rlwinm. R10, R10, 0, 22, 22 */
		/* 820FA400h case   32:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R10,regs.R10);
		/* 820FA400h case   32:*/		return 0x820FA404;
		  /* 820FA404h */ case   33:  		/* bc 4, CR0_EQ, 276 */
		/* 820FA404h case   33:*/		if ( !regs.CR[0].eq ) { return 0x820FA518;  }
		/* 820FA404h case   33:*/		return 0x820FA408;
		  /* 820FA408h */ case   34:  		/* lwz R10, <#[R31]> */
		/* 820FA408h case   34:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820FA408h case   34:*/		return 0x820FA40C;
		  /* 820FA40Ch */ case   35:  		/* mr R3, R31 */
		/* 820FA40Ch case   35:*/		regs.R3 = regs.R31;
		/* 820FA40Ch case   35:*/		return 0x820FA410;
		  /* 820FA410h */ case   36:  		/* lwz R4, <#[R11 + 108]> */
		/* 820FA410h case   36:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000006C) );
		/* 820FA410h case   36:*/		return 0x820FA414;
		  /* 820FA414h */ case   37:  		/* lwz R11, <#[R10 + 112]> */
		/* 820FA414h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000070) );
		/* 820FA414h case   37:*/		return 0x820FA418;
		  /* 820FA418h */ case   38:  		/* mtspr CTR, R11 */
		/* 820FA418h case   38:*/		regs.CTR = regs.R11;
		/* 820FA418h case   38:*/		return 0x820FA41C;
		  /* 820FA41Ch */ case   39:  		/* bcctrl 20, CR0_LT */
		/* 820FA41Ch case   39:*/		if ( 1 ) { regs.LR = 0x820FA420; return (uint32)regs.CTR; }
		/* 820FA41Ch case   39:*/		return 0x820FA420;
		  /* 820FA420h */ case   40:  		/* cmplwi CR6, R3, 17 */
		/* 820FA420h case   40:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000011);
		/* 820FA420h case   40:*/		return 0x820FA424;
		  /* 820FA424h */ case   41:  		/* bc 4, CR6_EQ, 244 */
		/* 820FA424h case   41:*/		if ( !regs.CR[6].eq ) { return 0x820FA518;  }
		/* 820FA424h case   41:*/		return 0x820FA428;
	}
	return 0x820FA428;
} // Block from 820FA380h-820FA428h (42 instructions)

//////////////////////////////////////////////////////
// Block at 820FA428h
// Function '?GenerateCode@C30Program@D3DXShader@@UAAJPAPAUID3DXBuffer@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA428);
		  /* 820FA428h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 820FA428h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820FA428h case    0:*/		return 0x820FA42C;
		  /* 820FA42Ch */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 820FA42Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820FA448;  }
		/* 820FA42Ch case    1:*/		return 0x820FA430;
	}
	return 0x820FA430;
} // Block from 820FA428h-820FA430h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FA430h
// Function '?ProcessVFaceVPos@C30Program@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA430);
		  /* 820FA430h */ case    0:  		/* lwz R11, <#[R31 + 260]> */
		/* 820FA430h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820FA430h case    0:*/		return 0x820FA434;
		  /* 820FA434h */ case    1:  		/* lis R10, 12288 */
		/* 820FA434h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x3000);
		/* 820FA434h case    1:*/		return 0x820FA438;
		  /* 820FA438h */ case    2:  		/* lwz R11, <#[R11]> */
		/* 820FA438h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FA438h case    2:*/		return 0x820FA43C;
		  /* 820FA43Ch */ case    3:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FA43Ch case    3:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FA43Ch case    3:*/		return 0x820FA440;
		  /* 820FA440h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FA440h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FA440h case    4:*/		return 0x820FA444;
		  /* 820FA444h */ case    5:  		/* bc 12, CR6_EQ, 212 */
		/* 820FA444h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FA518;  }
		/* 820FA444h case    5:*/		return 0x820FA448;
	}
	return 0x820FA448;
} // Block from 820FA430h-820FA448h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FA448h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA448);
		  /* 820FA448h */ case    0:  		/* cmpwi CR6, R29, -1 */
		/* 820FA448h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFF);
		/* 820FA448h case    0:*/		return 0x820FA44C;
		  /* 820FA44Ch */ case    1:  		/* bc 4, CR6_EQ, 180 */
		/* 820FA44Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820FA500;  }
		/* 820FA44Ch case    1:*/		return 0x820FA450;
		  /* 820FA450h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 820FA450h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820FA450h case    2:*/		return 0x820FA454;
		  /* 820FA454h */ case    3:  		/* li R5, 0 */
		/* 820FA454h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820FA454h case    3:*/		return 0x820FA458;
		  /* 820FA458h */ case    4:  		/* li R6, 0 */
		/* 820FA458h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820FA458h case    4:*/		return 0x820FA45C;
		  /* 820FA45Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820FA45Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FA45Ch case    5:*/		return 0x820FA460;
		  /* 820FA460h */ case    6:  		/* bc 4, CR6_GT, 68 */
		/* 820FA460h case    6:*/		if ( !regs.CR[6].gt ) { return 0x820FA4A4;  }
		/* 820FA460h case    6:*/		return 0x820FA464;
		  /* 820FA464h */ case    7:  		/* lwz R9, <#[R31 + 136]> */
		/* 820FA464h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000088) );
		/* 820FA464h case    7:*/		return 0x820FA468;
		  /* 820FA468h */ case    8:  		/* li R11, 0 */
		/* 820FA468h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820FA468h case    8:*/		return 0x820FA46C;
		  /* 820FA46Ch */ case    9:  		/* lwz R8, <#[R31 + 20]> */
		/* 820FA46Ch case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000014) );
		/* 820FA46Ch case    9:*/		return 0x820FA470;
		  /* 820FA470h */ case   10:  		/* lwz R7, <#[R31 + 8]> */
		/* 820FA470h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000008) );
		/* 820FA470h case   10:*/		return 0x820FA474;
		  /* 820FA474h */ case   11:  		/* lwzx R10, <#[R11 + R8]> */
		/* 820FA474h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820FA474h case   11:*/		return 0x820FA478;
		  /* 820FA478h */ case   12:  		/* lwz R4, <#[R10 + 4]> */
		/* 820FA478h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000004) );
		/* 820FA478h case   12:*/		return 0x820FA47C;
		  /* 820FA47Ch */ case   13:  		/* cmplw CR6, R9, R4 */
		/* 820FA47Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R4);
		/* 820FA47Ch case   13:*/		return 0x820FA480;
		  /* 820FA480h */ case   14:  		/* bc 4, CR6_EQ, 20 */
		/* 820FA480h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820FA494;  }
		/* 820FA480h case   14:*/		return 0x820FA484;
		  /* 820FA484h */ case   15:  		/* lwz R10, <#[R10 + 12]> */
		/* 820FA484h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 820FA484h case   15:*/		return 0x820FA488;
		  /* 820FA488h */ case   16:  		/* cmplw CR6, R10, R5 */
		/* 820FA488h case   16:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R5);
		/* 820FA488h case   16:*/		return 0x820FA48C;
		  /* 820FA48Ch */ case   17:  		/* bc 12, CR6_LT, 8 */
		/* 820FA48Ch case   17:*/		if ( regs.CR[6].lt ) { return 0x820FA494;  }
		/* 820FA48Ch case   17:*/		return 0x820FA490;
		  /* 820FA490h */ case   18:  		/* addi R5, R10, 1 */
		/* 820FA490h case   18:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x1);
		/* 820FA490h case   18:*/		return 0x820FA494;
	}
	return 0x820FA494;
} // Block from 820FA448h-820FA494h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820FA494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA494);
		  /* 820FA494h */ case    0:  		/* addi R6, R6, 1 */
		/* 820FA494h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820FA494h case    0:*/		return 0x820FA498;
		  /* 820FA498h */ case    1:  		/* addi R11, R11, 4 */
		/* 820FA498h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820FA498h case    1:*/		return 0x820FA49C;
		  /* 820FA49Ch */ case    2:  		/* cmplw CR6, R6, R7 */
		/* 820FA49Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R7);
		/* 820FA49Ch case    2:*/		return 0x820FA4A0;
		  /* 820FA4A0h */ case    3:  		/* bc 12, CR6_LT, -44 */
		/* 820FA4A0h case    3:*/		if ( regs.CR[6].lt ) { return 0x820FA474;  }
		/* 820FA4A0h case    3:*/		return 0x820FA4A4;
	}
	return 0x820FA4A4;
} // Block from 820FA494h-820FA4A4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FA4A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA4A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA4A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA4A4);
		  /* 820FA4A4h */ case    0:  		/* li R6, 0 */
		/* 820FA4A4h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820FA4A4h case    0:*/		return 0x820FA4A8;
		  /* 820FA4A8h */ case    1:  		/* lwz R4, <#[R31 + 136]> */
		/* 820FA4A8h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000088) );
		/* 820FA4A8h case    1:*/		return 0x820FA4AC;
		  /* 820FA4ACh */ case    2:  		/* mr R3, R31 */
		/* 820FA4ACh case    2:*/		regs.R3 = regs.R31;
		/* 820FA4ACh case    2:*/		return 0x820FA4B0;
		  /* 820FA4B0h */ case    3:  		/* fmr FR1, FR31 */
		/* 820FA4B0h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820FA4B0h case    3:*/		return 0x820FA4B4;
		  /* 820FA4B4h */ case    4:  		/* bl 11636 */
		/* 820FA4B4h case    4:*/		regs.LR = 0x820FA4B8; return 0x820FD228;
		/* 820FA4B4h case    4:*/		return 0x820FA4B8;
		  /* 820FA4B8h */ case    5:  		/* mr R29, R3 */
		/* 820FA4B8h case    5:*/		regs.R29 = regs.R3;
		/* 820FA4B8h case    5:*/		return 0x820FA4BC;
		  /* 820FA4BCh */ case    6:  		/* cmpwi CR6, R3, -1 */
		/* 820FA4BCh case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820FA4BCh case    6:*/		return 0x820FA4C0;
		  /* 820FA4C0h */ case    7:  		/* bc 12, CR6_EQ, 376 */
		/* 820FA4C0h case    7:*/		if ( regs.CR[6].eq ) { return 0x820FA638;  }
		/* 820FA4C0h case    7:*/		return 0x820FA4C4;
		  /* 820FA4C4h */ case    8:  		/* lwz R11, <#[R1 + 80]> */
		/* 820FA4C4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820FA4C4h case    8:*/		return 0x820FA4C8;
		  /* 820FA4C8h */ case    9:  		/* rlwinm R28, R3, 2, 0, 29 */
		/* 820FA4C8h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R3);
		/* 820FA4C8h case    9:*/		return 0x820FA4CC;
		  /* 820FA4CCh */ case   10:  		/* lwz R10, <#[R31 + 20]> */
		/* 820FA4CCh case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820FA4CCh case   10:*/		return 0x820FA4D0;
		  /* 820FA4D0h */ case   11:  		/* lwzx R11, <#[R30 + R11]> */
		/* 820FA4D0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820FA4D0h case   11:*/		return 0x820FA4D4;
		  /* 820FA4D4h */ case   12:  		/* lwzx R3, <#[R28 + R10]> */
		/* 820FA4D4h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + regs.R10 + 0x00000000) );
		/* 820FA4D4h case   12:*/		return 0x820FA4D8;
		  /* 820FA4D8h */ case   13:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FA4D8h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FA4D8h case   13:*/		return 0x820FA4DC;
		  /* 820FA4DCh */ case   14:  		/* lwzx R4, <#[R11 + R10]> */
		/* 820FA4DCh case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FA4DCh case   14:*/		return 0x820FA4E0;
		  /* 820FA4E0h */ case   15:  		/* bl 10176 */
		/* 820FA4E0h case   15:*/		regs.LR = 0x820FA4E4; return 0x820FCCA0;
		/* 820FA4E0h case   15:*/		return 0x820FA4E4;
		  /* 820FA4E4h */ case   16:  		/* lwz R11, <#[R31 + 20]> */
		/* 820FA4E4h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820FA4E4h case   16:*/		return 0x820FA4E8;
		  /* 820FA4E8h */ case   17:  		/* lwzx R11, <#[R28 + R11]> */
		/* 820FA4E8h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820FA4E8h case   17:*/		return 0x820FA4EC;
		  /* 820FA4ECh */ case   18:  		/* stw R23, <#[R11 + 108]> */
		/* 820FA4ECh case   18:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x0000006C) );
		/* 820FA4ECh case   18:*/		return 0x820FA4F0;
		  /* 820FA4F0h */ case   19:  		/* lwz R11, <#[R1 + 80]> */
		/* 820FA4F0h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820FA4F0h case   19:*/		return 0x820FA4F4;
		  /* 820FA4F4h */ case   20:  		/* lwz R27, <#[R31 + 260]> */
		/* 820FA4F4h case   20:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R31 + 0x00000104) );
		/* 820FA4F4h case   20:*/		return 0x820FA4F8;
		  /* 820FA4F8h */ case   21:  		/* lwzx R28, <#[R30 + R11]> */
		/* 820FA4F8h case   21:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820FA4F8h case   21:*/		return 0x820FA4FC;
		  /* 820FA4FCh */ case   22:  		/* b 8 */
		/* 820FA4FCh case   22:*/		return 0x820FA504;
		/* 820FA4FCh case   22:*/		return 0x820FA500;
	}
	return 0x820FA500;
} // Block from 820FA4A4h-820FA500h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820FA500h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA500);
		  /* 820FA500h */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 820FA500h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820FA500h case    0:*/		return 0x820FA504;
	}
	return 0x820FA504;
} // Block from 820FA500h-820FA504h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FA504h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA504( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA504) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA504);
		  /* 820FA504h */ case    0:  		/* addi R26, R26, 1 */
		/* 820FA504h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820FA504h case    0:*/		return 0x820FA508;
		  /* 820FA508h */ case    1:  		/* stwx R29, <#[R30 + R11]> */
		/* 820FA508h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820FA508h case    1:*/		return 0x820FA50C;
		  /* 820FA50Ch */ case    2:  		/* addi R30, R30, 4 */
		/* 820FA50Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820FA50Ch case    2:*/		return 0x820FA510;
		  /* 820FA510h */ case    3:  		/* cmplw CR6, R26, R25 */
		/* 820FA510h case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R25);
		/* 820FA510h case    3:*/		return 0x820FA514;
		  /* 820FA514h */ case    4:  		/* bc 12, CR6_LT, -324 */
		/* 820FA514h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FA3D0;  }
		/* 820FA514h case    4:*/		return 0x820FA518;
	}
	return 0x820FA518;
} // Block from 820FA504h-820FA518h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FA518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA518);
		  /* 820FA518h */ case    0:  		/* addi R24, R24, 1 */
		/* 820FA518h case    0:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 820FA518h case    0:*/		return 0x820FA51C;
		  /* 820FA51Ch */ case    1:  		/* cmplw CR6, R24, R21 */
		/* 820FA51Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R21);
		/* 820FA51Ch case    1:*/		return 0x820FA520;
		  /* 820FA520h */ case    2:  		/* bc 12, CR6_LT, -368 */
		/* 820FA520h case    2:*/		if ( regs.CR[6].lt ) { return 0x820FA3B0;  }
		/* 820FA520h case    2:*/		return 0x820FA524;
	}
	return 0x820FA524;
} // Block from 820FA518h-820FA524h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FA524h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA524( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA524) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA524);
		  /* 820FA524h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FA524h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FA524h case    0:*/		return 0x820FA528;
		  /* 820FA528h */ case    1:  		/* addi R22, R22, 1 */
		/* 820FA528h case    1:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 820FA528h case    1:*/		return 0x820FA52C;
		  /* 820FA52Ch */ case    2:  		/* addi R20, R20, 4 */
		/* 820FA52Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0x4);
		/* 820FA52Ch case    2:*/		return 0x820FA530;
		  /* 820FA530h */ case    3:  		/* cmplw CR6, R22, R11 */
		/* 820FA530h case    3:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 820FA530h case    3:*/		return 0x820FA534;
		  /* 820FA534h */ case    4:  		/* bc 12, CR6_LT, -444 */
		/* 820FA534h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FA378;  }
		/* 820FA534h case    4:*/		return 0x820FA538;
		  /* 820FA538h */ case    5:  		/* cmpwi CR6, R29, -1 */
		/* 820FA538h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFF);
		/* 820FA538h case    5:*/		return 0x820FA53C;
		  /* 820FA53Ch */ case    6:  		/* bc 12, CR6_EQ, 236 */
		/* 820FA53Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x820FA628;  }
		/* 820FA53Ch case    6:*/		return 0x820FA540;
		  /* 820FA540h */ case    7:  		/* lis R4, 12288 */
		/* 820FA540h case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0x3000);
		/* 820FA540h case    7:*/		return 0x820FA544;
		  /* 820FA544h */ case    8:  		/* li R6, 1 */
		/* 820FA544h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820FA544h case    8:*/		return 0x820FA548;
		  /* 820FA548h */ case    9:  		/* li R5, 3 */
		/* 820FA548h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 820FA548h case    9:*/		return 0x820FA54C;
		  /* 820FA54Ch */ case   10:  		/* ori R4, R4, 1 */
		/* 820FA54Ch case   10:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820FA54Ch case   10:*/		return 0x820FA550;
		  /* 820FA550h */ case   11:  		/* mr R3, R31 */
		/* 820FA550h case   11:*/		regs.R3 = regs.R31;
		/* 820FA550h case   11:*/		return 0x820FA554;
		  /* 820FA554h */ case   12:  		/* bl 11636 */
		/* 820FA554h case   12:*/		regs.LR = 0x820FA558; return 0x820FD2C8;
		/* 820FA554h case   12:*/		return 0x820FA558;
		  /* 820FA558h */ case   13:  		/* cmpwi CR6, R3, -1 */
		/* 820FA558h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820FA558h case   13:*/		return 0x820FA55C;
		  /* 820FA55Ch */ case   14:  		/* bc 12, CR6_EQ, 220 */
		/* 820FA55Ch case   14:*/		if ( regs.CR[6].eq ) { return 0x820FA638;  }
		/* 820FA55Ch case   14:*/		return 0x820FA560;
		  /* 820FA560h */ case   15:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FA560h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FA560h case   15:*/		return 0x820FA564;
		  /* 820FA564h */ case   16:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820FA564h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820FA564h case   16:*/		return 0x820FA568;
		  /* 820FA568h */ case   17:  		/* mr R4, R27 */
		/* 820FA568h case   17:*/		regs.R4 = regs.R27;
		/* 820FA568h case   17:*/		return 0x820FA56C;
		  /* 820FA56Ch */ case   18:  		/* lwzx R30, <#[R10 + R11]> */
		/* 820FA56Ch case   18:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820FA56Ch case   18:*/		return 0x820FA570;
		  /* 820FA570h */ case   19:  		/* mr R3, R30 */
		/* 820FA570h case   19:*/		regs.R3 = regs.R30;
		/* 820FA570h case   19:*/		return 0x820FA574;
		  /* 820FA574h */ case   20:  		/* bl 6524 */
		/* 820FA574h case   20:*/		regs.LR = 0x820FA578; return 0x820FBEF0;
		/* 820FA574h case   20:*/		return 0x820FA578;
		  /* 820FA578h */ case   21:  		/* lis R11, -32256 */
		/* 820FA578h case   21:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820FA578h case   21:*/		return 0x820FA57C;
		  /* 820FA57Ch */ case   22:  		/* li R6, 0 */
		/* 820FA57Ch case   22:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820FA57Ch case   22:*/		return 0x820FA580;
		  /* 820FA580h */ case   23:  		/* li R5, 0 */
		/* 820FA580h case   23:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820FA580h case   23:*/		return 0x820FA584;
		  /* 820FA584h */ case   24:  		/* mr R3, R31 */
		/* 820FA584h case   24:*/		regs.R3 = regs.R31;
		/* 820FA584h case   24:*/		return 0x820FA588;
		  /* 820FA588h */ case   25:  		/* lfd FR1, <#[R11 + 1848]> */
		/* 820FA588h case   25:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000738) );
		/* 820FA588h case   25:*/		return 0x820FA58C;
		  /* 820FA58Ch */ case   26:  		/* lwz R11, <#[R30 + 16]> */
		/* 820FA58Ch case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820FA58Ch case   26:*/		return 0x820FA590;
		  /* 820FA590h */ case   27:  		/* stw R29, <#[R11]> */
		/* 820FA590h case   27:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 820FA590h case   27:*/		return 0x820FA594;
		  /* 820FA594h */ case   28:  		/* lwz R11, <#[R30 + 8]> */
		/* 820FA594h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820FA594h case   28:*/		return 0x820FA598;
		  /* 820FA598h */ case   29:  		/* stw R28, <#[R11]> */
		/* 820FA598h case   29:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 820FA598h case   29:*/		return 0x820FA59C;
		  /* 820FA59Ch */ case   30:  		/* lwz R4, <#[R31 + 120]> */
		/* 820FA59Ch case   30:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000078) );
		/* 820FA59Ch case   30:*/		return 0x820FA5A0;
		  /* 820FA5A0h */ case   31:  		/* bl 11400 */
		/* 820FA5A0h case   31:*/		regs.LR = 0x820FA5A4; return 0x820FD228;
		/* 820FA5A0h case   31:*/		return 0x820FA5A4;
		  /* 820FA5A4h */ case   32:  		/* lwz R11, <#[R30 + 8]> */
		/* 820FA5A4h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820FA5A4h case   32:*/		return 0x820FA5A8;
		  /* 820FA5A8h */ case   33:  		/* li R6, 0 */
		/* 820FA5A8h case   33:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820FA5A8h case   33:*/		return 0x820FA5AC;
		  /* 820FA5ACh */ case   34:  		/* li R5, 0 */
		/* 820FA5ACh case   34:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820FA5ACh case   34:*/		return 0x820FA5B0;
		  /* 820FA5B0h */ case   35:  		/* stw R3, <#[R11 + 4]> */
		/* 820FA5B0h case   35:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000004) );
		/* 820FA5B0h case   35:*/		return 0x820FA5B4;
		  /* 820FA5B4h */ case   36:  		/* lis R11, -32255 */
		/* 820FA5B4h case   36:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820FA5B4h case   36:*/		return 0x820FA5B8;
		  /* 820FA5B8h */ case   37:  		/* mr R3, R31 */
		/* 820FA5B8h case   37:*/		regs.R3 = regs.R31;
		/* 820FA5B8h case   37:*/		return 0x820FA5BC;
		  /* 820FA5BCh */ case   38:  		/* lwz R4, <#[R31 + 120]> */
		/* 820FA5BCh case   38:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000078) );
		/* 820FA5BCh case   38:*/		return 0x820FA5C0;
	}
	return 0x820FA5C0;
} // Block from 820FA524h-820FA5C0h (39 instructions)

//////////////////////////////////////////////////////
// Block at 820FA5C0h
// Function '?PatternMatch@C30Program@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA5C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA5C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA5C0);
		  /* 820FA5C0h */ case    0:  		/* lfd FR1, <#[R11 - 24488]> */
		/* 820FA5C0h case    0:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0xFFFFA058) );
		/* 820FA5C0h case    0:*/		return 0x820FA5C4;
		  /* 820FA5C4h */ case    1:  		/* bl 11364 */
		/* 820FA5C4h case    1:*/		regs.LR = 0x820FA5C8; return 0x820FD228;
		/* 820FA5C4h case    1:*/		return 0x820FA5C8;
		  /* 820FA5C8h */ case    2:  		/* lwz R11, <#[R30 + 8]> */
		/* 820FA5C8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820FA5C8h case    2:*/		return 0x820FA5CC;
		  /* 820FA5CCh */ case    3:  		/* stw R3, <#[R11 + 8]> */
		/* 820FA5CCh case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000008) );
		/* 820FA5CCh case    3:*/		return 0x820FA5D0;
		  /* 820FA5D0h */ case    4:  		/* lwz R11, <#[R30 + 8]> */
		/* 820FA5D0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820FA5D0h case    4:*/		return 0x820FA5D4;
		  /* 820FA5D4h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820FA5D4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820FA5D4h case    5:*/		return 0x820FA5D8;
		  /* 820FA5D8h */ case    6:  		/* cmpwi CR6, R11, -1 */
		/* 820FA5D8h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FA5D8h case    6:*/		return 0x820FA5DC;
		  /* 820FA5DCh */ case    7:  		/* bc 12, CR6_EQ, 92 */
		/* 820FA5DCh case    7:*/		if ( regs.CR[6].eq ) { return 0x820FA638;  }
		/* 820FA5DCh case    7:*/		return 0x820FA5E0;
		  /* 820FA5E0h */ case    8:  		/* lwz R11, <#[R30 + 8]> */
		/* 820FA5E0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820FA5E0h case    8:*/		return 0x820FA5E4;
		  /* 820FA5E4h */ case    9:  		/* lwz R11, <#[R11 + 8]> */
		/* 820FA5E4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820FA5E4h case    9:*/		return 0x820FA5E8;
		  /* 820FA5E8h */ case   10:  		/* cmpwi CR6, R11, -1 */
		/* 820FA5E8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FA5E8h case   10:*/		return 0x820FA5EC;
		  /* 820FA5ECh */ case   11:  		/* bc 12, CR6_EQ, 76 */
		/* 820FA5ECh case   11:*/		if ( regs.CR[6].eq ) { return 0x820FA638;  }
		/* 820FA5ECh case   11:*/		return 0x820FA5F0;
		  /* 820FA5F0h */ case   12:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FA5F0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FA5F0h case   12:*/		return 0x820FA5F4;
		  /* 820FA5F4h */ case   13:  		/* cmplwi CR6, R11, 1 */
		/* 820FA5F4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820FA5F4h case   13:*/		return 0x820FA5F8;
		  /* 820FA5F8h */ case   14:  		/* bc 4, CR6_GT, 40 */
		/* 820FA5F8h case   14:*/		if ( !regs.CR[6].gt ) { return 0x820FA620;  }
		/* 820FA5F8h case   14:*/		return 0x820FA5FC;
		  /* 820FA5FCh */ case   15:  		/* addi R10, R11, -1 */
		/* 820FA5FCh case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 820FA5FCh case   15:*/		return 0x820FA600;
		  /* 820FA600h */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FA600h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FA600h case   16:*/		return 0x820FA604;
		  /* 820FA604h */ case   17:  		/* mtspr CTR, R10 */
		/* 820FA604h case   17:*/		regs.CTR = regs.R10;
		/* 820FA604h case   17:*/		return 0x820FA608;
		  /* 820FA608h */ case   18:  		/* lwz R10, <#[R31 + 24]> */
		/* 820FA608h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820FA608h case   18:*/		return 0x820FA60C;
		  /* 820FA60Ch */ case   19:  		/* addi R11, R11, -4 */
		/* 820FA60Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 820FA60Ch case   19:*/		return 0x820FA610;
		  /* 820FA610h */ case   20:  		/* add R10, R10, R11 */
		/* 820FA610h case   20:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820FA610h case   20:*/		return 0x820FA614;
		  /* 820FA614h */ case   21:  		/* lwz R9, <#[R10 - 4]> */
		/* 820FA614h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 820FA614h case   21:*/		return 0x820FA618;
		  /* 820FA618h */ case   22:  		/* stw R9, <#[R10]> */
		/* 820FA618h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820FA618h case   22:*/		return 0x820FA61C;
		  /* 820FA61Ch */ case   23:  		/* bc 16, CR0_LT, -20 */
		/* 820FA61Ch case   23:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820FA608;  }
		/* 820FA61Ch case   23:*/		return 0x820FA620;
	}
	return 0x820FA620;
} // Block from 820FA5C0h-820FA620h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820FA620h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA620( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA620) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA620);
		  /* 820FA620h */ case    0:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FA620h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FA620h case    0:*/		return 0x820FA624;
		  /* 820FA624h */ case    1:  		/* stw R30, <#[R11]> */
		/* 820FA624h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 820FA624h case    1:*/		return 0x820FA628;
	}
	return 0x820FA628;
} // Block from 820FA620h-820FA628h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FA628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA628);
		  /* 820FA628h */ case    0:  		/* li R3, 0 */
		/* 820FA628h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FA628h case    0:*/		return 0x820FA62C;
		  /* 820FA62Ch */ case    1:  		/* addi R1, R1, 208 */
		/* 820FA62Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 820FA62Ch case    1:*/		return 0x820FA630;
		  /* 820FA630h */ case    2:  		/* lfd FR31, <#[R1 - 112]> */
		/* 820FA630h case    2:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF90) );
		/* 820FA630h case    2:*/		return 0x820FA634;
		  /* 820FA634h */ case    3:  		/* b -431020 */
		/* 820FA634h case    3:*/		return 0x82091288;
		/* 820FA634h case    3:*/		return 0x820FA638;
	}
	return 0x820FA638;
} // Block from 820FA628h-820FA638h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FA638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA638);
		  /* 820FA638h */ case    0:  		/* lis R3, -32761 */
		/* 820FA638h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820FA638h case    0:*/		return 0x820FA63C;
		  /* 820FA63Ch */ case    1:  		/* ori R3, R3, 14 */
		/* 820FA63Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820FA63Ch case    1:*/		return 0x820FA640;
		  /* 820FA640h */ case    2:  		/* b -20 */
		/* 820FA640h case    2:*/		return 0x820FA62C;
		/* 820FA640h case    2:*/		return 0x820FA644;
		  /* 820FA644h */ case    3:  		/* nop */
		/* 820FA644h case    3:*/		cpu::op::nop();
		/* 820FA644h case    3:*/		return 0x820FA648;
	}
	return 0x820FA648;
} // Block from 820FA638h-820FA648h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FA648h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA648);
		  /* 820FA648h */ case    0:  		/* mfspr R12, LR */
		/* 820FA648h case    0:*/		regs.R12 = regs.LR;
		/* 820FA648h case    0:*/		return 0x820FA64C;
		  /* 820FA64Ch */ case    1:  		/* bl -431140 */
		/* 820FA64Ch case    1:*/		regs.LR = 0x820FA650; return 0x82091228;
		/* 820FA64Ch case    1:*/		return 0x820FA650;
		  /* 820FA650h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 820FA650h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 820FA650h case    2:*/		return 0x820FA654;
		  /* 820FA654h */ case    3:  		/* lwz R11, <#[R3 + 112]> */
		/* 820FA654h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000070) );
		/* 820FA654h case    3:*/		return 0x820FA658;
		  /* 820FA658h */ case    4:  		/* mr R31, R3 */
		/* 820FA658h case    4:*/		regs.R31 = regs.R3;
		/* 820FA658h case    4:*/		return 0x820FA65C;
		  /* 820FA65Ch */ case    5:  		/* li R30, 0 */
		/* 820FA65Ch case    5:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820FA65Ch case    5:*/		return 0x820FA660;
		  /* 820FA660h */ case    6:  		/* rlwinm. R11, R11, 0, 7, 7 */
		/* 820FA660h case    6:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R11,regs.R11);
		/* 820FA660h case    6:*/		return 0x820FA664;
		  /* 820FA664h */ case    7:  		/* bc 4, CR0_EQ, 16 */
		/* 820FA664h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820FA674;  }
		/* 820FA664h case    7:*/		return 0x820FA668;
		  /* 820FA668h */ case    8:  		/* bl -816 */
		/* 820FA668h case    8:*/		regs.LR = 0x820FA66C; return 0x820FA338;
		/* 820FA668h case    8:*/		return 0x820FA66C;
		  /* 820FA66Ch */ case    9:  		/* or. R30, R3, R3 */
		/* 820FA66Ch case    9:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FA66Ch case    9:*/		return 0x820FA670;
		  /* 820FA670h */ case   10:  		/* bc 12, CR0_LT, 2520 */
		/* 820FA670h case   10:*/		if ( regs.CR[0].lt ) { return 0x820FB048;  }
		/* 820FA670h case   10:*/		return 0x820FA674;
	}
	return 0x820FA674;
} // Block from 820FA648h-820FA674h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FA674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA674);
		  /* 820FA674h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FA674h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FA674h case    0:*/		return 0x820FA678;
		  /* 820FA678h */ case    1:  		/* lis R19, 4416 */
		/* 820FA678h case    1:*/		cpu::op::lis<0>(regs,&regs.R19,0x1140);
		/* 820FA678h case    1:*/		return 0x820FA67C;
		  /* 820FA67Ch */ case    2:  		/* li R29, 0 */
		/* 820FA67Ch case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820FA67Ch case    2:*/		return 0x820FA680;
		  /* 820FA680h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820FA680h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FA680h case    3:*/		return 0x820FA684;
		  /* 820FA684h */ case    4:  		/* bc 4, CR6_GT, 84 */
		/* 820FA684h case    4:*/		if ( !regs.CR[6].gt ) { return 0x820FA6D8;  }
		/* 820FA684h case    4:*/		return 0x820FA688;
		  /* 820FA688h */ case    5:  		/* li R28, 0 */
		/* 820FA688h case    5:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820FA688h case    5:*/		return 0x820FA68C;
		  /* 820FA68Ch */ case    6:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FA68Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FA68Ch case    6:*/		return 0x820FA690;
		  /* 820FA690h */ case    7:  		/* stw R29, <#[R31 + 256]> */
		/* 820FA690h case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000100) );
		/* 820FA690h case    7:*/		return 0x820FA694;
		  /* 820FA694h */ case    8:  		/* lwzx R11, <#[R28 + R11]> */
		/* 820FA694h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820FA694h case    8:*/		return 0x820FA698;
		  /* 820FA698h */ case    9:  		/* stw R11, <#[R31 + 260]> */
		/* 820FA698h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820FA698h case    9:*/		return 0x820FA69C;
		  /* 820FA69Ch */ case   10:  		/* lwz R11, <#[R11]> */
		/* 820FA69Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FA69Ch case   10:*/		return 0x820FA6A0;
		  /* 820FA6A0h */ case   11:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FA6A0h case   11:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FA6A0h case   11:*/		return 0x820FA6A4;
		  /* 820FA6A4h */ case   12:  		/* cmplw CR6, R11, R19 */
		/* 820FA6A4h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R19);
		/* 820FA6A4h case   12:*/		return 0x820FA6A8;
		  /* 820FA6A8h */ case   13:  		/* bc 12, CR6_EQ, 12 */
		/* 820FA6A8h case   13:*/		if ( regs.CR[6].eq ) { return 0x820FA6B4;  }
		/* 820FA6A8h case   13:*/		return 0x820FA6AC;
		  /* 820FA6ACh */ case   14:  		/* li R30, 1 */
		/* 820FA6ACh case   14:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820FA6ACh case   14:*/		return 0x820FA6B0;
		  /* 820FA6B0h */ case   15:  		/* b 20 */
		/* 820FA6B0h case   15:*/		return 0x820FA6C4;
		/* 820FA6B0h case   15:*/		return 0x820FA6B4;
	}
	return 0x820FA6B4;
} // Block from 820FA674h-820FA6B4h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820FA6B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA6B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA6B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA6B4);
		  /* 820FA6B4h */ case    0:  		/* mr R3, R31 */
		/* 820FA6B4h case    0:*/		regs.R3 = regs.R31;
		/* 820FA6B4h case    0:*/		return 0x820FA6B8;
		  /* 820FA6B8h */ case    1:  		/* bl -78120 */
		/* 820FA6B8h case    1:*/		regs.LR = 0x820FA6BC; return 0x820E7590;
		/* 820FA6B8h case    1:*/		return 0x820FA6BC;
		  /* 820FA6BCh */ case    2:  		/* or. R30, R3, R3 */
		/* 820FA6BCh case    2:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FA6BCh case    2:*/		return 0x820FA6C0;
		  /* 820FA6C0h */ case    3:  		/* bc 12, CR0_LT, 2440 */
		/* 820FA6C0h case    3:*/		if ( regs.CR[0].lt ) { return 0x820FB048;  }
		/* 820FA6C0h case    3:*/		return 0x820FA6C4;
	}
	return 0x820FA6C4;
} // Block from 820FA6B4h-820FA6C4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FA6C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA6C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA6C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA6C4);
		  /* 820FA6C4h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FA6C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FA6C4h case    0:*/		return 0x820FA6C8;
		  /* 820FA6C8h */ case    1:  		/* addi R29, R29, 1 */
		/* 820FA6C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820FA6C8h case    1:*/		return 0x820FA6CC;
		  /* 820FA6CCh */ case    2:  		/* addi R28, R28, 4 */
		/* 820FA6CCh case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820FA6CCh case    2:*/		return 0x820FA6D0;
		  /* 820FA6D0h */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 820FA6D0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820FA6D0h case    3:*/		return 0x820FA6D4;
		  /* 820FA6D4h */ case    4:  		/* bc 12, CR6_LT, -72 */
		/* 820FA6D4h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FA68C;  }
		/* 820FA6D4h case    4:*/		return 0x820FA6D8;
	}
	return 0x820FA6D8;
} // Block from 820FA6C4h-820FA6D8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FA6D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA6D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA6D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA6D8);
		  /* 820FA6D8h */ case    0:  		/* lwz R11, <#[R31 + 204]> */
		/* 820FA6D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000CC) );
		/* 820FA6D8h case    0:*/		return 0x820FA6DC;
		  /* 820FA6DCh */ case    1:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 820FA6DCh case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 820FA6DCh case    1:*/		return 0x820FA6E0;
		  /* 820FA6E0h */ case    2:  		/* bc 12, CR0_EQ, 104 */
		/* 820FA6E0h case    2:*/		if ( regs.CR[0].eq ) { return 0x820FA748;  }
		/* 820FA6E0h case    2:*/		return 0x820FA6E4;
		  /* 820FA6E4h */ case    3:  		/* mr R3, R31 */
		/* 820FA6E4h case    3:*/		regs.R3 = regs.R31;
		/* 820FA6E4h case    3:*/		return 0x820FA6E8;
		  /* 820FA6E8h */ case    4:  		/* bl 28312 */
		/* 820FA6E8h case    4:*/		regs.LR = 0x820FA6EC; return 0x82101580;
		/* 820FA6E8h case    4:*/		return 0x820FA6EC;
		  /* 820FA6ECh */ case    5:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FA6ECh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FA6ECh case    5:*/		return 0x820FA6F0;
		  /* 820FA6F0h */ case    6:  		/* li R29, 0 */
		/* 820FA6F0h case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820FA6F0h case    6:*/		return 0x820FA6F4;
		  /* 820FA6F4h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 820FA6F4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FA6F4h case    7:*/		return 0x820FA6F8;
		  /* 820FA6F8h */ case    8:  		/* bc 4, CR6_GT, 72 */
		/* 820FA6F8h case    8:*/		if ( !regs.CR[6].gt ) { return 0x820FA740;  }
		/* 820FA6F8h case    8:*/		return 0x820FA6FC;
		  /* 820FA6FCh */ case    9:  		/* li R28, 0 */
		/* 820FA6FCh case    9:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820FA6FCh case    9:*/		return 0x820FA700;
		  /* 820FA700h */ case   10:  		/* lwz R10, <#[R31 + 24]> */
		/* 820FA700h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820FA700h case   10:*/		return 0x820FA704;
		  /* 820FA704h */ case   11:  		/* lis R11, 4096 */
		/* 820FA704h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0x1000);
		/* 820FA704h case   11:*/		return 0x820FA708;
		  /* 820FA708h */ case   12:  		/* stw R29, <#[R31 + 256]> */
		/* 820FA708h case   12:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000100) );
		/* 820FA708h case   12:*/		return 0x820FA70C;
		  /* 820FA70Ch */ case   13:  		/* lwzx R10, <#[R28 + R10]> */
		/* 820FA70Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + regs.R10 + 0x00000000) );
		/* 820FA70Ch case   13:*/		return 0x820FA710;
		  /* 820FA710h */ case   14:  		/* stw R10, <#[R31 + 260]> */
		/* 820FA710h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000104) );
		/* 820FA710h case   14:*/		return 0x820FA714;
		  /* 820FA714h */ case   15:  		/* lwz R10, <#[R10]> */
		/* 820FA714h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820FA714h case   15:*/		return 0x820FA718;
		  /* 820FA718h */ case   16:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 820FA718h case   16:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 820FA718h case   16:*/		return 0x820FA71C;
		  /* 820FA71Ch */ case   17:  		/* cmplw CR6, R10, R11 */
		/* 820FA71Ch case   17:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820FA71Ch case   17:*/		return 0x820FA720;
		  /* 820FA720h */ case   18:  		/* bc 4, CR6_EQ, 12 */
		/* 820FA720h case   18:*/		if ( !regs.CR[6].eq ) { return 0x820FA72C;  }
		/* 820FA720h case   18:*/		return 0x820FA724;
		  /* 820FA724h */ case   19:  		/* mr R3, R31 */
		/* 820FA724h case   19:*/		regs.R3 = regs.R31;
		/* 820FA724h case   19:*/		return 0x820FA728;
		  /* 820FA728h */ case   20:  		/* bl -85776 */
		/* 820FA728h case   20:*/		regs.LR = 0x820FA72C; return 0x820E5818;
		/* 820FA728h case   20:*/		return 0x820FA72C;
	}
	return 0x820FA72C;
} // Block from 820FA6D8h-820FA72Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 820FA72Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA72C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA72C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA72C);
		  /* 820FA72Ch */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FA72Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FA72Ch case    0:*/		return 0x820FA730;
		  /* 820FA730h */ case    1:  		/* addi R29, R29, 1 */
		/* 820FA730h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820FA730h case    1:*/		return 0x820FA734;
		  /* 820FA734h */ case    2:  		/* addi R28, R28, 4 */
		/* 820FA734h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820FA734h case    2:*/		return 0x820FA738;
		  /* 820FA738h */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 820FA738h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820FA738h case    3:*/		return 0x820FA73C;
		  /* 820FA73Ch */ case    4:  		/* bc 12, CR6_LT, -60 */
		/* 820FA73Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x820FA700;  }
		/* 820FA73Ch case    4:*/		return 0x820FA740;
	}
	return 0x820FA740;
} // Block from 820FA72Ch-820FA740h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FA740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA740);
		  /* 820FA740h */ case    0:  		/* mr R3, R31 */
		/* 820FA740h case    0:*/		regs.R3 = regs.R31;
		/* 820FA740h case    0:*/		return 0x820FA744;
		  /* 820FA744h */ case    1:  		/* bl 48348 */
		/* 820FA744h case    1:*/		regs.LR = 0x820FA748; return 0x82106420;
		/* 820FA744h case    1:*/		return 0x820FA748;
	}
	return 0x820FA748;
} // Block from 820FA740h-820FA748h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FA748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA748);
		  /* 820FA748h */ case    0:  		/* lwz R11, <#[R31 + 204]> */
		/* 820FA748h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000CC) );
		/* 820FA748h case    0:*/		return 0x820FA74C;
		  /* 820FA74Ch */ case    1:  		/* lis R17, 4176 */
		/* 820FA74Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R17,0x1050);
		/* 820FA74Ch case    1:*/		return 0x820FA750;
		  /* 820FA750h */ case    2:  		/* lis R16, 20480 */
		/* 820FA750h case    2:*/		cpu::op::lis<0>(regs,&regs.R16,0x5000);
		/* 820FA750h case    2:*/		return 0x820FA754;
		  /* 820FA754h */ case    3:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 820FA754h case    3:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 820FA754h case    3:*/		return 0x820FA758;
		  /* 820FA758h */ case    4:  		/* lis R18, 28720 */
		/* 820FA758h case    4:*/		cpu::op::lis<0>(regs,&regs.R18,0x7030);
		/* 820FA758h case    4:*/		return 0x820FA75C;
		  /* 820FA75Ch */ case    5:  		/* lis R22, 29792 */
		/* 820FA75Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R22,0x7460);
		/* 820FA75Ch case    5:*/		return 0x820FA760;
		  /* 820FA760h */ case    6:  		/* lis R21, 29808 */
		/* 820FA760h case    6:*/		cpu::op::lis<0>(regs,&regs.R21,0x7470);
		/* 820FA760h case    6:*/		return 0x820FA764;
		  /* 820FA764h */ case    7:  		/* lis R23, 29760 */
		/* 820FA764h case    7:*/		cpu::op::lis<0>(regs,&regs.R23,0x7440);
		/* 820FA764h case    7:*/		return 0x820FA768;
		  /* 820FA768h */ case    8:  		/* lis R20, 29776 */
		/* 820FA768h case    8:*/		cpu::op::lis<0>(regs,&regs.R20,0x7450);
		/* 820FA768h case    8:*/		return 0x820FA76C;
		  /* 820FA76Ch */ case    9:  		/* bc 4, CR0_EQ, 1428 */
		/* 820FA76Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x820FAD00;  }
		/* 820FA76Ch case    9:*/		return 0x820FA770;
		  /* 820FA770h */ case   10:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FA770h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FA770h case   10:*/		return 0x820FA774;
		  /* 820FA774h */ case   11:  		/* li R29, 0 */
		/* 820FA774h case   11:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820FA774h case   11:*/		return 0x820FA778;
		  /* 820FA778h */ case   12:  		/* lis R26, 8192 */
		/* 820FA778h case   12:*/		cpu::op::lis<0>(regs,&regs.R26,0x2000);
		/* 820FA778h case   12:*/		return 0x820FA77C;
		  /* 820FA77Ch */ case   13:  		/* lis R25, 8208 */
		/* 820FA77Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R25,0x2010);
		/* 820FA77Ch case   13:*/		return 0x820FA780;
		  /* 820FA780h */ case   14:  		/* lis R27, 12288 */
		/* 820FA780h case   14:*/		cpu::op::lis<0>(regs,&regs.R27,0x3000);
		/* 820FA780h case   14:*/		return 0x820FA784;
		  /* 820FA784h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 820FA784h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FA784h case   15:*/		return 0x820FA788;
		  /* 820FA788h */ case   16:  		/* bc 4, CR6_GT, 144 */
		/* 820FA788h case   16:*/		if ( !regs.CR[6].gt ) { return 0x820FA818;  }
		/* 820FA788h case   16:*/		return 0x820FA78C;
		  /* 820FA78Ch */ case   17:  		/* li R28, 0 */
		/* 820FA78Ch case   17:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820FA78Ch case   17:*/		return 0x820FA790;
		  /* 820FA790h */ case   18:  		/* stw R29, <#[R31 + 256]> */
		/* 820FA790h case   18:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000100) );
		/* 820FA790h case   18:*/		return 0x820FA794;
		  /* 820FA794h */ case   19:  		/* lis R10, 4112 */
		/* 820FA794h case   19:*/		cpu::op::lis<0>(regs,&regs.R10,0x1010);
		/* 820FA794h case   19:*/		return 0x820FA798;
		  /* 820FA798h */ case   20:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FA798h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FA798h case   20:*/		return 0x820FA79C;
		  /* 820FA79Ch */ case   21:  		/* lwzx R11, <#[R28 + R11]> */
		/* 820FA79Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820FA79Ch case   21:*/		return 0x820FA7A0;
		  /* 820FA7A0h */ case   22:  		/* stw R11, <#[R31 + 260]> */
		/* 820FA7A0h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820FA7A0h case   22:*/		return 0x820FA7A4;
		  /* 820FA7A4h */ case   23:  		/* lwz R11, <#[R11]> */
		/* 820FA7A4h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FA7A4h case   23:*/		return 0x820FA7A8;
		  /* 820FA7A8h */ case   24:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FA7A8h case   24:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FA7A8h case   24:*/		return 0x820FA7AC;
		  /* 820FA7ACh */ case   25:  		/* cmplw CR6, R11, R10 */
		/* 820FA7ACh case   25:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FA7ACh case   25:*/		return 0x820FA7B0;
		  /* 820FA7B0h */ case   26:  		/* bc 12, CR6_EQ, 60 */
		/* 820FA7B0h case   26:*/		if ( regs.CR[6].eq ) { return 0x820FA7EC;  }
		/* 820FA7B0h case   26:*/		return 0x820FA7B4;
		  /* 820FA7B4h */ case   27:  		/* cmplw CR6, R11, R26 */
		/* 820FA7B4h case   27:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 820FA7B4h case   27:*/		return 0x820FA7B8;
		  /* 820FA7B8h */ case   28:  		/* bc 12, CR6_EQ, 28 */
		/* 820FA7B8h case   28:*/		if ( regs.CR[6].eq ) { return 0x820FA7D4;  }
		/* 820FA7B8h case   28:*/		return 0x820FA7BC;
		  /* 820FA7BCh */ case   29:  		/* cmplw CR6, R11, R25 */
		/* 820FA7BCh case   29:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 820FA7BCh case   29:*/		return 0x820FA7C0;
		  /* 820FA7C0h */ case   30:  		/* bc 12, CR6_EQ, 20 */
		/* 820FA7C0h case   30:*/		if ( regs.CR[6].eq ) { return 0x820FA7D4;  }
		/* 820FA7C0h case   30:*/		return 0x820FA7C4;
		  /* 820FA7C4h */ case   31:  		/* cmplw CR6, R11, R27 */
		/* 820FA7C4h case   31:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 820FA7C4h case   31:*/		return 0x820FA7C8;
		  /* 820FA7C8h */ case   32:  		/* bc 12, CR6_EQ, 12 */
		/* 820FA7C8h case   32:*/		if ( regs.CR[6].eq ) { return 0x820FA7D4;  }
		/* 820FA7C8h case   32:*/		return 0x820FA7CC;
		  /* 820FA7CCh */ case   33:  		/* li R30, 1 */
		/* 820FA7CCh case   33:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820FA7CCh case   33:*/		return 0x820FA7D0;
		  /* 820FA7D0h */ case   34:  		/* b 52 */
		/* 820FA7D0h case   34:*/		return 0x820FA804;
		/* 820FA7D0h case   34:*/		return 0x820FA7D4;
	}
	return 0x820FA7D4;
} // Block from 820FA748h-820FA7D4h (35 instructions)

//////////////////////////////////////////////////////
// Block at 820FA7D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA7D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA7D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA7D4);
		  /* 820FA7D4h */ case    0:  		/* mr R3, R31 */
		/* 820FA7D4h case    0:*/		regs.R3 = regs.R31;
		/* 820FA7D4h case    0:*/		return 0x820FA7D8;
		  /* 820FA7D8h */ case    1:  		/* bl -46208 */
		/* 820FA7D8h case    1:*/		regs.LR = 0x820FA7DC; return 0x820EF358;
		/* 820FA7D8h case    1:*/		return 0x820FA7DC;
		  /* 820FA7DCh */ case    2:  		/* mr R30, R3 */
		/* 820FA7DCh case    2:*/		regs.R30 = regs.R3;
		/* 820FA7DCh case    2:*/		return 0x820FA7E0;
		  /* 820FA7E0h */ case    3:  		/* mr R3, R31 */
		/* 820FA7E0h case    3:*/		regs.R3 = regs.R31;
		/* 820FA7E0h case    3:*/		return 0x820FA7E4;
		  /* 820FA7E4h */ case    4:  		/* bl -90116 */
		/* 820FA7E4h case    4:*/		regs.LR = 0x820FA7E8; return 0x820E47E0;
		/* 820FA7E4h case    4:*/		return 0x820FA7E8;
		  /* 820FA7E8h */ case    5:  		/* b 20 */
		/* 820FA7E8h case    5:*/		return 0x820FA7FC;
		/* 820FA7E8h case    5:*/		return 0x820FA7EC;
	}
	return 0x820FA7EC;
} // Block from 820FA7D4h-820FA7ECh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FA7ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA7EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA7EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA7EC);
		  /* 820FA7ECh */ case    0:  		/* li R4, 1 */
		/* 820FA7ECh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820FA7ECh case    0:*/		return 0x820FA7F0;
		  /* 820FA7F0h */ case    1:  		/* mr R3, R31 */
		/* 820FA7F0h case    1:*/		regs.R3 = regs.R31;
		/* 820FA7F0h case    1:*/		return 0x820FA7F4;
		  /* 820FA7F4h */ case    2:  		/* bl -32748 */
		/* 820FA7F4h case    2:*/		regs.LR = 0x820FA7F8; return 0x820F2808;
		/* 820FA7F4h case    2:*/		return 0x820FA7F8;
		  /* 820FA7F8h */ case    3:  		/* mr R30, R3 */
		/* 820FA7F8h case    3:*/		regs.R30 = regs.R3;
		/* 820FA7F8h case    3:*/		return 0x820FA7FC;
	}
	return 0x820FA7FC;
} // Block from 820FA7ECh-820FA7FCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FA7FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA7FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA7FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA7FC);
		  /* 820FA7FCh */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 820FA7FCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820FA7FCh case    0:*/		return 0x820FA800;
		  /* 820FA800h */ case    1:  		/* bc 12, CR6_LT, 2120 */
		/* 820FA800h case    1:*/		if ( regs.CR[6].lt ) { return 0x820FB048;  }
		/* 820FA800h case    1:*/		return 0x820FA804;
	}
	return 0x820FA804;
} // Block from 820FA7FCh-820FA804h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FA804h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA804( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA804) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA804);
		  /* 820FA804h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FA804h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FA804h case    0:*/		return 0x820FA808;
		  /* 820FA808h */ case    1:  		/* addi R29, R29, 1 */
		/* 820FA808h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820FA808h case    1:*/		return 0x820FA80C;
		  /* 820FA80Ch */ case    2:  		/* addi R28, R28, 4 */
		/* 820FA80Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820FA80Ch case    2:*/		return 0x820FA810;
		  /* 820FA810h */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 820FA810h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820FA810h case    3:*/		return 0x820FA814;
		  /* 820FA814h */ case    4:  		/* bc 12, CR6_LT, -132 */
		/* 820FA814h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FA790;  }
		/* 820FA814h case    4:*/		return 0x820FA818;
	}
	return 0x820FA818;
} // Block from 820FA804h-820FA818h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FA818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA818);
		  /* 820FA818h */ case    0:  		/* lwz R11, <#[R31 + 108]> */
		/* 820FA818h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 820FA818h case    0:*/		return 0x820FA81C;
		  /* 820FA81Ch */ case    1:  		/* rlwinm. R11, R11, 0, 8, 8 */
		/* 820FA81Ch case    1:*/		cpu::op::rlwinm<1,0,8,8>(regs,&regs.R11,regs.R11);
		/* 820FA81Ch case    1:*/		return 0x820FA820;
		  /* 820FA820h */ case    2:  		/* bc 12, CR0_EQ, 344 */
		/* 820FA820h case    2:*/		if ( regs.CR[0].eq ) { return 0x820FA978;  }
		/* 820FA820h case    2:*/		return 0x820FA824;
		  /* 820FA824h */ case    3:  		/* lwz R11, <#[R31 + 112]> */
		/* 820FA824h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820FA824h case    3:*/		return 0x820FA828;
		  /* 820FA828h */ case    4:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 820FA828h case    4:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 820FA828h case    4:*/		return 0x820FA82C;
		  /* 820FA82Ch */ case    5:  		/* bc 12, CR0_EQ, 332 */
		/* 820FA82Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820FA978;  }
		/* 820FA82Ch case    5:*/		return 0x820FA830;
		  /* 820FA830h */ case    6:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FA830h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FA830h case    6:*/		return 0x820FA834;
		  /* 820FA834h */ case    7:  		/* li R29, 0 */
		/* 820FA834h case    7:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820FA834h case    7:*/		return 0x820FA838;
	}
	return 0x820FA838;
} // Block from 820FA818h-820FA838h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820FA838h
// Function '?Constrain@C30Program@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA838);
		  /* 820FA838h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820FA838h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FA838h case    0:*/		return 0x820FA83C;
		  /* 820FA83Ch */ case    1:  		/* bc 4, CR6_GT, 132 */
		/* 820FA83Ch case    1:*/		if ( !regs.CR[6].gt ) { return 0x820FA8C0;  }
		/* 820FA83Ch case    1:*/		return 0x820FA840;
		  /* 820FA840h */ case    2:  		/* li R28, 0 */
		/* 820FA840h case    2:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820FA840h case    2:*/		return 0x820FA844;
		  /* 820FA844h */ case    3:  		/* stw R29, <#[R31 + 256]> */
		/* 820FA844h case    3:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000100) );
		/* 820FA844h case    3:*/		return 0x820FA848;
		  /* 820FA848h */ case    4:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FA848h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FA848h case    4:*/		return 0x820FA84C;
		  /* 820FA84Ch */ case    5:  		/* lwzx R11, <#[R28 + R11]> */
		/* 820FA84Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820FA84Ch case    5:*/		return 0x820FA850;
		  /* 820FA850h */ case    6:  		/* stw R11, <#[R31 + 260]> */
		/* 820FA850h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820FA850h case    6:*/		return 0x820FA854;
		  /* 820FA854h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820FA854h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FA854h case    7:*/		return 0x820FA858;
		  /* 820FA858h */ case    8:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FA858h case    8:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FA858h case    8:*/		return 0x820FA85C;
		  /* 820FA85Ch */ case    9:  		/* cmplw CR6, R11, R27 */
		/* 820FA85Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 820FA85Ch case    9:*/		return 0x820FA860;
		  /* 820FA860h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 820FA860h case   10:*/		if ( regs.CR[6].eq ) { return 0x820FA86C;  }
		/* 820FA860h case   10:*/		return 0x820FA864;
		  /* 820FA864h */ case   11:  		/* li R30, 1 */
		/* 820FA864h case   11:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820FA864h case   11:*/		return 0x820FA868;
		  /* 820FA868h */ case   12:  		/* b 68 */
		/* 820FA868h case   12:*/		return 0x820FA8AC;
		/* 820FA868h case   12:*/		return 0x820FA86C;
	}
	return 0x820FA86C;
} // Block from 820FA838h-820FA86Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FA86Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA86C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA86C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA86C);
		  /* 820FA86Ch */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 820FA86Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820FA86Ch case    0:*/		return 0x820FA870;
		  /* 820FA870h */ case    1:  		/* bc 12, CR6_LT, 2008 */
		/* 820FA870h case    1:*/		if ( regs.CR[6].lt ) { return 0x820FB048;  }
		/* 820FA870h case    1:*/		return 0x820FA874;
		  /* 820FA874h */ case    2:  		/* li R6, 0 */
		/* 820FA874h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820FA874h case    2:*/		return 0x820FA878;
		  /* 820FA878h */ case    3:  		/* li R5, 0 */
		/* 820FA878h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820FA878h case    3:*/		return 0x820FA87C;
		  /* 820FA87Ch */ case    4:  		/* li R4, 0 */
		/* 820FA87Ch case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820FA87Ch case    4:*/		return 0x820FA880;
		  /* 820FA880h */ case    5:  		/* mr R3, R31 */
		/* 820FA880h case    5:*/		regs.R3 = regs.R31;
		/* 820FA880h case    5:*/		return 0x820FA884;
		  /* 820FA884h */ case    6:  		/* bl -85948 */
		/* 820FA884h case    6:*/		regs.LR = 0x820FA888; return 0x820E58C8;
		/* 820FA884h case    6:*/		return 0x820FA888;
		  /* 820FA888h */ case    7:  		/* or. R30, R3, R3 */
		/* 820FA888h case    7:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FA888h case    7:*/		return 0x820FA88C;
		  /* 820FA88Ch */ case    8:  		/* bc 12, CR0_LT, 1980 */
		/* 820FA88Ch case    8:*/		if ( regs.CR[0].lt ) { return 0x820FB048;  }
		/* 820FA88Ch case    8:*/		return 0x820FA890;
		  /* 820FA890h */ case    9:  		/* li R6, 0 */
		/* 820FA890h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820FA890h case    9:*/		return 0x820FA894;
		  /* 820FA894h */ case   10:  		/* li R5, 0 */
		/* 820FA894h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820FA894h case   10:*/		return 0x820FA898;
		  /* 820FA898h */ case   11:  		/* li R4, 0 */
		/* 820FA898h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820FA898h case   11:*/		return 0x820FA89C;
		  /* 820FA89Ch */ case   12:  		/* mr R3, R31 */
		/* 820FA89Ch case   12:*/		regs.R3 = regs.R31;
		/* 820FA89Ch case   12:*/		return 0x820FA8A0;
		  /* 820FA8A0h */ case   13:  		/* bl -84288 */
		/* 820FA8A0h case   13:*/		regs.LR = 0x820FA8A4; return 0x820E5F60;
		/* 820FA8A0h case   13:*/		return 0x820FA8A4;
		  /* 820FA8A4h */ case   14:  		/* or. R30, R3, R3 */
		/* 820FA8A4h case   14:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FA8A4h case   14:*/		return 0x820FA8A8;
	}
	return 0x820FA8A8;
} // Block from 820FA86Ch-820FA8A8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820FA8A8h
// Function '?EmitVersion@CPSProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA8A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA8A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA8A8);
		  /* 820FA8A8h */ case    0:  		/* bc 12, CR0_LT, 1952 */
		/* 820FA8A8h case    0:*/		if ( regs.CR[0].lt ) { return 0x820FB048;  }
		/* 820FA8A8h case    0:*/		return 0x820FA8AC;
	}
	return 0x820FA8AC;
} // Block from 820FA8A8h-820FA8ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FA8ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA8AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA8AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA8AC);
		  /* 820FA8ACh */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FA8ACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FA8ACh case    0:*/		return 0x820FA8B0;
		  /* 820FA8B0h */ case    1:  		/* addi R29, R29, 1 */
		/* 820FA8B0h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820FA8B0h case    1:*/		return 0x820FA8B4;
		  /* 820FA8B4h */ case    2:  		/* addi R28, R28, 4 */
		/* 820FA8B4h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820FA8B4h case    2:*/		return 0x820FA8B8;
		  /* 820FA8B8h */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 820FA8B8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820FA8B8h case    3:*/		return 0x820FA8BC;
		  /* 820FA8BCh */ case    4:  		/* bc 12, CR6_LT, -120 */
		/* 820FA8BCh case    4:*/		if ( regs.CR[6].lt ) { return 0x820FA844;  }
		/* 820FA8BCh case    4:*/		return 0x820FA8C0;
	}
	return 0x820FA8C0;
} // Block from 820FA8ACh-820FA8C0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FA8C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA8C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA8C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA8C0);
		  /* 820FA8C0h */ case    0:  		/* mr R3, R31 */
		/* 820FA8C0h case    0:*/		regs.R3 = regs.R31;
		/* 820FA8C0h case    0:*/		return 0x820FA8C4;
		  /* 820FA8C4h */ case    1:  		/* bl 51108 */
		/* 820FA8C4h case    1:*/		regs.LR = 0x820FA8C8; return 0x82107068;
		/* 820FA8C4h case    1:*/		return 0x820FA8C8;
		  /* 820FA8C8h */ case    2:  		/* or. R30, R3, R3 */
		/* 820FA8C8h case    2:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FA8C8h case    2:*/		return 0x820FA8CC;
		  /* 820FA8CCh */ case    3:  		/* bc 12, CR0_LT, 1916 */
		/* 820FA8CCh case    3:*/		if ( regs.CR[0].lt ) { return 0x820FB048;  }
		/* 820FA8CCh case    3:*/		return 0x820FA8D0;
		  /* 820FA8D0h */ case    4:  		/* mr R3, R31 */
		/* 820FA8D0h case    4:*/		regs.R3 = regs.R31;
		/* 820FA8D0h case    4:*/		return 0x820FA8D4;
		  /* 820FA8D4h */ case    5:  		/* bl -90356 */
		/* 820FA8D4h case    5:*/		regs.LR = 0x820FA8D8; return 0x820E47E0;
		/* 820FA8D4h case    5:*/		return 0x820FA8D8;
		  /* 820FA8D8h */ case    6:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FA8D8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FA8D8h case    6:*/		return 0x820FA8DC;
		  /* 820FA8DCh */ case    7:  		/* li R29, 0 */
		/* 820FA8DCh case    7:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820FA8DCh case    7:*/		return 0x820FA8E0;
		  /* 820FA8E0h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 820FA8E0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FA8E0h case    8:*/		return 0x820FA8E4;
		  /* 820FA8E4h */ case    9:  		/* bc 4, CR6_GT, 148 */
		/* 820FA8E4h case    9:*/		if ( !regs.CR[6].gt ) { return 0x820FA978;  }
		/* 820FA8E4h case    9:*/		return 0x820FA8E8;
		  /* 820FA8E8h */ case   10:  		/* li R28, 0 */
		/* 820FA8E8h case   10:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820FA8E8h case   10:*/		return 0x820FA8EC;
		  /* 820FA8ECh */ case   11:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FA8ECh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FA8ECh case   11:*/		return 0x820FA8F0;
		  /* 820FA8F0h */ case   12:  		/* stw R29, <#[R31 + 256]> */
		/* 820FA8F0h case   12:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000100) );
		/* 820FA8F0h case   12:*/		return 0x820FA8F4;
		  /* 820FA8F4h */ case   13:  		/* lwzx R11, <#[R28 + R11]> */
		/* 820FA8F4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820FA8F4h case   13:*/		return 0x820FA8F8;
		  /* 820FA8F8h */ case   14:  		/* stw R11, <#[R31 + 260]> */
		/* 820FA8F8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820FA8F8h case   14:*/		return 0x820FA8FC;
		  /* 820FA8FCh */ case   15:  		/* lwz R11, <#[R11]> */
		/* 820FA8FCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FA8FCh case   15:*/		return 0x820FA900;
		  /* 820FA900h */ case   16:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FA900h case   16:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FA900h case   16:*/		return 0x820FA904;
		  /* 820FA904h */ case   17:  		/* cmplw CR6, R11, R26 */
		/* 820FA904h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 820FA904h case   17:*/		return 0x820FA908;
		  /* 820FA908h */ case   18:  		/* bc 12, CR6_EQ, 64 */
		/* 820FA908h case   18:*/		if ( regs.CR[6].eq ) { return 0x820FA948;  }
		/* 820FA908h case   18:*/		return 0x820FA90C;
		  /* 820FA90Ch */ case   19:  		/* cmplw CR6, R11, R27 */
		/* 820FA90Ch case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 820FA90Ch case   19:*/		return 0x820FA910;
	}
	return 0x820FA910;
} // Block from 820FA8C0h-820FA910h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820FA910h
// Function '?EmitAddress@C30Program@D3DXShader@@IAAJI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA910( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA910) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA910);
		  /* 820FA910h */ case    0:  		/* bc 12, CR6_EQ, 24 */
		/* 820FA910h case    0:*/		if ( regs.CR[6].eq ) { return 0x820FA928;  }
		/* 820FA910h case    0:*/		return 0x820FA914;
		  /* 820FA914h */ case    1:  		/* lis R10, 28848 */
		/* 820FA914h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x70B0);
		/* 820FA914h case    1:*/		return 0x820FA918;
		  /* 820FA918h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820FA918h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FA918h case    2:*/		return 0x820FA91C;
		  /* 820FA91Ch */ case    3:  		/* bc 12, CR6_EQ, 44 */
		/* 820FA91Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820FA948;  }
		/* 820FA91Ch case    3:*/		return 0x820FA920;
		  /* 820FA920h */ case    4:  		/* li R30, 1 */
		/* 820FA920h case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820FA920h case    4:*/		return 0x820FA924;
		  /* 820FA924h */ case    5:  		/* b 64 */
		/* 820FA924h case    5:*/		return 0x820FA964;
		/* 820FA924h case    5:*/		return 0x820FA928;
	}
	return 0x820FA928;
} // Block from 820FA910h-820FA928h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FA928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA928);
		  /* 820FA928h */ case    0:  		/* mr R3, R31 */
		/* 820FA928h case    0:*/		regs.R3 = regs.R31;
		/* 820FA928h case    0:*/		return 0x820FA92C;
		  /* 820FA92Ch */ case    1:  		/* bl -68412 */
		/* 820FA92Ch case    1:*/		regs.LR = 0x820FA930; return 0x820E9DF0;
		/* 820FA92Ch case    1:*/		return 0x820FA930;
		  /* 820FA930h */ case    2:  		/* or. R30, R3, R3 */
		/* 820FA930h case    2:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FA930h case    2:*/		return 0x820FA934;
		  /* 820FA934h */ case    3:  		/* bc 12, CR0_LT, 1812 */
		/* 820FA934h case    3:*/		if ( regs.CR[0].lt ) { return 0x820FB048;  }
		/* 820FA934h case    3:*/		return 0x820FA938;
		  /* 820FA938h */ case    4:  		/* mr R3, R31 */
		/* 820FA938h case    4:*/		regs.R3 = regs.R31;
		/* 820FA938h case    4:*/		return 0x820FA93C;
		  /* 820FA93Ch */ case    5:  		/* bl -68204 */
		/* 820FA93Ch case    5:*/		regs.LR = 0x820FA940; return 0x820E9ED0;
		/* 820FA93Ch case    5:*/		return 0x820FA940;
		  /* 820FA940h */ case    6:  		/* mr R30, R3 */
		/* 820FA940h case    6:*/		regs.R30 = regs.R3;
		/* 820FA940h case    6:*/		return 0x820FA944;
		  /* 820FA944h */ case    7:  		/* b 24 */
		/* 820FA944h case    7:*/		return 0x820FA95C;
		/* 820FA944h case    7:*/		return 0x820FA948;
	}
	return 0x820FA948;
} // Block from 820FA928h-820FA948h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820FA948h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA948( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA948) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA948);
		  /* 820FA948h */ case    0:  		/* mr R3, R31 */
		/* 820FA948h case    0:*/		regs.R3 = regs.R31;
		/* 820FA948h case    0:*/		return 0x820FA94C;
		  /* 820FA94Ch */ case    1:  		/* bl -46580 */
		/* 820FA94Ch case    1:*/		regs.LR = 0x820FA950; return 0x820EF358;
		/* 820FA94Ch case    1:*/		return 0x820FA950;
		  /* 820FA950h */ case    2:  		/* mr R30, R3 */
		/* 820FA950h case    2:*/		regs.R30 = regs.R3;
		/* 820FA950h case    2:*/		return 0x820FA954;
		  /* 820FA954h */ case    3:  		/* mr R3, R31 */
		/* 820FA954h case    3:*/		regs.R3 = regs.R31;
		/* 820FA954h case    3:*/		return 0x820FA958;
		  /* 820FA958h */ case    4:  		/* bl -90488 */
		/* 820FA958h case    4:*/		regs.LR = 0x820FA95C; return 0x820E47E0;
		/* 820FA958h case    4:*/		return 0x820FA95C;
	}
	return 0x820FA95C;
} // Block from 820FA948h-820FA95Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FA95Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA95C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA95C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA95C);
		  /* 820FA95Ch */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 820FA95Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820FA95Ch case    0:*/		return 0x820FA960;
		  /* 820FA960h */ case    1:  		/* bc 12, CR6_LT, 1768 */
		/* 820FA960h case    1:*/		if ( regs.CR[6].lt ) { return 0x820FB048;  }
		/* 820FA960h case    1:*/		return 0x820FA964;
	}
	return 0x820FA964;
} // Block from 820FA95Ch-820FA964h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FA964h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA964( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA964) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA964);
		  /* 820FA964h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FA964h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FA964h case    0:*/		return 0x820FA968;
		  /* 820FA968h */ case    1:  		/* addi R29, R29, 1 */
		/* 820FA968h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820FA968h case    1:*/		return 0x820FA96C;
		  /* 820FA96Ch */ case    2:  		/* addi R28, R28, 4 */
		/* 820FA96Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820FA96Ch case    2:*/		return 0x820FA970;
		  /* 820FA970h */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 820FA970h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820FA970h case    3:*/		return 0x820FA974;
		  /* 820FA974h */ case    4:  		/* bc 12, CR6_LT, -136 */
		/* 820FA974h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FA8EC;  }
		/* 820FA974h case    4:*/		return 0x820FA978;
	}
	return 0x820FA978;
} // Block from 820FA964h-820FA978h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FA978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA978);
		  /* 820FA978h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FA978h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FA978h case    0:*/		return 0x820FA97C;
		  /* 820FA97Ch */ case    1:  		/* li R27, 0 */
		/* 820FA97Ch case    1:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820FA97Ch case    1:*/		return 0x820FA980;
		  /* 820FA980h */ case    2:  		/* lis R24, 8272 */
		/* 820FA980h case    2:*/		cpu::op::lis<0>(regs,&regs.R24,0x2050);
		/* 820FA980h case    2:*/		return 0x820FA984;
		  /* 820FA984h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820FA984h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FA984h case    3:*/		return 0x820FA988;
		  /* 820FA988h */ case    4:  		/* bc 4, CR6_GT, 352 */
		/* 820FA988h case    4:*/		if ( !regs.CR[6].gt ) { return 0x820FAAE8;  }
		/* 820FA988h case    4:*/		return 0x820FA98C;
		  /* 820FA98Ch */ case    5:  		/* li R26, 0 */
		/* 820FA98Ch case    5:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820FA98Ch case    5:*/		return 0x820FA990;
		  /* 820FA990h */ case    6:  		/* stw R27, <#[R31 + 256]> */
		/* 820FA990h case    6:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000100) );
		/* 820FA990h case    6:*/		return 0x820FA994;
		  /* 820FA994h */ case    7:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FA994h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FA994h case    7:*/		return 0x820FA998;
		  /* 820FA998h */ case    8:  		/* lwzx R11, <#[R26 + R11]> */
		/* 820FA998h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 820FA998h case    8:*/		return 0x820FA99C;
		  /* 820FA99Ch */ case    9:  		/* stw R11, <#[R31 + 260]> */
		/* 820FA99Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820FA99Ch case    9:*/		return 0x820FA9A0;
		  /* 820FA9A0h */ case   10:  		/* lwz R11, <#[R11]> */
		/* 820FA9A0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FA9A0h case   10:*/		return 0x820FA9A4;
		  /* 820FA9A4h */ case   11:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FA9A4h case   11:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FA9A4h case   11:*/		return 0x820FA9A8;
		  /* 820FA9A8h */ case   12:  		/* cmplw CR6, R11, R17 */
		/* 820FA9A8h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R17);
		/* 820FA9A8h case   12:*/		return 0x820FA9AC;
		  /* 820FA9ACh */ case   13:  		/* bc 12, CR6_EQ, 168 */
		/* 820FA9ACh case   13:*/		if ( regs.CR[6].eq ) { return 0x820FAA54;  }
		/* 820FA9ACh case   13:*/		return 0x820FA9B0;
		  /* 820FA9B0h */ case   14:  		/* lis R10, 4336 */
		/* 820FA9B0h case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0x10F0);
		/* 820FA9B0h case   14:*/		return 0x820FA9B4;
		  /* 820FA9B4h */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 820FA9B4h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FA9B4h case   15:*/		return 0x820FA9B8;
		  /* 820FA9B8h */ case   16:  		/* bc 12, CR6_EQ, 144 */
		/* 820FA9B8h case   16:*/		if ( regs.CR[6].eq ) { return 0x820FAA48;  }
		/* 820FA9B8h case   16:*/		return 0x820FA9BC;
		  /* 820FA9BCh */ case   17:  		/* cmplw CR6, R11, R19 */
		/* 820FA9BCh case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R19);
		/* 820FA9BCh case   17:*/		return 0x820FA9C0;
		  /* 820FA9C0h */ case   18:  		/* bc 12, CR6_EQ, 124 */
		/* 820FA9C0h case   18:*/		if ( regs.CR[6].eq ) { return 0x820FAA3C;  }
		/* 820FA9C0h case   18:*/		return 0x820FA9C4;
		  /* 820FA9C4h */ case   19:  		/* cmplw CR6, R11, R25 */
		/* 820FA9C4h case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 820FA9C4h case   19:*/		return 0x820FA9C8;
		  /* 820FA9C8h */ case   20:  		/* bc 12, CR6_EQ, 92 */
		/* 820FA9C8h case   20:*/		if ( regs.CR[6].eq ) { return 0x820FAA24;  }
		/* 820FA9C8h case   20:*/		return 0x820FA9CC;
		  /* 820FA9CCh */ case   21:  		/* lis R10, 8256 */
		/* 820FA9CCh case   21:*/		cpu::op::lis<0>(regs,&regs.R10,0x2040);
		/* 820FA9CCh case   21:*/		return 0x820FA9D0;
		  /* 820FA9D0h */ case   22:  		/* cmplw CR6, R11, R10 */
		/* 820FA9D0h case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FA9D0h case   22:*/		return 0x820FA9D4;
		  /* 820FA9D4h */ case   23:  		/* bc 12, CR6_EQ, 32 */
		/* 820FA9D4h case   23:*/		if ( regs.CR[6].eq ) { return 0x820FA9F4;  }
		/* 820FA9D4h case   23:*/		return 0x820FA9D8;
		  /* 820FA9D8h */ case   24:  		/* cmplw CR6, R11, R24 */
		/* 820FA9D8h case   24:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 820FA9D8h case   24:*/		return 0x820FA9DC;
		  /* 820FA9DCh */ case   25:  		/* bc 12, CR6_EQ, 12 */
		/* 820FA9DCh case   25:*/		if ( regs.CR[6].eq ) { return 0x820FA9E8;  }
		/* 820FA9DCh case   25:*/		return 0x820FA9E0;
		  /* 820FA9E0h */ case   26:  		/* li R30, 1 */
		/* 820FA9E0h case   26:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820FA9E0h case   26:*/		return 0x820FA9E4;
		  /* 820FA9E4h */ case   27:  		/* b 152 */
		/* 820FA9E4h case   27:*/		return 0x820FAA7C;
		/* 820FA9E4h case   27:*/		return 0x820FA9E8;
	}
	return 0x820FA9E8;
} // Block from 820FA978h-820FA9E8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820FA9E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA9E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA9E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA9E8);
		  /* 820FA9E8h */ case    0:  		/* mr R3, R31 */
		/* 820FA9E8h case    0:*/		regs.R3 = regs.R31;
		/* 820FA9E8h case    0:*/		return 0x820FA9EC;
		  /* 820FA9ECh */ case    1:  		/* bl -72044 */
		/* 820FA9ECh case    1:*/		regs.LR = 0x820FA9F0; return 0x820E9080;
		/* 820FA9ECh case    1:*/		return 0x820FA9F0;
		  /* 820FA9F0h */ case    2:  		/* b 120 */
		/* 820FA9F0h case    2:*/		return 0x820FAA68;
		/* 820FA9F0h case    2:*/		return 0x820FA9F4;
	}
	return 0x820FA9F4;
} // Block from 820FA9E8h-820FA9F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FA9F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FA9F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FA9F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FA9F4);
		  /* 820FA9F4h */ case    0:  		/* lwz R11, <#[R31 + 108]> */
		/* 820FA9F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 820FA9F4h case    0:*/		return 0x820FA9F8;
		  /* 820FA9F8h */ case    1:  		/* rlwinm. R11, R11, 0, 6, 6 */
		/* 820FA9F8h case    1:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R11,regs.R11);
		/* 820FA9F8h case    1:*/		return 0x820FA9FC;
		  /* 820FA9FCh */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 820FA9FCh case    2:*/		if ( regs.CR[0].eq ) { return 0x820FAA0C;  }
		/* 820FA9FCh case    2:*/		return 0x820FAA00;
		  /* 820FAA00h */ case    3:  		/* mr R3, R31 */
		/* 820FAA00h case    3:*/		regs.R3 = regs.R31;
		/* 820FAA00h case    3:*/		return 0x820FAA04;
		  /* 820FAA04h */ case    4:  		/* bl -70908 */
		/* 820FAA04h case    4:*/		regs.LR = 0x820FAA08; return 0x820E9508;
		/* 820FAA04h case    4:*/		return 0x820FAA08;
		  /* 820FAA08h */ case    5:  		/* mr R30, R3 */
		/* 820FAA08h case    5:*/		regs.R30 = regs.R3;
		/* 820FAA08h case    5:*/		return 0x820FAA0C;
	}
	return 0x820FAA0C;
} // Block from 820FA9F4h-820FAA0Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FAA0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAA0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAA0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAA0C);
		  /* 820FAA0Ch */ case    0:  		/* cmpwi CR6, R30, 1 */
		/* 820FAA0Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000001);
		/* 820FAA0Ch case    0:*/		return 0x820FAA10;
		  /* 820FAA10h */ case    1:  		/* bc 4, CR6_EQ, 100 */
		/* 820FAA10h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820FAA74;  }
		/* 820FAA10h case    1:*/		return 0x820FAA14;
		  /* 820FAA14h */ case    2:  		/* li R4, 1 */
		/* 820FAA14h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820FAA14h case    2:*/		return 0x820FAA18;
		  /* 820FAA18h */ case    3:  		/* mr R3, R31 */
		/* 820FAA18h case    3:*/		regs.R3 = regs.R31;
		/* 820FAA18h case    3:*/		return 0x820FAA1C;
		  /* 820FAA1Ch */ case    4:  		/* bl -43180 */
		/* 820FAA1Ch case    4:*/		regs.LR = 0x820FAA20; return 0x820F0170;
		/* 820FAA1Ch case    4:*/		return 0x820FAA20;
		  /* 820FAA20h */ case    5:  		/* b 72 */
		/* 820FAA20h case    5:*/		return 0x820FAA68;
		/* 820FAA20h case    5:*/		return 0x820FAA24;
	}
	return 0x820FAA24;
} // Block from 820FAA0Ch-820FAA24h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FAA24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAA24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAA24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAA24);
		  /* 820FAA24h */ case    0:  		/* lhz R11, <#[R31 + 202]> */
		/* 820FAA24h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000CA) );
		/* 820FAA24h case    0:*/		return 0x820FAA28;
		  /* 820FAA28h */ case    1:  		/* cmplwi CR6, R11, 512 */
		/* 820FAA28h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000200);
		/* 820FAA28h case    1:*/		return 0x820FAA2C;
		  /* 820FAA2Ch */ case    2:  		/* bc 12, CR6_LT, 68 */
		/* 820FAA2Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x820FAA70;  }
		/* 820FAA2Ch case    2:*/		return 0x820FAA30;
		  /* 820FAA30h */ case    3:  		/* mr R3, R31 */
		/* 820FAA30h case    3:*/		regs.R3 = regs.R31;
		/* 820FAA30h case    3:*/		return 0x820FAA34;
		  /* 820FAA34h */ case    4:  		/* bl -68996 */
		/* 820FAA34h case    4:*/		regs.LR = 0x820FAA38; return 0x820E9CB0;
		/* 820FAA34h case    4:*/		return 0x820FAA38;
		  /* 820FAA38h */ case    5:  		/* b 48 */
		/* 820FAA38h case    5:*/		return 0x820FAA68;
		/* 820FAA38h case    5:*/		return 0x820FAA3C;
	}
	return 0x820FAA3C;
} // Block from 820FAA24h-820FAA3Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FAA3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAA3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAA3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAA3C);
		  /* 820FAA3Ch */ case    0:  		/* mr R3, R31 */
		/* 820FAA3Ch case    0:*/		regs.R3 = regs.R31;
		/* 820FAA3Ch case    0:*/		return 0x820FAA40;
		  /* 820FAA40h */ case    1:  		/* bl -79024 */
		/* 820FAA40h case    1:*/		regs.LR = 0x820FAA44; return 0x820E7590;
		/* 820FAA40h case    1:*/		return 0x820FAA44;
		  /* 820FAA44h */ case    2:  		/* b 36 */
		/* 820FAA44h case    2:*/		return 0x820FAA68;
		/* 820FAA44h case    2:*/		return 0x820FAA48;
	}
	return 0x820FAA48;
} // Block from 820FAA3Ch-820FAA48h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FAA48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAA48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAA48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAA48);
		  /* 820FAA48h */ case    0:  		/* mr R3, R31 */
		/* 820FAA48h case    0:*/		regs.R3 = regs.R31;
		/* 820FAA48h case    0:*/		return 0x820FAA4C;
		  /* 820FAA4Ch */ case    1:  		/* bl -82532 */
		/* 820FAA4Ch case    1:*/		regs.LR = 0x820FAA50; return 0x820E67E8;
		/* 820FAA4Ch case    1:*/		return 0x820FAA50;
		  /* 820FAA50h */ case    2:  		/* b 24 */
		/* 820FAA50h case    2:*/		return 0x820FAA68;
		/* 820FAA50h case    2:*/		return 0x820FAA54;
	}
	return 0x820FAA54;
} // Block from 820FAA48h-820FAA54h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FAA54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAA54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAA54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAA54);
		  /* 820FAA54h */ case    0:  		/* lhz R11, <#[R31 + 202]> */
		/* 820FAA54h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000CA) );
		/* 820FAA54h case    0:*/		return 0x820FAA58;
		  /* 820FAA58h */ case    1:  		/* cmplwi CR6, R11, 512 */
		/* 820FAA58h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000200);
		/* 820FAA58h case    1:*/		return 0x820FAA5C;
		  /* 820FAA5Ch */ case    2:  		/* bc 12, CR6_LT, 20 */
		/* 820FAA5Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x820FAA70;  }
		/* 820FAA5Ch case    2:*/		return 0x820FAA60;
		  /* 820FAA60h */ case    3:  		/* mr R3, R31 */
		/* 820FAA60h case    3:*/		regs.R3 = regs.R31;
		/* 820FAA60h case    3:*/		return 0x820FAA64;
		  /* 820FAA64h */ case    4:  		/* bl -87012 */
		/* 820FAA64h case    4:*/		regs.LR = 0x820FAA68; return 0x820E5680;
		/* 820FAA64h case    4:*/		return 0x820FAA68;
	}
	return 0x820FAA68;
} // Block from 820FAA54h-820FAA68h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FAA68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAA68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAA68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAA68);
		  /* 820FAA68h */ case    0:  		/* mr R30, R3 */
		/* 820FAA68h case    0:*/		regs.R30 = regs.R3;
		/* 820FAA68h case    0:*/		return 0x820FAA6C;
		  /* 820FAA6Ch */ case    1:  		/* b 8 */
		/* 820FAA6Ch case    1:*/		return 0x820FAA74;
		/* 820FAA6Ch case    1:*/		return 0x820FAA70;
	}
	return 0x820FAA70;
} // Block from 820FAA68h-820FAA70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FAA70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAA70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAA70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAA70);
		  /* 820FAA70h */ case    0:  		/* li R30, 1 */
		/* 820FAA70h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820FAA70h case    0:*/		return 0x820FAA74;
	}
	return 0x820FAA74;
} // Block from 820FAA70h-820FAA74h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FAA74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAA74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAA74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAA74);
		  /* 820FAA74h */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 820FAA74h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820FAA74h case    0:*/		return 0x820FAA78;
		  /* 820FAA78h */ case    1:  		/* bc 12, CR6_LT, 1488 */
		/* 820FAA78h case    1:*/		if ( regs.CR[6].lt ) { return 0x820FB048;  }
		/* 820FAA78h case    1:*/		return 0x820FAA7C;
	}
	return 0x820FAA7C;
} // Block from 820FAA74h-820FAA7Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FAA7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAA7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAA7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAA7C);
		  /* 820FAA7Ch */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FAA7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FAA7Ch case    0:*/		return 0x820FAA80;
		  /* 820FAA80h */ case    1:  		/* li R28, 0 */
		/* 820FAA80h case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820FAA80h case    1:*/		return 0x820FAA84;
		  /* 820FAA84h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820FAA84h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FAA84h case    2:*/		return 0x820FAA88;
		  /* 820FAA88h */ case    3:  		/* bc 4, CR6_GT, 76 */
		/* 820FAA88h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820FAAD4;  }
		/* 820FAA88h case    3:*/		return 0x820FAA8C;
		  /* 820FAA8Ch */ case    4:  		/* li R30, 1 */
		/* 820FAA8Ch case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820FAA8Ch case    4:*/		return 0x820FAA90;
		  /* 820FAA90h */ case    5:  		/* li R29, 0 */
		/* 820FAA90h case    5:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820FAA90h case    5:*/		return 0x820FAA94;
		  /* 820FAA94h */ case    6:  		/* stw R28, <#[R31 + 256]> */
		/* 820FAA94h case    6:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000100) );
		/* 820FAA94h case    6:*/		return 0x820FAA98;
		  /* 820FAA98h */ case    7:  		/* lis R11, 28672 */
		/* 820FAA98h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0x7000);
		/* 820FAA98h case    7:*/		return 0x820FAA9C;
		  /* 820FAA9Ch */ case    8:  		/* lwz R10, <#[R31 + 24]> */
		/* 820FAA9Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820FAA9Ch case    8:*/		return 0x820FAAA0;
	}
	return 0x820FAAA0;
} // Block from 820FAA7Ch-820FAAA0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820FAAA0h
// Function '??_EC30Program@D3DXShader@@UAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAAA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAAA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAAA0);
		  /* 820FAAA0h */ case    0:  		/* lwzx R10, <#[R29 + R10]> */
		/* 820FAAA0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + regs.R10 + 0x00000000) );
		/* 820FAAA0h case    0:*/		return 0x820FAAA4;
		  /* 820FAAA4h */ case    1:  		/* stw R10, <#[R31 + 260]> */
		/* 820FAAA4h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000104) );
		/* 820FAAA4h case    1:*/		return 0x820FAAA8;
		  /* 820FAAA8h */ case    2:  		/* lwz R10, <#[R10]> */
		/* 820FAAA8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820FAAA8h case    2:*/		return 0x820FAAAC;
		  /* 820FAAACh */ case    3:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 820FAAACh case    3:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 820FAAACh case    3:*/		return 0x820FAAB0;
		  /* 820FAAB0h */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 820FAAB0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820FAAB0h case    4:*/		return 0x820FAAB4;
		  /* 820FAAB4h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 820FAAB4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820FAAC0;  }
		/* 820FAAB4h case    5:*/		return 0x820FAAB8;
		  /* 820FAAB8h */ case    6:  		/* mr R3, R31 */
		/* 820FAAB8h case    6:*/		regs.R3 = regs.R31;
		/* 820FAAB8h case    6:*/		return 0x820FAABC;
		  /* 820FAABCh */ case    7:  		/* bl -33364 */
		/* 820FAABCh case    7:*/		regs.LR = 0x820FAAC0; return 0x820F2868;
		/* 820FAABCh case    7:*/		return 0x820FAAC0;
	}
	return 0x820FAAC0;
} // Block from 820FAAA0h-820FAAC0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820FAAC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAAC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAAC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAAC0);
		  /* 820FAAC0h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FAAC0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FAAC0h case    0:*/		return 0x820FAAC4;
		  /* 820FAAC4h */ case    1:  		/* addi R28, R28, 1 */
		/* 820FAAC4h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820FAAC4h case    1:*/		return 0x820FAAC8;
		  /* 820FAAC8h */ case    2:  		/* addi R29, R29, 4 */
		/* 820FAAC8h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820FAAC8h case    2:*/		return 0x820FAACC;
		  /* 820FAACCh */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 820FAACCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820FAACCh case    3:*/		return 0x820FAAD0;
		  /* 820FAAD0h */ case    4:  		/* bc 12, CR6_LT, -60 */
		/* 820FAAD0h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FAA94;  }
		/* 820FAAD0h case    4:*/		return 0x820FAAD4;
	}
	return 0x820FAAD4;
} // Block from 820FAAC0h-820FAAD4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FAAD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAAD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAAD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAAD4);
		  /* 820FAAD4h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FAAD4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FAAD4h case    0:*/		return 0x820FAAD8;
		  /* 820FAAD8h */ case    1:  		/* addi R27, R27, 1 */
		/* 820FAAD8h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 820FAAD8h case    1:*/		return 0x820FAADC;
		  /* 820FAADCh */ case    2:  		/* addi R26, R26, 4 */
		/* 820FAADCh case    2:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 820FAADCh case    2:*/		return 0x820FAAE0;
		  /* 820FAAE0h */ case    3:  		/* cmplw CR6, R27, R11 */
		/* 820FAAE0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 820FAAE0h case    3:*/		return 0x820FAAE4;
		  /* 820FAAE4h */ case    4:  		/* bc 12, CR6_LT, -340 */
		/* 820FAAE4h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FA990;  }
		/* 820FAAE4h case    4:*/		return 0x820FAAE8;
	}
	return 0x820FAAE8;
} // Block from 820FAAD4h-820FAAE8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FAAE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAAE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAAE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAAE8);
		  /* 820FAAE8h */ case    0:  		/* mr R3, R31 */
		/* 820FAAE8h case    0:*/		regs.R3 = regs.R31;
		/* 820FAAE8h case    0:*/		return 0x820FAAEC;
		  /* 820FAAECh */ case    1:  		/* bl 50556 */
		/* 820FAAECh case    1:*/		regs.LR = 0x820FAAF0; return 0x82107068;
		/* 820FAAECh case    1:*/		return 0x820FAAF0;
		  /* 820FAAF0h */ case    2:  		/* or. R30, R3, R3 */
		/* 820FAAF0h case    2:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FAAF0h case    2:*/		return 0x820FAAF4;
		  /* 820FAAF4h */ case    3:  		/* bc 12, CR0_LT, 1364 */
		/* 820FAAF4h case    3:*/		if ( regs.CR[0].lt ) { return 0x820FB048;  }
		/* 820FAAF4h case    3:*/		return 0x820FAAF8;
		  /* 820FAAF8h */ case    4:  		/* mr R3, R31 */
		/* 820FAAF8h case    4:*/		regs.R3 = regs.R31;
		/* 820FAAF8h case    4:*/		return 0x820FAAFC;
		  /* 820FAAFCh */ case    5:  		/* bl -90908 */
		/* 820FAAFCh case    5:*/		regs.LR = 0x820FAB00; return 0x820E47E0;
		/* 820FAAFCh case    5:*/		return 0x820FAB00;
	}
	return 0x820FAB00;
} // Block from 820FAAE8h-820FAB00h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FAB00h
// Function '?ValidateArguments@C30Program@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAB00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAB00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAB00);
		  /* 820FAB00h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FAB00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FAB00h case    0:*/		return 0x820FAB04;
		  /* 820FAB04h */ case    1:  		/* li R29, 0 */
		/* 820FAB04h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820FAB04h case    1:*/		return 0x820FAB08;
		  /* 820FAB08h */ case    2:  		/* lis R25, 29520 */
		/* 820FAB08h case    2:*/		cpu::op::lis<0>(regs,&regs.R25,0x7350);
		/* 820FAB08h case    2:*/		return 0x820FAB0C;
		  /* 820FAB0Ch */ case    3:  		/* lis R26, 29536 */
		/* 820FAB0Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R26,0x7360);
		/* 820FAB0Ch case    3:*/		return 0x820FAB10;
		  /* 820FAB10h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820FAB10h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FAB10h case    4:*/		return 0x820FAB14;
		  /* 820FAB14h */ case    5:  		/* bc 4, CR6_GT, 232 */
		/* 820FAB14h case    5:*/		if ( !regs.CR[6].gt ) { return 0x820FABFC;  }
		/* 820FAB14h case    5:*/		return 0x820FAB18;
		  /* 820FAB18h */ case    6:  		/* li R28, 0 */
		/* 820FAB18h case    6:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820FAB18h case    6:*/		return 0x820FAB1C;
		  /* 820FAB1Ch */ case    7:  		/* stw R29, <#[R31 + 256]> */
		/* 820FAB1Ch case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000100) );
		/* 820FAB1Ch case    7:*/		return 0x820FAB20;
		  /* 820FAB20h */ case    8:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FAB20h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FAB20h case    8:*/		return 0x820FAB24;
		  /* 820FAB24h */ case    9:  		/* lwzx R11, <#[R28 + R11]> */
		/* 820FAB24h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820FAB24h case    9:*/		return 0x820FAB28;
		  /* 820FAB28h */ case   10:  		/* stw R11, <#[R31 + 260]> */
		/* 820FAB28h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820FAB28h case   10:*/		return 0x820FAB2C;
		  /* 820FAB2Ch */ case   11:  		/* lwz R11, <#[R11]> */
		/* 820FAB2Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FAB2Ch case   11:*/		return 0x820FAB30;
		  /* 820FAB30h */ case   12:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FAB30h case   12:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FAB30h case   12:*/		return 0x820FAB34;
		  /* 820FAB34h */ case   13:  		/* cmplw CR6, R11, R24 */
		/* 820FAB34h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 820FAB34h case   13:*/		return 0x820FAB38;
		  /* 820FAB38h */ case   14:  		/* bc 12, CR6_EQ, 156 */
		/* 820FAB38h case   14:*/		if ( regs.CR[6].eq ) { return 0x820FABD4;  }
		/* 820FAB38h case   14:*/		return 0x820FAB3C;
		  /* 820FAB3Ch */ case   15:  		/* cmplw CR6, R11, R16 */
		/* 820FAB3Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R16);
		/* 820FAB3Ch case   15:*/		return 0x820FAB40;
	}
	return 0x820FAB40;
} // Block from 820FAB00h-820FAB40h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820FAB40h
// Function '?MatchVFace@C30Program@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAB40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAB40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAB40);
		  /* 820FAB40h */ case    0:  		/* bc 12, CR6_EQ, 124 */
		/* 820FAB40h case    0:*/		if ( regs.CR[6].eq ) { return 0x820FABBC;  }
		/* 820FAB40h case    0:*/		return 0x820FAB44;
		  /* 820FAB44h */ case    1:  		/* cmplw CR6, R11, R18 */
		/* 820FAB44h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R18);
		/* 820FAB44h case    1:*/		return 0x820FAB48;
		  /* 820FAB48h */ case    2:  		/* bc 12, CR6_EQ, 100 */
		/* 820FAB48h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FABAC;  }
		/* 820FAB48h case    2:*/		return 0x820FAB4C;
		  /* 820FAB4Ch */ case    3:  		/* cmplw CR6, R11, R25 */
		/* 820FAB4Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 820FAB4Ch case    3:*/		return 0x820FAB50;
		  /* 820FAB50h */ case    4:  		/* bc 12, CR6_EQ, 64 */
		/* 820FAB50h case    4:*/		if ( regs.CR[6].eq ) { return 0x820FAB90;  }
		/* 820FAB50h case    4:*/		return 0x820FAB54;
		  /* 820FAB54h */ case    5:  		/* cmplw CR6, R11, R26 */
		/* 820FAB54h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 820FAB54h case    5:*/		return 0x820FAB58;
		  /* 820FAB58h */ case    6:  		/* bc 12, CR6_EQ, 56 */
		/* 820FAB58h case    6:*/		if ( regs.CR[6].eq ) { return 0x820FAB90;  }
		/* 820FAB58h case    6:*/		return 0x820FAB5C;
		  /* 820FAB5Ch */ case    7:  		/* cmplw CR6, R11, R22 */
		/* 820FAB5Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R22);
		/* 820FAB5Ch case    7:*/		return 0x820FAB60;
		  /* 820FAB60h */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 820FAB60h case    8:*/		if ( regs.CR[6].eq ) { return 0x820FAB74;  }
		/* 820FAB60h case    8:*/		return 0x820FAB64;
		  /* 820FAB64h */ case    9:  		/* cmplw CR6, R11, R21 */
		/* 820FAB64h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R21);
		/* 820FAB64h case    9:*/		return 0x820FAB68;
		  /* 820FAB68h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 820FAB68h case   10:*/		if ( regs.CR[6].eq ) { return 0x820FAB74;  }
		/* 820FAB68h case   10:*/		return 0x820FAB6C;
		  /* 820FAB6Ch */ case   11:  		/* li R30, 1 */
		/* 820FAB6Ch case   11:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820FAB6Ch case   11:*/		return 0x820FAB70;
		  /* 820FAB70h */ case   12:  		/* b 120 */
		/* 820FAB70h case   12:*/		return 0x820FABE8;
		/* 820FAB70h case   12:*/		return 0x820FAB74;
	}
	return 0x820FAB74;
} // Block from 820FAB40h-820FAB74h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FAB74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAB74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAB74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAB74);
		  /* 820FAB74h */ case    0:  		/* mr R3, R31 */
		/* 820FAB74h case    0:*/		regs.R3 = regs.R31;
		/* 820FAB74h case    0:*/		return 0x820FAB78;
		  /* 820FAB78h */ case    1:  		/* bl -73928 */
		/* 820FAB78h case    1:*/		regs.LR = 0x820FAB7C; return 0x820E8AB0;
		/* 820FAB78h case    1:*/		return 0x820FAB7C;
		  /* 820FAB7Ch */ case    2:  		/* or. R30, R3, R3 */
		/* 820FAB7Ch case    2:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FAB7Ch case    2:*/		return 0x820FAB80;
		  /* 820FAB80h */ case    3:  		/* bc 12, CR0_LT, 1224 */
		/* 820FAB80h case    3:*/		if ( regs.CR[0].lt ) { return 0x820FB048;  }
		/* 820FAB80h case    3:*/		return 0x820FAB84;
		  /* 820FAB84h */ case    4:  		/* mr R3, R31 */
		/* 820FAB84h case    4:*/		regs.R3 = regs.R31;
		/* 820FAB84h case    4:*/		return 0x820FAB88;
		  /* 820FAB88h */ case    5:  		/* bl -73528 */
		/* 820FAB88h case    5:*/		regs.LR = 0x820FAB8C; return 0x820E8C50;
		/* 820FAB88h case    5:*/		return 0x820FAB8C;
		  /* 820FAB8Ch */ case    6:  		/* b 80 */
		/* 820FAB8Ch case    6:*/		return 0x820FABDC;
		/* 820FAB8Ch case    6:*/		return 0x820FAB90;
	}
	return 0x820FAB90;
} // Block from 820FAB74h-820FAB90h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820FAB90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAB90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAB90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAB90);
		  /* 820FAB90h */ case    0:  		/* mr R3, R31 */
		/* 820FAB90h case    0:*/		regs.R3 = regs.R31;
		/* 820FAB90h case    0:*/		return 0x820FAB94;
		  /* 820FAB94h */ case    1:  		/* bl -80852 */
		/* 820FAB94h case    1:*/		regs.LR = 0x820FAB98; return 0x820E6FC0;
		/* 820FAB94h case    1:*/		return 0x820FAB98;
		  /* 820FAB98h */ case    2:  		/* or. R30, R3, R3 */
		/* 820FAB98h case    2:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FAB98h case    2:*/		return 0x820FAB9C;
		  /* 820FAB9Ch */ case    3:  		/* bc 12, CR0_LT, 1196 */
		/* 820FAB9Ch case    3:*/		if ( regs.CR[0].lt ) { return 0x820FB048;  }
		/* 820FAB9Ch case    3:*/		return 0x820FABA0;
		  /* 820FABA0h */ case    4:  		/* mr R3, R31 */
		/* 820FABA0h case    4:*/		regs.R3 = regs.R31;
		/* 820FABA0h case    4:*/		return 0x820FABA4;
		  /* 820FABA4h */ case    5:  		/* bl -80452 */
		/* 820FABA4h case    5:*/		regs.LR = 0x820FABA8; return 0x820E7160;
		/* 820FABA4h case    5:*/		return 0x820FABA8;
		  /* 820FABA8h */ case    6:  		/* b 52 */
		/* 820FABA8h case    6:*/		return 0x820FABDC;
		/* 820FABA8h case    6:*/		return 0x820FABAC;
	}
	return 0x820FABAC;
} // Block from 820FAB90h-820FABACh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820FABACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FABAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FABAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FABAC);
		  /* 820FABACh */ case    0:  		/* li R4, 1 */
		/* 820FABACh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820FABACh case    0:*/		return 0x820FABB0;
		  /* 820FABB0h */ case    1:  		/* mr R3, R31 */
		/* 820FABB0h case    1:*/		regs.R3 = regs.R31;
		/* 820FABB0h case    1:*/		return 0x820FABB4;
		  /* 820FABB4h */ case    2:  		/* bl -67132 */
		/* 820FABB4h case    2:*/		regs.LR = 0x820FABB8; return 0x820EA578;
		/* 820FABB4h case    2:*/		return 0x820FABB8;
		  /* 820FABB8h */ case    3:  		/* b 36 */
		/* 820FABB8h case    3:*/		return 0x820FABDC;
		/* 820FABB8h case    3:*/		return 0x820FABBC;
	}
	return 0x820FABBC;
} // Block from 820FABACh-820FABBCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FABBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FABBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FABBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FABBC);
		  /* 820FABBCh */ case    0:  		/* lwz R11, <#[R31 + 108]> */
		/* 820FABBCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 820FABBCh case    0:*/		return 0x820FABC0;
		  /* 820FABC0h */ case    1:  		/* rlwinm. R11, R11, 0, 6, 6 */
		/* 820FABC0h case    1:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R11,regs.R11);
		/* 820FABC0h case    1:*/		return 0x820FABC4;
		  /* 820FABC4h */ case    2:  		/* bc 12, CR0_EQ, 28 */
		/* 820FABC4h case    2:*/		if ( regs.CR[0].eq ) { return 0x820FABE0;  }
		/* 820FABC4h case    2:*/		return 0x820FABC8;
		  /* 820FABC8h */ case    3:  		/* mr R3, R31 */
		/* 820FABC8h case    3:*/		regs.R3 = regs.R31;
		/* 820FABC8h case    3:*/		return 0x820FABCC;
		  /* 820FABCCh */ case    4:  		/* bl -70540 */
		/* 820FABCCh case    4:*/		regs.LR = 0x820FABD0; return 0x820E9840;
		/* 820FABCCh case    4:*/		return 0x820FABD0;
		  /* 820FABD0h */ case    5:  		/* b 12 */
		/* 820FABD0h case    5:*/		return 0x820FABDC;
		/* 820FABD0h case    5:*/		return 0x820FABD4;
	}
	return 0x820FABD4;
} // Block from 820FABBCh-820FABD4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FABD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FABD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FABD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FABD4);
		  /* 820FABD4h */ case    0:  		/* mr R3, R31 */
		/* 820FABD4h case    0:*/		regs.R3 = regs.R31;
		/* 820FABD4h case    0:*/		return 0x820FABD8;
		  /* 820FABD8h */ case    1:  		/* bl -72120 */
		/* 820FABD8h case    1:*/		regs.LR = 0x820FABDC; return 0x820E9220;
		/* 820FABD8h case    1:*/		return 0x820FABDC;
	}
	return 0x820FABDC;
} // Block from 820FABD4h-820FABDCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FABDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FABDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FABDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FABDC);
		  /* 820FABDCh */ case    0:  		/* mr R30, R3 */
		/* 820FABDCh case    0:*/		regs.R30 = regs.R3;
		/* 820FABDCh case    0:*/		return 0x820FABE0;
	}
	return 0x820FABE0;
} // Block from 820FABDCh-820FABE0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FABE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FABE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FABE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FABE0);
		  /* 820FABE0h */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 820FABE0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820FABE0h case    0:*/		return 0x820FABE4;
		  /* 820FABE4h */ case    1:  		/* bc 12, CR6_LT, 1124 */
		/* 820FABE4h case    1:*/		if ( regs.CR[6].lt ) { return 0x820FB048;  }
		/* 820FABE4h case    1:*/		return 0x820FABE8;
	}
	return 0x820FABE8;
} // Block from 820FABE0h-820FABE8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FABE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FABE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FABE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FABE8);
		  /* 820FABE8h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FABE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FABE8h case    0:*/		return 0x820FABEC;
		  /* 820FABECh */ case    1:  		/* addi R29, R29, 1 */
		/* 820FABECh case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820FABECh case    1:*/		return 0x820FABF0;
		  /* 820FABF0h */ case    2:  		/* addi R28, R28, 4 */
		/* 820FABF0h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820FABF0h case    2:*/		return 0x820FABF4;
		  /* 820FABF4h */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 820FABF4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820FABF4h case    3:*/		return 0x820FABF8;
		  /* 820FABF8h */ case    4:  		/* bc 12, CR6_LT, -220 */
		/* 820FABF8h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FAB1C;  }
		/* 820FABF8h case    4:*/		return 0x820FABFC;
	}
	return 0x820FABFC;
} // Block from 820FABE8h-820FABFCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FABFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FABFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FABFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FABFC);
		  /* 820FABFCh */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FABFCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FABFCh case    0:*/		return 0x820FAC00;
		  /* 820FAC00h */ case    1:  		/* li R29, 0 */
		/* 820FAC00h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820FAC00h case    1:*/		return 0x820FAC04;
		  /* 820FAC04h */ case    2:  		/* lis R27, 29552 */
		/* 820FAC04h case    2:*/		cpu::op::lis<0>(regs,&regs.R27,0x7370);
		/* 820FAC04h case    2:*/		return 0x820FAC08;
		  /* 820FAC08h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820FAC08h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FAC08h case    3:*/		return 0x820FAC0C;
		  /* 820FAC0Ch */ case    4:  		/* bc 4, CR6_GT, 156 */
		/* 820FAC0Ch case    4:*/		if ( !regs.CR[6].gt ) { return 0x820FACA8;  }
		/* 820FAC0Ch case    4:*/		return 0x820FAC10;
		  /* 820FAC10h */ case    5:  		/* li R28, 0 */
		/* 820FAC10h case    5:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820FAC10h case    5:*/		return 0x820FAC14;
		  /* 820FAC14h */ case    6:  		/* stw R29, <#[R31 + 256]> */
		/* 820FAC14h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000100) );
		/* 820FAC14h case    6:*/		return 0x820FAC18;
		  /* 820FAC18h */ case    7:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FAC18h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FAC18h case    7:*/		return 0x820FAC1C;
		  /* 820FAC1Ch */ case    8:  		/* lwzx R11, <#[R28 + R11]> */
		/* 820FAC1Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820FAC1Ch case    8:*/		return 0x820FAC20;
		  /* 820FAC20h */ case    9:  		/* stw R11, <#[R31 + 260]> */
		/* 820FAC20h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820FAC20h case    9:*/		return 0x820FAC24;
		  /* 820FAC24h */ case   10:  		/* lwz R11, <#[R11]> */
		/* 820FAC24h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FAC24h case   10:*/		return 0x820FAC28;
		  /* 820FAC28h */ case   11:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FAC28h case   11:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FAC28h case   11:*/		return 0x820FAC2C;
		  /* 820FAC2Ch */ case   12:  		/* cmplw CR6, R11, R23 */
		/* 820FAC2Ch case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R23);
		/* 820FAC2Ch case   12:*/		return 0x820FAC30;
		  /* 820FAC30h */ case   13:  		/* bc 12, CR6_GT, 56 */
		/* 820FAC30h case   13:*/		if ( regs.CR[6].gt ) { return 0x820FAC68;  }
		/* 820FAC30h case   13:*/		return 0x820FAC34;
		  /* 820FAC34h */ case   14:  		/* bc 12, CR6_EQ, 76 */
		/* 820FAC34h case   14:*/		if ( regs.CR[6].eq ) { return 0x820FAC80;  }
		/* 820FAC34h case   14:*/		return 0x820FAC38;
		  /* 820FAC38h */ case   15:  		/* cmplw CR6, R11, R25 */
		/* 820FAC38h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 820FAC38h case   15:*/		return 0x820FAC3C;
		  /* 820FAC3Ch */ case   16:  		/* bc 12, CR6_EQ, 32 */
		/* 820FAC3Ch case   16:*/		if ( regs.CR[6].eq ) { return 0x820FAC5C;  }
		/* 820FAC3Ch case   16:*/		return 0x820FAC40;
		  /* 820FAC40h */ case   17:  		/* cmplw CR6, R11, R26 */
		/* 820FAC40h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 820FAC40h case   17:*/		return 0x820FAC44;
		  /* 820FAC44h */ case   18:  		/* bc 12, CR6_EQ, 24 */
		/* 820FAC44h case   18:*/		if ( regs.CR[6].eq ) { return 0x820FAC5C;  }
		/* 820FAC44h case   18:*/		return 0x820FAC48;
		  /* 820FAC48h */ case   19:  		/* cmplw CR6, R11, R27 */
		/* 820FAC48h case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 820FAC48h case   19:*/		return 0x820FAC4C;
		  /* 820FAC4Ch */ case   20:  		/* bc 12, CR6_EQ, 16 */
		/* 820FAC4Ch case   20:*/		if ( regs.CR[6].eq ) { return 0x820FAC5C;  }
		/* 820FAC4Ch case   20:*/		return 0x820FAC50;
		  /* 820FAC50h */ case   21:  		/* lis R10, 29568 */
		/* 820FAC50h case   21:*/		cpu::op::lis<0>(regs,&regs.R10,0x7380);
		/* 820FAC50h case   21:*/		return 0x820FAC54;
		  /* 820FAC54h */ case   22:  		/* cmplw CR6, R11, R10 */
		/* 820FAC54h case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FAC54h case   22:*/		return 0x820FAC58;
		  /* 820FAC58h */ case   23:  		/* bc 4, CR6_EQ, 60 */
		/* 820FAC58h case   23:*/		if ( !regs.CR[6].eq ) { return 0x820FAC94;  }
		/* 820FAC58h case   23:*/		return 0x820FAC5C;
	}
	return 0x820FAC5C;
} // Block from 820FABFCh-820FAC5Ch (24 instructions)

//////////////////////////////////////////////////////
// Block at 820FAC5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAC5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAC5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAC5C);
		  /* 820FAC5Ch */ case    0:  		/* mr R3, R31 */
		/* 820FAC5Ch case    0:*/		regs.R3 = regs.R31;
		/* 820FAC5Ch case    0:*/		return 0x820FAC60;
		  /* 820FAC60h */ case    1:  		/* bl -80224 */
		/* 820FAC60h case    1:*/		regs.LR = 0x820FAC64; return 0x820E7300;
		/* 820FAC60h case    1:*/		return 0x820FAC64;
		  /* 820FAC64h */ case    2:  		/* b 36 */
		/* 820FAC64h case    2:*/		return 0x820FAC88;
		/* 820FAC64h case    2:*/		return 0x820FAC68;
	}
	return 0x820FAC68;
} // Block from 820FAC5Ch-820FAC68h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FAC68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAC68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAC68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAC68);
		  /* 820FAC68h */ case    0:  		/* cmplw CR6, R11, R20 */
		/* 820FAC68h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R20);
		/* 820FAC68h case    0:*/		return 0x820FAC6C;
		  /* 820FAC6Ch */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 820FAC6Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820FAC80;  }
		/* 820FAC6Ch case    1:*/		return 0x820FAC70;
		  /* 820FAC70h */ case    2:  		/* cmplw CR6, R11, R22 */
		/* 820FAC70h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R22);
		/* 820FAC70h case    2:*/		return 0x820FAC74;
		  /* 820FAC74h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 820FAC74h case    3:*/		if ( regs.CR[6].eq ) { return 0x820FAC80;  }
		/* 820FAC74h case    3:*/		return 0x820FAC78;
		  /* 820FAC78h */ case    4:  		/* cmplw CR6, R11, R21 */
		/* 820FAC78h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R21);
		/* 820FAC78h case    4:*/		return 0x820FAC7C;
		  /* 820FAC7Ch */ case    5:  		/* bc 4, CR6_EQ, 24 */
		/* 820FAC7Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x820FAC94;  }
		/* 820FAC7Ch case    5:*/		return 0x820FAC80;
	}
	return 0x820FAC80;
} // Block from 820FAC68h-820FAC80h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FAC80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAC80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAC80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAC80);
		  /* 820FAC80h */ case    0:  		/* mr R3, R31 */
		/* 820FAC80h case    0:*/		regs.R3 = regs.R31;
		/* 820FAC80h case    0:*/		return 0x820FAC84;
		  /* 820FAC84h */ case    1:  		/* bl -73364 */
		/* 820FAC84h case    1:*/		regs.LR = 0x820FAC88; return 0x820E8DF0;
		/* 820FAC84h case    1:*/		return 0x820FAC88;
	}
	return 0x820FAC88;
} // Block from 820FAC80h-820FAC88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FAC88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAC88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAC88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAC88);
		  /* 820FAC88h */ case    0:  		/* mr R30, R3 */
		/* 820FAC88h case    0:*/		regs.R30 = regs.R3;
		/* 820FAC88h case    0:*/		return 0x820FAC8C;
		  /* 820FAC8Ch */ case    1:  		/* cmpwi CR6, R3, 0 */
		/* 820FAC8Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820FAC8Ch case    1:*/		return 0x820FAC90;
		  /* 820FAC90h */ case    2:  		/* bc 12, CR6_LT, 952 */
		/* 820FAC90h case    2:*/		if ( regs.CR[6].lt ) { return 0x820FB048;  }
		/* 820FAC90h case    2:*/		return 0x820FAC94;
	}
	return 0x820FAC94;
} // Block from 820FAC88h-820FAC94h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FAC94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAC94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAC94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAC94);
		  /* 820FAC94h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FAC94h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FAC94h case    0:*/		return 0x820FAC98;
		  /* 820FAC98h */ case    1:  		/* addi R29, R29, 1 */
		/* 820FAC98h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820FAC98h case    1:*/		return 0x820FAC9C;
		  /* 820FAC9Ch */ case    2:  		/* addi R28, R28, 4 */
		/* 820FAC9Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820FAC9Ch case    2:*/		return 0x820FACA0;
		  /* 820FACA0h */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 820FACA0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820FACA0h case    3:*/		return 0x820FACA4;
		  /* 820FACA4h */ case    4:  		/* bc 12, CR6_LT, -144 */
		/* 820FACA4h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FAC14;  }
		/* 820FACA4h case    4:*/		return 0x820FACA8;
	}
	return 0x820FACA8;
} // Block from 820FAC94h-820FACA8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FACA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FACA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FACA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FACA8);
		  /* 820FACA8h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FACA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FACA8h case    0:*/		return 0x820FACAC;
		  /* 820FACACh */ case    1:  		/* li R29, 0 */
		/* 820FACACh case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820FACACh case    1:*/		return 0x820FACB0;
		  /* 820FACB0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820FACB0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FACB0h case    2:*/		return 0x820FACB4;
		  /* 820FACB4h */ case    3:  		/* bc 4, CR6_GT, 76 */
		/* 820FACB4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820FAD00;  }
		/* 820FACB4h case    3:*/		return 0x820FACB8;
		  /* 820FACB8h */ case    4:  		/* li R28, 0 */
		/* 820FACB8h case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820FACB8h case    4:*/		return 0x820FACBC;
		  /* 820FACBCh */ case    5:  		/* stw R29, <#[R31 + 256]> */
		/* 820FACBCh case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000100) );
		/* 820FACBCh case    5:*/		return 0x820FACC0;
		  /* 820FACC0h */ case    6:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FACC0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FACC0h case    6:*/		return 0x820FACC4;
		  /* 820FACC4h */ case    7:  		/* lwzx R11, <#[R28 + R11]> */
		/* 820FACC4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820FACC4h case    7:*/		return 0x820FACC8;
		  /* 820FACC8h */ case    8:  		/* stw R11, <#[R31 + 260]> */
		/* 820FACC8h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820FACC8h case    8:*/		return 0x820FACCC;
		  /* 820FACCCh */ case    9:  		/* lwz R11, <#[R11]> */
		/* 820FACCCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FACCCh case    9:*/		return 0x820FACD0;
		  /* 820FACD0h */ case   10:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FACD0h case   10:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FACD0h case   10:*/		return 0x820FACD4;
		  /* 820FACD4h */ case   11:  		/* cmplw CR6, R11, R27 */
		/* 820FACD4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 820FACD4h case   11:*/		return 0x820FACD8;
		  /* 820FACD8h */ case   12:  		/* bc 4, CR6_EQ, 20 */
		/* 820FACD8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820FACEC;  }
		/* 820FACD8h case   12:*/		return 0x820FACDC;
		  /* 820FACDCh */ case   13:  		/* mr R3, R31 */
		/* 820FACDCh case   13:*/		regs.R3 = regs.R31;
		/* 820FACDCh case   13:*/		return 0x820FACE0;
		  /* 820FACE0h */ case   14:  		/* bl -81488 */
		/* 820FACE0h case   14:*/		regs.LR = 0x820FACE4; return 0x820E6E90;
		/* 820FACE0h case   14:*/		return 0x820FACE4;
		  /* 820FACE4h */ case   15:  		/* or. R30, R3, R3 */
		/* 820FACE4h case   15:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FACE4h case   15:*/		return 0x820FACE8;
		  /* 820FACE8h */ case   16:  		/* bc 12, CR0_LT, 864 */
		/* 820FACE8h case   16:*/		if ( regs.CR[0].lt ) { return 0x820FB048;  }
		/* 820FACE8h case   16:*/		return 0x820FACEC;
	}
	return 0x820FACEC;
} // Block from 820FACA8h-820FACECh (17 instructions)

//////////////////////////////////////////////////////
// Block at 820FACECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FACEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FACEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FACEC);
		  /* 820FACECh */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FACECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FACECh case    0:*/		return 0x820FACF0;
		  /* 820FACF0h */ case    1:  		/* addi R29, R29, 1 */
		/* 820FACF0h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820FACF0h case    1:*/		return 0x820FACF4;
		  /* 820FACF4h */ case    2:  		/* addi R28, R28, 4 */
		/* 820FACF4h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820FACF4h case    2:*/		return 0x820FACF8;
		  /* 820FACF8h */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 820FACF8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820FACF8h case    3:*/		return 0x820FACFC;
		  /* 820FACFCh */ case    4:  		/* bc 12, CR6_LT, -64 */
		/* 820FACFCh case    4:*/		if ( regs.CR[6].lt ) { return 0x820FACBC;  }
		/* 820FACFCh case    4:*/		return 0x820FAD00;
	}
	return 0x820FAD00;
} // Block from 820FACECh-820FAD00h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FAD00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAD00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAD00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAD00);
		  /* 820FAD00h */ case    0:  		/* mr R3, R31 */
		/* 820FAD00h case    0:*/		regs.R3 = regs.R31;
		/* 820FAD00h case    0:*/		return 0x820FAD04;
		  /* 820FAD04h */ case    1:  		/* bl -91428 */
		/* 820FAD04h case    1:*/		regs.LR = 0x820FAD08; return 0x820E47E0;
		/* 820FAD04h case    1:*/		return 0x820FAD08;
		  /* 820FAD08h */ case    2:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FAD08h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FAD08h case    2:*/		return 0x820FAD0C;
		  /* 820FAD0Ch */ case    3:  		/* li R29, 0 */
		/* 820FAD0Ch case    3:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820FAD0Ch case    3:*/		return 0x820FAD10;
		  /* 820FAD10h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820FAD10h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FAD10h case    4:*/		return 0x820FAD14;
		  /* 820FAD14h */ case    5:  		/* bc 4, CR6_GT, 100 */
		/* 820FAD14h case    5:*/		if ( !regs.CR[6].gt ) { return 0x820FAD78;  }
		/* 820FAD14h case    5:*/		return 0x820FAD18;
		  /* 820FAD18h */ case    6:  		/* li R28, 0 */
		/* 820FAD18h case    6:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820FAD18h case    6:*/		return 0x820FAD1C;
		  /* 820FAD1Ch */ case    7:  		/* stw R29, <#[R31 + 256]> */
		/* 820FAD1Ch case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000100) );
		/* 820FAD1Ch case    7:*/		return 0x820FAD20;
		  /* 820FAD20h */ case    8:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FAD20h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FAD20h case    8:*/		return 0x820FAD24;
		  /* 820FAD24h */ case    9:  		/* lwzx R11, <#[R28 + R11]> */
		/* 820FAD24h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820FAD24h case    9:*/		return 0x820FAD28;
		  /* 820FAD28h */ case   10:  		/* stw R11, <#[R31 + 260]> */
		/* 820FAD28h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820FAD28h case   10:*/		return 0x820FAD2C;
		  /* 820FAD2Ch */ case   11:  		/* lwz R11, <#[R11]> */
		/* 820FAD2Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FAD2Ch case   11:*/		return 0x820FAD30;
		  /* 820FAD30h */ case   12:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FAD30h case   12:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FAD30h case   12:*/		return 0x820FAD34;
		  /* 820FAD34h */ case   13:  		/* cmplw CR6, R11, R22 */
		/* 820FAD34h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R22);
		/* 820FAD34h case   13:*/		return 0x820FAD38;
		  /* 820FAD38h */ case   14:  		/* bc 12, CR6_EQ, 12 */
		/* 820FAD38h case   14:*/		if ( regs.CR[6].eq ) { return 0x820FAD44;  }
		/* 820FAD38h case   14:*/		return 0x820FAD3C;
		  /* 820FAD3Ch */ case   15:  		/* cmplw CR6, R11, R21 */
		/* 820FAD3Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R21);
		/* 820FAD3Ch case   15:*/		return 0x820FAD40;
		  /* 820FAD40h */ case   16:  		/* bc 4, CR6_EQ, 36 */
		/* 820FAD40h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820FAD64;  }
		/* 820FAD40h case   16:*/		return 0x820FAD44;
	}
	return 0x820FAD44;
} // Block from 820FAD00h-820FAD44h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820FAD44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAD44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAD44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAD44);
		  /* 820FAD44h */ case    0:  		/* mr R3, R31 */
		/* 820FAD44h case    0:*/		regs.R3 = regs.R31;
		/* 820FAD44h case    0:*/		return 0x820FAD48;
		  /* 820FAD48h */ case    1:  		/* bl -74392 */
		/* 820FAD48h case    1:*/		regs.LR = 0x820FAD4C; return 0x820E8AB0;
		/* 820FAD48h case    1:*/		return 0x820FAD4C;
		  /* 820FAD4Ch */ case    2:  		/* or. R30, R3, R3 */
		/* 820FAD4Ch case    2:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FAD4Ch case    2:*/		return 0x820FAD50;
		  /* 820FAD50h */ case    3:  		/* bc 12, CR0_LT, 760 */
		/* 820FAD50h case    3:*/		if ( regs.CR[0].lt ) { return 0x820FB048;  }
		/* 820FAD50h case    3:*/		return 0x820FAD54;
		  /* 820FAD54h */ case    4:  		/* mr R3, R31 */
		/* 820FAD54h case    4:*/		regs.R3 = regs.R31;
		/* 820FAD54h case    4:*/		return 0x820FAD58;
		  /* 820FAD58h */ case    5:  		/* bl -73992 */
		/* 820FAD58h case    5:*/		regs.LR = 0x820FAD5C; return 0x820E8C50;
		/* 820FAD58h case    5:*/		return 0x820FAD5C;
		  /* 820FAD5Ch */ case    6:  		/* or. R30, R3, R3 */
		/* 820FAD5Ch case    6:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FAD5Ch case    6:*/		return 0x820FAD60;
		  /* 820FAD60h */ case    7:  		/* bc 12, CR0_LT, 744 */
		/* 820FAD60h case    7:*/		if ( regs.CR[0].lt ) { return 0x820FB048;  }
		/* 820FAD60h case    7:*/		return 0x820FAD64;
	}
	return 0x820FAD64;
} // Block from 820FAD44h-820FAD64h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820FAD64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAD64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAD64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAD64);
		  /* 820FAD64h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FAD64h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FAD64h case    0:*/		return 0x820FAD68;
		  /* 820FAD68h */ case    1:  		/* addi R29, R29, 1 */
		/* 820FAD68h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820FAD68h case    1:*/		return 0x820FAD6C;
		  /* 820FAD6Ch */ case    2:  		/* addi R28, R28, 4 */
		/* 820FAD6Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820FAD6Ch case    2:*/		return 0x820FAD70;
		  /* 820FAD70h */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 820FAD70h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820FAD70h case    3:*/		return 0x820FAD74;
		  /* 820FAD74h */ case    4:  		/* bc 12, CR6_LT, -88 */
		/* 820FAD74h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FAD1C;  }
		/* 820FAD74h case    4:*/		return 0x820FAD78;
	}
	return 0x820FAD78;
} // Block from 820FAD64h-820FAD78h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FAD78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAD78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAD78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAD78);
		  /* 820FAD78h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FAD78h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FAD78h case    0:*/		return 0x820FAD7C;
		  /* 820FAD7Ch */ case    1:  		/* li R30, 0 */
		/* 820FAD7Ch case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820FAD7Ch case    1:*/		return 0x820FAD80;
		  /* 820FAD80h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820FAD80h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FAD80h case    2:*/		return 0x820FAD84;
		  /* 820FAD84h */ case    3:  		/* bc 4, CR6_GT, 92 */
		/* 820FAD84h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820FADE0;  }
		/* 820FAD84h case    3:*/		return 0x820FAD88;
		  /* 820FAD88h */ case    4:  		/* li R29, 0 */
		/* 820FAD88h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820FAD88h case    4:*/		return 0x820FAD8C;
		  /* 820FAD8Ch */ case    5:  		/* stw R30, <#[R31 + 256]> */
		/* 820FAD8Ch case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000100) );
		/* 820FAD8Ch case    5:*/		return 0x820FAD90;
		  /* 820FAD90h */ case    6:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FAD90h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FAD90h case    6:*/		return 0x820FAD94;
		  /* 820FAD94h */ case    7:  		/* lwzx R11, <#[R29 + R11]> */
		/* 820FAD94h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820FAD94h case    7:*/		return 0x820FAD98;
		  /* 820FAD98h */ case    8:  		/* stw R11, <#[R31 + 260]> */
		/* 820FAD98h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820FAD98h case    8:*/		return 0x820FAD9C;
		  /* 820FAD9Ch */ case    9:  		/* lwz R11, <#[R11]> */
		/* 820FAD9Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FAD9Ch case    9:*/		return 0x820FADA0;
		  /* 820FADA0h */ case   10:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FADA0h case   10:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FADA0h case   10:*/		return 0x820FADA4;
		  /* 820FADA4h */ case   11:  		/* cmplw CR6, R11, R23 */
		/* 820FADA4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R23);
		/* 820FADA4h case   11:*/		return 0x820FADA8;
		  /* 820FADA8h */ case   12:  		/* bc 12, CR6_EQ, 28 */
		/* 820FADA8h case   12:*/		if ( regs.CR[6].eq ) { return 0x820FADC4;  }
		/* 820FADA8h case   12:*/		return 0x820FADAC;
		  /* 820FADACh */ case   13:  		/* cmplw CR6, R11, R20 */
		/* 820FADACh case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R20);
		/* 820FADACh case   13:*/		return 0x820FADB0;
		  /* 820FADB0h */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 820FADB0h case   14:*/		if ( regs.CR[6].eq ) { return 0x820FADC4;  }
		/* 820FADB0h case   14:*/		return 0x820FADB4;
		  /* 820FADB4h */ case   15:  		/* cmplw CR6, R11, R22 */
		/* 820FADB4h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R22);
		/* 820FADB4h case   15:*/		return 0x820FADB8;
		  /* 820FADB8h */ case   16:  		/* bc 12, CR6_EQ, 12 */
		/* 820FADB8h case   16:*/		if ( regs.CR[6].eq ) { return 0x820FADC4;  }
		/* 820FADB8h case   16:*/		return 0x820FADBC;
		  /* 820FADBCh */ case   17:  		/* cmplw CR6, R11, R21 */
		/* 820FADBCh case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R21);
		/* 820FADBCh case   17:*/		return 0x820FADC0;
		  /* 820FADC0h */ case   18:  		/* bc 4, CR6_EQ, 12 */
		/* 820FADC0h case   18:*/		if ( !regs.CR[6].eq ) { return 0x820FADCC;  }
		/* 820FADC0h case   18:*/		return 0x820FADC4;
	}
	return 0x820FADC4;
} // Block from 820FAD78h-820FADC4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820FADC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FADC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FADC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FADC4);
		  /* 820FADC4h */ case    0:  		/* mr R3, R31 */
		/* 820FADC4h case    0:*/		regs.R3 = regs.R31;
		/* 820FADC4h case    0:*/		return 0x820FADC8;
		  /* 820FADC8h */ case    1:  		/* bl -73688 */
		/* 820FADC8h case    1:*/		regs.LR = 0x820FADCC; return 0x820E8DF0;
		/* 820FADC8h case    1:*/		return 0x820FADCC;
	}
	return 0x820FADCC;
} // Block from 820FADC4h-820FADCCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FADCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FADCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FADCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FADCC);
		  /* 820FADCCh */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FADCCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FADCCh case    0:*/		return 0x820FADD0;
		  /* 820FADD0h */ case    1:  		/* addi R30, R30, 1 */
		/* 820FADD0h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820FADD0h case    1:*/		return 0x820FADD4;
		  /* 820FADD4h */ case    2:  		/* addi R29, R29, 4 */
		/* 820FADD4h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820FADD4h case    2:*/		return 0x820FADD8;
		  /* 820FADD8h */ case    3:  		/* cmplw CR6, R30, R11 */
		/* 820FADD8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820FADD8h case    3:*/		return 0x820FADDC;
		  /* 820FADDCh */ case    4:  		/* bc 12, CR6_LT, -80 */
		/* 820FADDCh case    4:*/		if ( regs.CR[6].lt ) { return 0x820FAD8C;  }
		/* 820FADDCh case    4:*/		return 0x820FADE0;
	}
	return 0x820FADE0;
} // Block from 820FADCCh-820FADE0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FADE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FADE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FADE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FADE0);
		  /* 820FADE0h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FADE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FADE0h case    0:*/		return 0x820FADE4;
		  /* 820FADE4h */ case    1:  		/* li R29, 0 */
		/* 820FADE4h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820FADE4h case    1:*/		return 0x820FADE8;
		  /* 820FADE8h */ case    2:  		/* lis R27, 8336 */
		/* 820FADE8h case    2:*/		cpu::op::lis<0>(regs,&regs.R27,0x2090);
		/* 820FADE8h case    2:*/		return 0x820FADEC;
		  /* 820FADECh */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820FADECh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FADECh case    3:*/		return 0x820FADF0;
		  /* 820FADF0h */ case    4:  		/* bc 4, CR6_GT, 76 */
		/* 820FADF0h case    4:*/		if ( !regs.CR[6].gt ) { return 0x820FAE3C;  }
		/* 820FADF0h case    4:*/		return 0x820FADF4;
		  /* 820FADF4h */ case    5:  		/* li R28, 0 */
		/* 820FADF4h case    5:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820FADF4h case    5:*/		return 0x820FADF8;
		  /* 820FADF8h */ case    6:  		/* stw R29, <#[R31 + 256]> */
		/* 820FADF8h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000100) );
		/* 820FADF8h case    6:*/		return 0x820FADFC;
		  /* 820FADFCh */ case    7:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FADFCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FADFCh case    7:*/		return 0x820FAE00;
		  /* 820FAE00h */ case    8:  		/* lwzx R11, <#[R28 + R11]> */
		/* 820FAE00h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820FAE00h case    8:*/		return 0x820FAE04;
		  /* 820FAE04h */ case    9:  		/* stw R11, <#[R31 + 260]> */
		/* 820FAE04h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820FAE04h case    9:*/		return 0x820FAE08;
		  /* 820FAE08h */ case   10:  		/* lwz R11, <#[R11]> */
		/* 820FAE08h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FAE08h case   10:*/		return 0x820FAE0C;
		  /* 820FAE0Ch */ case   11:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FAE0Ch case   11:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FAE0Ch case   11:*/		return 0x820FAE10;
		  /* 820FAE10h */ case   12:  		/* cmplw CR6, R11, R27 */
		/* 820FAE10h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 820FAE10h case   12:*/		return 0x820FAE14;
		  /* 820FAE14h */ case   13:  		/* bc 4, CR6_EQ, 20 */
		/* 820FAE14h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820FAE28;  }
		/* 820FAE14h case   13:*/		return 0x820FAE18;
		  /* 820FAE18h */ case   14:  		/* mr R3, R31 */
		/* 820FAE18h case   14:*/		regs.R3 = regs.R31;
		/* 820FAE18h case   14:*/		return 0x820FAE1C;
		  /* 820FAE1Ch */ case   15:  		/* bl -77172 */
		/* 820FAE1Ch case   15:*/		regs.LR = 0x820FAE20; return 0x820E80A8;
		/* 820FAE1Ch case   15:*/		return 0x820FAE20;
		  /* 820FAE20h */ case   16:  		/* or. R30, R3, R3 */
		/* 820FAE20h case   16:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FAE20h case   16:*/		return 0x820FAE24;
		  /* 820FAE24h */ case   17:  		/* bc 12, CR0_LT, 548 */
		/* 820FAE24h case   17:*/		if ( regs.CR[0].lt ) { return 0x820FB048;  }
		/* 820FAE24h case   17:*/		return 0x820FAE28;
	}
	return 0x820FAE28;
} // Block from 820FADE0h-820FAE28h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820FAE28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAE28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAE28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAE28);
		  /* 820FAE28h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FAE28h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FAE28h case    0:*/		return 0x820FAE2C;
		  /* 820FAE2Ch */ case    1:  		/* addi R29, R29, 1 */
		/* 820FAE2Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820FAE2Ch case    1:*/		return 0x820FAE30;
		  /* 820FAE30h */ case    2:  		/* addi R28, R28, 4 */
		/* 820FAE30h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820FAE30h case    2:*/		return 0x820FAE34;
		  /* 820FAE34h */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 820FAE34h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820FAE34h case    3:*/		return 0x820FAE38;
		  /* 820FAE38h */ case    4:  		/* bc 12, CR6_LT, -64 */
		/* 820FAE38h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FADF8;  }
		/* 820FAE38h case    4:*/		return 0x820FAE3C;
	}
	return 0x820FAE3C;
} // Block from 820FAE28h-820FAE3Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FAE3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAE3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAE3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAE3C);
		  /* 820FAE3Ch */ case    0:  		/* mr R3, R31 */
		/* 820FAE3Ch case    0:*/		regs.R3 = regs.R31;
		/* 820FAE3Ch case    0:*/		return 0x820FAE40;
		  /* 820FAE40h */ case    1:  		/* bl -91744 */
		/* 820FAE40h case    1:*/		regs.LR = 0x820FAE44; return 0x820E47E0;
		/* 820FAE40h case    1:*/		return 0x820FAE44;
		  /* 820FAE44h */ case    2:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FAE44h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FAE44h case    2:*/		return 0x820FAE48;
		  /* 820FAE48h */ case    3:  		/* li R29, 0 */
		/* 820FAE48h case    3:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820FAE48h case    3:*/		return 0x820FAE4C;
		  /* 820FAE4Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820FAE4Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FAE4Ch case    4:*/		return 0x820FAE50;
	}
	return 0x820FAE50;
} // Block from 820FAE3Ch-820FAE50h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FAE50h
// Function '?ViolatesPortConstraints@C30SWProgram@D3DXShader@@MAAHPAVCInstruction@2@PAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAE50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAE50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAE50);
		  /* 820FAE50h */ case    0:  		/* bc 4, CR6_GT, 76 */
		/* 820FAE50h case    0:*/		if ( !regs.CR[6].gt ) { return 0x820FAE9C;  }
		/* 820FAE50h case    0:*/		return 0x820FAE54;
		  /* 820FAE54h */ case    1:  		/* li R28, 0 */
		/* 820FAE54h case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820FAE54h case    1:*/		return 0x820FAE58;
		  /* 820FAE58h */ case    2:  		/* stw R29, <#[R31 + 256]> */
		/* 820FAE58h case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000100) );
		/* 820FAE58h case    2:*/		return 0x820FAE5C;
		  /* 820FAE5Ch */ case    3:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FAE5Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FAE5Ch case    3:*/		return 0x820FAE60;
		  /* 820FAE60h */ case    4:  		/* lwzx R11, <#[R28 + R11]> */
		/* 820FAE60h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820FAE60h case    4:*/		return 0x820FAE64;
		  /* 820FAE64h */ case    5:  		/* stw R11, <#[R31 + 260]> */
		/* 820FAE64h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820FAE64h case    5:*/		return 0x820FAE68;
		  /* 820FAE68h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 820FAE68h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FAE68h case    6:*/		return 0x820FAE6C;
		  /* 820FAE6Ch */ case    7:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FAE6Ch case    7:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FAE6Ch case    7:*/		return 0x820FAE70;
		  /* 820FAE70h */ case    8:  		/* cmplw CR6, R11, R27 */
		/* 820FAE70h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 820FAE70h case    8:*/		return 0x820FAE74;
		  /* 820FAE74h */ case    9:  		/* bc 4, CR6_EQ, 20 */
		/* 820FAE74h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820FAE88;  }
		/* 820FAE74h case    9:*/		return 0x820FAE78;
		  /* 820FAE78h */ case   10:  		/* mr R3, R31 */
		/* 820FAE78h case   10:*/		regs.R3 = regs.R31;
		/* 820FAE78h case   10:*/		return 0x820FAE7C;
		  /* 820FAE7Ch */ case   11:  		/* bl -78900 */
		/* 820FAE7Ch case   11:*/		regs.LR = 0x820FAE80; return 0x820E7A48;
		/* 820FAE7Ch case   11:*/		return 0x820FAE80;
		  /* 820FAE80h */ case   12:  		/* or. R30, R3, R3 */
		/* 820FAE80h case   12:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FAE80h case   12:*/		return 0x820FAE84;
		  /* 820FAE84h */ case   13:  		/* bc 12, CR0_LT, 452 */
		/* 820FAE84h case   13:*/		if ( regs.CR[0].lt ) { return 0x820FB048;  }
		/* 820FAE84h case   13:*/		return 0x820FAE88;
	}
	return 0x820FAE88;
} // Block from 820FAE50h-820FAE88h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820FAE88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAE88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAE88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAE88);
		  /* 820FAE88h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FAE88h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FAE88h case    0:*/		return 0x820FAE8C;
		  /* 820FAE8Ch */ case    1:  		/* addi R29, R29, 1 */
		/* 820FAE8Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820FAE8Ch case    1:*/		return 0x820FAE90;
		  /* 820FAE90h */ case    2:  		/* addi R28, R28, 4 */
		/* 820FAE90h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820FAE90h case    2:*/		return 0x820FAE94;
		  /* 820FAE94h */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 820FAE94h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820FAE94h case    3:*/		return 0x820FAE98;
		  /* 820FAE98h */ case    4:  		/* bc 12, CR6_LT, -64 */
		/* 820FAE98h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FAE58;  }
		/* 820FAE98h case    4:*/		return 0x820FAE9C;
	}
	return 0x820FAE9C;
} // Block from 820FAE88h-820FAE9Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FAE9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAE9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAE9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAE9C);
		  /* 820FAE9Ch */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FAE9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FAE9Ch case    0:*/		return 0x820FAEA0;
		  /* 820FAEA0h */ case    1:  		/* li R29, 0 */
		/* 820FAEA0h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820FAEA0h case    1:*/		return 0x820FAEA4;
		  /* 820FAEA4h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820FAEA4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FAEA4h case    2:*/		return 0x820FAEA8;
		  /* 820FAEA8h */ case    3:  		/* bc 4, CR6_GT, 76 */
		/* 820FAEA8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820FAEF4;  }
		/* 820FAEA8h case    3:*/		return 0x820FAEAC;
		  /* 820FAEACh */ case    4:  		/* li R28, 0 */
		/* 820FAEACh case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820FAEACh case    4:*/		return 0x820FAEB0;
		  /* 820FAEB0h */ case    5:  		/* stw R29, <#[R31 + 256]> */
		/* 820FAEB0h case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000100) );
		/* 820FAEB0h case    5:*/		return 0x820FAEB4;
		  /* 820FAEB4h */ case    6:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FAEB4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FAEB4h case    6:*/		return 0x820FAEB8;
		  /* 820FAEB8h */ case    7:  		/* lwzx R11, <#[R28 + R11]> */
		/* 820FAEB8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820FAEB8h case    7:*/		return 0x820FAEBC;
		  /* 820FAEBCh */ case    8:  		/* stw R11, <#[R31 + 260]> */
		/* 820FAEBCh case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820FAEBCh case    8:*/		return 0x820FAEC0;
		  /* 820FAEC0h */ case    9:  		/* lwz R11, <#[R11]> */
		/* 820FAEC0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FAEC0h case    9:*/		return 0x820FAEC4;
		  /* 820FAEC4h */ case   10:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FAEC4h case   10:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FAEC4h case   10:*/		return 0x820FAEC8;
		  /* 820FAEC8h */ case   11:  		/* cmplw CR6, R11, R19 */
		/* 820FAEC8h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R19);
		/* 820FAEC8h case   11:*/		return 0x820FAECC;
		  /* 820FAECCh */ case   12:  		/* bc 4, CR6_EQ, 20 */
		/* 820FAECCh case   12:*/		if ( !regs.CR[6].eq ) { return 0x820FAEE0;  }
		/* 820FAECCh case   12:*/		return 0x820FAED0;
		  /* 820FAED0h */ case   13:  		/* mr R3, R31 */
		/* 820FAED0h case   13:*/		regs.R3 = regs.R31;
		/* 820FAED0h case   13:*/		return 0x820FAED4;
		  /* 820FAED4h */ case   14:  		/* bl -91436 */
		/* 820FAED4h case   14:*/		regs.LR = 0x820FAED8; return 0x820E49A8;
		/* 820FAED4h case   14:*/		return 0x820FAED8;
		  /* 820FAED8h */ case   15:  		/* or. R30, R3, R3 */
		/* 820FAED8h case   15:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FAED8h case   15:*/		return 0x820FAEDC;
		  /* 820FAEDCh */ case   16:  		/* bc 12, CR0_LT, 364 */
		/* 820FAEDCh case   16:*/		if ( regs.CR[0].lt ) { return 0x820FB048;  }
		/* 820FAEDCh case   16:*/		return 0x820FAEE0;
	}
	return 0x820FAEE0;
} // Block from 820FAE9Ch-820FAEE0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820FAEE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAEE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAEE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAEE0);
		  /* 820FAEE0h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FAEE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FAEE0h case    0:*/		return 0x820FAEE4;
		  /* 820FAEE4h */ case    1:  		/* addi R29, R29, 1 */
		/* 820FAEE4h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820FAEE4h case    1:*/		return 0x820FAEE8;
		  /* 820FAEE8h */ case    2:  		/* addi R28, R28, 4 */
		/* 820FAEE8h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820FAEE8h case    2:*/		return 0x820FAEEC;
		  /* 820FAEECh */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 820FAEECh case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820FAEECh case    3:*/		return 0x820FAEF0;
		  /* 820FAEF0h */ case    4:  		/* bc 12, CR6_LT, -64 */
		/* 820FAEF0h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FAEB0;  }
		/* 820FAEF0h case    4:*/		return 0x820FAEF4;
	}
	return 0x820FAEF4;
} // Block from 820FAEE0h-820FAEF4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FAEF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAEF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAEF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAEF4);
		  /* 820FAEF4h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FAEF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FAEF4h case    0:*/		return 0x820FAEF8;
		  /* 820FAEF8h */ case    1:  		/* li R29, 0 */
		/* 820FAEF8h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820FAEF8h case    1:*/		return 0x820FAEFC;
		  /* 820FAEFCh */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820FAEFCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FAEFCh case    2:*/		return 0x820FAF00;
		  /* 820FAF00h */ case    3:  		/* bc 4, CR6_GT, 80 */
		/* 820FAF00h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820FAF50;  }
		/* 820FAF00h case    3:*/		return 0x820FAF04;
		  /* 820FAF04h */ case    4:  		/* li R28, 0 */
		/* 820FAF04h case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820FAF04h case    4:*/		return 0x820FAF08;
		  /* 820FAF08h */ case    5:  		/* stw R29, <#[R31 + 256]> */
		/* 820FAF08h case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000100) );
		/* 820FAF08h case    5:*/		return 0x820FAF0C;
		  /* 820FAF0Ch */ case    6:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FAF0Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FAF0Ch case    6:*/		return 0x820FAF10;
		  /* 820FAF10h */ case    7:  		/* lwzx R11, <#[R28 + R11]> */
		/* 820FAF10h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820FAF10h case    7:*/		return 0x820FAF14;
		  /* 820FAF14h */ case    8:  		/* stw R11, <#[R31 + 260]> */
		/* 820FAF14h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820FAF14h case    8:*/		return 0x820FAF18;
		  /* 820FAF18h */ case    9:  		/* lwz R11, <#[R11]> */
		/* 820FAF18h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FAF18h case    9:*/		return 0x820FAF1C;
		  /* 820FAF1Ch */ case   10:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FAF1Ch case   10:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FAF1Ch case   10:*/		return 0x820FAF20;
		  /* 820FAF20h */ case   11:  		/* cmplw CR6, R11, R18 */
		/* 820FAF20h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R18);
		/* 820FAF20h case   11:*/		return 0x820FAF24;
		  /* 820FAF24h */ case   12:  		/* bc 4, CR6_EQ, 24 */
		/* 820FAF24h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820FAF3C;  }
		/* 820FAF24h case   12:*/		return 0x820FAF28;
		  /* 820FAF28h */ case   13:  		/* li R4, 0 */
		/* 820FAF28h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820FAF28h case   13:*/		return 0x820FAF2C;
		  /* 820FAF2Ch */ case   14:  		/* mr R3, R31 */
		/* 820FAF2Ch case   14:*/		regs.R3 = regs.R31;
		/* 820FAF2Ch case   14:*/		return 0x820FAF30;
		  /* 820FAF30h */ case   15:  		/* bl -68024 */
		/* 820FAF30h case   15:*/		regs.LR = 0x820FAF34; return 0x820EA578;
		/* 820FAF30h case   15:*/		return 0x820FAF34;
		  /* 820FAF34h */ case   16:  		/* or. R30, R3, R3 */
		/* 820FAF34h case   16:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FAF34h case   16:*/		return 0x820FAF38;
		  /* 820FAF38h */ case   17:  		/* bc 12, CR0_LT, 272 */
		/* 820FAF38h case   17:*/		if ( regs.CR[0].lt ) { return 0x820FB048;  }
		/* 820FAF38h case   17:*/		return 0x820FAF3C;
	}
	return 0x820FAF3C;
} // Block from 820FAEF4h-820FAF3Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 820FAF3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAF3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAF3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAF3C);
		  /* 820FAF3Ch */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FAF3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FAF3Ch case    0:*/		return 0x820FAF40;
		  /* 820FAF40h */ case    1:  		/* addi R29, R29, 1 */
		/* 820FAF40h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820FAF40h case    1:*/		return 0x820FAF44;
		  /* 820FAF44h */ case    2:  		/* addi R28, R28, 4 */
		/* 820FAF44h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820FAF44h case    2:*/		return 0x820FAF48;
		  /* 820FAF48h */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 820FAF48h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820FAF48h case    3:*/		return 0x820FAF4C;
		  /* 820FAF4Ch */ case    4:  		/* bc 12, CR6_LT, -68 */
		/* 820FAF4Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x820FAF08;  }
		/* 820FAF4Ch case    4:*/		return 0x820FAF50;
	}
	return 0x820FAF50;
} // Block from 820FAF3Ch-820FAF50h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FAF50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAF50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAF50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAF50);
		  /* 820FAF50h */ case    0:  		/* mr R3, R31 */
		/* 820FAF50h case    0:*/		regs.R3 = regs.R31;
		/* 820FAF50h case    0:*/		return 0x820FAF54;
		  /* 820FAF54h */ case    1:  		/* bl -92020 */
		/* 820FAF54h case    1:*/		regs.LR = 0x820FAF58; return 0x820E47E0;
		/* 820FAF54h case    1:*/		return 0x820FAF58;
		  /* 820FAF58h */ case    2:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FAF58h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FAF58h case    2:*/		return 0x820FAF5C;
		  /* 820FAF5Ch */ case    3:  		/* li R29, 0 */
		/* 820FAF5Ch case    3:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820FAF5Ch case    3:*/		return 0x820FAF60;
		  /* 820FAF60h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820FAF60h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FAF60h case    4:*/		return 0x820FAF64;
		  /* 820FAF64h */ case    5:  		/* bc 4, CR6_GT, 144 */
		/* 820FAF64h case    5:*/		if ( !regs.CR[6].gt ) { return 0x820FAFF4;  }
		/* 820FAF64h case    5:*/		return 0x820FAF68;
		  /* 820FAF68h */ case    6:  		/* li R28, 0 */
		/* 820FAF68h case    6:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820FAF68h case    6:*/		return 0x820FAF6C;
		  /* 820FAF6Ch */ case    7:  		/* stw R29, <#[R31 + 256]> */
		/* 820FAF6Ch case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000100) );
		/* 820FAF6Ch case    7:*/		return 0x820FAF70;
		  /* 820FAF70h */ case    8:  		/* lis R10, 4144 */
		/* 820FAF70h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0x1030);
		/* 820FAF70h case    8:*/		return 0x820FAF74;
		  /* 820FAF74h */ case    9:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FAF74h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FAF74h case    9:*/		return 0x820FAF78;
		  /* 820FAF78h */ case   10:  		/* lwzx R11, <#[R28 + R11]> */
		/* 820FAF78h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820FAF78h case   10:*/		return 0x820FAF7C;
		  /* 820FAF7Ch */ case   11:  		/* stw R11, <#[R31 + 260]> */
		/* 820FAF7Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820FAF7Ch case   11:*/		return 0x820FAF80;
		  /* 820FAF80h */ case   12:  		/* lwz R11, <#[R11]> */
		/* 820FAF80h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FAF80h case   12:*/		return 0x820FAF84;
		  /* 820FAF84h */ case   13:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FAF84h case   13:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FAF84h case   13:*/		return 0x820FAF88;
		  /* 820FAF88h */ case   14:  		/* cmplw CR6, R11, R10 */
		/* 820FAF88h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FAF88h case   14:*/		return 0x820FAF8C;
		  /* 820FAF8Ch */ case   15:  		/* bc 12, CR6_EQ, 64 */
		/* 820FAF8Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x820FAFCC;  }
		/* 820FAF8Ch case   15:*/		return 0x820FAF90;
		  /* 820FAF90h */ case   16:  		/* cmplw CR6, R11, R17 */
		/* 820FAF90h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R17);
		/* 820FAF90h case   16:*/		return 0x820FAF94;
		  /* 820FAF94h */ case   17:  		/* bc 12, CR6_EQ, 56 */
		/* 820FAF94h case   17:*/		if ( regs.CR[6].eq ) { return 0x820FAFCC;  }
		/* 820FAF94h case   17:*/		return 0x820FAF98;
		  /* 820FAF98h */ case   18:  		/* lis R10, 4192 */
		/* 820FAF98h case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0x1060);
		/* 820FAF98h case   18:*/		return 0x820FAF9C;
		  /* 820FAF9Ch */ case   19:  		/* cmplw CR6, R11, R10 */
		/* 820FAF9Ch case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FAF9Ch case   19:*/		return 0x820FAFA0;
		  /* 820FAFA0h */ case   20:  		/* bc 12, CR6_EQ, 44 */
		/* 820FAFA0h case   20:*/		if ( regs.CR[6].eq ) { return 0x820FAFCC;  }
		/* 820FAFA0h case   20:*/		return 0x820FAFA4;
		  /* 820FAFA4h */ case   21:  		/* lis R10, 4208 */
		/* 820FAFA4h case   21:*/		cpu::op::lis<0>(regs,&regs.R10,0x1070);
		/* 820FAFA4h case   21:*/		return 0x820FAFA8;
		  /* 820FAFA8h */ case   22:  		/* cmplw CR6, R11, R10 */
		/* 820FAFA8h case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FAFA8h case   22:*/		return 0x820FAFAC;
		  /* 820FAFACh */ case   23:  		/* bc 12, CR6_EQ, 32 */
		/* 820FAFACh case   23:*/		if ( regs.CR[6].eq ) { return 0x820FAFCC;  }
		/* 820FAFACh case   23:*/		return 0x820FAFB0;
		  /* 820FAFB0h */ case   24:  		/* cmplw CR6, R11, R16 */
		/* 820FAFB0h case   24:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R16);
		/* 820FAFB0h case   24:*/		return 0x820FAFB4;
		  /* 820FAFB4h */ case   25:  		/* bc 12, CR6_EQ, 24 */
		/* 820FAFB4h case   25:*/		if ( regs.CR[6].eq ) { return 0x820FAFCC;  }
		/* 820FAFB4h case   25:*/		return 0x820FAFB8;
		  /* 820FAFB8h */ case   26:  		/* cmplw CR6, R11, R18 */
		/* 820FAFB8h case   26:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R18);
		/* 820FAFB8h case   26:*/		return 0x820FAFBC;
		  /* 820FAFBCh */ case   27:  		/* bc 4, CR6_EQ, 36 */
		/* 820FAFBCh case   27:*/		if ( !regs.CR[6].eq ) { return 0x820FAFE0;  }
		/* 820FAFBCh case   27:*/		return 0x820FAFC0;
		  /* 820FAFC0h */ case   28:  		/* mr R3, R31 */
		/* 820FAFC0h case   28:*/		regs.R3 = regs.R31;
		/* 820FAFC0h case   28:*/		return 0x820FAFC4;
		  /* 820FAFC4h */ case   29:  		/* bl -42996 */
		/* 820FAFC4h case   29:*/		regs.LR = 0x820FAFC8; return 0x820F07D0;
		/* 820FAFC4h case   29:*/		return 0x820FAFC8;
		  /* 820FAFC8h */ case   30:  		/* b 12 */
		/* 820FAFC8h case   30:*/		return 0x820FAFD4;
		/* 820FAFC8h case   30:*/		return 0x820FAFCC;
	}
	return 0x820FAFCC;
} // Block from 820FAF50h-820FAFCCh (31 instructions)

//////////////////////////////////////////////////////
// Block at 820FAFCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAFCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAFCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAFCC);
		  /* 820FAFCCh */ case    0:  		/* mr R3, R31 */
		/* 820FAFCCh case    0:*/		regs.R3 = regs.R31;
		/* 820FAFCCh case    0:*/		return 0x820FAFD0;
		  /* 820FAFD0h */ case    1:  		/* bl -84976 */
		/* 820FAFD0h case    1:*/		regs.LR = 0x820FAFD4; return 0x820E63E0;
		/* 820FAFD0h case    1:*/		return 0x820FAFD4;
	}
	return 0x820FAFD4;
} // Block from 820FAFCCh-820FAFD4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FAFD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAFD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAFD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAFD4);
		  /* 820FAFD4h */ case    0:  		/* mr R30, R3 */
		/* 820FAFD4h case    0:*/		regs.R30 = regs.R3;
		/* 820FAFD4h case    0:*/		return 0x820FAFD8;
		  /* 820FAFD8h */ case    1:  		/* cmpwi CR6, R3, 0 */
		/* 820FAFD8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820FAFD8h case    1:*/		return 0x820FAFDC;
		  /* 820FAFDCh */ case    2:  		/* bc 12, CR6_LT, 108 */
		/* 820FAFDCh case    2:*/		if ( regs.CR[6].lt ) { return 0x820FB048;  }
		/* 820FAFDCh case    2:*/		return 0x820FAFE0;
	}
	return 0x820FAFE0;
} // Block from 820FAFD4h-820FAFE0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FAFE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAFE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAFE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAFE0);
		  /* 820FAFE0h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FAFE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FAFE0h case    0:*/		return 0x820FAFE4;
		  /* 820FAFE4h */ case    1:  		/* addi R29, R29, 1 */
		/* 820FAFE4h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820FAFE4h case    1:*/		return 0x820FAFE8;
		  /* 820FAFE8h */ case    2:  		/* addi R28, R28, 4 */
		/* 820FAFE8h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820FAFE8h case    2:*/		return 0x820FAFEC;
		  /* 820FAFECh */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 820FAFECh case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820FAFECh case    3:*/		return 0x820FAFF0;
		  /* 820FAFF0h */ case    4:  		/* bc 12, CR6_LT, -132 */
		/* 820FAFF0h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FAF6C;  }
		/* 820FAFF0h case    4:*/		return 0x820FAFF4;
	}
	return 0x820FAFF4;
} // Block from 820FAFE0h-820FAFF4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FAFF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FAFF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FAFF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FAFF4);
		  /* 820FAFF4h */ case    0:  		/* mr R3, R31 */
		/* 820FAFF4h case    0:*/		regs.R3 = regs.R31;
		/* 820FAFF4h case    0:*/		return 0x820FAFF8;
		  /* 820FAFF8h */ case    1:  		/* bl -92184 */
		/* 820FAFF8h case    1:*/		regs.LR = 0x820FAFFC; return 0x820E47E0;
		/* 820FAFF8h case    1:*/		return 0x820FAFFC;
		  /* 820FAFFCh */ case    2:  		/* mr R3, R31 */
		/* 820FAFFCh case    2:*/		regs.R3 = regs.R31;
		/* 820FAFFCh case    2:*/		return 0x820FB000;
		  /* 820FB000h */ case    3:  		/* bl 49256 */
		/* 820FB000h case    3:*/		regs.LR = 0x820FB004; return 0x82107068;
		/* 820FB000h case    3:*/		return 0x820FB004;
		  /* 820FB004h */ case    4:  		/* or. R30, R3, R3 */
		/* 820FB004h case    4:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FB004h case    4:*/		return 0x820FB008;
		  /* 820FB008h */ case    5:  		/* bc 12, CR0_LT, 64 */
		/* 820FB008h case    5:*/		if ( regs.CR[0].lt ) { return 0x820FB048;  }
		/* 820FB008h case    5:*/		return 0x820FB00C;
		  /* 820FB00Ch */ case    6:  		/* mr R3, R31 */
		/* 820FB00Ch case    6:*/		regs.R3 = regs.R31;
		/* 820FB00Ch case    6:*/		return 0x820FB010;
		  /* 820FB010h */ case    7:  		/* bl 51032 */
		/* 820FB010h case    7:*/		regs.LR = 0x820FB014; return 0x82107768;
		/* 820FB010h case    7:*/		return 0x820FB014;
		  /* 820FB014h */ case    8:  		/* or. R30, R3, R3 */
		/* 820FB014h case    8:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FB014h case    8:*/		return 0x820FB018;
		  /* 820FB018h */ case    9:  		/* bc 12, CR0_LT, 48 */
		/* 820FB018h case    9:*/		if ( regs.CR[0].lt ) { return 0x820FB048;  }
		/* 820FB018h case    9:*/		return 0x820FB01C;
		  /* 820FB01Ch */ case   10:  		/* mr R3, R31 */
		/* 820FB01Ch case   10:*/		regs.R3 = regs.R31;
		/* 820FB01Ch case   10:*/		return 0x820FB020;
		  /* 820FB020h */ case   11:  		/* bl 27712 */
		/* 820FB020h case   11:*/		regs.LR = 0x820FB024; return 0x82101C60;
		/* 820FB020h case   11:*/		return 0x820FB024;
		  /* 820FB024h */ case   12:  		/* or. R30, R3, R3 */
		/* 820FB024h case   12:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FB024h case   12:*/		return 0x820FB028;
		  /* 820FB028h */ case   13:  		/* bc 12, CR0_LT, 32 */
		/* 820FB028h case   13:*/		if ( regs.CR[0].lt ) { return 0x820FB048;  }
		/* 820FB028h case   13:*/		return 0x820FB02C;
		  /* 820FB02Ch */ case   14:  		/* mr R3, R31 */
		/* 820FB02Ch case   14:*/		regs.R3 = regs.R31;
		/* 820FB02Ch case   14:*/		return 0x820FB030;
		  /* 820FB030h */ case   15:  		/* bl 61824 */
		/* 820FB030h case   15:*/		regs.LR = 0x820FB034; return 0x8210A1B0;
		/* 820FB030h case   15:*/		return 0x820FB034;
		  /* 820FB034h */ case   16:  		/* or. R30, R3, R3 */
		/* 820FB034h case   16:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FB034h case   16:*/		return 0x820FB038;
		  /* 820FB038h */ case   17:  		/* bc 12, CR0_LT, 16 */
		/* 820FB038h case   17:*/		if ( regs.CR[0].lt ) { return 0x820FB048;  }
		/* 820FB038h case   17:*/		return 0x820FB03C;
		  /* 820FB03Ch */ case   18:  		/* mr R3, R31 */
		/* 820FB03Ch case   18:*/		regs.R3 = regs.R31;
		/* 820FB03Ch case   18:*/		return 0x820FB040;
		  /* 820FB040h */ case   19:  		/* bl -92256 */
		/* 820FB040h case   19:*/		regs.LR = 0x820FB044; return 0x820E47E0;
		/* 820FB040h case   19:*/		return 0x820FB044;
		  /* 820FB044h */ case   20:  		/* li R30, 0 */
		/* 820FB044h case   20:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820FB044h case   20:*/		return 0x820FB048;
	}
	return 0x820FB048;
} // Block from 820FAFF4h-820FB048h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820FB048h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB048( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB048) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB048);
		  /* 820FB048h */ case    0:  		/* mr R3, R30 */
		/* 820FB048h case    0:*/		regs.R3 = regs.R30;
		/* 820FB048h case    0:*/		return 0x820FB04C;
		  /* 820FB04Ch */ case    1:  		/* addi R1, R1, 224 */
		/* 820FB04Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 820FB04Ch case    1:*/		return 0x820FB050;
		  /* 820FB050h */ case    2:  		/* b -433624 */
		/* 820FB050h case    2:*/		return 0x82091278;
		/* 820FB050h case    2:*/		return 0x820FB054;
		  /* 820FB054h */ case    3:  		/* nop */
		/* 820FB054h case    3:*/		cpu::op::nop();
		/* 820FB054h case    3:*/		return 0x820FB058;
	}
	return 0x820FB058;
} // Block from 820FB048h-820FB058h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FB058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB058);
		  /* 820FB058h */ case    0:  		/* mfspr R12, LR */
		/* 820FB058h case    0:*/		regs.R12 = regs.LR;
		/* 820FB058h case    0:*/		return 0x820FB05C;
		  /* 820FB05Ch */ case    1:  		/* bl -433724 */
		/* 820FB05Ch case    1:*/		regs.LR = 0x820FB060; return 0x82091220;
		/* 820FB05Ch case    1:*/		return 0x820FB060;
		  /* 820FB060h */ case    2:  		/* stwu R1, <#[R1 - 240]> */
		/* 820FB060h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 820FB060h case    2:*/		return 0x820FB064;
		  /* 820FB064h */ case    3:  		/* lwz R11, <#[R3 + 12]> */
		/* 820FB064h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820FB064h case    3:*/		return 0x820FB068;
		  /* 820FB068h */ case    4:  		/* mr R31, R3 */
		/* 820FB068h case    4:*/		regs.R31 = regs.R3;
		/* 820FB068h case    4:*/		return 0x820FB06C;
		  /* 820FB06Ch */ case    5:  		/* li R30, 0 */
		/* 820FB06Ch case    5:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820FB06Ch case    5:*/		return 0x820FB070;
		  /* 820FB070h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820FB070h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FB070h case    6:*/		return 0x820FB074;
		  /* 820FB074h */ case    7:  		/* bc 4, CR6_GT, 52 */
		/* 820FB074h case    7:*/		if ( !regs.CR[6].gt ) { return 0x820FB0A8;  }
		/* 820FB074h case    7:*/		return 0x820FB078;
		  /* 820FB078h */ case    8:  		/* li R29, 0 */
		/* 820FB078h case    8:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820FB078h case    8:*/		return 0x820FB07C;
		  /* 820FB07Ch */ case    9:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FB07Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FB07Ch case    9:*/		return 0x820FB080;
		  /* 820FB080h */ case   10:  		/* mr R3, R31 */
		/* 820FB080h case   10:*/		regs.R3 = regs.R31;
		/* 820FB080h case   10:*/		return 0x820FB084;
		  /* 820FB084h */ case   11:  		/* stw R30, <#[R31 + 256]> */
		/* 820FB084h case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000100) );
		/* 820FB084h case   11:*/		return 0x820FB088;
		  /* 820FB088h */ case   12:  		/* lwzx R11, <#[R11 + R29]> */
		/* 820FB088h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 820FB088h case   12:*/		return 0x820FB08C;
		  /* 820FB08Ch */ case   13:  		/* stw R11, <#[R31 + 260]> */
		/* 820FB08Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820FB08Ch case   13:*/		return 0x820FB090;
		  /* 820FB090h */ case   14:  		/* bl -90056 */
		/* 820FB090h case   14:*/		regs.LR = 0x820FB094; return 0x820E50C8;
		/* 820FB090h case   14:*/		return 0x820FB094;
		  /* 820FB094h */ case   15:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FB094h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FB094h case   15:*/		return 0x820FB098;
		  /* 820FB098h */ case   16:  		/* addi R30, R30, 1 */
		/* 820FB098h case   16:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820FB098h case   16:*/		return 0x820FB09C;
		  /* 820FB09Ch */ case   17:  		/* addi R29, R29, 4 */
		/* 820FB09Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820FB09Ch case   17:*/		return 0x820FB0A0;
		  /* 820FB0A0h */ case   18:  		/* cmplw CR6, R30, R11 */
		/* 820FB0A0h case   18:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820FB0A0h case   18:*/		return 0x820FB0A4;
		  /* 820FB0A4h */ case   19:  		/* bc 12, CR6_LT, -40 */
		/* 820FB0A4h case   19:*/		if ( regs.CR[6].lt ) { return 0x820FB07C;  }
		/* 820FB0A4h case   19:*/		return 0x820FB0A8;
	}
	return 0x820FB0A8;
} // Block from 820FB058h-820FB0A8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820FB0A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB0A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB0A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB0A8);
		  /* 820FB0A8h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FB0A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FB0A8h case    0:*/		return 0x820FB0AC;
		  /* 820FB0ACh */ case    1:  		/* li R14, 0 */
		/* 820FB0ACh case    1:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 820FB0ACh case    1:*/		return 0x820FB0B0;
		  /* 820FB0B0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820FB0B0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FB0B0h case    2:*/		return 0x820FB0B4;
		  /* 820FB0B4h */ case    3:  		/* bc 4, CR6_GT, 1788 */
		/* 820FB0B4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820FB7B0;  }
		/* 820FB0B4h case    3:*/		return 0x820FB0B8;
		  /* 820FB0B8h */ case    4:  		/* lis R11, -32768 */
		/* 820FB0B8h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8000);
		/* 820FB0B8h case    4:*/		return 0x820FB0BC;
		  /* 820FB0BCh */ case    5:  		/* lis R29, 24816 */
		/* 820FB0BCh case    5:*/		cpu::op::lis<0>(regs,&regs.R29,0x60F0);
		/* 820FB0BCh case    5:*/		return 0x820FB0C0;
		  /* 820FB0C0h */ case    6:  		/* lis R15, 8304 */
		/* 820FB0C0h case    6:*/		cpu::op::lis<0>(regs,&regs.R15,0x2070);
		/* 820FB0C0h case    6:*/		return 0x820FB0C4;
		  /* 820FB0C4h */ case    7:  		/* lis R16, 4336 */
		/* 820FB0C4h case    7:*/		cpu::op::lis<0>(regs,&regs.R16,0x10F0);
		/* 820FB0C4h case    7:*/		return 0x820FB0C8;
		  /* 820FB0C8h */ case    8:  		/* lis R17, 4176 */
		/* 820FB0C8h case    8:*/		cpu::op::lis<0>(regs,&regs.R17,0x1050);
		/* 820FB0C8h case    8:*/		return 0x820FB0CC;
		  /* 820FB0CCh */ case    9:  		/* ori R30, R11, 16385 */
		/* 820FB0CCh case    9:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R11,0x4001);
		/* 820FB0CCh case    9:*/		return 0x820FB0D0;
		  /* 820FB0D0h */ case   10:  		/* lis R18, 8208 */
		/* 820FB0D0h case   10:*/		cpu::op::lis<0>(regs,&regs.R18,0x2010);
		/* 820FB0D0h case   10:*/		return 0x820FB0D4;
		  /* 820FB0D4h */ case   11:  		/* lis R19, 24640 */
		/* 820FB0D4h case   11:*/		cpu::op::lis<0>(regs,&regs.R19,0x6040);
		/* 820FB0D4h case   11:*/		return 0x820FB0D8;
		  /* 820FB0D8h */ case   12:  		/* lis R20, 20528 */
		/* 820FB0D8h case   12:*/		cpu::op::lis<0>(regs,&regs.R20,0x5030);
		/* 820FB0D8h case   12:*/		return 0x820FB0DC;
		  /* 820FB0DCh */ case   13:  		/* lis R21, 24736 */
		/* 820FB0DCh case   13:*/		cpu::op::lis<0>(regs,&regs.R21,0x60A0);
		/* 820FB0DCh case   13:*/		return 0x820FB0E0;
		  /* 820FB0E0h */ case   14:  		/* lis R22, 29504 */
		/* 820FB0E0h case   14:*/		cpu::op::lis<0>(regs,&regs.R22,0x7340);
		/* 820FB0E0h case   14:*/		return 0x820FB0E4;
		  /* 820FB0E4h */ case   15:  		/* lis R23, 28768 */
		/* 820FB0E4h case   15:*/		cpu::op::lis<0>(regs,&regs.R23,0x7060);
		/* 820FB0E4h case   15:*/		return 0x820FB0E8;
		  /* 820FB0E8h */ case   16:  		/* lis R24, 28688 */
		/* 820FB0E8h case   16:*/		cpu::op::lis<0>(regs,&regs.R24,0x7010);
		/* 820FB0E8h case   16:*/		return 0x820FB0EC;
		  /* 820FB0ECh */ case   17:  		/* lis R25, 28880 */
		/* 820FB0ECh case   17:*/		cpu::op::lis<0>(regs,&regs.R25,0x70D0);
		/* 820FB0ECh case   17:*/		return 0x820FB0F0;
		  /* 820FB0F0h */ case   18:  		/* lis R26, 29680 */
		/* 820FB0F0h case   18:*/		cpu::op::lis<0>(regs,&regs.R26,0x73F0);
		/* 820FB0F0h case   18:*/		return 0x820FB0F4;
		  /* 820FB0F4h */ case   19:  		/* lis R27, 29600 */
		/* 820FB0F4h case   19:*/		cpu::op::lis<0>(regs,&regs.R27,0x73A0);
		/* 820FB0F4h case   19:*/		return 0x820FB0F8;
		  /* 820FB0F8h */ case   20:  		/* lis R28, 29776 */
		/* 820FB0F8h case   20:*/		cpu::op::lis<0>(regs,&regs.R28,0x7450);
		/* 820FB0F8h case   20:*/		return 0x820FB0FC;
		  /* 820FB0FCh */ case   21:  		/* stw R14, <#[R31 + 256]> */
		/* 820FB0FCh case   21:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R31 + 0x00000100) );
		/* 820FB0FCh case   21:*/		return 0x820FB100;
		  /* 820FB100h */ case   22:  		/* rlwinm R11, R14, 2, 0, 29 */
		/* 820FB100h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R14);
		/* 820FB100h case   22:*/		return 0x820FB104;
		  /* 820FB104h */ case   23:  		/* lwz R10, <#[R31 + 24]> */
		/* 820FB104h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820FB104h case   23:*/		return 0x820FB108;
		  /* 820FB108h */ case   24:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820FB108h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FB108h case   24:*/		return 0x820FB10C;
		  /* 820FB10Ch */ case   25:  		/* stw R11, <#[R31 + 260]> */
		/* 820FB10Ch case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820FB10Ch case   25:*/		return 0x820FB110;
		  /* 820FB110h */ case   26:  		/* lwz R11, <#[R11 + 60]> */
		/* 820FB110h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000003C) );
		/* 820FB110h case   26:*/		return 0x820FB114;
		  /* 820FB114h */ case   27:  		/* cmplwi CR6, R11, 0 */
		/* 820FB114h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FB114h case   27:*/		return 0x820FB118;
		  /* 820FB118h */ case   28:  		/* bc 12, CR6_EQ, 24 */
		/* 820FB118h case   28:*/		if ( regs.CR[6].eq ) { return 0x820FB130;  }
		/* 820FB118h case   28:*/		return 0x820FB11C;
		  /* 820FB11Ch */ case   29:  		/* lwz R10, <#[R11 + 4]> */
		/* 820FB11Ch case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820FB11Ch case   29:*/		return 0x820FB120;
		  /* 820FB120h */ case   30:  		/* cmpwi CR6, R10, 14 */
		/* 820FB120h case   30:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000E);
		/* 820FB120h case   30:*/		return 0x820FB124;
		  /* 820FB124h */ case   31:  		/* bc 4, CR6_EQ, 12 */
		/* 820FB124h case   31:*/		if ( !regs.CR[6].eq ) { return 0x820FB130;  }
		/* 820FB124h case   31:*/		return 0x820FB128;
		  /* 820FB128h */ case   32:  		/* addi R11, R11, 48 */
		/* 820FB128h case   32:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x30);
		/* 820FB128h case   32:*/		return 0x820FB12C;
		  /* 820FB12Ch */ case   33:  		/* stw R11, <#[R31 + 264]> */
		/* 820FB12Ch case   33:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000108) );
		/* 820FB12Ch case   33:*/		return 0x820FB130;
	}
	return 0x820FB130;
} // Block from 820FB0A8h-820FB130h (34 instructions)

//////////////////////////////////////////////////////
// Block at 820FB130h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB130);
		  /* 820FB130h */ case    0:  		/* mr R3, R31 */
		/* 820FB130h case    0:*/		regs.R3 = regs.R31;
		/* 820FB130h case    0:*/		return 0x820FB134;
		  /* 820FB134h */ case    1:  		/* bl 290180 */
		/* 820FB134h case    1:*/		regs.LR = 0x820FB138; return 0x82141EB8;
		/* 820FB134h case    1:*/		return 0x820FB138;
		  /* 820FB138h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820FB138h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FB138h case    2:*/		return 0x820FB13C;
		  /* 820FB13Ch */ case    3:  		/* bc 12, CR0_LT, 1656 */
		/* 820FB13Ch case    3:*/		if ( regs.CR[0].lt ) { return 0x820FB7B4;  }
		/* 820FB13Ch case    3:*/		return 0x820FB140;
		  /* 820FB140h */ case    4:  		/* lwz R11, <#[R31 + 260]> */
		/* 820FB140h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820FB140h case    4:*/		return 0x820FB144;
		  /* 820FB144h */ case    5:  		/* lwz R11, <#[R11]> */
		/* 820FB144h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FB144h case    5:*/		return 0x820FB148;
		  /* 820FB148h */ case    6:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FB148h case    6:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FB148h case    6:*/		return 0x820FB14C;
		  /* 820FB14Ch */ case    7:  		/* cmplw CR6, R11, R29 */
		/* 820FB14Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 820FB14Ch case    7:*/		return 0x820FB150;
	}
	return 0x820FB150;
} // Block from 820FB130h-820FB150h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820FB150h
// Function '?EmitAddresses@C30Program@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB150);
		  /* 820FB150h */ case    0:  		/* bc 12, CR6_GT, 896 */
		/* 820FB150h case    0:*/		if ( regs.CR[6].gt ) { return 0x820FB4D0;  }
		/* 820FB150h case    0:*/		return 0x820FB154;
		  /* 820FB154h */ case    1:  		/* bc 12, CR6_EQ, 868 */
		/* 820FB154h case    1:*/		if ( regs.CR[6].eq ) { return 0x820FB4B8;  }
		/* 820FB154h case    1:*/		return 0x820FB158;
		  /* 820FB158h */ case    2:  		/* cmplw CR6, R11, R15 */
		/* 820FB158h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R15);
		/* 820FB158h case    2:*/		return 0x820FB15C;
		  /* 820FB15Ch */ case    3:  		/* bc 12, CR6_GT, 504 */
		/* 820FB15Ch case    3:*/		if ( regs.CR[6].gt ) { return 0x820FB354;  }
		/* 820FB15Ch case    3:*/		return 0x820FB160;
		  /* 820FB160h */ case    4:  		/* bc 12, CR6_EQ, 488 */
		/* 820FB160h case    4:*/		if ( regs.CR[6].eq ) { return 0x820FB348;  }
		/* 820FB160h case    4:*/		return 0x820FB164;
		  /* 820FB164h */ case    5:  		/* cmplw CR6, R11, R16 */
		/* 820FB164h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R16);
		/* 820FB164h case    5:*/		return 0x820FB168;
		  /* 820FB168h */ case    6:  		/* bc 12, CR6_GT, 276 */
		/* 820FB168h case    6:*/		if ( regs.CR[6].gt ) { return 0x820FB27C;  }
		/* 820FB168h case    6:*/		return 0x820FB16C;
		  /* 820FB16Ch */ case    7:  		/* bc 12, CR6_EQ, 1432 */
		/* 820FB16Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x820FB704;  }
		/* 820FB16Ch case    7:*/		return 0x820FB170;
		  /* 820FB170h */ case    8:  		/* cmplw CR6, R11, R17 */
		/* 820FB170h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R17);
		/* 820FB170h case    8:*/		return 0x820FB174;
		  /* 820FB174h */ case    9:  		/* bc 12, CR6_GT, 136 */
		/* 820FB174h case    9:*/		if ( regs.CR[6].gt ) { return 0x820FB1FC;  }
		/* 820FB174h case    9:*/		return 0x820FB178;
		  /* 820FB178h */ case   10:  		/* bc 12, CR6_EQ, 120 */
		/* 820FB178h case   10:*/		if ( regs.CR[6].eq ) { return 0x820FB1F0;  }
		/* 820FB178h case   10:*/		return 0x820FB17C;
		  /* 820FB17Ch */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 820FB17Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FB17Ch case   11:*/		return 0x820FB180;
		  /* 820FB180h */ case   12:  		/* bc 12, CR6_EQ, 100 */
		/* 820FB180h case   12:*/		if ( regs.CR[6].eq ) { return 0x820FB1E4;  }
		/* 820FB180h case   12:*/		return 0x820FB184;
		  /* 820FB184h */ case   13:  		/* lis R10, 4096 */
		/* 820FB184h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0x1000);
		/* 820FB184h case   13:*/		return 0x820FB188;
		  /* 820FB188h */ case   14:  		/* cmplw CR6, R11, R10 */
		/* 820FB188h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB188h case   14:*/		return 0x820FB18C;
		  /* 820FB18Ch */ case   15:  		/* bc 12, CR6_EQ, 76 */
		/* 820FB18Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x820FB1D8;  }
		/* 820FB18Ch case   15:*/		return 0x820FB190;
		  /* 820FB190h */ case   16:  		/* lis R10, 4112 */
		/* 820FB190h case   16:*/		cpu::op::lis<0>(regs,&regs.R10,0x1010);
		/* 820FB190h case   16:*/		return 0x820FB194;
		  /* 820FB194h */ case   17:  		/* cmplw CR6, R11, R10 */
		/* 820FB194h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB194h case   17:*/		return 0x820FB198;
		  /* 820FB198h */ case   18:  		/* bc 12, CR6_EQ, 52 */
		/* 820FB198h case   18:*/		if ( regs.CR[6].eq ) { return 0x820FB1CC;  }
		/* 820FB198h case   18:*/		return 0x820FB19C;
		  /* 820FB19Ch */ case   19:  		/* lis R10, 4144 */
		/* 820FB19Ch case   19:*/		cpu::op::lis<0>(regs,&regs.R10,0x1030);
		/* 820FB19Ch case   19:*/		return 0x820FB1A0;
		  /* 820FB1A0h */ case   20:  		/* cmplw CR6, R11, R10 */
		/* 820FB1A0h case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB1A0h case   20:*/		return 0x820FB1A4;
		  /* 820FB1A4h */ case   21:  		/* bc 12, CR6_EQ, 28 */
		/* 820FB1A4h case   21:*/		if ( regs.CR[6].eq ) { return 0x820FB1C0;  }
		/* 820FB1A4h case   21:*/		return 0x820FB1A8;
		  /* 820FB1A8h */ case   22:  		/* lis R10, 4160 */
		/* 820FB1A8h case   22:*/		cpu::op::lis<0>(regs,&regs.R10,0x1040);
		/* 820FB1A8h case   22:*/		return 0x820FB1AC;
		  /* 820FB1ACh */ case   23:  		/* cmplw CR6, R11, R10 */
		/* 820FB1ACh case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB1ACh case   23:*/		return 0x820FB1B0;
		  /* 820FB1B0h */ case   24:  		/* bc 4, CR6_EQ, 1644 */
		/* 820FB1B0h case   24:*/		if ( !regs.CR[6].eq ) { return 0x820FB81C;  }
		/* 820FB1B0h case   24:*/		return 0x820FB1B4;
		  /* 820FB1B4h */ case   25:  		/* lwz R11, <#[R31]> */
		/* 820FB1B4h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB1B4h case   25:*/		return 0x820FB1B8;
		  /* 820FB1B8h */ case   26:  		/* lwz R11, <#[R11 + 136]> */
		/* 820FB1B8h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000088) );
		/* 820FB1B8h case   26:*/		return 0x820FB1BC;
		  /* 820FB1BCh */ case   27:  		/* b 1488 */
		/* 820FB1BCh case   27:*/		return 0x820FB78C;
		/* 820FB1BCh case   27:*/		return 0x820FB1C0;
	}
	return 0x820FB1C0;
} // Block from 820FB150h-820FB1C0h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820FB1C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB1C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB1C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB1C0);
		  /* 820FB1C0h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB1C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB1C0h case    0:*/		return 0x820FB1C4;
		  /* 820FB1C4h */ case    1:  		/* lwz R11, <#[R11 + 132]> */
		/* 820FB1C4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000084) );
		/* 820FB1C4h case    1:*/		return 0x820FB1C8;
		  /* 820FB1C8h */ case    2:  		/* b 1476 */
		/* 820FB1C8h case    2:*/		return 0x820FB78C;
		/* 820FB1C8h case    2:*/		return 0x820FB1CC;
	}
	return 0x820FB1CC;
} // Block from 820FB1C0h-820FB1CCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB1CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB1CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB1CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB1CC);
		  /* 820FB1CCh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB1CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB1CCh case    0:*/		return 0x820FB1D0;
		  /* 820FB1D0h */ case    1:  		/* lwz R11, <#[R11 + 128]> */
		/* 820FB1D0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000080) );
		/* 820FB1D0h case    1:*/		return 0x820FB1D4;
		  /* 820FB1D4h */ case    2:  		/* b 1464 */
		/* 820FB1D4h case    2:*/		return 0x820FB78C;
		/* 820FB1D4h case    2:*/		return 0x820FB1D8;
	}
	return 0x820FB1D8;
} // Block from 820FB1CCh-820FB1D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB1D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB1D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB1D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB1D8);
		  /* 820FB1D8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB1D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB1D8h case    0:*/		return 0x820FB1DC;
		  /* 820FB1DCh */ case    1:  		/* lwz R11, <#[R11 + 124]> */
		/* 820FB1DCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000007C) );
		/* 820FB1DCh case    1:*/		return 0x820FB1E0;
	}
	return 0x820FB1E0;
} // Block from 820FB1D8h-820FB1E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FB1E0h
// Function '?Translate@C30Program@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB1E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB1E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB1E0);
		  /* 820FB1E0h */ case    0:  		/* b 1452 */
		/* 820FB1E0h case    0:*/		return 0x820FB78C;
		/* 820FB1E0h case    0:*/		return 0x820FB1E4;
	}
	return 0x820FB1E4;
} // Block from 820FB1E0h-820FB1E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FB1E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB1E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB1E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB1E4);
		  /* 820FB1E4h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB1E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB1E4h case    0:*/		return 0x820FB1E8;
		  /* 820FB1E8h */ case    1:  		/* lwz R11, <#[R11 + 120]> */
		/* 820FB1E8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000078) );
		/* 820FB1E8h case    1:*/		return 0x820FB1EC;
		  /* 820FB1ECh */ case    2:  		/* b 1440 */
		/* 820FB1ECh case    2:*/		return 0x820FB78C;
		/* 820FB1ECh case    2:*/		return 0x820FB1F0;
	}
	return 0x820FB1F0;
} // Block from 820FB1E4h-820FB1F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB1F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB1F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB1F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB1F0);
		  /* 820FB1F0h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB1F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB1F0h case    0:*/		return 0x820FB1F4;
		  /* 820FB1F4h */ case    1:  		/* lwz R11, <#[R11 + 140]> */
		/* 820FB1F4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000008C) );
		/* 820FB1F4h case    1:*/		return 0x820FB1F8;
		  /* 820FB1F8h */ case    2:  		/* b 1428 */
		/* 820FB1F8h case    2:*/		return 0x820FB78C;
		/* 820FB1F8h case    2:*/		return 0x820FB1FC;
	}
	return 0x820FB1FC;
} // Block from 820FB1F0h-820FB1FCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB1FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB1FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB1FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB1FC);
		  /* 820FB1FCh */ case    0:  		/* lis R10, 4192 */
		/* 820FB1FCh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x1060);
		/* 820FB1FCh case    0:*/		return 0x820FB200;
		  /* 820FB200h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FB200h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB200h case    1:*/		return 0x820FB204;
		  /* 820FB204h */ case    2:  		/* bc 12, CR6_EQ, 108 */
		/* 820FB204h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FB270;  }
		/* 820FB204h case    2:*/		return 0x820FB208;
		  /* 820FB208h */ case    3:  		/* lis R10, 4208 */
		/* 820FB208h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x1070);
		/* 820FB208h case    3:*/		return 0x820FB20C;
		  /* 820FB20Ch */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FB20Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB20Ch case    4:*/		return 0x820FB210;
		  /* 820FB210h */ case    5:  		/* bc 12, CR6_EQ, 84 */
		/* 820FB210h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FB264;  }
		/* 820FB210h case    5:*/		return 0x820FB214;
		  /* 820FB214h */ case    6:  		/* lis R10, 4304 */
		/* 820FB214h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x10D0);
		/* 820FB214h case    6:*/		return 0x820FB218;
		  /* 820FB218h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FB218h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB218h case    7:*/		return 0x820FB21C;
		  /* 820FB21Ch */ case    8:  		/* bc 12, CR6_EQ, 40 */
		/* 820FB21Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x820FB244;  }
		/* 820FB21Ch case    8:*/		return 0x820FB220;
		  /* 820FB220h */ case    9:  		/* lis R10, 4320 */
		/* 820FB220h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x10E0);
		/* 820FB220h case    9:*/		return 0x820FB224;
		  /* 820FB224h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820FB224h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB224h case   10:*/		return 0x820FB228;
		  /* 820FB228h */ case   11:  		/* bc 4, CR6_EQ, 1524 */
		/* 820FB228h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820FB81C;  }
		/* 820FB228h case   11:*/		return 0x820FB22C;
		  /* 820FB22Ch */ case   12:  		/* lwz R11, <#[R31 + 112]> */
		/* 820FB22Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820FB22Ch case   12:*/		return 0x820FB230;
		  /* 820FB230h */ case   13:  		/* rlwinm. R11, R11, 0, 5, 5 */
		/* 820FB230h case   13:*/		cpu::op::rlwinm<1,0,5,5>(regs,&regs.R11,regs.R11);
		/* 820FB230h case   13:*/		return 0x820FB234;
		  /* 820FB234h */ case   14:  		/* bc 12, CR0_EQ, 40 */
		/* 820FB234h case   14:*/		if ( regs.CR[0].eq ) { return 0x820FB25C;  }
		/* 820FB234h case   14:*/		return 0x820FB238;
		  /* 820FB238h */ case   15:  		/* lwz R11, <#[R31]> */
		/* 820FB238h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB238h case   15:*/		return 0x820FB23C;
		  /* 820FB23Ch */ case   16:  		/* lwz R11, <#[R11 + 228]> */
		/* 820FB23Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000E4) );
		/* 820FB23Ch case   16:*/		return 0x820FB240;
		  /* 820FB240h */ case   17:  		/* b 1356 */
		/* 820FB240h case   17:*/		return 0x820FB78C;
		/* 820FB240h case   17:*/		return 0x820FB244;
	}
	return 0x820FB244;
} // Block from 820FB1FCh-820FB244h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820FB244h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB244( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB244) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB244);
		  /* 820FB244h */ case    0:  		/* lwz R11, <#[R31 + 112]> */
		/* 820FB244h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820FB244h case    0:*/		return 0x820FB248;
		  /* 820FB248h */ case    1:  		/* rlwinm. R11, R11, 0, 5, 5 */
		/* 820FB248h case    1:*/		cpu::op::rlwinm<1,0,5,5>(regs,&regs.R11,regs.R11);
		/* 820FB248h case    1:*/		return 0x820FB24C;
		  /* 820FB24Ch */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 820FB24Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x820FB25C;  }
		/* 820FB24Ch case    2:*/		return 0x820FB250;
		  /* 820FB250h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 820FB250h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB250h case    3:*/		return 0x820FB254;
		  /* 820FB254h */ case    4:  		/* lwz R11, <#[R11 + 224]> */
		/* 820FB254h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000E0) );
		/* 820FB254h case    4:*/		return 0x820FB258;
		  /* 820FB258h */ case    5:  		/* b 1332 */
		/* 820FB258h case    5:*/		return 0x820FB78C;
		/* 820FB258h case    5:*/		return 0x820FB25C;
	}
	return 0x820FB25C;
} // Block from 820FB244h-820FB25Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FB25Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB25C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB25C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB25C);
		  /* 820FB25Ch */ case    0:  		/* mr R3, R30 */
		/* 820FB25Ch case    0:*/		regs.R3 = regs.R30;
		/* 820FB25Ch case    0:*/		return 0x820FB260;
		  /* 820FB260h */ case    1:  		/* b 1336 */
		/* 820FB260h case    1:*/		return 0x820FB798;
		/* 820FB260h case    1:*/		return 0x820FB264;
	}
	return 0x820FB264;
} // Block from 820FB25Ch-820FB264h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FB264h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB264( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB264) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB264);
		  /* 820FB264h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB264h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB264h case    0:*/		return 0x820FB268;
		  /* 820FB268h */ case    1:  		/* lwz R11, <#[R11 + 152]> */
		/* 820FB268h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000098) );
		/* 820FB268h case    1:*/		return 0x820FB26C;
		  /* 820FB26Ch */ case    2:  		/* b 1312 */
		/* 820FB26Ch case    2:*/		return 0x820FB78C;
		/* 820FB26Ch case    2:*/		return 0x820FB270;
	}
	return 0x820FB270;
} // Block from 820FB264h-820FB270h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB270);
		  /* 820FB270h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB270h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB270h case    0:*/		return 0x820FB274;
		  /* 820FB274h */ case    1:  		/* lwz R11, <#[R11 + 144]> */
		/* 820FB274h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000090) );
		/* 820FB274h case    1:*/		return 0x820FB278;
		  /* 820FB278h */ case    2:  		/* b 1300 */
		/* 820FB278h case    2:*/		return 0x820FB78C;
		/* 820FB278h case    2:*/		return 0x820FB27C;
	}
	return 0x820FB27C;
} // Block from 820FB270h-820FB27Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB27Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB27C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB27C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB27C);
		  /* 820FB27Ch */ case    0:  		/* cmplw CR6, R11, R18 */
		/* 820FB27Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R18);
		/* 820FB27Ch case    0:*/		return 0x820FB280;
		  /* 820FB280h */ case    1:  		/* bc 12, CR6_GT, 104 */
		/* 820FB280h case    1:*/		if ( regs.CR[6].gt ) { return 0x820FB2E8;  }
		/* 820FB280h case    1:*/		return 0x820FB284;
		  /* 820FB284h */ case    2:  		/* bc 12, CR6_EQ, 900 */
		/* 820FB284h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FB608;  }
		/* 820FB284h case    2:*/		return 0x820FB288;
		  /* 820FB288h */ case    3:  		/* lis R10, 4352 */
		/* 820FB288h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x1100);
		/* 820FB288h case    3:*/		return 0x820FB28C;
		  /* 820FB28Ch */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FB28Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB28Ch case    4:*/		return 0x820FB290;
		  /* 820FB290h */ case    5:  		/* bc 12, CR6_EQ, 64 */
		/* 820FB290h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FB2D0;  }
		/* 820FB290h case    5:*/		return 0x820FB294;
		  /* 820FB294h */ case    6:  		/* lis R10, 4384 */
		/* 820FB294h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x1120);
		/* 820FB294h case    6:*/		return 0x820FB298;
		  /* 820FB298h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FB298h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB298h case    7:*/		return 0x820FB29C;
		  /* 820FB29Ch */ case    8:  		/* bc 12, CR6_EQ, -196 */
		/* 820FB29Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x820FB1D8;  }
		/* 820FB29Ch case    8:*/		return 0x820FB2A0;
		  /* 820FB2A0h */ case    9:  		/* lis R10, 4400 */
		/* 820FB2A0h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x1130);
		/* 820FB2A0h case    9:*/		return 0x820FB2A4;
		  /* 820FB2A4h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820FB2A4h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB2A4h case   10:*/		return 0x820FB2A8;
		  /* 820FB2A8h */ case   11:  		/* bc 12, CR6_EQ, 1272 */
		/* 820FB2A8h case   11:*/		if ( regs.CR[6].eq ) { return 0x820FB7A0;  }
		/* 820FB2A8h case   11:*/		return 0x820FB2AC;
		  /* 820FB2ACh */ case   12:  		/* lis R10, 4432 */
		/* 820FB2ACh case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0x1150);
		/* 820FB2ACh case   12:*/		return 0x820FB2B0;
		  /* 820FB2B0h */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 820FB2B0h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB2B0h case   13:*/		return 0x820FB2B4;
		  /* 820FB2B4h */ case   14:  		/* bc 12, CR6_EQ, -220 */
		/* 820FB2B4h case   14:*/		if ( regs.CR[6].eq ) { return 0x820FB1D8;  }
		/* 820FB2B4h case   14:*/		return 0x820FB2B8;
		  /* 820FB2B8h */ case   15:  		/* lis R10, 8192 */
		/* 820FB2B8h case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0x2000);
		/* 820FB2B8h case   15:*/		return 0x820FB2BC;
		  /* 820FB2BCh */ case   16:  		/* cmplw CR6, R11, R10 */
		/* 820FB2BCh case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB2BCh case   16:*/		return 0x820FB2C0;
		  /* 820FB2C0h */ case   17:  		/* bc 4, CR6_EQ, 1372 */
		/* 820FB2C0h case   17:*/		if ( !regs.CR[6].eq ) { return 0x820FB81C;  }
		/* 820FB2C0h case   17:*/		return 0x820FB2C4;
		  /* 820FB2C4h */ case   18:  		/* lwz R11, <#[R31]> */
		/* 820FB2C4h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB2C4h case   18:*/		return 0x820FB2C8;
		  /* 820FB2C8h */ case   19:  		/* lwz R11, <#[R11 + 156]> */
		/* 820FB2C8h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000009C) );
		/* 820FB2C8h case   19:*/		return 0x820FB2CC;
		  /* 820FB2CCh */ case   20:  		/* b 1216 */
		/* 820FB2CCh case   20:*/		return 0x820FB78C;
		/* 820FB2CCh case   20:*/		return 0x820FB2D0;
	}
	return 0x820FB2D0;
} // Block from 820FB27Ch-820FB2D0h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820FB2D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB2D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB2D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB2D0);
		  /* 820FB2D0h */ case    0:  		/* lwz R11, <#[R31 + 112]> */
		/* 820FB2D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820FB2D0h case    0:*/		return 0x820FB2D4;
		  /* 820FB2D4h */ case    1:  		/* rlwinm. R11, R11, 0, 7, 7 */
		/* 820FB2D4h case    1:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R11,regs.R11);
		/* 820FB2D4h case    1:*/		return 0x820FB2D8;
		  /* 820FB2D8h */ case    2:  		/* bc 4, CR0_EQ, 1348 */
		/* 820FB2D8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820FB81C;  }
		/* 820FB2D8h case    2:*/		return 0x820FB2DC;
		  /* 820FB2DCh */ case    3:  		/* lwz R11, <#[R31]> */
		/* 820FB2DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB2DCh case    3:*/		return 0x820FB2E0;
		  /* 820FB2E0h */ case    4:  		/* lwz R11, <#[R11 + 220]> */
		/* 820FB2E0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000DC) );
		/* 820FB2E0h case    4:*/		return 0x820FB2E4;
		  /* 820FB2E4h */ case    5:  		/* b 1192 */
		/* 820FB2E4h case    5:*/		return 0x820FB78C;
		/* 820FB2E4h case    5:*/		return 0x820FB2E8;
	}
	return 0x820FB2E8;
} // Block from 820FB2D0h-820FB2E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FB2E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB2E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB2E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB2E8);
		  /* 820FB2E8h */ case    0:  		/* lis R10, 8224 */
		/* 820FB2E8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x2020);
		/* 820FB2E8h case    0:*/		return 0x820FB2EC;
		  /* 820FB2ECh */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FB2ECh case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB2ECh case    1:*/		return 0x820FB2F0;
		  /* 820FB2F0h */ case    2:  		/* bc 12, CR6_EQ, 76 */
		/* 820FB2F0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FB33C;  }
		/* 820FB2F0h case    2:*/		return 0x820FB2F4;
		  /* 820FB2F4h */ case    3:  		/* lis R10, 8240 */
		/* 820FB2F4h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x2030);
		/* 820FB2F4h case    3:*/		return 0x820FB2F8;
		  /* 820FB2F8h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FB2F8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB2F8h case    4:*/		return 0x820FB2FC;
		  /* 820FB2FCh */ case    5:  		/* bc 12, CR6_EQ, 52 */
		/* 820FB2FCh case    5:*/		if ( regs.CR[6].eq ) { return 0x820FB330;  }
		/* 820FB2FCh case    5:*/		return 0x820FB300;
		  /* 820FB300h */ case    6:  		/* lis R10, 8256 */
		/* 820FB300h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x2040);
		/* 820FB300h case    6:*/		return 0x820FB304;
		  /* 820FB304h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FB304h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB304h case    7:*/		return 0x820FB308;
		  /* 820FB308h */ case    8:  		/* bc 12, CR6_EQ, 28 */
		/* 820FB308h case    8:*/		if ( regs.CR[6].eq ) { return 0x820FB324;  }
		/* 820FB308h case    8:*/		return 0x820FB30C;
		  /* 820FB30Ch */ case    9:  		/* lis R10, 8272 */
		/* 820FB30Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x2050);
		/* 820FB30Ch case    9:*/		return 0x820FB310;
		  /* 820FB310h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820FB310h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB310h case   10:*/		return 0x820FB314;
		  /* 820FB314h */ case   11:  		/* bc 4, CR6_EQ, 1288 */
		/* 820FB314h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820FB81C;  }
		/* 820FB314h case   11:*/		return 0x820FB318;
		  /* 820FB318h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 820FB318h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB318h case   12:*/		return 0x820FB31C;
		  /* 820FB31Ch */ case   13:  		/* lwz R11, <#[R11 + 176]> */
		/* 820FB31Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000B0) );
		/* 820FB31Ch case   13:*/		return 0x820FB320;
		  /* 820FB320h */ case   14:  		/* b 1132 */
		/* 820FB320h case   14:*/		return 0x820FB78C;
		/* 820FB320h case   14:*/		return 0x820FB324;
	}
	return 0x820FB324;
} // Block from 820FB2E8h-820FB324h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820FB324h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB324( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB324) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB324);
		  /* 820FB324h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB324h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB324h case    0:*/		return 0x820FB328;
		  /* 820FB328h */ case    1:  		/* lwz R11, <#[R11 + 172]> */
		/* 820FB328h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000AC) );
		/* 820FB328h case    1:*/		return 0x820FB32C;
		  /* 820FB32Ch */ case    2:  		/* b 1120 */
		/* 820FB32Ch case    2:*/		return 0x820FB78C;
		/* 820FB32Ch case    2:*/		return 0x820FB330;
	}
	return 0x820FB330;
} // Block from 820FB324h-820FB330h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB330);
		  /* 820FB330h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB330h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB330h case    0:*/		return 0x820FB334;
		  /* 820FB334h */ case    1:  		/* lwz R11, <#[R11 + 168]> */
		/* 820FB334h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000A8) );
		/* 820FB334h case    1:*/		return 0x820FB338;
		  /* 820FB338h */ case    2:  		/* b 1108 */
		/* 820FB338h case    2:*/		return 0x820FB78C;
		/* 820FB338h case    2:*/		return 0x820FB33C;
	}
	return 0x820FB33C;
} // Block from 820FB330h-820FB33Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB33Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB33C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB33C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB33C);
		  /* 820FB33Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB33Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB33Ch case    0:*/		return 0x820FB340;
		  /* 820FB340h */ case    1:  		/* lwz R11, <#[R11 + 164]> */
		/* 820FB340h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000A4) );
		/* 820FB340h case    1:*/		return 0x820FB344;
		  /* 820FB344h */ case    2:  		/* b 1096 */
		/* 820FB344h case    2:*/		return 0x820FB78C;
		/* 820FB344h case    2:*/		return 0x820FB348;
	}
	return 0x820FB348;
} // Block from 820FB33Ch-820FB348h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB348);
		  /* 820FB348h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB348h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB348h case    0:*/		return 0x820FB34C;
		  /* 820FB34Ch */ case    1:  		/* lwz R11, <#[R11 + 260]> */
		/* 820FB34Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000104) );
		/* 820FB34Ch case    1:*/		return 0x820FB350;
		  /* 820FB350h */ case    2:  		/* b 1084 */
		/* 820FB350h case    2:*/		return 0x820FB78C;
		/* 820FB350h case    2:*/		return 0x820FB354;
	}
	return 0x820FB354;
} // Block from 820FB348h-820FB354h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB354h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB354( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB354) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB354);
		  /* 820FB354h */ case    0:  		/* cmplw CR6, R11, R19 */
		/* 820FB354h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R19);
		/* 820FB354h case    0:*/		return 0x820FB358;
		  /* 820FB358h */ case    1:  		/* bc 12, CR6_GT, 212 */
		/* 820FB358h case    1:*/		if ( regs.CR[6].gt ) { return 0x820FB42C;  }
		/* 820FB358h case    1:*/		return 0x820FB35C;
		  /* 820FB35Ch */ case    2:  		/* bc 12, CR6_EQ, 280 */
		/* 820FB35Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820FB474;  }
		/* 820FB35Ch case    2:*/		return 0x820FB360;
		  /* 820FB360h */ case    3:  		/* cmplw CR6, R11, R20 */
		/* 820FB360h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R20);
		/* 820FB360h case    3:*/		return 0x820FB364;
		  /* 820FB364h */ case    4:  		/* bc 12, CR6_GT, 128 */
		/* 820FB364h case    4:*/		if ( regs.CR[6].gt ) { return 0x820FB3E4;  }
		/* 820FB364h case    4:*/		return 0x820FB368;
		  /* 820FB368h */ case    5:  		/* bc 12, CR6_EQ, 112 */
		/* 820FB368h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FB3D8;  }
		/* 820FB368h case    5:*/		return 0x820FB36C;
		  /* 820FB36Ch */ case    6:  		/* lis R10, 8320 */
		/* 820FB36Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x2080);
		/* 820FB36Ch case    6:*/		return 0x820FB370;
		  /* 820FB370h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FB370h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB370h case    7:*/		return 0x820FB374;
		  /* 820FB374h */ case    8:  		/* bc 12, CR6_EQ, 1068 */
		/* 820FB374h case    8:*/		if ( regs.CR[6].eq ) { return 0x820FB7A0;  }
		/* 820FB374h case    8:*/		return 0x820FB378;
		  /* 820FB378h */ case    9:  		/* lis R10, 8336 */
		/* 820FB378h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x2090);
		/* 820FB378h case    9:*/		return 0x820FB37C;
		  /* 820FB37Ch */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820FB37Ch case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB37Ch case   10:*/		return 0x820FB380;
		  /* 820FB380h */ case   11:  		/* bc 12, CR6_EQ, -424 */
		/* 820FB380h case   11:*/		if ( regs.CR[6].eq ) { return 0x820FB1D8;  }
		/* 820FB380h case   11:*/		return 0x820FB384;
		  /* 820FB384h */ case   12:  		/* lis R10, 12288 */
		/* 820FB384h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0x3000);
		/* 820FB384h case   12:*/		return 0x820FB388;
		  /* 820FB388h */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 820FB388h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB388h case   13:*/		return 0x820FB38C;
		  /* 820FB38Ch */ case   14:  		/* bc 12, CR6_EQ, 52 */
		/* 820FB38Ch case   14:*/		if ( regs.CR[6].eq ) { return 0x820FB3C0;  }
		/* 820FB38Ch case   14:*/		return 0x820FB390;
		  /* 820FB390h */ case   15:  		/* lis R10, 20480 */
		/* 820FB390h case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0x5000);
		/* 820FB390h case   15:*/		return 0x820FB394;
		  /* 820FB394h */ case   16:  		/* cmplw CR6, R11, R10 */
		/* 820FB394h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB394h case   16:*/		return 0x820FB398;
		  /* 820FB398h */ case   17:  		/* bc 12, CR6_EQ, 28 */
		/* 820FB398h case   17:*/		if ( regs.CR[6].eq ) { return 0x820FB3B4;  }
		/* 820FB398h case   17:*/		return 0x820FB39C;
		  /* 820FB39Ch */ case   18:  		/* lis R10, 20496 */
		/* 820FB39Ch case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0x5010);
		/* 820FB39Ch case   18:*/		return 0x820FB3A0;
		  /* 820FB3A0h */ case   19:  		/* cmplw CR6, R11, R10 */
		/* 820FB3A0h case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB3A0h case   19:*/		return 0x820FB3A4;
		  /* 820FB3A4h */ case   20:  		/* bc 4, CR6_EQ, 1144 */
		/* 820FB3A4h case   20:*/		if ( !regs.CR[6].eq ) { return 0x820FB81C;  }
		/* 820FB3A4h case   20:*/		return 0x820FB3A8;
		  /* 820FB3A8h */ case   21:  		/* lwz R11, <#[R31]> */
		/* 820FB3A8h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB3A8h case   21:*/		return 0x820FB3AC;
		  /* 820FB3ACh */ case   22:  		/* lwz R11, <#[R11 + 184]> */
		/* 820FB3ACh case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000B8) );
		/* 820FB3ACh case   22:*/		return 0x820FB3B0;
		  /* 820FB3B0h */ case   23:  		/* b 988 */
		/* 820FB3B0h case   23:*/		return 0x820FB78C;
		/* 820FB3B0h case   23:*/		return 0x820FB3B4;
	}
	return 0x820FB3B4;
} // Block from 820FB354h-820FB3B4h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820FB3B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB3B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB3B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB3B4);
		  /* 820FB3B4h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB3B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB3B4h case    0:*/		return 0x820FB3B8;
		  /* 820FB3B8h */ case    1:  		/* lwz R11, <#[R11 + 180]> */
		/* 820FB3B8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000B4) );
		/* 820FB3B8h case    1:*/		return 0x820FB3BC;
		  /* 820FB3BCh */ case    2:  		/* b 976 */
		/* 820FB3BCh case    2:*/		return 0x820FB78C;
		/* 820FB3BCh case    2:*/		return 0x820FB3C0;
	}
	return 0x820FB3C0;
} // Block from 820FB3B4h-820FB3C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB3C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB3C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB3C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB3C0);
		  /* 820FB3C0h */ case    0:  		/* lwz R11, <#[R31 + 112]> */
		/* 820FB3C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820FB3C0h case    0:*/		return 0x820FB3C4;
		  /* 820FB3C4h */ case    1:  		/* rlwinm. R11, R11, 0, 7, 7 */
		/* 820FB3C4h case    1:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R11,regs.R11);
		/* 820FB3C4h case    1:*/		return 0x820FB3C8;
		  /* 820FB3C8h */ case    2:  		/* bc 4, CR0_EQ, 1108 */
		/* 820FB3C8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820FB81C;  }
		/* 820FB3C8h case    2:*/		return 0x820FB3CC;
		  /* 820FB3CCh */ case    3:  		/* lwz R11, <#[R31]> */
		/* 820FB3CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB3CCh case    3:*/		return 0x820FB3D0;
		  /* 820FB3D0h */ case    4:  		/* lwz R11, <#[R11 + 188]> */
		/* 820FB3D0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000BC) );
		/* 820FB3D0h case    4:*/		return 0x820FB3D4;
		  /* 820FB3D4h */ case    5:  		/* b 952 */
		/* 820FB3D4h case    5:*/		return 0x820FB78C;
		/* 820FB3D4h case    5:*/		return 0x820FB3D8;
	}
	return 0x820FB3D8;
} // Block from 820FB3C0h-820FB3D8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FB3D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB3D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB3D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB3D8);
		  /* 820FB3D8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB3D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB3D8h case    0:*/		return 0x820FB3DC;
		  /* 820FB3DCh */ case    1:  		/* lwz R11, <#[R11 + 232]> */
		/* 820FB3DCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000E8) );
		/* 820FB3DCh case    1:*/		return 0x820FB3E0;
		  /* 820FB3E0h */ case    2:  		/* b 940 */
		/* 820FB3E0h case    2:*/		return 0x820FB78C;
		/* 820FB3E0h case    2:*/		return 0x820FB3E4;
	}
	return 0x820FB3E4;
} // Block from 820FB3D8h-820FB3E4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB3E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB3E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB3E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB3E4);
		  /* 820FB3E4h */ case    0:  		/* lis R10, 24576 */
		/* 820FB3E4h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x6000);
		/* 820FB3E4h case    0:*/		return 0x820FB3E8;
		  /* 820FB3E8h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FB3E8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB3E8h case    1:*/		return 0x820FB3EC;
		  /* 820FB3ECh */ case    2:  		/* bc 12, CR6_EQ, 204 */
		/* 820FB3ECh case    2:*/		if ( regs.CR[6].eq ) { return 0x820FB4B8;  }
		/* 820FB3ECh case    2:*/		return 0x820FB3F0;
		  /* 820FB3F0h */ case    3:  		/* lis R10, 24592 */
		/* 820FB3F0h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x6010);
		/* 820FB3F0h case    3:*/		return 0x820FB3F4;
		  /* 820FB3F4h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FB3F4h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB3F4h case    4:*/		return 0x820FB3F8;
		  /* 820FB3F8h */ case    5:  		/* bc 12, CR6_EQ, 348 */
		/* 820FB3F8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FB554;  }
		/* 820FB3F8h case    5:*/		return 0x820FB3FC;
		  /* 820FB3FCh */ case    6:  		/* lis R10, 24608 */
		/* 820FB3FCh case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x6020);
		/* 820FB3FCh case    6:*/		return 0x820FB400;
		  /* 820FB400h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FB400h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB400h case    7:*/		return 0x820FB404;
		  /* 820FB404h */ case    8:  		/* bc 12, CR6_EQ, 312 */
		/* 820FB404h case    8:*/		if ( regs.CR[6].eq ) { return 0x820FB53C;  }
		/* 820FB404h case    8:*/		return 0x820FB408;
		  /* 820FB408h */ case    9:  		/* lis R10, 24624 */
		/* 820FB408h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x6030);
		/* 820FB408h case    9:*/		return 0x820FB40C;
		  /* 820FB40Ch */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820FB40Ch case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB40Ch case   10:*/		return 0x820FB410;
		  /* 820FB410h */ case   11:  		/* bc 4, CR6_EQ, 1036 */
		/* 820FB410h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820FB81C;  }
		/* 820FB410h case   11:*/		return 0x820FB414;
		  /* 820FB414h */ case   12:  		/* lwz R11, <#[R31 + 112]> */
		/* 820FB414h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820FB414h case   12:*/		return 0x820FB418;
		  /* 820FB418h */ case   13:  		/* rlwinm. R11, R11, 0, 7, 7 */
		/* 820FB418h case   13:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R11,regs.R11);
		/* 820FB418h case   13:*/		return 0x820FB41C;
		  /* 820FB41Ch */ case   14:  		/* bc 4, CR0_EQ, 1024 */
		/* 820FB41Ch case   14:*/		if ( !regs.CR[0].eq ) { return 0x820FB81C;  }
		/* 820FB41Ch case   14:*/		return 0x820FB420;
		  /* 820FB420h */ case   15:  		/* lwz R11, <#[R31]> */
		/* 820FB420h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB420h case   15:*/		return 0x820FB424;
		  /* 820FB424h */ case   16:  		/* lwz R11, <#[R11 + 272]> */
		/* 820FB424h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000110) );
		/* 820FB424h case   16:*/		return 0x820FB428;
		  /* 820FB428h */ case   17:  		/* b 868 */
		/* 820FB428h case   17:*/		return 0x820FB78C;
		/* 820FB428h case   17:*/		return 0x820FB42C;
	}
	return 0x820FB42C;
} // Block from 820FB3E4h-820FB42Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 820FB42Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB42C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB42C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB42C);
		  /* 820FB42Ch */ case    0:  		/* cmplw CR6, R11, R21 */
		/* 820FB42Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R21);
		/* 820FB42Ch case    0:*/		return 0x820FB430;
		  /* 820FB430h */ case    1:  		/* bc 12, CR6_GT, 92 */
		/* 820FB430h case    1:*/		if ( regs.CR[6].gt ) { return 0x820FB48C;  }
		/* 820FB430h case    1:*/		return 0x820FB434;
		  /* 820FB434h */ case    2:  		/* bc 12, CR6_EQ, 132 */
		/* 820FB434h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FB4B8;  }
		/* 820FB434h case    2:*/		return 0x820FB438;
		  /* 820FB438h */ case    3:  		/* lis R10, 24656 */
		/* 820FB438h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x6050);
		/* 820FB438h case    3:*/		return 0x820FB43C;
		  /* 820FB43Ch */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FB43Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB43Ch case    4:*/		return 0x820FB440;
		  /* 820FB440h */ case    5:  		/* bc 12, CR6_EQ, 120 */
		/* 820FB440h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FB4B8;  }
		/* 820FB440h case    5:*/		return 0x820FB444;
		  /* 820FB444h */ case    6:  		/* lis R10, 24672 */
		/* 820FB444h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x6060);
		/* 820FB444h case    6:*/		return 0x820FB448;
		  /* 820FB448h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FB448h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB448h case    7:*/		return 0x820FB44C;
		  /* 820FB44Ch */ case    8:  		/* bc 12, CR6_EQ, 264 */
		/* 820FB44Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x820FB554;  }
		/* 820FB44Ch case    8:*/		return 0x820FB450;
		  /* 820FB450h */ case    9:  		/* lis R10, 24688 */
		/* 820FB450h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x6070);
		/* 820FB450h case    9:*/		return 0x820FB454;
		  /* 820FB454h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820FB454h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB454h case   10:*/		return 0x820FB458;
		  /* 820FB458h */ case   11:  		/* bc 12, CR6_EQ, 228 */
		/* 820FB458h case   11:*/		if ( regs.CR[6].eq ) { return 0x820FB53C;  }
		/* 820FB458h case   11:*/		return 0x820FB45C;
		  /* 820FB45Ch */ case   12:  		/* lis R10, 24704 */
		/* 820FB45Ch case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0x6080);
		/* 820FB45Ch case   12:*/		return 0x820FB460;
		  /* 820FB460h */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 820FB460h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB460h case   13:*/		return 0x820FB464;
		  /* 820FB464h */ case   14:  		/* bc 12, CR6_EQ, -80 */
		/* 820FB464h case   14:*/		if ( regs.CR[6].eq ) { return 0x820FB414;  }
		/* 820FB464h case   14:*/		return 0x820FB468;
		  /* 820FB468h */ case   15:  		/* lis R10, 24720 */
		/* 820FB468h case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0x6090);
		/* 820FB468h case   15:*/		return 0x820FB46C;
		  /* 820FB46Ch */ case   16:  		/* cmplw CR6, R11, R10 */
		/* 820FB46Ch case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB46Ch case   16:*/		return 0x820FB470;
		  /* 820FB470h */ case   17:  		/* bc 4, CR6_EQ, 940 */
		/* 820FB470h case   17:*/		if ( !regs.CR[6].eq ) { return 0x820FB81C;  }
		/* 820FB470h case   17:*/		return 0x820FB474;
	}
	return 0x820FB474;
} // Block from 820FB42Ch-820FB474h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820FB474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB474);
		  /* 820FB474h */ case    0:  		/* lwz R11, <#[R31 + 112]> */
		/* 820FB474h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820FB474h case    0:*/		return 0x820FB478;
		  /* 820FB478h */ case    1:  		/* rlwinm. R11, R11, 0, 6, 6 */
		/* 820FB478h case    1:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R11,regs.R11);
		/* 820FB478h case    1:*/		return 0x820FB47C;
		  /* 820FB47Ch */ case    2:  		/* bc 12, CR0_EQ, 928 */
		/* 820FB47Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x820FB81C;  }
		/* 820FB47Ch case    2:*/		return 0x820FB480;
		  /* 820FB480h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 820FB480h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB480h case    3:*/		return 0x820FB484;
		  /* 820FB484h */ case    4:  		/* lwz R11, <#[R11 + 276]> */
		/* 820FB484h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000114) );
		/* 820FB484h case    4:*/		return 0x820FB488;
		  /* 820FB488h */ case    5:  		/* b 772 */
		/* 820FB488h case    5:*/		return 0x820FB78C;
		/* 820FB488h case    5:*/		return 0x820FB48C;
	}
	return 0x820FB48C;
} // Block from 820FB474h-820FB48Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FB48Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB48C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB48C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB48C);
		  /* 820FB48Ch */ case    0:  		/* lis R10, 24752 */
		/* 820FB48Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x60B0);
		/* 820FB48Ch case    0:*/		return 0x820FB490;
		  /* 820FB490h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FB490h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB490h case    1:*/		return 0x820FB494;
		  /* 820FB494h */ case    2:  		/* bc 12, CR6_EQ, 192 */
		/* 820FB494h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FB554;  }
		/* 820FB494h case    2:*/		return 0x820FB498;
		  /* 820FB498h */ case    3:  		/* lis R10, 24768 */
		/* 820FB498h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x60C0);
		/* 820FB498h case    3:*/		return 0x820FB49C;
		  /* 820FB49Ch */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FB49Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB49Ch case    4:*/		return 0x820FB4A0;
		  /* 820FB4A0h */ case    5:  		/* bc 12, CR6_EQ, 156 */
		/* 820FB4A0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FB53C;  }
		/* 820FB4A0h case    5:*/		return 0x820FB4A4;
		  /* 820FB4A4h */ case    6:  		/* lis R10, 24784 */
		/* 820FB4A4h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x60D0);
		/* 820FB4A4h case    6:*/		return 0x820FB4A8;
		  /* 820FB4A8h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FB4A8h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB4A8h case    7:*/		return 0x820FB4AC;
		  /* 820FB4ACh */ case    8:  		/* bc 12, CR6_EQ, -152 */
		/* 820FB4ACh case    8:*/		if ( regs.CR[6].eq ) { return 0x820FB414;  }
		/* 820FB4ACh case    8:*/		return 0x820FB4B0;
		  /* 820FB4B0h */ case    9:  		/* lis R10, 24800 */
		/* 820FB4B0h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x60E0);
		/* 820FB4B0h case    9:*/		return 0x820FB4B4;
		  /* 820FB4B4h */ case   10:  		/* b -72 */
		/* 820FB4B4h case   10:*/		return 0x820FB46C;
		/* 820FB4B4h case   10:*/		return 0x820FB4B8;
	}
	return 0x820FB4B8;
} // Block from 820FB48Ch-820FB4B8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FB4B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB4B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB4B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB4B8);
		  /* 820FB4B8h */ case    0:  		/* lwz R11, <#[R31 + 112]> */
		/* 820FB4B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820FB4B8h case    0:*/		return 0x820FB4BC;
		  /* 820FB4BCh */ case    1:  		/* rlwinm. R11, R11, 0, 7, 7 */
		/* 820FB4BCh case    1:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R11,regs.R11);
		/* 820FB4BCh case    1:*/		return 0x820FB4C0;
		  /* 820FB4C0h */ case    2:  		/* bc 4, CR0_EQ, 860 */
		/* 820FB4C0h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820FB81C;  }
		/* 820FB4C0h case    2:*/		return 0x820FB4C4;
		  /* 820FB4C4h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 820FB4C4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB4C4h case    3:*/		return 0x820FB4C8;
		  /* 820FB4C8h */ case    4:  		/* lwz R11, <#[R11 + 264]> */
		/* 820FB4C8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000108) );
		/* 820FB4C8h case    4:*/		return 0x820FB4CC;
		  /* 820FB4CCh */ case    5:  		/* b 704 */
		/* 820FB4CCh case    5:*/		return 0x820FB78C;
		/* 820FB4CCh case    5:*/		return 0x820FB4D0;
	}
	return 0x820FB4D0;
} // Block from 820FB4B8h-820FB4D0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FB4D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB4D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB4D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB4D0);
		  /* 820FB4D0h */ case    0:  		/* cmplw CR6, R11, R22 */
		/* 820FB4D0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R22);
		/* 820FB4D0h case    0:*/		return 0x820FB4D4;
		  /* 820FB4D4h */ case    1:  		/* bc 12, CR6_GT, 464 */
		/* 820FB4D4h case    1:*/		if ( regs.CR[6].gt ) { return 0x820FB6A4;  }
		/* 820FB4D4h case    1:*/		return 0x820FB4D8;
		  /* 820FB4D8h */ case    2:  		/* bc 12, CR6_EQ, 448 */
		/* 820FB4D8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FB698;  }
		/* 820FB4D8h case    2:*/		return 0x820FB4DC;
		  /* 820FB4DCh */ case    3:  		/* cmplw CR6, R11, R23 */
		/* 820FB4DCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R23);
		/* 820FB4DCh case    3:*/		return 0x820FB4E0;
		  /* 820FB4E0h */ case    4:  		/* bc 12, CR6_GT, 224 */
		/* 820FB4E0h case    4:*/		if ( regs.CR[6].gt ) { return 0x820FB5C0;  }
		/* 820FB4E0h case    4:*/		return 0x820FB4E4;
		  /* 820FB4E4h */ case    5:  		/* bc 12, CR6_EQ, 184 */
		/* 820FB4E4h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FB59C;  }
		/* 820FB4E4h case    5:*/		return 0x820FB4E8;
		  /* 820FB4E8h */ case    6:  		/* cmplw CR6, R11, R24 */
		/* 820FB4E8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 820FB4E8h case    6:*/		return 0x820FB4EC;
		  /* 820FB4ECh */ case    7:  		/* bc 12, CR6_GT, 128 */
		/* 820FB4ECh case    7:*/		if ( regs.CR[6].gt ) { return 0x820FB56C;  }
		/* 820FB4ECh case    7:*/		return 0x820FB4F0;
		  /* 820FB4F0h */ case    8:  		/* bc 12, CR6_EQ, 112 */
		/* 820FB4F0h case    8:*/		if ( regs.CR[6].eq ) { return 0x820FB560;  }
		/* 820FB4F0h case    8:*/		return 0x820FB4F4;
		  /* 820FB4F4h */ case    9:  		/* lis R10, 24832 */
		/* 820FB4F4h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x6100);
		/* 820FB4F4h case    9:*/		return 0x820FB4F8;
		  /* 820FB4F8h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820FB4F8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB4F8h case   10:*/		return 0x820FB4FC;
		  /* 820FB4FCh */ case   11:  		/* bc 12, CR6_EQ, 88 */
		/* 820FB4FCh case   11:*/		if ( regs.CR[6].eq ) { return 0x820FB554;  }
		/* 820FB4FCh case   11:*/		return 0x820FB500;
		  /* 820FB500h */ case   12:  		/* lis R10, 24848 */
		/* 820FB500h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0x6110);
		/* 820FB500h case   12:*/		return 0x820FB504;
		  /* 820FB504h */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 820FB504h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB504h case   13:*/		return 0x820FB508;
		  /* 820FB508h */ case   14:  		/* bc 12, CR6_EQ, 52 */
		/* 820FB508h case   14:*/		if ( regs.CR[6].eq ) { return 0x820FB53C;  }
		/* 820FB508h case   14:*/		return 0x820FB50C;
		  /* 820FB50Ch */ case   15:  		/* lis R10, 24864 */
		/* 820FB50Ch case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0x6120);
		/* 820FB50Ch case   15:*/		return 0x820FB510;
		  /* 820FB510h */ case   16:  		/* cmplw CR6, R11, R10 */
		/* 820FB510h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB510h case   16:*/		return 0x820FB514;
		  /* 820FB514h */ case   17:  		/* bc 12, CR6_EQ, -256 */
		/* 820FB514h case   17:*/		if ( regs.CR[6].eq ) { return 0x820FB414;  }
		/* 820FB514h case   17:*/		return 0x820FB518;
		  /* 820FB518h */ case   18:  		/* lis R10, 24880 */
		/* 820FB518h case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0x6130);
		/* 820FB518h case   18:*/		return 0x820FB51C;
		  /* 820FB51Ch */ case   19:  		/* cmplw CR6, R11, R10 */
		/* 820FB51Ch case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB51Ch case   19:*/		return 0x820FB520;
		  /* 820FB520h */ case   20:  		/* bc 12, CR6_EQ, -172 */
		/* 820FB520h case   20:*/		if ( regs.CR[6].eq ) { return 0x820FB474;  }
		/* 820FB520h case   20:*/		return 0x820FB524;
		  /* 820FB524h */ case   21:  		/* lis R10, 28672 */
		/* 820FB524h case   21:*/		cpu::op::lis<0>(regs,&regs.R10,0x7000);
		/* 820FB524h case   21:*/		return 0x820FB528;
		  /* 820FB528h */ case   22:  		/* cmplw CR6, R11, R10 */
		/* 820FB528h case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB528h case   22:*/		return 0x820FB52C;
		  /* 820FB52Ch */ case   23:  		/* bc 4, CR6_EQ, 752 */
		/* 820FB52Ch case   23:*/		if ( !regs.CR[6].eq ) { return 0x820FB81C;  }
		/* 820FB52Ch case   23:*/		return 0x820FB530;
		  /* 820FB530h */ case   24:  		/* lwz R11, <#[R31]> */
		/* 820FB530h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB530h case   24:*/		return 0x820FB534;
		  /* 820FB534h */ case   25:  		/* lwz R11, <#[R11 + 196]> */
		/* 820FB534h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000C4) );
		/* 820FB534h case   25:*/		return 0x820FB538;
		  /* 820FB538h */ case   26:  		/* b 596 */
		/* 820FB538h case   26:*/		return 0x820FB78C;
		/* 820FB538h case   26:*/		return 0x820FB53C;
	}
	return 0x820FB53C;
} // Block from 820FB4D0h-820FB53Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 820FB53Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB53C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB53C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB53C);
		  /* 820FB53Ch */ case    0:  		/* lwz R11, <#[R31 + 112]> */
		/* 820FB53Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820FB53Ch case    0:*/		return 0x820FB540;
		  /* 820FB540h */ case    1:  		/* rlwinm. R11, R11, 0, 7, 7 */
		/* 820FB540h case    1:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R11,regs.R11);
		/* 820FB540h case    1:*/		return 0x820FB544;
		  /* 820FB544h */ case    2:  		/* bc 4, CR0_EQ, 728 */
		/* 820FB544h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820FB81C;  }
		/* 820FB544h case    2:*/		return 0x820FB548;
		  /* 820FB548h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 820FB548h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB548h case    3:*/		return 0x820FB54C;
		  /* 820FB54Ch */ case    4:  		/* lwz R11, <#[R11 + 268]> */
		/* 820FB54Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000010C) );
		/* 820FB54Ch case    4:*/		return 0x820FB550;
		  /* 820FB550h */ case    5:  		/* b 572 */
		/* 820FB550h case    5:*/		return 0x820FB78C;
		/* 820FB550h case    5:*/		return 0x820FB554;
	}
	return 0x820FB554;
} // Block from 820FB53Ch-820FB554h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FB554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB554);
		  /* 820FB554h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB554h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB554h case    0:*/		return 0x820FB558;
		  /* 820FB558h */ case    1:  		/* lwz R11, <#[R11 + 280]> */
		/* 820FB558h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000118) );
		/* 820FB558h case    1:*/		return 0x820FB55C;
		  /* 820FB55Ch */ case    2:  		/* b 560 */
		/* 820FB55Ch case    2:*/		return 0x820FB78C;
		/* 820FB55Ch case    2:*/		return 0x820FB560;
	}
	return 0x820FB560;
} // Block from 820FB554h-820FB560h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB560h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB560);
		  /* 820FB560h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB560h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB560h case    0:*/		return 0x820FB564;
		  /* 820FB564h */ case    1:  		/* lwz R11, <#[R11 + 200]> */
		/* 820FB564h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000C8) );
		/* 820FB564h case    1:*/		return 0x820FB568;
		  /* 820FB568h */ case    2:  		/* b 548 */
		/* 820FB568h case    2:*/		return 0x820FB78C;
		/* 820FB568h case    2:*/		return 0x820FB56C;
	}
	return 0x820FB56C;
} // Block from 820FB560h-820FB56Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB56Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB56C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB56C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB56C);
		  /* 820FB56Ch */ case    0:  		/* lis R10, 28704 */
		/* 820FB56Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x7020);
		/* 820FB56Ch case    0:*/		return 0x820FB570;
		  /* 820FB570h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FB570h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB570h case    1:*/		return 0x820FB574;
		  /* 820FB574h */ case    2:  		/* bc 12, CR6_EQ, 64 */
		/* 820FB574h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FB5B4;  }
		/* 820FB574h case    2:*/		return 0x820FB578;
		  /* 820FB578h */ case    3:  		/* lis R10, 28720 */
		/* 820FB578h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x7030);
		/* 820FB578h case    3:*/		return 0x820FB57C;
		  /* 820FB57Ch */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FB57Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB57Ch case    4:*/		return 0x820FB580;
		  /* 820FB580h */ case    5:  		/* bc 12, CR6_EQ, 40 */
		/* 820FB580h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FB5A8;  }
		/* 820FB580h case    5:*/		return 0x820FB584;
		  /* 820FB584h */ case    6:  		/* lis R10, 28736 */
		/* 820FB584h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x7040);
		/* 820FB584h case    6:*/		return 0x820FB588;
		  /* 820FB588h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FB588h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB588h case    7:*/		return 0x820FB58C;
		  /* 820FB58Ch */ case    8:  		/* bc 12, CR6_EQ, 28 */
		/* 820FB58Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x820FB5A8;  }
		/* 820FB58Ch case    8:*/		return 0x820FB590;
		  /* 820FB590h */ case    9:  		/* lis R10, 28752 */
		/* 820FB590h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x7050);
		/* 820FB590h case    9:*/		return 0x820FB594;
		  /* 820FB594h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820FB594h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB594h case   10:*/		return 0x820FB598;
		  /* 820FB598h */ case   11:  		/* bc 4, CR6_EQ, 644 */
		/* 820FB598h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820FB81C;  }
		/* 820FB598h case   11:*/		return 0x820FB59C;
	}
	return 0x820FB59C;
} // Block from 820FB56Ch-820FB59Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820FB59Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB59C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB59C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB59C);
		  /* 820FB59Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB59Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB59Ch case    0:*/		return 0x820FB5A0;
		  /* 820FB5A0h */ case    1:  		/* lwz R11, <#[R11 + 216]> */
		/* 820FB5A0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000D8) );
		/* 820FB5A0h case    1:*/		return 0x820FB5A4;
		  /* 820FB5A4h */ case    2:  		/* b 488 */
		/* 820FB5A4h case    2:*/		return 0x820FB78C;
		/* 820FB5A4h case    2:*/		return 0x820FB5A8;
	}
	return 0x820FB5A8;
} // Block from 820FB59Ch-820FB5A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB5A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB5A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB5A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB5A8);
		  /* 820FB5A8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB5A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB5A8h case    0:*/		return 0x820FB5AC;
		  /* 820FB5ACh */ case    1:  		/* lwz R11, <#[R11 + 208]> */
		/* 820FB5ACh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000D0) );
		/* 820FB5ACh case    1:*/		return 0x820FB5B0;
		  /* 820FB5B0h */ case    2:  		/* b 476 */
		/* 820FB5B0h case    2:*/		return 0x820FB78C;
		/* 820FB5B0h case    2:*/		return 0x820FB5B4;
	}
	return 0x820FB5B4;
} // Block from 820FB5A8h-820FB5B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB5B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB5B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB5B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB5B4);
		  /* 820FB5B4h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB5B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB5B4h case    0:*/		return 0x820FB5B8;
		  /* 820FB5B8h */ case    1:  		/* lwz R11, <#[R11 + 204]> */
		/* 820FB5B8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000CC) );
		/* 820FB5B8h case    1:*/		return 0x820FB5BC;
		  /* 820FB5BCh */ case    2:  		/* b 464 */
		/* 820FB5BCh case    2:*/		return 0x820FB78C;
		/* 820FB5BCh case    2:*/		return 0x820FB5C0;
	}
	return 0x820FB5C0;
} // Block from 820FB5B4h-820FB5C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB5C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB5C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB5C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB5C0);
		  /* 820FB5C0h */ case    0:  		/* cmplw CR6, R11, R25 */
		/* 820FB5C0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 820FB5C0h case    0:*/		return 0x820FB5C4;
		  /* 820FB5C4h */ case    1:  		/* bc 12, CR6_GT, 116 */
		/* 820FB5C4h case    1:*/		if ( regs.CR[6].gt ) { return 0x820FB638;  }
		/* 820FB5C4h case    1:*/		return 0x820FB5C8;
		  /* 820FB5C8h */ case    2:  		/* bc 12, CR6_EQ, 100 */
		/* 820FB5C8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FB62C;  }
		/* 820FB5C8h case    2:*/		return 0x820FB5CC;
		  /* 820FB5CCh */ case    3:  		/* lis R10, 28784 */
		/* 820FB5CCh case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x7070);
		/* 820FB5CCh case    3:*/		return 0x820FB5D0;
		  /* 820FB5D0h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FB5D0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB5D0h case    4:*/		return 0x820FB5D4;
		  /* 820FB5D4h */ case    5:  		/* bc 12, CR6_EQ, -56 */
		/* 820FB5D4h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FB59C;  }
		/* 820FB5D4h case    5:*/		return 0x820FB5D8;
		  /* 820FB5D8h */ case    6:  		/* lis R10, 28800 */
		/* 820FB5D8h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x7080);
		/* 820FB5D8h case    6:*/		return 0x820FB5DC;
		  /* 820FB5DCh */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FB5DCh case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB5DCh case    7:*/		return 0x820FB5E0;
		  /* 820FB5E0h */ case    8:  		/* bc 12, CR6_EQ, 64 */
		/* 820FB5E0h case    8:*/		if ( regs.CR[6].eq ) { return 0x820FB620;  }
		/* 820FB5E0h case    8:*/		return 0x820FB5E4;
		  /* 820FB5E4h */ case    9:  		/* lis R10, 28816 */
		/* 820FB5E4h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x7090);
		/* 820FB5E4h case    9:*/		return 0x820FB5E8;
		  /* 820FB5E8h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820FB5E8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB5E8h case   10:*/		return 0x820FB5EC;
		  /* 820FB5ECh */ case   11:  		/* bc 12, CR6_EQ, 40 */
		/* 820FB5ECh case   11:*/		if ( regs.CR[6].eq ) { return 0x820FB614;  }
		/* 820FB5ECh case   11:*/		return 0x820FB5F0;
		  /* 820FB5F0h */ case   12:  		/* lis R10, 28848 */
		/* 820FB5F0h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0x70B0);
		/* 820FB5F0h case   12:*/		return 0x820FB5F4;
		  /* 820FB5F4h */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 820FB5F4h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB5F4h case   13:*/		return 0x820FB5F8;
		  /* 820FB5F8h */ case   14:  		/* bc 12, CR6_EQ, -820 */
		/* 820FB5F8h case   14:*/		if ( regs.CR[6].eq ) { return 0x820FB2C4;  }
		/* 820FB5F8h case   14:*/		return 0x820FB5FC;
		  /* 820FB5FCh */ case   15:  		/* lis R10, 28864 */
		/* 820FB5FCh case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0x70C0);
		/* 820FB5FCh case   15:*/		return 0x820FB600;
		  /* 820FB600h */ case   16:  		/* cmplw CR6, R11, R10 */
		/* 820FB600h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB600h case   16:*/		return 0x820FB604;
		  /* 820FB604h */ case   17:  		/* bc 4, CR6_EQ, 536 */
		/* 820FB604h case   17:*/		if ( !regs.CR[6].eq ) { return 0x820FB81C;  }
		/* 820FB604h case   17:*/		return 0x820FB608;
	}
	return 0x820FB608;
} // Block from 820FB5C0h-820FB608h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820FB608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB608);
		  /* 820FB608h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB608h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB608h case    0:*/		return 0x820FB60C;
		  /* 820FB60Ch */ case    1:  		/* lwz R11, <#[R11 + 160]> */
		/* 820FB60Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000A0) );
		/* 820FB60Ch case    1:*/		return 0x820FB610;
		  /* 820FB610h */ case    2:  		/* b 380 */
		/* 820FB610h case    2:*/		return 0x820FB78C;
		/* 820FB610h case    2:*/		return 0x820FB614;
	}
	return 0x820FB614;
} // Block from 820FB608h-820FB614h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB614);
		  /* 820FB614h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB614h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB614h case    0:*/		return 0x820FB618;
		  /* 820FB618h */ case    1:  		/* lwz R11, <#[R11 + 212]> */
		/* 820FB618h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000D4) );
		/* 820FB618h case    1:*/		return 0x820FB61C;
		  /* 820FB61Ch */ case    2:  		/* b 368 */
		/* 820FB61Ch case    2:*/		return 0x820FB78C;
		/* 820FB61Ch case    2:*/		return 0x820FB620;
	}
	return 0x820FB620;
} // Block from 820FB614h-820FB620h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB620h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB620( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB620) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB620);
		  /* 820FB620h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB620h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB620h case    0:*/		return 0x820FB624;
		  /* 820FB624h */ case    1:  		/* lwz R11, <#[R11 + 284]> */
		/* 820FB624h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000011C) );
		/* 820FB624h case    1:*/		return 0x820FB628;
		  /* 820FB628h */ case    2:  		/* b 356 */
		/* 820FB628h case    2:*/		return 0x820FB78C;
		/* 820FB628h case    2:*/		return 0x820FB62C;
	}
	return 0x820FB62C;
} // Block from 820FB620h-820FB62Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB62Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB62C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB62C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB62C);
		  /* 820FB62Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB62Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB62Ch case    0:*/		return 0x820FB630;
		  /* 820FB630h */ case    1:  		/* lwz R11, <#[R11 + 148]> */
		/* 820FB630h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000094) );
		/* 820FB630h case    1:*/		return 0x820FB634;
		  /* 820FB634h */ case    2:  		/* b 344 */
		/* 820FB634h case    2:*/		return 0x820FB78C;
		/* 820FB634h case    2:*/		return 0x820FB638;
	}
	return 0x820FB638;
} // Block from 820FB62Ch-820FB638h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB638);
		  /* 820FB638h */ case    0:  		/* lis R10, 29440 */
		/* 820FB638h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x7300);
		/* 820FB638h case    0:*/		return 0x820FB63C;
		  /* 820FB63Ch */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FB63Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB63Ch case    1:*/		return 0x820FB640;
		  /* 820FB640h */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 820FB640h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FB67C;  }
		/* 820FB640h case    2:*/		return 0x820FB644;
		  /* 820FB644h */ case    3:  		/* lis R10, 29456 */
		/* 820FB644h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x7310);
		/* 820FB644h case    3:*/		return 0x820FB648;
		  /* 820FB648h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FB648h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB648h case    4:*/		return 0x820FB64C;
		  /* 820FB64Ch */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 820FB64Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820FB668;  }
		/* 820FB64Ch case    5:*/		return 0x820FB650;
		  /* 820FB650h */ case    6:  		/* lis R10, 29472 */
		/* 820FB650h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x7320);
		/* 820FB650h case    6:*/		return 0x820FB654;
		  /* 820FB654h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FB654h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB654h case    7:*/		return 0x820FB658;
		  /* 820FB658h */ case    8:  		/* bc 12, CR6_EQ, 28 */
		/* 820FB658h case    8:*/		if ( regs.CR[6].eq ) { return 0x820FB674;  }
		/* 820FB658h case    8:*/		return 0x820FB65C;
		  /* 820FB65Ch */ case    9:  		/* lis R10, 29488 */
		/* 820FB65Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x7330);
		/* 820FB65Ch case    9:*/		return 0x820FB660;
		  /* 820FB660h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820FB660h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB660h case   10:*/		return 0x820FB664;
		  /* 820FB664h */ case   11:  		/* bc 4, CR6_EQ, 440 */
		/* 820FB664h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820FB81C;  }
		/* 820FB664h case   11:*/		return 0x820FB668;
	}
	return 0x820FB668;
} // Block from 820FB638h-820FB668h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820FB668h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB668);
		  /* 820FB668h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB668h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB668h case    0:*/		return 0x820FB66C;
		  /* 820FB66Ch */ case    1:  		/* lwz R11, <#[R11 + 296]> */
		/* 820FB66Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000128) );
		/* 820FB66Ch case    1:*/		return 0x820FB670;
		  /* 820FB670h */ case    2:  		/* b 284 */
		/* 820FB670h case    2:*/		return 0x820FB78C;
		/* 820FB670h case    2:*/		return 0x820FB674;
	}
	return 0x820FB674;
} // Block from 820FB668h-820FB674h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB674);
		  /* 820FB674h */ case    0:  		/* li R4, 1 */
		/* 820FB674h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820FB674h case    0:*/		return 0x820FB678;
		  /* 820FB678h */ case    1:  		/* b 8 */
		/* 820FB678h case    1:*/		return 0x820FB680;
		/* 820FB678h case    1:*/		return 0x820FB67C;
	}
	return 0x820FB67C;
} // Block from 820FB674h-820FB67Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FB67Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB67C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB67C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB67C);
		  /* 820FB67Ch */ case    0:  		/* li R4, 0 */
		/* 820FB67Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820FB67Ch case    0:*/		return 0x820FB680;
	}
	return 0x820FB680;
} // Block from 820FB67Ch-820FB680h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FB680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB680);
		  /* 820FB680h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB680h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB680h case    0:*/		return 0x820FB684;
		  /* 820FB684h */ case    1:  		/* mr R3, R31 */
		/* 820FB684h case    1:*/		regs.R3 = regs.R31;
		/* 820FB684h case    1:*/		return 0x820FB688;
		  /* 820FB688h */ case    2:  		/* lwz R11, <#[R11 + 292]> */
		/* 820FB688h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000124) );
		/* 820FB688h case    2:*/		return 0x820FB68C;
		  /* 820FB68Ch */ case    3:  		/* mtspr CTR, R11 */
		/* 820FB68Ch case    3:*/		regs.CTR = regs.R11;
		/* 820FB68Ch case    3:*/		return 0x820FB690;
		  /* 820FB690h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 820FB690h case    4:*/		if ( 1 ) { regs.LR = 0x820FB694; return (uint32)regs.CTR; }
		/* 820FB690h case    4:*/		return 0x820FB694;
		  /* 820FB694h */ case    5:  		/* b 260 */
		/* 820FB694h case    5:*/		return 0x820FB798;
		/* 820FB694h case    5:*/		return 0x820FB698;
	}
	return 0x820FB698;
} // Block from 820FB680h-820FB698h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FB698h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB698);
		  /* 820FB698h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB698h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB698h case    0:*/		return 0x820FB69C;
		  /* 820FB69Ch */ case    1:  		/* lwz R11, <#[R11 + 300]> */
		/* 820FB69Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000012C) );
		/* 820FB69Ch case    1:*/		return 0x820FB6A0;
		  /* 820FB6A0h */ case    2:  		/* b 236 */
		/* 820FB6A0h case    2:*/		return 0x820FB78C;
		/* 820FB6A0h case    2:*/		return 0x820FB6A4;
	}
	return 0x820FB6A4;
} // Block from 820FB698h-820FB6A4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB6A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB6A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB6A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB6A4);
		  /* 820FB6A4h */ case    0:  		/* cmplw CR6, R11, R26 */
		/* 820FB6A4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 820FB6A4h case    0:*/		return 0x820FB6A8;
		  /* 820FB6A8h */ case    1:  		/* bc 12, CR6_GT, 148 */
		/* 820FB6A8h case    1:*/		if ( regs.CR[6].gt ) { return 0x820FB73C;  }
		/* 820FB6A8h case    1:*/		return 0x820FB6AC;
		  /* 820FB6ACh */ case    2:  		/* bc 12, CR6_EQ, -68 */
		/* 820FB6ACh case    2:*/		if ( regs.CR[6].eq ) { return 0x820FB668;  }
		/* 820FB6ACh case    2:*/		return 0x820FB6B0;
		  /* 820FB6B0h */ case    3:  		/* cmplw CR6, R11, R27 */
		/* 820FB6B0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 820FB6B0h case    3:*/		return 0x820FB6B4;
		  /* 820FB6B4h */ case    4:  		/* bc 12, CR6_GT, 92 */
		/* 820FB6B4h case    4:*/		if ( regs.CR[6].gt ) { return 0x820FB710;  }
		/* 820FB6B4h case    4:*/		return 0x820FB6B8;
		  /* 820FB6B8h */ case    5:  		/* bc 12, CR6_EQ, 64 */
		/* 820FB6B8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FB6F8;  }
		/* 820FB6B8h case    5:*/		return 0x820FB6BC;
		  /* 820FB6BCh */ case    6:  		/* lis R10, 29520 */
		/* 820FB6BCh case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x7350);
		/* 820FB6BCh case    6:*/		return 0x820FB6C0;
		  /* 820FB6C0h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FB6C0h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB6C0h case    7:*/		return 0x820FB6C4;
		  /* 820FB6C4h */ case    8:  		/* bc 12, CR6_EQ, 64 */
		/* 820FB6C4h case    8:*/		if ( regs.CR[6].eq ) { return 0x820FB704;  }
		/* 820FB6C4h case    8:*/		return 0x820FB6C8;
		  /* 820FB6C8h */ case    9:  		/* lis R10, 29536 */
		/* 820FB6C8h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x7360);
		/* 820FB6C8h case    9:*/		return 0x820FB6CC;
		  /* 820FB6CCh */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820FB6CCh case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB6CCh case   10:*/		return 0x820FB6D0;
		  /* 820FB6D0h */ case   11:  		/* bc 12, CR6_EQ, 52 */
		/* 820FB6D0h case   11:*/		if ( regs.CR[6].eq ) { return 0x820FB704;  }
		/* 820FB6D0h case   11:*/		return 0x820FB6D4;
		  /* 820FB6D4h */ case   12:  		/* lis R10, 29552 */
		/* 820FB6D4h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0x7370);
		/* 820FB6D4h case   12:*/		return 0x820FB6D8;
		  /* 820FB6D8h */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 820FB6D8h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB6D8h case   13:*/		return 0x820FB6DC;
		  /* 820FB6DCh */ case   14:  		/* bc 12, CR6_EQ, 40 */
		/* 820FB6DCh case   14:*/		if ( regs.CR[6].eq ) { return 0x820FB704;  }
		/* 820FB6DCh case   14:*/		return 0x820FB6E0;
		  /* 820FB6E0h */ case   15:  		/* lis R10, 29568 */
		/* 820FB6E0h case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0x7380);
		/* 820FB6E0h case   15:*/		return 0x820FB6E4;
		  /* 820FB6E4h */ case   16:  		/* cmplw CR6, R11, R10 */
		/* 820FB6E4h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB6E4h case   16:*/		return 0x820FB6E8;
		  /* 820FB6E8h */ case   17:  		/* bc 12, CR6_EQ, 28 */
		/* 820FB6E8h case   17:*/		if ( regs.CR[6].eq ) { return 0x820FB704;  }
		/* 820FB6E8h case   17:*/		return 0x820FB6EC;
		  /* 820FB6ECh */ case   18:  		/* lis R10, 29584 */
		/* 820FB6ECh case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0x7390);
		/* 820FB6ECh case   18:*/		return 0x820FB6F0;
		  /* 820FB6F0h */ case   19:  		/* cmplw CR6, R11, R10 */
		/* 820FB6F0h case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB6F0h case   19:*/		return 0x820FB6F4;
		  /* 820FB6F4h */ case   20:  		/* bc 4, CR6_EQ, 296 */
		/* 820FB6F4h case   20:*/		if ( !regs.CR[6].eq ) { return 0x820FB81C;  }
		/* 820FB6F4h case   20:*/		return 0x820FB6F8;
	}
	return 0x820FB6F8;
} // Block from 820FB6A4h-820FB6F8h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820FB6F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB6F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB6F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB6F8);
		  /* 820FB6F8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB6F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB6F8h case    0:*/		return 0x820FB6FC;
		  /* 820FB6FCh */ case    1:  		/* lwz R11, <#[R11 + 288]> */
		/* 820FB6FCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000120) );
		/* 820FB6FCh case    1:*/		return 0x820FB700;
		  /* 820FB700h */ case    2:  		/* b 140 */
		/* 820FB700h case    2:*/		return 0x820FB78C;
		/* 820FB700h case    2:*/		return 0x820FB704;
	}
	return 0x820FB704;
} // Block from 820FB6F8h-820FB704h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB704h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB704( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB704) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB704);
		  /* 820FB704h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB704h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB704h case    0:*/		return 0x820FB708;
		  /* 820FB708h */ case    1:  		/* lwz R11, <#[R11 + 256]> */
		/* 820FB708h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000100) );
		/* 820FB708h case    1:*/		return 0x820FB70C;
		  /* 820FB70Ch */ case    2:  		/* b 128 */
		/* 820FB70Ch case    2:*/		return 0x820FB78C;
		/* 820FB70Ch case    2:*/		return 0x820FB710;
	}
	return 0x820FB710;
} // Block from 820FB704h-820FB710h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB710);
		  /* 820FB710h */ case    0:  		/* lis R10, 29616 */
		/* 820FB710h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x73B0);
		/* 820FB710h case    0:*/		return 0x820FB714;
		  /* 820FB714h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FB714h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB714h case    1:*/		return 0x820FB718;
		  /* 820FB718h */ case    2:  		/* bc 12, CR6_EQ, -32 */
		/* 820FB718h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FB6F8;  }
		/* 820FB718h case    2:*/		return 0x820FB71C;
		  /* 820FB71Ch */ case    3:  		/* lis R10, 29632 */
		/* 820FB71Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x73C0);
		/* 820FB71Ch case    3:*/		return 0x820FB720;
		  /* 820FB720h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FB720h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB720h case    4:*/		return 0x820FB724;
		  /* 820FB724h */ case    5:  		/* bc 12, CR6_EQ, -44 */
		/* 820FB724h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FB6F8;  }
		/* 820FB724h case    5:*/		return 0x820FB728;
		  /* 820FB728h */ case    6:  		/* lis R10, 29648 */
		/* 820FB728h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x73D0);
		/* 820FB728h case    6:*/		return 0x820FB72C;
		  /* 820FB72Ch */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FB72Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB72Ch case    7:*/		return 0x820FB730;
		  /* 820FB730h */ case    8:  		/* bc 12, CR6_EQ, -200 */
		/* 820FB730h case    8:*/		if ( regs.CR[6].eq ) { return 0x820FB668;  }
		/* 820FB730h case    8:*/		return 0x820FB734;
		  /* 820FB734h */ case    9:  		/* lis R10, 29664 */
		/* 820FB734h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x73E0);
		/* 820FB734h case    9:*/		return 0x820FB738;
		  /* 820FB738h */ case   10:  		/* b -216 */
		/* 820FB738h case   10:*/		return 0x820FB660;
		/* 820FB738h case   10:*/		return 0x820FB73C;
	}
	return 0x820FB73C;
} // Block from 820FB710h-820FB73Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FB73Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB73C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB73C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB73C);
		  /* 820FB73Ch */ case    0:  		/* cmplw CR6, R11, R28 */
		/* 820FB73Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 820FB73Ch case    0:*/		return 0x820FB740;
		  /* 820FB740h */ case    1:  		/* bc 12, CR6_GT, 148 */
		/* 820FB740h case    1:*/		if ( regs.CR[6].gt ) { return 0x820FB7D4;  }
		/* 820FB740h case    1:*/		return 0x820FB744;
		  /* 820FB744h */ case    2:  		/* bc 12, CR6_EQ, 64 */
		/* 820FB744h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FB784;  }
		/* 820FB744h case    2:*/		return 0x820FB748;
		  /* 820FB748h */ case    3:  		/* lis R10, 29696 */
		/* 820FB748h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x7400);
		/* 820FB748h case    3:*/		return 0x820FB74C;
		  /* 820FB74Ch */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FB74Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB74Ch case    4:*/		return 0x820FB750;
		  /* 820FB750h */ case    5:  		/* bc 12, CR6_EQ, -232 */
		/* 820FB750h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FB668;  }
		/* 820FB750h case    5:*/		return 0x820FB754;
		  /* 820FB754h */ case    6:  		/* lis R10, 29712 */
		/* 820FB754h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x7410);
		/* 820FB754h case    6:*/		return 0x820FB758;
		  /* 820FB758h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FB758h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB758h case    7:*/		return 0x820FB75C;
		  /* 820FB75Ch */ case    8:  		/* bc 12, CR6_EQ, 108 */
		/* 820FB75Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x820FB7C8;  }
		/* 820FB75Ch case    8:*/		return 0x820FB760;
		  /* 820FB760h */ case    9:  		/* lis R10, 29728 */
		/* 820FB760h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x7420);
		/* 820FB760h case    9:*/		return 0x820FB764;
		  /* 820FB764h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820FB764h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB764h case   10:*/		return 0x820FB768;
		  /* 820FB768h */ case   11:  		/* bc 12, CR6_EQ, 84 */
		/* 820FB768h case   11:*/		if ( regs.CR[6].eq ) { return 0x820FB7BC;  }
		/* 820FB768h case   11:*/		return 0x820FB76C;
		  /* 820FB76Ch */ case   12:  		/* lis R10, 29744 */
		/* 820FB76Ch case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0x7430);
		/* 820FB76Ch case   12:*/		return 0x820FB770;
		  /* 820FB770h */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 820FB770h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB770h case   13:*/		return 0x820FB774;
		  /* 820FB774h */ case   14:  		/* bc 12, CR6_EQ, 16 */
		/* 820FB774h case   14:*/		if ( regs.CR[6].eq ) { return 0x820FB784;  }
		/* 820FB774h case   14:*/		return 0x820FB778;
		  /* 820FB778h */ case   15:  		/* lis R10, 29760 */
		/* 820FB778h case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0x7440);
		/* 820FB778h case   15:*/		return 0x820FB77C;
		  /* 820FB77Ch */ case   16:  		/* cmplw CR6, R11, R10 */
		/* 820FB77Ch case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB77Ch case   16:*/		return 0x820FB780;
		  /* 820FB780h */ case   17:  		/* bc 4, CR6_EQ, 156 */
		/* 820FB780h case   17:*/		if ( !regs.CR[6].eq ) { return 0x820FB81C;  }
		/* 820FB780h case   17:*/		return 0x820FB784;
	}
	return 0x820FB784;
} // Block from 820FB73Ch-820FB784h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820FB784h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB784( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB784) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB784);
		  /* 820FB784h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB784h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB784h case    0:*/		return 0x820FB788;
		  /* 820FB788h */ case    1:  		/* lwz R11, <#[R11 + 252]> */
		/* 820FB788h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000FC) );
		/* 820FB788h case    1:*/		return 0x820FB78C;
	}
	return 0x820FB78C;
} // Block from 820FB784h-820FB78Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FB78Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB78C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB78C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB78C);
		  /* 820FB78Ch */ case    0:  		/* mr R3, R31 */
		/* 820FB78Ch case    0:*/		regs.R3 = regs.R31;
		/* 820FB78Ch case    0:*/		return 0x820FB790;
		  /* 820FB790h */ case    1:  		/* mtspr CTR, R11 */
		/* 820FB790h case    1:*/		regs.CTR = regs.R11;
		/* 820FB790h case    1:*/		return 0x820FB794;
		  /* 820FB794h */ case    2:  		/* bcctrl 20, CR0_LT */
		/* 820FB794h case    2:*/		if ( 1 ) { regs.LR = 0x820FB798; return (uint32)regs.CTR; }
		/* 820FB794h case    2:*/		return 0x820FB798;
	}
	return 0x820FB798;
} // Block from 820FB78Ch-820FB798h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB798h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB798);
		  /* 820FB798h */ case    0:  		/* cmpw CR6, R3, R30 */
		/* 820FB798h case    0:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R30);
		/* 820FB798h case    0:*/		return 0x820FB79C;
		  /* 820FB79Ch */ case    1:  		/* bc 12, CR6_EQ, 128 */
		/* 820FB79Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820FB81C;  }
		/* 820FB79Ch case    1:*/		return 0x820FB7A0;
	}
	return 0x820FB7A0;
} // Block from 820FB798h-820FB7A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FB7A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB7A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB7A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB7A0);
		  /* 820FB7A0h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FB7A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FB7A0h case    0:*/		return 0x820FB7A4;
		  /* 820FB7A4h */ case    1:  		/* addi R14, R14, 1 */
		/* 820FB7A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R14,regs.R14,0x1);
		/* 820FB7A4h case    1:*/		return 0x820FB7A8;
		  /* 820FB7A8h */ case    2:  		/* cmplw CR6, R14, R11 */
		/* 820FB7A8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R14,regs.R11);
		/* 820FB7A8h case    2:*/		return 0x820FB7AC;
		  /* 820FB7ACh */ case    3:  		/* bc 12, CR6_LT, -1712 */
		/* 820FB7ACh case    3:*/		if ( regs.CR[6].lt ) { return 0x820FB0FC;  }
		/* 820FB7ACh case    3:*/		return 0x820FB7B0;
	}
	return 0x820FB7B0;
} // Block from 820FB7A0h-820FB7B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FB7B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB7B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB7B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB7B0);
		  /* 820FB7B0h */ case    0:  		/* li R3, 0 */
		/* 820FB7B0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FB7B0h case    0:*/		return 0x820FB7B4;
	}
	return 0x820FB7B4;
} // Block from 820FB7B0h-820FB7B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FB7B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB7B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB7B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB7B4);
		  /* 820FB7B4h */ case    0:  		/* addi R1, R1, 240 */
		/* 820FB7B4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 820FB7B4h case    0:*/		return 0x820FB7B8;
		  /* 820FB7B8h */ case    1:  		/* b -435528 */
		/* 820FB7B8h case    1:*/		return 0x82091270;
		/* 820FB7B8h case    1:*/		return 0x820FB7BC;
	}
	return 0x820FB7BC;
} // Block from 820FB7B4h-820FB7BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FB7BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB7BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB7BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB7BC);
		  /* 820FB7BCh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB7BCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB7BCh case    0:*/		return 0x820FB7C0;
		  /* 820FB7C0h */ case    1:  		/* lwz R11, <#[R11 + 236]> */
		/* 820FB7C0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000EC) );
		/* 820FB7C0h case    1:*/		return 0x820FB7C4;
		  /* 820FB7C4h */ case    2:  		/* b -56 */
		/* 820FB7C4h case    2:*/		return 0x820FB78C;
		/* 820FB7C4h case    2:*/		return 0x820FB7C8;
	}
	return 0x820FB7C8;
} // Block from 820FB7BCh-820FB7C8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB7C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB7C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB7C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB7C8);
		  /* 820FB7C8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB7C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB7C8h case    0:*/		return 0x820FB7CC;
		  /* 820FB7CCh */ case    1:  		/* lwz R11, <#[R11 + 244]> */
		/* 820FB7CCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000F4) );
		/* 820FB7CCh case    1:*/		return 0x820FB7D0;
		  /* 820FB7D0h */ case    2:  		/* b -68 */
		/* 820FB7D0h case    2:*/		return 0x820FB78C;
		/* 820FB7D0h case    2:*/		return 0x820FB7D4;
	}
	return 0x820FB7D4;
} // Block from 820FB7C8h-820FB7D4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB7D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB7D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB7D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB7D4);
		  /* 820FB7D4h */ case    0:  		/* lis R10, 29792 */
		/* 820FB7D4h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x7460);
		/* 820FB7D4h case    0:*/		return 0x820FB7D8;
		  /* 820FB7D8h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FB7D8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB7D8h case    1:*/		return 0x820FB7DC;
		  /* 820FB7DCh */ case    2:  		/* bc 12, CR6_EQ, -88 */
		/* 820FB7DCh case    2:*/		if ( regs.CR[6].eq ) { return 0x820FB784;  }
		/* 820FB7DCh case    2:*/		return 0x820FB7E0;
		  /* 820FB7E0h */ case    3:  		/* lis R10, 29808 */
		/* 820FB7E0h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x7470);
		/* 820FB7E0h case    3:*/		return 0x820FB7E4;
		  /* 820FB7E4h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FB7E4h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB7E4h case    4:*/		return 0x820FB7E8;
		  /* 820FB7E8h */ case    5:  		/* bc 12, CR6_EQ, -100 */
		/* 820FB7E8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FB784;  }
		/* 820FB7E8h case    5:*/		return 0x820FB7EC;
		  /* 820FB7ECh */ case    6:  		/* lis R10, 29856 */
		/* 820FB7ECh case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x74A0);
		/* 820FB7ECh case    6:*/		return 0x820FB7F0;
		  /* 820FB7F0h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FB7F0h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB7F0h case    7:*/		return 0x820FB7F4;
		  /* 820FB7F4h */ case    8:  		/* bc 12, CR6_EQ, 28 */
		/* 820FB7F4h case    8:*/		if ( regs.CR[6].eq ) { return 0x820FB810;  }
		/* 820FB7F4h case    8:*/		return 0x820FB7F8;
		  /* 820FB7F8h */ case    9:  		/* lis R10, 29872 */
		/* 820FB7F8h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x74B0);
		/* 820FB7F8h case    9:*/		return 0x820FB7FC;
		  /* 820FB7FCh */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820FB7FCh case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FB7FCh case   10:*/		return 0x820FB800;
		  /* 820FB800h */ case   11:  		/* bc 4, CR6_EQ, 28 */
		/* 820FB800h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820FB81C;  }
		/* 820FB800h case   11:*/		return 0x820FB804;
		  /* 820FB804h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 820FB804h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB804h case   12:*/		return 0x820FB808;
		  /* 820FB808h */ case   13:  		/* lwz R11, <#[R11 + 240]> */
		/* 820FB808h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000F0) );
		/* 820FB808h case   13:*/		return 0x820FB80C;
		  /* 820FB80Ch */ case   14:  		/* b -128 */
		/* 820FB80Ch case   14:*/		return 0x820FB78C;
		/* 820FB80Ch case   14:*/		return 0x820FB810;
	}
	return 0x820FB810;
} // Block from 820FB7D4h-820FB810h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820FB810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB810);
		  /* 820FB810h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FB810h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB810h case    0:*/		return 0x820FB814;
		  /* 820FB814h */ case    1:  		/* lwz R11, <#[R11 + 248]> */
		/* 820FB814h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000F8) );
		/* 820FB814h case    1:*/		return 0x820FB818;
		  /* 820FB818h */ case    2:  		/* b -140 */
		/* 820FB818h case    2:*/		return 0x820FB78C;
		/* 820FB818h case    2:*/		return 0x820FB81C;
	}
	return 0x820FB81C;
} // Block from 820FB810h-820FB81Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB81Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB81C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB81C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB81C);
		  /* 820FB81Ch */ case    0:  		/* lwz R11, <#[R31 + 112]> */
		/* 820FB81Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820FB81Ch case    0:*/		return 0x820FB820;
		  /* 820FB820h */ case    1:  		/* li R5, 4532 */
		/* 820FB820h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x11B4);
		/* 820FB820h case    1:*/		return 0x820FB824;
		  /* 820FB824h */ case    2:  		/* mr R3, R31 */
		/* 820FB824h case    2:*/		regs.R3 = regs.R31;
		/* 820FB824h case    2:*/		return 0x820FB828;
		  /* 820FB828h */ case    3:  		/* rlwinm. R11, R11, 0, 7, 7 */
		/* 820FB828h case    3:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R11,regs.R11);
		/* 820FB828h case    3:*/		return 0x820FB82C;
		  /* 820FB82Ch */ case    4:  		/* lwz R11, <#[R31 + 260]> */
		/* 820FB82Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820FB82Ch case    4:*/		return 0x820FB830;
		  /* 820FB830h */ case    5:  		/* lwz R4, <#[R11 + 60]> */
		/* 820FB830h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000003C) );
		/* 820FB830h case    5:*/		return 0x820FB834;
		  /* 820FB834h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 820FB834h case    6:*/		if ( regs.CR[0].eq ) { return 0x820FB844;  }
		/* 820FB834h case    6:*/		return 0x820FB838;
		  /* 820FB838h */ case    7:  		/* lis R10, -32254 */
		/* 820FB838h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820FB838h case    7:*/		return 0x820FB83C;
		  /* 820FB83Ch */ case    8:  		/* addi R6, R10, -31872 */
		/* 820FB83Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFF8380);
		/* 820FB83Ch case    8:*/		return 0x820FB840;
		  /* 820FB840h */ case    9:  		/* b 12 */
		/* 820FB840h case    9:*/		return 0x820FB84C;
		/* 820FB840h case    9:*/		return 0x820FB844;
	}
	return 0x820FB844;
} // Block from 820FB81Ch-820FB844h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FB844h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB844( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB844) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB844);
		  /* 820FB844h */ case    0:  		/* lis R10, -32254 */
		/* 820FB844h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820FB844h case    0:*/		return 0x820FB848;
		  /* 820FB848h */ case    1:  		/* addi R6, R10, -31928 */
		/* 820FB848h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFF8348);
		/* 820FB848h case    1:*/		return 0x820FB84C;
	}
	return 0x820FB84C;
} // Block from 820FB844h-820FB84Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FB84Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB84C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB84C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB84C);
		  /* 820FB84Ch */ case    0:  		/* bl 77540 */
		/* 820FB84Ch case    0:*/		regs.LR = 0x820FB850; return 0x8210E730;
		/* 820FB84Ch case    0:*/		return 0x820FB850;
		  /* 820FB850h */ case    1:  		/* mr R3, R30 */
		/* 820FB850h case    1:*/		regs.R3 = regs.R30;
		/* 820FB850h case    1:*/		return 0x820FB854;
		  /* 820FB854h */ case    2:  		/* b -160 */
		/* 820FB854h case    2:*/		return 0x820FB7B4;
		/* 820FB854h case    2:*/		return 0x820FB858;
	}
	return 0x820FB858;
} // Block from 820FB84Ch-820FB858h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB858h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB858);
		  /* 820FB858h */ case    0:  		/* mfspr R12, LR */
		/* 820FB858h case    0:*/		regs.R12 = regs.LR;
		/* 820FB858h case    0:*/		return 0x820FB85C;
		  /* 820FB85Ch */ case    1:  		/* bl -435728 */
		/* 820FB85Ch case    1:*/		regs.LR = 0x820FB860; return 0x8209124C;
		/* 820FB85Ch case    1:*/		return 0x820FB860;
		  /* 820FB860h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 820FB860h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 820FB860h case    2:*/		return 0x820FB864;
		  /* 820FB864h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820FB864h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820FB864h case    3:*/		return 0x820FB868;
		  /* 820FB868h */ case    4:  		/* mr R26, R4 */
		/* 820FB868h case    4:*/		regs.R26 = regs.R4;
		/* 820FB868h case    4:*/		return 0x820FB86C;
		  /* 820FB86Ch */ case    5:  		/* lwz R4, <#[R4 + 108]> */
		/* 820FB86Ch case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x0000006C) );
		/* 820FB86Ch case    5:*/		return 0x820FB870;
		  /* 820FB870h */ case    6:  		/* mr R31, R3 */
		/* 820FB870h case    6:*/		regs.R31 = regs.R3;
		/* 820FB870h case    6:*/		return 0x820FB874;
		  /* 820FB874h */ case    7:  		/* mr R25, R5 */
		/* 820FB874h case    7:*/		regs.R25 = regs.R5;
		/* 820FB874h case    7:*/		return 0x820FB878;
		  /* 820FB878h */ case    8:  		/* lwz R11, <#[R11 + 112]> */
		/* 820FB878h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000070) );
		/* 820FB878h case    8:*/		return 0x820FB87C;
		  /* 820FB87Ch */ case    9:  		/* mtspr CTR, R11 */
		/* 820FB87Ch case    9:*/		regs.CTR = regs.R11;
		/* 820FB87Ch case    9:*/		return 0x820FB880;
		  /* 820FB880h */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 820FB880h case   10:*/		if ( 1 ) { regs.LR = 0x820FB884; return (uint32)regs.CTR; }
		/* 820FB880h case   10:*/		return 0x820FB884;
		  /* 820FB884h */ case   11:  		/* lwz R11, <#[R31]> */
		/* 820FB884h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FB884h case   11:*/		return 0x820FB888;
		  /* 820FB888h */ case   12:  		/* mr R30, R3 */
		/* 820FB888h case   12:*/		regs.R30 = regs.R3;
		/* 820FB888h case   12:*/		return 0x820FB88C;
		  /* 820FB88Ch */ case   13:  		/* mr R3, R31 */
		/* 820FB88Ch case   13:*/		regs.R3 = regs.R31;
		/* 820FB88Ch case   13:*/		return 0x820FB890;
		  /* 820FB890h */ case   14:  		/* lwz R4, <#[R26 + 108]> */
		/* 820FB890h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x0000006C) );
		/* 820FB890h case   14:*/		return 0x820FB894;
		  /* 820FB894h */ case   15:  		/* lwz R11, <#[R11 + 116]> */
		/* 820FB894h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000074) );
		/* 820FB894h case   15:*/		return 0x820FB898;
		  /* 820FB898h */ case   16:  		/* mtspr CTR, R11 */
		/* 820FB898h case   16:*/		regs.CTR = regs.R11;
		/* 820FB898h case   16:*/		return 0x820FB89C;
		  /* 820FB89Ch */ case   17:  		/* bcctrl 20, CR0_LT */
		/* 820FB89Ch case   17:*/		if ( 1 ) { regs.LR = 0x820FB8A0; return (uint32)regs.CTR; }
		/* 820FB89Ch case   17:*/		return 0x820FB8A0;
		  /* 820FB8A0h */ case   18:  		/* lwz R11, <#[R31 + 348]> */
		/* 820FB8A0h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000015C) );
		/* 820FB8A0h case   18:*/		return 0x820FB8A4;
		  /* 820FB8A4h */ case   19:  		/* mr R29, R3 */
		/* 820FB8A4h case   19:*/		regs.R29 = regs.R3;
		/* 820FB8A4h case   19:*/		return 0x820FB8A8;
		  /* 820FB8A8h */ case   20:  		/* cmpwi CR6, R11, 0 */
		/* 820FB8A8h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820FB8A8h case   20:*/		return 0x820FB8AC;
		  /* 820FB8ACh */ case   21:  		/* bc 12, CR6_EQ, 404 */
		/* 820FB8ACh case   21:*/		if ( regs.CR[6].eq ) { return 0x820FBA40;  }
		/* 820FB8ACh case   21:*/		return 0x820FB8B0;
		  /* 820FB8B0h */ case   22:  		/* lwz R11, <#[R26 + 108]> */
		/* 820FB8B0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000006C) );
		/* 820FB8B0h case   22:*/		return 0x820FB8B4;
		  /* 820FB8B4h */ case   23:  		/* cmpwi CR6, R11, -1 */
		/* 820FB8B4h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FB8B4h case   23:*/		return 0x820FB8B8;
		  /* 820FB8B8h */ case   24:  		/* bc 4, CR6_EQ, 12 */
		/* 820FB8B8h case   24:*/		if ( !regs.CR[6].eq ) { return 0x820FB8C4;  }
		/* 820FB8B8h case   24:*/		return 0x820FB8BC;
		  /* 820FB8BCh */ case   25:  		/* li R3, 0 */
		/* 820FB8BCh case   25:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FB8BCh case   25:*/		return 0x820FB8C0;
		  /* 820FB8C0h */ case   26:  		/* b 696 */
		/* 820FB8C0h case   26:*/		return 0x820FBB78;
		/* 820FB8C0h case   26:*/		return 0x820FB8C4;
	}
	return 0x820FB8C4;
} // Block from 820FB858h-820FB8C4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820FB8C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB8C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB8C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB8C4);
		  /* 820FB8C4h */ case    0:  		/* cmplwi CR6, R30, 65535 */
		/* 820FB8C4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x0000FFFF);
		/* 820FB8C4h case    0:*/		return 0x820FB8C8;
		  /* 820FB8C8h */ case    1:  		/* bc 12, CR6_EQ, 356 */
		/* 820FB8C8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820FBA2C;  }
		/* 820FB8C8h case    1:*/		return 0x820FB8CC;
		  /* 820FB8CCh */ case    2:  		/* lwz R11, <#[R26 + 4]> */
		/* 820FB8CCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 820FB8CCh case    2:*/		return 0x820FB8D0;
		  /* 820FB8D0h */ case    3:  		/* mr R4, R30 */
		/* 820FB8D0h case    3:*/		regs.R4 = regs.R30;
		/* 820FB8D0h case    3:*/		return 0x820FB8D4;
		  /* 820FB8D4h */ case    4:  		/* lwz R10, <#[R31 + 16]> */
		/* 820FB8D4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820FB8D4h case    4:*/		return 0x820FB8D8;
		  /* 820FB8D8h */ case    5:  		/* mr R3, R31 */
		/* 820FB8D8h case    5:*/		regs.R3 = regs.R31;
		/* 820FB8D8h case    5:*/		return 0x820FB8DC;
		  /* 820FB8DCh */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FB8DCh case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FB8DCh case    6:*/		return 0x820FB8E0;
		  /* 820FB8E0h */ case    7:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820FB8E0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FB8E0h case    7:*/		return 0x820FB8E4;
		  /* 820FB8E4h */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 820FB8E4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820FB8E4h case    8:*/		return 0x820FB8E8;
		  /* 820FB8E8h */ case    9:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 820FB8E8h case    9:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 820FB8E8h case    9:*/		return 0x820FB8EC;
		  /* 820FB8ECh */ case   10:  		/* bc 12, CR0_EQ, 20 */
		/* 820FB8ECh case   10:*/		if ( regs.CR[0].eq ) { return 0x820FB900;  }
		/* 820FB8ECh case   10:*/		return 0x820FB8F0;
		  /* 820FB8F0h */ case   11:  		/* bl -39792 */
		/* 820FB8F0h case   11:*/		regs.LR = 0x820FB8F4; return 0x820F1D80;
		/* 820FB8F0h case   11:*/		return 0x820FB8F4;
		  /* 820FB8F4h */ case   12:  		/* lis R10, -32254 */
		/* 820FB8F4h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820FB8F4h case   12:*/		return 0x820FB8F8;
		  /* 820FB8F8h */ case   13:  		/* addi R5, R10, -14428 */
		/* 820FB8F8h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFC7A4);
		/* 820FB8F8h case   13:*/		return 0x820FB8FC;
		  /* 820FB8FCh */ case   14:  		/* b 16 */
		/* 820FB8FCh case   14:*/		return 0x820FB90C;
		/* 820FB8FCh case   14:*/		return 0x820FB900;
	}
	return 0x820FB900;
} // Block from 820FB8C4h-820FB900h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820FB900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB900);
		  /* 820FB900h */ case    0:  		/* bl -39808 */
		/* 820FB900h case    0:*/		regs.LR = 0x820FB904; return 0x820F1D80;
		/* 820FB900h case    0:*/		return 0x820FB904;
		  /* 820FB904h */ case    1:  		/* lis R10, -32254 */
		/* 820FB904h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820FB904h case    1:*/		return 0x820FB908;
		  /* 820FB908h */ case    2:  		/* addi R5, R10, -14436 */
		/* 820FB908h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFC79C);
		/* 820FB908h case    2:*/		return 0x820FB90C;
	}
	return 0x820FB90C;
} // Block from 820FB900h-820FB90Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FB90Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB90C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB90C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB90C);
		  /* 820FB90Ch */ case    0:  		/* lwz R6, <#[R3]> */
		/* 820FB90Ch case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000000) );
		/* 820FB90Ch case    0:*/		return 0x820FB910;
		  /* 820FB910h */ case    1:  		/* mr R11, R3 */
		/* 820FB910h case    1:*/		regs.R11 = regs.R3;
		/* 820FB910h case    1:*/		return 0x820FB914;
		  /* 820FB914h */ case    2:  		/* mr R7, R29 */
		/* 820FB914h case    2:*/		regs.R7 = regs.R29;
		/* 820FB914h case    2:*/		return 0x820FB918;
		  /* 820FB918h */ case    3:  		/* li R4, 32 */
		/* 820FB918h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x20);
		/* 820FB918h case    3:*/		return 0x820FB91C;
		  /* 820FB91Ch */ case    4:  		/* addi R3, R1, 112 */
		/* 820FB91Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 820FB91Ch case    4:*/		return 0x820FB920;
		  /* 820FB920h */ case    5:  		/* bl -365280 */
		/* 820FB920h case    5:*/		regs.LR = 0x820FB924; return 0x820A2640;
		/* 820FB920h case    5:*/		return 0x820FB924;
		  /* 820FB924h */ case    6:  		/* li R11, 0 */
		/* 820FB924h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820FB924h case    6:*/		return 0x820FB928;
		  /* 820FB928h */ case    7:  		/* addi R27, R31, 472 */
		/* 820FB928h case    7:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R31,0x1D8);
		/* 820FB928h case    7:*/		return 0x820FB92C;
		  /* 820FB92Ch */ case    8:  		/* lwz R5, <#[R26 + 12]> */
		/* 820FB92Ch case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R26 + 0x0000000C) );
		/* 820FB92Ch case    8:*/		return 0x820FB930;
		  /* 820FB930h */ case    9:  		/* stb R11, <#[R1 + 143]> */
		/* 820FB930h case    9:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x0000008F) );
		/* 820FB930h case    9:*/		return 0x820FB934;
		  /* 820FB934h */ case   10:  		/* li R6, 1 */
		/* 820FB934h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820FB934h case   10:*/		return 0x820FB938;
		  /* 820FB938h */ case   11:  		/* addi R4, R1, 112 */
		/* 820FB938h case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 820FB938h case   11:*/		return 0x820FB93C;
		  /* 820FB93Ch */ case   12:  		/* mr R3, R27 */
		/* 820FB93Ch case   12:*/		regs.R3 = regs.R27;
		/* 820FB93Ch case   12:*/		return 0x820FB940;
		  /* 820FB940h */ case   13:  		/* bl -336840 */
		/* 820FB940h case   13:*/		regs.LR = 0x820FB944; return 0x820A9578;
		/* 820FB940h case   13:*/		return 0x820FB944;
		  /* 820FB944h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 820FB944h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FB944h case   14:*/		return 0x820FB948;
		  /* 820FB948h */ case   15:  		/* bc 12, CR0_LT, 560 */
		/* 820FB948h case   15:*/		if ( regs.CR[0].lt ) { return 0x820FBB78;  }
		/* 820FB948h case   15:*/		return 0x820FB94C;
		  /* 820FB94Ch */ case   16:  		/* lwz R11, <#[R31 + 500]> */
		/* 820FB94Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000001F4) );
		/* 820FB94Ch case   16:*/		return 0x820FB950;
		  /* 820FB950h */ case   17:  		/* lwz R10, <#[R31 + 204]> */
		/* 820FB950h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000CC) );
		/* 820FB950h case   17:*/		return 0x820FB954;
		  /* 820FB954h */ case   18:  		/* addi R11, R11, 1 */
		/* 820FB954h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820FB954h case   18:*/		return 0x820FB958;
		  /* 820FB958h */ case   19:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 820FB958h case   19:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 820FB958h case   19:*/		return 0x820FB95C;
		  /* 820FB95Ch */ case   20:  		/* stw R11, <#[R31 + 500]> */
		/* 820FB95Ch case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000001F4) );
		/* 820FB95Ch case   20:*/		return 0x820FB960;
		  /* 820FB960h */ case   21:  		/* bc 12, CR0_EQ, 204 */
		/* 820FB960h case   21:*/		if ( regs.CR[0].eq ) { return 0x820FBA2C;  }
		/* 820FB960h case   21:*/		return 0x820FB964;
		  /* 820FB964h */ case   22:  		/* lwz R11, <#[R26 + 96]> */
		/* 820FB964h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000060) );
		/* 820FB964h case   22:*/		return 0x820FB968;
		  /* 820FB968h */ case   23:  		/* cmplwi CR6, R11, 0 */
		/* 820FB968h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FB968h case   23:*/		return 0x820FB96C;
		  /* 820FB96Ch */ case   24:  		/* bc 12, CR6_EQ, 192 */
		/* 820FB96Ch case   24:*/		if ( regs.CR[6].eq ) { return 0x820FBA2C;  }
		/* 820FB96Ch case   24:*/		return 0x820FB970;
		  /* 820FB970h */ case   25:  		/* lwz R10, <#[R11 + 4]> */
		/* 820FB970h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820FB970h case   25:*/		return 0x820FB974;
		  /* 820FB974h */ case   26:  		/* cmpwi CR6, R10, 6 */
		/* 820FB974h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000006);
		/* 820FB974h case   26:*/		return 0x820FB978;
		  /* 820FB978h */ case   27:  		/* bc 4, CR6_EQ, 180 */
		/* 820FB978h case   27:*/		if ( !regs.CR[6].eq ) { return 0x820FBA2C;  }
		/* 820FB978h case   27:*/		return 0x820FB97C;
		  /* 820FB97Ch */ case   28:  		/* lwz R28, <#[R11 + 20]> */
		/* 820FB97Ch case   28:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000014) );
		/* 820FB97Ch case   28:*/		return 0x820FB980;
		  /* 820FB980h */ case   29:  		/* lwz R11, <#[R28 + 4]> */
		/* 820FB980h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 820FB980h case   29:*/		return 0x820FB984;
		  /* 820FB984h */ case   30:  		/* cmpwi CR6, R11, 3 */
		/* 820FB984h case   30:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 820FB984h case   30:*/		return 0x820FB988;
		  /* 820FB988h */ case   31:  		/* bc 4, CR6_EQ, 164 */
		/* 820FB988h case   31:*/		if ( !regs.CR[6].eq ) { return 0x820FBA2C;  }
		/* 820FB988h case   31:*/		return 0x820FB98C;
		  /* 820FB98Ch */ case   32:  		/* lwz R11, <#[R28 + 24]> */
		/* 820FB98Ch case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000018) );
		/* 820FB98Ch case   32:*/		return 0x820FB990;
		  /* 820FB990h */ case   33:  		/* mr R10, R11 */
		/* 820FB990h case   33:*/		regs.R10 = regs.R11;
		/* 820FB990h case   33:*/		return 0x820FB994;
		  /* 820FB994h */ case   34:  		/* lbz R9, <#[R11]> */
		/* 820FB994h case   34:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820FB994h case   34:*/		return 0x820FB998;
		  /* 820FB998h */ case   35:  		/* addi R11, R11, 1 */
		/* 820FB998h case   35:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820FB998h case   35:*/		return 0x820FB99C;
		  /* 820FB99Ch */ case   36:  		/* cmplwi CR6, R9, 0 */
		/* 820FB99Ch case   36:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820FB99Ch case   36:*/		return 0x820FB9A0;
		  /* 820FB9A0h */ case   37:  		/* bc 4, CR6_EQ, -12 */
		/* 820FB9A0h case   37:*/		if ( !regs.CR[6].eq ) { return 0x820FB994;  }
		/* 820FB9A0h case   37:*/		return 0x820FB9A4;
		  /* 820FB9A4h */ case   38:  		/* subf R11, R10, R11 */
		/* 820FB9A4h case   38:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820FB9A4h case   38:*/		return 0x820FB9A8;
		  /* 820FB9A8h */ case   39:  		/* lis R4, 9345 */
		/* 820FB9A8h case   39:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820FB9A8h case   39:*/		return 0x820FB9AC;
		  /* 820FB9ACh */ case   40:  		/* addi R11, R11, -1 */
		/* 820FB9ACh case   40:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820FB9ACh case   40:*/		return 0x820FB9B0;
		  /* 820FB9B0h */ case   41:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820FB9B0h case   41:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820FB9B0h case   41:*/		return 0x820FB9B4;
		  /* 820FB9B4h */ case   42:  		/* addi R29, R11, 3 */
		/* 820FB9B4h case   42:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x3);
		/* 820FB9B4h case   42:*/		return 0x820FB9B8;
		  /* 820FB9B8h */ case   43:  		/* mr R3, R29 */
		/* 820FB9B8h case   43:*/		regs.R3 = regs.R29;
		/* 820FB9B8h case   43:*/		return 0x820FB9BC;
		  /* 820FB9BCh */ case   44:  		/* bl -473020 */
		/* 820FB9BCh case   44:*/		regs.LR = 0x820FB9C0; return 0x82088200;
		/* 820FB9BCh case   44:*/		return 0x820FB9C0;
		  /* 820FB9C0h */ case   45:  		/* or. R30, R3, R3 */
		/* 820FB9C0h case   45:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FB9C0h case   45:*/		return 0x820FB9C4;
		  /* 820FB9C4h */ case   46:  		/* bc 4, CR0_EQ, 16 */
		/* 820FB9C4h case   46:*/		if ( !regs.CR[0].eq ) { return 0x820FB9D4;  }
		/* 820FB9C4h case   46:*/		return 0x820FB9C8;
		  /* 820FB9C8h */ case   47:  		/* lis R3, -32761 */
		/* 820FB9C8h case   47:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820FB9C8h case   47:*/		return 0x820FB9CC;
		  /* 820FB9CCh */ case   48:  		/* ori R3, R3, 14 */
		/* 820FB9CCh case   48:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820FB9CCh case   48:*/		return 0x820FB9D0;
		  /* 820FB9D0h */ case   49:  		/* b 424 */
		/* 820FB9D0h case   49:*/		return 0x820FBB78;
		/* 820FB9D0h case   49:*/		return 0x820FB9D4;
	}
	return 0x820FB9D4;
} // Block from 820FB90Ch-820FB9D4h (50 instructions)

//////////////////////////////////////////////////////
// Block at 820FB9D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FB9D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FB9D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FB9D4);
		  /* 820FB9D4h */ case    0:  		/* lis R11, -32254 */
		/* 820FB9D4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820FB9D4h case    0:*/		return 0x820FB9D8;
		  /* 820FB9D8h */ case    1:  		/* lwz R6, <#[R28 + 24]> */
		/* 820FB9D8h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R28 + 0x00000018) );
		/* 820FB9D8h case    1:*/		return 0x820FB9DC;
		  /* 820FB9DCh */ case    2:  		/* mr R4, R29 */
		/* 820FB9DCh case    2:*/		regs.R4 = regs.R29;
		/* 820FB9DCh case    2:*/		return 0x820FB9E0;
		  /* 820FB9E0h */ case    3:  		/* addi R5, R11, -14444 */
		/* 820FB9E0h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFC794);
		/* 820FB9E0h case    3:*/		return 0x820FB9E4;
		  /* 820FB9E4h */ case    4:  		/* mr R3, R30 */
		/* 820FB9E4h case    4:*/		regs.R3 = regs.R30;
		/* 820FB9E4h case    4:*/		return 0x820FB9E8;
		  /* 820FB9E8h */ case    5:  		/* bl -365480 */
		/* 820FB9E8h case    5:*/		regs.LR = 0x820FB9EC; return 0x820A2640;
		/* 820FB9E8h case    5:*/		return 0x820FB9EC;
		  /* 820FB9ECh */ case    6:  		/* li R6, 1 */
		/* 820FB9ECh case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820FB9ECh case    6:*/		return 0x820FB9F0;
		  /* 820FB9F0h */ case    7:  		/* mr R4, R30 */
		/* 820FB9F0h case    7:*/		regs.R4 = regs.R30;
		/* 820FB9F0h case    7:*/		return 0x820FB9F4;
		  /* 820FB9F4h */ case    8:  		/* lwz R5, <#[R26 + 12]> */
		/* 820FB9F4h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R26 + 0x0000000C) );
		/* 820FB9F4h case    8:*/		return 0x820FB9F8;
		  /* 820FB9F8h */ case    9:  		/* mr R3, R27 */
		/* 820FB9F8h case    9:*/		regs.R3 = regs.R27;
		/* 820FB9F8h case    9:*/		return 0x820FB9FC;
		  /* 820FB9FCh */ case   10:  		/* bl -337028 */
		/* 820FB9FCh case   10:*/		regs.LR = 0x820FBA00; return 0x820A9578;
		/* 820FB9FCh case   10:*/		return 0x820FBA00;
		  /* 820FBA00h */ case   11:  		/* mr R29, R3 */
		/* 820FBA00h case   11:*/		regs.R29 = regs.R3;
		/* 820FBA00h case   11:*/		return 0x820FBA04;
		  /* 820FBA04h */ case   12:  		/* lis R4, 9345 */
		/* 820FBA04h case   12:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820FBA04h case   12:*/		return 0x820FBA08;
		  /* 820FBA08h */ case   13:  		/* mr R3, R30 */
		/* 820FBA08h case   13:*/		regs.R3 = regs.R30;
		/* 820FBA08h case   13:*/		return 0x820FBA0C;
		  /* 820FBA0Ch */ case   14:  		/* bl -472788 */
		/* 820FBA0Ch case   14:*/		regs.LR = 0x820FBA10; return 0x82088338;
		/* 820FBA0Ch case   14:*/		return 0x820FBA10;
		  /* 820FBA10h */ case   15:  		/* cmpwi CR6, R29, 0 */
		/* 820FBA10h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820FBA10h case   15:*/		return 0x820FBA14;
		  /* 820FBA14h */ case   16:  		/* bc 4, CR6_LT, 12 */
		/* 820FBA14h case   16:*/		if ( !regs.CR[6].lt ) { return 0x820FBA20;  }
		/* 820FBA14h case   16:*/		return 0x820FBA18;
		  /* 820FBA18h */ case   17:  		/* mr R3, R29 */
		/* 820FBA18h case   17:*/		regs.R3 = regs.R29;
		/* 820FBA18h case   17:*/		return 0x820FBA1C;
		  /* 820FBA1Ch */ case   18:  		/* b 348 */
		/* 820FBA1Ch case   18:*/		return 0x820FBB78;
		/* 820FBA1Ch case   18:*/		return 0x820FBA20;
	}
	return 0x820FBA20;
} // Block from 820FB9D4h-820FBA20h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820FBA20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBA20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBA20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBA20);
		  /* 820FBA20h */ case    0:  		/* lwz R11, <#[R31 + 500]> */
		/* 820FBA20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000001F4) );
		/* 820FBA20h case    0:*/		return 0x820FBA24;
		  /* 820FBA24h */ case    1:  		/* addi R11, R11, 1 */
		/* 820FBA24h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820FBA24h case    1:*/		return 0x820FBA28;
		  /* 820FBA28h */ case    2:  		/* stw R11, <#[R31 + 500]> */
		/* 820FBA28h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000001F4) );
		/* 820FBA28h case    2:*/		return 0x820FBA2C;
	}
	return 0x820FBA2C;
} // Block from 820FBA20h-820FBA2Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FBA2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBA2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBA2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBA2C);
		  /* 820FBA2Ch */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 820FBA2Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820FBA2Ch case    0:*/		return 0x820FBA30;
		  /* 820FBA30h */ case    1:  		/* bc 12, CR6_EQ, -372 */
		/* 820FBA30h case    1:*/		if ( regs.CR[6].eq ) { return 0x820FB8BC;  }
		/* 820FBA30h case    1:*/		return 0x820FBA34;
		  /* 820FBA34h */ case    2:  		/* lwz R11, <#[R26 + 108]> */
		/* 820FBA34h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000006C) );
		/* 820FBA34h case    2:*/		return 0x820FBA38;
		  /* 820FBA38h */ case    3:  		/* stw R11, <#[R25]> */
		/* 820FBA38h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820FBA38h case    3:*/		return 0x820FBA3C;
		  /* 820FBA3Ch */ case    4:  		/* b -384 */
		/* 820FBA3Ch case    4:*/		return 0x820FB8BC;
		/* 820FBA3Ch case    4:*/		return 0x820FBA40;
	}
	return 0x820FBA40;
} // Block from 820FBA2Ch-820FBA40h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FBA40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBA40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBA40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBA40);
		  /* 820FBA40h */ case    0:  		/* li R28, 0 */
		/* 820FBA40h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820FBA40h case    0:*/		return 0x820FBA44;
		  /* 820FBA44h */ case    1:  		/* cmplwi CR6, R30, 18 */
		/* 820FBA44h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000012);
		/* 820FBA44h case    1:*/		return 0x820FBA48;
		  /* 820FBA48h */ case    2:  		/* stw R28, <#[R1 + 80]> */
		/* 820FBA48h case    2:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 820FBA48h case    2:*/		return 0x820FBA4C;
		  /* 820FBA4Ch */ case    3:  		/* bc 12, CR6_GT, 292 */
		/* 820FBA4Ch case    3:*/		if ( regs.CR[6].gt ) { return 0x820FBB70;  }
		/* 820FBA4Ch case    3:*/		return 0x820FBA50;
		  /* 820FBA50h */ case    4:  		/* lis R12, -32254 */
		/* 820FBA50h case    4:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8202);
		/* 820FBA50h case    4:*/		return 0x820FBA54;
		  /* 820FBA54h */ case    5:  		/* addi R12, R12, -15280 */
		/* 820FBA54h case    5:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFC450);
		/* 820FBA54h case    5:*/		return 0x820FBA58;
		  /* 820FBA58h */ case    6:  		/* lbzx R0, <#[R12 + R30]> */
		/* 820FBA58h case    6:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R30 + 0x00000000) );
		/* 820FBA58h case    6:*/		return 0x820FBA5C;
		  /* 820FBA5Ch */ case    7:  		/* rlwinm R0, R0, 2, 0, 29 */
		/* 820FBA5Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R0,regs.R0);
		/* 820FBA5Ch case    7:*/		return 0x820FBA60;
		  /* 820FBA60h */ case    8:  		/* lis R12, -32240 */
		/* 820FBA60h case    8:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8210);
		/* 820FBA60h case    8:*/		return 0x820FBA64;
		  /* 820FBA64h */ case    9:  		/* ori R0, R0, 0 */
		/* 820FBA64h case    9:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820FBA64h case    9:*/		return 0x820FBA68;
		  /* 820FBA68h */ case   10:  		/* addi R12, R12, -17800 */
		/* 820FBA68h case   10:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFBA78);
		/* 820FBA68h case   10:*/		return 0x820FBA6C;
		  /* 820FBA6Ch */ case   11:  		/* add R12, R12, R0 */
		/* 820FBA6Ch case   11:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 820FBA6Ch case   11:*/		return 0x820FBA70;
		  /* 820FBA70h */ case   12:  		/* mtspr CTR, R12 */
		/* 820FBA70h case   12:*/		regs.CTR = regs.R12;
		/* 820FBA70h case   12:*/		return 0x820FBA74;
		  /* 820FBA74h */ case   13:  		/* bcctr 20, CR0_LT */
		/* 820FBA74h case   13:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820FBA74h case   13:*/		return 0x820FBA78;
		  /* 820FBA78h */ case   14:  		/* mr R11, R28 */
		/* 820FBA78h case   14:*/		regs.R11 = regs.R28;
		/* 820FBA78h case   14:*/		return 0x820FBA7C;
		  /* 820FBA7Ch */ case   15:  		/* cmplwi CR6, R29, 15 */
		/* 820FBA7Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x0000000F);
		/* 820FBA7Ch case   15:*/		return 0x820FBA80;
		  /* 820FBA80h */ case   16:  		/* bc 12, CR6_GT, 240 */
		/* 820FBA80h case   16:*/		if ( regs.CR[6].gt ) { return 0x820FBB70;  }
		/* 820FBA80h case   16:*/		return 0x820FBA84;
		  /* 820FBA84h */ case   17:  		/* lis R9, -32768 */
		/* 820FBA84h case   17:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8000);
		/* 820FBA84h case   17:*/		return 0x820FBA88;
		  /* 820FBA88h */ case   18:  		/* lwz R10, <#[R26]> */
		/* 820FBA88h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 820FBA88h case   18:*/		return 0x820FBA8C;
		  /* 820FBA8Ch */ case   19:  		/* mr R30, R28 */
		/* 820FBA8Ch case   19:*/		regs.R30 = regs.R28;
		/* 820FBA8Ch case   19:*/		return 0x820FBA90;
		  /* 820FBA90h */ case   20:  		/* rlwimi R9, R29, 16, 1, 15 */
		/* 820FBA90h case   20:*/		cpu::op::rlwimi<0,16,1,15>(regs,&regs.R9,regs.R29);
		/* 820FBA90h case   20:*/		return 0x820FBA94;
		  /* 820FBA94h */ case   21:  		/* rlwinm. R10, R10, 0, 7, 7 */
		/* 820FBA94h case   21:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R10,regs.R10);
		/* 820FBA94h case   21:*/		return 0x820FBA98;
		  /* 820FBA98h */ case   22:  		/* or R29, R9, R11 */
		/* 820FBA98h case   22:*/		cpu::op::or<0>(regs,&regs.R29,regs.R9,regs.R11);
		/* 820FBA98h case   22:*/		return 0x820FBA9C;
		  /* 820FBA9Ch */ case   23:  		/* bc 12, CR0_EQ, 8 */
		/* 820FBA9Ch case   23:*/		if ( regs.CR[0].eq ) { return 0x820FBAA4;  }
		/* 820FBA9Ch case   23:*/		return 0x820FBAA0;
		  /* 820FBAA0h */ case   24:  		/* lis R30, 64 */
		/* 820FBAA0h case   24:*/		cpu::op::lis<0>(regs,&regs.R30,0x40);
		/* 820FBAA0h case   24:*/		return 0x820FBAA4;
	}
	return 0x820FBAA4;
} // Block from 820FBA40h-820FBAA4h (25 instructions)

//////////////////////////////////////////////////////
// Block at 820FBAA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBAA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBAA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBAA4);
		  /* 820FBAA4h */ case    0:  		/* li R4, 31 */
		/* 820FBAA4h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1F);
		/* 820FBAA4h case    0:*/		return 0x820FBAA8;
		  /* 820FBAA8h */ case    1:  		/* mr R3, R31 */
		/* 820FBAA8h case    1:*/		regs.R3 = regs.R31;
		/* 820FBAA8h case    1:*/		return 0x820FBAAC;
		  /* 820FBAACh */ case    2:  		/* bl -22972 */
		/* 820FBAACh case    2:*/		regs.LR = 0x820FBAB0; return 0x820F60F0;
		/* 820FBAACh case    2:*/		return 0x820FBAB0;
		  /* 820FBAB0h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820FBAB0h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FBAB0h case    3:*/		return 0x820FBAB4;
		  /* 820FBAB4h */ case    4:  		/* bc 12, CR0_LT, 196 */
		/* 820FBAB4h case    4:*/		if ( regs.CR[0].lt ) { return 0x820FBB78;  }
		/* 820FBAB4h case    4:*/		return 0x820FBAB8;
		  /* 820FBAB8h */ case    5:  		/* mr R4, R29 */
		/* 820FBAB8h case    5:*/		regs.R4 = regs.R29;
		/* 820FBAB8h case    5:*/		return 0x820FBABC;
		  /* 820FBABCh */ case    6:  		/* mr R3, R31 */
		/* 820FBABCh case    6:*/		regs.R3 = regs.R31;
		/* 820FBABCh case    6:*/		return 0x820FBAC0;
		  /* 820FBAC0h */ case    7:  		/* bl -34640 */
		/* 820FBAC0h case    7:*/		regs.LR = 0x820FBAC4; return 0x820F3370;
		/* 820FBAC0h case    7:*/		return 0x820FBAC4;
		  /* 820FBAC4h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 820FBAC4h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FBAC4h case    8:*/		return 0x820FBAC8;
		  /* 820FBAC8h */ case    9:  		/* bc 12, CR0_LT, 176 */
		/* 820FBAC8h case    9:*/		if ( regs.CR[0].lt ) { return 0x820FBB78;  }
		/* 820FBAC8h case    9:*/		return 0x820FBACC;
		  /* 820FBACCh */ case   10:  		/* lwz R11, <#[R26 + 4]> */
		/* 820FBACCh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 820FBACCh case   10:*/		return 0x820FBAD0;
		  /* 820FBAD0h */ case   11:  		/* addi R6, R1, 88 */
		/* 820FBAD0h case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x58);
		/* 820FBAD0h case   11:*/		return 0x820FBAD4;
		  /* 820FBAD4h */ case   12:  		/* lwz R10, <#[R31 + 16]> */
		/* 820FBAD4h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820FBAD4h case   12:*/		return 0x820FBAD8;
		  /* 820FBAD8h */ case   13:  		/* addi R5, R1, 92 */
		/* 820FBAD8h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x5C);
		/* 820FBAD8h case   13:*/		return 0x820FBADC;
		  /* 820FBADCh */ case   14:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FBADCh case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FBADCh case   14:*/		return 0x820FBAE0;
		  /* 820FBAE0h */ case   15:  		/* mr R4, R26 */
		/* 820FBAE0h case   15:*/		regs.R4 = regs.R26;
		/* 820FBAE0h case   15:*/		return 0x820FBAE4;
		  /* 820FBAE4h */ case   16:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820FBAE4h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FBAE4h case   16:*/		return 0x820FBAE8;
		  /* 820FBAE8h */ case   17:  		/* lwz R11, <#[R11 + 4]> */
		/* 820FBAE8h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820FBAE8h case   17:*/		return 0x820FBAEC;
		  /* 820FBAECh */ case   18:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 820FBAECh case   18:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 820FBAECh case   18:*/		return 0x820FBAF0;
		  /* 820FBAF0h */ case   19:  		/* bc 12, CR0_EQ, 208 */
		/* 820FBAF0h case   19:*/		if ( regs.CR[0].eq ) { return 0x820FBBC0;  }
		/* 820FBAF0h case   19:*/		return 0x820FBAF4;
		  /* 820FBAF4h */ case   20:  		/* lwz R11, <#[R31 + 112]> */
		/* 820FBAF4h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820FBAF4h case   20:*/		return 0x820FBAF8;
		  /* 820FBAF8h */ case   21:  		/* mr R3, R31 */
		/* 820FBAF8h case   21:*/		regs.R3 = regs.R31;
		/* 820FBAF8h case   21:*/		return 0x820FBAFC;
		  /* 820FBAFCh */ case   22:  		/* lwz R10, <#[R1 + 80]> */
		/* 820FBAFCh case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820FBAFCh case   22:*/		return 0x820FBB00;
		  /* 820FBB00h */ case   23:  		/* rlwinm R11, R11, 7, 0, 24 */
		/* 820FBB00h case   23:*/		cpu::op::rlwinm<0,7,0,24>(regs,&regs.R11,regs.R11);
		/* 820FBB00h case   23:*/		return 0x820FBB04;
		  /* 820FBB04h */ case   24:  		/* lwz R9, <#[R31]> */
		/* 820FBB04h case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 820FBB04h case   24:*/		return 0x820FBB08;
		  /* 820FBB08h */ case   25:  		/* srawi R11, R11, 31 */
		/* 820FBB08h case   25:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R11);
		/* 820FBB08h case   25:*/		return 0x820FBB0C;
		  /* 820FBB0Ch */ case   26:  		/* or R11, R11, R10 */
		/* 820FBB0Ch case   26:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820FBB0Ch case   26:*/		return 0x820FBB10;
		  /* 820FBB10h */ case   27:  		/* lwz R10, <#[R9 + 348]> */
		/* 820FBB10h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x0000015C) );
		/* 820FBB10h case   27:*/		return 0x820FBB14;
		  /* 820FBB14h */ case   28:  		/* stw R11, <#[R1 + 80]> */
		/* 820FBB14h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820FBB14h case   28:*/		return 0x820FBB18;
		  /* 820FBB18h */ case   29:  		/* mtspr CTR, R10 */
		/* 820FBB18h case   29:*/		regs.CTR = regs.R10;
		/* 820FBB18h case   29:*/		return 0x820FBB1C;
		  /* 820FBB1Ch */ case   30:  		/* bcctrl 20, CR0_LT */
		/* 820FBB1Ch case   30:*/		if ( 1 ) { regs.LR = 0x820FBB20; return (uint32)regs.CTR; }
		/* 820FBB1Ch case   30:*/		return 0x820FBB20;
		  /* 820FBB20h */ case   31:  		/* cmpwi CR0, R3, 0 */
		/* 820FBB20h case   31:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FBB20h case   31:*/		return 0x820FBB24;
		  /* 820FBB24h */ case   32:  		/* bc 4, CR0_LT, 192 */
		/* 820FBB24h case   32:*/		if ( !regs.CR[0].lt ) { return 0x820FBBE4;  }
		/* 820FBB24h case   32:*/		return 0x820FBB28;
		  /* 820FBB28h */ case   33:  		/* b 80 */
		/* 820FBB28h case   33:*/		return 0x820FBB78;
		/* 820FBB28h case   33:*/		return 0x820FBB2C;
		  /* 820FBB2Ch */ case   34:  		/* li R11, 1 */
		/* 820FBB2Ch case   34:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820FBB2Ch case   34:*/		return 0x820FBB30;
		  /* 820FBB30h */ case   35:  		/* b -180 */
		/* 820FBB30h case   35:*/		return 0x820FBA7C;
		/* 820FBB30h case   35:*/		return 0x820FBB34;
		  /* 820FBB34h */ case   36:  		/* li R11, 2 */
		/* 820FBB34h case   36:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820FBB34h case   36:*/		return 0x820FBB38;
		  /* 820FBB38h */ case   37:  		/* b -188 */
		/* 820FBB38h case   37:*/		return 0x820FBA7C;
		/* 820FBB38h case   37:*/		return 0x820FBB3C;
		  /* 820FBB3Ch */ case   38:  		/* li R11, 3 */
		/* 820FBB3Ch case   38:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820FBB3Ch case   38:*/		return 0x820FBB40;
		  /* 820FBB40h */ case   39:  		/* b -196 */
		/* 820FBB40h case   39:*/		return 0x820FBA7C;
		/* 820FBB40h case   39:*/		return 0x820FBB44;
		  /* 820FBB44h */ case   40:  		/* li R11, 4 */
		/* 820FBB44h case   40:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 820FBB44h case   40:*/		return 0x820FBB48;
		  /* 820FBB48h */ case   41:  		/* b -204 */
		/* 820FBB48h case   41:*/		return 0x820FBA7C;
		/* 820FBB48h case   41:*/		return 0x820FBB4C;
		  /* 820FBB4Ch */ case   42:  		/* li R11, 5 */
		/* 820FBB4Ch case   42:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820FBB4Ch case   42:*/		return 0x820FBB50;
		  /* 820FBB50h */ case   43:  		/* b -212 */
		/* 820FBB50h case   43:*/		return 0x820FBA7C;
		/* 820FBB50h case   43:*/		return 0x820FBB54;
		  /* 820FBB54h */ case   44:  		/* li R11, 6 */
		/* 820FBB54h case   44:*/		cpu::op::li<0>(regs,&regs.R11,0x6);
		/* 820FBB54h case   44:*/		return 0x820FBB58;
		  /* 820FBB58h */ case   45:  		/* b -220 */
		/* 820FBB58h case   45:*/		return 0x820FBA7C;
		/* 820FBB58h case   45:*/		return 0x820FBB5C;
		  /* 820FBB5Ch */ case   46:  		/* li R11, 7 */
		/* 820FBB5Ch case   46:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 820FBB5Ch case   46:*/		return 0x820FBB60;
		  /* 820FBB60h */ case   47:  		/* b -228 */
		/* 820FBB60h case   47:*/		return 0x820FBA7C;
		/* 820FBB60h case   47:*/		return 0x820FBB64;
		  /* 820FBB64h */ case   48:  		/* li R11, 8 */
		/* 820FBB64h case   48:*/		cpu::op::li<0>(regs,&regs.R11,0x8);
		/* 820FBB64h case   48:*/		return 0x820FBB68;
		  /* 820FBB68h */ case   49:  		/* cmplwi CR6, R29, 0 */
		/* 820FBB68h case   49:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820FBB68h case   49:*/		return 0x820FBB6C;
		  /* 820FBB6Ch */ case   50:  		/* bc 12, CR6_EQ, -232 */
		/* 820FBB6Ch case   50:*/		if ( regs.CR[6].eq ) { return 0x820FBA84;  }
		/* 820FBB6Ch case   50:*/		return 0x820FBB70;
	}
	return 0x820FBB70;
} // Block from 820FBAA4h-820FBB70h (51 instructions)

//////////////////////////////////////////////////////
// Block at 820FBB70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBB70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBB70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBB70);
		  /* 820FBB70h */ case    0:  		/* lis R3, -32768 */
		/* 820FBB70h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820FBB70h case    0:*/		return 0x820FBB74;
		  /* 820FBB74h */ case    1:  		/* ori R3, R3, 16389 */
		/* 820FBB74h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820FBB74h case    1:*/		return 0x820FBB78;
	}
	return 0x820FBB78;
} // Block from 820FBB70h-820FBB78h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FBB78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBB78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBB78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBB78);
		  /* 820FBB78h */ case    0:  		/* addi R1, R1, 208 */
		/* 820FBB78h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 820FBB78h case    0:*/		return 0x820FBB7C;
		  /* 820FBB7Ch */ case    1:  		/* b -436448 */
		/* 820FBB7Ch case    1:*/		return 0x8209129C;
		/* 820FBB7Ch case    1:*/		return 0x820FBB80;
		  /* 820FBB80h */ case    2:  		/* li R11, 9 */
		/* 820FBB80h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 820FBB80h case    2:*/		return 0x820FBB84;
		  /* 820FBB84h */ case    3:  		/* b -264 */
		/* 820FBB84h case    3:*/		return 0x820FBA7C;
		/* 820FBB84h case    3:*/		return 0x820FBB88;
		  /* 820FBB88h */ case    4:  		/* li R11, 10 */
		/* 820FBB88h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0xA);
		/* 820FBB88h case    4:*/		return 0x820FBB8C;
		  /* 820FBB8Ch */ case    5:  		/* b -272 */
		/* 820FBB8Ch case    5:*/		return 0x820FBA7C;
		/* 820FBB8Ch case    5:*/		return 0x820FBB90;
		  /* 820FBB90h */ case    6:  		/* li R11, 11 */
		/* 820FBB90h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0xB);
		/* 820FBB90h case    6:*/		return 0x820FBB94;
		  /* 820FBB94h */ case    7:  		/* b -280 */
		/* 820FBB94h case    7:*/		return 0x820FBA7C;
		/* 820FBB94h case    7:*/		return 0x820FBB98;
		  /* 820FBB98h */ case    8:  		/* li R11, 12 */
		/* 820FBB98h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0xC);
		/* 820FBB98h case    8:*/		return 0x820FBB9C;
		  /* 820FBB9Ch */ case    9:  		/* b -288 */
		/* 820FBB9Ch case    9:*/		return 0x820FBA7C;
		/* 820FBB9Ch case    9:*/		return 0x820FBBA0;
		  /* 820FBBA0h */ case   10:  		/* li R11, 13 */
		/* 820FBBA0h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0xD);
		/* 820FBBA0h case   10:*/		return 0x820FBBA4;
		  /* 820FBBA4h */ case   11:  		/* b -296 */
		/* 820FBBA4h case   11:*/		return 0x820FBA7C;
		/* 820FBBA4h case   11:*/		return 0x820FBBA8;
		  /* 820FBBA8h */ case   12:  		/* lis R11, -32768 */
		/* 820FBBA8h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8000);
		/* 820FBBA8h case   12:*/		return 0x820FBBAC;
		  /* 820FBBACh */ case   13:  		/* b -304 */
		/* 820FBBACh case   13:*/		return 0x820FBA7C;
		/* 820FBBACh case   13:*/		return 0x820FBBB0;
		  /* 820FBBB0h */ case   14:  		/* li R10, 1 */
		/* 820FBBB0h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820FBBB0h case   14:*/		return 0x820FBBB4;
		  /* 820FBBB4h */ case   15:  		/* lis R11, -32768 */
		/* 820FBBB4h case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8000);
		/* 820FBBB4h case   15:*/		return 0x820FBBB8;
		  /* 820FBBB8h */ case   16:  		/* stw R10, <#[R1 + 80]> */
		/* 820FBBB8h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820FBBB8h case   16:*/		return 0x820FBBBC;
		  /* 820FBBBCh */ case   17:  		/* b -320 */
		/* 820FBBBCh case   17:*/		return 0x820FBA7C;
		/* 820FBBBCh case   17:*/		return 0x820FBBC0;
	}
	return 0x820FBBC0;
} // Block from 820FBB78h-820FBBC0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820FBBC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBBC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBBC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBBC0);
		  /* 820FBBC0h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FBBC0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FBBC0h case    0:*/		return 0x820FBBC4;
		  /* 820FBBC4h */ case    1:  		/* addi R7, R1, 80 */
		/* 820FBBC4h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 820FBBC4h case    1:*/		return 0x820FBBC8;
		  /* 820FBBC8h */ case    2:  		/* mr R3, R31 */
		/* 820FBBC8h case    2:*/		regs.R3 = regs.R31;
		/* 820FBBC8h case    2:*/		return 0x820FBBCC;
		  /* 820FBBCCh */ case    3:  		/* lwz R11, <#[R11 + 344]> */
		/* 820FBBCCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000158) );
		/* 820FBBCCh case    3:*/		return 0x820FBBD0;
		  /* 820FBBD0h */ case    4:  		/* mtspr CTR, R11 */
		/* 820FBBD0h case    4:*/		regs.CTR = regs.R11;
		/* 820FBBD0h case    4:*/		return 0x820FBBD4;
		  /* 820FBBD4h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 820FBBD4h case    5:*/		if ( 1 ) { regs.LR = 0x820FBBD8; return (uint32)regs.CTR; }
		/* 820FBBD4h case    5:*/		return 0x820FBBD8;
		  /* 820FBBD8h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820FBBD8h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FBBD8h case    6:*/		return 0x820FBBDC;
		  /* 820FBBDCh */ case    7:  		/* bc 12, CR0_LT, -100 */
		/* 820FBBDCh case    7:*/		if ( regs.CR[0].lt ) { return 0x820FBB78;  }
		/* 820FBBDCh case    7:*/		return 0x820FBBE0;
		  /* 820FBBE0h */ case    8:  		/* stw R28, <#[R1 + 80]> */
		/* 820FBBE0h case    8:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 820FBBE0h case    8:*/		return 0x820FBBE4;
	}
	return 0x820FBBE4;
} // Block from 820FBBC0h-820FBBE4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820FBBE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBBE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBBE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBBE4);
		  /* 820FBBE4h */ case    0:  		/* addi R10, R1, 96 */
		/* 820FBBE4h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 820FBBE4h case    0:*/		return 0x820FBBE8;
		  /* 820FBBE8h */ case    1:  		/* lwz R9, <#[R31 + 8]> */
		/* 820FBBE8h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 820FBBE8h case    1:*/		return 0x820FBBEC;
		  /* 820FBBECh */ case    2:  		/* li R11, -1 */
		/* 820FBBECh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820FBBECh case    2:*/		return 0x820FBBF0;
	}
	return 0x820FBBF0;
} // Block from 820FBBE4h-820FBBF0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FBBF0h
// Function '?EmitInstructions@C30Program@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBBF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBBF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBBF0);
		  /* 820FBBF0h */ case    0:  		/* mr R5, R28 */
		/* 820FBBF0h case    0:*/		regs.R5 = regs.R28;
		/* 820FBBF0h case    0:*/		return 0x820FBBF4;
		  /* 820FBBF4h */ case    1:  		/* mr R7, R28 */
		/* 820FBBF4h case    1:*/		regs.R7 = regs.R28;
		/* 820FBBF4h case    1:*/		return 0x820FBBF8;
		  /* 820FBBF8h */ case    2:  		/* cmplwi CR6, R9, 0 */
		/* 820FBBF8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820FBBF8h case    2:*/		return 0x820FBBFC;
		  /* 820FBBFCh */ case    3:  		/* stw R11, <#[R10]> */
		/* 820FBBFCh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820FBBFCh case    3:*/		return 0x820FBC00;
		  /* 820FBC00h */ case    4:  		/* stw R11, <#[R10 + 4]> */
		/* 820FBC00h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 820FBC00h case    4:*/		return 0x820FBC04;
		  /* 820FBC04h */ case    5:  		/* stw R11, <#[R10 + 8]> */
		/* 820FBC04h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 820FBC04h case    5:*/		return 0x820FBC08;
		  /* 820FBC08h */ case    6:  		/* stw R11, <#[R10 + 12]> */
		/* 820FBC08h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 820FBC08h case    6:*/		return 0x820FBC0C;
		  /* 820FBC0Ch */ case    7:  		/* bc 4, CR6_GT, 100 */
		/* 820FBC0Ch case    7:*/		if ( !regs.CR[6].gt ) { return 0x820FBC70;  }
		/* 820FBC0Ch case    7:*/		return 0x820FBC10;
		  /* 820FBC10h */ case    8:  		/* lwz R9, <#[R31 + 20]> */
		/* 820FBC10h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820FBC10h case    8:*/		return 0x820FBC14;
		  /* 820FBC14h */ case    9:  		/* mr R10, R28 */
		/* 820FBC14h case    9:*/		regs.R10 = regs.R28;
		/* 820FBC14h case    9:*/		return 0x820FBC18;
		  /* 820FBC18h */ case   10:  		/* lwz R8, <#[R26 + 4]> */
		/* 820FBC18h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000004) );
		/* 820FBC18h case   10:*/		return 0x820FBC1C;
		  /* 820FBC1Ch */ case   11:  		/* lwz R6, <#[R31 + 8]> */
		/* 820FBC1Ch case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000008) );
		/* 820FBC1Ch case   11:*/		return 0x820FBC20;
		  /* 820FBC20h */ case   12:  		/* lwzx R11, <#[R10 + R9]> */
		/* 820FBC20h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820FBC20h case   12:*/		return 0x820FBC24;
		  /* 820FBC24h */ case   13:  		/* lwz R4, <#[R11 + 4]> */
		/* 820FBC24h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 820FBC24h case   13:*/		return 0x820FBC28;
		  /* 820FBC28h */ case   14:  		/* cmplw CR6, R8, R4 */
		/* 820FBC28h case   14:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R4);
		/* 820FBC28h case   14:*/		return 0x820FBC2C;
		  /* 820FBC2Ch */ case   15:  		/* bc 4, CR6_EQ, 52 */
		/* 820FBC2Ch case   15:*/		if ( !regs.CR[6].eq ) { return 0x820FBC60;  }
		/* 820FBC2Ch case   15:*/		return 0x820FBC30;
		  /* 820FBC30h */ case   16:  		/* lwz R4, <#[R26 + 8]> */
		/* 820FBC30h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000008) );
		/* 820FBC30h case   16:*/		return 0x820FBC34;
		  /* 820FBC34h */ case   17:  		/* lwz R3, <#[R11 + 8]> */
		/* 820FBC34h case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000008) );
		/* 820FBC34h case   17:*/		return 0x820FBC38;
		  /* 820FBC38h */ case   18:  		/* cmplw CR6, R4, R3 */
		/* 820FBC38h case   18:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R3);
		/* 820FBC38h case   18:*/		return 0x820FBC3C;
		  /* 820FBC3Ch */ case   19:  		/* bc 4, CR6_EQ, 36 */
		/* 820FBC3Ch case   19:*/		if ( !regs.CR[6].eq ) { return 0x820FBC60;  }
		/* 820FBC3Ch case   19:*/		return 0x820FBC40;
		  /* 820FBC40h */ case   20:  		/* lwz R4, <#[R26 + 12]> */
		/* 820FBC40h case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x0000000C) );
		/* 820FBC40h case   20:*/		return 0x820FBC44;
		  /* 820FBC44h */ case   21:  		/* lwz R3, <#[R11 + 12]> */
		/* 820FBC44h case   21:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x0000000C) );
		/* 820FBC44h case   21:*/		return 0x820FBC48;
		  /* 820FBC48h */ case   22:  		/* cmplw CR6, R4, R3 */
		/* 820FBC48h case   22:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R3);
		/* 820FBC48h case   22:*/		return 0x820FBC4C;
		  /* 820FBC4Ch */ case   23:  		/* bc 4, CR6_EQ, 20 */
		/* 820FBC4Ch case   23:*/		if ( !regs.CR[6].eq ) { return 0x820FBC60;  }
		/* 820FBC4Ch case   23:*/		return 0x820FBC50;
		  /* 820FBC50h */ case   24:  		/* lwz R11, <#[R11 + 16]> */
		/* 820FBC50h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820FBC50h case   24:*/		return 0x820FBC54;
		  /* 820FBC54h */ case   25:  		/* addi R4, R1, 96 */
		/* 820FBC54h case   25:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 820FBC54h case   25:*/		return 0x820FBC58;
		  /* 820FBC58h */ case   26:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FBC58h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FBC58h case   26:*/		return 0x820FBC5C;
		  /* 820FBC5Ch */ case   27:  		/* stwx R7, <#[R11 + R4]> */
		/* 820FBC5Ch case   27:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + regs.R4 + 0x00000000) );
		/* 820FBC5Ch case   27:*/		return 0x820FBC60;
	}
	return 0x820FBC60;
} // Block from 820FBBF0h-820FBC60h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820FBC60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBC60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBC60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBC60);
		  /* 820FBC60h */ case    0:  		/* addi R7, R7, 1 */
		/* 820FBC60h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820FBC60h case    0:*/		return 0x820FBC64;
		  /* 820FBC64h */ case    1:  		/* addi R10, R10, 4 */
		/* 820FBC64h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820FBC64h case    1:*/		return 0x820FBC68;
		  /* 820FBC68h */ case    2:  		/* cmplw CR6, R7, R6 */
		/* 820FBC68h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 820FBC68h case    2:*/		return 0x820FBC6C;
		  /* 820FBC6Ch */ case    3:  		/* bc 12, CR6_LT, -76 */
		/* 820FBC6Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x820FBC20;  }
		/* 820FBC6Ch case    3:*/		return 0x820FBC70;
	}
	return 0x820FBC70;
} // Block from 820FBC60h-820FBC70h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FBC70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBC70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBC70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBC70);
		  /* 820FBC70h */ case    0:  		/* li R11, 4 */
		/* 820FBC70h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 820FBC70h case    0:*/		return 0x820FBC74;
		  /* 820FBC74h */ case    1:  		/* addi R10, R1, 92 */
		/* 820FBC74h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x5C);
		/* 820FBC74h case    1:*/		return 0x820FBC78;
		  /* 820FBC78h */ case    2:  		/* addi R9, R1, 96 */
		/* 820FBC78h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 820FBC78h case    2:*/		return 0x820FBC7C;
		  /* 820FBC7Ch */ case    3:  		/* mtspr CTR, R11 */
		/* 820FBC7Ch case    3:*/		regs.CTR = regs.R11;
		/* 820FBC7Ch case    3:*/		return 0x820FBC80;
		  /* 820FBC80h */ case    4:  		/* lwz R11, <#[R9]> */
		/* 820FBC80h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820FBC80h case    4:*/		return 0x820FBC84;
		  /* 820FBC84h */ case    5:  		/* cmpwi CR6, R11, -1 */
		/* 820FBC84h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FBC84h case    5:*/		return 0x820FBC88;
		  /* 820FBC88h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 820FBC88h case    6:*/		if ( regs.CR[6].eq ) { return 0x820FBC94;  }
		/* 820FBC88h case    6:*/		return 0x820FBC8C;
		  /* 820FBC8Ch */ case    7:  		/* stwu R11, <#[R10 + 4]> */
		/* 820FBC8Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820FBC8Ch case    7:*/		return 0x820FBC90;
		  /* 820FBC90h */ case    8:  		/* addi R5, R5, 1 */
		/* 820FBC90h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820FBC90h case    8:*/		return 0x820FBC94;
	}
	return 0x820FBC94;
} // Block from 820FBC70h-820FBC94h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820FBC94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBC94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBC94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBC94);
		  /* 820FBC94h */ case    0:  		/* addi R9, R9, 4 */
		/* 820FBC94h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820FBC94h case    0:*/		return 0x820FBC98;
		  /* 820FBC98h */ case    1:  		/* bc 16, CR0_LT, -24 */
		/* 820FBC98h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820FBC80;  }
		/* 820FBC98h case    1:*/		return 0x820FBC9C;
		  /* 820FBC9Ch */ case    2:  		/* lwz R11, <#[R31]> */
		/* 820FBC9Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FBC9Ch case    2:*/		return 0x820FBCA0;
		  /* 820FBCA0h */ case    3:  		/* addi R6, R1, 84 */
		/* 820FBCA0h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 820FBCA0h case    3:*/		return 0x820FBCA4;
		  /* 820FBCA4h */ case    4:  		/* addi R4, R1, 96 */
		/* 820FBCA4h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 820FBCA4h case    4:*/		return 0x820FBCA8;
		  /* 820FBCA8h */ case    5:  		/* lwz R7, <#[R1 + 80]> */
		/* 820FBCA8h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 820FBCA8h case    5:*/		return 0x820FBCAC;
		  /* 820FBCACh */ case    6:  		/* mr R3, R31 */
		/* 820FBCACh case    6:*/		regs.R3 = regs.R31;
		/* 820FBCACh case    6:*/		return 0x820FBCB0;
		  /* 820FBCB0h */ case    7:  		/* lwz R11, <#[R11 + 324]> */
		/* 820FBCB0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000144) );
		/* 820FBCB0h case    7:*/		return 0x820FBCB4;
		  /* 820FBCB4h */ case    8:  		/* mtspr CTR, R11 */
		/* 820FBCB4h case    8:*/		regs.CTR = regs.R11;
		/* 820FBCB4h case    8:*/		return 0x820FBCB8;
		  /* 820FBCB8h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820FBCB8h case    9:*/		if ( 1 ) { regs.LR = 0x820FBCBC; return (uint32)regs.CTR; }
		/* 820FBCB8h case    9:*/		return 0x820FBCBC;
		  /* 820FBCBCh */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 820FBCBCh case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FBCBCh case   10:*/		return 0x820FBCC0;
		  /* 820FBCC0h */ case   11:  		/* bc 12, CR0_LT, -328 */
		/* 820FBCC0h case   11:*/		if ( regs.CR[0].lt ) { return 0x820FBB78;  }
		/* 820FBCC0h case   11:*/		return 0x820FBCC4;
		  /* 820FBCC4h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 820FBCC4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FBCC4h case   12:*/		return 0x820FBCC8;
		  /* 820FBCC8h */ case   13:  		/* li R5, 0 */
		/* 820FBCC8h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820FBCC8h case   13:*/		return 0x820FBCCC;
		  /* 820FBCCCh */ case   14:  		/* li R4, 4 */
		/* 820FBCCCh case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 820FBCCCh case   14:*/		return 0x820FBCD0;
		  /* 820FBCD0h */ case   15:  		/* mr R3, R31 */
		/* 820FBCD0h case   15:*/		regs.R3 = regs.R31;
		/* 820FBCD0h case   15:*/		return 0x820FBCD4;
		  /* 820FBCD4h */ case   16:  		/* lwz R11, <#[R11 + 108]> */
		/* 820FBCD4h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000006C) );
		/* 820FBCD4h case   16:*/		return 0x820FBCD8;
		  /* 820FBCD8h */ case   17:  		/* mtspr CTR, R11 */
		/* 820FBCD8h case   17:*/		regs.CTR = regs.R11;
		/* 820FBCD8h case   17:*/		return 0x820FBCDC;
		  /* 820FBCDCh */ case   18:  		/* bcctrl 20, CR0_LT */
		/* 820FBCDCh case   18:*/		if ( 1 ) { regs.LR = 0x820FBCE0; return (uint32)regs.CTR; }
		/* 820FBCDCh case   18:*/		return 0x820FBCE0;
		  /* 820FBCE0h */ case   19:  		/* rlwinm R11, R29, 0, 1, 31 */
		/* 820FBCE0h case   19:*/		cpu::op::rlwinm<0,0,1,31>(regs,&regs.R11,regs.R29);
		/* 820FBCE0h case   19:*/		return 0x820FBCE4;
		  /* 820FBCE4h */ case   20:  		/* cmplw CR6, R11, R3 */
		/* 820FBCE4h case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R3);
		/* 820FBCE4h case   20:*/		return 0x820FBCE8;
		  /* 820FBCE8h */ case   21:  		/* lwz R11, <#[R1 + 84]> */
		/* 820FBCE8h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820FBCE8h case   21:*/		return 0x820FBCEC;
		  /* 820FBCECh */ case   22:  		/* bc 4, CR6_EQ, 8 */
		/* 820FBCECh case   22:*/		if ( !regs.CR[6].eq ) { return 0x820FBCF4;  }
		/* 820FBCECh case   22:*/		return 0x820FBCF0;
		  /* 820FBCF0h */ case   23:  		/* oris R11, R11, 15 */
		/* 820FBCF0h case   23:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0xF);
		/* 820FBCF0h case   23:*/		return 0x820FBCF4;
	}
	return 0x820FBCF4;
} // Block from 820FBC94h-820FBCF4h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820FBCF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBCF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBCF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBCF4);
		  /* 820FBCF4h */ case    0:  		/* lwz R10, <#[R31 + 112]> */
		/* 820FBCF4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000070) );
		/* 820FBCF4h case    0:*/		return 0x820FBCF8;
		  /* 820FBCF8h */ case    1:  		/* rlwinm R5, R11, 0, 12, 10 */
		/* 820FBCF8h case    1:*/		cpu::op::rlwinm<0,0,12,10>(regs,&regs.R5,regs.R11);
		/* 820FBCF8h case    1:*/		return 0x820FBCFC;
		  /* 820FBCFCh */ case    2:  		/* rlwinm. R11, R10, 0, 7, 7 */
		/* 820FBCFCh case    2:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R11,regs.R10);
		/* 820FBCFCh case    2:*/		return 0x820FBD00;
		  /* 820FBD00h */ case    3:  		/* stw R5, <#[R1 + 84]> */
		/* 820FBD00h case    3:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 820FBD00h case    3:*/		return 0x820FBD04;
		  /* 820FBD04h */ case    4:  		/* bc 4, CR0_EQ, 36 */
		/* 820FBD04h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820FBD28;  }
		/* 820FBD04h case    4:*/		return 0x820FBD08;
		  /* 820FBD08h */ case    5:  		/* lwz R11, <#[R31 + 204]> */
		/* 820FBD08h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000CC) );
		/* 820FBD08h case    5:*/		return 0x820FBD0C;
		  /* 820FBD0Ch */ case    6:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 820FBD0Ch case    6:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 820FBD0Ch case    6:*/		return 0x820FBD10;
		  /* 820FBD10h */ case    7:  		/* bc 4, CR0_EQ, 16 */
		/* 820FBD10h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820FBD20;  }
		/* 820FBD10h case    7:*/		return 0x820FBD14;
		  /* 820FBD14h */ case    8:  		/* lwz R11, <#[R26]> */
		/* 820FBD14h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820FBD14h case    8:*/		return 0x820FBD18;
		  /* 820FBD18h */ case    9:  		/* rlwinm. R11, R11, 0, 6, 6 */
		/* 820FBD18h case    9:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R11,regs.R11);
		/* 820FBD18h case    9:*/		return 0x820FBD1C;
		  /* 820FBD1Ch */ case   10:  		/* bc 12, CR0_EQ, 12 */
		/* 820FBD1Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x820FBD28;  }
		/* 820FBD1Ch case   10:*/		return 0x820FBD20;
	}
	return 0x820FBD20;
} // Block from 820FBCF4h-820FBD20h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FBD20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBD20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBD20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBD20);
		  /* 820FBD20h */ case    0:  		/* oris R5, R5, 32 */
		/* 820FBD20h case    0:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R5,0x20);
		/* 820FBD20h case    0:*/		return 0x820FBD24;
		  /* 820FBD24h */ case    1:  		/* stw R5, <#[R1 + 84]> */
		/* 820FBD24h case    1:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 820FBD24h case    1:*/		return 0x820FBD28;
	}
	return 0x820FBD28;
} // Block from 820FBD20h-820FBD28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FBD28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBD28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBD28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBD28);
		  /* 820FBD28h */ case    0:  		/* lwz R11, <#[R1 + 88]> */
		/* 820FBD28h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 820FBD28h case    0:*/		return 0x820FBD2C;
		  /* 820FBD2Ch */ case    1:  		/* lis R10, -128 */
		/* 820FBD2Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFF80);
		/* 820FBD2Ch case    1:*/		return 0x820FBD30;
		  /* 820FBD30h */ case    2:  		/* lwz R9, <#[R31]> */
		/* 820FBD30h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 820FBD30h case    2:*/		return 0x820FBD34;
		  /* 820FBD34h */ case    3:  		/* li R6, 0 */
		/* 820FBD34h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820FBD34h case    3:*/		return 0x820FBD38;
		  /* 820FBD38h */ case    4:  		/* rlwimi R10, R11, 20, 9, 11 */
		/* 820FBD38h case    4:*/		cpu::op::rlwimi<0,20,9,11>(regs,&regs.R10,regs.R11);
		/* 820FBD38h case    4:*/		return 0x820FBD3C;
		  /* 820FBD3Ch */ case    5:  		/* lwz R7, <#[R1 + 92]> */
		/* 820FBD3Ch case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x0000005C) );
		/* 820FBD3Ch case    5:*/		return 0x820FBD40;
		  /* 820FBD40h */ case    6:  		/* rlwinm R8, R11, 0, 27, 28 */
		/* 820FBD40h case    6:*/		cpu::op::rlwinm<0,0,27,28>(regs,&regs.R8,regs.R11);
		/* 820FBD40h case    6:*/		return 0x820FBD44;
		  /* 820FBD44h */ case    7:  		/* rlwinm R11, R7, 0, 21, 31 */
		/* 820FBD44h case    7:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R11,regs.R7);
		/* 820FBD44h case    7:*/		return 0x820FBD48;
		  /* 820FBD48h */ case    8:  		/* or R10, R10, R8 */
		/* 820FBD48h case    8:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 820FBD48h case    8:*/		return 0x820FBD4C;
		  /* 820FBD4Ch */ case    9:  		/* lwz R9, <#[R9 + 312]> */
		/* 820FBD4Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000138) );
		/* 820FBD4Ch case    9:*/		return 0x820FBD50;
		  /* 820FBD50h */ case   10:  		/* mr R3, R31 */
		/* 820FBD50h case   10:*/		regs.R3 = regs.R31;
		/* 820FBD50h case   10:*/		return 0x820FBD54;
		  /* 820FBD54h */ case   11:  		/* rlwinm R10, R10, 8, 0, 23 */
		/* 820FBD54h case   11:*/		cpu::op::rlwinm<0,8,0,23>(regs,&regs.R10,regs.R10);
		/* 820FBD54h case   11:*/		return 0x820FBD58;
		  /* 820FBD58h */ case   12:  		/* or R11, R10, R11 */
		/* 820FBD58h case   12:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820FBD58h case   12:*/		return 0x820FBD5C;
		  /* 820FBD5Ch */ case   13:  		/* or R4, R11, R30 */
		/* 820FBD5Ch case   13:*/		cpu::op::or<0>(regs,&regs.R4,regs.R11,regs.R30);
		/* 820FBD5Ch case   13:*/		return 0x820FBD60;
		  /* 820FBD60h */ case   14:  		/* mtspr CTR, R9 */
		/* 820FBD60h case   14:*/		regs.CTR = regs.R9;
		/* 820FBD60h case   14:*/		return 0x820FBD64;
		  /* 820FBD64h */ case   15:  		/* bcctrl 20, CR0_LT */
		/* 820FBD64h case   15:*/		if ( 1 ) { regs.LR = 0x820FBD68; return (uint32)regs.CTR; }
		/* 820FBD64h case   15:*/		return 0x820FBD68;
		  /* 820FBD68h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 820FBD68h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FBD68h case   16:*/		return 0x820FBD6C;
		  /* 820FBD6Ch */ case   17:  		/* bc 12, CR0_LT, -500 */
		/* 820FBD6Ch case   17:*/		if ( regs.CR[0].lt ) { return 0x820FBB78;  }
		/* 820FBD6Ch case   17:*/		return 0x820FBD70;
		  /* 820FBD70h */ case   18:  		/* lwz R11, <#[R31]> */
		/* 820FBD70h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FBD70h case   18:*/		return 0x820FBD74;
		  /* 820FBD74h */ case   19:  		/* mr R3, R31 */
		/* 820FBD74h case   19:*/		regs.R3 = regs.R31;
		/* 820FBD74h case   19:*/		return 0x820FBD78;
		  /* 820FBD78h */ case   20:  		/* lwz R11, <#[R11 + 308]> */
		/* 820FBD78h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000134) );
		/* 820FBD78h case   20:*/		return 0x820FBD7C;
		  /* 820FBD7Ch */ case   21:  		/* mtspr CTR, R11 */
		/* 820FBD7Ch case   21:*/		regs.CTR = regs.R11;
		/* 820FBD7Ch case   21:*/		return 0x820FBD80;
		  /* 820FBD80h */ case   22:  		/* bcctrl 20, CR0_LT */
		/* 820FBD80h case   22:*/		if ( 1 ) { regs.LR = 0x820FBD84; return (uint32)regs.CTR; }
		/* 820FBD80h case   22:*/		return 0x820FBD84;
		  /* 820FBD84h */ case   23:  		/* cmpwi CR0, R3, 0 */
		/* 820FBD84h case   23:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FBD84h case   23:*/		return 0x820FBD88;
		  /* 820FBD88h */ case   24:  		/* bc 12, CR0_LT, -528 */
		/* 820FBD88h case   24:*/		if ( regs.CR[0].lt ) { return 0x820FBB78;  }
		/* 820FBD88h case   24:*/		return 0x820FBD8C;
		  /* 820FBD8Ch */ case   25:  		/* mr R3, R31 */
		/* 820FBD8Ch case   25:*/		regs.R3 = regs.R31;
		/* 820FBD8Ch case   25:*/		return 0x820FBD90;
		  /* 820FBD90h */ case   26:  		/* bl -58504 */
		/* 820FBD90h case   26:*/		regs.LR = 0x820FBD94; return 0x820ED908;
		/* 820FBD90h case   26:*/		return 0x820FBD94;
		  /* 820FBD94h */ case   27:  		/* cmpwi CR0, R3, 0 */
		/* 820FBD94h case   27:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FBD94h case   27:*/		return 0x820FBD98;
		  /* 820FBD98h */ case   28:  		/* bc 12, CR0_LT, -544 */
		/* 820FBD98h case   28:*/		if ( regs.CR[0].lt ) { return 0x820FBB78;  }
		/* 820FBD98h case   28:*/		return 0x820FBD9C;
		  /* 820FBD9Ch */ case   29:  		/* cmplwi CR6, R25, 0 */
		/* 820FBD9Ch case   29:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820FBD9Ch case   29:*/		return 0x820FBDA0;
		  /* 820FBDA0h */ case   30:  		/* bc 12, CR6_EQ, -1252 */
		/* 820FBDA0h case   30:*/		if ( regs.CR[6].eq ) { return 0x820FB8BC;  }
		/* 820FBDA0h case   30:*/		return 0x820FBDA4;
		  /* 820FBDA4h */ case   31:  		/* stw R29, <#[R25]> */
		/* 820FBDA4h case   31:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R25 + 0x00000000) );
		/* 820FBDA4h case   31:*/		return 0x820FBDA8;
		  /* 820FBDA8h */ case   32:  		/* b -1260 */
		/* 820FBDA8h case   32:*/		return 0x820FB8BC;
		/* 820FBDA8h case   32:*/		return 0x820FBDAC;
		  /* 820FBDACh */ case   33:  		/* li R3, 1 */
		/* 820FBDACh case   33:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FBDACh case   33:*/		return 0x820FBDB0;
		  /* 820FBDB0h */ case   34:  		/* b -568 */
		/* 820FBDB0h case   34:*/		return 0x820FBB78;
		/* 820FBDB0h case   34:*/		return 0x820FBDB4;
		  /* 820FBDB4h */ case   35:  		/* nop */
		/* 820FBDB4h case   35:*/		cpu::op::nop();
		/* 820FBDB4h case   35:*/		return 0x820FBDB8;
	}
	return 0x820FBDB8;
} // Block from 820FBD28h-820FBDB8h (36 instructions)

//////////////////////////////////////////////////////
// Block at 820FBDB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBDB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBDB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBDB8);
		  /* 820FBDB8h */ case    0:  		/* mfspr R12, LR */
		/* 820FBDB8h case    0:*/		regs.R12 = regs.LR;
		/* 820FBDB8h case    0:*/		return 0x820FBDBC;
		  /* 820FBDBCh */ case    1:  		/* bl -437096 */
		/* 820FBDBCh case    1:*/		regs.LR = 0x820FBDC0; return 0x82091254;
		/* 820FBDBCh case    1:*/		return 0x820FBDC0;
		  /* 820FBDC0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820FBDC0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820FBDC0h case    2:*/		return 0x820FBDC4;
		  /* 820FBDC4h */ case    3:  		/* lwz R10, <#[R3 + 128]> */
		/* 820FBDC4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000080) );
		/* 820FBDC4h case    3:*/		return 0x820FBDC8;
		  /* 820FBDC8h */ case    4:  		/* mr R31, R3 */
		/* 820FBDC8h case    4:*/		regs.R31 = regs.R3;
		/* 820FBDC8h case    4:*/		return 0x820FBDCC;
		  /* 820FBDCCh */ case    5:  		/* lwz R11, <#[R4 + 4]> */
		/* 820FBDCCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820FBDCCh case    5:*/		return 0x820FBDD0;
		  /* 820FBDD0h */ case    6:  		/* mr R30, R4 */
		/* 820FBDD0h case    6:*/		regs.R30 = regs.R4;
		/* 820FBDD0h case    6:*/		return 0x820FBDD4;
		  /* 820FBDD4h */ case    7:  		/* mr R29, R5 */
		/* 820FBDD4h case    7:*/		regs.R29 = regs.R5;
		/* 820FBDD4h case    7:*/		return 0x820FBDD8;
		  /* 820FBDD8h */ case    8:  		/* mr R28, R6 */
		/* 820FBDD8h case    8:*/		regs.R28 = regs.R6;
		/* 820FBDD8h case    8:*/		return 0x820FBDDC;
		  /* 820FBDDCh */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 820FBDDCh case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FBDDCh case    9:*/		return 0x820FBDE0;
		  /* 820FBDE0h */ case   10:  		/* bc 12, CR6_EQ, 16 */
		/* 820FBDE0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820FBDF0;  }
		/* 820FBDE0h case   10:*/		return 0x820FBDE4;
		  /* 820FBDE4h */ case   11:  		/* lwz R10, <#[R3 + 132]> */
		/* 820FBDE4h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000084) );
		/* 820FBDE4h case   11:*/		return 0x820FBDE8;
		  /* 820FBDE8h */ case   12:  		/* cmplw CR6, R11, R10 */
		/* 820FBDE8h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FBDE8h case   12:*/		return 0x820FBDEC;
		  /* 820FBDECh */ case   13:  		/* bc 4, CR6_EQ, 64 */
		/* 820FBDECh case   13:*/		if ( !regs.CR[6].eq ) { return 0x820FBE2C;  }
		/* 820FBDECh case   13:*/		return 0x820FBDF0;
	}
	return 0x820FBDF0;
} // Block from 820FBDB8h-820FBDF0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820FBDF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBDF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBDF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBDF0);
		  /* 820FBDF0h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FBDF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FBDF0h case    0:*/		return 0x820FBDF4;
		  /* 820FBDF4h */ case    1:  		/* mr R3, R31 */
		/* 820FBDF4h case    1:*/		regs.R3 = regs.R31;
		/* 820FBDF4h case    1:*/		return 0x820FBDF8;
		  /* 820FBDF8h */ case    2:  		/* lwz R4, <#[R30 + 108]> */
		/* 820FBDF8h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000006C) );
		/* 820FBDF8h case    2:*/		return 0x820FBDFC;
		  /* 820FBDFCh */ case    3:  		/* lwz R11, <#[R11 + 112]> */
		/* 820FBDFCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000070) );
		/* 820FBDFCh case    3:*/		return 0x820FBE00;
		  /* 820FBE00h */ case    4:  		/* mtspr CTR, R11 */
		/* 820FBE00h case    4:*/		regs.CTR = regs.R11;
		/* 820FBE00h case    4:*/		return 0x820FBE04;
		  /* 820FBE04h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 820FBE04h case    5:*/		if ( 1 ) { regs.LR = 0x820FBE08; return (uint32)regs.CTR; }
		/* 820FBE04h case    5:*/		return 0x820FBE08;
		  /* 820FBE08h */ case    6:  		/* lis R11, -32217 */
		/* 820FBE08h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 820FBE08h case    6:*/		return 0x820FBE0C;
		  /* 820FBE0Ch */ case    7:  		/* mr R5, R3 */
		/* 820FBE0Ch case    7:*/		regs.R5 = regs.R3;
		/* 820FBE0Ch case    7:*/		return 0x820FBE10;
		  /* 820FBE10h */ case    8:  		/* addi R4, R11, 14408 */
		/* 820FBE10h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x3848);
		/* 820FBE10h case    8:*/		return 0x820FBE14;
		  /* 820FBE14h */ case    9:  		/* mr R3, R31 */
		/* 820FBE14h case    9:*/		regs.R3 = regs.R31;
		/* 820FBE14h case    9:*/		return 0x820FBE18;
		  /* 820FBE18h */ case   10:  		/* bl -57904 */
		/* 820FBE18h case   10:*/		regs.LR = 0x820FBE1C; return 0x820EDBE8;
		/* 820FBE18h case   10:*/		return 0x820FBE1C;
		  /* 820FBE1Ch */ case   11:  		/* lwz R11, <#[R3 + 16]> */
		/* 820FBE1Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820FBE1Ch case   11:*/		return 0x820FBE20;
		  /* 820FBE20h */ case   12:  		/* mr R27, R3 */
		/* 820FBE20h case   12:*/		regs.R27 = regs.R3;
		/* 820FBE20h case   12:*/		return 0x820FBE24;
		  /* 820FBE24h */ case   13:  		/* cmpwi CR6, R11, -1 */
		/* 820FBE24h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FBE24h case   13:*/		return 0x820FBE28;
		  /* 820FBE28h */ case   14:  		/* bc 4, CR6_EQ, 28 */
		/* 820FBE28h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820FBE44;  }
		/* 820FBE28h case   14:*/		return 0x820FBE2C;
	}
	return 0x820FBE2C;
} // Block from 820FBDF0h-820FBE2Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 820FBE2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBE2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBE2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBE2C);
		  /* 820FBE2Ch */ case    0:  		/* mr R6, R28 */
		/* 820FBE2Ch case    0:*/		regs.R6 = regs.R28;
		/* 820FBE2Ch case    0:*/		return 0x820FBE30;
		  /* 820FBE30h */ case    1:  		/* mr R5, R29 */
		/* 820FBE30h case    1:*/		regs.R5 = regs.R29;
		/* 820FBE30h case    1:*/		return 0x820FBE34;
		  /* 820FBE34h */ case    2:  		/* mr R4, R30 */
		/* 820FBE34h case    2:*/		regs.R4 = regs.R30;
		/* 820FBE34h case    2:*/		return 0x820FBE38;
		  /* 820FBE38h */ case    3:  		/* mr R3, R31 */
		/* 820FBE38h case    3:*/		regs.R3 = regs.R31;
		/* 820FBE38h case    3:*/		return 0x820FBE3C;
		  /* 820FBE3Ch */ case    4:  		/* bl 75788 */
		/* 820FBE3Ch case    4:*/		regs.LR = 0x820FBE40; return 0x8210E648;
		/* 820FBE3Ch case    4:*/		return 0x820FBE40;
		  /* 820FBE40h */ case    5:  		/* b 88 */
		/* 820FBE40h case    5:*/		return 0x820FBE98;
		/* 820FBE40h case    5:*/		return 0x820FBE44;
	}
	return 0x820FBE44;
} // Block from 820FBE2Ch-820FBE44h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FBE44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBE44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBE44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBE44);
		  /* 820FBE44h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FBE44h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FBE44h case    0:*/		return 0x820FBE48;
		  /* 820FBE48h */ case    1:  		/* mr R3, R31 */
		/* 820FBE48h case    1:*/		regs.R3 = regs.R31;
		/* 820FBE48h case    1:*/		return 0x820FBE4C;
		  /* 820FBE4Ch */ case    2:  		/* lwz R4, <#[R30 + 108]> */
		/* 820FBE4Ch case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000006C) );
		/* 820FBE4Ch case    2:*/		return 0x820FBE50;
		  /* 820FBE50h */ case    3:  		/* lwz R11, <#[R11 + 116]> */
		/* 820FBE50h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000074) );
		/* 820FBE50h case    3:*/		return 0x820FBE54;
		  /* 820FBE54h */ case    4:  		/* mtspr CTR, R11 */
		/* 820FBE54h case    4:*/		regs.CTR = regs.R11;
		/* 820FBE54h case    4:*/		return 0x820FBE58;
		  /* 820FBE58h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 820FBE58h case    5:*/		if ( 1 ) { regs.LR = 0x820FBE5C; return (uint32)regs.CTR; }
		/* 820FBE58h case    5:*/		return 0x820FBE5C;
		  /* 820FBE5Ch */ case    6:  		/* lwz R11, <#[R30 + 4]> */
		/* 820FBE5Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 820FBE5Ch case    6:*/		return 0x820FBE60;
		  /* 820FBE60h */ case    7:  		/* lis R10, -32254 */
		/* 820FBE60h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820FBE60h case    7:*/		return 0x820FBE64;
		  /* 820FBE64h */ case    8:  		/* lwz R9, <#[R31 + 16]> */
		/* 820FBE64h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 820FBE64h case    8:*/		return 0x820FBE68;
		  /* 820FBE68h */ case    9:  		/* mr R8, R3 */
		/* 820FBE68h case    9:*/		regs.R8 = regs.R3;
		/* 820FBE68h case    9:*/		return 0x820FBE6C;
		  /* 820FBE6Ch */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FBE6Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FBE6Ch case   10:*/		return 0x820FBE70;
		  /* 820FBE70h */ case   11:  		/* lwz R7, <#[R27]> */
		/* 820FBE70h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R27 + 0x00000000) );
		/* 820FBE70h case   11:*/		return 0x820FBE74;
		  /* 820FBE74h */ case   12:  		/* addi R5, R10, -14420 */
		/* 820FBE74h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFC7AC);
		/* 820FBE74h case   12:*/		return 0x820FBE78;
		  /* 820FBE78h */ case   13:  		/* mr R4, R28 */
		/* 820FBE78h case   13:*/		regs.R4 = regs.R28;
		/* 820FBE78h case   13:*/		return 0x820FBE7C;
		  /* 820FBE7Ch */ case   14:  		/* mr R3, R29 */
		/* 820FBE7Ch case   14:*/		regs.R3 = regs.R29;
		/* 820FBE7Ch case   14:*/		return 0x820FBE80;
		  /* 820FBE80h */ case   15:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820FBE80h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FBE80h case   15:*/		return 0x820FBE84;
		  /* 820FBE84h */ case   16:  		/* lwz R6, <#[R11]> */
		/* 820FBE84h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 820FBE84h case   16:*/		return 0x820FBE88;
		  /* 820FBE88h */ case   17:  		/* bl -366664 */
		/* 820FBE88h case   17:*/		regs.LR = 0x820FBE8C; return 0x820A2640;
		/* 820FBE88h case   17:*/		return 0x820FBE8C;
		  /* 820FBE8Ch */ case   18:  		/* add R11, R29, R28 */
		/* 820FBE8Ch case   18:*/		cpu::op::add<0>(regs,&regs.R11,regs.R29,regs.R28);
		/* 820FBE8Ch case   18:*/		return 0x820FBE90;
		  /* 820FBE90h */ case   19:  		/* li R10, 0 */
		/* 820FBE90h case   19:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820FBE90h case   19:*/		return 0x820FBE94;
		  /* 820FBE94h */ case   20:  		/* stb R10, <#[R11 - 1]> */
		/* 820FBE94h case   20:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0xFFFFFFFF) );
		/* 820FBE94h case   20:*/		return 0x820FBE98;
	}
	return 0x820FBE98;
} // Block from 820FBE44h-820FBE98h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820FBE98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBE98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBE98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBE98);
		  /* 820FBE98h */ case    0:  		/* addi R1, R1, 128 */
		/* 820FBE98h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820FBE98h case    0:*/		return 0x820FBE9C;
		  /* 820FBE9Ch */ case    1:  		/* b -437240 */
		/* 820FBE9Ch case    1:*/		return 0x820912A4;
		/* 820FBE9Ch case    1:*/		return 0x820FBEA0;
	}
	return 0x820FBEA0;
} // Block from 820FBE98h-820FBEA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FBEA0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBEA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBEA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBEA0);
		  /* 820FBEA0h */ case    0:  		/* li R11, 0 */
		/* 820FBEA0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820FBEA0h case    0:*/		return 0x820FBEA4;
		  /* 820FBEA4h */ case    1:  		/* li R10, -1 */
		/* 820FBEA4h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820FBEA4h case    1:*/		return 0x820FBEA8;
		  /* 820FBEA8h */ case    2:  		/* stw R11, <#[R3]> */
		/* 820FBEA8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820FBEA8h case    2:*/		return 0x820FBEAC;
		  /* 820FBEACh */ case    3:  		/* stw R11, <#[R3 + 4]> */
		/* 820FBEACh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820FBEACh case    3:*/		return 0x820FBEB0;
		  /* 820FBEB0h */ case    4:  		/* stw R11, <#[R3 + 8]> */
		/* 820FBEB0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820FBEB0h case    4:*/		return 0x820FBEB4;
		  /* 820FBEB4h */ case    5:  		/* stw R11, <#[R3 + 12]> */
		/* 820FBEB4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820FBEB4h case    5:*/		return 0x820FBEB8;
		  /* 820FBEB8h */ case    6:  		/* stw R11, <#[R3 + 16]> */
		/* 820FBEB8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820FBEB8h case    6:*/		return 0x820FBEBC;
		  /* 820FBEBCh */ case    7:  		/* stw R11, <#[R3 + 20]> */
		/* 820FBEBCh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820FBEBCh case    7:*/		return 0x820FBEC0;
		  /* 820FBEC0h */ case    8:  		/* stw R11, <#[R3 + 24]> */
		/* 820FBEC0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820FBEC0h case    8:*/		return 0x820FBEC4;
		  /* 820FBEC4h */ case    9:  		/* stw R11, <#[R3 + 28]> */
		/* 820FBEC4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820FBEC4h case    9:*/		return 0x820FBEC8;
		  /* 820FBEC8h */ case   10:  		/* stw R11, <#[R3 + 32]> */
		/* 820FBEC8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820FBEC8h case   10:*/		return 0x820FBECC;
		  /* 820FBECCh */ case   11:  		/* stw R11, <#[R3 + 36]> */
		/* 820FBECCh case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820FBECCh case   11:*/		return 0x820FBED0;
		  /* 820FBED0h */ case   12:  		/* stw R11, <#[R3 + 40]> */
		/* 820FBED0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 820FBED0h case   12:*/		return 0x820FBED4;
		  /* 820FBED4h */ case   13:  		/* stw R11, <#[R3 + 44]> */
		/* 820FBED4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 820FBED4h case   13:*/		return 0x820FBED8;
		  /* 820FBED8h */ case   14:  		/* stw R10, <#[R3 + 48]> */
		/* 820FBED8h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000030) );
		/* 820FBED8h case   14:*/		return 0x820FBEDC;
		  /* 820FBEDCh */ case   15:  		/* stw R10, <#[R3 + 52]> */
		/* 820FBEDCh case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000034) );
		/* 820FBEDCh case   15:*/		return 0x820FBEE0;
		  /* 820FBEE0h */ case   16:  		/* stw R11, <#[R3 + 56]> */
		/* 820FBEE0h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 820FBEE0h case   16:*/		return 0x820FBEE4;
		  /* 820FBEE4h */ case   17:  		/* stw R11, <#[R3 + 60]> */
		/* 820FBEE4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000003C) );
		/* 820FBEE4h case   17:*/		return 0x820FBEE8;
		  /* 820FBEE8h */ case   18:  		/* bclr 20, CR0_LT */
		/* 820FBEE8h case   18:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FBEE8h case   18:*/		return 0x820FBEEC;
	}
	return 0x820FBEEC;
} // Block from 820FBEA0h-820FBEECh (19 instructions)

//////////////////////////////////////////////////////
// Block at 820FBEECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBEEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBEEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBEEC);
		  /* 820FBEECh */ case    0:  		/* nop */
		/* 820FBEECh case    0:*/		cpu::op::nop();
		/* 820FBEECh case    0:*/		return 0x820FBEF0;
	}
	return 0x820FBEF0;
} // Block from 820FBEECh-820FBEF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FBEF0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBEF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBEF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBEF0);
		  /* 820FBEF0h */ case    0:  		/* mr R11, R3 */
		/* 820FBEF0h case    0:*/		regs.R11 = regs.R3;
		/* 820FBEF0h case    0:*/		return 0x820FBEF4;
		  /* 820FBEF4h */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 820FBEF4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820FBEF4h case    1:*/		return 0x820FBEF8;
		  /* 820FBEF8h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820FBEF8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FBF08;  }
		/* 820FBEF8h case    2:*/		return 0x820FBEFC;
		  /* 820FBEFCh */ case    3:  		/* lis R3, -32768 */
		/* 820FBEFCh case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820FBEFCh case    3:*/		return 0x820FBF00;
		  /* 820FBF00h */ case    4:  		/* ori R3, R3, 16389 */
		/* 820FBF00h case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820FBF00h case    4:*/		return 0x820FBF04;
		  /* 820FBF04h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820FBF04h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FBF04h case    5:*/		return 0x820FBF08;
	}
	return 0x820FBF08;
} // Block from 820FBEF0h-820FBF08h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FBF08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBF08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBF08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBF08);
		  /* 820FBF08h */ case    0:  		/* lwz R10, <#[R4 + 60]> */
		/* 820FBF08h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000003C) );
		/* 820FBF08h case    0:*/		return 0x820FBF0C;
		  /* 820FBF0Ch */ case    1:  		/* li R3, 0 */
		/* 820FBF0Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FBF0Ch case    1:*/		return 0x820FBF10;
		  /* 820FBF10h */ case    2:  		/* stw R10, <#[R11 + 60]> */
		/* 820FBF10h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000003C) );
		/* 820FBF10h case    2:*/		return 0x820FBF14;
		  /* 820FBF14h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820FBF14h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FBF14h case    3:*/		return 0x820FBF18;
	}
	return 0x820FBF18;
} // Block from 820FBF08h-820FBF18h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FBF18h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBF18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBF18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBF18);
		  /* 820FBF18h */ case    0:  		/* lwz R10, <#[R3]> */
		/* 820FBF18h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820FBF18h case    0:*/		return 0x820FBF1C;
		  /* 820FBF1Ch */ case    1:  		/* mr R11, R3 */
		/* 820FBF1Ch case    1:*/		regs.R11 = regs.R3;
		/* 820FBF1Ch case    1:*/		return 0x820FBF20;
		  /* 820FBF20h */ case    2:  		/* lwz R9, <#[R3 + 4]> */
		/* 820FBF20h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820FBF20h case    2:*/		return 0x820FBF24;
		  /* 820FBF24h */ case    3:  		/* rlwinm R3, R10, 0, 12, 31 */
		/* 820FBF24h case    3:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R3,regs.R10);
		/* 820FBF24h case    3:*/		return 0x820FBF28;
		  /* 820FBF28h */ case    4:  		/* mullw R10, R3, R4 */
		/* 820FBF28h case    4:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R3,regs.R4);
		/* 820FBF28h case    4:*/		return 0x820FBF2C;
		  /* 820FBF2Ch */ case    5:  		/* add R8, R10, R3 */
		/* 820FBF2Ch case    5:*/		cpu::op::add<0>(regs,&regs.R8,regs.R10,regs.R3);
		/* 820FBF2Ch case    5:*/		return 0x820FBF30;
		  /* 820FBF30h */ case    6:  		/* cmplw CR6, R8, R9 */
		/* 820FBF30h case    6:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 820FBF30h case    6:*/		return 0x820FBF34;
		  /* 820FBF34h */ case    7:  		/* bc 4, CR6_GT, 28 */
		/* 820FBF34h case    7:*/		if ( !regs.CR[6].gt ) { return 0x820FBF50;  }
		/* 820FBF34h case    7:*/		return 0x820FBF38;
		  /* 820FBF38h */ case    8:  		/* cmplwi CR6, R5, 0 */
		/* 820FBF38h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820FBF38h case    8:*/		return 0x820FBF3C;
		  /* 820FBF3Ch */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 820FBF3Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820FBF48;  }
		/* 820FBF3Ch case    9:*/		return 0x820FBF40;
		  /* 820FBF40h */ case   10:  		/* li R11, 0 */
		/* 820FBF40h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820FBF40h case   10:*/		return 0x820FBF44;
		  /* 820FBF44h */ case   11:  		/* stw R11, <#[R5]> */
		/* 820FBF44h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820FBF44h case   11:*/		return 0x820FBF48;
	}
	return 0x820FBF48;
} // Block from 820FBF18h-820FBF48h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820FBF48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBF48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBF48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBF48);
		  /* 820FBF48h */ case    0:  		/* li R3, 0 */
		/* 820FBF48h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FBF48h case    0:*/		return 0x820FBF4C;
		  /* 820FBF4Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 820FBF4Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FBF4Ch case    1:*/		return 0x820FBF50;
	}
	return 0x820FBF50;
} // Block from 820FBF48h-820FBF50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FBF50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBF50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBF50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBF50);
		  /* 820FBF50h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 820FBF50h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820FBF50h case    0:*/		return 0x820FBF54;
		  /* 820FBF54h */ case    1:  		/* bclr 12, CR6_EQ */
		/* 820FBF54h case    1:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820FBF54h case    1:*/		return 0x820FBF58;
	}
	return 0x820FBF58;
} // Block from 820FBF50h-820FBF58h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FBF58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBF58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBF58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBF58);
		  /* 820FBF58h */ case    0:  		/* lwz R9, <#[R11 + 8]> */
		/* 820FBF58h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 820FBF58h case    0:*/		return 0x820FBF5C;
		  /* 820FBF5Ch */ case    1:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 820FBF5Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 820FBF5Ch case    1:*/		return 0x820FBF60;
		  /* 820FBF60h */ case    2:  		/* add R11, R11, R9 */
		/* 820FBF60h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820FBF60h case    2:*/		return 0x820FBF64;
		  /* 820FBF64h */ case    3:  		/* stw R11, <#[R5]> */
		/* 820FBF64h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820FBF64h case    3:*/		return 0x820FBF68;
		  /* 820FBF68h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820FBF68h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FBF68h case    4:*/		return 0x820FBF6C;
	}
	return 0x820FBF6C;
} // Block from 820FBF58h-820FBF6Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FBF6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBF6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBF6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBF6C);
		  /* 820FBF6Ch */ case    0:  		/* nop */
		/* 820FBF6Ch case    0:*/		cpu::op::nop();
		/* 820FBF6Ch case    0:*/		return 0x820FBF70;
	}
	return 0x820FBF70;
} // Block from 820FBF6Ch-820FBF70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FBF70h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBF70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBF70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBF70);
		  /* 820FBF70h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 820FBF70h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820FBF70h case    0:*/		return 0x820FBF74;
		  /* 820FBF74h */ case    1:  		/* lis R10, 24576 */
		/* 820FBF74h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x6000);
		/* 820FBF74h case    1:*/		return 0x820FBF78;
		  /* 820FBF78h */ case    2:  		/* rlwinm R9, R11, 0, 0, 3 */
		/* 820FBF78h case    2:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R9,regs.R11);
		/* 820FBF78h case    2:*/		return 0x820FBF7C;
		  /* 820FBF7Ch */ case    3:  		/* cmplw CR6, R9, R10 */
		/* 820FBF7Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 820FBF7Ch case    3:*/		return 0x820FBF80;
		  /* 820FBF80h */ case    4:  		/* bc 12, CR6_EQ, 48 */
		/* 820FBF80h case    4:*/		if ( regs.CR[6].eq ) { return 0x820FBFB0;  }
		/* 820FBF80h case    4:*/		return 0x820FBF84;
		  /* 820FBF84h */ case    5:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FBF84h case    5:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FBF84h case    5:*/		return 0x820FBF88;
		  /* 820FBF88h */ case    6:  		/* lis R10, 20496 */
		/* 820FBF88h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x5010);
		/* 820FBF88h case    6:*/		return 0x820FBF8C;
		  /* 820FBF8Ch */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FBF8Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FBF8Ch case    7:*/		return 0x820FBF90;
		  /* 820FBF90h */ case    8:  		/* bc 12, CR6_EQ, 32 */
		/* 820FBF90h case    8:*/		if ( regs.CR[6].eq ) { return 0x820FBFB0;  }
		/* 820FBF90h case    8:*/		return 0x820FBF94;
		  /* 820FBF94h */ case    9:  		/* lis R10, 20512 */
		/* 820FBF94h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x5020);
		/* 820FBF94h case    9:*/		return 0x820FBF98;
		  /* 820FBF98h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820FBF98h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FBF98h case   10:*/		return 0x820FBF9C;
		  /* 820FBF9Ch */ case   11:  		/* bc 12, CR6_EQ, 20 */
		/* 820FBF9Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820FBFB0;  }
		/* 820FBF9Ch case   11:*/		return 0x820FBFA0;
		  /* 820FBFA0h */ case   12:  		/* lis R10, 20528 */
		/* 820FBFA0h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0x5030);
		/* 820FBFA0h case   12:*/		return 0x820FBFA4;
		  /* 820FBFA4h */ case   13:  		/* li R3, 0 */
		/* 820FBFA4h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FBFA4h case   13:*/		return 0x820FBFA8;
		  /* 820FBFA8h */ case   14:  		/* cmplw CR6, R11, R10 */
		/* 820FBFA8h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FBFA8h case   14:*/		return 0x820FBFAC;
		  /* 820FBFACh */ case   15:  		/* bclr 4, CR6_EQ */
		/* 820FBFACh case   15:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820FBFACh case   15:*/		return 0x820FBFB0;
	}
	return 0x820FBFB0;
} // Block from 820FBF70h-820FBFB0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820FBFB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBFB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBFB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBFB0);
		  /* 820FBFB0h */ case    0:  		/* li R3, 1 */
		/* 820FBFB0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FBFB0h case    0:*/		return 0x820FBFB4;
		  /* 820FBFB4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820FBFB4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FBFB4h case    1:*/		return 0x820FBFB8;
	}
	return 0x820FBFB8;
} // Block from 820FBFB0h-820FBFB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FBFB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBFB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBFB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBFB8);
		  /* 820FBFB8h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 820FBFB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820FBFB8h case    0:*/		return 0x820FBFBC;
		  /* 820FBFBCh */ case    1:  		/* lis R10, 4144 */
		/* 820FBFBCh case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x1030);
		/* 820FBFBCh case    1:*/		return 0x820FBFC0;
		  /* 820FBFC0h */ case    2:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FBFC0h case    2:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FBFC0h case    2:*/		return 0x820FBFC4;
		  /* 820FBFC4h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820FBFC4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FBFC4h case    3:*/		return 0x820FBFC8;
		  /* 820FBFC8h */ case    4:  		/* bc 12, CR6_EQ, 44 */
		/* 820FBFC8h case    4:*/		if ( regs.CR[6].eq ) { return 0x820FBFF4;  }
		/* 820FBFC8h case    4:*/		return 0x820FBFCC;
		  /* 820FBFCCh */ case    5:  		/* lis R10, 4176 */
		/* 820FBFCCh case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0x1050);
		/* 820FBFCCh case    5:*/		return 0x820FBFD0;
		  /* 820FBFD0h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 820FBFD0h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FBFD0h case    6:*/		return 0x820FBFD4;
		  /* 820FBFD4h */ case    7:  		/* bc 12, CR6_EQ, 32 */
		/* 820FBFD4h case    7:*/		if ( regs.CR[6].eq ) { return 0x820FBFF4;  }
		/* 820FBFD4h case    7:*/		return 0x820FBFD8;
		  /* 820FBFD8h */ case    8:  		/* lis R10, 4192 */
		/* 820FBFD8h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0x1060);
		/* 820FBFD8h case    8:*/		return 0x820FBFDC;
		  /* 820FBFDCh */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 820FBFDCh case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FBFDCh case    9:*/		return 0x820FBFE0;
		  /* 820FBFE0h */ case   10:  		/* bc 12, CR6_EQ, 20 */
		/* 820FBFE0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820FBFF4;  }
		/* 820FBFE0h case   10:*/		return 0x820FBFE4;
		  /* 820FBFE4h */ case   11:  		/* lis R10, 4208 */
		/* 820FBFE4h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0x1070);
		/* 820FBFE4h case   11:*/		return 0x820FBFE8;
		  /* 820FBFE8h */ case   12:  		/* li R3, 0 */
		/* 820FBFE8h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FBFE8h case   12:*/		return 0x820FBFEC;
		  /* 820FBFECh */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 820FBFECh case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FBFECh case   13:*/		return 0x820FBFF0;
		  /* 820FBFF0h */ case   14:  		/* bclr 4, CR6_EQ */
		/* 820FBFF0h case   14:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820FBFF0h case   14:*/		return 0x820FBFF4;
	}
	return 0x820FBFF4;
} // Block from 820FBFB8h-820FBFF4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820FBFF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBFF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBFF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBFF4);
		  /* 820FBFF4h */ case    0:  		/* li R3, 1 */
		/* 820FBFF4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FBFF4h case    0:*/		return 0x820FBFF8;
		  /* 820FBFF8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820FBFF8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FBFF8h case    1:*/		return 0x820FBFFC;
	}
	return 0x820FBFFC;
} // Block from 820FBFF4h-820FBFFCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FBFFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FBFFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FBFFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FBFFC);
		  /* 820FBFFCh */ case    0:  		/* nop */
		/* 820FBFFCh case    0:*/		cpu::op::nop();
		/* 820FBFFCh case    0:*/		return 0x820FC000;
		  /* 820FC000h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 820FC000h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820FC000h case    1:*/		return 0x820FC004;
		  /* 820FC004h */ case    2:  		/* lis R10, 8192 */
		/* 820FC004h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0x2000);
		/* 820FC004h case    2:*/		return 0x820FC008;
		  /* 820FC008h */ case    3:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FC008h case    3:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FC008h case    3:*/		return 0x820FC00C;
		  /* 820FC00Ch */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FC00Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC00Ch case    4:*/		return 0x820FC010;
		  /* 820FC010h */ case    5:  		/* bc 12, CR6_EQ, 56 */
		/* 820FC010h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FC048;  }
		/* 820FC010h case    5:*/		return 0x820FC014;
		  /* 820FC014h */ case    6:  		/* lis R10, 8208 */
		/* 820FC014h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x2010);
		/* 820FC014h case    6:*/		return 0x820FC018;
		  /* 820FC018h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FC018h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC018h case    7:*/		return 0x820FC01C;
		  /* 820FC01Ch */ case    8:  		/* bc 12, CR6_EQ, 44 */
		/* 820FC01Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x820FC048;  }
		/* 820FC01Ch case    8:*/		return 0x820FC020;
		  /* 820FC020h */ case    9:  		/* lis R10, 8256 */
		/* 820FC020h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x2040);
		/* 820FC020h case    9:*/		return 0x820FC024;
		  /* 820FC024h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820FC024h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC024h case   10:*/		return 0x820FC028;
		  /* 820FC028h */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 820FC028h case   11:*/		if ( regs.CR[6].eq ) { return 0x820FC048;  }
		/* 820FC028h case   11:*/		return 0x820FC02C;
		  /* 820FC02Ch */ case   12:  		/* lis R10, 8272 */
		/* 820FC02Ch case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0x2050);
		/* 820FC02Ch case   12:*/		return 0x820FC030;
		  /* 820FC030h */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 820FC030h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC030h case   13:*/		return 0x820FC034;
		  /* 820FC034h */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 820FC034h case   14:*/		if ( regs.CR[6].eq ) { return 0x820FC048;  }
		/* 820FC034h case   14:*/		return 0x820FC038;
		  /* 820FC038h */ case   15:  		/* lis R10, 20480 */
		/* 820FC038h case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0x5000);
		/* 820FC038h case   15:*/		return 0x820FC03C;
		  /* 820FC03Ch */ case   16:  		/* li R3, 0 */
		/* 820FC03Ch case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FC03Ch case   16:*/		return 0x820FC040;
		  /* 820FC040h */ case   17:  		/* cmplw CR6, R11, R10 */
		/* 820FC040h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC040h case   17:*/		return 0x820FC044;
		  /* 820FC044h */ case   18:  		/* bclr 4, CR6_EQ */
		/* 820FC044h case   18:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820FC044h case   18:*/		return 0x820FC048;
	}
	return 0x820FC048;
} // Block from 820FBFFCh-820FC048h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820FC048h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC048( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC048) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC048);
		  /* 820FC048h */ case    0:  		/* li R3, 1 */
		/* 820FC048h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FC048h case    0:*/		return 0x820FC04C;
		  /* 820FC04Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 820FC04Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FC04Ch case    1:*/		return 0x820FC050;
	}
	return 0x820FC050;
} // Block from 820FC048h-820FC050h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FC050h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC050);
		  /* 820FC050h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 820FC050h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820FC050h case    0:*/		return 0x820FC054;
		  /* 820FC054h */ case    1:  		/* lis R10, 4096 */
		/* 820FC054h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x1000);
		/* 820FC054h case    1:*/		return 0x820FC058;
		  /* 820FC058h */ case    2:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FC058h case    2:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FC058h case    2:*/		return 0x820FC05C;
		  /* 820FC05Ch */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820FC05Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC05Ch case    3:*/		return 0x820FC060;
		  /* 820FC060h */ case    4:  		/* bc 12, CR6_EQ, 68 */
		/* 820FC060h case    4:*/		if ( regs.CR[6].eq ) { return 0x820FC0A4;  }
		/* 820FC060h case    4:*/		return 0x820FC064;
		  /* 820FC064h */ case    5:  		/* lis R10, 4112 */
		/* 820FC064h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0x1010);
		/* 820FC064h case    5:*/		return 0x820FC068;
		  /* 820FC068h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 820FC068h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC068h case    6:*/		return 0x820FC06C;
		  /* 820FC06Ch */ case    7:  		/* bc 12, CR6_EQ, 56 */
		/* 820FC06Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x820FC0A4;  }
		/* 820FC06Ch case    7:*/		return 0x820FC070;
		  /* 820FC070h */ case    8:  		/* lis R10, 4384 */
		/* 820FC070h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0x1120);
		/* 820FC070h case    8:*/		return 0x820FC074;
		  /* 820FC074h */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 820FC074h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC074h case    9:*/		return 0x820FC078;
		  /* 820FC078h */ case   10:  		/* bc 12, CR6_EQ, 44 */
		/* 820FC078h case   10:*/		if ( regs.CR[6].eq ) { return 0x820FC0A4;  }
		/* 820FC078h case   10:*/		return 0x820FC07C;
		  /* 820FC07Ch */ case   11:  		/* lis R10, 8304 */
		/* 820FC07Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0x2070);
		/* 820FC07Ch case   11:*/		return 0x820FC080;
		  /* 820FC080h */ case   12:  		/* cmplw CR6, R11, R10 */
		/* 820FC080h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC080h case   12:*/		return 0x820FC084;
		  /* 820FC084h */ case   13:  		/* bc 12, CR6_EQ, 32 */
		/* 820FC084h case   13:*/		if ( regs.CR[6].eq ) { return 0x820FC0A4;  }
		/* 820FC084h case   13:*/		return 0x820FC088;
		  /* 820FC088h */ case   14:  		/* lis R10, 8320 */
		/* 820FC088h case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0x2080);
		/* 820FC088h case   14:*/		return 0x820FC08C;
		  /* 820FC08Ch */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 820FC08Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC08Ch case   15:*/		return 0x820FC090;
		  /* 820FC090h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 820FC090h case   16:*/		if ( regs.CR[6].eq ) { return 0x820FC0A4;  }
		/* 820FC090h case   16:*/		return 0x820FC094;
		  /* 820FC094h */ case   17:  		/* lis R10, 8336 */
		/* 820FC094h case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0x2090);
		/* 820FC094h case   17:*/		return 0x820FC098;
		  /* 820FC098h */ case   18:  		/* li R3, 0 */
		/* 820FC098h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FC098h case   18:*/		return 0x820FC09C;
		  /* 820FC09Ch */ case   19:  		/* cmplw CR6, R11, R10 */
		/* 820FC09Ch case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC09Ch case   19:*/		return 0x820FC0A0;
		  /* 820FC0A0h */ case   20:  		/* bclr 4, CR6_EQ */
		/* 820FC0A0h case   20:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820FC0A0h case   20:*/		return 0x820FC0A4;
	}
	return 0x820FC0A4;
} // Block from 820FC050h-820FC0A4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820FC0A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC0A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC0A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC0A4);
		  /* 820FC0A4h */ case    0:  		/* li R3, 1 */
		/* 820FC0A4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FC0A4h case    0:*/		return 0x820FC0A8;
		  /* 820FC0A8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820FC0A8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FC0A8h case    1:*/		return 0x820FC0AC;
	}
	return 0x820FC0AC;
} // Block from 820FC0A4h-820FC0ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FC0ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC0AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC0AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC0AC);
		  /* 820FC0ACh */ case    0:  		/* nop */
		/* 820FC0ACh case    0:*/		cpu::op::nop();
		/* 820FC0ACh case    0:*/		return 0x820FC0B0;
		  /* 820FC0B0h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 820FC0B0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820FC0B0h case    1:*/		return 0x820FC0B4;
		  /* 820FC0B4h */ case    2:  		/* lis R10, 28784 */
		/* 820FC0B4h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0x7070);
		/* 820FC0B4h case    2:*/		return 0x820FC0B8;
		  /* 820FC0B8h */ case    3:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FC0B8h case    3:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FC0B8h case    3:*/		return 0x820FC0BC;
		  /* 820FC0BCh */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FC0BCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC0BCh case    4:*/		return 0x820FC0C0;
		  /* 820FC0C0h */ case    5:  		/* bc 12, CR6_GT, 64 */
		/* 820FC0C0h case    5:*/		if ( regs.CR[6].gt ) { return 0x820FC100;  }
		/* 820FC0C0h case    5:*/		return 0x820FC0C4;
		  /* 820FC0C4h */ case    6:  		/* bc 12, CR6_EQ, 112 */
		/* 820FC0C4h case    6:*/		if ( regs.CR[6].eq ) { return 0x820FC134;  }
		/* 820FC0C4h case    6:*/		return 0x820FC0C8;
		  /* 820FC0C8h */ case    7:  		/* lis R10, 20528 */
		/* 820FC0C8h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0x5030);
		/* 820FC0C8h case    7:*/		return 0x820FC0CC;
		  /* 820FC0CCh */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 820FC0CCh case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC0CCh case    8:*/		return 0x820FC0D0;
		  /* 820FC0D0h */ case    9:  		/* bc 12, CR6_EQ, 100 */
		/* 820FC0D0h case    9:*/		if ( regs.CR[6].eq ) { return 0x820FC134;  }
		/* 820FC0D0h case    9:*/		return 0x820FC0D4;
		  /* 820FC0D4h */ case   10:  		/* lis R10, 28688 */
		/* 820FC0D4h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0x7010);
		/* 820FC0D4h case   10:*/		return 0x820FC0D8;
		  /* 820FC0D8h */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 820FC0D8h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC0D8h case   11:*/		return 0x820FC0DC;
		  /* 820FC0DCh */ case   12:  		/* bc 12, CR6_EQ, 88 */
		/* 820FC0DCh case   12:*/		if ( regs.CR[6].eq ) { return 0x820FC134;  }
		/* 820FC0DCh case   12:*/		return 0x820FC0E0;
		  /* 820FC0E0h */ case   13:  		/* lis R10, 28704 */
		/* 820FC0E0h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0x7020);
		/* 820FC0E0h case   13:*/		return 0x820FC0E4;
		  /* 820FC0E4h */ case   14:  		/* cmplw CR6, R11, R10 */
		/* 820FC0E4h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC0E4h case   14:*/		return 0x820FC0E8;
		  /* 820FC0E8h */ case   15:  		/* bc 12, CR6_EQ, 76 */
		/* 820FC0E8h case   15:*/		if ( regs.CR[6].eq ) { return 0x820FC134;  }
		/* 820FC0E8h case   15:*/		return 0x820FC0EC;
		  /* 820FC0ECh */ case   16:  		/* lis R10, 28752 */
		/* 820FC0ECh case   16:*/		cpu::op::lis<0>(regs,&regs.R10,0x7050);
		/* 820FC0ECh case   16:*/		return 0x820FC0F0;
		  /* 820FC0F0h */ case   17:  		/* cmplw CR6, R11, R10 */
		/* 820FC0F0h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC0F0h case   17:*/		return 0x820FC0F4;
		  /* 820FC0F4h */ case   18:  		/* bc 12, CR6_EQ, 64 */
		/* 820FC0F4h case   18:*/		if ( regs.CR[6].eq ) { return 0x820FC134;  }
		/* 820FC0F4h case   18:*/		return 0x820FC0F8;
		  /* 820FC0F8h */ case   19:  		/* lis R10, 28768 */
		/* 820FC0F8h case   19:*/		cpu::op::lis<0>(regs,&regs.R10,0x7060);
		/* 820FC0F8h case   19:*/		return 0x820FC0FC;
		  /* 820FC0FCh */ case   20:  		/* b 44 */
		/* 820FC0FCh case   20:*/		return 0x820FC128;
		/* 820FC0FCh case   20:*/		return 0x820FC100;
	}
	return 0x820FC100;
} // Block from 820FC0ACh-820FC100h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820FC100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC100);
		  /* 820FC100h */ case    0:  		/* lis R10, 28848 */
		/* 820FC100h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x70B0);
		/* 820FC100h case    0:*/		return 0x820FC104;
		  /* 820FC104h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FC104h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC104h case    1:*/		return 0x820FC108;
		  /* 820FC108h */ case    2:  		/* bc 12, CR6_EQ, 44 */
		/* 820FC108h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FC134;  }
		/* 820FC108h case    2:*/		return 0x820FC10C;
		  /* 820FC10Ch */ case    3:  		/* lis R10, 28864 */
		/* 820FC10Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x70C0);
		/* 820FC10Ch case    3:*/		return 0x820FC110;
		  /* 820FC110h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FC110h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC110h case    4:*/		return 0x820FC114;
		  /* 820FC114h */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 820FC114h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FC134;  }
		/* 820FC114h case    5:*/		return 0x820FC118;
		  /* 820FC118h */ case    6:  		/* lis R10, 28880 */
		/* 820FC118h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x70D0);
		/* 820FC118h case    6:*/		return 0x820FC11C;
		  /* 820FC11Ch */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FC11Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC11Ch case    7:*/		return 0x820FC120;
		  /* 820FC120h */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 820FC120h case    8:*/		if ( regs.CR[6].eq ) { return 0x820FC134;  }
		/* 820FC120h case    8:*/		return 0x820FC124;
		  /* 820FC124h */ case    9:  		/* lis R10, 28928 */
		/* 820FC124h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x7100);
		/* 820FC124h case    9:*/		return 0x820FC128;
	}
	return 0x820FC128;
} // Block from 820FC100h-820FC128h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FC128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC128);
		  /* 820FC128h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 820FC128h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC128h case    0:*/		return 0x820FC12C;
		  /* 820FC12Ch */ case    1:  		/* li R3, 0 */
		/* 820FC12Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FC12Ch case    1:*/		return 0x820FC130;
		  /* 820FC130h */ case    2:  		/* bclr 4, CR6_EQ */
		/* 820FC130h case    2:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820FC130h case    2:*/		return 0x820FC134;
	}
	return 0x820FC134;
} // Block from 820FC128h-820FC134h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FC134h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC134( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC134) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC134);
		  /* 820FC134h */ case    0:  		/* li R3, 1 */
		/* 820FC134h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FC134h case    0:*/		return 0x820FC138;
		  /* 820FC138h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820FC138h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FC138h case    1:*/		return 0x820FC13C;
	}
	return 0x820FC13C;
} // Block from 820FC134h-820FC13Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FC13Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC13C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC13C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC13C);
		  /* 820FC13Ch */ case    0:  		/* nop */
		/* 820FC13Ch case    0:*/		cpu::op::nop();
		/* 820FC13Ch case    0:*/		return 0x820FC140;
		  /* 820FC140h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 820FC140h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820FC140h case    1:*/		return 0x820FC144;
		  /* 820FC144h */ case    2:  		/* lis R10, 29728 */
		/* 820FC144h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0x7420);
		/* 820FC144h case    2:*/		return 0x820FC148;
		  /* 820FC148h */ case    3:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FC148h case    3:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FC148h case    3:*/		return 0x820FC14C;
		  /* 820FC14Ch */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FC14Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC14Ch case    4:*/		return 0x820FC150;
		  /* 820FC150h */ case    5:  		/* bc 12, CR6_GT, 100 */
		/* 820FC150h case    5:*/		if ( regs.CR[6].gt ) { return 0x820FC1B4;  }
		/* 820FC150h case    5:*/		return 0x820FC154;
		  /* 820FC154h */ case    6:  		/* bc 12, CR6_EQ, 184 */
		/* 820FC154h case    6:*/		if ( regs.CR[6].eq ) { return 0x820FC20C;  }
		/* 820FC154h case    6:*/		return 0x820FC158;
		  /* 820FC158h */ case    7:  		/* lis R10, 4432 */
		/* 820FC158h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0x1150);
		/* 820FC158h case    7:*/		return 0x820FC15C;
		  /* 820FC15Ch */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 820FC15Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC15Ch case    8:*/		return 0x820FC160;
		  /* 820FC160h */ case    9:  		/* bc 12, CR6_GT, 52 */
		/* 820FC160h case    9:*/		if ( regs.CR[6].gt ) { return 0x820FC194;  }
		/* 820FC160h case    9:*/		return 0x820FC164;
		  /* 820FC164h */ case   10:  		/* bc 12, CR6_EQ, 168 */
		/* 820FC164h case   10:*/		if ( regs.CR[6].eq ) { return 0x820FC20C;  }
		/* 820FC164h case   10:*/		return 0x820FC168;
		  /* 820FC168h */ case   11:  		/* lis R10, 4368 */
		/* 820FC168h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0x1110);
		/* 820FC168h case   11:*/		return 0x820FC16C;
		  /* 820FC16Ch */ case   12:  		/* cmplw CR6, R11, R10 */
		/* 820FC16Ch case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC16Ch case   12:*/		return 0x820FC170;
		  /* 820FC170h */ case   13:  		/* bc 12, CR6_EQ, 156 */
		/* 820FC170h case   13:*/		if ( regs.CR[6].eq ) { return 0x820FC20C;  }
		/* 820FC170h case   13:*/		return 0x820FC174;
		  /* 820FC174h */ case   14:  		/* lis R10, 4384 */
		/* 820FC174h case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0x1120);
		/* 820FC174h case   14:*/		return 0x820FC178;
		  /* 820FC178h */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 820FC178h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC178h case   15:*/		return 0x820FC17C;
		  /* 820FC17Ch */ case   16:  		/* bc 12, CR6_EQ, 144 */
		/* 820FC17Ch case   16:*/		if ( regs.CR[6].eq ) { return 0x820FC20C;  }
		/* 820FC17Ch case   16:*/		return 0x820FC180;
		  /* 820FC180h */ case   17:  		/* lis R10, 4400 */
		/* 820FC180h case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0x1130);
		/* 820FC180h case   17:*/		return 0x820FC184;
		  /* 820FC184h */ case   18:  		/* cmplw CR6, R11, R10 */
		/* 820FC184h case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC184h case   18:*/		return 0x820FC188;
		  /* 820FC188h */ case   19:  		/* bc 12, CR6_EQ, 132 */
		/* 820FC188h case   19:*/		if ( regs.CR[6].eq ) { return 0x820FC20C;  }
		/* 820FC188h case   19:*/		return 0x820FC18C;
		  /* 820FC18Ch */ case   20:  		/* lis R10, 4416 */
		/* 820FC18Ch case   20:*/		cpu::op::lis<0>(regs,&regs.R10,0x1140);
		/* 820FC18Ch case   20:*/		return 0x820FC190;
		  /* 820FC190h */ case   21:  		/* b 112 */
		/* 820FC190h case   21:*/		return 0x820FC200;
		/* 820FC190h case   21:*/		return 0x820FC194;
	}
	return 0x820FC194;
} // Block from 820FC13Ch-820FC194h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820FC194h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC194( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC194) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC194);
		  /* 820FC194h */ case    0:  		/* lis R10, 8320 */
		/* 820FC194h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x2080);
		/* 820FC194h case    0:*/		return 0x820FC198;
		  /* 820FC198h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FC198h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC198h case    1:*/		return 0x820FC19C;
		  /* 820FC19Ch */ case    2:  		/* bc 12, CR6_EQ, 112 */
		/* 820FC19Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820FC20C;  }
		/* 820FC19Ch case    2:*/		return 0x820FC1A0;
		  /* 820FC1A0h */ case    3:  		/* lis R10, 8336 */
		/* 820FC1A0h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x2090);
		/* 820FC1A0h case    3:*/		return 0x820FC1A4;
		  /* 820FC1A4h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FC1A4h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC1A4h case    4:*/		return 0x820FC1A8;
		  /* 820FC1A8h */ case    5:  		/* bc 12, CR6_EQ, 100 */
		/* 820FC1A8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FC20C;  }
		/* 820FC1A8h case    5:*/		return 0x820FC1AC;
		  /* 820FC1ACh */ case    6:  		/* lis R10, 29712 */
		/* 820FC1ACh case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x7410);
		/* 820FC1ACh case    6:*/		return 0x820FC1B0;
		  /* 820FC1B0h */ case    7:  		/* b 80 */
		/* 820FC1B0h case    7:*/		return 0x820FC200;
		/* 820FC1B0h case    7:*/		return 0x820FC1B4;
	}
	return 0x820FC1B4;
} // Block from 820FC194h-820FC1B4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820FC1B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC1B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC1B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC1B4);
		  /* 820FC1B4h */ case    0:  		/* lis R10, 29744 */
		/* 820FC1B4h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x7430);
		/* 820FC1B4h case    0:*/		return 0x820FC1B8;
		  /* 820FC1B8h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FC1B8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC1B8h case    1:*/		return 0x820FC1BC;
		  /* 820FC1BCh */ case    2:  		/* bc 12, CR6_EQ, 80 */
		/* 820FC1BCh case    2:*/		if ( regs.CR[6].eq ) { return 0x820FC20C;  }
		/* 820FC1BCh case    2:*/		return 0x820FC1C0;
		  /* 820FC1C0h */ case    3:  		/* lis R10, 29760 */
		/* 820FC1C0h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x7440);
		/* 820FC1C0h case    3:*/		return 0x820FC1C4;
		  /* 820FC1C4h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FC1C4h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC1C4h case    4:*/		return 0x820FC1C8;
		  /* 820FC1C8h */ case    5:  		/* bc 12, CR6_EQ, 68 */
		/* 820FC1C8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FC20C;  }
		/* 820FC1C8h case    5:*/		return 0x820FC1CC;
		  /* 820FC1CCh */ case    6:  		/* lis R10, 29776 */
		/* 820FC1CCh case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x7450);
		/* 820FC1CCh case    6:*/		return 0x820FC1D0;
		  /* 820FC1D0h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FC1D0h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC1D0h case    7:*/		return 0x820FC1D4;
		  /* 820FC1D4h */ case    8:  		/* bc 12, CR6_EQ, 56 */
		/* 820FC1D4h case    8:*/		if ( regs.CR[6].eq ) { return 0x820FC20C;  }
		/* 820FC1D4h case    8:*/		return 0x820FC1D8;
		  /* 820FC1D8h */ case    9:  		/* lis R10, 29792 */
		/* 820FC1D8h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x7460);
		/* 820FC1D8h case    9:*/		return 0x820FC1DC;
		  /* 820FC1DCh */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820FC1DCh case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC1DCh case   10:*/		return 0x820FC1E0;
		  /* 820FC1E0h */ case   11:  		/* bc 12, CR6_EQ, 44 */
		/* 820FC1E0h case   11:*/		if ( regs.CR[6].eq ) { return 0x820FC20C;  }
		/* 820FC1E0h case   11:*/		return 0x820FC1E4;
		  /* 820FC1E4h */ case   12:  		/* lis R10, 29808 */
		/* 820FC1E4h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0x7470);
		/* 820FC1E4h case   12:*/		return 0x820FC1E8;
		  /* 820FC1E8h */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 820FC1E8h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC1E8h case   13:*/		return 0x820FC1EC;
		  /* 820FC1ECh */ case   14:  		/* bc 12, CR6_EQ, 32 */
		/* 820FC1ECh case   14:*/		if ( regs.CR[6].eq ) { return 0x820FC20C;  }
		/* 820FC1ECh case   14:*/		return 0x820FC1F0;
		  /* 820FC1F0h */ case   15:  		/* lis R10, 29856 */
		/* 820FC1F0h case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0x74A0);
		/* 820FC1F0h case   15:*/		return 0x820FC1F4;
		  /* 820FC1F4h */ case   16:  		/* cmplw CR6, R11, R10 */
		/* 820FC1F4h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC1F4h case   16:*/		return 0x820FC1F8;
		  /* 820FC1F8h */ case   17:  		/* bc 12, CR6_EQ, 20 */
		/* 820FC1F8h case   17:*/		if ( regs.CR[6].eq ) { return 0x820FC20C;  }
		/* 820FC1F8h case   17:*/		return 0x820FC1FC;
		  /* 820FC1FCh */ case   18:  		/* lis R10, 29872 */
		/* 820FC1FCh case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0x74B0);
		/* 820FC1FCh case   18:*/		return 0x820FC200;
	}
	return 0x820FC200;
} // Block from 820FC1B4h-820FC200h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820FC200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC200);
		  /* 820FC200h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 820FC200h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC200h case    0:*/		return 0x820FC204;
		  /* 820FC204h */ case    1:  		/* li R3, 0 */
		/* 820FC204h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FC204h case    1:*/		return 0x820FC208;
		  /* 820FC208h */ case    2:  		/* bclr 4, CR6_EQ */
		/* 820FC208h case    2:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820FC208h case    2:*/		return 0x820FC20C;
	}
	return 0x820FC20C;
} // Block from 820FC200h-820FC20Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FC20Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC20C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC20C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC20C);
		  /* 820FC20Ch */ case    0:  		/* li R3, 1 */
		/* 820FC20Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FC20Ch case    0:*/		return 0x820FC210;
		  /* 820FC210h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820FC210h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FC210h case    1:*/		return 0x820FC214;
	}
	return 0x820FC214;
} // Block from 820FC20Ch-820FC214h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FC214h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC214( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC214) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC214);
		  /* 820FC214h */ case    0:  		/* nop */
		/* 820FC214h case    0:*/		cpu::op::nop();
		/* 820FC214h case    0:*/		return 0x820FC218;
	}
	return 0x820FC218;
} // Block from 820FC214h-820FC218h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FC218h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC218);
		  /* 820FC218h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 820FC218h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820FC218h case    0:*/		return 0x820FC21C;
		  /* 820FC21Ch */ case    1:  		/* lis R10, 29456 */
		/* 820FC21Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x7310);
		/* 820FC21Ch case    1:*/		return 0x820FC220;
		  /* 820FC220h */ case    2:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FC220h case    2:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FC220h case    2:*/		return 0x820FC224;
		  /* 820FC224h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820FC224h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC224h case    3:*/		return 0x820FC228;
		  /* 820FC228h */ case    4:  		/* bc 12, CR6_EQ, 68 */
		/* 820FC228h case    4:*/		if ( regs.CR[6].eq ) { return 0x820FC26C;  }
		/* 820FC228h case    4:*/		return 0x820FC22C;
		  /* 820FC22Ch */ case    5:  		/* lis R10, 29488 */
		/* 820FC22Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0x7330);
		/* 820FC22Ch case    5:*/		return 0x820FC230;
		  /* 820FC230h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 820FC230h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC230h case    6:*/		return 0x820FC234;
		  /* 820FC234h */ case    7:  		/* bc 12, CR6_EQ, 56 */
		/* 820FC234h case    7:*/		if ( regs.CR[6].eq ) { return 0x820FC26C;  }
		/* 820FC234h case    7:*/		return 0x820FC238;
		  /* 820FC238h */ case    8:  		/* lis R10, 29648 */
		/* 820FC238h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0x73D0);
		/* 820FC238h case    8:*/		return 0x820FC23C;
		  /* 820FC23Ch */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 820FC23Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC23Ch case    9:*/		return 0x820FC240;
		  /* 820FC240h */ case   10:  		/* bc 12, CR6_EQ, 44 */
		/* 820FC240h case   10:*/		if ( regs.CR[6].eq ) { return 0x820FC26C;  }
		/* 820FC240h case   10:*/		return 0x820FC244;
		  /* 820FC244h */ case   11:  		/* lis R10, 29664 */
		/* 820FC244h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0x73E0);
		/* 820FC244h case   11:*/		return 0x820FC248;
		  /* 820FC248h */ case   12:  		/* cmplw CR6, R11, R10 */
		/* 820FC248h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC248h case   12:*/		return 0x820FC24C;
		  /* 820FC24Ch */ case   13:  		/* bc 12, CR6_EQ, 32 */
		/* 820FC24Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x820FC26C;  }
		/* 820FC24Ch case   13:*/		return 0x820FC250;
		  /* 820FC250h */ case   14:  		/* lis R10, 29680 */
		/* 820FC250h case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0x73F0);
		/* 820FC250h case   14:*/		return 0x820FC254;
		  /* 820FC254h */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 820FC254h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC254h case   15:*/		return 0x820FC258;
		  /* 820FC258h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 820FC258h case   16:*/		if ( regs.CR[6].eq ) { return 0x820FC26C;  }
		/* 820FC258h case   16:*/		return 0x820FC25C;
		  /* 820FC25Ch */ case   17:  		/* lis R10, 29696 */
		/* 820FC25Ch case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0x7400);
		/* 820FC25Ch case   17:*/		return 0x820FC260;
		  /* 820FC260h */ case   18:  		/* li R3, 0 */
		/* 820FC260h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FC260h case   18:*/		return 0x820FC264;
		  /* 820FC264h */ case   19:  		/* cmplw CR6, R11, R10 */
		/* 820FC264h case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC264h case   19:*/		return 0x820FC268;
		  /* 820FC268h */ case   20:  		/* bclr 4, CR6_EQ */
		/* 820FC268h case   20:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820FC268h case   20:*/		return 0x820FC26C;
	}
	return 0x820FC26C;
} // Block from 820FC218h-820FC26Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 820FC26Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC26C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC26C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC26C);
		  /* 820FC26Ch */ case    0:  		/* li R3, 1 */
		/* 820FC26Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FC26Ch case    0:*/		return 0x820FC270;
		  /* 820FC270h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820FC270h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FC270h case    1:*/		return 0x820FC274;
	}
	return 0x820FC274;
} // Block from 820FC26Ch-820FC274h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FC274h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC274( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC274) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC274);
		  /* 820FC274h */ case    0:  		/* nop */
		/* 820FC274h case    0:*/		cpu::op::nop();
		/* 820FC274h case    0:*/		return 0x820FC278;
	}
	return 0x820FC278;
} // Block from 820FC274h-820FC278h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FC278h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC278);
		  /* 820FC278h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 820FC278h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820FC278h case    0:*/		return 0x820FC27C;
		  /* 820FC27Ch */ case    1:  		/* lis R10, 8304 */
		/* 820FC27Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x2070);
		/* 820FC27Ch case    1:*/		return 0x820FC280;
		  /* 820FC280h */ case    2:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FC280h case    2:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FC280h case    2:*/		return 0x820FC284;
		  /* 820FC284h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820FC284h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC284h case    3:*/		return 0x820FC288;
		  /* 820FC288h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 820FC288h case    4:*/		if ( regs.CR[6].eq ) { return 0x820FC29C;  }
		/* 820FC288h case    4:*/		return 0x820FC28C;
		  /* 820FC28Ch */ case    5:  		/* lis R10, 29504 */
		/* 820FC28Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0x7340);
		/* 820FC28Ch case    5:*/		return 0x820FC290;
		  /* 820FC290h */ case    6:  		/* li R3, 0 */
		/* 820FC290h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FC290h case    6:*/		return 0x820FC294;
		  /* 820FC294h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FC294h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC294h case    7:*/		return 0x820FC298;
		  /* 820FC298h */ case    8:  		/* bclr 4, CR6_EQ */
		/* 820FC298h case    8:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820FC298h case    8:*/		return 0x820FC29C;
	}
	return 0x820FC29C;
} // Block from 820FC278h-820FC29Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820FC29Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC29C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC29C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC29C);
		  /* 820FC29Ch */ case    0:  		/* li R3, 1 */
		/* 820FC29Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FC29Ch case    0:*/		return 0x820FC2A0;
		  /* 820FC2A0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820FC2A0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FC2A0h case    1:*/		return 0x820FC2A4;
	}
	return 0x820FC2A4;
} // Block from 820FC29Ch-820FC2A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FC2A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC2A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC2A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC2A4);
		  /* 820FC2A4h */ case    0:  		/* nop */
		/* 820FC2A4h case    0:*/		cpu::op::nop();
		/* 820FC2A4h case    0:*/		return 0x820FC2A8;
	}
	return 0x820FC2A8;
} // Block from 820FC2A4h-820FC2A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FC2A8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC2A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC2A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC2A8);
		  /* 820FC2A8h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 820FC2A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820FC2A8h case    0:*/		return 0x820FC2AC;
		  /* 820FC2ACh */ case    1:  		/* lis R10, 29568 */
		/* 820FC2ACh case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x7380);
		/* 820FC2ACh case    1:*/		return 0x820FC2B0;
		  /* 820FC2B0h */ case    2:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FC2B0h case    2:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FC2B0h case    2:*/		return 0x820FC2B4;
		  /* 820FC2B4h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820FC2B4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC2B4h case    3:*/		return 0x820FC2B8;
		  /* 820FC2B8h */ case    4:  		/* bc 12, CR6_GT, 208 */
		/* 820FC2B8h case    4:*/		if ( regs.CR[6].gt ) { return 0x820FC388;  }
		/* 820FC2B8h case    4:*/		return 0x820FC2BC;
		  /* 820FC2BCh */ case    5:  		/* bc 12, CR6_EQ, 412 */
		/* 820FC2BCh case    5:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC2BCh case    5:*/		return 0x820FC2C0;
		  /* 820FC2C0h */ case    6:  		/* lis R10, 8336 */
		/* 820FC2C0h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x2090);
		/* 820FC2C0h case    6:*/		return 0x820FC2C4;
		  /* 820FC2C4h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FC2C4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC2C4h case    7:*/		return 0x820FC2C8;
		  /* 820FC2C8h */ case    8:  		/* bc 12, CR6_GT, 100 */
		/* 820FC2C8h case    8:*/		if ( regs.CR[6].gt ) { return 0x820FC32C;  }
		/* 820FC2C8h case    8:*/		return 0x820FC2CC;
		  /* 820FC2CCh */ case    9:  		/* bc 12, CR6_EQ, 396 */
		/* 820FC2CCh case    9:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC2CCh case    9:*/		return 0x820FC2D0;
		  /* 820FC2D0h */ case   10:  		/* lis R10, 4416 */
		/* 820FC2D0h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0x1140);
		/* 820FC2D0h case   10:*/		return 0x820FC2D4;
		  /* 820FC2D4h */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 820FC2D4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC2D4h case   11:*/		return 0x820FC2D8;
		  /* 820FC2D8h */ case   12:  		/* bc 12, CR6_GT, 52 */
		/* 820FC2D8h case   12:*/		if ( regs.CR[6].gt ) { return 0x820FC30C;  }
		/* 820FC2D8h case   12:*/		return 0x820FC2DC;
		  /* 820FC2DCh */ case   13:  		/* bc 12, CR6_EQ, 380 */
		/* 820FC2DCh case   13:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC2DCh case   13:*/		return 0x820FC2E0;
		  /* 820FC2E0h */ case   14:  		/* lis R10, 4336 */
		/* 820FC2E0h case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0x10F0);
		/* 820FC2E0h case   14:*/		return 0x820FC2E4;
		  /* 820FC2E4h */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 820FC2E4h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC2E4h case   15:*/		return 0x820FC2E8;
		  /* 820FC2E8h */ case   16:  		/* bc 12, CR6_EQ, 368 */
		/* 820FC2E8h case   16:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC2E8h case   16:*/		return 0x820FC2EC;
		  /* 820FC2ECh */ case   17:  		/* lis R10, 4368 */
		/* 820FC2ECh case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0x1110);
		/* 820FC2ECh case   17:*/		return 0x820FC2F0;
		  /* 820FC2F0h */ case   18:  		/* cmplw CR6, R11, R10 */
		/* 820FC2F0h case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC2F0h case   18:*/		return 0x820FC2F4;
		  /* 820FC2F4h */ case   19:  		/* bc 12, CR6_EQ, 356 */
		/* 820FC2F4h case   19:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC2F4h case   19:*/		return 0x820FC2F8;
		  /* 820FC2F8h */ case   20:  		/* lis R10, 4384 */
		/* 820FC2F8h case   20:*/		cpu::op::lis<0>(regs,&regs.R10,0x1120);
		/* 820FC2F8h case   20:*/		return 0x820FC2FC;
		  /* 820FC2FCh */ case   21:  		/* cmplw CR6, R11, R10 */
		/* 820FC2FCh case   21:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC2FCh case   21:*/		return 0x820FC300;
		  /* 820FC300h */ case   22:  		/* bc 12, CR6_EQ, 344 */
		/* 820FC300h case   22:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC300h case   22:*/		return 0x820FC304;
		  /* 820FC304h */ case   23:  		/* lis R10, 4400 */
		/* 820FC304h case   23:*/		cpu::op::lis<0>(regs,&regs.R10,0x1130);
		/* 820FC304h case   23:*/		return 0x820FC308;
		  /* 820FC308h */ case   24:  		/* b 324 */
		/* 820FC308h case   24:*/		return 0x820FC44C;
		/* 820FC308h case   24:*/		return 0x820FC30C;
	}
	return 0x820FC30C;
} // Block from 820FC2A8h-820FC30Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 820FC30Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC30C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC30C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC30C);
		  /* 820FC30Ch */ case    0:  		/* lis R10, 4432 */
		/* 820FC30Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x1150);
		/* 820FC30Ch case    0:*/		return 0x820FC310;
		  /* 820FC310h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FC310h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC310h case    1:*/		return 0x820FC314;
		  /* 820FC314h */ case    2:  		/* bc 12, CR6_EQ, 324 */
		/* 820FC314h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC314h case    2:*/		return 0x820FC318;
		  /* 820FC318h */ case    3:  		/* lis R10, 8304 */
		/* 820FC318h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x2070);
		/* 820FC318h case    3:*/		return 0x820FC31C;
		  /* 820FC31Ch */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FC31Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC31Ch case    4:*/		return 0x820FC320;
		  /* 820FC320h */ case    5:  		/* bc 12, CR6_EQ, 312 */
		/* 820FC320h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC320h case    5:*/		return 0x820FC324;
		  /* 820FC324h */ case    6:  		/* lis R10, 8320 */
		/* 820FC324h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x2080);
		/* 820FC324h case    6:*/		return 0x820FC328;
		  /* 820FC328h */ case    7:  		/* b 292 */
		/* 820FC328h case    7:*/		return 0x820FC44C;
		/* 820FC328h case    7:*/		return 0x820FC32C;
	}
	return 0x820FC32C;
} // Block from 820FC30Ch-820FC32Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820FC32Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC32C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC32C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC32C);
		  /* 820FC32Ch */ case    0:  		/* lis R10, 29504 */
		/* 820FC32Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x7340);
		/* 820FC32Ch case    0:*/		return 0x820FC330;
		  /* 820FC330h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FC330h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC330h case    1:*/		return 0x820FC334;
		  /* 820FC334h */ case    2:  		/* bc 12, CR6_GT, 52 */
		/* 820FC334h case    2:*/		if ( regs.CR[6].gt ) { return 0x820FC368;  }
		/* 820FC334h case    2:*/		return 0x820FC338;
		  /* 820FC338h */ case    3:  		/* bc 12, CR6_EQ, 288 */
		/* 820FC338h case    3:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC338h case    3:*/		return 0x820FC33C;
		  /* 820FC33Ch */ case    4:  		/* lis R10, 29440 */
		/* 820FC33Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0x7300);
		/* 820FC33Ch case    4:*/		return 0x820FC340;
		  /* 820FC340h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 820FC340h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC340h case    5:*/		return 0x820FC344;
		  /* 820FC344h */ case    6:  		/* bc 12, CR6_EQ, 276 */
		/* 820FC344h case    6:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC344h case    6:*/		return 0x820FC348;
		  /* 820FC348h */ case    7:  		/* lis R10, 29456 */
		/* 820FC348h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0x7310);
		/* 820FC348h case    7:*/		return 0x820FC34C;
		  /* 820FC34Ch */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 820FC34Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC34Ch case    8:*/		return 0x820FC350;
		  /* 820FC350h */ case    9:  		/* bc 12, CR6_EQ, 264 */
		/* 820FC350h case    9:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC350h case    9:*/		return 0x820FC354;
		  /* 820FC354h */ case   10:  		/* lis R10, 29472 */
		/* 820FC354h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0x7320);
		/* 820FC354h case   10:*/		return 0x820FC358;
		  /* 820FC358h */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 820FC358h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC358h case   11:*/		return 0x820FC35C;
		  /* 820FC35Ch */ case   12:  		/* bc 12, CR6_EQ, 252 */
		/* 820FC35Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC35Ch case   12:*/		return 0x820FC360;
		  /* 820FC360h */ case   13:  		/* lis R10, 29488 */
		/* 820FC360h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0x7330);
		/* 820FC360h case   13:*/		return 0x820FC364;
		  /* 820FC364h */ case   14:  		/* b 232 */
		/* 820FC364h case   14:*/		return 0x820FC44C;
		/* 820FC364h case   14:*/		return 0x820FC368;
	}
	return 0x820FC368;
} // Block from 820FC32Ch-820FC368h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820FC368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC368);
		  /* 820FC368h */ case    0:  		/* lis R10, 29520 */
		/* 820FC368h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x7350);
		/* 820FC368h case    0:*/		return 0x820FC36C;
		  /* 820FC36Ch */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FC36Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC36Ch case    1:*/		return 0x820FC370;
		  /* 820FC370h */ case    2:  		/* bc 12, CR6_EQ, 232 */
		/* 820FC370h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC370h case    2:*/		return 0x820FC374;
		  /* 820FC374h */ case    3:  		/* lis R10, 29536 */
		/* 820FC374h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x7360);
		/* 820FC374h case    3:*/		return 0x820FC378;
		  /* 820FC378h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FC378h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC378h case    4:*/		return 0x820FC37C;
		  /* 820FC37Ch */ case    5:  		/* bc 12, CR6_EQ, 220 */
		/* 820FC37Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC37Ch case    5:*/		return 0x820FC380;
		  /* 820FC380h */ case    6:  		/* lis R10, 29552 */
		/* 820FC380h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x7370);
		/* 820FC380h case    6:*/		return 0x820FC384;
		  /* 820FC384h */ case    7:  		/* b 200 */
		/* 820FC384h case    7:*/		return 0x820FC44C;
		/* 820FC384h case    7:*/		return 0x820FC388;
	}
	return 0x820FC388;
} // Block from 820FC368h-820FC388h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820FC388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC388);
		  /* 820FC388h */ case    0:  		/* lis R10, 29712 */
		/* 820FC388h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x7410);
		/* 820FC388h case    0:*/		return 0x820FC38C;
		  /* 820FC38Ch */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FC38Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC38Ch case    1:*/		return 0x820FC390;
		  /* 820FC390h */ case    2:  		/* bc 12, CR6_GT, 100 */
		/* 820FC390h case    2:*/		if ( regs.CR[6].gt ) { return 0x820FC3F4;  }
		/* 820FC390h case    2:*/		return 0x820FC394;
		  /* 820FC394h */ case    3:  		/* bc 12, CR6_EQ, 196 */
		/* 820FC394h case    3:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC394h case    3:*/		return 0x820FC398;
		  /* 820FC398h */ case    4:  		/* lis R10, 29648 */
		/* 820FC398h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0x73D0);
		/* 820FC398h case    4:*/		return 0x820FC39C;
		  /* 820FC39Ch */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 820FC39Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC39Ch case    5:*/		return 0x820FC3A0;
		  /* 820FC3A0h */ case    6:  		/* bc 12, CR6_GT, 52 */
		/* 820FC3A0h case    6:*/		if ( regs.CR[6].gt ) { return 0x820FC3D4;  }
		/* 820FC3A0h case    6:*/		return 0x820FC3A4;
		  /* 820FC3A4h */ case    7:  		/* bc 12, CR6_EQ, 180 */
		/* 820FC3A4h case    7:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC3A4h case    7:*/		return 0x820FC3A8;
		  /* 820FC3A8h */ case    8:  		/* lis R10, 29584 */
		/* 820FC3A8h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0x7390);
		/* 820FC3A8h case    8:*/		return 0x820FC3AC;
		  /* 820FC3ACh */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 820FC3ACh case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC3ACh case    9:*/		return 0x820FC3B0;
		  /* 820FC3B0h */ case   10:  		/* bc 12, CR6_EQ, 168 */
		/* 820FC3B0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC3B0h case   10:*/		return 0x820FC3B4;
		  /* 820FC3B4h */ case   11:  		/* lis R10, 29600 */
		/* 820FC3B4h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0x73A0);
		/* 820FC3B4h case   11:*/		return 0x820FC3B8;
		  /* 820FC3B8h */ case   12:  		/* cmplw CR6, R11, R10 */
		/* 820FC3B8h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC3B8h case   12:*/		return 0x820FC3BC;
		  /* 820FC3BCh */ case   13:  		/* bc 12, CR6_EQ, 156 */
		/* 820FC3BCh case   13:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC3BCh case   13:*/		return 0x820FC3C0;
		  /* 820FC3C0h */ case   14:  		/* lis R10, 29616 */
		/* 820FC3C0h case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0x73B0);
		/* 820FC3C0h case   14:*/		return 0x820FC3C4;
		  /* 820FC3C4h */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 820FC3C4h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC3C4h case   15:*/		return 0x820FC3C8;
		  /* 820FC3C8h */ case   16:  		/* bc 12, CR6_EQ, 144 */
		/* 820FC3C8h case   16:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC3C8h case   16:*/		return 0x820FC3CC;
		  /* 820FC3CCh */ case   17:  		/* lis R10, 29632 */
		/* 820FC3CCh case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0x73C0);
		/* 820FC3CCh case   17:*/		return 0x820FC3D0;
		  /* 820FC3D0h */ case   18:  		/* b 124 */
		/* 820FC3D0h case   18:*/		return 0x820FC44C;
		/* 820FC3D0h case   18:*/		return 0x820FC3D4;
	}
	return 0x820FC3D4;
} // Block from 820FC388h-820FC3D4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820FC3D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC3D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC3D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC3D4);
		  /* 820FC3D4h */ case    0:  		/* lis R10, 29664 */
		/* 820FC3D4h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x73E0);
		/* 820FC3D4h case    0:*/		return 0x820FC3D8;
		  /* 820FC3D8h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FC3D8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC3D8h case    1:*/		return 0x820FC3DC;
		  /* 820FC3DCh */ case    2:  		/* bc 12, CR6_EQ, 124 */
		/* 820FC3DCh case    2:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC3DCh case    2:*/		return 0x820FC3E0;
		  /* 820FC3E0h */ case    3:  		/* lis R10, 29680 */
		/* 820FC3E0h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x73F0);
		/* 820FC3E0h case    3:*/		return 0x820FC3E4;
		  /* 820FC3E4h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FC3E4h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC3E4h case    4:*/		return 0x820FC3E8;
		  /* 820FC3E8h */ case    5:  		/* bc 12, CR6_EQ, 112 */
		/* 820FC3E8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC3E8h case    5:*/		return 0x820FC3EC;
		  /* 820FC3ECh */ case    6:  		/* lis R10, 29696 */
		/* 820FC3ECh case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x7400);
		/* 820FC3ECh case    6:*/		return 0x820FC3F0;
	}
	return 0x820FC3F0;
} // Block from 820FC3D4h-820FC3F0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820FC3F0h
// Function '?EmitDCL@C30Program@D3DXShader@@MAAJPAVCArgument@2@PAK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC3F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC3F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC3F0);
		  /* 820FC3F0h */ case    0:  		/* b 92 */
		/* 820FC3F0h case    0:*/		return 0x820FC44C;
		/* 820FC3F0h case    0:*/		return 0x820FC3F4;
	}
	return 0x820FC3F4;
} // Block from 820FC3F0h-820FC3F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FC3F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC3F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC3F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC3F4);
		  /* 820FC3F4h */ case    0:  		/* lis R10, 29792 */
		/* 820FC3F4h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x7460);
		/* 820FC3F4h case    0:*/		return 0x820FC3F8;
		  /* 820FC3F8h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FC3F8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC3F8h case    1:*/		return 0x820FC3FC;
		  /* 820FC3FCh */ case    2:  		/* bc 12, CR6_GT, 52 */
		/* 820FC3FCh case    2:*/		if ( regs.CR[6].gt ) { return 0x820FC430;  }
		/* 820FC3FCh case    2:*/		return 0x820FC400;
		  /* 820FC400h */ case    3:  		/* bc 12, CR6_EQ, 88 */
		/* 820FC400h case    3:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC400h case    3:*/		return 0x820FC404;
		  /* 820FC404h */ case    4:  		/* lis R10, 29728 */
		/* 820FC404h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0x7420);
		/* 820FC404h case    4:*/		return 0x820FC408;
		  /* 820FC408h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 820FC408h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC408h case    5:*/		return 0x820FC40C;
		  /* 820FC40Ch */ case    6:  		/* bc 12, CR6_EQ, 76 */
		/* 820FC40Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC40Ch case    6:*/		return 0x820FC410;
		  /* 820FC410h */ case    7:  		/* lis R10, 29744 */
		/* 820FC410h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0x7430);
		/* 820FC410h case    7:*/		return 0x820FC414;
		  /* 820FC414h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 820FC414h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC414h case    8:*/		return 0x820FC418;
		  /* 820FC418h */ case    9:  		/* bc 12, CR6_EQ, 64 */
		/* 820FC418h case    9:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC418h case    9:*/		return 0x820FC41C;
		  /* 820FC41Ch */ case   10:  		/* lis R10, 29760 */
		/* 820FC41Ch case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0x7440);
		/* 820FC41Ch case   10:*/		return 0x820FC420;
		  /* 820FC420h */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 820FC420h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC420h case   11:*/		return 0x820FC424;
		  /* 820FC424h */ case   12:  		/* bc 12, CR6_EQ, 52 */
		/* 820FC424h case   12:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC424h case   12:*/		return 0x820FC428;
		  /* 820FC428h */ case   13:  		/* lis R10, 29776 */
		/* 820FC428h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0x7450);
		/* 820FC428h case   13:*/		return 0x820FC42C;
		  /* 820FC42Ch */ case   14:  		/* b 32 */
		/* 820FC42Ch case   14:*/		return 0x820FC44C;
		/* 820FC42Ch case   14:*/		return 0x820FC430;
	}
	return 0x820FC430;
} // Block from 820FC3F4h-820FC430h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820FC430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC430);
		  /* 820FC430h */ case    0:  		/* lis R10, 29808 */
		/* 820FC430h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x7470);
		/* 820FC430h case    0:*/		return 0x820FC434;
		  /* 820FC434h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FC434h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC434h case    1:*/		return 0x820FC438;
		  /* 820FC438h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 820FC438h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC438h case    2:*/		return 0x820FC43C;
		  /* 820FC43Ch */ case    3:  		/* lis R10, 29856 */
		/* 820FC43Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x74A0);
		/* 820FC43Ch case    3:*/		return 0x820FC440;
		  /* 820FC440h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FC440h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC440h case    4:*/		return 0x820FC444;
		  /* 820FC444h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 820FC444h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FC458;  }
		/* 820FC444h case    5:*/		return 0x820FC448;
		  /* 820FC448h */ case    6:  		/* lis R10, 29872 */
		/* 820FC448h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x74B0);
		/* 820FC448h case    6:*/		return 0x820FC44C;
	}
	return 0x820FC44C;
} // Block from 820FC430h-820FC44Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820FC44Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC44C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC44C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC44C);
		  /* 820FC44Ch */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 820FC44Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC44Ch case    0:*/		return 0x820FC450;
		  /* 820FC450h */ case    1:  		/* li R3, 0 */
		/* 820FC450h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FC450h case    1:*/		return 0x820FC454;
		  /* 820FC454h */ case    2:  		/* bclr 4, CR6_EQ */
		/* 820FC454h case    2:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820FC454h case    2:*/		return 0x820FC458;
	}
	return 0x820FC458;
} // Block from 820FC44Ch-820FC458h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FC458h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC458);
		  /* 820FC458h */ case    0:  		/* li R3, 1 */
		/* 820FC458h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FC458h case    0:*/		return 0x820FC45C;
		  /* 820FC45Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 820FC45Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FC45Ch case    1:*/		return 0x820FC460;
	}
	return 0x820FC460;
} // Block from 820FC458h-820FC460h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FC460h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC460);
		  /* 820FC460h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 820FC460h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820FC460h case    0:*/		return 0x820FC464;
		  /* 820FC464h */ case    1:  		/* lis R10, 24704 */
		/* 820FC464h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x6080);
		/* 820FC464h case    1:*/		return 0x820FC468;
		  /* 820FC468h */ case    2:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FC468h case    2:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FC468h case    2:*/		return 0x820FC46C;
		  /* 820FC46Ch */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820FC46Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC46Ch case    3:*/		return 0x820FC470;
		  /* 820FC470h */ case    4:  		/* bc 12, CR6_GT, 88 */
		/* 820FC470h case    4:*/		if ( regs.CR[6].gt ) { return 0x820FC4C8;  }
		/* 820FC470h case    4:*/		return 0x820FC474;
		  /* 820FC474h */ case    5:  		/* bc 12, CR6_EQ, 160 */
		/* 820FC474h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FC514;  }
		/* 820FC474h case    5:*/		return 0x820FC478;
		  /* 820FC478h */ case    6:  		/* lis R10, 4304 */
		/* 820FC478h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x10D0);
		/* 820FC478h case    6:*/		return 0x820FC47C;
		  /* 820FC47Ch */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FC47Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC47Ch case    7:*/		return 0x820FC480;
		  /* 820FC480h */ case    8:  		/* bc 12, CR6_EQ, 148 */
		/* 820FC480h case    8:*/		if ( regs.CR[6].eq ) { return 0x820FC514;  }
		/* 820FC480h case    8:*/		return 0x820FC484;
		  /* 820FC484h */ case    9:  		/* lis R10, 4320 */
		/* 820FC484h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x10E0);
		/* 820FC484h case    9:*/		return 0x820FC488;
		  /* 820FC488h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820FC488h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC488h case   10:*/		return 0x820FC48C;
		  /* 820FC48Ch */ case   11:  		/* bc 12, CR6_EQ, 136 */
		/* 820FC48Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820FC514;  }
		/* 820FC48Ch case   11:*/		return 0x820FC490;
		  /* 820FC490h */ case   12:  		/* lis R10, 24576 */
		/* 820FC490h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0x6000);
		/* 820FC490h case   12:*/		return 0x820FC494;
		  /* 820FC494h */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 820FC494h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC494h case   13:*/		return 0x820FC498;
		  /* 820FC498h */ case   14:  		/* bc 12, CR6_EQ, 124 */
		/* 820FC498h case   14:*/		if ( regs.CR[6].eq ) { return 0x820FC514;  }
		/* 820FC498h case   14:*/		return 0x820FC49C;
		  /* 820FC49Ch */ case   15:  		/* lis R10, 24608 */
		/* 820FC49Ch case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0x6020);
		/* 820FC49Ch case   15:*/		return 0x820FC4A0;
		  /* 820FC4A0h */ case   16:  		/* cmplw CR6, R11, R10 */
		/* 820FC4A0h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC4A0h case   16:*/		return 0x820FC4A4;
		  /* 820FC4A4h */ case   17:  		/* bc 12, CR6_EQ, 112 */
		/* 820FC4A4h case   17:*/		if ( regs.CR[6].eq ) { return 0x820FC514;  }
		/* 820FC4A4h case   17:*/		return 0x820FC4A8;
		  /* 820FC4A8h */ case   18:  		/* lis R10, 24624 */
		/* 820FC4A8h case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0x6030);
		/* 820FC4A8h case   18:*/		return 0x820FC4AC;
		  /* 820FC4ACh */ case   19:  		/* cmplw CR6, R11, R10 */
		/* 820FC4ACh case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC4ACh case   19:*/		return 0x820FC4B0;
		  /* 820FC4B0h */ case   20:  		/* bc 12, CR6_EQ, 100 */
		/* 820FC4B0h case   20:*/		if ( regs.CR[6].eq ) { return 0x820FC514;  }
		/* 820FC4B0h case   20:*/		return 0x820FC4B4;
		  /* 820FC4B4h */ case   21:  		/* lis R10, 24656 */
		/* 820FC4B4h case   21:*/		cpu::op::lis<0>(regs,&regs.R10,0x6050);
		/* 820FC4B4h case   21:*/		return 0x820FC4B8;
		  /* 820FC4B8h */ case   22:  		/* cmplw CR6, R11, R10 */
		/* 820FC4B8h case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC4B8h case   22:*/		return 0x820FC4BC;
		  /* 820FC4BCh */ case   23:  		/* bc 12, CR6_EQ, 88 */
		/* 820FC4BCh case   23:*/		if ( regs.CR[6].eq ) { return 0x820FC514;  }
		/* 820FC4BCh case   23:*/		return 0x820FC4C0;
		  /* 820FC4C0h */ case   24:  		/* lis R10, 24688 */
		/* 820FC4C0h case   24:*/		cpu::op::lis<0>(regs,&regs.R10,0x6070);
		/* 820FC4C0h case   24:*/		return 0x820FC4C4;
		  /* 820FC4C4h */ case   25:  		/* b 68 */
		/* 820FC4C4h case   25:*/		return 0x820FC508;
		/* 820FC4C4h case   25:*/		return 0x820FC4C8;
	}
	return 0x820FC4C8;
} // Block from 820FC460h-820FC4C8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820FC4C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC4C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC4C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC4C8);
		  /* 820FC4C8h */ case    0:  		/* lis R10, 24736 */
		/* 820FC4C8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x60A0);
		/* 820FC4C8h case    0:*/		return 0x820FC4CC;
		  /* 820FC4CCh */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FC4CCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC4CCh case    1:*/		return 0x820FC4D0;
		  /* 820FC4D0h */ case    2:  		/* bc 12, CR6_EQ, 68 */
		/* 820FC4D0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FC514;  }
		/* 820FC4D0h case    2:*/		return 0x820FC4D4;
		  /* 820FC4D4h */ case    3:  		/* lis R10, 24768 */
		/* 820FC4D4h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x60C0);
		/* 820FC4D4h case    3:*/		return 0x820FC4D8;
		  /* 820FC4D8h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FC4D8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC4D8h case    4:*/		return 0x820FC4DC;
		  /* 820FC4DCh */ case    5:  		/* bc 12, CR6_EQ, 56 */
		/* 820FC4DCh case    5:*/		if ( regs.CR[6].eq ) { return 0x820FC514;  }
		/* 820FC4DCh case    5:*/		return 0x820FC4E0;
		  /* 820FC4E0h */ case    6:  		/* lis R10, 24784 */
		/* 820FC4E0h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x60D0);
		/* 820FC4E0h case    6:*/		return 0x820FC4E4;
		  /* 820FC4E4h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FC4E4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC4E4h case    7:*/		return 0x820FC4E8;
		  /* 820FC4E8h */ case    8:  		/* bc 12, CR6_EQ, 44 */
		/* 820FC4E8h case    8:*/		if ( regs.CR[6].eq ) { return 0x820FC514;  }
		/* 820FC4E8h case    8:*/		return 0x820FC4EC;
		  /* 820FC4ECh */ case    9:  		/* lis R10, 24816 */
		/* 820FC4ECh case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x60F0);
		/* 820FC4ECh case    9:*/		return 0x820FC4F0;
		  /* 820FC4F0h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820FC4F0h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC4F0h case   10:*/		return 0x820FC4F4;
		  /* 820FC4F4h */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 820FC4F4h case   11:*/		if ( regs.CR[6].eq ) { return 0x820FC514;  }
		/* 820FC4F4h case   11:*/		return 0x820FC4F8;
		  /* 820FC4F8h */ case   12:  		/* lis R10, 24848 */
		/* 820FC4F8h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0x6110);
		/* 820FC4F8h case   12:*/		return 0x820FC4FC;
		  /* 820FC4FCh */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 820FC4FCh case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC4FCh case   13:*/		return 0x820FC500;
		  /* 820FC500h */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 820FC500h case   14:*/		if ( regs.CR[6].eq ) { return 0x820FC514;  }
		/* 820FC500h case   14:*/		return 0x820FC504;
		  /* 820FC504h */ case   15:  		/* lis R10, 24864 */
		/* 820FC504h case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0x6120);
		/* 820FC504h case   15:*/		return 0x820FC508;
	}
	return 0x820FC508;
} // Block from 820FC4C8h-820FC508h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820FC508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC508);
		  /* 820FC508h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 820FC508h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC508h case    0:*/		return 0x820FC50C;
		  /* 820FC50Ch */ case    1:  		/* li R3, 0 */
		/* 820FC50Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FC50Ch case    1:*/		return 0x820FC510;
		  /* 820FC510h */ case    2:  		/* bclr 4, CR6_EQ */
		/* 820FC510h case    2:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820FC510h case    2:*/		return 0x820FC514;
	}
	return 0x820FC514;
} // Block from 820FC508h-820FC514h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FC514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC514);
		  /* 820FC514h */ case    0:  		/* li R3, 1 */
		/* 820FC514h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FC514h case    0:*/		return 0x820FC518;
		  /* 820FC518h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820FC518h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FC518h case    1:*/		return 0x820FC51C;
	}
	return 0x820FC51C;
} // Block from 820FC514h-820FC51Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FC51Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC51C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC51C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC51C);
		  /* 820FC51Ch */ case    0:  		/* nop */
		/* 820FC51Ch case    0:*/		cpu::op::nop();
		/* 820FC51Ch case    0:*/		return 0x820FC520;
	}
	return 0x820FC520;
} // Block from 820FC51Ch-820FC520h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FC520h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC520);
		  /* 820FC520h */ case    0:  		/* mfspr R12, LR */
		/* 820FC520h case    0:*/		regs.R12 = regs.LR;
		/* 820FC520h case    0:*/		return 0x820FC524;
		  /* 820FC524h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820FC524h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FC524h case    1:*/		return 0x820FC528;
		  /* 820FC528h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820FC528h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FC528h case    2:*/		return 0x820FC52C;
		  /* 820FC52Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820FC52Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820FC52Ch case    3:*/		return 0x820FC530;
		  /* 820FC530h */ case    4:  		/* mr R31, R3 */
		/* 820FC530h case    4:*/		regs.R31 = regs.R3;
		/* 820FC530h case    4:*/		return 0x820FC534;
		  /* 820FC534h */ case    5:  		/* bl -193796 */
		/* 820FC534h case    5:*/		regs.LR = 0x820FC538; return 0x820CD030;
		/* 820FC534h case    5:*/		return 0x820FC538;
		  /* 820FC538h */ case    6:  		/* li R11, 0 */
		/* 820FC538h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820FC538h case    6:*/		return 0x820FC53C;
		  /* 820FC53Ch */ case    7:  		/* stw R31, <#[R3 + 16]> */
		/* 820FC53Ch case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000010) );
		/* 820FC53Ch case    7:*/		return 0x820FC540;
		  /* 820FC540h */ case    8:  		/* stw R11, <#[R3 + 12]> */
		/* 820FC540h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820FC540h case    8:*/		return 0x820FC544;
		  /* 820FC544h */ case    9:  		/* addi R1, R1, 96 */
		/* 820FC544h case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820FC544h case    9:*/		return 0x820FC548;
		  /* 820FC548h */ case   10:  		/* lwz R12, <#[R1 - 8]> */
		/* 820FC548h case   10:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FC548h case   10:*/		return 0x820FC54C;
		  /* 820FC54Ch */ case   11:  		/* mtspr LR, R12 */
		/* 820FC54Ch case   11:*/		regs.LR = regs.R12;
		/* 820FC54Ch case   11:*/		return 0x820FC550;
		  /* 820FC550h */ case   12:  		/* ld R31, <#[R1 - 16]> */
		/* 820FC550h case   12:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FC550h case   12:*/		return 0x820FC554;
		  /* 820FC554h */ case   13:  		/* bclr 20, CR0_LT */
		/* 820FC554h case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FC554h case   13:*/		return 0x820FC558;
	}
	return 0x820FC558;
} // Block from 820FC520h-820FC558h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820FC558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC558);
		  /* 820FC558h */ case    0:  		/* mfspr R12, LR */
		/* 820FC558h case    0:*/		regs.R12 = regs.LR;
		/* 820FC558h case    0:*/		return 0x820FC55C;
		  /* 820FC55Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820FC55Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FC55Ch case    1:*/		return 0x820FC560;
		  /* 820FC560h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820FC560h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FC560h case    2:*/		return 0x820FC564;
		  /* 820FC564h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820FC564h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820FC564h case    3:*/		return 0x820FC568;
		  /* 820FC568h */ case    4:  		/* mr R31, R3 */
		/* 820FC568h case    4:*/		regs.R31 = regs.R3;
		/* 820FC568h case    4:*/		return 0x820FC56C;
		  /* 820FC56Ch */ case    5:  		/* bl -193852 */
		/* 820FC56Ch case    5:*/		regs.LR = 0x820FC570; return 0x820CD030;
		/* 820FC56Ch case    5:*/		return 0x820FC570;
		  /* 820FC570h */ case    6:  		/* li R5, 16 */
		/* 820FC570h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820FC570h case    6:*/		return 0x820FC574;
		  /* 820FC574h */ case    7:  		/* lwz R3, <#[R3 + 16]> */
		/* 820FC574h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000010) );
		/* 820FC574h case    7:*/		return 0x820FC578;
		  /* 820FC578h */ case    8:  		/* rlwinm R4, R31, 2, 0, 29 */
		/* 820FC578h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R31);
		/* 820FC578h case    8:*/		return 0x820FC57C;
		  /* 820FC57Ch */ case    9:  		/* bl -210076 */
		/* 820FC57Ch case    9:*/		regs.LR = 0x820FC580; return 0x820C90E0;
		/* 820FC57Ch case    9:*/		return 0x820FC580;
		  /* 820FC580h */ case   10:  		/* addi R1, R1, 96 */
		/* 820FC580h case   10:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820FC580h case   10:*/		return 0x820FC584;
		  /* 820FC584h */ case   11:  		/* lwz R12, <#[R1 - 8]> */
		/* 820FC584h case   11:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FC584h case   11:*/		return 0x820FC588;
		  /* 820FC588h */ case   12:  		/* mtspr LR, R12 */
		/* 820FC588h case   12:*/		regs.LR = regs.R12;
		/* 820FC588h case   12:*/		return 0x820FC58C;
		  /* 820FC58Ch */ case   13:  		/* ld R31, <#[R1 - 16]> */
		/* 820FC58Ch case   13:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FC58Ch case   13:*/		return 0x820FC590;
		  /* 820FC590h */ case   14:  		/* bclr 20, CR0_LT */
		/* 820FC590h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FC590h case   14:*/		return 0x820FC594;
	}
	return 0x820FC594;
} // Block from 820FC558h-820FC594h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820FC594h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC594( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC594) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC594);
		  /* 820FC594h */ case    0:  		/* nop */
		/* 820FC594h case    0:*/		cpu::op::nop();
		/* 820FC594h case    0:*/		return 0x820FC598;
	}
	return 0x820FC598;
} // Block from 820FC594h-820FC598h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FC598h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC598);
		  /* 820FC598h */ case    0:  		/* mfspr R12, LR */
		/* 820FC598h case    0:*/		regs.R12 = regs.LR;
		/* 820FC598h case    0:*/		return 0x820FC59C;
		  /* 820FC59Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820FC59Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FC59Ch case    1:*/		return 0x820FC5A0;
		  /* 820FC5A0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820FC5A0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FC5A0h case    2:*/		return 0x820FC5A4;
		  /* 820FC5A4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820FC5A4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820FC5A4h case    3:*/		return 0x820FC5A8;
		  /* 820FC5A8h */ case    4:  		/* mr R31, R3 */
		/* 820FC5A8h case    4:*/		regs.R31 = regs.R3;
		/* 820FC5A8h case    4:*/		return 0x820FC5AC;
		  /* 820FC5ACh */ case    5:  		/* bl -193916 */
		/* 820FC5ACh case    5:*/		regs.LR = 0x820FC5B0; return 0x820CD030;
		/* 820FC5ACh case    5:*/		return 0x820FC5B0;
		  /* 820FC5B0h */ case    6:  		/* mr R11, R3 */
		/* 820FC5B0h case    6:*/		regs.R11 = regs.R3;
		/* 820FC5B0h case    6:*/		return 0x820FC5B4;
		  /* 820FC5B4h */ case    7:  		/* lwz R3, <#[R3 + 12]> */
		/* 820FC5B4h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000000C) );
		/* 820FC5B4h case    7:*/		return 0x820FC5B8;
		  /* 820FC5B8h */ case    8:  		/* cmplwi CR6, R3, 0 */
		/* 820FC5B8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820FC5B8h case    8:*/		return 0x820FC5BC;
		  /* 820FC5BCh */ case    9:  		/* bc 12, CR6_EQ, 16 */
		/* 820FC5BCh case    9:*/		if ( regs.CR[6].eq ) { return 0x820FC5CC;  }
		/* 820FC5BCh case    9:*/		return 0x820FC5C0;
		  /* 820FC5C0h */ case   10:  		/* lwz R10, <#[R3 + 112]> */
		/* 820FC5C0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000070) );
		/* 820FC5C0h case   10:*/		return 0x820FC5C4;
		  /* 820FC5C4h */ case   11:  		/* stw R10, <#[R11 + 12]> */
		/* 820FC5C4h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820FC5C4h case   11:*/		return 0x820FC5C8;
		  /* 820FC5C8h */ case   12:  		/* b 20 */
		/* 820FC5C8h case   12:*/		return 0x820FC5DC;
		/* 820FC5C8h case   12:*/		return 0x820FC5CC;
	}
	return 0x820FC5CC;
} // Block from 820FC598h-820FC5CCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FC5CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC5CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC5CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC5CC);
		  /* 820FC5CCh */ case    0:  		/* li R5, 16 */
		/* 820FC5CCh case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820FC5CCh case    0:*/		return 0x820FC5D0;
		  /* 820FC5D0h */ case    1:  		/* lwz R3, <#[R11 + 16]> */
		/* 820FC5D0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000010) );
		/* 820FC5D0h case    1:*/		return 0x820FC5D4;
		  /* 820FC5D4h */ case    2:  		/* mr R4, R31 */
		/* 820FC5D4h case    2:*/		regs.R4 = regs.R31;
		/* 820FC5D4h case    2:*/		return 0x820FC5D8;
		  /* 820FC5D8h */ case    3:  		/* bl -210168 */
		/* 820FC5D8h case    3:*/		regs.LR = 0x820FC5DC; return 0x820C90E0;
		/* 820FC5D8h case    3:*/		return 0x820FC5DC;
	}
	return 0x820FC5DC;
} // Block from 820FC5CCh-820FC5DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FC5DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC5DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC5DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC5DC);
		  /* 820FC5DCh */ case    0:  		/* addi R1, R1, 96 */
		/* 820FC5DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820FC5DCh case    0:*/		return 0x820FC5E0;
		  /* 820FC5E0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820FC5E0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FC5E0h case    1:*/		return 0x820FC5E4;
		  /* 820FC5E4h */ case    2:  		/* mtspr LR, R12 */
		/* 820FC5E4h case    2:*/		regs.LR = regs.R12;
		/* 820FC5E4h case    2:*/		return 0x820FC5E8;
		  /* 820FC5E8h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820FC5E8h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FC5E8h case    3:*/		return 0x820FC5EC;
		  /* 820FC5ECh */ case    4:  		/* bclr 20, CR0_LT */
		/* 820FC5ECh case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FC5ECh case    4:*/		return 0x820FC5F0;
	}
	return 0x820FC5F0;
} // Block from 820FC5DCh-820FC5F0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FC5F0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC5F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC5F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC5F0);
		  /* 820FC5F0h */ case    0:  		/* mfspr R12, LR */
		/* 820FC5F0h case    0:*/		regs.R12 = regs.LR;
		/* 820FC5F0h case    0:*/		return 0x820FC5F4;
		  /* 820FC5F4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820FC5F4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FC5F4h case    1:*/		return 0x820FC5F8;
		  /* 820FC5F8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820FC5F8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FC5F8h case    2:*/		return 0x820FC5FC;
		  /* 820FC5FCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820FC5FCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820FC5FCh case    3:*/		return 0x820FC600;
		  /* 820FC600h */ case    4:  		/* mr R31, R3 */
		/* 820FC600h case    4:*/		regs.R31 = regs.R3;
		/* 820FC600h case    4:*/		return 0x820FC604;
		  /* 820FC604h */ case    5:  		/* cmplwi CR6, R3, 0 */
		/* 820FC604h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820FC604h case    5:*/		return 0x820FC608;
		  /* 820FC608h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 820FC608h case    6:*/		if ( regs.CR[6].eq ) { return 0x820FC61C;  }
		/* 820FC608h case    6:*/		return 0x820FC60C;
		  /* 820FC60Ch */ case    7:  		/* bl -194012 */
		/* 820FC60Ch case    7:*/		regs.LR = 0x820FC610; return 0x820CD030;
		/* 820FC60Ch case    7:*/		return 0x820FC610;
		  /* 820FC610h */ case    8:  		/* lwz R11, <#[R3 + 12]> */
		/* 820FC610h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820FC610h case    8:*/		return 0x820FC614;
		  /* 820FC614h */ case    9:  		/* stw R11, <#[R31 + 112]> */
		/* 820FC614h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820FC614h case    9:*/		return 0x820FC618;
		  /* 820FC618h */ case   10:  		/* stw R31, <#[R3 + 12]> */
		/* 820FC618h case   10:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x0000000C) );
		/* 820FC618h case   10:*/		return 0x820FC61C;
	}
	return 0x820FC61C;
} // Block from 820FC5F0h-820FC61Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FC61Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC61C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC61C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC61C);
		  /* 820FC61Ch */ case    0:  		/* addi R1, R1, 96 */
		/* 820FC61Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820FC61Ch case    0:*/		return 0x820FC620;
		  /* 820FC620h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820FC620h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FC620h case    1:*/		return 0x820FC624;
		  /* 820FC624h */ case    2:  		/* mtspr LR, R12 */
		/* 820FC624h case    2:*/		regs.LR = regs.R12;
		/* 820FC624h case    2:*/		return 0x820FC628;
		  /* 820FC628h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820FC628h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FC628h case    3:*/		return 0x820FC62C;
		  /* 820FC62Ch */ case    4:  		/* bclr 20, CR0_LT */
		/* 820FC62Ch case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FC62Ch case    4:*/		return 0x820FC630;
	}
	return 0x820FC630;
} // Block from 820FC61Ch-820FC630h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FC630h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC630);
		  /* 820FC630h */ case    0:  		/* mfspr R12, LR */
		/* 820FC630h case    0:*/		regs.R12 = regs.LR;
		/* 820FC630h case    0:*/		return 0x820FC634;
		  /* 820FC634h */ case    1:  		/* bl -439256 */
		/* 820FC634h case    1:*/		regs.LR = 0x820FC638; return 0x8209125C;
		/* 820FC634h case    1:*/		return 0x820FC638;
		  /* 820FC638h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820FC638h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820FC638h case    2:*/		return 0x820FC63C;
		  /* 820FC63Ch */ case    3:  		/* mr R30, R3 */
		/* 820FC63Ch case    3:*/		regs.R30 = regs.R3;
		/* 820FC63Ch case    3:*/		return 0x820FC640;
		  /* 820FC640h */ case    4:  		/* stw R4, <#[R3]> */
		/* 820FC640h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000000) );
		/* 820FC640h case    4:*/		return 0x820FC644;
		  /* 820FC644h */ case    5:  		/* li R29, 0 */
		/* 820FC644h case    5:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820FC644h case    5:*/		return 0x820FC648;
		  /* 820FC648h */ case    6:  		/* stw R5, <#[R3 + 4]> */
		/* 820FC648h case    6:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000004) );
		/* 820FC648h case    6:*/		return 0x820FC64C;
		  /* 820FC64Ch */ case    7:  		/* rlwinm R11, R4, 0, 12, 31 */
		/* 820FC64Ch case    7:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R4);
		/* 820FC64Ch case    7:*/		return 0x820FC650;
		  /* 820FC650h */ case    8:  		/* stw R6, <#[R3 + 12]> */
		/* 820FC650h case    8:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x0000000C) );
		/* 820FC650h case    8:*/		return 0x820FC654;
		  /* 820FC654h */ case    9:  		/* cmpwi CR6, R7, 0 */
		/* 820FC654h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 820FC654h case    9:*/		return 0x820FC658;
		  /* 820FC658h */ case   10:  		/* bc 4, CR6_EQ, 564 */
		/* 820FC658h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820FC88C;  }
		/* 820FC658h case   10:*/		return 0x820FC65C;
		  /* 820FC65Ch */ case   11:  		/* rlwinm. R10, R4, 0, 0, 3 */
		/* 820FC65Ch case   11:*/		cpu::op::rlwinm<1,0,0,3>(regs,&regs.R10,regs.R4);
		/* 820FC65Ch case   11:*/		return 0x820FC660;
		  /* 820FC660h */ case   12:  		/* bc 12, CR0_EQ, 464 */
		/* 820FC660h case   12:*/		if ( regs.CR[0].eq ) { return 0x820FC830;  }
		/* 820FC660h case   12:*/		return 0x820FC664;
		  /* 820FC664h */ case   13:  		/* lis R9, 4096 */
		/* 820FC664h case   13:*/		cpu::op::lis<0>(regs,&regs.R9,0x1000);
		/* 820FC664h case   13:*/		return 0x820FC668;
		  /* 820FC668h */ case   14:  		/* cmplw CR6, R10, R9 */
		/* 820FC668h case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820FC668h case   14:*/		return 0x820FC66C;
		  /* 820FC66Ch */ case   15:  		/* bc 12, CR6_EQ, 388 */
		/* 820FC66Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x820FC7F0;  }
		/* 820FC66Ch case   15:*/		return 0x820FC670;
		  /* 820FC670h */ case   16:  		/* lis R9, 8192 */
		/* 820FC670h case   16:*/		cpu::op::lis<0>(regs,&regs.R9,0x2000);
		/* 820FC670h case   16:*/		return 0x820FC674;
		  /* 820FC674h */ case   17:  		/* cmplw CR6, R10, R9 */
		/* 820FC674h case   17:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820FC674h case   17:*/		return 0x820FC678;
		  /* 820FC678h */ case   18:  		/* bc 12, CR6_EQ, 432 */
		/* 820FC678h case   18:*/		if ( regs.CR[6].eq ) { return 0x820FC828;  }
		/* 820FC678h case   18:*/		return 0x820FC67C;
		  /* 820FC67Ch */ case   19:  		/* lis R9, 12288 */
		/* 820FC67Ch case   19:*/		cpu::op::lis<0>(regs,&regs.R9,0x3000);
		/* 820FC67Ch case   19:*/		return 0x820FC680;
		  /* 820FC680h */ case   20:  		/* cmplw CR6, R10, R9 */
		/* 820FC680h case   20:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820FC680h case   20:*/		return 0x820FC684;
		  /* 820FC684h */ case   21:  		/* bc 12, CR6_EQ, 412 */
		/* 820FC684h case   21:*/		if ( regs.CR[6].eq ) { return 0x820FC820;  }
		/* 820FC684h case   21:*/		return 0x820FC688;
		  /* 820FC688h */ case   22:  		/* lis R9, 16384 */
		/* 820FC688h case   22:*/		cpu::op::lis<0>(regs,&regs.R9,0x4000);
		/* 820FC688h case   22:*/		return 0x820FC68C;
		  /* 820FC68Ch */ case   23:  		/* cmplw CR6, R10, R9 */
		/* 820FC68Ch case   23:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820FC68Ch case   23:*/		return 0x820FC690;
		  /* 820FC690h */ case   24:  		/* bc 12, CR6_EQ, 392 */
		/* 820FC690h case   24:*/		if ( regs.CR[6].eq ) { return 0x820FC818;  }
		/* 820FC690h case   24:*/		return 0x820FC694;
		  /* 820FC694h */ case   25:  		/* lis R9, 20480 */
		/* 820FC694h case   25:*/		cpu::op::lis<0>(regs,&regs.R9,0x5000);
		/* 820FC694h case   25:*/		return 0x820FC698;
		  /* 820FC698h */ case   26:  		/* cmplw CR6, R10, R9 */
		/* 820FC698h case   26:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820FC698h case   26:*/		return 0x820FC69C;
		  /* 820FC69Ch */ case   27:  		/* bc 12, CR6_EQ, 292 */
		/* 820FC69Ch case   27:*/		if ( regs.CR[6].eq ) { return 0x820FC7C0;  }
		/* 820FC69Ch case   27:*/		return 0x820FC6A0;
		  /* 820FC6A0h */ case   28:  		/* lis R9, 24576 */
		/* 820FC6A0h case   28:*/		cpu::op::lis<0>(regs,&regs.R9,0x6000);
		/* 820FC6A0h case   28:*/		return 0x820FC6A4;
		  /* 820FC6A4h */ case   29:  		/* cmplw CR6, R10, R9 */
		/* 820FC6A4h case   29:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820FC6A4h case   29:*/		return 0x820FC6A8;
		  /* 820FC6A8h */ case   30:  		/* bc 4, CR6_EQ, 400 */
		/* 820FC6A8h case   30:*/		if ( !regs.CR[6].eq ) { return 0x820FC838;  }
		/* 820FC6A8h case   30:*/		return 0x820FC6AC;
		  /* 820FC6ACh */ case   31:  		/* lis R10, 24736 */
		/* 820FC6ACh case   31:*/		cpu::op::lis<0>(regs,&regs.R10,0x60A0);
		/* 820FC6ACh case   31:*/		return 0x820FC6B0;
		  /* 820FC6B0h */ case   32:  		/* rlwinm R11, R4, 0, 0, 11 */
		/* 820FC6B0h case   32:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R4);
		/* 820FC6B0h case   32:*/		return 0x820FC6B4;
		  /* 820FC6B4h */ case   33:  		/* cmplw CR6, R11, R10 */
		/* 820FC6B4h case   33:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC6B4h case   33:*/		return 0x820FC6B8;
		  /* 820FC6B8h */ case   34:  		/* bc 12, CR6_GT, 148 */
		/* 820FC6B8h case   34:*/		if ( regs.CR[6].gt ) { return 0x820FC74C;  }
		/* 820FC6B8h case   34:*/		return 0x820FC6BC;
		  /* 820FC6BCh */ case   35:  		/* bc 12, CR6_EQ, 136 */
		/* 820FC6BCh case   35:*/		if ( regs.CR[6].eq ) { return 0x820FC744;  }
		/* 820FC6BCh case   35:*/		return 0x820FC6C0;
		  /* 820FC6C0h */ case   36:  		/* lis R10, 24656 */
		/* 820FC6C0h case   36:*/		cpu::op::lis<0>(regs,&regs.R10,0x6050);
		/* 820FC6C0h case   36:*/		return 0x820FC6C4;
		  /* 820FC6C4h */ case   37:  		/* cmplw CR6, R11, R10 */
		/* 820FC6C4h case   37:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC6C4h case   37:*/		return 0x820FC6C8;
		  /* 820FC6C8h */ case   38:  		/* bc 12, CR6_GT, 80 */
		/* 820FC6C8h case   38:*/		if ( regs.CR[6].gt ) { return 0x820FC718;  }
		/* 820FC6C8h case   38:*/		return 0x820FC6CC;
		  /* 820FC6CCh */ case   39:  		/* bc 12, CR6_EQ, 68 */
		/* 820FC6CCh case   39:*/		if ( regs.CR[6].eq ) { return 0x820FC710;  }
		/* 820FC6CCh case   39:*/		return 0x820FC6D0;
		  /* 820FC6D0h */ case   40:  		/* cmplw CR6, R11, R9 */
		/* 820FC6D0h case   40:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820FC6D0h case   40:*/		return 0x820FC6D4;
		  /* 820FC6D4h */ case   41:  		/* bc 12, CR6_EQ, 60 */
		/* 820FC6D4h case   41:*/		if ( regs.CR[6].eq ) { return 0x820FC710;  }
		/* 820FC6D4h case   41:*/		return 0x820FC6D8;
		  /* 820FC6D8h */ case   42:  		/* lis R10, 24592 */
		/* 820FC6D8h case   42:*/		cpu::op::lis<0>(regs,&regs.R10,0x6010);
		/* 820FC6D8h case   42:*/		return 0x820FC6DC;
		  /* 820FC6DCh */ case   43:  		/* cmplw CR6, R11, R10 */
		/* 820FC6DCh case   43:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC6DCh case   43:*/		return 0x820FC6E0;
		  /* 820FC6E0h */ case   44:  		/* bc 12, CR6_EQ, 40 */
		/* 820FC6E0h case   44:*/		if ( regs.CR[6].eq ) { return 0x820FC708;  }
		/* 820FC6E0h case   44:*/		return 0x820FC6E4;
		  /* 820FC6E4h */ case   45:  		/* lis R10, 24608 */
		/* 820FC6E4h case   45:*/		cpu::op::lis<0>(regs,&regs.R10,0x6020);
		/* 820FC6E4h case   45:*/		return 0x820FC6E8;
		  /* 820FC6E8h */ case   46:  		/* cmplw CR6, R11, R10 */
		/* 820FC6E8h case   46:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC6E8h case   46:*/		return 0x820FC6EC;
		  /* 820FC6ECh */ case   47:  		/* bc 12, CR6_EQ, 28 */
		/* 820FC6ECh case   47:*/		if ( regs.CR[6].eq ) { return 0x820FC708;  }
		/* 820FC6ECh case   47:*/		return 0x820FC6F0;
		  /* 820FC6F0h */ case   48:  		/* lis R10, 24624 */
		/* 820FC6F0h case   48:*/		cpu::op::lis<0>(regs,&regs.R10,0x6030);
		/* 820FC6F0h case   48:*/		return 0x820FC6F4;
		  /* 820FC6F4h */ case   49:  		/* cmplw CR6, R11, R10 */
		/* 820FC6F4h case   49:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC6F4h case   49:*/		return 0x820FC6F8;
		  /* 820FC6F8h */ case   50:  		/* bc 12, CR6_EQ, 16 */
		/* 820FC6F8h case   50:*/		if ( regs.CR[6].eq ) { return 0x820FC708;  }
		/* 820FC6F8h case   50:*/		return 0x820FC6FC;
		  /* 820FC6FCh */ case   51:  		/* lis R10, 24640 */
		/* 820FC6FCh case   51:*/		cpu::op::lis<0>(regs,&regs.R10,0x6040);
		/* 820FC6FCh case   51:*/		return 0x820FC700;
		  /* 820FC700h */ case   52:  		/* cmplw CR6, R11, R10 */
		/* 820FC700h case   52:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC700h case   52:*/		return 0x820FC704;
		  /* 820FC704h */ case   53:  		/* bc 4, CR6_EQ, 308 */
		/* 820FC704h case   53:*/		if ( !regs.CR[6].eq ) { return 0x820FC838;  }
		/* 820FC704h case   53:*/		return 0x820FC708;
	}
	return 0x820FC708;
} // Block from 820FC630h-820FC708h (54 instructions)

//////////////////////////////////////////////////////
// Block at 820FC708h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC708);
		  /* 820FC708h */ case    0:  		/* li R5, 8 */
		/* 820FC708h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x8);
		/* 820FC708h case    0:*/		return 0x820FC70C;
		  /* 820FC70Ch */ case    1:  		/* b 172 */
		/* 820FC70Ch case    1:*/		return 0x820FC7B8;
		/* 820FC70Ch case    1:*/		return 0x820FC710;
	}
	return 0x820FC710;
} // Block from 820FC708h-820FC710h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FC710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC710);
		  /* 820FC710h */ case    0:  		/* li R5, 4 */
		/* 820FC710h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 820FC710h case    0:*/		return 0x820FC714;
		  /* 820FC714h */ case    1:  		/* b 164 */
		/* 820FC714h case    1:*/		return 0x820FC7B8;
		/* 820FC714h case    1:*/		return 0x820FC718;
	}
	return 0x820FC718;
} // Block from 820FC710h-820FC718h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FC718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC718);
		  /* 820FC718h */ case    0:  		/* lis R10, 24672 */
		/* 820FC718h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x6060);
		/* 820FC718h case    0:*/		return 0x820FC71C;
		  /* 820FC71Ch */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FC71Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC71Ch case    1:*/		return 0x820FC720;
		  /* 820FC720h */ case    2:  		/* bc 12, CR6_EQ, -24 */
		/* 820FC720h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FC708;  }
		/* 820FC720h case    2:*/		return 0x820FC724;
		  /* 820FC724h */ case    3:  		/* lis R10, 24688 */
		/* 820FC724h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x6070);
		/* 820FC724h case    3:*/		return 0x820FC728;
		  /* 820FC728h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FC728h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC728h case    4:*/		return 0x820FC72C;
		  /* 820FC72Ch */ case    5:  		/* bc 12, CR6_EQ, -36 */
		/* 820FC72Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820FC708;  }
		/* 820FC72Ch case    5:*/		return 0x820FC730;
		  /* 820FC730h */ case    6:  		/* lis R10, 24704 */
		/* 820FC730h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x6080);
		/* 820FC730h case    6:*/		return 0x820FC734;
		  /* 820FC734h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FC734h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC734h case    7:*/		return 0x820FC738;
		  /* 820FC738h */ case    8:  		/* bc 12, CR6_EQ, -48 */
		/* 820FC738h case    8:*/		if ( regs.CR[6].eq ) { return 0x820FC708;  }
		/* 820FC738h case    8:*/		return 0x820FC73C;
		  /* 820FC73Ch */ case    9:  		/* lis R10, 24720 */
		/* 820FC73Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x6090);
		/* 820FC73Ch case    9:*/		return 0x820FC740;
		  /* 820FC740h */ case   10:  		/* b -64 */
		/* 820FC740h case   10:*/		return 0x820FC700;
		/* 820FC740h case   10:*/		return 0x820FC744;
	}
	return 0x820FC744;
} // Block from 820FC718h-820FC744h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FC744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC744);
		  /* 820FC744h */ case    0:  		/* li R5, 6 */
		/* 820FC744h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x6);
		/* 820FC744h case    0:*/		return 0x820FC748;
		  /* 820FC748h */ case    1:  		/* b 112 */
		/* 820FC748h case    1:*/		return 0x820FC7B8;
		/* 820FC748h case    1:*/		return 0x820FC74C;
	}
	return 0x820FC74C;
} // Block from 820FC744h-820FC74Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FC74Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC74C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC74C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC74C);
		  /* 820FC74Ch */ case    0:  		/* lis R10, 24816 */
		/* 820FC74Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x60F0);
		/* 820FC74Ch case    0:*/		return 0x820FC750;
		  /* 820FC750h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FC750h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC750h case    1:*/		return 0x820FC754;
		  /* 820FC754h */ case    2:  		/* bc 12, CR6_GT, 52 */
		/* 820FC754h case    2:*/		if ( regs.CR[6].gt ) { return 0x820FC788;  }
		/* 820FC754h case    2:*/		return 0x820FC758;
		  /* 820FC758h */ case    3:  		/* bc 12, CR6_EQ, -20 */
		/* 820FC758h case    3:*/		if ( regs.CR[6].eq ) { return 0x820FC744;  }
		/* 820FC758h case    3:*/		return 0x820FC75C;
		  /* 820FC75Ch */ case    4:  		/* lis R10, 24752 */
		/* 820FC75Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0x60B0);
		/* 820FC75Ch case    4:*/		return 0x820FC760;
		  /* 820FC760h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 820FC760h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC760h case    5:*/		return 0x820FC764;
		  /* 820FC764h */ case    6:  		/* bc 12, CR6_EQ, 80 */
		/* 820FC764h case    6:*/		if ( regs.CR[6].eq ) { return 0x820FC7B4;  }
		/* 820FC764h case    6:*/		return 0x820FC768;
		  /* 820FC768h */ case    7:  		/* lis R10, 24768 */
		/* 820FC768h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0x60C0);
		/* 820FC768h case    7:*/		return 0x820FC76C;
		  /* 820FC76Ch */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 820FC76Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC76Ch case    8:*/		return 0x820FC770;
		  /* 820FC770h */ case    9:  		/* bc 12, CR6_EQ, -104 */
		/* 820FC770h case    9:*/		if ( regs.CR[6].eq ) { return 0x820FC708;  }
		/* 820FC770h case    9:*/		return 0x820FC774;
		  /* 820FC774h */ case   10:  		/* lis R10, 24784 */
		/* 820FC774h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0x60D0);
		/* 820FC774h case   10:*/		return 0x820FC778;
		  /* 820FC778h */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 820FC778h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC778h case   11:*/		return 0x820FC77C;
		  /* 820FC77Ch */ case   12:  		/* bc 12, CR6_EQ, -116 */
		/* 820FC77Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x820FC708;  }
		/* 820FC77Ch case   12:*/		return 0x820FC780;
		  /* 820FC780h */ case   13:  		/* lis R10, 24800 */
		/* 820FC780h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0x60E0);
		/* 820FC780h case   13:*/		return 0x820FC784;
		  /* 820FC784h */ case   14:  		/* b -132 */
		/* 820FC784h case   14:*/		return 0x820FC700;
		/* 820FC784h case   14:*/		return 0x820FC788;
	}
	return 0x820FC788;
} // Block from 820FC74Ch-820FC788h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820FC788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC788);
		  /* 820FC788h */ case    0:  		/* lis R10, 24832 */
		/* 820FC788h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x6100);
		/* 820FC788h case    0:*/		return 0x820FC78C;
		  /* 820FC78Ch */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FC78Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC78Ch case    1:*/		return 0x820FC790;
		  /* 820FC790h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820FC790h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FC7B4;  }
		/* 820FC790h case    2:*/		return 0x820FC794;
		  /* 820FC794h */ case    3:  		/* lis R10, 24848 */
		/* 820FC794h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x6110);
		/* 820FC794h case    3:*/		return 0x820FC798;
		  /* 820FC798h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FC798h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC798h case    4:*/		return 0x820FC79C;
		  /* 820FC79Ch */ case    5:  		/* bc 12, CR6_EQ, -148 */
		/* 820FC79Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820FC708;  }
		/* 820FC79Ch case    5:*/		return 0x820FC7A0;
		  /* 820FC7A0h */ case    6:  		/* lis R10, 24864 */
		/* 820FC7A0h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x6120);
		/* 820FC7A0h case    6:*/		return 0x820FC7A4;
		  /* 820FC7A4h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FC7A4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FC7A4h case    7:*/		return 0x820FC7A8;
		  /* 820FC7A8h */ case    8:  		/* bc 12, CR6_EQ, -160 */
		/* 820FC7A8h case    8:*/		if ( regs.CR[6].eq ) { return 0x820FC708;  }
		/* 820FC7A8h case    8:*/		return 0x820FC7AC;
		  /* 820FC7ACh */ case    9:  		/* lis R10, 24880 */
		/* 820FC7ACh case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x6130);
		/* 820FC7ACh case    9:*/		return 0x820FC7B0;
		  /* 820FC7B0h */ case   10:  		/* b -176 */
		/* 820FC7B0h case   10:*/		return 0x820FC700;
		/* 820FC7B0h case   10:*/		return 0x820FC7B4;
	}
	return 0x820FC7B4;
} // Block from 820FC788h-820FC7B4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FC7B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC7B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC7B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC7B4);
		  /* 820FC7B4h */ case    0:  		/* li R5, 12 */
		/* 820FC7B4h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0xC);
		/* 820FC7B4h case    0:*/		return 0x820FC7B8;
	}
	return 0x820FC7B8;
} // Block from 820FC7B4h-820FC7B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FC7B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC7B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC7B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC7B8);
		  /* 820FC7B8h */ case    0:  		/* li R6, 4 */
		/* 820FC7B8h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 820FC7B8h case    0:*/		return 0x820FC7BC;
		  /* 820FC7BCh */ case    1:  		/* b 124 */
		/* 820FC7BCh case    1:*/		return 0x820FC838;
		/* 820FC7BCh case    1:*/		return 0x820FC7C0;
	}
	return 0x820FC7C0;
} // Block from 820FC7B8h-820FC7C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FC7C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC7C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC7C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC7C0);
		  /* 820FC7C0h */ case    0:  		/* rlwinm R10, R4, 0, 0, 11 */
		/* 820FC7C0h case    0:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R4);
		/* 820FC7C0h case    0:*/		return 0x820FC7C4;
		  /* 820FC7C4h */ case    1:  		/* cmplw CR6, R10, R9 */
		/* 820FC7C4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820FC7C4h case    1:*/		return 0x820FC7C8;
		  /* 820FC7C8h */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 820FC7C8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FC804;  }
		/* 820FC7C8h case    2:*/		return 0x820FC7CC;
		  /* 820FC7CCh */ case    3:  		/* lis R9, 20496 */
		/* 820FC7CCh case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0x5010);
		/* 820FC7CCh case    3:*/		return 0x820FC7D0;
		  /* 820FC7D0h */ case    4:  		/* cmplw CR6, R10, R9 */
		/* 820FC7D0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820FC7D0h case    4:*/		return 0x820FC7D4;
		  /* 820FC7D4h */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 820FC7D4h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FC7F0;  }
		/* 820FC7D4h case    5:*/		return 0x820FC7D8;
		  /* 820FC7D8h */ case    6:  		/* lis R9, 20512 */
		/* 820FC7D8h case    6:*/		cpu::op::lis<0>(regs,&regs.R9,0x5020);
		/* 820FC7D8h case    6:*/		return 0x820FC7DC;
		  /* 820FC7DCh */ case    7:  		/* cmplw CR6, R10, R9 */
		/* 820FC7DCh case    7:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820FC7DCh case    7:*/		return 0x820FC7E0;
		  /* 820FC7E0h */ case    8:  		/* bc 12, CR6_EQ, 28 */
		/* 820FC7E0h case    8:*/		if ( regs.CR[6].eq ) { return 0x820FC7FC;  }
		/* 820FC7E0h case    8:*/		return 0x820FC7E4;
		  /* 820FC7E4h */ case    9:  		/* lis R9, 20528 */
		/* 820FC7E4h case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0x5030);
		/* 820FC7E4h case    9:*/		return 0x820FC7E8;
		  /* 820FC7E8h */ case   10:  		/* cmplw CR6, R10, R9 */
		/* 820FC7E8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820FC7E8h case   10:*/		return 0x820FC7EC;
		  /* 820FC7ECh */ case   11:  		/* bc 4, CR6_EQ, 76 */
		/* 820FC7ECh case   11:*/		if ( !regs.CR[6].eq ) { return 0x820FC838;  }
		/* 820FC7ECh case   11:*/		return 0x820FC7F0;
	}
	return 0x820FC7F0;
} // Block from 820FC7C0h-820FC7F0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820FC7F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC7F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC7F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC7F0);
		  /* 820FC7F0h */ case    0:  		/* mr R5, R11 */
		/* 820FC7F0h case    0:*/		regs.R5 = regs.R11;
		/* 820FC7F0h case    0:*/		return 0x820FC7F4;
		  /* 820FC7F4h */ case    1:  		/* mr R6, R11 */
		/* 820FC7F4h case    1:*/		regs.R6 = regs.R11;
		/* 820FC7F4h case    1:*/		return 0x820FC7F8;
		  /* 820FC7F8h */ case    2:  		/* b 64 */
		/* 820FC7F8h case    2:*/		return 0x820FC838;
		/* 820FC7F8h case    2:*/		return 0x820FC7FC;
	}
	return 0x820FC7FC;
} // Block from 820FC7F0h-820FC7FCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FC7FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC7FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC7FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC7FC);
		  /* 820FC7FCh */ case    0:  		/* mr R5, R11 */
		/* 820FC7FCh case    0:*/		regs.R5 = regs.R11;
		/* 820FC7FCh case    0:*/		return 0x820FC800;
		  /* 820FC800h */ case    1:  		/* b 16 */
		/* 820FC800h case    1:*/		return 0x820FC810;
		/* 820FC800h case    1:*/		return 0x820FC804;
	}
	return 0x820FC804;
} // Block from 820FC7FCh-820FC804h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FC804h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC804( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC804) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC804);
		  /* 820FC804h */ case    0:  		/* rlwinm R5, R11, 1, 0, 30 */
		/* 820FC804h case    0:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R5,regs.R11);
		/* 820FC804h case    0:*/		return 0x820FC808;
		  /* 820FC808h */ case    1:  		/* cmpwi CR6, R6, -1 */
		/* 820FC808h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R6,0xFFFFFFFF);
		/* 820FC808h case    1:*/		return 0x820FC80C;
		  /* 820FC80Ch */ case    2:  		/* bc 4, CR6_EQ, 44 */
		/* 820FC80Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FC838;  }
		/* 820FC80Ch case    2:*/		return 0x820FC810;
	}
	return 0x820FC810;
} // Block from 820FC804h-820FC810h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FC810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC810);
		  /* 820FC810h */ case    0:  		/* li R6, 1 */
		/* 820FC810h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820FC810h case    0:*/		return 0x820FC814;
		  /* 820FC814h */ case    1:  		/* b 36 */
		/* 820FC814h case    1:*/		return 0x820FC838;
		/* 820FC814h case    1:*/		return 0x820FC818;
	}
	return 0x820FC818;
} // Block from 820FC810h-820FC818h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FC818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC818);
		  /* 820FC818h */ case    0:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820FC818h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820FC818h case    0:*/		return 0x820FC81C;
		  /* 820FC81Ch */ case    1:  		/* b -40 */
		/* 820FC81Ch case    1:*/		return 0x820FC7F4;
		/* 820FC81Ch case    1:*/		return 0x820FC820;
	}
	return 0x820FC820;
} // Block from 820FC818h-820FC820h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FC820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC820);
		  /* 820FC820h */ case    0:  		/* mulli R5, R11, 3 */
		/* 820FC820h case    0:*/		cpu::op::mulli<0>(regs,&regs.R5,regs.R11,0x3);
		/* 820FC820h case    0:*/		return 0x820FC824;
		  /* 820FC824h */ case    1:  		/* b -48 */
		/* 820FC824h case    1:*/		return 0x820FC7F4;
		/* 820FC824h case    1:*/		return 0x820FC828;
	}
	return 0x820FC828;
} // Block from 820FC820h-820FC828h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FC828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC828);
		  /* 820FC828h */ case    0:  		/* rlwinm R5, R11, 1, 0, 30 */
		/* 820FC828h case    0:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R5,regs.R11);
		/* 820FC828h case    0:*/		return 0x820FC82C;
		  /* 820FC82Ch */ case    1:  		/* b -56 */
		/* 820FC82Ch case    1:*/		return 0x820FC7F4;
		/* 820FC82Ch case    1:*/		return 0x820FC830;
	}
	return 0x820FC830;
} // Block from 820FC828h-820FC830h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FC830h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC830);
		  /* 820FC830h */ case    0:  		/* mr R5, R29 */
		/* 820FC830h case    0:*/		regs.R5 = regs.R29;
		/* 820FC830h case    0:*/		return 0x820FC834;
		  /* 820FC834h */ case    1:  		/* mr R6, R29 */
		/* 820FC834h case    1:*/		regs.R6 = regs.R29;
		/* 820FC834h case    1:*/		return 0x820FC838;
	}
	return 0x820FC838;
} // Block from 820FC830h-820FC838h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FC838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC838);
		  /* 820FC838h */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 820FC838h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 820FC838h case    0:*/		return 0x820FC83C;
		  /* 820FC83Ch */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 820FC83Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FC83Ch case    1:*/		return 0x820FC840;
		  /* 820FC840h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820FC840h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FC848;  }
		/* 820FC840h case    2:*/		return 0x820FC844;
		  /* 820FC844h */ case    3:  		/* stw R5, <#[R30 + 4]> */
		/* 820FC844h case    3:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R30 + 0x00000004) );
		/* 820FC844h case    3:*/		return 0x820FC848;
	}
	return 0x820FC848;
} // Block from 820FC838h-820FC848h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FC848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC848);
		  /* 820FC848h */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 820FC848h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 820FC848h case    0:*/		return 0x820FC84C;
		  /* 820FC84Ch */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 820FC84Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FC84Ch case    1:*/		return 0x820FC850;
		  /* 820FC850h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820FC850h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FC858;  }
		/* 820FC850h case    2:*/		return 0x820FC854;
		  /* 820FC854h */ case    3:  		/* stw R6, <#[R30 + 12]> */
		/* 820FC854h case    3:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R30 + 0x0000000C) );
		/* 820FC854h case    3:*/		return 0x820FC858;
	}
	return 0x820FC858;
} // Block from 820FC848h-820FC858h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FC858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC858);
		  /* 820FC858h */ case    0:  		/* lwz R10, <#[R30 + 4]> */
		/* 820FC858h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 820FC858h case    0:*/		return 0x820FC85C;
		  /* 820FC85Ch */ case    1:  		/* cmplw CR6, R10, R5 */
		/* 820FC85Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R5);
		/* 820FC85Ch case    1:*/		return 0x820FC860;
		  /* 820FC860h */ case    2:  		/* bc 4, CR6_EQ, 32 */
		/* 820FC860h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FC880;  }
		/* 820FC860h case    2:*/		return 0x820FC864;
		  /* 820FC864h */ case    3:  		/* lwz R11, <#[R30 + 12]> */
		/* 820FC864h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 820FC864h case    3:*/		return 0x820FC868;
		  /* 820FC868h */ case    4:  		/* cmplw CR6, R11, R6 */
		/* 820FC868h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820FC868h case    4:*/		return 0x820FC86C;
		  /* 820FC86Ch */ case    5:  		/* bc 4, CR6_EQ, 20 */
		/* 820FC86Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x820FC880;  }
		/* 820FC86Ch case    5:*/		return 0x820FC870;
		  /* 820FC870h */ case    6:  		/* cmpwi CR6, R10, -1 */
		/* 820FC870h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820FC870h case    6:*/		return 0x820FC874;
		  /* 820FC874h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 820FC874h case    7:*/		if ( regs.CR[6].eq ) { return 0x820FC880;  }
		/* 820FC874h case    7:*/		return 0x820FC878;
		  /* 820FC878h */ case    8:  		/* cmpwi CR6, R11, -1 */
		/* 820FC878h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FC878h case    8:*/		return 0x820FC87C;
		  /* 820FC87Ch */ case    9:  		/* bc 4, CR6_EQ, 16 */
		/* 820FC87Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x820FC88C;  }
		/* 820FC87Ch case    9:*/		return 0x820FC880;
	}
	return 0x820FC880;
} // Block from 820FC858h-820FC880h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FC880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC880);
		  /* 820FC880h */ case    0:  		/* lis R3, -32768 */
		/* 820FC880h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820FC880h case    0:*/		return 0x820FC884;
		  /* 820FC884h */ case    1:  		/* ori R3, R3, 16389 */
		/* 820FC884h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820FC884h case    1:*/		return 0x820FC888;
		  /* 820FC888h */ case    2:  		/* b 188 */
		/* 820FC888h case    2:*/		return 0x820FC944;
		/* 820FC888h case    2:*/		return 0x820FC88C;
	}
	return 0x820FC88C;
} // Block from 820FC880h-820FC88Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FC88Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC88C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC88C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC88C);
		  /* 820FC88Ch */ case    0:  		/* lwz R31, <#[R30 + 4]> */
		/* 820FC88Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000004) );
		/* 820FC88Ch case    0:*/		return 0x820FC890;
		  /* 820FC890h */ case    1:  		/* cmplwi CR6, R31, 8 */
		/* 820FC890h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000008);
		/* 820FC890h case    1:*/		return 0x820FC894;
		  /* 820FC894h */ case    2:  		/* bc 12, CR6_GT, 36 */
		/* 820FC894h case    2:*/		if ( regs.CR[6].gt ) { return 0x820FC8B8;  }
		/* 820FC894h case    2:*/		return 0x820FC898;
		  /* 820FC898h */ case    3:  		/* addi R11, R30, 64 */
		/* 820FC898h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x40);
		/* 820FC898h case    3:*/		return 0x820FC89C;
		  /* 820FC89Ch */ case    4:  		/* stw R11, <#[R30 + 8]> */
		/* 820FC89Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820FC89Ch case    4:*/		return 0x820FC8A0;
		  /* 820FC8A0h */ case    5:  		/* lwz R31, <#[R30 + 12]> */
		/* 820FC8A0h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x0000000C) );
		/* 820FC8A0h case    5:*/		return 0x820FC8A4;
		  /* 820FC8A4h */ case    6:  		/* cmplwi CR6, R31, 4 */
		/* 820FC8A4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000004);
		/* 820FC8A4h case    6:*/		return 0x820FC8A8;
		  /* 820FC8A8h */ case    7:  		/* bc 12, CR6_GT, 60 */
		/* 820FC8A8h case    7:*/		if ( regs.CR[6].gt ) { return 0x820FC8E4;  }
		/* 820FC8A8h case    7:*/		return 0x820FC8AC;
		  /* 820FC8ACh */ case    8:  		/* addi R11, R30, 96 */
		/* 820FC8ACh case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x60);
		/* 820FC8ACh case    8:*/		return 0x820FC8B0;
		  /* 820FC8B0h */ case    9:  		/* stw R11, <#[R30 + 16]> */
		/* 820FC8B0h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820FC8B0h case    9:*/		return 0x820FC8B4;
		  /* 820FC8B4h */ case   10:  		/* b 80 */
		/* 820FC8B4h case   10:*/		return 0x820FC904;
		/* 820FC8B4h case   10:*/		return 0x820FC8B8;
	}
	return 0x820FC8B8;
} // Block from 820FC88Ch-820FC8B8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FC8B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC8B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC8B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC8B8);
		  /* 820FC8B8h */ case    0:  		/* bl -194696 */
		/* 820FC8B8h case    0:*/		regs.LR = 0x820FC8BC; return 0x820CD030;
		/* 820FC8B8h case    0:*/		return 0x820FC8BC;
		  /* 820FC8BCh */ case    1:  		/* li R5, 16 */
		/* 820FC8BCh case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820FC8BCh case    1:*/		return 0x820FC8C0;
		  /* 820FC8C0h */ case    2:  		/* rlwinm R4, R31, 2, 0, 29 */
		/* 820FC8C0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R31);
		/* 820FC8C0h case    2:*/		return 0x820FC8C4;
		  /* 820FC8C4h */ case    3:  		/* lwz R3, <#[R3 + 16]> */
		/* 820FC8C4h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000010) );
		/* 820FC8C4h case    3:*/		return 0x820FC8C8;
		  /* 820FC8C8h */ case    4:  		/* bl -210920 */
		/* 820FC8C8h case    4:*/		regs.LR = 0x820FC8CC; return 0x820C90E0;
		/* 820FC8C8h case    4:*/		return 0x820FC8CC;
		  /* 820FC8CCh */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 820FC8CCh case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820FC8CCh case    5:*/		return 0x820FC8D0;
		  /* 820FC8D0h */ case    6:  		/* stw R3, <#[R30 + 8]> */
		/* 820FC8D0h case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000008) );
		/* 820FC8D0h case    6:*/		return 0x820FC8D4;
		  /* 820FC8D4h */ case    7:  		/* bc 4, CR0_EQ, -52 */
		/* 820FC8D4h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820FC8A0;  }
		/* 820FC8D4h case    7:*/		return 0x820FC8D8;
		  /* 820FC8D8h */ case    8:  		/* lis R3, -32761 */
		/* 820FC8D8h case    8:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820FC8D8h case    8:*/		return 0x820FC8DC;
		  /* 820FC8DCh */ case    9:  		/* ori R3, R3, 14 */
		/* 820FC8DCh case    9:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820FC8DCh case    9:*/		return 0x820FC8E0;
		  /* 820FC8E0h */ case   10:  		/* b 100 */
		/* 820FC8E0h case   10:*/		return 0x820FC944;
		/* 820FC8E0h case   10:*/		return 0x820FC8E4;
	}
	return 0x820FC8E4;
} // Block from 820FC8B8h-820FC8E4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FC8E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC8E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC8E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC8E4);
		  /* 820FC8E4h */ case    0:  		/* bl -194740 */
		/* 820FC8E4h case    0:*/		regs.LR = 0x820FC8E8; return 0x820CD030;
		/* 820FC8E4h case    0:*/		return 0x820FC8E8;
		  /* 820FC8E8h */ case    1:  		/* li R5, 16 */
		/* 820FC8E8h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820FC8E8h case    1:*/		return 0x820FC8EC;
		  /* 820FC8ECh */ case    2:  		/* rlwinm R4, R31, 2, 0, 29 */
		/* 820FC8ECh case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R31);
		/* 820FC8ECh case    2:*/		return 0x820FC8F0;
		  /* 820FC8F0h */ case    3:  		/* lwz R3, <#[R3 + 16]> */
		/* 820FC8F0h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000010) );
		/* 820FC8F0h case    3:*/		return 0x820FC8F4;
		  /* 820FC8F4h */ case    4:  		/* bl -210964 */
		/* 820FC8F4h case    4:*/		regs.LR = 0x820FC8F8; return 0x820C90E0;
		/* 820FC8F4h case    4:*/		return 0x820FC8F8;
		  /* 820FC8F8h */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 820FC8F8h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820FC8F8h case    5:*/		return 0x820FC8FC;
		  /* 820FC8FCh */ case    6:  		/* stw R3, <#[R30 + 16]> */
		/* 820FC8FCh case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000010) );
		/* 820FC8FCh case    6:*/		return 0x820FC900;
		  /* 820FC900h */ case    7:  		/* bc 12, CR0_EQ, -40 */
		/* 820FC900h case    7:*/		if ( regs.CR[0].eq ) { return 0x820FC8D8;  }
		/* 820FC900h case    7:*/		return 0x820FC904;
	}
	return 0x820FC904;
} // Block from 820FC8E4h-820FC904h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820FC904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC904);
		  /* 820FC904h */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 820FC904h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 820FC904h case    0:*/		return 0x820FC908;
		  /* 820FC908h */ case    1:  		/* li R4, 255 */
		/* 820FC908h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xFF);
		/* 820FC908h case    1:*/		return 0x820FC90C;
		  /* 820FC90Ch */ case    2:  		/* lwz R3, <#[R30 + 8]> */
		/* 820FC90Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000008) );
		/* 820FC90Ch case    2:*/		return 0x820FC910;
		  /* 820FC910h */ case    3:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820FC910h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820FC910h case    3:*/		return 0x820FC914;
		  /* 820FC914h */ case    4:  		/* bl -439764 */
		/* 820FC914h case    4:*/		regs.LR = 0x820FC918; return 0x82091340;
		/* 820FC914h case    4:*/		return 0x820FC918;
		  /* 820FC918h */ case    5:  		/* lwz R11, <#[R30 + 12]> */
		/* 820FC918h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 820FC918h case    5:*/		return 0x820FC91C;
		  /* 820FC91Ch */ case    6:  		/* li R4, 255 */
		/* 820FC91Ch case    6:*/		cpu::op::li<0>(regs,&regs.R4,0xFF);
		/* 820FC91Ch case    6:*/		return 0x820FC920;
		  /* 820FC920h */ case    7:  		/* lwz R3, <#[R30 + 16]> */
		/* 820FC920h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000010) );
		/* 820FC920h case    7:*/		return 0x820FC924;
		  /* 820FC924h */ case    8:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820FC924h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820FC924h case    8:*/		return 0x820FC928;
		  /* 820FC928h */ case    9:  		/* bl -439784 */
		/* 820FC928h case    9:*/		regs.LR = 0x820FC92C; return 0x82091340;
		/* 820FC928h case    9:*/		return 0x820FC92C;
		  /* 820FC92Ch */ case   10:  		/* stw R29, <#[R30 + 36]> */
		/* 820FC92Ch case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000024) );
		/* 820FC92Ch case   10:*/		return 0x820FC930;
		  /* 820FC930h */ case   11:  		/* stw R29, <#[R30 + 40]> */
		/* 820FC930h case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000028) );
		/* 820FC930h case   11:*/		return 0x820FC934;
		  /* 820FC934h */ case   12:  		/* li R3, 0 */
		/* 820FC934h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FC934h case   12:*/		return 0x820FC938;
		  /* 820FC938h */ case   13:  		/* stw R29, <#[R30 + 44]> */
		/* 820FC938h case   13:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x0000002C) );
		/* 820FC938h case   13:*/		return 0x820FC93C;
		  /* 820FC93Ch */ case   14:  		/* stw R29, <#[R30 + 56]> */
		/* 820FC93Ch case   14:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000038) );
		/* 820FC93Ch case   14:*/		return 0x820FC940;
		  /* 820FC940h */ case   15:  		/* stw R29, <#[R30 + 60]> */
		/* 820FC940h case   15:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x0000003C) );
		/* 820FC940h case   15:*/		return 0x820FC944;
	}
	return 0x820FC944;
} // Block from 820FC904h-820FC944h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820FC944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC944);
		  /* 820FC944h */ case    0:  		/* addi R1, R1, 112 */
		/* 820FC944h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820FC944h case    0:*/		return 0x820FC948;
		  /* 820FC948h */ case    1:  		/* b -439964 */
		/* 820FC948h case    1:*/		return 0x820912AC;
		/* 820FC948h case    1:*/		return 0x820FC94C;
		  /* 820FC94Ch */ case    2:  		/* nop */
		/* 820FC94Ch case    2:*/		cpu::op::nop();
		/* 820FC94Ch case    2:*/		return 0x820FC950;
	}
	return 0x820FC950;
} // Block from 820FC944h-820FC950h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FC950h
// Function '?GetArgumentName@C30Program@D3DXShader@@MAAXPAVCArgument@2@PADI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC950);
		  /* 820FC950h */ case    0:  		/* mfspr R12, LR */
		/* 820FC950h case    0:*/		regs.R12 = regs.LR;
		/* 820FC950h case    0:*/		return 0x820FC954;
		  /* 820FC954h */ case    1:  		/* bl -440056 */
		/* 820FC954h case    1:*/		regs.LR = 0x820FC958; return 0x8209125C;
		/* 820FC954h case    1:*/		return 0x820FC958;
		  /* 820FC958h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820FC958h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820FC958h case    2:*/		return 0x820FC95C;
		  /* 820FC95Ch */ case    3:  		/* mr R31, R3 */
		/* 820FC95Ch case    3:*/		regs.R31 = regs.R3;
		/* 820FC95Ch case    3:*/		return 0x820FC960;
		  /* 820FC960h */ case    4:  		/* mr R30, R4 */
		/* 820FC960h case    4:*/		regs.R30 = regs.R4;
		/* 820FC960h case    4:*/		return 0x820FC964;
		  /* 820FC964h */ case    5:  		/* cmplwi CR6, R4, 0 */
		/* 820FC964h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820FC964h case    5:*/		return 0x820FC968;
		  /* 820FC968h */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 820FC968h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820FC978;  }
		/* 820FC968h case    6:*/		return 0x820FC96C;
		  /* 820FC96Ch */ case    7:  		/* lis R3, -32768 */
		/* 820FC96Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820FC96Ch case    7:*/		return 0x820FC970;
		  /* 820FC970h */ case    8:  		/* ori R3, R3, 16389 */
		/* 820FC970h case    8:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820FC970h case    8:*/		return 0x820FC974;
		  /* 820FC974h */ case    9:  		/* b 240 */
		/* 820FC974h case    9:*/		return 0x820FCA64;
		/* 820FC974h case    9:*/		return 0x820FC978;
	}
	return 0x820FC978;
} // Block from 820FC950h-820FC978h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FC978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC978);
		  /* 820FC978h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 820FC978h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820FC978h case    0:*/		return 0x820FC97C;
		  /* 820FC97Ch */ case    1:  		/* lwz R10, <#[R31 + 4]> */
		/* 820FC97Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820FC97Ch case    1:*/		return 0x820FC980;
		  /* 820FC980h */ case    2:  		/* stw R11, <#[R31]> */
		/* 820FC980h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FC980h case    2:*/		return 0x820FC984;
		  /* 820FC984h */ case    3:  		/* lwz R29, <#[R30 + 4]> */
		/* 820FC984h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000004) );
		/* 820FC984h case    3:*/		return 0x820FC988;
		  /* 820FC988h */ case    4:  		/* cmplw CR6, R29, R10 */
		/* 820FC988h case    4:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R10);
		/* 820FC988h case    4:*/		return 0x820FC98C;
		  /* 820FC98Ch */ case    5:  		/* bc 4, CR6_GT, 20 */
		/* 820FC98Ch case    5:*/		if ( !regs.CR[6].gt ) { return 0x820FC9A0;  }
		/* 820FC98Ch case    5:*/		return 0x820FC990;
		  /* 820FC990h */ case    6:  		/* cmplwi CR6, R29, 8 */
		/* 820FC990h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000008);
		/* 820FC990h case    6:*/		return 0x820FC994;
		  /* 820FC994h */ case    7:  		/* bc 12, CR6_GT, 72 */
		/* 820FC994h case    7:*/		if ( regs.CR[6].gt ) { return 0x820FC9DC;  }
		/* 820FC994h case    7:*/		return 0x820FC998;
		  /* 820FC998h */ case    8:  		/* addi R11, R31, 64 */
		/* 820FC998h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x40);
		/* 820FC998h case    8:*/		return 0x820FC99C;
		  /* 820FC99Ch */ case    9:  		/* stw R11, <#[R31 + 8]> */
		/* 820FC99Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820FC99Ch case    9:*/		return 0x820FC9A0;
	}
	return 0x820FC9A0;
} // Block from 820FC978h-820FC9A0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FC9A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC9A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC9A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC9A0);
		  /* 820FC9A0h */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 820FC9A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 820FC9A0h case    0:*/		return 0x820FC9A4;
		  /* 820FC9A4h */ case    1:  		/* lwz R3, <#[R31 + 8]> */
		/* 820FC9A4h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820FC9A4h case    1:*/		return 0x820FC9A8;
		  /* 820FC9A8h */ case    2:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820FC9A8h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820FC9A8h case    2:*/		return 0x820FC9AC;
		  /* 820FC9ACh */ case    3:  		/* stw R11, <#[R31 + 4]> */
		/* 820FC9ACh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820FC9ACh case    3:*/		return 0x820FC9B0;
		  /* 820FC9B0h */ case    4:  		/* lwz R4, <#[R30 + 8]> */
		/* 820FC9B0h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000008) );
		/* 820FC9B0h case    4:*/		return 0x820FC9B4;
		  /* 820FC9B4h */ case    5:  		/* bl -438276 */
		/* 820FC9B4h case    5:*/		regs.LR = 0x820FC9B8; return 0x820919B0;
		/* 820FC9B4h case    5:*/		return 0x820FC9B8;
		  /* 820FC9B8h */ case    6:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FC9B8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FC9B8h case    6:*/		return 0x820FC9BC;
		  /* 820FC9BCh */ case    7:  		/* lwz R29, <#[R30 + 12]> */
		/* 820FC9BCh case    7:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x0000000C) );
		/* 820FC9BCh case    7:*/		return 0x820FC9C0;
		  /* 820FC9C0h */ case    8:  		/* cmplw CR6, R29, R11 */
		/* 820FC9C0h case    8:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820FC9C0h case    8:*/		return 0x820FC9C4;
		  /* 820FC9C4h */ case    9:  		/* bc 4, CR6_GT, 100 */
		/* 820FC9C4h case    9:*/		if ( !regs.CR[6].gt ) { return 0x820FCA28;  }
		/* 820FC9C4h case    9:*/		return 0x820FC9C8;
		  /* 820FC9C8h */ case   10:  		/* cmplwi CR6, R29, 4 */
		/* 820FC9C8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000004);
		/* 820FC9C8h case   10:*/		return 0x820FC9CC;
		  /* 820FC9CCh */ case   11:  		/* bc 12, CR6_GT, 60 */
		/* 820FC9CCh case   11:*/		if ( regs.CR[6].gt ) { return 0x820FCA08;  }
		/* 820FC9CCh case   11:*/		return 0x820FC9D0;
		  /* 820FC9D0h */ case   12:  		/* addi R11, R31, 96 */
		/* 820FC9D0h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x60);
		/* 820FC9D0h case   12:*/		return 0x820FC9D4;
		  /* 820FC9D4h */ case   13:  		/* stw R11, <#[R31 + 16]> */
		/* 820FC9D4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820FC9D4h case   13:*/		return 0x820FC9D8;
		  /* 820FC9D8h */ case   14:  		/* b 80 */
		/* 820FC9D8h case   14:*/		return 0x820FCA28;
		/* 820FC9D8h case   14:*/		return 0x820FC9DC;
	}
	return 0x820FC9DC;
} // Block from 820FC9A0h-820FC9DCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 820FC9DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FC9DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FC9DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FC9DC);
		  /* 820FC9DCh */ case    0:  		/* bl -194988 */
		/* 820FC9DCh case    0:*/		regs.LR = 0x820FC9E0; return 0x820CD030;
		/* 820FC9DCh case    0:*/		return 0x820FC9E0;
		  /* 820FC9E0h */ case    1:  		/* li R5, 16 */
		/* 820FC9E0h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820FC9E0h case    1:*/		return 0x820FC9E4;
		  /* 820FC9E4h */ case    2:  		/* rlwinm R4, R29, 2, 0, 29 */
		/* 820FC9E4h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R29);
		/* 820FC9E4h case    2:*/		return 0x820FC9E8;
		  /* 820FC9E8h */ case    3:  		/* lwz R3, <#[R3 + 16]> */
		/* 820FC9E8h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000010) );
		/* 820FC9E8h case    3:*/		return 0x820FC9EC;
		  /* 820FC9ECh */ case    4:  		/* bl -211212 */
		/* 820FC9ECh case    4:*/		regs.LR = 0x820FC9F0; return 0x820C90E0;
		/* 820FC9ECh case    4:*/		return 0x820FC9F0;
		  /* 820FC9F0h */ case    5:  		/* stw R3, <#[R31 + 8]> */
		/* 820FC9F0h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820FC9F0h case    5:*/		return 0x820FC9F4;
		  /* 820FC9F4h */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 820FC9F4h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820FC9F4h case    6:*/		return 0x820FC9F8;
		  /* 820FC9F8h */ case    7:  		/* bc 4, CR0_EQ, -88 */
		/* 820FC9F8h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820FC9A0;  }
		/* 820FC9F8h case    7:*/		return 0x820FC9FC;
		  /* 820FC9FCh */ case    8:  		/* lis R3, -32761 */
		/* 820FC9FCh case    8:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820FC9FCh case    8:*/		return 0x820FCA00;
		  /* 820FCA00h */ case    9:  		/* ori R3, R3, 14 */
		/* 820FCA00h case    9:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820FCA00h case    9:*/		return 0x820FCA04;
		  /* 820FCA04h */ case   10:  		/* b 96 */
		/* 820FCA04h case   10:*/		return 0x820FCA64;
		/* 820FCA04h case   10:*/		return 0x820FCA08;
	}
	return 0x820FCA08;
} // Block from 820FC9DCh-820FCA08h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FCA08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCA08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCA08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCA08);
		  /* 820FCA08h */ case    0:  		/* bl -195032 */
		/* 820FCA08h case    0:*/		regs.LR = 0x820FCA0C; return 0x820CD030;
		/* 820FCA08h case    0:*/		return 0x820FCA0C;
		  /* 820FCA0Ch */ case    1:  		/* li R5, 16 */
		/* 820FCA0Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820FCA0Ch case    1:*/		return 0x820FCA10;
		  /* 820FCA10h */ case    2:  		/* rlwinm R4, R29, 2, 0, 29 */
		/* 820FCA10h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R29);
		/* 820FCA10h case    2:*/		return 0x820FCA14;
		  /* 820FCA14h */ case    3:  		/* lwz R3, <#[R3 + 16]> */
		/* 820FCA14h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000010) );
		/* 820FCA14h case    3:*/		return 0x820FCA18;
		  /* 820FCA18h */ case    4:  		/* bl -211256 */
		/* 820FCA18h case    4:*/		regs.LR = 0x820FCA1C; return 0x820C90E0;
		/* 820FCA18h case    4:*/		return 0x820FCA1C;
		  /* 820FCA1Ch */ case    5:  		/* stw R3, <#[R31 + 16]> */
		/* 820FCA1Ch case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 820FCA1Ch case    5:*/		return 0x820FCA20;
		  /* 820FCA20h */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 820FCA20h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820FCA20h case    6:*/		return 0x820FCA24;
		  /* 820FCA24h */ case    7:  		/* bc 12, CR0_EQ, -40 */
		/* 820FCA24h case    7:*/		if ( regs.CR[0].eq ) { return 0x820FC9FC;  }
		/* 820FCA24h case    7:*/		return 0x820FCA28;
	}
	return 0x820FCA28;
} // Block from 820FCA08h-820FCA28h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820FCA28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCA28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCA28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCA28);
		  /* 820FCA28h */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 820FCA28h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 820FCA28h case    0:*/		return 0x820FCA2C;
		  /* 820FCA2Ch */ case    1:  		/* lwz R3, <#[R31 + 16]> */
		/* 820FCA2Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 820FCA2Ch case    1:*/		return 0x820FCA30;
		  /* 820FCA30h */ case    2:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820FCA30h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820FCA30h case    2:*/		return 0x820FCA34;
		  /* 820FCA34h */ case    3:  		/* stw R11, <#[R31 + 12]> */
		/* 820FCA34h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FCA34h case    3:*/		return 0x820FCA38;
	}
	return 0x820FCA38;
} // Block from 820FCA28h-820FCA38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FCA38h
// Function '??0CInstruction@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCA38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCA38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCA38);
		  /* 820FCA38h */ case    0:  		/* lwz R4, <#[R30 + 16]> */
		/* 820FCA38h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000010) );
		/* 820FCA38h case    0:*/		return 0x820FCA3C;
		  /* 820FCA3Ch */ case    1:  		/* bl -438412 */
		/* 820FCA3Ch case    1:*/		regs.LR = 0x820FCA40; return 0x820919B0;
		/* 820FCA3Ch case    1:*/		return 0x820FCA40;
		  /* 820FCA40h */ case    2:  		/* lwz R11, <#[R30 + 36]> */
		/* 820FCA40h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 820FCA40h case    2:*/		return 0x820FCA44;
		  /* 820FCA44h */ case    3:  		/* li R3, 0 */
		/* 820FCA44h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FCA44h case    3:*/		return 0x820FCA48;
		  /* 820FCA48h */ case    4:  		/* stw R11, <#[R31 + 36]> */
		/* 820FCA48h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 820FCA48h case    4:*/		return 0x820FCA4C;
		  /* 820FCA4Ch */ case    5:  		/* lwz R11, <#[R30 + 40]> */
		/* 820FCA4Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 820FCA4Ch case    5:*/		return 0x820FCA50;
		  /* 820FCA50h */ case    6:  		/* stw R11, <#[R31 + 40]> */
		/* 820FCA50h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820FCA50h case    6:*/		return 0x820FCA54;
		  /* 820FCA54h */ case    7:  		/* lwz R11, <#[R30 + 48]> */
		/* 820FCA54h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 820FCA54h case    7:*/		return 0x820FCA58;
		  /* 820FCA58h */ case    8:  		/* stw R11, <#[R31 + 48]> */
		/* 820FCA58h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820FCA58h case    8:*/		return 0x820FCA5C;
		  /* 820FCA5Ch */ case    9:  		/* lwz R11, <#[R30 + 60]> */
		/* 820FCA5Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000003C) );
		/* 820FCA5Ch case    9:*/		return 0x820FCA60;
		  /* 820FCA60h */ case   10:  		/* stw R11, <#[R31 + 60]> */
		/* 820FCA60h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 820FCA60h case   10:*/		return 0x820FCA64;
	}
	return 0x820FCA64;
} // Block from 820FCA38h-820FCA64h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FCA64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCA64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCA64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCA64);
		  /* 820FCA64h */ case    0:  		/* addi R1, R1, 112 */
		/* 820FCA64h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820FCA64h case    0:*/		return 0x820FCA68;
		  /* 820FCA68h */ case    1:  		/* b -440252 */
		/* 820FCA68h case    1:*/		return 0x820912AC;
		/* 820FCA68h case    1:*/		return 0x820FCA6C;
		  /* 820FCA6Ch */ case    2:  		/* nop */
		/* 820FCA6Ch case    2:*/		cpu::op::nop();
		/* 820FCA6Ch case    2:*/		return 0x820FCA70;
	}
	return 0x820FCA70;
} // Block from 820FCA64h-820FCA70h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FCA70h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCA70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCA70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCA70);
		  /* 820FCA70h */ case    0:  		/* lwz R9, <#[R3]> */
		/* 820FCA70h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 820FCA70h case    0:*/		return 0x820FCA74;
		  /* 820FCA74h */ case    1:  		/* mr R10, R3 */
		/* 820FCA74h case    1:*/		regs.R10 = regs.R3;
		/* 820FCA74h case    1:*/		return 0x820FCA78;
		  /* 820FCA78h */ case    2:  		/* rlwinm. R11, R9, 0, 0, 11 */
		/* 820FCA78h case    2:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R9);
		/* 820FCA78h case    2:*/		return 0x820FCA7C;
		  /* 820FCA7Ch */ case    3:  		/* bc 12, CR0_EQ, 88 */
		/* 820FCA7Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x820FCAD4;  }
		/* 820FCA7Ch case    3:*/		return 0x820FCA80;
		  /* 820FCA80h */ case    4:  		/* lis R8, 20480 */
		/* 820FCA80h case    4:*/		cpu::op::lis<0>(regs,&regs.R8,0x5000);
		/* 820FCA80h case    4:*/		return 0x820FCA84;
		  /* 820FCA84h */ case    5:  		/* cmplw CR6, R11, R8 */
		/* 820FCA84h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820FCA84h case    5:*/		return 0x820FCA88;
	}
	return 0x820FCA88;
} // Block from 820FCA70h-820FCA88h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FCA88h
// Function '?Instance@CInstruction@D3DXShader@@QAAJPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCA88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCA88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCA88);
		  /* 820FCA88h */ case    0:  		/* bc 12, CR6_EQ, 68 */
		/* 820FCA88h case    0:*/		if ( regs.CR[6].eq ) { return 0x820FCACC;  }
		/* 820FCA88h case    0:*/		return 0x820FCA8C;
		  /* 820FCA8Ch */ case    1:  		/* lis R8, 20512 */
		/* 820FCA8Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R8,0x5020);
		/* 820FCA8Ch case    1:*/		return 0x820FCA90;
		  /* 820FCA90h */ case    2:  		/* cmplw CR6, R11, R8 */
		/* 820FCA90h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820FCA90h case    2:*/		return 0x820FCA94;
		  /* 820FCA94h */ case    3:  		/* bc 12, CR6_EQ, 48 */
		/* 820FCA94h case    3:*/		if ( regs.CR[6].eq ) { return 0x820FCAC4;  }
		/* 820FCA94h case    3:*/		return 0x820FCA98;
		  /* 820FCA98h */ case    4:  		/* lis R8, 28800 */
		/* 820FCA98h case    4:*/		cpu::op::lis<0>(regs,&regs.R8,0x7080);
		/* 820FCA98h case    4:*/		return 0x820FCA9C;
		  /* 820FCA9Ch */ case    5:  		/* cmplw CR6, R11, R8 */
		/* 820FCA9Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820FCA9Ch case    5:*/		return 0x820FCAA0;
		  /* 820FCAA0h */ case    6:  		/* bc 12, CR6_EQ, 44 */
		/* 820FCAA0h case    6:*/		if ( regs.CR[6].eq ) { return 0x820FCACC;  }
		/* 820FCAA0h case    6:*/		return 0x820FCAA4;
		  /* 820FCAA4h */ case    7:  		/* rlwinm R11, R9, 0, 0, 3 */
		/* 820FCAA4h case    7:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R11,regs.R9);
		/* 820FCAA4h case    7:*/		return 0x820FCAA8;
		  /* 820FCAA8h */ case    8:  		/* lis R8, 24576 */
		/* 820FCAA8h case    8:*/		cpu::op::lis<0>(regs,&regs.R8,0x6000);
		/* 820FCAA8h case    8:*/		return 0x820FCAAC;
		  /* 820FCAACh */ case    9:  		/* cmplw CR6, R11, R8 */
		/* 820FCAACh case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820FCAACh case    9:*/		return 0x820FCAB0;
	}
	return 0x820FCAB0;
} // Block from 820FCA88h-820FCAB0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FCAB0h
// Function '?GetInputs@CInstruction@D3DXShader@@QAAIIPAPAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCAB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCAB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCAB0);
		  /* 820FCAB0h */ case    0:  		/* bc 4, CR6_EQ, 12 */
		/* 820FCAB0h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820FCABC;  }
		/* 820FCAB0h case    0:*/		return 0x820FCAB4;
		  /* 820FCAB4h */ case    1:  		/* li R3, 4 */
		/* 820FCAB4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x4);
		/* 820FCAB4h case    1:*/		return 0x820FCAB8;
		  /* 820FCAB8h */ case    2:  		/* b 32 */
		/* 820FCAB8h case    2:*/		return 0x820FCAD8;
		/* 820FCAB8h case    2:*/		return 0x820FCABC;
	}
	return 0x820FCABC;
} // Block from 820FCAB0h-820FCABCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FCABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCABC);
		  /* 820FCABCh */ case    0:  		/* rlwinm R3, R9, 0, 12, 31 */
		/* 820FCABCh case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R3,regs.R9);
		/* 820FCABCh case    0:*/		return 0x820FCAC0;
		  /* 820FCAC0h */ case    1:  		/* b 24 */
		/* 820FCAC0h case    1:*/		return 0x820FCAD8;
		/* 820FCAC0h case    1:*/		return 0x820FCAC4;
	}
	return 0x820FCAC4;
} // Block from 820FCABCh-820FCAC4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FCAC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCAC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCAC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCAC4);
		  /* 820FCAC4h */ case    0:  		/* li R3, 1 */
		/* 820FCAC4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FCAC4h case    0:*/		return 0x820FCAC8;
		  /* 820FCAC8h */ case    1:  		/* b 16 */
		/* 820FCAC8h case    1:*/		return 0x820FCAD8;
		/* 820FCAC8h case    1:*/		return 0x820FCACC;
	}
	return 0x820FCACC;
} // Block from 820FCAC4h-820FCACCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FCACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCACC);
		  /* 820FCACCh */ case    0:  		/* lwz R3, <#[R10 + 12]> */
		/* 820FCACCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x0000000C) );
		/* 820FCACCh case    0:*/		return 0x820FCAD0;
		  /* 820FCAD0h */ case    1:  		/* b 8 */
		/* 820FCAD0h case    1:*/		return 0x820FCAD8;
		/* 820FCAD0h case    1:*/		return 0x820FCAD4;
	}
	return 0x820FCAD4;
} // Block from 820FCACCh-820FCAD4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FCAD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCAD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCAD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCAD4);
		  /* 820FCAD4h */ case    0:  		/* li R3, 0 */
		/* 820FCAD4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FCAD4h case    0:*/		return 0x820FCAD8;
	}
	return 0x820FCAD8;
} // Block from 820FCAD4h-820FCAD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FCAD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCAD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCAD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCAD8);
		  /* 820FCAD8h */ case    0:  		/* mullw R11, R3, R4 */
		/* 820FCAD8h case    0:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R3,regs.R4);
		/* 820FCAD8h case    0:*/		return 0x820FCADC;
		  /* 820FCADCh */ case    1:  		/* lwz R9, <#[R10 + 12]> */
		/* 820FCADCh case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		/* 820FCADCh case    1:*/		return 0x820FCAE0;
		  /* 820FCAE0h */ case    2:  		/* add R8, R11, R3 */
		/* 820FCAE0h case    2:*/		cpu::op::add<0>(regs,&regs.R8,regs.R11,regs.R3);
		/* 820FCAE0h case    2:*/		return 0x820FCAE4;
		  /* 820FCAE4h */ case    3:  		/* cmplw CR6, R8, R9 */
		/* 820FCAE4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 820FCAE4h case    3:*/		return 0x820FCAE8;
		  /* 820FCAE8h */ case    4:  		/* bc 4, CR6_GT, 28 */
		/* 820FCAE8h case    4:*/		if ( !regs.CR[6].gt ) { return 0x820FCB04;  }
		/* 820FCAE8h case    4:*/		return 0x820FCAEC;
		  /* 820FCAECh */ case    5:  		/* cmplwi CR6, R5, 0 */
		/* 820FCAECh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820FCAECh case    5:*/		return 0x820FCAF0;
		  /* 820FCAF0h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 820FCAF0h case    6:*/		if ( regs.CR[6].eq ) { return 0x820FCAFC;  }
		/* 820FCAF0h case    6:*/		return 0x820FCAF4;
		  /* 820FCAF4h */ case    7:  		/* li R11, 0 */
		/* 820FCAF4h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820FCAF4h case    7:*/		return 0x820FCAF8;
		  /* 820FCAF8h */ case    8:  		/* stw R11, <#[R5]> */
		/* 820FCAF8h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820FCAF8h case    8:*/		return 0x820FCAFC;
	}
	return 0x820FCAFC;
} // Block from 820FCAD8h-820FCAFCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820FCAFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCAFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCAFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCAFC);
		  /* 820FCAFCh */ case    0:  		/* li R3, 0 */
		/* 820FCAFCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FCAFCh case    0:*/		return 0x820FCB00;
		  /* 820FCB00h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820FCB00h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FCB00h case    1:*/		return 0x820FCB04;
	}
	return 0x820FCB04;
} // Block from 820FCAFCh-820FCB04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FCB04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCB04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCB04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCB04);
		  /* 820FCB04h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 820FCB04h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820FCB04h case    0:*/		return 0x820FCB08;
	}
	return 0x820FCB08;
} // Block from 820FCB04h-820FCB08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FCB08h
// Function '?IsSpecial@CInstruction@D3DXShader@@QAAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCB08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCB08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCB08);
		  /* 820FCB08h */ case    0:  		/* bclr 12, CR6_EQ */
		/* 820FCB08h case    0:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820FCB08h case    0:*/		return 0x820FCB0C;
	}
	return 0x820FCB0C;
} // Block from 820FCB08h-820FCB0Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FCB0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCB0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCB0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCB0C);
		  /* 820FCB0Ch */ case    0:  		/* lwz R10, <#[R10 + 16]> */
		/* 820FCB0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000010) );
		/* 820FCB0Ch case    0:*/		return 0x820FCB10;
		  /* 820FCB10h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FCB10h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FCB10h case    1:*/		return 0x820FCB14;
		  /* 820FCB14h */ case    2:  		/* add R11, R11, R10 */
		/* 820FCB14h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820FCB14h case    2:*/		return 0x820FCB18;
		  /* 820FCB18h */ case    3:  		/* stw R11, <#[R5]> */
		/* 820FCB18h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820FCB18h case    3:*/		return 0x820FCB1C;
		  /* 820FCB1Ch */ case    4:  		/* bclr 20, CR0_LT */
		/* 820FCB1Ch case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FCB1Ch case    4:*/		return 0x820FCB20;
	}
	return 0x820FCB20;
} // Block from 820FCB0Ch-820FCB20h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FCB20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCB20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCB20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCB20);
		  /* 820FCB20h */ case    0:  		/* mr R9, R3 */
		/* 820FCB20h case    0:*/		regs.R9 = regs.R3;
		/* 820FCB20h case    0:*/		return 0x820FCB24;
		  /* 820FCB24h */ case    1:  		/* stfd FR1, <#[R3 + 32]> */
		/* 820FCB24h case    1:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R3 + 0x00000020) );
		/* 820FCB24h case    1:*/		return 0x820FCB28;
		  /* 820FCB28h */ case    2:  		/* li R11, -1 */
		/* 820FCB28h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820FCB28h case    2:*/		return 0x820FCB2C;
		  /* 820FCB2Ch */ case    3:  		/* stfd FR1, <#[R3 + 40]> */
		/* 820FCB2Ch case    3:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R3 + 0x00000028) );
		/* 820FCB2Ch case    3:*/		return 0x820FCB30;
		  /* 820FCB30h */ case    4:  		/* li R10, 0 */
		/* 820FCB30h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820FCB30h case    4:*/		return 0x820FCB34;
		  /* 820FCB34h */ case    5:  		/* stw R4, <#[R3 + 4]> */
		/* 820FCB34h case    5:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 820FCB34h case    5:*/		return 0x820FCB38;
		  /* 820FCB38h */ case    6:  		/* li R8, 1 */
		/* 820FCB38h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820FCB38h case    6:*/		return 0x820FCB3C;
		  /* 820FCB3Ch */ case    7:  		/* stw R11, <#[R3 + 8]> */
		/* 820FCB3Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820FCB3Ch case    7:*/		return 0x820FCB40;
		  /* 820FCB40h */ case    8:  		/* li R3, 0 */
		/* 820FCB40h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FCB40h case    8:*/		return 0x820FCB44;
		  /* 820FCB44h */ case    9:  		/* stw R5, <#[R9 + 12]> */
		/* 820FCB44h case    9:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R9 + 0x0000000C) );
		/* 820FCB44h case    9:*/		return 0x820FCB48;
		  /* 820FCB48h */ case   10:  		/* stw R6, <#[R9 + 16]> */
		/* 820FCB48h case   10:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R9 + 0x00000010) );
		/* 820FCB48h case   10:*/		return 0x820FCB4C;
		  /* 820FCB4Ch */ case   11:  		/* stw R11, <#[R9 + 20]> */
		/* 820FCB4Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000014) );
		/* 820FCB4Ch case   11:*/		return 0x820FCB50;
	}
	return 0x820FCB50;
} // Block from 820FCB20h-820FCB50h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820FCB50h
// Function '?IsScalar@CInstruction@D3DXShader@@QAAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCB50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCB50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCB50);
		  /* 820FCB50h */ case    0:  		/* stw R8, <#[R9 + 24]> */
		/* 820FCB50h case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000018) );
		/* 820FCB50h case    0:*/		return 0x820FCB54;
		  /* 820FCB54h */ case    1:  		/* stw R10, <#[R9]> */
		/* 820FCB54h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 820FCB54h case    1:*/		return 0x820FCB58;
		  /* 820FCB58h */ case    2:  		/* stw R11, <#[R9 + 48]> */
		/* 820FCB58h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000030) );
		/* 820FCB58h case    2:*/		return 0x820FCB5C;
		  /* 820FCB5Ch */ case    3:  		/* stw R11, <#[R9 + 52]> */
		/* 820FCB5Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000034) );
		/* 820FCB5Ch case    3:*/		return 0x820FCB60;
		  /* 820FCB60h */ case    4:  		/* stw R11, <#[R9 + 56]> */
		/* 820FCB60h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000038) );
		/* 820FCB60h case    4:*/		return 0x820FCB64;
		  /* 820FCB64h */ case    5:  		/* stw R11, <#[R9 + 64]> */
		/* 820FCB64h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000040) );
		/* 820FCB64h case    5:*/		return 0x820FCB68;
		  /* 820FCB68h */ case    6:  		/* stw R10, <#[R9 + 60]> */
		/* 820FCB68h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x0000003C) );
		/* 820FCB68h case    6:*/		return 0x820FCB6C;
		  /* 820FCB6Ch */ case    7:  		/* stw R11, <#[R9 + 68]> */
		/* 820FCB6Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000044) );
		/* 820FCB6Ch case    7:*/		return 0x820FCB70;
		  /* 820FCB70h */ case    8:  		/* stw R11, <#[R9 + 72]> */
		/* 820FCB70h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000048) );
		/* 820FCB70h case    8:*/		return 0x820FCB74;
		  /* 820FCB74h */ case    9:  		/* stw R11, <#[R9 + 76]> */
		/* 820FCB74h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x0000004C) );
		/* 820FCB74h case    9:*/		return 0x820FCB78;
		  /* 820FCB78h */ case   10:  		/* stw R11, <#[R9 + 80]> */
		/* 820FCB78h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000050) );
		/* 820FCB78h case   10:*/		return 0x820FCB7C;
		  /* 820FCB7Ch */ case   11:  		/* stw R11, <#[R9 + 84]> */
		/* 820FCB7Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000054) );
		/* 820FCB7Ch case   11:*/		return 0x820FCB80;
		  /* 820FCB80h */ case   12:  		/* stw R11, <#[R9 + 88]> */
		/* 820FCB80h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000058) );
		/* 820FCB80h case   12:*/		return 0x820FCB84;
		  /* 820FCB84h */ case   13:  		/* stw R10, <#[R9 + 92]> */
		/* 820FCB84h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x0000005C) );
		/* 820FCB84h case   13:*/		return 0x820FCB88;
		  /* 820FCB88h */ case   14:  		/* stw R10, <#[R9 + 96]> */
		/* 820FCB88h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000060) );
		/* 820FCB88h case   14:*/		return 0x820FCB8C;
		  /* 820FCB8Ch */ case   15:  		/* stw R10, <#[R9 + 100]> */
		/* 820FCB8Ch case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000064) );
		/* 820FCB8Ch case   15:*/		return 0x820FCB90;
		  /* 820FCB90h */ case   16:  		/* stw R10, <#[R9 + 104]> */
		/* 820FCB90h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000068) );
		/* 820FCB90h case   16:*/		return 0x820FCB94;
		  /* 820FCB94h */ case   17:  		/* stw R11, <#[R9 + 108]> */
		/* 820FCB94h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x0000006C) );
		/* 820FCB94h case   17:*/		return 0x820FCB98;
	}
	return 0x820FCB98;
} // Block from 820FCB50h-820FCB98h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820FCB98h
// Function '?IsSymetric@CInstruction@D3DXShader@@QAAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCB98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCB98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCB98);
		  /* 820FCB98h */ case    0:  		/* stw R10, <#[R9 + 112]> */
		/* 820FCB98h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000070) );
		/* 820FCB98h case    0:*/		return 0x820FCB9C;
		  /* 820FCB9Ch */ case    1:  		/* stw R11, <#[R9 + 116]> */
		/* 820FCB9Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000074) );
		/* 820FCB9Ch case    1:*/		return 0x820FCBA0;
		  /* 820FCBA0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820FCBA0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FCBA0h case    2:*/		return 0x820FCBA4;
	}
	return 0x820FCBA4;
} // Block from 820FCB98h-820FCBA4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FCBA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCBA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCBA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCBA4);
		  /* 820FCBA4h */ case    0:  		/* nop */
		/* 820FCBA4h case    0:*/		cpu::op::nop();
		/* 820FCBA4h case    0:*/		return 0x820FCBA8;
	}
	return 0x820FCBA8;
} // Block from 820FCBA4h-820FCBA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FCBA8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCBA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCBA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCBA8);
		  /* 820FCBA8h */ case    0:  		/* mr R11, R3 */
		/* 820FCBA8h case    0:*/		regs.R11 = regs.R3;
		/* 820FCBA8h case    0:*/		return 0x820FCBAC;
		  /* 820FCBACh */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 820FCBACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820FCBACh case    1:*/		return 0x820FCBB0;
		  /* 820FCBB0h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820FCBB0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FCBC0;  }
		/* 820FCBB0h case    2:*/		return 0x820FCBB4;
		  /* 820FCBB4h */ case    3:  		/* lis R3, -32768 */
		/* 820FCBB4h case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820FCBB4h case    3:*/		return 0x820FCBB8;
		  /* 820FCBB8h */ case    4:  		/* ori R3, R3, 16389 */
		/* 820FCBB8h case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820FCBB8h case    4:*/		return 0x820FCBBC;
		  /* 820FCBBCh */ case    5:  		/* bclr 20, CR0_LT */
		/* 820FCBBCh case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FCBBCh case    5:*/		return 0x820FCBC0;
	}
	return 0x820FCBC0;
} // Block from 820FCBA8h-820FCBC0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FCBC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCBC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCBC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCBC0);
		  /* 820FCBC0h */ case    0:  		/* lwz R10, <#[R4 + 4]> */
		/* 820FCBC0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 820FCBC0h case    0:*/		return 0x820FCBC4;
		  /* 820FCBC4h */ case    1:  		/* li R3, 0 */
		/* 820FCBC4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FCBC4h case    1:*/		return 0x820FCBC8;
		  /* 820FCBC8h */ case    2:  		/* stw R10, <#[R11 + 4]> */
		/* 820FCBC8h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820FCBC8h case    2:*/		return 0x820FCBCC;
		  /* 820FCBCCh */ case    3:  		/* lwz R10, <#[R4 + 8]> */
		/* 820FCBCCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 820FCBCCh case    3:*/		return 0x820FCBD0;
		  /* 820FCBD0h */ case    4:  		/* stw R10, <#[R11 + 8]> */
		/* 820FCBD0h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820FCBD0h case    4:*/		return 0x820FCBD4;
		  /* 820FCBD4h */ case    5:  		/* lwz R10, <#[R4 + 12]> */
		/* 820FCBD4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000000C) );
		/* 820FCBD4h case    5:*/		return 0x820FCBD8;
		  /* 820FCBD8h */ case    6:  		/* stw R10, <#[R11 + 12]> */
		/* 820FCBD8h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820FCBD8h case    6:*/		return 0x820FCBDC;
		  /* 820FCBDCh */ case    7:  		/* lwz R10, <#[R4 + 16]> */
		/* 820FCBDCh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000010) );
		/* 820FCBDCh case    7:*/		return 0x820FCBE0;
		  /* 820FCBE0h */ case    8:  		/* stw R10, <#[R11 + 16]> */
		/* 820FCBE0h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 820FCBE0h case    8:*/		return 0x820FCBE4;
		  /* 820FCBE4h */ case    9:  		/* lwz R10, <#[R4 + 20]> */
		/* 820FCBE4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000014) );
		/* 820FCBE4h case    9:*/		return 0x820FCBE8;
	}
	return 0x820FCBE8;
} // Block from 820FCBC0h-820FCBE8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FCBE8h
// Function '?IsCopy@CInstruction@D3DXShader@@QAAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCBE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCBE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCBE8);
		  /* 820FCBE8h */ case    0:  		/* stw R10, <#[R11 + 20]> */
		/* 820FCBE8h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 820FCBE8h case    0:*/		return 0x820FCBEC;
		  /* 820FCBECh */ case    1:  		/* lwz R10, <#[R4 + 24]> */
		/* 820FCBECh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000018) );
		/* 820FCBECh case    1:*/		return 0x820FCBF0;
		  /* 820FCBF0h */ case    2:  		/* stw R10, <#[R11 + 24]> */
		/* 820FCBF0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 820FCBF0h case    2:*/		return 0x820FCBF4;
		  /* 820FCBF4h */ case    3:  		/* lfd FR0, <#[R4 + 32]> */
		/* 820FCBF4h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R4 + 0x00000020) );
		/* 820FCBF4h case    3:*/		return 0x820FCBF8;
		  /* 820FCBF8h */ case    4:  		/* stfd FR0, <#[R11 + 32]> */
		/* 820FCBF8h case    4:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000020) );
		/* 820FCBF8h case    4:*/		return 0x820FCBFC;
		  /* 820FCBFCh */ case    5:  		/* lfd FR0, <#[R4 + 40]> */
		/* 820FCBFCh case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R4 + 0x00000028) );
		/* 820FCBFCh case    5:*/		return 0x820FCC00;
		  /* 820FCC00h */ case    6:  		/* stfd FR0, <#[R11 + 40]> */
		/* 820FCC00h case    6:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000028) );
		/* 820FCC00h case    6:*/		return 0x820FCC04;
		  /* 820FCC04h */ case    7:  		/* lwz R10, <#[R4]> */
		/* 820FCC04h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 820FCC04h case    7:*/		return 0x820FCC08;
		  /* 820FCC08h */ case    8:  		/* stw R10, <#[R11]> */
		/* 820FCC08h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820FCC08h case    8:*/		return 0x820FCC0C;
		  /* 820FCC0Ch */ case    9:  		/* lwz R10, <#[R4 + 48]> */
		/* 820FCC0Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000030) );
		/* 820FCC0Ch case    9:*/		return 0x820FCC10;
		  /* 820FCC10h */ case   10:  		/* stw R10, <#[R11 + 48]> */
		/* 820FCC10h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 820FCC10h case   10:*/		return 0x820FCC14;
		  /* 820FCC14h */ case   11:  		/* lwz R10, <#[R4 + 52]> */
		/* 820FCC14h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000034) );
		/* 820FCC14h case   11:*/		return 0x820FCC18;
		  /* 820FCC18h */ case   12:  		/* stw R10, <#[R11 + 52]> */
		/* 820FCC18h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000034) );
		/* 820FCC18h case   12:*/		return 0x820FCC1C;
		  /* 820FCC1Ch */ case   13:  		/* lwz R10, <#[R4 + 56]> */
		/* 820FCC1Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000038) );
		/* 820FCC1Ch case   13:*/		return 0x820FCC20;
		  /* 820FCC20h */ case   14:  		/* stw R10, <#[R11 + 56]> */
		/* 820FCC20h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000038) );
		/* 820FCC20h case   14:*/		return 0x820FCC24;
		  /* 820FCC24h */ case   15:  		/* lwz R10, <#[R4 + 64]> */
		/* 820FCC24h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000040) );
		/* 820FCC24h case   15:*/		return 0x820FCC28;
		  /* 820FCC28h */ case   16:  		/* stw R10, <#[R11 + 64]> */
		/* 820FCC28h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000040) );
		/* 820FCC28h case   16:*/		return 0x820FCC2C;
		  /* 820FCC2Ch */ case   17:  		/* lwz R10, <#[R4 + 60]> */
		/* 820FCC2Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000003C) );
		/* 820FCC2Ch case   17:*/		return 0x820FCC30;
		  /* 820FCC30h */ case   18:  		/* stw R10, <#[R11 + 60]> */
		/* 820FCC30h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000003C) );
		/* 820FCC30h case   18:*/		return 0x820FCC34;
		  /* 820FCC34h */ case   19:  		/* lwz R10, <#[R4 + 68]> */
		/* 820FCC34h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000044) );
		/* 820FCC34h case   19:*/		return 0x820FCC38;
		  /* 820FCC38h */ case   20:  		/* stw R10, <#[R11 + 68]> */
		/* 820FCC38h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000044) );
		/* 820FCC38h case   20:*/		return 0x820FCC3C;
		  /* 820FCC3Ch */ case   21:  		/* lwz R10, <#[R4 + 72]> */
		/* 820FCC3Ch case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000048) );
		/* 820FCC3Ch case   21:*/		return 0x820FCC40;
		  /* 820FCC40h */ case   22:  		/* stw R10, <#[R11 + 72]> */
		/* 820FCC40h case   22:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000048) );
		/* 820FCC40h case   22:*/		return 0x820FCC44;
		  /* 820FCC44h */ case   23:  		/* lwz R10, <#[R4 + 76]> */
		/* 820FCC44h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000004C) );
		/* 820FCC44h case   23:*/		return 0x820FCC48;
	}
	return 0x820FCC48;
} // Block from 820FCBE8h-820FCC48h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820FCC48h
// Function '?IsMacro@CInstruction@D3DXShader@@QAAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCC48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCC48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCC48);
		  /* 820FCC48h */ case    0:  		/* stw R10, <#[R11 + 76]> */
		/* 820FCC48h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000004C) );
		/* 820FCC48h case    0:*/		return 0x820FCC4C;
		  /* 820FCC4Ch */ case    1:  		/* lwz R10, <#[R4 + 80]> */
		/* 820FCC4Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000050) );
		/* 820FCC4Ch case    1:*/		return 0x820FCC50;
		  /* 820FCC50h */ case    2:  		/* stw R10, <#[R11 + 80]> */
		/* 820FCC50h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000050) );
		/* 820FCC50h case    2:*/		return 0x820FCC54;
		  /* 820FCC54h */ case    3:  		/* lwz R10, <#[R4 + 84]> */
		/* 820FCC54h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000054) );
		/* 820FCC54h case    3:*/		return 0x820FCC58;
		  /* 820FCC58h */ case    4:  		/* stw R10, <#[R11 + 84]> */
		/* 820FCC58h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000054) );
		/* 820FCC58h case    4:*/		return 0x820FCC5C;
		  /* 820FCC5Ch */ case    5:  		/* lwz R10, <#[R4 + 88]> */
		/* 820FCC5Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000058) );
		/* 820FCC5Ch case    5:*/		return 0x820FCC60;
		  /* 820FCC60h */ case    6:  		/* stw R10, <#[R11 + 88]> */
		/* 820FCC60h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000058) );
		/* 820FCC60h case    6:*/		return 0x820FCC64;
		  /* 820FCC64h */ case    7:  		/* lwz R10, <#[R4 + 92]> */
		/* 820FCC64h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000005C) );
		/* 820FCC64h case    7:*/		return 0x820FCC68;
		  /* 820FCC68h */ case    8:  		/* stw R10, <#[R11 + 92]> */
		/* 820FCC68h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000005C) );
		/* 820FCC68h case    8:*/		return 0x820FCC6C;
		  /* 820FCC6Ch */ case    9:  		/* lwz R10, <#[R4 + 96]> */
		/* 820FCC6Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000060) );
		/* 820FCC6Ch case    9:*/		return 0x820FCC70;
		  /* 820FCC70h */ case   10:  		/* stw R10, <#[R11 + 96]> */
		/* 820FCC70h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000060) );
		/* 820FCC70h case   10:*/		return 0x820FCC74;
		  /* 820FCC74h */ case   11:  		/* lwz R10, <#[R4 + 100]> */
		/* 820FCC74h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000064) );
		/* 820FCC74h case   11:*/		return 0x820FCC78;
		  /* 820FCC78h */ case   12:  		/* stw R10, <#[R11 + 100]> */
		/* 820FCC78h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000064) );
		/* 820FCC78h case   12:*/		return 0x820FCC7C;
		  /* 820FCC7Ch */ case   13:  		/* lwz R10, <#[R4 + 104]> */
		/* 820FCC7Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000068) );
		/* 820FCC7Ch case   13:*/		return 0x820FCC80;
		  /* 820FCC80h */ case   14:  		/* stw R10, <#[R11 + 104]> */
		/* 820FCC80h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000068) );
		/* 820FCC80h case   14:*/		return 0x820FCC84;
		  /* 820FCC84h */ case   15:  		/* lwz R10, <#[R4 + 108]> */
		/* 820FCC84h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000006C) );
		/* 820FCC84h case   15:*/		return 0x820FCC88;
		  /* 820FCC88h */ case   16:  		/* stw R10, <#[R11 + 108]> */
		/* 820FCC88h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000006C) );
		/* 820FCC88h case   16:*/		return 0x820FCC8C;
		  /* 820FCC8Ch */ case   17:  		/* lwz R10, <#[R4 + 112]> */
		/* 820FCC8Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000070) );
		/* 820FCC8Ch case   17:*/		return 0x820FCC90;
		  /* 820FCC90h */ case   18:  		/* stw R10, <#[R11 + 112]> */
		/* 820FCC90h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000070) );
		/* 820FCC90h case   18:*/		return 0x820FCC94;
		  /* 820FCC94h */ case   19:  		/* lwz R10, <#[R4 + 116]> */
		/* 820FCC94h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000074) );
		/* 820FCC94h case   19:*/		return 0x820FCC98;
		  /* 820FCC98h */ case   20:  		/* stw R10, <#[R11 + 116]> */
		/* 820FCC98h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000074) );
		/* 820FCC98h case   20:*/		return 0x820FCC9C;
		  /* 820FCC9Ch */ case   21:  		/* bclr 20, CR0_LT */
		/* 820FCC9Ch case   21:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FCC9Ch case   21:*/		return 0x820FCCA0;
	}
	return 0x820FCCA0;
} // Block from 820FCC48h-820FCCA0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820FCCA0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCCA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCCA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCCA0);
		  /* 820FCCA0h */ case    0:  		/* mr R11, R3 */
		/* 820FCCA0h case    0:*/		regs.R11 = regs.R3;
		/* 820FCCA0h case    0:*/		return 0x820FCCA4;
		  /* 820FCCA4h */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 820FCCA4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820FCCA4h case    1:*/		return 0x820FCCA8;
		  /* 820FCCA8h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820FCCA8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FCCB8;  }
		/* 820FCCA8h case    2:*/		return 0x820FCCAC;
		  /* 820FCCACh */ case    3:  		/* lis R3, -32768 */
		/* 820FCCACh case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820FCCACh case    3:*/		return 0x820FCCB0;
		  /* 820FCCB0h */ case    4:  		/* ori R3, R3, 16389 */
		/* 820FCCB0h case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820FCCB0h case    4:*/		return 0x820FCCB4;
		  /* 820FCCB4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820FCCB4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FCCB4h case    5:*/		return 0x820FCCB8;
	}
	return 0x820FCCB8;
} // Block from 820FCCA0h-820FCCB8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FCCB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCCB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCCB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCCB8);
		  /* 820FCCB8h */ case    0:  		/* lwz R10, <#[R4 + 96]> */
		/* 820FCCB8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000060) );
		/* 820FCCB8h case    0:*/		return 0x820FCCBC;
		  /* 820FCCBCh */ case    1:  		/* li R3, 0 */
		/* 820FCCBCh case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FCCBCh case    1:*/		return 0x820FCCC0;
		  /* 820FCCC0h */ case    2:  		/* stw R10, <#[R11 + 96]> */
		/* 820FCCC0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000060) );
		/* 820FCCC0h case    2:*/		return 0x820FCCC4;
		  /* 820FCCC4h */ case    3:  		/* lwz R10, <#[R4 + 100]> */
		/* 820FCCC4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000064) );
		/* 820FCCC4h case    3:*/		return 0x820FCCC8;
		  /* 820FCCC8h */ case    4:  		/* stw R10, <#[R11 + 100]> */
		/* 820FCCC8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000064) );
		/* 820FCCC8h case    4:*/		return 0x820FCCCC;
		  /* 820FCCCCh */ case    5:  		/* lwz R10, <#[R4 + 104]> */
		/* 820FCCCCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000068) );
		/* 820FCCCCh case    5:*/		return 0x820FCCD0;
		  /* 820FCCD0h */ case    6:  		/* stw R10, <#[R11 + 104]> */
		/* 820FCCD0h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000068) );
		/* 820FCCD0h case    6:*/		return 0x820FCCD4;
		  /* 820FCCD4h */ case    7:  		/* lwz R10, <#[R4 + 108]> */
		/* 820FCCD4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000006C) );
		/* 820FCCD4h case    7:*/		return 0x820FCCD8;
	}
	return 0x820FCCD8;
} // Block from 820FCCB8h-820FCCD8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820FCCD8h
// Function '?IsLoop@CInstruction@D3DXShader@@QAAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCCD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCCD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCCD8);
		  /* 820FCCD8h */ case    0:  		/* stw R10, <#[R11 + 108]> */
		/* 820FCCD8h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000006C) );
		/* 820FCCD8h case    0:*/		return 0x820FCCDC;
		  /* 820FCCDCh */ case    1:  		/* lwz R10, <#[R4 + 112]> */
		/* 820FCCDCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000070) );
		/* 820FCCDCh case    1:*/		return 0x820FCCE0;
		  /* 820FCCE0h */ case    2:  		/* stw R10, <#[R11 + 112]> */
		/* 820FCCE0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000070) );
		/* 820FCCE0h case    2:*/		return 0x820FCCE4;
		  /* 820FCCE4h */ case    3:  		/* lwz R10, <#[R4 + 116]> */
		/* 820FCCE4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000074) );
		/* 820FCCE4h case    3:*/		return 0x820FCCE8;
		  /* 820FCCE8h */ case    4:  		/* stw R10, <#[R11 + 116]> */
		/* 820FCCE8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000074) );
		/* 820FCCE8h case    4:*/		return 0x820FCCEC;
		  /* 820FCCECh */ case    5:  		/* bclr 20, CR0_LT */
		/* 820FCCECh case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FCCECh case    5:*/		return 0x820FCCF0;
	}
	return 0x820FCCF0;
} // Block from 820FCCD8h-820FCCF0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FCCF0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCCF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCCF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCCF0);
		  /* 820FCCF0h */ case    0:  		/* mfspr R12, LR */
		/* 820FCCF0h case    0:*/		regs.R12 = regs.LR;
		/* 820FCCF0h case    0:*/		return 0x820FCCF4;
		  /* 820FCCF4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820FCCF4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FCCF4h case    1:*/		return 0x820FCCF8;
		  /* 820FCCF8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820FCCF8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FCCF8h case    2:*/		return 0x820FCCFC;
		  /* 820FCCFCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820FCCFCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820FCCFCh case    3:*/		return 0x820FCD00;
		  /* 820FCD00h */ case    4:  		/* mr R31, R3 */
		/* 820FCD00h case    4:*/		regs.R31 = regs.R3;
		/* 820FCD00h case    4:*/		return 0x820FCD04;
		  /* 820FCD04h */ case    5:  		/* bl -195796 */
		/* 820FCD04h case    5:*/		regs.LR = 0x820FCD08; return 0x820CD030;
		/* 820FCD04h case    5:*/		return 0x820FCD08;
		  /* 820FCD08h */ case    6:  		/* li R11, 0 */
		/* 820FCD08h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820FCD08h case    6:*/		return 0x820FCD0C;
		  /* 820FCD0Ch */ case    7:  		/* stw R31, <#[R3 + 8]> */
		/* 820FCD0Ch case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000008) );
		/* 820FCD0Ch case    7:*/		return 0x820FCD10;
		  /* 820FCD10h */ case    8:  		/* stw R11, <#[R3 + 4]> */
		/* 820FCD10h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820FCD10h case    8:*/		return 0x820FCD14;
		  /* 820FCD14h */ case    9:  		/* addi R1, R1, 96 */
		/* 820FCD14h case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820FCD14h case    9:*/		return 0x820FCD18;
		  /* 820FCD18h */ case   10:  		/* lwz R12, <#[R1 - 8]> */
		/* 820FCD18h case   10:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FCD18h case   10:*/		return 0x820FCD1C;
		  /* 820FCD1Ch */ case   11:  		/* mtspr LR, R12 */
		/* 820FCD1Ch case   11:*/		regs.LR = regs.R12;
		/* 820FCD1Ch case   11:*/		return 0x820FCD20;
		  /* 820FCD20h */ case   12:  		/* ld R31, <#[R1 - 16]> */
		/* 820FCD20h case   12:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FCD20h case   12:*/		return 0x820FCD24;
		  /* 820FCD24h */ case   13:  		/* bclr 20, CR0_LT */
		/* 820FCD24h case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FCD24h case   13:*/		return 0x820FCD28;
	}
	return 0x820FCD28;
} // Block from 820FCCF0h-820FCD28h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820FCD28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCD28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCD28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCD28);
		  /* 820FCD28h */ case    0:  		/* mfspr R12, LR */
		/* 820FCD28h case    0:*/		regs.R12 = regs.LR;
		/* 820FCD28h case    0:*/		return 0x820FCD2C;
		  /* 820FCD2Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820FCD2Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FCD2Ch case    1:*/		return 0x820FCD30;
		  /* 820FCD30h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820FCD30h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FCD30h case    2:*/		return 0x820FCD34;
		  /* 820FCD34h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820FCD34h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820FCD34h case    3:*/		return 0x820FCD38;
		  /* 820FCD38h */ case    4:  		/* mr R31, R3 */
		/* 820FCD38h case    4:*/		regs.R31 = regs.R3;
		/* 820FCD38h case    4:*/		return 0x820FCD3C;
		  /* 820FCD3Ch */ case    5:  		/* bl -195852 */
		/* 820FCD3Ch case    5:*/		regs.LR = 0x820FCD40; return 0x820CD030;
		/* 820FCD3Ch case    5:*/		return 0x820FCD40;
		  /* 820FCD40h */ case    6:  		/* mr R11, R3 */
		/* 820FCD40h case    6:*/		regs.R11 = regs.R3;
		/* 820FCD40h case    6:*/		return 0x820FCD44;
		  /* 820FCD44h */ case    7:  		/* lwz R3, <#[R3 + 4]> */
		/* 820FCD44h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000004) );
		/* 820FCD44h case    7:*/		return 0x820FCD48;
		  /* 820FCD48h */ case    8:  		/* cmplwi CR6, R3, 0 */
		/* 820FCD48h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820FCD48h case    8:*/		return 0x820FCD4C;
		  /* 820FCD4Ch */ case    9:  		/* bc 12, CR6_EQ, 16 */
		/* 820FCD4Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820FCD5C;  }
		/* 820FCD4Ch case    9:*/		return 0x820FCD50;
		  /* 820FCD50h */ case   10:  		/* lwz R10, <#[R3 + 120]> */
		/* 820FCD50h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000078) );
		/* 820FCD50h case   10:*/		return 0x820FCD54;
		  /* 820FCD54h */ case   11:  		/* stw R10, <#[R11 + 4]> */
		/* 820FCD54h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820FCD54h case   11:*/		return 0x820FCD58;
		  /* 820FCD58h */ case   12:  		/* b 20 */
		/* 820FCD58h case   12:*/		return 0x820FCD6C;
		/* 820FCD58h case   12:*/		return 0x820FCD5C;
	}
	return 0x820FCD5C;
} // Block from 820FCD28h-820FCD5Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FCD5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCD5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCD5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCD5C);
		  /* 820FCD5Ch */ case    0:  		/* li R5, 16 */
		/* 820FCD5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820FCD5Ch case    0:*/		return 0x820FCD60;
		  /* 820FCD60h */ case    1:  		/* lwz R3, <#[R11 + 8]> */
		/* 820FCD60h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000008) );
		/* 820FCD60h case    1:*/		return 0x820FCD64;
		  /* 820FCD64h */ case    2:  		/* mr R4, R31 */
		/* 820FCD64h case    2:*/		regs.R4 = regs.R31;
		/* 820FCD64h case    2:*/		return 0x820FCD68;
		  /* 820FCD68h */ case    3:  		/* bl -212104 */
		/* 820FCD68h case    3:*/		regs.LR = 0x820FCD6C; return 0x820C90E0;
		/* 820FCD68h case    3:*/		return 0x820FCD6C;
	}
	return 0x820FCD6C;
} // Block from 820FCD5Ch-820FCD6Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FCD6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCD6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCD6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCD6C);
		  /* 820FCD6Ch */ case    0:  		/* addi R1, R1, 96 */
		/* 820FCD6Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820FCD6Ch case    0:*/		return 0x820FCD70;
		  /* 820FCD70h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820FCD70h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FCD70h case    1:*/		return 0x820FCD74;
		  /* 820FCD74h */ case    2:  		/* mtspr LR, R12 */
		/* 820FCD74h case    2:*/		regs.LR = regs.R12;
		/* 820FCD74h case    2:*/		return 0x820FCD78;
		  /* 820FCD78h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820FCD78h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FCD78h case    3:*/		return 0x820FCD7C;
		  /* 820FCD7Ch */ case    4:  		/* bclr 20, CR0_LT */
		/* 820FCD7Ch case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FCD7Ch case    4:*/		return 0x820FCD80;
	}
	return 0x820FCD80;
} // Block from 820FCD6Ch-820FCD80h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FCD80h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCD80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCD80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCD80);
		  /* 820FCD80h */ case    0:  		/* mfspr R12, LR */
		/* 820FCD80h case    0:*/		regs.R12 = regs.LR;
		/* 820FCD80h case    0:*/		return 0x820FCD84;
		  /* 820FCD84h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820FCD84h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FCD84h case    1:*/		return 0x820FCD88;
		  /* 820FCD88h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820FCD88h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FCD88h case    2:*/		return 0x820FCD8C;
		  /* 820FCD8Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820FCD8Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820FCD8Ch case    3:*/		return 0x820FCD90;
		  /* 820FCD90h */ case    4:  		/* mr R31, R3 */
		/* 820FCD90h case    4:*/		regs.R31 = regs.R3;
		/* 820FCD90h case    4:*/		return 0x820FCD94;
		  /* 820FCD94h */ case    5:  		/* cmplwi CR6, R3, 0 */
		/* 820FCD94h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820FCD94h case    5:*/		return 0x820FCD98;
		  /* 820FCD98h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 820FCD98h case    6:*/		if ( regs.CR[6].eq ) { return 0x820FCDAC;  }
		/* 820FCD98h case    6:*/		return 0x820FCD9C;
		  /* 820FCD9Ch */ case    7:  		/* bl -195948 */
		/* 820FCD9Ch case    7:*/		regs.LR = 0x820FCDA0; return 0x820CD030;
		/* 820FCD9Ch case    7:*/		return 0x820FCDA0;
		  /* 820FCDA0h */ case    8:  		/* lwz R11, <#[R3 + 4]> */
		/* 820FCDA0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820FCDA0h case    8:*/		return 0x820FCDA4;
		  /* 820FCDA4h */ case    9:  		/* stw R11, <#[R31 + 120]> */
		/* 820FCDA4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000078) );
		/* 820FCDA4h case    9:*/		return 0x820FCDA8;
		  /* 820FCDA8h */ case   10:  		/* stw R31, <#[R3 + 4]> */
		/* 820FCDA8h case   10:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000004) );
		/* 820FCDA8h case   10:*/		return 0x820FCDAC;
	}
	return 0x820FCDAC;
} // Block from 820FCD80h-820FCDACh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FCDACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCDAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCDAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCDAC);
		  /* 820FCDACh */ case    0:  		/* addi R1, R1, 96 */
		/* 820FCDACh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820FCDACh case    0:*/		return 0x820FCDB0;
	}
	return 0x820FCDB0;
} // Block from 820FCDACh-820FCDB0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FCDB0h
// Function '?IsElse@CInstruction@D3DXShader@@QAAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCDB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCDB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCDB0);
		  /* 820FCDB0h */ case    0:  		/* lwz R12, <#[R1 - 8]> */
		/* 820FCDB0h case    0:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FCDB0h case    0:*/		return 0x820FCDB4;
		  /* 820FCDB4h */ case    1:  		/* mtspr LR, R12 */
		/* 820FCDB4h case    1:*/		regs.LR = regs.R12;
		/* 820FCDB4h case    1:*/		return 0x820FCDB8;
		  /* 820FCDB8h */ case    2:  		/* ld R31, <#[R1 - 16]> */
		/* 820FCDB8h case    2:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FCDB8h case    2:*/		return 0x820FCDBC;
		  /* 820FCDBCh */ case    3:  		/* bclr 20, CR0_LT */
		/* 820FCDBCh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FCDBCh case    3:*/		return 0x820FCDC0;
	}
	return 0x820FCDC0;
} // Block from 820FCDB0h-820FCDC0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FCDC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCDC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCDC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCDC0);
		  /* 820FCDC0h */ case    0:  		/* lis R10, -32254 */
		/* 820FCDC0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820FCDC0h case    0:*/		return 0x820FCDC4;
		  /* 820FCDC4h */ case    1:  		/* li R11, 0 */
		/* 820FCDC4h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820FCDC4h case    1:*/		return 0x820FCDC8;
		  /* 820FCDC8h */ case    2:  		/* addi R10, R10, -14412 */
		/* 820FCDC8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFC7B4);
		/* 820FCDC8h case    2:*/		return 0x820FCDCC;
		  /* 820FCDCCh */ case    3:  		/* stw R11, <#[R3 + 4]> */
		/* 820FCDCCh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820FCDCCh case    3:*/		return 0x820FCDD0;
		  /* 820FCDD0h */ case    4:  		/* stw R10, <#[R3]> */
		/* 820FCDD0h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820FCDD0h case    4:*/		return 0x820FCDD4;
		  /* 820FCDD4h */ case    5:  		/* stw R11, <#[R3 + 28]> */
		/* 820FCDD4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820FCDD4h case    5:*/		return 0x820FCDD8;
		  /* 820FCDD8h */ case    6:  		/* stw R11, <#[R3 + 16]> */
		/* 820FCDD8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820FCDD8h case    6:*/		return 0x820FCDDC;
		  /* 820FCDDCh */ case    7:  		/* stw R11, <#[R3 + 8]> */
		/* 820FCDDCh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820FCDDCh case    7:*/		return 0x820FCDE0;
		  /* 820FCDE0h */ case    8:  		/* stw R11, <#[R3 + 32]> */
		/* 820FCDE0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820FCDE0h case    8:*/		return 0x820FCDE4;
		  /* 820FCDE4h */ case    9:  		/* stw R11, <#[R3 + 20]> */
		/* 820FCDE4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820FCDE4h case    9:*/		return 0x820FCDE8;
		  /* 820FCDE8h */ case   10:  		/* stw R11, <#[R3 + 12]> */
		/* 820FCDE8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820FCDE8h case   10:*/		return 0x820FCDEC;
		  /* 820FCDECh */ case   11:  		/* stw R11, <#[R3 + 36]> */
		/* 820FCDECh case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820FCDECh case   11:*/		return 0x820FCDF0;
		  /* 820FCDF0h */ case   12:  		/* stw R11, <#[R3 + 24]> */
		/* 820FCDF0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820FCDF0h case   12:*/		return 0x820FCDF4;
		  /* 820FCDF4h */ case   13:  		/* bclr 20, CR0_LT */
		/* 820FCDF4h case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FCDF4h case   13:*/		return 0x820FCDF8;
	}
	return 0x820FCDF8;
} // Block from 820FCDC0h-820FCDF8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820FCDF8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCDF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCDF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCDF8);
		  /* 820FCDF8h */ case    0:  		/* lwz R10, <#[R4 + 4]> */
		/* 820FCDF8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 820FCDF8h case    0:*/		return 0x820FCDFC;
		  /* 820FCDFCh */ case    1:  		/* lis R11, -32254 */
		/* 820FCDFCh case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820FCDFCh case    1:*/		return 0x820FCE00;
		  /* 820FCE00h */ case    2:  		/* lwz R9, <#[R3 + 16]> */
		/* 820FCE00h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000010) );
		/* 820FCE00h case    2:*/		return 0x820FCE04;
		  /* 820FCE04h */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FCE04h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FCE04h case    3:*/		return 0x820FCE08;
		  /* 820FCE08h */ case    4:  		/* addi R3, R11, -14400 */
		/* 820FCE08h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFC7C0);
		/* 820FCE08h case    4:*/		return 0x820FCE0C;
		  /* 820FCE0Ch */ case    5:  		/* lwzx R11, <#[R10 + R9]> */
		/* 820FCE0Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820FCE0Ch case    5:*/		return 0x820FCE10;
	}
	return 0x820FCE10;
} // Block from 820FCDF8h-820FCE10h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FCE10h
// Function '?IsEndIf@CInstruction@D3DXShader@@QAAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCE10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCE10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCE10);
		  /* 820FCE10h */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 820FCE10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820FCE10h case    0:*/		return 0x820FCE14;
		  /* 820FCE14h */ case    1:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 820FCE14h case    1:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 820FCE14h case    1:*/		return 0x820FCE18;
		  /* 820FCE18h */ case    2:  		/* bclr 12, CR0_EQ */
		/* 820FCE18h case    2:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 820FCE18h case    2:*/		return 0x820FCE1C;
	}
	return 0x820FCE1C;
} // Block from 820FCE10h-820FCE1Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FCE1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCE1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCE1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCE1C);
		  /* 820FCE1Ch */ case    0:  		/* lis R11, -32254 */
		/* 820FCE1Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820FCE1Ch case    0:*/		return 0x820FCE20;
		  /* 820FCE20h */ case    1:  		/* addi R3, R11, -14408 */
		/* 820FCE20h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFC7B8);
		/* 820FCE20h case    1:*/		return 0x820FCE24;
		  /* 820FCE24h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820FCE24h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FCE24h case    2:*/		return 0x820FCE28;
	}
	return 0x820FCE28;
} // Block from 820FCE1Ch-820FCE28h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FCE28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCE28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCE28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCE28);
		  /* 820FCE28h */ case    0:  		/* mfspr R12, LR */
		/* 820FCE28h case    0:*/		regs.R12 = regs.LR;
		/* 820FCE28h case    0:*/		return 0x820FCE2C;
		  /* 820FCE2Ch */ case    1:  		/* bl -441300 */
		/* 820FCE2Ch case    1:*/		regs.LR = 0x820FCE30; return 0x82091258;
		/* 820FCE2Ch case    1:*/		return 0x820FCE30;
		  /* 820FCE30h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820FCE30h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820FCE30h case    2:*/		return 0x820FCE34;
		  /* 820FCE34h */ case    3:  		/* lwz R11, <#[R3 + 28]> */
		/* 820FCE34h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820FCE34h case    3:*/		return 0x820FCE38;
		  /* 820FCE38h */ case    4:  		/* mr R31, R3 */
		/* 820FCE38h case    4:*/		regs.R31 = regs.R3;
		/* 820FCE38h case    4:*/		return 0x820FCE3C;
		  /* 820FCE3Ch */ case    5:  		/* lwz R10, <#[R3 + 4]> */
		/* 820FCE3Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820FCE3Ch case    5:*/		return 0x820FCE40;
	}
	return 0x820FCE40;
} // Block from 820FCE28h-820FCE40h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FCE40h
// Function '?IsFlowControl@CInstruction@D3DXShader@@QAAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCE40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCE40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCE40);
		  /* 820FCE40h */ case    0:  		/* mr R28, R4 */
		/* 820FCE40h case    0:*/		regs.R28 = regs.R4;
		/* 820FCE40h case    0:*/		return 0x820FCE44;
		  /* 820FCE44h */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 820FCE44h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820FCE44h case    1:*/		return 0x820FCE48;
		  /* 820FCE48h */ case    2:  		/* bc 4, CR6_EQ, 144 */
		/* 820FCE48h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FCED8;  }
		/* 820FCE48h case    2:*/		return 0x820FCE4C;
		  /* 820FCE4Ch */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820FCE4Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FCE4Ch case    3:*/		return 0x820FCE50;
		  /* 820FCE50h */ case    4:  		/* rlwinm R29, R11, 1, 0, 30 */
		/* 820FCE50h case    4:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R29,regs.R11);
		/* 820FCE50h case    4:*/		return 0x820FCE54;
		  /* 820FCE54h */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 820FCE54h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820FCE5C;  }
		/* 820FCE54h case    5:*/		return 0x820FCE58;
		  /* 820FCE58h */ case    6:  		/* li R29, 16 */
		/* 820FCE58h case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x10);
		/* 820FCE58h case    6:*/		return 0x820FCE5C;
	}
	return 0x820FCE5C;
} // Block from 820FCE40h-820FCE5Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820FCE5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCE5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCE5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCE5C);
		  /* 820FCE5Ch */ case    0:  		/* lis R4, 9345 */
		/* 820FCE5Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820FCE5Ch case    0:*/		return 0x820FCE60;
		  /* 820FCE60h */ case    1:  		/* rlwinm R3, R29, 2, 0, 29 */
		/* 820FCE60h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R29);
		/* 820FCE60h case    1:*/		return 0x820FCE64;
		  /* 820FCE64h */ case    2:  		/* bl -478308 */
		/* 820FCE64h case    2:*/		regs.LR = 0x820FCE68; return 0x82088200;
		/* 820FCE64h case    2:*/		return 0x820FCE68;
		  /* 820FCE68h */ case    3:  		/* or. R30, R3, R3 */
		/* 820FCE68h case    3:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FCE68h case    3:*/		return 0x820FCE6C;
		  /* 820FCE6Ch */ case    4:  		/* bc 4, CR0_EQ, 40 */
		/* 820FCE6Ch case    4:*/		if ( !regs.CR[0].eq ) { return 0x820FCE94;  }
		/* 820FCE6Ch case    4:*/		return 0x820FCE70;
		  /* 820FCE70h */ case    5:  		/* cmplwi CR6, R28, 0 */
		/* 820FCE70h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820FCE70h case    5:*/		return 0x820FCE74;
		  /* 820FCE74h */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 820FCE74h case    6:*/		if ( regs.CR[6].eq ) { return 0x820FCE8C;  }
		/* 820FCE74h case    6:*/		return 0x820FCE78;
		  /* 820FCE78h */ case    7:  		/* mr R3, R28 */
		/* 820FCE78h case    7:*/		regs.R3 = regs.R28;
		/* 820FCE78h case    7:*/		return 0x820FCE7C;
		  /* 820FCE7Ch */ case    8:  		/* bl 1180996 */
		/* 820FCE7Ch case    8:*/		regs.LR = 0x820FCE80; return 0x8221D3C0;
		/* 820FCE7Ch case    8:*/		return 0x820FCE80;
		  /* 820FCE80h */ case    9:  		/* lis R4, 9345 */
		/* 820FCE80h case    9:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820FCE80h case    9:*/		return 0x820FCE84;
		  /* 820FCE84h */ case   10:  		/* mr R3, R28 */
		/* 820FCE84h case   10:*/		regs.R3 = regs.R28;
		/* 820FCE84h case   10:*/		return 0x820FCE88;
		  /* 820FCE88h */ case   11:  		/* bl -478032 */
		/* 820FCE88h case   11:*/		regs.LR = 0x820FCE8C; return 0x82088338;
		/* 820FCE88h case   11:*/		return 0x820FCE8C;
	}
	return 0x820FCE8C;
} // Block from 820FCE5Ch-820FCE8Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820FCE8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCE8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCE8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCE8C);
		  /* 820FCE8Ch */ case    0:  		/* li R3, -1 */
		/* 820FCE8Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820FCE8Ch case    0:*/		return 0x820FCE90;
		  /* 820FCE90h */ case    1:  		/* b 100 */
		/* 820FCE90h case    1:*/		return 0x820FCEF4;
		/* 820FCE90h case    1:*/		return 0x820FCE94;
	}
	return 0x820FCE94;
} // Block from 820FCE8Ch-820FCE94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FCE94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCE94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCE94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCE94);
		  /* 820FCE94h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 820FCE94h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820FCE94h case    0:*/		return 0x820FCE98;
		  /* 820FCE98h */ case    1:  		/* mr R3, R30 */
		/* 820FCE98h case    1:*/		regs.R3 = regs.R30;
		/* 820FCE98h case    1:*/		return 0x820FCE9C;
		  /* 820FCE9Ch */ case    2:  		/* lwz R4, <#[R31 + 16]> */
		/* 820FCE9Ch case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 820FCE9Ch case    2:*/		return 0x820FCEA0;
		  /* 820FCEA0h */ case    3:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820FCEA0h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820FCEA0h case    3:*/		return 0x820FCEA4;
		  /* 820FCEA4h */ case    4:  		/* bl -439540 */
		/* 820FCEA4h case    4:*/		regs.LR = 0x820FCEA8; return 0x820919B0;
		/* 820FCEA4h case    4:*/		return 0x820FCEA8;
		  /* 820FCEA8h */ case    5:  		/* lwz R10, <#[R31 + 4]> */
		/* 820FCEA8h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820FCEA8h case    5:*/		return 0x820FCEAC;
		  /* 820FCEACh */ case    6:  		/* li R4, 0 */
		/* 820FCEACh case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820FCEACh case    6:*/		return 0x820FCEB0;
		  /* 820FCEB0h */ case    7:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 820FCEB0h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 820FCEB0h case    7:*/		return 0x820FCEB4;
		  /* 820FCEB4h */ case    8:  		/* subf R10, R10, R29 */
		/* 820FCEB4h case    8:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R29);
		/* 820FCEB4h case    8:*/		return 0x820FCEB8;
		  /* 820FCEB8h */ case    9:  		/* add R3, R11, R30 */
		/* 820FCEB8h case    9:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R30);
		/* 820FCEB8h case    9:*/		return 0x820FCEBC;
		  /* 820FCEBCh */ case   10:  		/* rlwinm R5, R10, 2, 0, 29 */
		/* 820FCEBCh case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R10);
		/* 820FCEBCh case   10:*/		return 0x820FCEC0;
		  /* 820FCEC0h */ case   11:  		/* bl -441216 */
		/* 820FCEC0h case   11:*/		regs.LR = 0x820FCEC4; return 0x82091340;
		/* 820FCEC0h case   11:*/		return 0x820FCEC4;
		  /* 820FCEC4h */ case   12:  		/* lis R4, 9345 */
		/* 820FCEC4h case   12:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820FCEC4h case   12:*/		return 0x820FCEC8;
		  /* 820FCEC8h */ case   13:  		/* lwz R3, <#[R31 + 16]> */
		/* 820FCEC8h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 820FCEC8h case   13:*/		return 0x820FCECC;
		  /* 820FCECCh */ case   14:  		/* bl -478100 */
		/* 820FCECCh case   14:*/		regs.LR = 0x820FCED0; return 0x82088338;
		/* 820FCECCh case   14:*/		return 0x820FCED0;
		  /* 820FCED0h */ case   15:  		/* stw R30, <#[R31 + 16]> */
		/* 820FCED0h case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000010) );
		/* 820FCED0h case   15:*/		return 0x820FCED4;
		  /* 820FCED4h */ case   16:  		/* stw R29, <#[R31 + 28]> */
		/* 820FCED4h case   16:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x0000001C) );
		/* 820FCED4h case   16:*/		return 0x820FCED8;
	}
	return 0x820FCED8;
} // Block from 820FCE94h-820FCED8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820FCED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCED8);
		  /* 820FCED8h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 820FCED8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820FCED8h case    0:*/		return 0x820FCEDC;
		  /* 820FCEDCh */ case    1:  		/* lwz R10, <#[R31 + 16]> */
		/* 820FCEDCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820FCEDCh case    1:*/		return 0x820FCEE0;
		  /* 820FCEE0h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FCEE0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FCEE0h case    2:*/		return 0x820FCEE4;
		  /* 820FCEE4h */ case    3:  		/* stwx R28, <#[R11 + R10]> */
		/* 820FCEE4h case    3:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FCEE4h case    3:*/		return 0x820FCEE8;
		  /* 820FCEE8h */ case    4:  		/* lwz R3, <#[R31 + 4]> */
		/* 820FCEE8h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820FCEE8h case    4:*/		return 0x820FCEEC;
		  /* 820FCEECh */ case    5:  		/* addi R11, R3, 1 */
		/* 820FCEECh case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x1);
		/* 820FCEECh case    5:*/		return 0x820FCEF0;
		  /* 820FCEF0h */ case    6:  		/* stw R11, <#[R31 + 4]> */
		/* 820FCEF0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820FCEF0h case    6:*/		return 0x820FCEF4;
	}
	return 0x820FCEF4;
} // Block from 820FCED8h-820FCEF4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820FCEF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCEF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCEF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCEF4);
		  /* 820FCEF4h */ case    0:  		/* addi R1, R1, 128 */
		/* 820FCEF4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820FCEF4h case    0:*/		return 0x820FCEF8;
		  /* 820FCEF8h */ case    1:  		/* b -441424 */
		/* 820FCEF8h case    1:*/		return 0x820912A8;
		/* 820FCEF8h case    1:*/		return 0x820FCEFC;
		  /* 820FCEFCh */ case    2:  		/* nop */
		/* 820FCEFCh case    2:*/		cpu::op::nop();
		/* 820FCEFCh case    2:*/		return 0x820FCF00;
	}
	return 0x820FCF00;
} // Block from 820FCEF4h-820FCF00h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FCF00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCF00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCF00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCF00);
		  /* 820FCF00h */ case    0:  		/* mfspr R12, LR */
		/* 820FCF00h case    0:*/		regs.R12 = regs.LR;
		/* 820FCF00h case    0:*/		return 0x820FCF04;
		  /* 820FCF04h */ case    1:  		/* bl -441516 */
		/* 820FCF04h case    1:*/		regs.LR = 0x820FCF08; return 0x82091258;
		/* 820FCF04h case    1:*/		return 0x820FCF08;
		  /* 820FCF08h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820FCF08h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820FCF08h case    2:*/		return 0x820FCF0C;
		  /* 820FCF0Ch */ case    3:  		/* lwz R11, <#[R3 + 32]> */
		/* 820FCF0Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820FCF0Ch case    3:*/		return 0x820FCF10;
		  /* 820FCF10h */ case    4:  		/* mr R31, R3 */
		/* 820FCF10h case    4:*/		regs.R31 = regs.R3;
		/* 820FCF10h case    4:*/		return 0x820FCF14;
		  /* 820FCF14h */ case    5:  		/* lwz R10, <#[R3 + 8]> */
		/* 820FCF14h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820FCF14h case    5:*/		return 0x820FCF18;
		  /* 820FCF18h */ case    6:  		/* mr R30, R4 */
		/* 820FCF18h case    6:*/		regs.R30 = regs.R4;
		/* 820FCF18h case    6:*/		return 0x820FCF1C;
		  /* 820FCF1Ch */ case    7:  		/* cmplw CR6, R10, R11 */
		/* 820FCF1Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820FCF1Ch case    7:*/		return 0x820FCF20;
		  /* 820FCF20h */ case    8:  		/* bc 4, CR6_EQ, 140 */
		/* 820FCF20h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820FCFAC;  }
		/* 820FCF20h case    8:*/		return 0x820FCF24;
		  /* 820FCF24h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820FCF24h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FCF24h case    9:*/		return 0x820FCF28;
		  /* 820FCF28h */ case   10:  		/* rlwinm R28, R11, 1, 0, 30 */
		/* 820FCF28h case   10:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R28,regs.R11);
		/* 820FCF28h case   10:*/		return 0x820FCF2C;
		  /* 820FCF2Ch */ case   11:  		/* bc 4, CR6_EQ, 8 */
		/* 820FCF2Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x820FCF34;  }
		/* 820FCF2Ch case   11:*/		return 0x820FCF30;
		  /* 820FCF30h */ case   12:  		/* li R28, 1024 */
		/* 820FCF30h case   12:*/		cpu::op::li<0>(regs,&regs.R28,0x400);
		/* 820FCF30h case   12:*/		return 0x820FCF34;
	}
	return 0x820FCF34;
} // Block from 820FCF00h-820FCF34h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FCF34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCF34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCF34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCF34);
		  /* 820FCF34h */ case    0:  		/* lis R4, 9345 */
		/* 820FCF34h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820FCF34h case    0:*/		return 0x820FCF38;
		  /* 820FCF38h */ case    1:  		/* rlwinm R3, R28, 2, 0, 29 */
		/* 820FCF38h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R28);
		/* 820FCF38h case    1:*/		return 0x820FCF3C;
		  /* 820FCF3Ch */ case    2:  		/* bl -478524 */
		/* 820FCF3Ch case    2:*/		regs.LR = 0x820FCF40; return 0x82088200;
		/* 820FCF3Ch case    2:*/		return 0x820FCF40;
		  /* 820FCF40h */ case    3:  		/* or. R29, R3, R3 */
		/* 820FCF40h case    3:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820FCF40h case    3:*/		return 0x820FCF44;
		  /* 820FCF44h */ case    4:  		/* bc 4, CR0_EQ, 36 */
		/* 820FCF44h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820FCF68;  }
		/* 820FCF44h case    4:*/		return 0x820FCF48;
		  /* 820FCF48h */ case    5:  		/* cmplwi CR6, R30, 0 */
		/* 820FCF48h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820FCF48h case    5:*/		return 0x820FCF4C;
		  /* 820FCF4Ch */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 820FCF4Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x820FCF60;  }
		/* 820FCF4Ch case    6:*/		return 0x820FCF50;
		  /* 820FCF50h */ case    7:  		/* mr R3, R30 */
		/* 820FCF50h case    7:*/		regs.R3 = regs.R30;
		/* 820FCF50h case    7:*/		return 0x820FCF54;
		  /* 820FCF54h */ case    8:  		/* bl 1180780 */
		/* 820FCF54h case    8:*/		regs.LR = 0x820FCF58; return 0x8221D3C0;
		/* 820FCF54h case    8:*/		return 0x820FCF58;
		  /* 820FCF58h */ case    9:  		/* mr R3, R30 */
		/* 820FCF58h case    9:*/		regs.R3 = regs.R30;
		/* 820FCF58h case    9:*/		return 0x820FCF5C;
		  /* 820FCF5Ch */ case   10:  		/* bl -476 */
		/* 820FCF5Ch case   10:*/		regs.LR = 0x820FCF60; return 0x820FCD80;
		/* 820FCF5Ch case   10:*/		return 0x820FCF60;
	}
	return 0x820FCF60;
} // Block from 820FCF34h-820FCF60h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FCF60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCF60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCF60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCF60);
		  /* 820FCF60h */ case    0:  		/* li R3, -1 */
		/* 820FCF60h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820FCF60h case    0:*/		return 0x820FCF64;
		  /* 820FCF64h */ case    1:  		/* b 328 */
		/* 820FCF64h case    1:*/		return 0x820FD0AC;
		/* 820FCF64h case    1:*/		return 0x820FCF68;
	}
	return 0x820FCF68;
} // Block from 820FCF60h-820FCF68h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FCF68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCF68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCF68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCF68);
		  /* 820FCF68h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820FCF68h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820FCF68h case    0:*/		return 0x820FCF6C;
		  /* 820FCF6Ch */ case    1:  		/* mr R3, R29 */
		/* 820FCF6Ch case    1:*/		regs.R3 = regs.R29;
		/* 820FCF6Ch case    1:*/		return 0x820FCF70;
		  /* 820FCF70h */ case    2:  		/* lwz R4, <#[R31 + 20]> */
		/* 820FCF70h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000014) );
		/* 820FCF70h case    2:*/		return 0x820FCF74;
		  /* 820FCF74h */ case    3:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820FCF74h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820FCF74h case    3:*/		return 0x820FCF78;
		  /* 820FCF78h */ case    4:  		/* bl -439752 */
		/* 820FCF78h case    4:*/		regs.LR = 0x820FCF7C; return 0x820919B0;
		/* 820FCF78h case    4:*/		return 0x820FCF7C;
		  /* 820FCF7Ch */ case    5:  		/* lwz R10, <#[R31 + 8]> */
		/* 820FCF7Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820FCF7Ch case    5:*/		return 0x820FCF80;
		  /* 820FCF80h */ case    6:  		/* li R4, 0 */
		/* 820FCF80h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820FCF80h case    6:*/		return 0x820FCF84;
		  /* 820FCF84h */ case    7:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 820FCF84h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 820FCF84h case    7:*/		return 0x820FCF88;
		  /* 820FCF88h */ case    8:  		/* subf R10, R10, R28 */
		/* 820FCF88h case    8:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R28);
		/* 820FCF88h case    8:*/		return 0x820FCF8C;
		  /* 820FCF8Ch */ case    9:  		/* add R3, R11, R29 */
		/* 820FCF8Ch case    9:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 820FCF8Ch case    9:*/		return 0x820FCF90;
		  /* 820FCF90h */ case   10:  		/* rlwinm R5, R10, 2, 0, 29 */
		/* 820FCF90h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R10);
		/* 820FCF90h case   10:*/		return 0x820FCF94;
		  /* 820FCF94h */ case   11:  		/* bl -441428 */
		/* 820FCF94h case   11:*/		regs.LR = 0x820FCF98; return 0x82091340;
		/* 820FCF94h case   11:*/		return 0x820FCF98;
		  /* 820FCF98h */ case   12:  		/* lis R4, 9345 */
		/* 820FCF98h case   12:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820FCF98h case   12:*/		return 0x820FCF9C;
		  /* 820FCF9Ch */ case   13:  		/* lwz R3, <#[R31 + 20]> */
		/* 820FCF9Ch case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 820FCF9Ch case   13:*/		return 0x820FCFA0;
		  /* 820FCFA0h */ case   14:  		/* bl -478312 */
		/* 820FCFA0h case   14:*/		regs.LR = 0x820FCFA4; return 0x82088338;
		/* 820FCFA0h case   14:*/		return 0x820FCFA4;
		  /* 820FCFA4h */ case   15:  		/* stw R29, <#[R31 + 20]> */
		/* 820FCFA4h case   15:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000014) );
		/* 820FCFA4h case   15:*/		return 0x820FCFA8;
		  /* 820FCFA8h */ case   16:  		/* stw R28, <#[R31 + 32]> */
		/* 820FCFA8h case   16:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000020) );
		/* 820FCFA8h case   16:*/		return 0x820FCFAC;
	}
	return 0x820FCFAC;
} // Block from 820FCF68h-820FCFACh (17 instructions)

//////////////////////////////////////////////////////
// Block at 820FCFACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCFAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCFAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCFAC);
		  /* 820FCFACh */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820FCFACh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820FCFACh case    0:*/		return 0x820FCFB0;
		  /* 820FCFB0h */ case    1:  		/* bc 12, CR6_EQ, 224 */
		/* 820FCFB0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820FD090;  }
		/* 820FCFB0h case    1:*/		return 0x820FCFB4;
		  /* 820FCFB4h */ case    2:  		/* lwz R11, <#[R30 + 4]> */
		/* 820FCFB4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 820FCFB4h case    2:*/		return 0x820FCFB8;
		  /* 820FCFB8h */ case    3:  		/* lwz R10, <#[R31 + 16]> */
		/* 820FCFB8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820FCFB8h case    3:*/		return 0x820FCFBC;
		  /* 820FCFBCh */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FCFBCh case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FCFBCh case    4:*/		return 0x820FCFC0;
		  /* 820FCFC0h */ case    5:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820FCFC0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FCFC0h case    5:*/		return 0x820FCFC4;
		  /* 820FCFC4h */ case    6:  		/* lwz R11, <#[R11 + 4]> */
		/* 820FCFC4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820FCFC4h case    6:*/		return 0x820FCFC8;
		  /* 820FCFC8h */ case    7:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 820FCFC8h case    7:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 820FCFC8h case    7:*/		return 0x820FCFCC;
		  /* 820FCFCCh */ case    8:  		/* bc 12, CR0_EQ, 196 */
		/* 820FCFCCh case    8:*/		if ( regs.CR[0].eq ) { return 0x820FD090;  }
		/* 820FCFCCh case    8:*/		return 0x820FCFD0;
		  /* 820FCFD0h */ case    9:  		/* lwz R11, <#[R30 + 8]> */
		/* 820FCFD0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820FCFD0h case    9:*/		return 0x820FCFD4;
		  /* 820FCFD4h */ case   10:  		/* cmpwi CR6, R11, -1 */
		/* 820FCFD4h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FCFD4h case   10:*/		return 0x820FCFD8;
		  /* 820FCFD8h */ case   11:  		/* bc 4, CR6_EQ, 184 */
		/* 820FCFD8h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820FD090;  }
		/* 820FCFD8h case   11:*/		return 0x820FCFDC;
		  /* 820FCFDCh */ case   12:  		/* lis R10, -32256 */
		/* 820FCFDCh case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 820FCFDCh case   12:*/		return 0x820FCFE0;
		  /* 820FCFE0h */ case   13:  		/* lwz R11, <#[R30]> */
		/* 820FCFE0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820FCFE0h case   13:*/		return 0x820FCFE4;
		  /* 820FCFE4h */ case   14:  		/* lis R9, -32256 */
		/* 820FCFE4h case   14:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 820FCFE4h case   14:*/		return 0x820FCFE8;
		  /* 820FCFE8h */ case   15:  		/* lfd FR0, <#[R30 + 32]> */
		/* 820FCFE8h case   15:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R30 + 0x00000020) );
		/* 820FCFE8h case   15:*/		return 0x820FCFEC;
		  /* 820FCFECh */ case   16:  		/* ori R11, R11, 128 */
		/* 820FCFECh case   16:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x80);
		/* 820FCFECh case   16:*/		return 0x820FCFF0;
		  /* 820FCFF0h */ case   17:  		/* stw R11, <#[R30]> */
		/* 820FCFF0h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820FCFF0h case   17:*/		return 0x820FCFF4;
		  /* 820FCFF4h */ case   18:  		/* lfd FR13, <#[R10 + 1808]> */
		/* 820FCFF4h case   18:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000710) );
		/* 820FCFF4h case   18:*/		return 0x820FCFF8;
	}
	return 0x820FCFF8;
} // Block from 820FCFACh-820FCFF8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820FCFF8h
// Function '?IsGradient@CInstruction@D3DXShader@@QAAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FCFF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FCFF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FCFF8);
		  /* 820FCFF8h */ case    0:  		/* lfd FR11, <#[R9 + 1848]> */
		/* 820FCFF8h case    0:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R9 + 0x00000738) );
		/* 820FCFF8h case    0:*/		return 0x820FCFFC;
		  /* 820FCFFCh */ case    1:  		/* fcmpu CR6, FR0, FR13 */
		/* 820FCFFCh case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 820FCFFCh case    1:*/		return 0x820FD000;
		  /* 820FD000h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 820FD000h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FD00C;  }
		/* 820FD000h case    2:*/		return 0x820FD004;
		  /* 820FD004h */ case    3:  		/* fcmpu CR6, FR0, FR11 */
		/* 820FD004h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR11);
		/* 820FD004h case    3:*/		return 0x820FD008;
		  /* 820FD008h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 820FD008h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820FD014;  }
		/* 820FD008h case    4:*/		return 0x820FD00C;
	}
	return 0x820FD00C;
} // Block from 820FCFF8h-820FD00Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FD00Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD00C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD00C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD00C);
		  /* 820FD00Ch */ case    0:  		/* ori R11, R11, 1 */
		/* 820FD00Ch case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820FD00Ch case    0:*/		return 0x820FD010;
		  /* 820FD010h */ case    1:  		/* stw R11, <#[R30]> */
		/* 820FD010h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820FD010h case    1:*/		return 0x820FD014;
	}
	return 0x820FD014;
} // Block from 820FD00Ch-820FD014h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FD014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD014);
		  /* 820FD014h */ case    0:  		/* fctiwz FR12, FR0 */
		/* 820FD014h case    0:*/		cpu::op::fctiwz<0>(regs,&regs.FR12,regs.FR0);
		/* 820FD014h case    0:*/		return 0x820FD018;
		  /* 820FD018h */ case    1:  		/* stfd FR12, <#[R1 + 80]> */
		/* 820FD018h case    1:*/		cpu::mem::store64f( regs, regs.FR12, (uint32)(regs.R1 + 0x00000050) );
		/* 820FD018h case    1:*/		return 0x820FD01C;
		  /* 820FD01Ch */ case    2:  		/* lwa R11, <#[R1 + 84]> */
		/* 820FD01Ch case    2:*/		cpu::mem::load32a( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820FD01Ch case    2:*/		return 0x820FD020;
		  /* 820FD020h */ case    3:  		/* std R11, <#[R1 + 80]> */
		/* 820FD020h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820FD020h case    3:*/		return 0x820FD024;
		  /* 820FD024h */ case    4:  		/* lis R11, -32255 */
		/* 820FD024h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820FD024h case    4:*/		return 0x820FD028;
		  /* 820FD028h */ case    5:  		/* lfd FR12, <#[R1 + 80]> */
		/* 820FD028h case    5:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R1 + 0x00000050) );
		/* 820FD028h case    5:*/		return 0x820FD02C;
		  /* 820FD02Ch */ case    6:  		/* fcfid FR12, FR12 */
		/* 820FD02Ch case    6:*/		cpu::op::fcfid<0>(regs,&regs.FR12,regs.FR12);
		/* 820FD02Ch case    6:*/		return 0x820FD030;
		  /* 820FD030h */ case    7:  		/* fsub FR10, FR0, FR12 */
		/* 820FD030h case    7:*/		cpu::op::fsub<0>(regs,&regs.FR10,regs.FR0,regs.FR12);
		/* 820FD030h case    7:*/		return 0x820FD034;
		  /* 820FD034h */ case    8:  		/* lfd FR12, <#[R11 + 8072]> */
		/* 820FD034h case    8:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00001F88) );
		/* 820FD034h case    8:*/		return 0x820FD038;
		  /* 820FD038h */ case    9:  		/* fabs FR10, FR10 */
		/* 820FD038h case    9:*/		cpu::op::fabs<0>(regs,&regs.FR10,regs.FR10);
		/* 820FD038h case    9:*/		return 0x820FD03C;
		  /* 820FD03Ch */ case   10:  		/* fcmpu CR6, FR10, FR12 */
		/* 820FD03Ch case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR10,regs.FR12);
		/* 820FD03Ch case   10:*/		return 0x820FD040;
		  /* 820FD040h */ case   11:  		/* bc 4, CR6_LT, 16 */
		/* 820FD040h case   11:*/		if ( !regs.CR[6].lt ) { return 0x820FD050;  }
		/* 820FD040h case   11:*/		return 0x820FD044;
		  /* 820FD044h */ case   12:  		/* lwz R11, <#[R30]> */
		/* 820FD044h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820FD044h case   12:*/		return 0x820FD048;
		  /* 820FD048h */ case   13:  		/* ori R11, R11, 2 */
		/* 820FD048h case   13:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820FD048h case   13:*/		return 0x820FD04C;
		  /* 820FD04Ch */ case   14:  		/* stw R11, <#[R30]> */
		/* 820FD04Ch case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820FD04Ch case   14:*/		return 0x820FD050;
	}
	return 0x820FD050;
} // Block from 820FD014h-820FD050h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820FD050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD050);
		  /* 820FD050h */ case    0:  		/* fcmpu CR6, FR0, FR13 */
		/* 820FD050h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 820FD050h case    0:*/		return 0x820FD054;
		  /* 820FD054h */ case    1:  		/* bc 12, CR6_LT, 16 */
		/* 820FD054h case    1:*/		if ( regs.CR[6].lt ) { return 0x820FD064;  }
		/* 820FD054h case    1:*/		return 0x820FD058;
		  /* 820FD058h */ case    2:  		/* lwz R11, <#[R30]> */
		/* 820FD058h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820FD058h case    2:*/		return 0x820FD05C;
		  /* 820FD05Ch */ case    3:  		/* ori R11, R11, 4 */
		/* 820FD05Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820FD05Ch case    3:*/		return 0x820FD060;
		  /* 820FD060h */ case    4:  		/* stw R11, <#[R30]> */
		/* 820FD060h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820FD060h case    4:*/		return 0x820FD064;
	}
	return 0x820FD064;
} // Block from 820FD050h-820FD064h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FD064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD064);
		  /* 820FD064h */ case    0:  		/* fcmpu CR6, FR0, FR13 */
		/* 820FD064h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 820FD064h case    0:*/		return 0x820FD068;
		  /* 820FD068h */ case    1:  		/* bc 12, CR6_GT, 16 */
		/* 820FD068h case    1:*/		if ( regs.CR[6].gt ) { return 0x820FD078;  }
		/* 820FD068h case    1:*/		return 0x820FD06C;
		  /* 820FD06Ch */ case    2:  		/* lwz R11, <#[R30]> */
		/* 820FD06Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820FD06Ch case    2:*/		return 0x820FD070;
		  /* 820FD070h */ case    3:  		/* ori R11, R11, 8 */
		/* 820FD070h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8);
		/* 820FD070h case    3:*/		return 0x820FD074;
		  /* 820FD074h */ case    4:  		/* stw R11, <#[R30]> */
		/* 820FD074h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820FD074h case    4:*/		return 0x820FD078;
	}
	return 0x820FD078;
} // Block from 820FD064h-820FD078h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FD078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD078);
		  /* 820FD078h */ case    0:  		/* fabs FR0, FR0 */
		/* 820FD078h case    0:*/		cpu::op::fabs<0>(regs,&regs.FR0,regs.FR0);
		/* 820FD078h case    0:*/		return 0x820FD07C;
		  /* 820FD07Ch */ case    1:  		/* fcmpu CR6, FR0, FR11 */
		/* 820FD07Ch case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR11);
		/* 820FD07Ch case    1:*/		return 0x820FD080;
		  /* 820FD080h */ case    2:  		/* bc 12, CR6_GT, 16 */
		/* 820FD080h case    2:*/		if ( regs.CR[6].gt ) { return 0x820FD090;  }
		/* 820FD080h case    2:*/		return 0x820FD084;
		  /* 820FD084h */ case    3:  		/* lwz R11, <#[R30]> */
		/* 820FD084h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820FD084h case    3:*/		return 0x820FD088;
		  /* 820FD088h */ case    4:  		/* ori R11, R11, 16 */
		/* 820FD088h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x10);
		/* 820FD088h case    4:*/		return 0x820FD08C;
		  /* 820FD08Ch */ case    5:  		/* stw R11, <#[R30]> */
		/* 820FD08Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820FD08Ch case    5:*/		return 0x820FD090;
	}
	return 0x820FD090;
} // Block from 820FD078h-820FD090h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FD090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD090);
		  /* 820FD090h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820FD090h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820FD090h case    0:*/		return 0x820FD094;
		  /* 820FD094h */ case    1:  		/* lwz R10, <#[R31 + 20]> */
		/* 820FD094h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820FD094h case    1:*/		return 0x820FD098;
		  /* 820FD098h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FD098h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FD098h case    2:*/		return 0x820FD09C;
		  /* 820FD09Ch */ case    3:  		/* stwx R30, <#[R11 + R10]> */
		/* 820FD09Ch case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FD09Ch case    3:*/		return 0x820FD0A0;
		  /* 820FD0A0h */ case    4:  		/* lwz R3, <#[R31 + 8]> */
		/* 820FD0A0h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820FD0A0h case    4:*/		return 0x820FD0A4;
		  /* 820FD0A4h */ case    5:  		/* addi R11, R3, 1 */
		/* 820FD0A4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x1);
		/* 820FD0A4h case    5:*/		return 0x820FD0A8;
		  /* 820FD0A8h */ case    6:  		/* stw R11, <#[R31 + 8]> */
		/* 820FD0A8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820FD0A8h case    6:*/		return 0x820FD0AC;
	}
	return 0x820FD0AC;
} // Block from 820FD090h-820FD0ACh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820FD0ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD0AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD0AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD0AC);
		  /* 820FD0ACh */ case    0:  		/* addi R1, R1, 128 */
		/* 820FD0ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820FD0ACh case    0:*/		return 0x820FD0B0;
		  /* 820FD0B0h */ case    1:  		/* b -441864 */
		/* 820FD0B0h case    1:*/		return 0x820912A8;
		/* 820FD0B0h case    1:*/		return 0x820FD0B4;
		  /* 820FD0B4h */ case    2:  		/* nop */
		/* 820FD0B4h case    2:*/		cpu::op::nop();
		/* 820FD0B4h case    2:*/		return 0x820FD0B8;
	}
	return 0x820FD0B8;
} // Block from 820FD0ACh-820FD0B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FD0B8h
// Function '?SetAlloc@CInstruction@D3DXShader@@SAXPAVCAlloc@D3DXCore@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD0B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD0B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD0B8);
		  /* 820FD0B8h */ case    0:  		/* mfspr R12, LR */
		/* 820FD0B8h case    0:*/		regs.R12 = regs.LR;
		/* 820FD0B8h case    0:*/		return 0x820FD0BC;
		  /* 820FD0BCh */ case    1:  		/* bl -441956 */
		/* 820FD0BCh case    1:*/		regs.LR = 0x820FD0C0; return 0x82091258;
		/* 820FD0BCh case    1:*/		return 0x820FD0C0;
		  /* 820FD0C0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820FD0C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820FD0C0h case    2:*/		return 0x820FD0C4;
		  /* 820FD0C4h */ case    3:  		/* lwz R11, <#[R3 + 36]> */
		/* 820FD0C4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820FD0C4h case    3:*/		return 0x820FD0C8;
		  /* 820FD0C8h */ case    4:  		/* mr R31, R3 */
		/* 820FD0C8h case    4:*/		regs.R31 = regs.R3;
		/* 820FD0C8h case    4:*/		return 0x820FD0CC;
		  /* 820FD0CCh */ case    5:  		/* lwz R10, <#[R3 + 12]> */
		/* 820FD0CCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 820FD0CCh case    5:*/		return 0x820FD0D0;
		  /* 820FD0D0h */ case    6:  		/* mr R28, R4 */
		/* 820FD0D0h case    6:*/		regs.R28 = regs.R4;
		/* 820FD0D0h case    6:*/		return 0x820FD0D4;
		  /* 820FD0D4h */ case    7:  		/* cmplw CR6, R10, R11 */
		/* 820FD0D4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820FD0D4h case    7:*/		return 0x820FD0D8;
		  /* 820FD0D8h */ case    8:  		/* bc 4, CR6_EQ, 140 */
		/* 820FD0D8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820FD164;  }
		/* 820FD0D8h case    8:*/		return 0x820FD0DC;
		  /* 820FD0DCh */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820FD0DCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FD0DCh case    9:*/		return 0x820FD0E0;
		  /* 820FD0E0h */ case   10:  		/* rlwinm R29, R11, 1, 0, 30 */
		/* 820FD0E0h case   10:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R29,regs.R11);
		/* 820FD0E0h case   10:*/		return 0x820FD0E4;
		  /* 820FD0E4h */ case   11:  		/* bc 4, CR6_EQ, 8 */
		/* 820FD0E4h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820FD0EC;  }
		/* 820FD0E4h case   11:*/		return 0x820FD0E8;
		  /* 820FD0E8h */ case   12:  		/* li R29, 256 */
		/* 820FD0E8h case   12:*/		cpu::op::li<0>(regs,&regs.R29,0x100);
		/* 820FD0E8h case   12:*/		return 0x820FD0EC;
	}
	return 0x820FD0EC;
} // Block from 820FD0B8h-820FD0ECh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FD0ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD0EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD0EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD0EC);
		  /* 820FD0ECh */ case    0:  		/* lis R4, 9345 */
		/* 820FD0ECh case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820FD0ECh case    0:*/		return 0x820FD0F0;
	}
	return 0x820FD0F0;
} // Block from 820FD0ECh-820FD0F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FD0F0h
// Function '?Alloc@CInstruction@D3DXShader@@SAPAIK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD0F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD0F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD0F0);
		  /* 820FD0F0h */ case    0:  		/* rlwinm R3, R29, 2, 0, 29 */
		/* 820FD0F0h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R29);
		/* 820FD0F0h case    0:*/		return 0x820FD0F4;
		  /* 820FD0F4h */ case    1:  		/* bl -478964 */
		/* 820FD0F4h case    1:*/		regs.LR = 0x820FD0F8; return 0x82088200;
		/* 820FD0F4h case    1:*/		return 0x820FD0F8;
		  /* 820FD0F8h */ case    2:  		/* or. R30, R3, R3 */
		/* 820FD0F8h case    2:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820FD0F8h case    2:*/		return 0x820FD0FC;
		  /* 820FD0FCh */ case    3:  		/* bc 4, CR0_EQ, 36 */
		/* 820FD0FCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x820FD120;  }
		/* 820FD0FCh case    3:*/		return 0x820FD100;
		  /* 820FD100h */ case    4:  		/* cmplwi CR6, R28, 0 */
		/* 820FD100h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820FD100h case    4:*/		return 0x820FD104;
		  /* 820FD104h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 820FD104h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FD118;  }
		/* 820FD104h case    5:*/		return 0x820FD108;
		  /* 820FD108h */ case    6:  		/* mr R3, R28 */
		/* 820FD108h case    6:*/		regs.R3 = regs.R28;
		/* 820FD108h case    6:*/		return 0x820FD10C;
		  /* 820FD10Ch */ case    7:  		/* bl 1180340 */
		/* 820FD10Ch case    7:*/		regs.LR = 0x820FD110; return 0x8221D3C0;
		/* 820FD10Ch case    7:*/		return 0x820FD110;
		  /* 820FD110h */ case    8:  		/* mr R3, R28 */
		/* 820FD110h case    8:*/		regs.R3 = regs.R28;
		/* 820FD110h case    8:*/		return 0x820FD114;
		  /* 820FD114h */ case    9:  		/* bl -2852 */
		/* 820FD114h case    9:*/		regs.LR = 0x820FD118; return 0x820FC5F0;
		/* 820FD114h case    9:*/		return 0x820FD118;
	}
	return 0x820FD118;
} // Block from 820FD0F0h-820FD118h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FD118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD118);
		  /* 820FD118h */ case    0:  		/* li R3, -1 */
		/* 820FD118h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820FD118h case    0:*/		return 0x820FD11C;
		  /* 820FD11Ch */ case    1:  		/* b 100 */
		/* 820FD11Ch case    1:*/		return 0x820FD180;
		/* 820FD11Ch case    1:*/		return 0x820FD120;
	}
	return 0x820FD120;
} // Block from 820FD118h-820FD120h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FD120h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD120);
		  /* 820FD120h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FD120h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FD120h case    0:*/		return 0x820FD124;
		  /* 820FD124h */ case    1:  		/* mr R3, R30 */
		/* 820FD124h case    1:*/		regs.R3 = regs.R30;
		/* 820FD124h case    1:*/		return 0x820FD128;
		  /* 820FD128h */ case    2:  		/* lwz R4, <#[R31 + 24]> */
		/* 820FD128h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 820FD128h case    2:*/		return 0x820FD12C;
		  /* 820FD12Ch */ case    3:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820FD12Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820FD12Ch case    3:*/		return 0x820FD130;
	}
	return 0x820FD130;
} // Block from 820FD120h-820FD130h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FD130h
// Function '??2CInstruction@D3DXShader@@SAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD130);
		  /* 820FD130h */ case    0:  		/* bl -440192 */
		/* 820FD130h case    0:*/		regs.LR = 0x820FD134; return 0x820919B0;
		/* 820FD130h case    0:*/		return 0x820FD134;
		  /* 820FD134h */ case    1:  		/* lwz R10, <#[R31 + 12]> */
		/* 820FD134h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FD134h case    1:*/		return 0x820FD138;
		  /* 820FD138h */ case    2:  		/* li R4, 0 */
		/* 820FD138h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820FD138h case    2:*/		return 0x820FD13C;
		  /* 820FD13Ch */ case    3:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 820FD13Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 820FD13Ch case    3:*/		return 0x820FD140;
		  /* 820FD140h */ case    4:  		/* subf R10, R10, R29 */
		/* 820FD140h case    4:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R29);
		/* 820FD140h case    4:*/		return 0x820FD144;
		  /* 820FD144h */ case    5:  		/* add R3, R11, R30 */
		/* 820FD144h case    5:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R30);
		/* 820FD144h case    5:*/		return 0x820FD148;
		  /* 820FD148h */ case    6:  		/* rlwinm R5, R10, 2, 0, 29 */
		/* 820FD148h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R10);
		/* 820FD148h case    6:*/		return 0x820FD14C;
		  /* 820FD14Ch */ case    7:  		/* bl -441868 */
		/* 820FD14Ch case    7:*/		regs.LR = 0x820FD150; return 0x82091340;
		/* 820FD14Ch case    7:*/		return 0x820FD150;
		  /* 820FD150h */ case    8:  		/* lis R4, 9345 */
		/* 820FD150h case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820FD150h case    8:*/		return 0x820FD154;
		  /* 820FD154h */ case    9:  		/* lwz R3, <#[R31 + 24]> */
		/* 820FD154h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 820FD154h case    9:*/		return 0x820FD158;
		  /* 820FD158h */ case   10:  		/* bl -478752 */
		/* 820FD158h case   10:*/		regs.LR = 0x820FD15C; return 0x82088338;
		/* 820FD158h case   10:*/		return 0x820FD15C;
		  /* 820FD15Ch */ case   11:  		/* stw R30, <#[R31 + 24]> */
		/* 820FD15Ch case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000018) );
		/* 820FD15Ch case   11:*/		return 0x820FD160;
		  /* 820FD160h */ case   12:  		/* stw R29, <#[R31 + 36]> */
		/* 820FD160h case   12:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000024) );
		/* 820FD160h case   12:*/		return 0x820FD164;
	}
	return 0x820FD164;
} // Block from 820FD130h-820FD164h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FD164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD164);
		  /* 820FD164h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FD164h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FD164h case    0:*/		return 0x820FD168;
		  /* 820FD168h */ case    1:  		/* lwz R10, <#[R31 + 24]> */
		/* 820FD168h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820FD168h case    1:*/		return 0x820FD16C;
		  /* 820FD16Ch */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FD16Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FD16Ch case    2:*/		return 0x820FD170;
		  /* 820FD170h */ case    3:  		/* stwx R28, <#[R11 + R10]> */
		/* 820FD170h case    3:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FD170h case    3:*/		return 0x820FD174;
		  /* 820FD174h */ case    4:  		/* lwz R3, <#[R31 + 12]> */
		/* 820FD174h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FD174h case    4:*/		return 0x820FD178;
		  /* 820FD178h */ case    5:  		/* addi R11, R3, 1 */
		/* 820FD178h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x1);
		/* 820FD178h case    5:*/		return 0x820FD17C;
		  /* 820FD17Ch */ case    6:  		/* stw R11, <#[R31 + 12]> */
		/* 820FD17Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FD17Ch case    6:*/		return 0x820FD180;
	}
	return 0x820FD180;
} // Block from 820FD164h-820FD180h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820FD180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD180);
		  /* 820FD180h */ case    0:  		/* addi R1, R1, 128 */
		/* 820FD180h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820FD180h case    0:*/		return 0x820FD184;
		  /* 820FD184h */ case    1:  		/* b -442076 */
		/* 820FD184h case    1:*/		return 0x820912A8;
		/* 820FD184h case    1:*/		return 0x820FD188;
	}
	return 0x820FD188;
} // Block from 820FD180h-820FD188h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FD188h
// Function '??3CInstruction@D3DXShader@@SAXPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD188);
		  /* 820FD188h */ case    0:  		/* mfspr R12, LR */
		/* 820FD188h case    0:*/		regs.R12 = regs.LR;
		/* 820FD188h case    0:*/		return 0x820FD18C;
		  /* 820FD18Ch */ case    1:  		/* bl -442172 */
		/* 820FD18Ch case    1:*/		regs.LR = 0x820FD190; return 0x82091250;
		/* 820FD18Ch case    1:*/		return 0x820FD190;
		  /* 820FD190h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820FD190h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820FD190h case    2:*/		return 0x820FD194;
		  /* 820FD194h */ case    3:  		/* mr R26, R3 */
		/* 820FD194h case    3:*/		regs.R26 = regs.R3;
		/* 820FD194h case    3:*/		return 0x820FD198;
		  /* 820FD198h */ case    4:  		/* mr R30, R4 */
		/* 820FD198h case    4:*/		regs.R30 = regs.R4;
		/* 820FD198h case    4:*/		return 0x820FD19C;
		  /* 820FD19Ch */ case    5:  		/* lis R4, 9345 */
		/* 820FD19Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820FD19Ch case    5:*/		return 0x820FD1A0;
		  /* 820FD1A0h */ case    6:  		/* li R3, 52 */
		/* 820FD1A0h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x34);
		/* 820FD1A0h case    6:*/		return 0x820FD1A4;
		  /* 820FD1A4h */ case    7:  		/* mr R29, R5 */
		/* 820FD1A4h case    7:*/		regs.R29 = regs.R5;
		/* 820FD1A4h case    7:*/		return 0x820FD1A8;
		  /* 820FD1A8h */ case    8:  		/* mr R28, R6 */
		/* 820FD1A8h case    8:*/		regs.R28 = regs.R6;
		/* 820FD1A8h case    8:*/		return 0x820FD1AC;
		  /* 820FD1ACh */ case    9:  		/* mr R27, R7 */
		/* 820FD1ACh case    9:*/		regs.R27 = regs.R7;
		/* 820FD1ACh case    9:*/		return 0x820FD1B0;
		  /* 820FD1B0h */ case   10:  		/* bl -479152 */
		/* 820FD1B0h case   10:*/		regs.LR = 0x820FD1B4; return 0x82088200;
		/* 820FD1B0h case   10:*/		return 0x820FD1B4;
		  /* 820FD1B4h */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820FD1B4h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820FD1B4h case   11:*/		return 0x820FD1B8;
		  /* 820FD1B8h */ case   12:  		/* bc 12, CR0_EQ, 16 */
		/* 820FD1B8h case   12:*/		if ( regs.CR[0].eq ) { return 0x820FD1C8;  }
		/* 820FD1B8h case   12:*/		return 0x820FD1BC;
		  /* 820FD1BCh */ case   13:  		/* bl 1180164 */
		/* 820FD1BCh case   13:*/		regs.LR = 0x820FD1C0; return 0x8221D3C0;
		/* 820FD1BCh case   13:*/		return 0x820FD1C0;
		  /* 820FD1C0h */ case   14:  		/* mr R31, R3 */
		/* 820FD1C0h case   14:*/		regs.R31 = regs.R3;
		/* 820FD1C0h case   14:*/		return 0x820FD1C4;
		  /* 820FD1C4h */ case   15:  		/* b 8 */
		/* 820FD1C4h case   15:*/		return 0x820FD1CC;
		/* 820FD1C4h case   15:*/		return 0x820FD1C8;
	}
	return 0x820FD1C8;
} // Block from 820FD188h-820FD1C8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820FD1C8h
// Function '?Initialize@CInstruction@D3DXShader@@QAAJKIIH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD1C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD1C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD1C8);
		  /* 820FD1C8h */ case    0:  		/* li R31, 0 */
		/* 820FD1C8h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820FD1C8h case    0:*/		return 0x820FD1CC;
	}
	return 0x820FD1CC;
} // Block from 820FD1C8h-820FD1CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FD1CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD1CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD1CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD1CC);
		  /* 820FD1CCh */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820FD1CCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820FD1CCh case    0:*/		return 0x820FD1D0;
		  /* 820FD1D0h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820FD1D0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820FD1DC;  }
		/* 820FD1D0h case    1:*/		return 0x820FD1D4;
		  /* 820FD1D4h */ case    2:  		/* li R3, -1 */
		/* 820FD1D4h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820FD1D4h case    2:*/		return 0x820FD1D8;
		  /* 820FD1D8h */ case    3:  		/* b 72 */
		/* 820FD1D8h case    3:*/		return 0x820FD220;
		/* 820FD1D8h case    3:*/		return 0x820FD1DC;
	}
	return 0x820FD1DC;
} // Block from 820FD1CCh-820FD1DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FD1DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD1DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD1DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD1DC);
		  /* 820FD1DCh */ case    0:  		/* mr R7, R27 */
		/* 820FD1DCh case    0:*/		regs.R7 = regs.R27;
		/* 820FD1DCh case    0:*/		return 0x820FD1E0;
		  /* 820FD1E0h */ case    1:  		/* mr R6, R28 */
		/* 820FD1E0h case    1:*/		regs.R6 = regs.R28;
		/* 820FD1E0h case    1:*/		return 0x820FD1E4;
		  /* 820FD1E4h */ case    2:  		/* mr R5, R29 */
		/* 820FD1E4h case    2:*/		regs.R5 = regs.R29;
		/* 820FD1E4h case    2:*/		return 0x820FD1E8;
		  /* 820FD1E8h */ case    3:  		/* mr R4, R30 */
		/* 820FD1E8h case    3:*/		regs.R4 = regs.R30;
		/* 820FD1E8h case    3:*/		return 0x820FD1EC;
		  /* 820FD1ECh */ case    4:  		/* mr R3, R31 */
		/* 820FD1ECh case    4:*/		regs.R3 = regs.R31;
		/* 820FD1ECh case    4:*/		return 0x820FD1F0;
		  /* 820FD1F0h */ case    5:  		/* bl 291624 */
		/* 820FD1F0h case    5:*/		regs.LR = 0x820FD1F4; return 0x82144518;
		/* 820FD1F0h case    5:*/		return 0x820FD1F4;
		  /* 820FD1F4h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820FD1F4h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FD1F4h case    6:*/		return 0x820FD1F8;
		  /* 820FD1F8h */ case    7:  		/* bc 4, CR0_LT, 28 */
		/* 820FD1F8h case    7:*/		if ( !regs.CR[0].lt ) { return 0x820FD214;  }
		/* 820FD1F8h case    7:*/		return 0x820FD1FC;
		  /* 820FD1FCh */ case    8:  		/* mr R3, R31 */
		/* 820FD1FCh case    8:*/		regs.R3 = regs.R31;
		/* 820FD1FCh case    8:*/		return 0x820FD200;
		  /* 820FD200h */ case    9:  		/* bl 1180096 */
		/* 820FD200h case    9:*/		regs.LR = 0x820FD204; return 0x8221D3C0;
		/* 820FD200h case    9:*/		return 0x820FD204;
		  /* 820FD204h */ case   10:  		/* lis R4, 9345 */
		/* 820FD204h case   10:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820FD204h case   10:*/		return 0x820FD208;
		  /* 820FD208h */ case   11:  		/* mr R3, R31 */
		/* 820FD208h case   11:*/		regs.R3 = regs.R31;
		/* 820FD208h case   11:*/		return 0x820FD20C;
		  /* 820FD20Ch */ case   12:  		/* bl -478932 */
		/* 820FD20Ch case   12:*/		regs.LR = 0x820FD210; return 0x82088338;
		/* 820FD20Ch case   12:*/		return 0x820FD210;
		  /* 820FD210h */ case   13:  		/* b -60 */
		/* 820FD210h case   13:*/		return 0x820FD1D4;
		/* 820FD210h case   13:*/		return 0x820FD214;
	}
	return 0x820FD214;
} // Block from 820FD1DCh-820FD214h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820FD214h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD214( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD214) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD214);
		  /* 820FD214h */ case    0:  		/* mr R4, R31 */
		/* 820FD214h case    0:*/		regs.R4 = regs.R31;
		/* 820FD214h case    0:*/		return 0x820FD218;
		  /* 820FD218h */ case    1:  		/* mr R3, R26 */
		/* 820FD218h case    1:*/		regs.R3 = regs.R26;
		/* 820FD218h case    1:*/		return 0x820FD21C;
		  /* 820FD21Ch */ case    2:  		/* bl -1012 */
		/* 820FD21Ch case    2:*/		regs.LR = 0x820FD220; return 0x820FCE28;
		/* 820FD21Ch case    2:*/		return 0x820FD220;
	}
	return 0x820FD220;
} // Block from 820FD214h-820FD220h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FD220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD220);
		  /* 820FD220h */ case    0:  		/* addi R1, R1, 144 */
		/* 820FD220h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820FD220h case    0:*/		return 0x820FD224;
		  /* 820FD224h */ case    1:  		/* b -442244 */
		/* 820FD224h case    1:*/		return 0x820912A0;
		/* 820FD224h case    1:*/		return 0x820FD228;
	}
	return 0x820FD228;
} // Block from 820FD220h-820FD228h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FD228h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD228);
		  /* 820FD228h */ case    0:  		/* mfspr R12, LR */
		/* 820FD228h case    0:*/		regs.R12 = regs.LR;
		/* 820FD228h case    0:*/		return 0x820FD22C;
		  /* 820FD22Ch */ case    1:  		/* bl -442328 */
		/* 820FD22Ch case    1:*/		regs.LR = 0x820FD230; return 0x82091254;
		/* 820FD22Ch case    1:*/		return 0x820FD230;
		  /* 820FD230h */ case    2:  		/* stfd FR31, <#[R1 - 56]> */
		/* 820FD230h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFC8) );
		/* 820FD230h case    2:*/		return 0x820FD234;
		  /* 820FD234h */ case    3:  		/* stwu R1, <#[R1 - 144]> */
		/* 820FD234h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820FD234h case    3:*/		return 0x820FD238;
		  /* 820FD238h */ case    4:  		/* mr R27, R3 */
		/* 820FD238h case    4:*/		regs.R27 = regs.R3;
		/* 820FD238h case    4:*/		return 0x820FD23C;
		  /* 820FD23Ch */ case    5:  		/* fmr FR31, FR1 */
		/* 820FD23Ch case    5:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 820FD23Ch case    5:*/		return 0x820FD240;
		  /* 820FD240h */ case    6:  		/* li R3, 128 */
		/* 820FD240h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x80);
		/* 820FD240h case    6:*/		return 0x820FD244;
		  /* 820FD244h */ case    7:  		/* mr R30, R4 */
		/* 820FD244h case    7:*/		regs.R30 = regs.R4;
		/* 820FD244h case    7:*/		return 0x820FD248;
		  /* 820FD248h */ case    8:  		/* mr R29, R5 */
		/* 820FD248h case    8:*/		regs.R29 = regs.R5;
		/* 820FD248h case    8:*/		return 0x820FD24C;
		  /* 820FD24Ch */ case    9:  		/* mr R28, R6 */
		/* 820FD24Ch case    9:*/		regs.R28 = regs.R6;
		/* 820FD24Ch case    9:*/		return 0x820FD250;
		  /* 820FD250h */ case   10:  		/* bl -1320 */
		/* 820FD250h case   10:*/		regs.LR = 0x820FD254; return 0x820FCD28;
		/* 820FD250h case   10:*/		return 0x820FD254;
		  /* 820FD254h */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820FD254h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820FD254h case   11:*/		return 0x820FD258;
		  /* 820FD258h */ case   12:  		/* bc 12, CR0_EQ, 16 */
		/* 820FD258h case   12:*/		if ( regs.CR[0].eq ) { return 0x820FD268;  }
		/* 820FD258h case   12:*/		return 0x820FD25C;
		  /* 820FD25Ch */ case   13:  		/* bl 1180004 */
		/* 820FD25Ch case   13:*/		regs.LR = 0x820FD260; return 0x8221D3C0;
		/* 820FD25Ch case   13:*/		return 0x820FD260;
		  /* 820FD260h */ case   14:  		/* mr R31, R3 */
		/* 820FD260h case   14:*/		regs.R31 = regs.R3;
		/* 820FD260h case   14:*/		return 0x820FD264;
		  /* 820FD264h */ case   15:  		/* b 8 */
		/* 820FD264h case   15:*/		return 0x820FD26C;
		/* 820FD264h case   15:*/		return 0x820FD268;
	}
	return 0x820FD268;
} // Block from 820FD228h-820FD268h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820FD268h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD268);
		  /* 820FD268h */ case    0:  		/* li R31, 0 */
		/* 820FD268h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820FD268h case    0:*/		return 0x820FD26C;
	}
	return 0x820FD26C;
} // Block from 820FD268h-820FD26Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FD26Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD26C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD26C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD26C);
		  /* 820FD26Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820FD26Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820FD26Ch case    0:*/		return 0x820FD270;
		  /* 820FD270h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820FD270h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820FD27C;  }
		/* 820FD270h case    1:*/		return 0x820FD274;
		  /* 820FD274h */ case    2:  		/* li R3, -1 */
		/* 820FD274h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820FD274h case    2:*/		return 0x820FD278;
		  /* 820FD278h */ case    3:  		/* b 68 */
		/* 820FD278h case    3:*/		return 0x820FD2BC;
		/* 820FD278h case    3:*/		return 0x820FD27C;
	}
	return 0x820FD27C;
} // Block from 820FD26Ch-820FD27Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FD27Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD27C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD27C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD27C);
		  /* 820FD27Ch */ case    0:  		/* mr R6, R28 */
		/* 820FD27Ch case    0:*/		regs.R6 = regs.R28;
		/* 820FD27Ch case    0:*/		return 0x820FD280;
		  /* 820FD280h */ case    1:  		/* fmr FR1, FR31 */
		/* 820FD280h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820FD280h case    1:*/		return 0x820FD284;
		  /* 820FD284h */ case    2:  		/* mr R5, R29 */
		/* 820FD284h case    2:*/		regs.R5 = regs.R29;
		/* 820FD284h case    2:*/		return 0x820FD288;
		  /* 820FD288h */ case    3:  		/* mr R4, R30 */
		/* 820FD288h case    3:*/		regs.R4 = regs.R30;
		/* 820FD288h case    3:*/		return 0x820FD28C;
		  /* 820FD28Ch */ case    4:  		/* mr R3, R31 */
		/* 820FD28Ch case    4:*/		regs.R3 = regs.R31;
		/* 820FD28Ch case    4:*/		return 0x820FD290;
		  /* 820FD290h */ case    5:  		/* bl -1904 */
		/* 820FD290h case    5:*/		regs.LR = 0x820FD294; return 0x820FCB20;
		/* 820FD290h case    5:*/		return 0x820FD294;
		  /* 820FD294h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820FD294h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FD294h case    6:*/		return 0x820FD298;
		  /* 820FD298h */ case    7:  		/* bc 4, CR0_LT, 24 */
		/* 820FD298h case    7:*/		if ( !regs.CR[0].lt ) { return 0x820FD2B0;  }
		/* 820FD298h case    7:*/		return 0x820FD29C;
		  /* 820FD29Ch */ case    8:  		/* mr R3, R31 */
		/* 820FD29Ch case    8:*/		regs.R3 = regs.R31;
		/* 820FD29Ch case    8:*/		return 0x820FD2A0;
		  /* 820FD2A0h */ case    9:  		/* bl 1179936 */
		/* 820FD2A0h case    9:*/		regs.LR = 0x820FD2A4; return 0x8221D3C0;
		/* 820FD2A0h case    9:*/		return 0x820FD2A4;
		  /* 820FD2A4h */ case   10:  		/* mr R3, R31 */
		/* 820FD2A4h case   10:*/		regs.R3 = regs.R31;
		/* 820FD2A4h case   10:*/		return 0x820FD2A8;
		  /* 820FD2A8h */ case   11:  		/* bl -1320 */
		/* 820FD2A8h case   11:*/		regs.LR = 0x820FD2AC; return 0x820FCD80;
		/* 820FD2A8h case   11:*/		return 0x820FD2AC;
		  /* 820FD2ACh */ case   12:  		/* b -56 */
		/* 820FD2ACh case   12:*/		return 0x820FD274;
		/* 820FD2ACh case   12:*/		return 0x820FD2B0;
	}
	return 0x820FD2B0;
} // Block from 820FD27Ch-820FD2B0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FD2B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD2B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD2B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD2B0);
		  /* 820FD2B0h */ case    0:  		/* mr R4, R31 */
		/* 820FD2B0h case    0:*/		regs.R4 = regs.R31;
		/* 820FD2B0h case    0:*/		return 0x820FD2B4;
		  /* 820FD2B4h */ case    1:  		/* mr R3, R27 */
		/* 820FD2B4h case    1:*/		regs.R3 = regs.R27;
		/* 820FD2B4h case    1:*/		return 0x820FD2B8;
		  /* 820FD2B8h */ case    2:  		/* bl -952 */
		/* 820FD2B8h case    2:*/		regs.LR = 0x820FD2BC; return 0x820FCF00;
		/* 820FD2B8h case    2:*/		return 0x820FD2BC;
	}
	return 0x820FD2BC;
} // Block from 820FD2B0h-820FD2BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FD2BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD2BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD2BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD2BC);
		  /* 820FD2BCh */ case    0:  		/* addi R1, R1, 144 */
		/* 820FD2BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820FD2BCh case    0:*/		return 0x820FD2C0;
		  /* 820FD2C0h */ case    1:  		/* lfd FR31, <#[R1 - 56]> */
		/* 820FD2C0h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFC8) );
		/* 820FD2C0h case    1:*/		return 0x820FD2C4;
		  /* 820FD2C4h */ case    2:  		/* b -442400 */
		/* 820FD2C4h case    2:*/		return 0x820912A4;
		/* 820FD2C4h case    2:*/		return 0x820FD2C8;
	}
	return 0x820FD2C8;
} // Block from 820FD2BCh-820FD2C8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FD2C8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD2C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD2C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD2C8);
		  /* 820FD2C8h */ case    0:  		/* mfspr R12, LR */
		/* 820FD2C8h case    0:*/		regs.R12 = regs.LR;
		/* 820FD2C8h case    0:*/		return 0x820FD2CC;
		  /* 820FD2CCh */ case    1:  		/* bl -442488 */
		/* 820FD2CCh case    1:*/		regs.LR = 0x820FD2D0; return 0x82091254;
		/* 820FD2CCh case    1:*/		return 0x820FD2D0;
		  /* 820FD2D0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820FD2D0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820FD2D0h case    2:*/		return 0x820FD2D4;
		  /* 820FD2D4h */ case    3:  		/* mr R27, R3 */
		/* 820FD2D4h case    3:*/		regs.R27 = regs.R3;
		/* 820FD2D4h case    3:*/		return 0x820FD2D8;
		  /* 820FD2D8h */ case    4:  		/* li R3, 116 */
		/* 820FD2D8h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x74);
		/* 820FD2D8h case    4:*/		return 0x820FD2DC;
		  /* 820FD2DCh */ case    5:  		/* mr R30, R4 */
		/* 820FD2DCh case    5:*/		regs.R30 = regs.R4;
		/* 820FD2DCh case    5:*/		return 0x820FD2E0;
		  /* 820FD2E0h */ case    6:  		/* mr R29, R5 */
		/* 820FD2E0h case    6:*/		regs.R29 = regs.R5;
		/* 820FD2E0h case    6:*/		return 0x820FD2E4;
		  /* 820FD2E4h */ case    7:  		/* mr R28, R6 */
		/* 820FD2E4h case    7:*/		regs.R28 = regs.R6;
		/* 820FD2E4h case    7:*/		return 0x820FD2E8;
		  /* 820FD2E8h */ case    8:  		/* bl -3408 */
		/* 820FD2E8h case    8:*/		regs.LR = 0x820FD2EC; return 0x820FC598;
		/* 820FD2E8h case    8:*/		return 0x820FD2EC;
		  /* 820FD2ECh */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820FD2ECh case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820FD2ECh case    9:*/		return 0x820FD2F0;
		  /* 820FD2F0h */ case   10:  		/* bc 12, CR0_EQ, 16 */
		/* 820FD2F0h case   10:*/		if ( regs.CR[0].eq ) { return 0x820FD300;  }
		/* 820FD2F0h case   10:*/		return 0x820FD2F4;
		  /* 820FD2F4h */ case   11:  		/* bl -5204 */
		/* 820FD2F4h case   11:*/		regs.LR = 0x820FD2F8; return 0x820FBEA0;
		/* 820FD2F4h case   11:*/		return 0x820FD2F8;
		  /* 820FD2F8h */ case   12:  		/* mr R31, R3 */
		/* 820FD2F8h case   12:*/		regs.R31 = regs.R3;
		/* 820FD2F8h case   12:*/		return 0x820FD2FC;
		  /* 820FD2FCh */ case   13:  		/* b 8 */
		/* 820FD2FCh case   13:*/		return 0x820FD304;
		/* 820FD2FCh case   13:*/		return 0x820FD300;
	}
	return 0x820FD300;
} // Block from 820FD2C8h-820FD300h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820FD300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD300);
		  /* 820FD300h */ case    0:  		/* li R31, 0 */
		/* 820FD300h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820FD300h case    0:*/		return 0x820FD304;
	}
	return 0x820FD304;
} // Block from 820FD300h-820FD304h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FD304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD304);
		  /* 820FD304h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820FD304h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820FD304h case    0:*/		return 0x820FD308;
		  /* 820FD308h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820FD308h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820FD314;  }
		/* 820FD308h case    1:*/		return 0x820FD30C;
		  /* 820FD30Ch */ case    2:  		/* li R3, -1 */
		/* 820FD30Ch case    2:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820FD30Ch case    2:*/		return 0x820FD310;
		  /* 820FD310h */ case    3:  		/* b 68 */
		/* 820FD310h case    3:*/		return 0x820FD354;
		/* 820FD310h case    3:*/		return 0x820FD314;
	}
	return 0x820FD314;
} // Block from 820FD304h-820FD314h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FD314h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD314( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD314) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD314);
		  /* 820FD314h */ case    0:  		/* li R7, 0 */
		/* 820FD314h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820FD314h case    0:*/		return 0x820FD318;
		  /* 820FD318h */ case    1:  		/* mr R6, R28 */
		/* 820FD318h case    1:*/		regs.R6 = regs.R28;
		/* 820FD318h case    1:*/		return 0x820FD31C;
		  /* 820FD31Ch */ case    2:  		/* mr R5, R29 */
		/* 820FD31Ch case    2:*/		regs.R5 = regs.R29;
		/* 820FD31Ch case    2:*/		return 0x820FD320;
		  /* 820FD320h */ case    3:  		/* mr R4, R30 */
		/* 820FD320h case    3:*/		regs.R4 = regs.R30;
		/* 820FD320h case    3:*/		return 0x820FD324;
		  /* 820FD324h */ case    4:  		/* mr R3, R31 */
		/* 820FD324h case    4:*/		regs.R3 = regs.R31;
		/* 820FD324h case    4:*/		return 0x820FD328;
		  /* 820FD328h */ case    5:  		/* bl -3320 */
		/* 820FD328h case    5:*/		regs.LR = 0x820FD32C; return 0x820FC630;
		/* 820FD328h case    5:*/		return 0x820FD32C;
		  /* 820FD32Ch */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820FD32Ch case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FD32Ch case    6:*/		return 0x820FD330;
		  /* 820FD330h */ case    7:  		/* bc 4, CR0_LT, 24 */
		/* 820FD330h case    7:*/		if ( !regs.CR[0].lt ) { return 0x820FD348;  }
		/* 820FD330h case    7:*/		return 0x820FD334;
		  /* 820FD334h */ case    8:  		/* mr R3, R31 */
		/* 820FD334h case    8:*/		regs.R3 = regs.R31;
		/* 820FD334h case    8:*/		return 0x820FD338;
		  /* 820FD338h */ case    9:  		/* bl 1179784 */
		/* 820FD338h case    9:*/		regs.LR = 0x820FD33C; return 0x8221D3C0;
		/* 820FD338h case    9:*/		return 0x820FD33C;
		  /* 820FD33Ch */ case   10:  		/* mr R3, R31 */
		/* 820FD33Ch case   10:*/		regs.R3 = regs.R31;
		/* 820FD33Ch case   10:*/		return 0x820FD340;
		  /* 820FD340h */ case   11:  		/* bl -3408 */
		/* 820FD340h case   11:*/		regs.LR = 0x820FD344; return 0x820FC5F0;
		/* 820FD340h case   11:*/		return 0x820FD344;
		  /* 820FD344h */ case   12:  		/* b -56 */
		/* 820FD344h case   12:*/		return 0x820FD30C;
		/* 820FD344h case   12:*/		return 0x820FD348;
	}
	return 0x820FD348;
} // Block from 820FD314h-820FD348h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FD348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD348);
		  /* 820FD348h */ case    0:  		/* mr R4, R31 */
		/* 820FD348h case    0:*/		regs.R4 = regs.R31;
		/* 820FD348h case    0:*/		return 0x820FD34C;
		  /* 820FD34Ch */ case    1:  		/* mr R3, R27 */
		/* 820FD34Ch case    1:*/		regs.R3 = regs.R27;
		/* 820FD34Ch case    1:*/		return 0x820FD350;
		  /* 820FD350h */ case    2:  		/* bl -664 */
		/* 820FD350h case    2:*/		regs.LR = 0x820FD354; return 0x820FD0B8;
		/* 820FD350h case    2:*/		return 0x820FD354;
	}
	return 0x820FD354;
} // Block from 820FD348h-820FD354h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FD354h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD354( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD354) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD354);
		  /* 820FD354h */ case    0:  		/* addi R1, R1, 128 */
		/* 820FD354h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820FD354h case    0:*/		return 0x820FD358;
		  /* 820FD358h */ case    1:  		/* b -442548 */
		/* 820FD358h case    1:*/		return 0x820912A4;
		/* 820FD358h case    1:*/		return 0x820FD35C;
		  /* 820FD35Ch */ case    2:  		/* nop */
		/* 820FD35Ch case    2:*/		cpu::op::nop();
		/* 820FD35Ch case    2:*/		return 0x820FD360;
	}
	return 0x820FD360;
} // Block from 820FD354h-820FD360h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FD360h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD360);
		  /* 820FD360h */ case    0:  		/* mfspr R12, LR */
		/* 820FD360h case    0:*/		regs.R12 = regs.LR;
		/* 820FD360h case    0:*/		return 0x820FD364;
		  /* 820FD364h */ case    1:  		/* bl -442632 */
		/* 820FD364h case    1:*/		regs.LR = 0x820FD368; return 0x8209125C;
		/* 820FD364h case    1:*/		return 0x820FD368;
		  /* 820FD368h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820FD368h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820FD368h case    2:*/		return 0x820FD36C;
		  /* 820FD36Ch */ case    3:  		/* mr R29, R3 */
		/* 820FD36Ch case    3:*/		regs.R29 = regs.R3;
		/* 820FD36Ch case    3:*/		return 0x820FD370;
		  /* 820FD370h */ case    4:  		/* mr R30, R4 */
		/* 820FD370h case    4:*/		regs.R30 = regs.R4;
		/* 820FD370h case    4:*/		return 0x820FD374;
		  /* 820FD374h */ case    5:  		/* lis R4, 9345 */
		/* 820FD374h case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820FD374h case    5:*/		return 0x820FD378;
		  /* 820FD378h */ case    6:  		/* li R3, 52 */
		/* 820FD378h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x34);
		/* 820FD378h case    6:*/		return 0x820FD37C;
		  /* 820FD37Ch */ case    7:  		/* bl -479612 */
		/* 820FD37Ch case    7:*/		regs.LR = 0x820FD380; return 0x82088200;
		/* 820FD37Ch case    7:*/		return 0x820FD380;
		  /* 820FD380h */ case    8:  		/* cmplwi CR0, R3, 0 */
		/* 820FD380h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820FD380h case    8:*/		return 0x820FD384;
		  /* 820FD384h */ case    9:  		/* bc 12, CR0_EQ, 16 */
		/* 820FD384h case    9:*/		if ( regs.CR[0].eq ) { return 0x820FD394;  }
		/* 820FD384h case    9:*/		return 0x820FD388;
		  /* 820FD388h */ case   10:  		/* bl 1179704 */
		/* 820FD388h case   10:*/		regs.LR = 0x820FD38C; return 0x8221D3C0;
		/* 820FD388h case   10:*/		return 0x820FD38C;
		  /* 820FD38Ch */ case   11:  		/* mr R31, R3 */
		/* 820FD38Ch case   11:*/		regs.R31 = regs.R3;
		/* 820FD38Ch case   11:*/		return 0x820FD390;
		  /* 820FD390h */ case   12:  		/* b 8 */
		/* 820FD390h case   12:*/		return 0x820FD398;
		/* 820FD390h case   12:*/		return 0x820FD394;
	}
	return 0x820FD394;
} // Block from 820FD360h-820FD394h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FD394h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD394( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD394) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD394);
		  /* 820FD394h */ case    0:  		/* li R31, 0 */
		/* 820FD394h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820FD394h case    0:*/		return 0x820FD398;
	}
	return 0x820FD398;
} // Block from 820FD394h-820FD398h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FD398h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD398);
		  /* 820FD398h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820FD398h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820FD398h case    0:*/		return 0x820FD39C;
		  /* 820FD39Ch */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820FD39Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820FD3A8;  }
		/* 820FD39Ch case    1:*/		return 0x820FD3A0;
		  /* 820FD3A0h */ case    2:  		/* li R3, -1 */
		/* 820FD3A0h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820FD3A0h case    2:*/		return 0x820FD3A4;
		  /* 820FD3A4h */ case    3:  		/* b 60 */
		/* 820FD3A4h case    3:*/		return 0x820FD3E0;
		/* 820FD3A4h case    3:*/		return 0x820FD3A8;
	}
	return 0x820FD3A8;
} // Block from 820FD398h-820FD3A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FD3A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD3A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD3A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD3A8);
		  /* 820FD3A8h */ case    0:  		/* mr R4, R30 */
		/* 820FD3A8h case    0:*/		regs.R4 = regs.R30;
		/* 820FD3A8h case    0:*/		return 0x820FD3AC;
		  /* 820FD3ACh */ case    1:  		/* mr R3, R31 */
		/* 820FD3ACh case    1:*/		regs.R3 = regs.R31;
		/* 820FD3ACh case    1:*/		return 0x820FD3B0;
		  /* 820FD3B0h */ case    2:  		/* bl 291264 */
		/* 820FD3B0h case    2:*/		regs.LR = 0x820FD3B4; return 0x82144570;
		/* 820FD3B0h case    2:*/		return 0x820FD3B4;
		  /* 820FD3B4h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820FD3B4h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FD3B4h case    3:*/		return 0x820FD3B8;
		  /* 820FD3B8h */ case    4:  		/* bc 4, CR0_LT, 28 */
		/* 820FD3B8h case    4:*/		if ( !regs.CR[0].lt ) { return 0x820FD3D4;  }
		/* 820FD3B8h case    4:*/		return 0x820FD3BC;
		  /* 820FD3BCh */ case    5:  		/* mr R3, R31 */
		/* 820FD3BCh case    5:*/		regs.R3 = regs.R31;
		/* 820FD3BCh case    5:*/		return 0x820FD3C0;
		  /* 820FD3C0h */ case    6:  		/* bl 1179648 */
		/* 820FD3C0h case    6:*/		regs.LR = 0x820FD3C4; return 0x8221D3C0;
		/* 820FD3C0h case    6:*/		return 0x820FD3C4;
		  /* 820FD3C4h */ case    7:  		/* lis R4, 9345 */
		/* 820FD3C4h case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820FD3C4h case    7:*/		return 0x820FD3C8;
		  /* 820FD3C8h */ case    8:  		/* mr R3, R31 */
		/* 820FD3C8h case    8:*/		regs.R3 = regs.R31;
		/* 820FD3C8h case    8:*/		return 0x820FD3CC;
		  /* 820FD3CCh */ case    9:  		/* bl -479380 */
		/* 820FD3CCh case    9:*/		regs.LR = 0x820FD3D0; return 0x82088338;
		/* 820FD3CCh case    9:*/		return 0x820FD3D0;
		  /* 820FD3D0h */ case   10:  		/* b -48 */
		/* 820FD3D0h case   10:*/		return 0x820FD3A0;
		/* 820FD3D0h case   10:*/		return 0x820FD3D4;
	}
	return 0x820FD3D4;
} // Block from 820FD3A8h-820FD3D4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FD3D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD3D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD3D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD3D4);
		  /* 820FD3D4h */ case    0:  		/* mr R4, R31 */
		/* 820FD3D4h case    0:*/		regs.R4 = regs.R31;
		/* 820FD3D4h case    0:*/		return 0x820FD3D8;
		  /* 820FD3D8h */ case    1:  		/* mr R3, R29 */
		/* 820FD3D8h case    1:*/		regs.R3 = regs.R29;
		/* 820FD3D8h case    1:*/		return 0x820FD3DC;
		  /* 820FD3DCh */ case    2:  		/* bl -1460 */
		/* 820FD3DCh case    2:*/		regs.LR = 0x820FD3E0; return 0x820FCE28;
		/* 820FD3DCh case    2:*/		return 0x820FD3E0;
	}
	return 0x820FD3E0;
} // Block from 820FD3D4h-820FD3E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FD3E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD3E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD3E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD3E0);
		  /* 820FD3E0h */ case    0:  		/* addi R1, R1, 112 */
		/* 820FD3E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820FD3E0h case    0:*/		return 0x820FD3E4;
		  /* 820FD3E4h */ case    1:  		/* b -442680 */
		/* 820FD3E4h case    1:*/		return 0x820912AC;
		/* 820FD3E4h case    1:*/		return 0x820FD3E8;
	}
	return 0x820FD3E8;
} // Block from 820FD3E0h-820FD3E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FD3E8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD3E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD3E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD3E8);
		  /* 820FD3E8h */ case    0:  		/* mfspr R12, LR */
		/* 820FD3E8h case    0:*/		regs.R12 = regs.LR;
		/* 820FD3E8h case    0:*/		return 0x820FD3EC;
		  /* 820FD3ECh */ case    1:  		/* bl -442768 */
		/* 820FD3ECh case    1:*/		regs.LR = 0x820FD3F0; return 0x8209125C;
		/* 820FD3ECh case    1:*/		return 0x820FD3F0;
		  /* 820FD3F0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820FD3F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820FD3F0h case    2:*/		return 0x820FD3F4;
		  /* 820FD3F4h */ case    3:  		/* mr R29, R3 */
		/* 820FD3F4h case    3:*/		regs.R29 = regs.R3;
		/* 820FD3F4h case    3:*/		return 0x820FD3F8;
		  /* 820FD3F8h */ case    4:  		/* li R3, 128 */
		/* 820FD3F8h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x80);
		/* 820FD3F8h case    4:*/		return 0x820FD3FC;
		  /* 820FD3FCh */ case    5:  		/* mr R30, R4 */
		/* 820FD3FCh case    5:*/		regs.R30 = regs.R4;
		/* 820FD3FCh case    5:*/		return 0x820FD400;
		  /* 820FD400h */ case    6:  		/* bl -1752 */
		/* 820FD400h case    6:*/		regs.LR = 0x820FD404; return 0x820FCD28;
		/* 820FD400h case    6:*/		return 0x820FD404;
		  /* 820FD404h */ case    7:  		/* cmplwi CR0, R3, 0 */
		/* 820FD404h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820FD404h case    7:*/		return 0x820FD408;
		  /* 820FD408h */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 820FD408h case    8:*/		if ( regs.CR[0].eq ) { return 0x820FD418;  }
		/* 820FD408h case    8:*/		return 0x820FD40C;
		  /* 820FD40Ch */ case    9:  		/* bl 1179572 */
		/* 820FD40Ch case    9:*/		regs.LR = 0x820FD410; return 0x8221D3C0;
		/* 820FD40Ch case    9:*/		return 0x820FD410;
		  /* 820FD410h */ case   10:  		/* mr R31, R3 */
		/* 820FD410h case   10:*/		regs.R31 = regs.R3;
		/* 820FD410h case   10:*/		return 0x820FD414;
		  /* 820FD414h */ case   11:  		/* b 8 */
		/* 820FD414h case   11:*/		return 0x820FD41C;
		/* 820FD414h case   11:*/		return 0x820FD418;
	}
	return 0x820FD418;
} // Block from 820FD3E8h-820FD418h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820FD418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD418);
		  /* 820FD418h */ case    0:  		/* li R31, 0 */
		/* 820FD418h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820FD418h case    0:*/		return 0x820FD41C;
	}
	return 0x820FD41C;
} // Block from 820FD418h-820FD41Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FD41Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD41C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD41C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD41C);
		  /* 820FD41Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820FD41Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820FD41Ch case    0:*/		return 0x820FD420;
		  /* 820FD420h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820FD420h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820FD42C;  }
		/* 820FD420h case    1:*/		return 0x820FD424;
		  /* 820FD424h */ case    2:  		/* li R3, -1 */
		/* 820FD424h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820FD424h case    2:*/		return 0x820FD428;
		  /* 820FD428h */ case    3:  		/* b 56 */
		/* 820FD428h case    3:*/		return 0x820FD460;
		/* 820FD428h case    3:*/		return 0x820FD42C;
	}
	return 0x820FD42C;
} // Block from 820FD41Ch-820FD42Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FD42Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD42C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD42C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD42C);
		  /* 820FD42Ch */ case    0:  		/* mr R4, R30 */
		/* 820FD42Ch case    0:*/		regs.R4 = regs.R30;
		/* 820FD42Ch case    0:*/		return 0x820FD430;
		  /* 820FD430h */ case    1:  		/* mr R3, R31 */
		/* 820FD430h case    1:*/		regs.R3 = regs.R31;
		/* 820FD430h case    1:*/		return 0x820FD434;
		  /* 820FD434h */ case    2:  		/* bl -2188 */
		/* 820FD434h case    2:*/		regs.LR = 0x820FD438; return 0x820FCBA8;
		/* 820FD434h case    2:*/		return 0x820FD438;
		  /* 820FD438h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820FD438h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FD438h case    3:*/		return 0x820FD43C;
		  /* 820FD43Ch */ case    4:  		/* bc 4, CR0_LT, 24 */
		/* 820FD43Ch case    4:*/		if ( !regs.CR[0].lt ) { return 0x820FD454;  }
		/* 820FD43Ch case    4:*/		return 0x820FD440;
		  /* 820FD440h */ case    5:  		/* mr R3, R31 */
		/* 820FD440h case    5:*/		regs.R3 = regs.R31;
		/* 820FD440h case    5:*/		return 0x820FD444;
		  /* 820FD444h */ case    6:  		/* bl 1179516 */
		/* 820FD444h case    6:*/		regs.LR = 0x820FD448; return 0x8221D3C0;
		/* 820FD444h case    6:*/		return 0x820FD448;
		  /* 820FD448h */ case    7:  		/* mr R3, R31 */
		/* 820FD448h case    7:*/		regs.R3 = regs.R31;
		/* 820FD448h case    7:*/		return 0x820FD44C;
		  /* 820FD44Ch */ case    8:  		/* bl -1740 */
		/* 820FD44Ch case    8:*/		regs.LR = 0x820FD450; return 0x820FCD80;
		/* 820FD44Ch case    8:*/		return 0x820FD450;
		  /* 820FD450h */ case    9:  		/* b -44 */
		/* 820FD450h case    9:*/		return 0x820FD424;
		/* 820FD450h case    9:*/		return 0x820FD454;
	}
	return 0x820FD454;
} // Block from 820FD42Ch-820FD454h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FD454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD454);
		  /* 820FD454h */ case    0:  		/* mr R4, R31 */
		/* 820FD454h case    0:*/		regs.R4 = regs.R31;
		/* 820FD454h case    0:*/		return 0x820FD458;
		  /* 820FD458h */ case    1:  		/* mr R3, R29 */
		/* 820FD458h case    1:*/		regs.R3 = regs.R29;
		/* 820FD458h case    1:*/		return 0x820FD45C;
		  /* 820FD45Ch */ case    2:  		/* bl -1372 */
		/* 820FD45Ch case    2:*/		regs.LR = 0x820FD460; return 0x820FCF00;
		/* 820FD45Ch case    2:*/		return 0x820FD460;
	}
	return 0x820FD460;
} // Block from 820FD454h-820FD460h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FD460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD460);
		  /* 820FD460h */ case    0:  		/* addi R1, R1, 112 */
		/* 820FD460h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820FD460h case    0:*/		return 0x820FD464;
		  /* 820FD464h */ case    1:  		/* b -442808 */
		/* 820FD464h case    1:*/		return 0x820912AC;
		/* 820FD464h case    1:*/		return 0x820FD468;
	}
	return 0x820FD468;
} // Block from 820FD460h-820FD468h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FD468h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD468( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD468) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD468);
		  /* 820FD468h */ case    0:  		/* mfspr R12, LR */
		/* 820FD468h case    0:*/		regs.R12 = regs.LR;
		/* 820FD468h case    0:*/		return 0x820FD46C;
		  /* 820FD46Ch */ case    1:  		/* bl -442896 */
		/* 820FD46Ch case    1:*/		regs.LR = 0x820FD470; return 0x8209125C;
		/* 820FD46Ch case    1:*/		return 0x820FD470;
		  /* 820FD470h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820FD470h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820FD470h case    2:*/		return 0x820FD474;
		  /* 820FD474h */ case    3:  		/* mr R29, R3 */
		/* 820FD474h case    3:*/		regs.R29 = regs.R3;
		/* 820FD474h case    3:*/		return 0x820FD478;
		  /* 820FD478h */ case    4:  		/* li R3, 116 */
		/* 820FD478h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x74);
		/* 820FD478h case    4:*/		return 0x820FD47C;
		  /* 820FD47Ch */ case    5:  		/* mr R30, R4 */
		/* 820FD47Ch case    5:*/		regs.R30 = regs.R4;
		/* 820FD47Ch case    5:*/		return 0x820FD480;
		  /* 820FD480h */ case    6:  		/* bl -3816 */
		/* 820FD480h case    6:*/		regs.LR = 0x820FD484; return 0x820FC598;
		/* 820FD480h case    6:*/		return 0x820FD484;
		  /* 820FD484h */ case    7:  		/* cmplwi CR0, R3, 0 */
		/* 820FD484h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820FD484h case    7:*/		return 0x820FD488;
		  /* 820FD488h */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 820FD488h case    8:*/		if ( regs.CR[0].eq ) { return 0x820FD498;  }
		/* 820FD488h case    8:*/		return 0x820FD48C;
		  /* 820FD48Ch */ case    9:  		/* bl -5612 */
		/* 820FD48Ch case    9:*/		regs.LR = 0x820FD490; return 0x820FBEA0;
		/* 820FD48Ch case    9:*/		return 0x820FD490;
		  /* 820FD490h */ case   10:  		/* mr R31, R3 */
		/* 820FD490h case   10:*/		regs.R31 = regs.R3;
		/* 820FD490h case   10:*/		return 0x820FD494;
		  /* 820FD494h */ case   11:  		/* b 8 */
		/* 820FD494h case   11:*/		return 0x820FD49C;
		/* 820FD494h case   11:*/		return 0x820FD498;
	}
	return 0x820FD498;
} // Block from 820FD468h-820FD498h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820FD498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD498);
		  /* 820FD498h */ case    0:  		/* li R31, 0 */
		/* 820FD498h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820FD498h case    0:*/		return 0x820FD49C;
	}
	return 0x820FD49C;
} // Block from 820FD498h-820FD49Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FD49Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD49C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD49C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD49C);
		  /* 820FD49Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820FD49Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820FD49Ch case    0:*/		return 0x820FD4A0;
		  /* 820FD4A0h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820FD4A0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820FD4AC;  }
		/* 820FD4A0h case    1:*/		return 0x820FD4A4;
		  /* 820FD4A4h */ case    2:  		/* li R3, -1 */
		/* 820FD4A4h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820FD4A4h case    2:*/		return 0x820FD4A8;
		  /* 820FD4A8h */ case    3:  		/* b 56 */
		/* 820FD4A8h case    3:*/		return 0x820FD4E0;
		/* 820FD4A8h case    3:*/		return 0x820FD4AC;
	}
	return 0x820FD4AC;
} // Block from 820FD49Ch-820FD4ACh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FD4ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD4AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD4AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD4AC);
		  /* 820FD4ACh */ case    0:  		/* mr R4, R30 */
		/* 820FD4ACh case    0:*/		regs.R4 = regs.R30;
		/* 820FD4ACh case    0:*/		return 0x820FD4B0;
		  /* 820FD4B0h */ case    1:  		/* mr R3, R31 */
		/* 820FD4B0h case    1:*/		regs.R3 = regs.R31;
		/* 820FD4B0h case    1:*/		return 0x820FD4B4;
		  /* 820FD4B4h */ case    2:  		/* bl -2916 */
		/* 820FD4B4h case    2:*/		regs.LR = 0x820FD4B8; return 0x820FC950;
		/* 820FD4B4h case    2:*/		return 0x820FD4B8;
		  /* 820FD4B8h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820FD4B8h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FD4B8h case    3:*/		return 0x820FD4BC;
		  /* 820FD4BCh */ case    4:  		/* bc 4, CR0_LT, 24 */
		/* 820FD4BCh case    4:*/		if ( !regs.CR[0].lt ) { return 0x820FD4D4;  }
		/* 820FD4BCh case    4:*/		return 0x820FD4C0;
		  /* 820FD4C0h */ case    5:  		/* mr R3, R31 */
		/* 820FD4C0h case    5:*/		regs.R3 = regs.R31;
		/* 820FD4C0h case    5:*/		return 0x820FD4C4;
		  /* 820FD4C4h */ case    6:  		/* bl 1179388 */
		/* 820FD4C4h case    6:*/		regs.LR = 0x820FD4C8; return 0x8221D3C0;
		/* 820FD4C4h case    6:*/		return 0x820FD4C8;
		  /* 820FD4C8h */ case    7:  		/* mr R3, R31 */
		/* 820FD4C8h case    7:*/		regs.R3 = regs.R31;
		/* 820FD4C8h case    7:*/		return 0x820FD4CC;
		  /* 820FD4CCh */ case    8:  		/* bl -3804 */
		/* 820FD4CCh case    8:*/		regs.LR = 0x820FD4D0; return 0x820FC5F0;
		/* 820FD4CCh case    8:*/		return 0x820FD4D0;
		  /* 820FD4D0h */ case    9:  		/* b -44 */
		/* 820FD4D0h case    9:*/		return 0x820FD4A4;
		/* 820FD4D0h case    9:*/		return 0x820FD4D4;
	}
	return 0x820FD4D4;
} // Block from 820FD4ACh-820FD4D4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FD4D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD4D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD4D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD4D4);
		  /* 820FD4D4h */ case    0:  		/* mr R4, R31 */
		/* 820FD4D4h case    0:*/		regs.R4 = regs.R31;
		/* 820FD4D4h case    0:*/		return 0x820FD4D8;
		  /* 820FD4D8h */ case    1:  		/* mr R3, R29 */
		/* 820FD4D8h case    1:*/		regs.R3 = regs.R29;
		/* 820FD4D8h case    1:*/		return 0x820FD4DC;
		  /* 820FD4DCh */ case    2:  		/* bl -1060 */
		/* 820FD4DCh case    2:*/		regs.LR = 0x820FD4E0; return 0x820FD0B8;
		/* 820FD4DCh case    2:*/		return 0x820FD4E0;
	}
	return 0x820FD4E0;
} // Block from 820FD4D4h-820FD4E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FD4E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD4E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD4E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD4E0);
		  /* 820FD4E0h */ case    0:  		/* addi R1, R1, 112 */
		/* 820FD4E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820FD4E0h case    0:*/		return 0x820FD4E4;
		  /* 820FD4E4h */ case    1:  		/* b -442936 */
		/* 820FD4E4h case    1:*/		return 0x820912AC;
		/* 820FD4E4h case    1:*/		return 0x820FD4E8;
	}
	return 0x820FD4E8;
} // Block from 820FD4E0h-820FD4E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FD4E8h
// Function '?Initialize@CInstruction@D3DXShader@@QAAJPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD4E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD4E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD4E8);
		  /* 820FD4E8h */ case    0:  		/* mfspr R12, LR */
		/* 820FD4E8h case    0:*/		regs.R12 = regs.LR;
		/* 820FD4E8h case    0:*/		return 0x820FD4EC;
		  /* 820FD4ECh */ case    1:  		/* bl -443028 */
		/* 820FD4ECh case    1:*/		regs.LR = 0x820FD4F0; return 0x82091258;
		/* 820FD4ECh case    1:*/		return 0x820FD4F0;
		  /* 820FD4F0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820FD4F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820FD4F0h case    2:*/		return 0x820FD4F4;
		  /* 820FD4F4h */ case    3:  		/* lis R11, -32254 */
		/* 820FD4F4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820FD4F4h case    3:*/		return 0x820FD4F8;
		  /* 820FD4F8h */ case    4:  		/* lwz R10, <#[R3 + 16]> */
		/* 820FD4F8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 820FD4F8h case    4:*/		return 0x820FD4FC;
		  /* 820FD4FCh */ case    5:  		/* mr R31, R3 */
		/* 820FD4FCh case    5:*/		regs.R31 = regs.R3;
		/* 820FD4FCh case    5:*/		return 0x820FD500;
		  /* 820FD500h */ case    6:  		/* addi R11, R11, -14412 */
		/* 820FD500h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFC7B4);
		/* 820FD500h case    6:*/		return 0x820FD504;
		  /* 820FD504h */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 820FD504h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820FD504h case    7:*/		return 0x820FD508;
		  /* 820FD508h */ case    8:  		/* stw R11, <#[R3]> */
		/* 820FD508h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820FD508h case    8:*/		return 0x820FD50C;
		  /* 820FD50Ch */ case    9:  		/* bc 12, CR6_EQ, 92 */
		/* 820FD50Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820FD568;  }
		/* 820FD50Ch case    9:*/		return 0x820FD510;
		  /* 820FD510h */ case   10:  		/* lwz R11, <#[R3 + 4]> */
		/* 820FD510h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820FD510h case   10:*/		return 0x820FD514;
		  /* 820FD514h */ case   11:  		/* li R28, 0 */
		/* 820FD514h case   11:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820FD514h case   11:*/		return 0x820FD518;
		  /* 820FD518h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 820FD518h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FD518h case   12:*/		return 0x820FD51C;
		  /* 820FD51Ch */ case   13:  		/* bc 4, CR6_GT, 64 */
		/* 820FD51Ch case   13:*/		if ( !regs.CR[6].gt ) { return 0x820FD55C;  }
		/* 820FD51Ch case   13:*/		return 0x820FD520;
		  /* 820FD520h */ case   14:  		/* li R30, 0 */
		/* 820FD520h case   14:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820FD520h case   14:*/		return 0x820FD524;
		  /* 820FD524h */ case   15:  		/* lwz R11, <#[R31 + 16]> */
		/* 820FD524h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820FD524h case   15:*/		return 0x820FD528;
		  /* 820FD528h */ case   16:  		/* lwzx R29, <#[R30 + R11]> */
		/* 820FD528h case   16:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820FD528h case   16:*/		return 0x820FD52C;
		  /* 820FD52Ch */ case   17:  		/* cmplwi CR6, R29, 0 */
		/* 820FD52Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820FD52Ch case   17:*/		return 0x820FD530;
		  /* 820FD530h */ case   18:  		/* bc 12, CR6_EQ, 24 */
		/* 820FD530h case   18:*/		if ( regs.CR[6].eq ) { return 0x820FD548;  }
		/* 820FD530h case   18:*/		return 0x820FD534;
		  /* 820FD534h */ case   19:  		/* mr R3, R29 */
		/* 820FD534h case   19:*/		regs.R3 = regs.R29;
		/* 820FD534h case   19:*/		return 0x820FD538;
		  /* 820FD538h */ case   20:  		/* bl 1179272 */
		/* 820FD538h case   20:*/		regs.LR = 0x820FD53C; return 0x8221D3C0;
		/* 820FD538h case   20:*/		return 0x820FD53C;
		  /* 820FD53Ch */ case   21:  		/* lis R4, 9345 */
		/* 820FD53Ch case   21:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820FD53Ch case   21:*/		return 0x820FD540;
		  /* 820FD540h */ case   22:  		/* mr R3, R29 */
		/* 820FD540h case   22:*/		regs.R3 = regs.R29;
		/* 820FD540h case   22:*/		return 0x820FD544;
		  /* 820FD544h */ case   23:  		/* bl -479756 */
		/* 820FD544h case   23:*/		regs.LR = 0x820FD548; return 0x82088338;
		/* 820FD544h case   23:*/		return 0x820FD548;
	}
	return 0x820FD548;
} // Block from 820FD4E8h-820FD548h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820FD548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD548);
		  /* 820FD548h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 820FD548h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820FD548h case    0:*/		return 0x820FD54C;
		  /* 820FD54Ch */ case    1:  		/* addi R28, R28, 1 */
		/* 820FD54Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820FD54Ch case    1:*/		return 0x820FD550;
		  /* 820FD550h */ case    2:  		/* addi R30, R30, 4 */
		/* 820FD550h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820FD550h case    2:*/		return 0x820FD554;
		  /* 820FD554h */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 820FD554h case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820FD554h case    3:*/		return 0x820FD558;
		  /* 820FD558h */ case    4:  		/* bc 12, CR6_LT, -52 */
		/* 820FD558h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FD524;  }
		/* 820FD558h case    4:*/		return 0x820FD55C;
	}
	return 0x820FD55C;
} // Block from 820FD548h-820FD55Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FD55Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD55C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD55C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD55C);
		  /* 820FD55Ch */ case    0:  		/* lis R4, 9345 */
		/* 820FD55Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820FD55Ch case    0:*/		return 0x820FD560;
		  /* 820FD560h */ case    1:  		/* lwz R3, <#[R31 + 16]> */
		/* 820FD560h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 820FD560h case    1:*/		return 0x820FD564;
		  /* 820FD564h */ case    2:  		/* bl -479788 */
		/* 820FD564h case    2:*/		regs.LR = 0x820FD568; return 0x82088338;
		/* 820FD564h case    2:*/		return 0x820FD568;
	}
	return 0x820FD568;
} // Block from 820FD55Ch-820FD568h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FD568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD568);
		  /* 820FD568h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 820FD568h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820FD568h case    0:*/		return 0x820FD56C;
		  /* 820FD56Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820FD56Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FD56Ch case    1:*/		return 0x820FD570;
		  /* 820FD570h */ case    2:  		/* bc 12, CR6_EQ, 88 */
		/* 820FD570h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FD5C8;  }
		/* 820FD570h case    2:*/		return 0x820FD574;
		  /* 820FD574h */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 820FD574h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820FD574h case    3:*/		return 0x820FD578;
		  /* 820FD578h */ case    4:  		/* li R28, 0 */
		/* 820FD578h case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820FD578h case    4:*/		return 0x820FD57C;
		  /* 820FD57Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820FD57Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FD57Ch case    5:*/		return 0x820FD580;
		  /* 820FD580h */ case    6:  		/* bc 4, CR6_GT, 60 */
		/* 820FD580h case    6:*/		if ( !regs.CR[6].gt ) { return 0x820FD5BC;  }
		/* 820FD580h case    6:*/		return 0x820FD584;
		  /* 820FD584h */ case    7:  		/* li R30, 0 */
		/* 820FD584h case    7:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820FD584h case    7:*/		return 0x820FD588;
		  /* 820FD588h */ case    8:  		/* lwz R11, <#[R31 + 20]> */
		/* 820FD588h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820FD588h case    8:*/		return 0x820FD58C;
		  /* 820FD58Ch */ case    9:  		/* lwzx R29, <#[R11 + R30]> */
		/* 820FD58Ch case    9:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820FD58Ch case    9:*/		return 0x820FD590;
		  /* 820FD590h */ case   10:  		/* cmplwi CR6, R29, 0 */
		/* 820FD590h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820FD590h case   10:*/		return 0x820FD594;
		  /* 820FD594h */ case   11:  		/* bc 12, CR6_EQ, 20 */
		/* 820FD594h case   11:*/		if ( regs.CR[6].eq ) { return 0x820FD5A8;  }
		/* 820FD594h case   11:*/		return 0x820FD598;
		  /* 820FD598h */ case   12:  		/* mr R3, R29 */
		/* 820FD598h case   12:*/		regs.R3 = regs.R29;
		/* 820FD598h case   12:*/		return 0x820FD59C;
		  /* 820FD59Ch */ case   13:  		/* bl 1179172 */
		/* 820FD59Ch case   13:*/		regs.LR = 0x820FD5A0; return 0x8221D3C0;
		/* 820FD59Ch case   13:*/		return 0x820FD5A0;
		  /* 820FD5A0h */ case   14:  		/* mr R3, R29 */
		/* 820FD5A0h case   14:*/		regs.R3 = regs.R29;
		/* 820FD5A0h case   14:*/		return 0x820FD5A4;
		  /* 820FD5A4h */ case   15:  		/* bl -2084 */
		/* 820FD5A4h case   15:*/		regs.LR = 0x820FD5A8; return 0x820FCD80;
		/* 820FD5A4h case   15:*/		return 0x820FD5A8;
	}
	return 0x820FD5A8;
} // Block from 820FD568h-820FD5A8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820FD5A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD5A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD5A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD5A8);
		  /* 820FD5A8h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820FD5A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820FD5A8h case    0:*/		return 0x820FD5AC;
		  /* 820FD5ACh */ case    1:  		/* addi R28, R28, 1 */
		/* 820FD5ACh case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820FD5ACh case    1:*/		return 0x820FD5B0;
		  /* 820FD5B0h */ case    2:  		/* addi R30, R30, 4 */
		/* 820FD5B0h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820FD5B0h case    2:*/		return 0x820FD5B4;
		  /* 820FD5B4h */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 820FD5B4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820FD5B4h case    3:*/		return 0x820FD5B8;
		  /* 820FD5B8h */ case    4:  		/* bc 12, CR6_LT, -48 */
		/* 820FD5B8h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FD588;  }
		/* 820FD5B8h case    4:*/		return 0x820FD5BC;
	}
	return 0x820FD5BC;
} // Block from 820FD5A8h-820FD5BCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FD5BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD5BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD5BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD5BC);
		  /* 820FD5BCh */ case    0:  		/* lis R4, 9345 */
		/* 820FD5BCh case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820FD5BCh case    0:*/		return 0x820FD5C0;
		  /* 820FD5C0h */ case    1:  		/* lwz R3, <#[R31 + 20]> */
		/* 820FD5C0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 820FD5C0h case    1:*/		return 0x820FD5C4;
		  /* 820FD5C4h */ case    2:  		/* bl -479884 */
		/* 820FD5C4h case    2:*/		regs.LR = 0x820FD5C8; return 0x82088338;
		/* 820FD5C4h case    2:*/		return 0x820FD5C8;
	}
	return 0x820FD5C8;
} // Block from 820FD5BCh-820FD5C8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FD5C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD5C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD5C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD5C8);
		  /* 820FD5C8h */ case    0:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FD5C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FD5C8h case    0:*/		return 0x820FD5CC;
		  /* 820FD5CCh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820FD5CCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FD5CCh case    1:*/		return 0x820FD5D0;
		  /* 820FD5D0h */ case    2:  		/* bc 12, CR6_EQ, 88 */
		/* 820FD5D0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FD628;  }
		/* 820FD5D0h case    2:*/		return 0x820FD5D4;
		  /* 820FD5D4h */ case    3:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FD5D4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FD5D4h case    3:*/		return 0x820FD5D8;
		  /* 820FD5D8h */ case    4:  		/* li R28, 0 */
		/* 820FD5D8h case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820FD5D8h case    4:*/		return 0x820FD5DC;
		  /* 820FD5DCh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820FD5DCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FD5DCh case    5:*/		return 0x820FD5E0;
		  /* 820FD5E0h */ case    6:  		/* bc 4, CR6_GT, 60 */
		/* 820FD5E0h case    6:*/		if ( !regs.CR[6].gt ) { return 0x820FD61C;  }
		/* 820FD5E0h case    6:*/		return 0x820FD5E4;
		  /* 820FD5E4h */ case    7:  		/* li R30, 0 */
		/* 820FD5E4h case    7:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820FD5E4h case    7:*/		return 0x820FD5E8;
		  /* 820FD5E8h */ case    8:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FD5E8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FD5E8h case    8:*/		return 0x820FD5EC;
		  /* 820FD5ECh */ case    9:  		/* lwzx R29, <#[R11 + R30]> */
		/* 820FD5ECh case    9:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820FD5ECh case    9:*/		return 0x820FD5F0;
		  /* 820FD5F0h */ case   10:  		/* cmplwi CR6, R29, 0 */
		/* 820FD5F0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820FD5F0h case   10:*/		return 0x820FD5F4;
		  /* 820FD5F4h */ case   11:  		/* bc 12, CR6_EQ, 20 */
		/* 820FD5F4h case   11:*/		if ( regs.CR[6].eq ) { return 0x820FD608;  }
		/* 820FD5F4h case   11:*/		return 0x820FD5F8;
		  /* 820FD5F8h */ case   12:  		/* mr R3, R29 */
		/* 820FD5F8h case   12:*/		regs.R3 = regs.R29;
		/* 820FD5F8h case   12:*/		return 0x820FD5FC;
		  /* 820FD5FCh */ case   13:  		/* bl 1179076 */
		/* 820FD5FCh case   13:*/		regs.LR = 0x820FD600; return 0x8221D3C0;
		/* 820FD5FCh case   13:*/		return 0x820FD600;
		  /* 820FD600h */ case   14:  		/* mr R3, R29 */
		/* 820FD600h case   14:*/		regs.R3 = regs.R29;
		/* 820FD600h case   14:*/		return 0x820FD604;
		  /* 820FD604h */ case   15:  		/* bl -4116 */
		/* 820FD604h case   15:*/		regs.LR = 0x820FD608; return 0x820FC5F0;
		/* 820FD604h case   15:*/		return 0x820FD608;
	}
	return 0x820FD608;
} // Block from 820FD5C8h-820FD608h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820FD608h
// Function '?GetOutputs@CInstruction@D3DXShader@@QAAIIPAPAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD608);
		  /* 820FD608h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FD608h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FD608h case    0:*/		return 0x820FD60C;
		  /* 820FD60Ch */ case    1:  		/* addi R28, R28, 1 */
		/* 820FD60Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820FD60Ch case    1:*/		return 0x820FD610;
		  /* 820FD610h */ case    2:  		/* addi R30, R30, 4 */
		/* 820FD610h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820FD610h case    2:*/		return 0x820FD614;
		  /* 820FD614h */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 820FD614h case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820FD614h case    3:*/		return 0x820FD618;
		  /* 820FD618h */ case    4:  		/* bc 12, CR6_LT, -48 */
		/* 820FD618h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FD5E8;  }
		/* 820FD618h case    4:*/		return 0x820FD61C;
	}
	return 0x820FD61C;
} // Block from 820FD608h-820FD61Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FD61Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD61C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD61C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD61C);
		  /* 820FD61Ch */ case    0:  		/* lis R4, 9345 */
		/* 820FD61Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820FD61Ch case    0:*/		return 0x820FD620;
		  /* 820FD620h */ case    1:  		/* lwz R3, <#[R31 + 24]> */
		/* 820FD620h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 820FD620h case    1:*/		return 0x820FD624;
		  /* 820FD624h */ case    2:  		/* bl -479980 */
		/* 820FD624h case    2:*/		regs.LR = 0x820FD628; return 0x82088338;
		/* 820FD624h case    2:*/		return 0x820FD628;
	}
	return 0x820FD628;
} // Block from 820FD61Ch-820FD628h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FD628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD628);
		  /* 820FD628h */ case    0:  		/* addi R1, R1, 128 */
		/* 820FD628h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820FD628h case    0:*/		return 0x820FD62C;
		  /* 820FD62Ch */ case    1:  		/* b -443268 */
		/* 820FD62Ch case    1:*/		return 0x820912A8;
		/* 820FD62Ch case    1:*/		return 0x820FD630;
	}
	return 0x820FD630;
} // Block from 820FD628h-820FD630h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FD630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD630);
		  /* 820FD630h */ case    0:  		/* mfspr R12, LR */
		/* 820FD630h case    0:*/		regs.R12 = regs.LR;
		/* 820FD630h case    0:*/		return 0x820FD634;
		  /* 820FD634h */ case    1:  		/* bl -443368 */
		/* 820FD634h case    1:*/		regs.LR = 0x820FD638; return 0x8209124C;
		/* 820FD634h case    1:*/		return 0x820FD638;
		  /* 820FD638h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820FD638h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820FD638h case    2:*/		return 0x820FD63C;
		  /* 820FD63Ch */ case    3:  		/* lis R11, 16383 */
		/* 820FD63Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0x3FFF);
		/* 820FD63Ch case    3:*/		return 0x820FD640;
		  /* 820FD640h */ case    4:  		/* li R29, 0 */
		/* 820FD640h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820FD640h case    4:*/		return 0x820FD644;
		  /* 820FD644h */ case    5:  		/* ori R26, R11, 65535 */
		/* 820FD644h case    5:*/		cpu::op::ori<0>(regs,&regs.R26,regs.R11,0xFFFF);
		/* 820FD644h case    5:*/		return 0x820FD648;
		  /* 820FD648h */ case    6:  		/* stw R29, <#[R3 + 4]> */
		/* 820FD648h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000004) );
		/* 820FD648h case    6:*/		return 0x820FD64C;
		  /* 820FD64Ch */ case    7:  		/* mr R30, R3 */
		/* 820FD64Ch case    7:*/		regs.R30 = regs.R3;
		/* 820FD64Ch case    7:*/		return 0x820FD650;
		  /* 820FD650h */ case    8:  		/* lwz R11, <#[R4 + 4]> */
		/* 820FD650h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820FD650h case    8:*/		return 0x820FD654;
		  /* 820FD654h */ case    9:  		/* mr R31, R4 */
		/* 820FD654h case    9:*/		regs.R31 = regs.R4;
		/* 820FD654h case    9:*/		return 0x820FD658;
		  /* 820FD658h */ case   10:  		/* stw R11, <#[R3 + 28]> */
		/* 820FD658h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820FD658h case   10:*/		return 0x820FD65C;
		  /* 820FD65Ch */ case   11:  		/* li R25, -1 */
		/* 820FD65Ch case   11:*/		cpu::op::li<0>(regs,&regs.R25,0xFFFFFFFF);
		/* 820FD65Ch case   11:*/		return 0x820FD660;
		  /* 820FD660h */ case   12:  		/* cmplw CR6, R11, R26 */
		/* 820FD660h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 820FD660h case   12:*/		return 0x820FD664;
		  /* 820FD664h */ case   13:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820FD664h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820FD664h case   13:*/		return 0x820FD668;
		  /* 820FD668h */ case   14:  		/* bc 4, CR6_GT, 8 */
		/* 820FD668h case   14:*/		if ( !regs.CR[6].gt ) { return 0x820FD670;  }
		/* 820FD668h case   14:*/		return 0x820FD66C;
		  /* 820FD66Ch */ case   15:  		/* mr R3, R25 */
		/* 820FD66Ch case   15:*/		regs.R3 = regs.R25;
		/* 820FD66Ch case   15:*/		return 0x820FD670;
	}
	return 0x820FD670;
} // Block from 820FD630h-820FD670h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820FD670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD670);
		  /* 820FD670h */ case    0:  		/* bl -433960 */
		/* 820FD670h case    0:*/		regs.LR = 0x820FD674; return 0x82093748;
		/* 820FD670h case    0:*/		return 0x820FD674;
		  /* 820FD674h */ case    1:  		/* stw R3, <#[R30 + 16]> */
		/* 820FD674h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000010) );
		/* 820FD674h case    1:*/		return 0x820FD678;
		  /* 820FD678h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820FD678h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820FD678h case    2:*/		return 0x820FD67C;
		  /* 820FD67Ch */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 820FD67Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x820FD68C;  }
		/* 820FD67Ch case    3:*/		return 0x820FD680;
		  /* 820FD680h */ case    4:  		/* lis R3, -32761 */
		/* 820FD680h case    4:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820FD680h case    4:*/		return 0x820FD684;
		  /* 820FD684h */ case    5:  		/* ori R3, R3, 14 */
		/* 820FD684h case    5:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820FD684h case    5:*/		return 0x820FD688;
		  /* 820FD688h */ case    6:  		/* b 284 */
		/* 820FD688h case    6:*/		return 0x820FD7A4;
		/* 820FD688h case    6:*/		return 0x820FD68C;
	}
	return 0x820FD68C;
} // Block from 820FD670h-820FD68Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820FD68Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD68C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD68C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD68C);
		  /* 820FD68Ch */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 820FD68Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820FD68Ch case    0:*/		return 0x820FD690;
		  /* 820FD690h */ case    1:  		/* mr R27, R29 */
		/* 820FD690h case    1:*/		regs.R27 = regs.R29;
		/* 820FD690h case    1:*/		return 0x820FD694;
		  /* 820FD694h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820FD694h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FD694h case    2:*/		return 0x820FD698;
		  /* 820FD698h */ case    3:  		/* bc 4, CR6_GT, 52 */
		/* 820FD698h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820FD6CC;  }
		/* 820FD698h case    3:*/		return 0x820FD69C;
		  /* 820FD69Ch */ case    4:  		/* mr R28, R29 */
		/* 820FD69Ch case    4:*/		regs.R28 = regs.R29;
		/* 820FD69Ch case    4:*/		return 0x820FD6A0;
		  /* 820FD6A0h */ case    5:  		/* lwz R11, <#[R31 + 16]> */
		/* 820FD6A0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820FD6A0h case    5:*/		return 0x820FD6A4;
		  /* 820FD6A4h */ case    6:  		/* mr R3, R30 */
		/* 820FD6A4h case    6:*/		regs.R3 = regs.R30;
		/* 820FD6A4h case    6:*/		return 0x820FD6A8;
		  /* 820FD6A8h */ case    7:  		/* lwzx R4, <#[R11 + R28]> */
		/* 820FD6A8h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 820FD6A8h case    7:*/		return 0x820FD6AC;
		  /* 820FD6ACh */ case    8:  		/* bl -844 */
		/* 820FD6ACh case    8:*/		regs.LR = 0x820FD6B0; return 0x820FD360;
		/* 820FD6ACh case    8:*/		return 0x820FD6B0;
		  /* 820FD6B0h */ case    9:  		/* cmpwi CR6, R3, -1 */
		/* 820FD6B0h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820FD6B0h case    9:*/		return 0x820FD6B4;
		  /* 820FD6B4h */ case   10:  		/* bc 12, CR6_EQ, -52 */
		/* 820FD6B4h case   10:*/		if ( regs.CR[6].eq ) { return 0x820FD680;  }
		/* 820FD6B4h case   10:*/		return 0x820FD6B8;
	}
	return 0x820FD6B8;
} // Block from 820FD68Ch-820FD6B8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FD6B8h
// Function '?Initialize@CArgument@D3DXShader@@QAAJIIIN@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD6B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD6B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD6B8);
		  /* 820FD6B8h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 820FD6B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820FD6B8h case    0:*/		return 0x820FD6BC;
		  /* 820FD6BCh */ case    1:  		/* addi R27, R27, 1 */
		/* 820FD6BCh case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 820FD6BCh case    1:*/		return 0x820FD6C0;
		  /* 820FD6C0h */ case    2:  		/* addi R28, R28, 4 */
		/* 820FD6C0h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820FD6C0h case    2:*/		return 0x820FD6C4;
		  /* 820FD6C4h */ case    3:  		/* cmplw CR6, R27, R11 */
		/* 820FD6C4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 820FD6C4h case    3:*/		return 0x820FD6C8;
		  /* 820FD6C8h */ case    4:  		/* bc 12, CR6_LT, -40 */
		/* 820FD6C8h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FD6A0;  }
		/* 820FD6C8h case    4:*/		return 0x820FD6CC;
	}
	return 0x820FD6CC;
} // Block from 820FD6B8h-820FD6CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FD6CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD6CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD6CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD6CC);
		  /* 820FD6CCh */ case    0:  		/* stw R29, <#[R30 + 8]> */
		/* 820FD6CCh case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000008) );
		/* 820FD6CCh case    0:*/		return 0x820FD6D0;
		  /* 820FD6D0h */ case    1:  		/* lwz R11, <#[R31 + 8]> */
		/* 820FD6D0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820FD6D0h case    1:*/		return 0x820FD6D4;
		  /* 820FD6D4h */ case    2:  		/* cmplw CR6, R11, R26 */
		/* 820FD6D4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 820FD6D4h case    2:*/		return 0x820FD6D8;
		  /* 820FD6D8h */ case    3:  		/* stw R11, <#[R30 + 32]> */
		/* 820FD6D8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000020) );
		/* 820FD6D8h case    3:*/		return 0x820FD6DC;
		  /* 820FD6DCh */ case    4:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820FD6DCh case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820FD6DCh case    4:*/		return 0x820FD6E0;
		  /* 820FD6E0h */ case    5:  		/* bc 4, CR6_GT, 8 */
		/* 820FD6E0h case    5:*/		if ( !regs.CR[6].gt ) { return 0x820FD6E8;  }
		/* 820FD6E0h case    5:*/		return 0x820FD6E4;
		  /* 820FD6E4h */ case    6:  		/* mr R3, R25 */
		/* 820FD6E4h case    6:*/		regs.R3 = regs.R25;
		/* 820FD6E4h case    6:*/		return 0x820FD6E8;
	}
	return 0x820FD6E8;
} // Block from 820FD6CCh-820FD6E8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820FD6E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD6E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD6E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD6E8);
		  /* 820FD6E8h */ case    0:  		/* bl -434080 */
		/* 820FD6E8h case    0:*/		regs.LR = 0x820FD6EC; return 0x82093748;
		/* 820FD6E8h case    0:*/		return 0x820FD6EC;
		  /* 820FD6ECh */ case    1:  		/* stw R3, <#[R30 + 20]> */
		/* 820FD6ECh case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000014) );
		/* 820FD6ECh case    1:*/		return 0x820FD6F0;
		  /* 820FD6F0h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820FD6F0h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820FD6F0h case    2:*/		return 0x820FD6F4;
		  /* 820FD6F4h */ case    3:  		/* bc 12, CR0_EQ, -116 */
		/* 820FD6F4h case    3:*/		if ( regs.CR[0].eq ) { return 0x820FD680;  }
		/* 820FD6F4h case    3:*/		return 0x820FD6F8;
		  /* 820FD6F8h */ case    4:  		/* lwz R11, <#[R31 + 8]> */
		/* 820FD6F8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820FD6F8h case    4:*/		return 0x820FD6FC;
		  /* 820FD6FCh */ case    5:  		/* mr R27, R29 */
		/* 820FD6FCh case    5:*/		regs.R27 = regs.R29;
		/* 820FD6FCh case    5:*/		return 0x820FD700;
		  /* 820FD700h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820FD700h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FD700h case    6:*/		return 0x820FD704;
		  /* 820FD704h */ case    7:  		/* bc 4, CR6_GT, 52 */
		/* 820FD704h case    7:*/		if ( !regs.CR[6].gt ) { return 0x820FD738;  }
		/* 820FD704h case    7:*/		return 0x820FD708;
		  /* 820FD708h */ case    8:  		/* mr R28, R29 */
		/* 820FD708h case    8:*/		regs.R28 = regs.R29;
		/* 820FD708h case    8:*/		return 0x820FD70C;
		  /* 820FD70Ch */ case    9:  		/* lwz R11, <#[R31 + 20]> */
		/* 820FD70Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820FD70Ch case    9:*/		return 0x820FD710;
		  /* 820FD710h */ case   10:  		/* mr R3, R30 */
		/* 820FD710h case   10:*/		regs.R3 = regs.R30;
		/* 820FD710h case   10:*/		return 0x820FD714;
		  /* 820FD714h */ case   11:  		/* lwzx R4, <#[R11 + R28]> */
		/* 820FD714h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 820FD714h case   11:*/		return 0x820FD718;
		  /* 820FD718h */ case   12:  		/* bl -816 */
		/* 820FD718h case   12:*/		regs.LR = 0x820FD71C; return 0x820FD3E8;
		/* 820FD718h case   12:*/		return 0x820FD71C;
		  /* 820FD71Ch */ case   13:  		/* cmpwi CR6, R3, -1 */
		/* 820FD71Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820FD71Ch case   13:*/		return 0x820FD720;
		  /* 820FD720h */ case   14:  		/* bc 12, CR6_EQ, -160 */
		/* 820FD720h case   14:*/		if ( regs.CR[6].eq ) { return 0x820FD680;  }
		/* 820FD720h case   14:*/		return 0x820FD724;
		  /* 820FD724h */ case   15:  		/* lwz R11, <#[R31 + 8]> */
		/* 820FD724h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820FD724h case   15:*/		return 0x820FD728;
		  /* 820FD728h */ case   16:  		/* addi R27, R27, 1 */
		/* 820FD728h case   16:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 820FD728h case   16:*/		return 0x820FD72C;
		  /* 820FD72Ch */ case   17:  		/* addi R28, R28, 4 */
		/* 820FD72Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820FD72Ch case   17:*/		return 0x820FD730;
		  /* 820FD730h */ case   18:  		/* cmplw CR6, R27, R11 */
		/* 820FD730h case   18:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 820FD730h case   18:*/		return 0x820FD734;
		  /* 820FD734h */ case   19:  		/* bc 12, CR6_LT, -40 */
		/* 820FD734h case   19:*/		if ( regs.CR[6].lt ) { return 0x820FD70C;  }
		/* 820FD734h case   19:*/		return 0x820FD738;
	}
	return 0x820FD738;
} // Block from 820FD6E8h-820FD738h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820FD738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD738);
		  /* 820FD738h */ case    0:  		/* stw R29, <#[R30 + 12]> */
		/* 820FD738h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x0000000C) );
		/* 820FD738h case    0:*/		return 0x820FD73C;
		  /* 820FD73Ch */ case    1:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FD73Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FD73Ch case    1:*/		return 0x820FD740;
	}
	return 0x820FD740;
} // Block from 820FD738h-820FD740h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FD740h
// Function '?Initialize@CArgument@D3DXShader@@QAAJPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD740);
		  /* 820FD740h */ case    0:  		/* cmplw CR6, R11, R26 */
		/* 820FD740h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 820FD740h case    0:*/		return 0x820FD744;
		  /* 820FD744h */ case    1:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820FD744h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820FD744h case    1:*/		return 0x820FD748;
		  /* 820FD748h */ case    2:  		/* stw R11, <#[R30 + 36]> */
		/* 820FD748h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 820FD748h case    2:*/		return 0x820FD74C;
		  /* 820FD74Ch */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 820FD74Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x820FD754;  }
		/* 820FD74Ch case    3:*/		return 0x820FD750;
		  /* 820FD750h */ case    4:  		/* mr R3, R25 */
		/* 820FD750h case    4:*/		regs.R3 = regs.R25;
		/* 820FD750h case    4:*/		return 0x820FD754;
	}
	return 0x820FD754;
} // Block from 820FD740h-820FD754h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FD754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD754);
		  /* 820FD754h */ case    0:  		/* bl -434188 */
		/* 820FD754h case    0:*/		regs.LR = 0x820FD758; return 0x82093748;
		/* 820FD754h case    0:*/		return 0x820FD758;
		  /* 820FD758h */ case    1:  		/* stw R3, <#[R30 + 24]> */
		/* 820FD758h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000018) );
		/* 820FD758h case    1:*/		return 0x820FD75C;
		  /* 820FD75Ch */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820FD75Ch case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820FD75Ch case    2:*/		return 0x820FD760;
		  /* 820FD760h */ case    3:  		/* bc 12, CR0_EQ, -224 */
		/* 820FD760h case    3:*/		if ( regs.CR[0].eq ) { return 0x820FD680;  }
		/* 820FD760h case    3:*/		return 0x820FD764;
		  /* 820FD764h */ case    4:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FD764h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FD764h case    4:*/		return 0x820FD768;
		  /* 820FD768h */ case    5:  		/* mr R28, R29 */
		/* 820FD768h case    5:*/		regs.R28 = regs.R29;
		/* 820FD768h case    5:*/		return 0x820FD76C;
		  /* 820FD76Ch */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820FD76Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FD76Ch case    6:*/		return 0x820FD770;
		  /* 820FD770h */ case    7:  		/* bc 4, CR6_GT, 48 */
		/* 820FD770h case    7:*/		if ( !regs.CR[6].gt ) { return 0x820FD7A0;  }
		/* 820FD770h case    7:*/		return 0x820FD774;
		  /* 820FD774h */ case    8:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FD774h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FD774h case    8:*/		return 0x820FD778;
		  /* 820FD778h */ case    9:  		/* mr R3, R30 */
		/* 820FD778h case    9:*/		regs.R3 = regs.R30;
		/* 820FD778h case    9:*/		return 0x820FD77C;
		  /* 820FD77Ch */ case   10:  		/* lwzx R4, <#[R11 + R29]> */
		/* 820FD77Ch case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 820FD77Ch case   10:*/		return 0x820FD780;
		  /* 820FD780h */ case   11:  		/* bl -792 */
		/* 820FD780h case   11:*/		regs.LR = 0x820FD784; return 0x820FD468;
		/* 820FD780h case   11:*/		return 0x820FD784;
		  /* 820FD784h */ case   12:  		/* cmpwi CR6, R3, -1 */
		/* 820FD784h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820FD784h case   12:*/		return 0x820FD788;
		  /* 820FD788h */ case   13:  		/* bc 12, CR6_EQ, -264 */
		/* 820FD788h case   13:*/		if ( regs.CR[6].eq ) { return 0x820FD680;  }
		/* 820FD788h case   13:*/		return 0x820FD78C;
		  /* 820FD78Ch */ case   14:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FD78Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FD78Ch case   14:*/		return 0x820FD790;
		  /* 820FD790h */ case   15:  		/* addi R28, R28, 1 */
		/* 820FD790h case   15:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820FD790h case   15:*/		return 0x820FD794;
		  /* 820FD794h */ case   16:  		/* addi R29, R29, 4 */
		/* 820FD794h case   16:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820FD794h case   16:*/		return 0x820FD798;
		  /* 820FD798h */ case   17:  		/* cmplw CR6, R28, R11 */
		/* 820FD798h case   17:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820FD798h case   17:*/		return 0x820FD79C;
		  /* 820FD79Ch */ case   18:  		/* bc 12, CR6_LT, -40 */
		/* 820FD79Ch case   18:*/		if ( regs.CR[6].lt ) { return 0x820FD774;  }
		/* 820FD79Ch case   18:*/		return 0x820FD7A0;
	}
	return 0x820FD7A0;
} // Block from 820FD754h-820FD7A0h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820FD7A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD7A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD7A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD7A0);
		  /* 820FD7A0h */ case    0:  		/* li R3, 0 */
		/* 820FD7A0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FD7A0h case    0:*/		return 0x820FD7A4;
	}
	return 0x820FD7A4;
} // Block from 820FD7A0h-820FD7A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FD7A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD7A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD7A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD7A4);
		  /* 820FD7A4h */ case    0:  		/* addi R1, R1, 144 */
		/* 820FD7A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820FD7A4h case    0:*/		return 0x820FD7A8;
		  /* 820FD7A8h */ case    1:  		/* b -443660 */
		/* 820FD7A8h case    1:*/		return 0x8209129C;
		/* 820FD7A8h case    1:*/		return 0x820FD7AC;
		  /* 820FD7ACh */ case    2:  		/* nop */
		/* 820FD7ACh case    2:*/		cpu::op::nop();
		/* 820FD7ACh case    2:*/		return 0x820FD7B0;
	}
	return 0x820FD7B0;
} // Block from 820FD7A4h-820FD7B0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FD7B0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD7B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD7B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD7B0);
		  /* 820FD7B0h */ case    0:  		/* mfspr R12, LR */
		/* 820FD7B0h case    0:*/		regs.R12 = regs.LR;
		/* 820FD7B0h case    0:*/		return 0x820FD7B4;
		  /* 820FD7B4h */ case    1:  		/* bl -443736 */
		/* 820FD7B4h case    1:*/		regs.LR = 0x820FD7B8; return 0x8209125C;
		/* 820FD7B4h case    1:*/		return 0x820FD7B8;
		  /* 820FD7B8h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820FD7B8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820FD7B8h case    2:*/		return 0x820FD7BC;
		  /* 820FD7BCh */ case    3:  		/* lwz R9, <#[R4 + 104]> */
		/* 820FD7BCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000068) );
		/* 820FD7BCh case    3:*/		return 0x820FD7C0;
		  /* 820FD7C0h */ case    4:  		/* mr R30, R5 */
		/* 820FD7C0h case    4:*/		regs.R30 = regs.R5;
		/* 820FD7C0h case    4:*/		return 0x820FD7C4;
		  /* 820FD7C4h */ case    5:  		/* mr R29, R6 */
		/* 820FD7C4h case    5:*/		regs.R29 = regs.R6;
		/* 820FD7C4h case    5:*/		return 0x820FD7C8;
		  /* 820FD7C8h */ case    6:  		/* li R10, 64 */
		/* 820FD7C8h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x40);
		/* 820FD7C8h case    6:*/		return 0x820FD7CC;
		  /* 820FD7CCh */ case    7:  		/* addi R11, R1, 80 */
		/* 820FD7CCh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820FD7CCh case    7:*/		return 0x820FD7D0;
		  /* 820FD7D0h */ case    8:  		/* lwz R9, <#[R9 + 24]> */
		/* 820FD7D0h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000018) );
		/* 820FD7D0h case    8:*/		return 0x820FD7D4;
		  /* 820FD7D4h */ case    9:  		/* lbz R8, <#[R9]> */
		/* 820FD7D4h case    9:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 820FD7D4h case    9:*/		return 0x820FD7D8;
		  /* 820FD7D8h */ case   10:  		/* cmplwi CR0, R8, 0 */
		/* 820FD7D8h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R8,0x00000000);
		/* 820FD7D8h case   10:*/		return 0x820FD7DC;
		  /* 820FD7DCh */ case   11:  		/* bc 12, CR0_EQ, 24 */
		/* 820FD7DCh case   11:*/		if ( regs.CR[0].eq ) { return 0x820FD7F4;  }
		/* 820FD7DCh case   11:*/		return 0x820FD7E0;
		  /* 820FD7E0h */ case   12:  		/* stb R8, <#[R11]> */
		/* 820FD7E0h case   12:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820FD7E0h case   12:*/		return 0x820FD7E4;
		  /* 820FD7E4h */ case   13:  		/* addic. R10, R10, -1 */
		/* 820FD7E4h case   13:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820FD7E4h case   13:*/		return 0x820FD7E8;
		  /* 820FD7E8h */ case   14:  		/* addi R11, R11, 1 */
		/* 820FD7E8h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820FD7E8h case   14:*/		return 0x820FD7EC;
		  /* 820FD7ECh */ case   15:  		/* addi R9, R9, 1 */
		/* 820FD7ECh case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820FD7ECh case   15:*/		return 0x820FD7F0;
		  /* 820FD7F0h */ case   16:  		/* bc 4, CR0_EQ, -28 */
		/* 820FD7F0h case   16:*/		if ( !regs.CR[0].eq ) { return 0x820FD7D4;  }
		/* 820FD7F0h case   16:*/		return 0x820FD7F4;
	}
	return 0x820FD7F4;
} // Block from 820FD7B0h-820FD7F4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820FD7F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD7F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD7F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD7F4);
		  /* 820FD7F4h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 820FD7F4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820FD7F4h case    0:*/		return 0x820FD7F8;
		  /* 820FD7F8h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 820FD7F8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820FD800;  }
		/* 820FD7F8h case    1:*/		return 0x820FD7FC;
		  /* 820FD7FCh */ case    2:  		/* addi R11, R11, -1 */
		/* 820FD7FCh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820FD7FCh case    2:*/		return 0x820FD800;
	}
	return 0x820FD800;
} // Block from 820FD7F4h-820FD800h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FD800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD800);
		  /* 820FD800h */ case    0:  		/* lwz R9, <#[R4 + 4]> */
		/* 820FD800h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000004) );
		/* 820FD800h case    0:*/		return 0x820FD804;
		  /* 820FD804h */ case    1:  		/* li R31, 0 */
		/* 820FD804h case    1:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820FD804h case    1:*/		return 0x820FD808;
		  /* 820FD808h */ case    2:  		/* lwz R8, <#[R3 + 16]> */
		/* 820FD808h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000010) );
		/* 820FD808h case    2:*/		return 0x820FD80C;
		  /* 820FD80Ch */ case    3:  		/* lis R10, -32254 */
		/* 820FD80Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820FD80Ch case    3:*/		return 0x820FD810;
		  /* 820FD810h */ case    4:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820FD810h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820FD810h case    4:*/		return 0x820FD814;
		  /* 820FD814h */ case    5:  		/* stb R31, <#[R11]> */
		/* 820FD814h case    5:*/		cpu::mem::store8( regs, regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 820FD814h case    5:*/		return 0x820FD818;
		  /* 820FD818h */ case    6:  		/* addi R6, R10, -14400 */
		/* 820FD818h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFC7C0);
		/* 820FD818h case    6:*/		return 0x820FD81C;
		  /* 820FD81Ch */ case    7:  		/* lwzx R11, <#[R9 + R8]> */
		/* 820FD81Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820FD81Ch case    7:*/		return 0x820FD820;
		  /* 820FD820h */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 820FD820h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820FD820h case    8:*/		return 0x820FD824;
		  /* 820FD824h */ case    9:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 820FD824h case    9:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 820FD824h case    9:*/		return 0x820FD828;
		  /* 820FD828h */ case   10:  		/* bc 12, CR0_EQ, 12 */
		/* 820FD828h case   10:*/		if ( regs.CR[0].eq ) { return 0x820FD834;  }
		/* 820FD828h case   10:*/		return 0x820FD82C;
		  /* 820FD82Ch */ case   11:  		/* lis R11, -32254 */
		/* 820FD82Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820FD82Ch case   11:*/		return 0x820FD830;
		  /* 820FD830h */ case   12:  		/* addi R6, R11, -14408 */
		/* 820FD830h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFC7B8);
		/* 820FD830h case   12:*/		return 0x820FD834;
	}
	return 0x820FD834;
} // Block from 820FD800h-820FD834h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FD834h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD834( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD834) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD834);
		  /* 820FD834h */ case    0:  		/* lis R11, -32254 */
		/* 820FD834h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820FD834h case    0:*/		return 0x820FD838;
	}
	return 0x820FD838;
} // Block from 820FD834h-820FD838h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FD838h
// Function '?Instance@CArgument@D3DXShader@@QAAJPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD838);
		  /* 820FD838h */ case    0:  		/* addi R7, R1, 80 */
		/* 820FD838h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 820FD838h case    0:*/		return 0x820FD83C;
		  /* 820FD83Ch */ case    1:  		/* addi R5, R11, -14392 */
		/* 820FD83Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFC7C8);
		/* 820FD83Ch case    1:*/		return 0x820FD840;
		  /* 820FD840h */ case    2:  		/* mr R4, R29 */
		/* 820FD840h case    2:*/		regs.R4 = regs.R29;
		/* 820FD840h case    2:*/		return 0x820FD844;
		  /* 820FD844h */ case    3:  		/* mr R3, R30 */
		/* 820FD844h case    3:*/		regs.R3 = regs.R30;
		/* 820FD844h case    3:*/		return 0x820FD848;
		  /* 820FD848h */ case    4:  		/* bl -373256 */
		/* 820FD848h case    4:*/		regs.LR = 0x820FD84C; return 0x820A2640;
		/* 820FD848h case    4:*/		return 0x820FD84C;
		  /* 820FD84Ch */ case    5:  		/* add R11, R30, R29 */
		/* 820FD84Ch case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R29);
		/* 820FD84Ch case    5:*/		return 0x820FD850;
		  /* 820FD850h */ case    6:  		/* li R3, 0 */
		/* 820FD850h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FD850h case    6:*/		return 0x820FD854;
		  /* 820FD854h */ case    7:  		/* stb R31, <#[R11 - 1]> */
		/* 820FD854h case    7:*/		cpu::mem::store8( regs, regs.R31, (uint32)(regs.R11 + 0xFFFFFFFF) );
		/* 820FD854h case    7:*/		return 0x820FD858;
		  /* 820FD858h */ case    8:  		/* addi R1, R1, 176 */
		/* 820FD858h case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820FD858h case    8:*/		return 0x820FD85C;
		  /* 820FD85Ch */ case    9:  		/* b -443824 */
		/* 820FD85Ch case    9:*/		return 0x820912AC;
		/* 820FD85Ch case    9:*/		return 0x820FD860;
	}
	return 0x820FD860;
} // Block from 820FD838h-820FD860h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FD860h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD860);
		  /* 820FD860h */ case    0:  		/* mfspr R12, LR */
		/* 820FD860h case    0:*/		regs.R12 = regs.LR;
		/* 820FD860h case    0:*/		return 0x820FD864;
		  /* 820FD864h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820FD864h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FD864h case    1:*/		return 0x820FD868;
		  /* 820FD868h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820FD868h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820FD868h case    2:*/		return 0x820FD86C;
		  /* 820FD86Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820FD86Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FD86Ch case    3:*/		return 0x820FD870;
		  /* 820FD870h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820FD870h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820FD870h case    4:*/		return 0x820FD874;
		  /* 820FD874h */ case    5:  		/* mr R31, R3 */
		/* 820FD874h case    5:*/		regs.R31 = regs.R3;
		/* 820FD874h case    5:*/		return 0x820FD878;
		  /* 820FD878h */ case    6:  		/* mr R30, R4 */
		/* 820FD878h case    6:*/		regs.R30 = regs.R4;
		/* 820FD878h case    6:*/		return 0x820FD87C;
		  /* 820FD87Ch */ case    7:  		/* bl -916 */
		/* 820FD87Ch case    7:*/		regs.LR = 0x820FD880; return 0x820FD4E8;
		/* 820FD87Ch case    7:*/		return 0x820FD880;
		  /* 820FD880h */ case    8:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 820FD880h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 820FD880h case    8:*/		return 0x820FD884;
		  /* 820FD884h */ case    9:  		/* bc 12, CR0_EQ, 16 */
		/* 820FD884h case    9:*/		if ( regs.CR[0].eq ) { return 0x820FD894;  }
		/* 820FD884h case    9:*/		return 0x820FD888;
	}
	return 0x820FD888;
} // Block from 820FD860h-820FD888h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FD888h
// Function '?SetAlloc@CArgument@D3DXShader@@SAXPAVCAlloc@D3DXCore@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD888);
		  /* 820FD888h */ case    0:  		/* lis R4, 9345 */
		/* 820FD888h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820FD888h case    0:*/		return 0x820FD88C;
		  /* 820FD88Ch */ case    1:  		/* mr R3, R31 */
		/* 820FD88Ch case    1:*/		regs.R3 = regs.R31;
		/* 820FD88Ch case    1:*/		return 0x820FD890;
		  /* 820FD890h */ case    2:  		/* bl -480600 */
		/* 820FD890h case    2:*/		regs.LR = 0x820FD894; return 0x82088338;
		/* 820FD890h case    2:*/		return 0x820FD894;
	}
	return 0x820FD894;
} // Block from 820FD888h-820FD894h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FD894h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD894( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD894) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD894);
		  /* 820FD894h */ case    0:  		/* mr R3, R31 */
		/* 820FD894h case    0:*/		regs.R3 = regs.R31;
		/* 820FD894h case    0:*/		return 0x820FD898;
		  /* 820FD898h */ case    1:  		/* addi R1, R1, 112 */
		/* 820FD898h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820FD898h case    1:*/		return 0x820FD89C;
		  /* 820FD89Ch */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820FD89Ch case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FD89Ch case    2:*/		return 0x820FD8A0;
		  /* 820FD8A0h */ case    3:  		/* mtspr LR, R12 */
		/* 820FD8A0h case    3:*/		regs.LR = regs.R12;
		/* 820FD8A0h case    3:*/		return 0x820FD8A4;
		  /* 820FD8A4h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 820FD8A4h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820FD8A4h case    4:*/		return 0x820FD8A8;
		  /* 820FD8A8h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 820FD8A8h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FD8A8h case    5:*/		return 0x820FD8AC;
		  /* 820FD8ACh */ case    6:  		/* bclr 20, CR0_LT */
		/* 820FD8ACh case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FD8ACh case    6:*/		return 0x820FD8B0;
	}
	return 0x820FD8B0;
} // Block from 820FD894h-820FD8B0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820FD8B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD8B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD8B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD8B0);
		  /* 820FD8B0h */ case    0:  		/* lwz R11, <#[R5 + 20]> */
		/* 820FD8B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000014) );
		/* 820FD8B0h case    0:*/		return 0x820FD8B4;
		  /* 820FD8B4h */ case    1:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820FD8B4h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820FD8B4h case    1:*/		return 0x820FD8B8;
		  /* 820FD8B8h */ case    2:  		/* rlwinm R8, R4, 2, 0, 29 */
		/* 820FD8B8h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R4);
		/* 820FD8B8h case    2:*/		return 0x820FD8BC;
		  /* 820FD8BCh */ case    3:  		/* lwzx R9, <#[R10 + R11]> */
		/* 820FD8BCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820FD8BCh case    3:*/		return 0x820FD8C0;
	}
	return 0x820FD8C0;
} // Block from 820FD8B0h-820FD8C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FD8C0h
// Function '??2CArgument@D3DXShader@@SAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD8C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD8C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD8C0);
		  /* 820FD8C0h */ case    0:  		/* lwzx R8, <#[R8 + R11]> */
		/* 820FD8C0h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 820FD8C0h case    0:*/		return 0x820FD8C4;
		  /* 820FD8C4h */ case    1:  		/* lwz R11, <#[R9 + 4]> */
		/* 820FD8C4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 820FD8C4h case    1:*/		return 0x820FD8C8;
		  /* 820FD8C8h */ case    2:  		/* lwz R10, <#[R8 + 4]> */
		/* 820FD8C8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000004) );
		/* 820FD8C8h case    2:*/		return 0x820FD8CC;
		  /* 820FD8CCh */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820FD8CCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FD8CCh case    3:*/		return 0x820FD8D0;
		  /* 820FD8D0h */ case    4:  		/* bc 4, CR6_LT, 12 */
		/* 820FD8D0h case    4:*/		if ( !regs.CR[6].lt ) { return 0x820FD8DC;  }
		/* 820FD8D0h case    4:*/		return 0x820FD8D4;
		  /* 820FD8D4h */ case    5:  		/* li R3, -1 */
		/* 820FD8D4h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820FD8D4h case    5:*/		return 0x820FD8D8;
		  /* 820FD8D8h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820FD8D8h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FD8D8h case    6:*/		return 0x820FD8DC;
	}
	return 0x820FD8DC;
} // Block from 820FD8C0h-820FD8DCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820FD8DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD8DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD8DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD8DC);
		  /* 820FD8DCh */ case    0:  		/* bc 4, CR6_GT, 12 */
		/* 820FD8DCh case    0:*/		if ( !regs.CR[6].gt ) { return 0x820FD8E8;  }
		/* 820FD8DCh case    0:*/		return 0x820FD8E0;
		  /* 820FD8E0h */ case    1:  		/* li R3, 1 */
		/* 820FD8E0h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FD8E0h case    1:*/		return 0x820FD8E4;
		  /* 820FD8E4h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820FD8E4h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FD8E4h case    2:*/		return 0x820FD8E8;
	}
	return 0x820FD8E8;
} // Block from 820FD8DCh-820FD8E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FD8E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD8E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD8E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD8E8);
		  /* 820FD8E8h */ case    0:  		/* lwz R11, <#[R9 + 60]> */
		/* 820FD8E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000003C) );
		/* 820FD8E8h case    0:*/		return 0x820FD8EC;
		  /* 820FD8ECh */ case    1:  		/* rlwinm. R11, R11, 0, 12, 12 */
		/* 820FD8ECh case    1:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R11,regs.R11);
		/* 820FD8ECh case    1:*/		return 0x820FD8F0;
		  /* 820FD8F0h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 820FD8F0h case    2:*/		if ( regs.CR[0].eq ) { return 0x820FD900;  }
		/* 820FD8F0h case    2:*/		return 0x820FD8F4;
		  /* 820FD8F4h */ case    3:  		/* lfd FR0, <#[R9 + 32]> */
		/* 820FD8F4h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000020) );
		/* 820FD8F4h case    3:*/		return 0x820FD8F8;
		  /* 820FD8F8h */ case    4:  		/* fneg FR13, FR0 */
		/* 820FD8F8h case    4:*/		cpu::op::fneg<0>(regs,&regs.FR13,regs.FR0);
		/* 820FD8F8h case    4:*/		return 0x820FD8FC;
		  /* 820FD8FCh */ case    5:  		/* b 8 */
		/* 820FD8FCh case    5:*/		return 0x820FD904;
		/* 820FD8FCh case    5:*/		return 0x820FD900;
	}
	return 0x820FD900;
} // Block from 820FD8E8h-820FD900h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FD900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD900);
		  /* 820FD900h */ case    0:  		/* lfd FR13, <#[R9 + 32]> */
		/* 820FD900h case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R9 + 0x00000020) );
		/* 820FD900h case    0:*/		return 0x820FD904;
	}
	return 0x820FD904;
} // Block from 820FD900h-820FD904h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FD904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD904);
		  /* 820FD904h */ case    0:  		/* lwz R11, <#[R8 + 60]> */
		/* 820FD904h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x0000003C) );
		/* 820FD904h case    0:*/		return 0x820FD908;
		  /* 820FD908h */ case    1:  		/* lfd FR0, <#[R8 + 32]> */
		/* 820FD908h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R8 + 0x00000020) );
		/* 820FD908h case    1:*/		return 0x820FD90C;
		  /* 820FD90Ch */ case    2:  		/* rlwinm. R11, R11, 0, 12, 12 */
		/* 820FD90Ch case    2:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R11,regs.R11);
		/* 820FD90Ch case    2:*/		return 0x820FD910;
		  /* 820FD910h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 820FD910h case    3:*/		if ( regs.CR[0].eq ) { return 0x820FD918;  }
		/* 820FD910h case    3:*/		return 0x820FD914;
		  /* 820FD914h */ case    4:  		/* fneg FR0, FR0 */
		/* 820FD914h case    4:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR0);
		/* 820FD914h case    4:*/		return 0x820FD918;
	}
	return 0x820FD918;
} // Block from 820FD904h-820FD918h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FD918h
// Function '??3CArgument@D3DXShader@@SAXPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD918);
		  /* 820FD918h */ case    0:  		/* fcmpu CR6, FR13, FR0 */
		/* 820FD918h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820FD918h case    0:*/		return 0x820FD91C;
		  /* 820FD91Ch */ case    1:  		/* bc 12, CR6_LT, -72 */
		/* 820FD91Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x820FD8D4;  }
		/* 820FD91Ch case    1:*/		return 0x820FD920;
		  /* 820FD920h */ case    2:  		/* fcmpu CR6, FR13, FR0 */
		/* 820FD920h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820FD920h case    2:*/		return 0x820FD924;
		  /* 820FD924h */ case    3:  		/* li R3, 1 */
		/* 820FD924h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FD924h case    3:*/		return 0x820FD928;
		  /* 820FD928h */ case    4:  		/* bclr 12, CR6_GT */
		/* 820FD928h case    4:*/		if ( regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 820FD928h case    4:*/		return 0x820FD92C;
	}
	return 0x820FD92C;
} // Block from 820FD918h-820FD92Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FD92Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD92C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD92C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD92C);
		  /* 820FD92Ch */ case    0:  		/* li R3, 0 */
		/* 820FD92Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FD92Ch case    0:*/		return 0x820FD930;
		  /* 820FD930h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820FD930h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FD930h case    1:*/		return 0x820FD934;
	}
	return 0x820FD934;
} // Block from 820FD92Ch-820FD934h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FD934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD934);
		  /* 820FD934h */ case    0:  		/* nop */
		/* 820FD934h case    0:*/		cpu::op::nop();
		/* 820FD934h case    0:*/		return 0x820FD938;
		  /* 820FD938h */ case    1:  		/* lwz R10, <#[R5 + 20]> */
		/* 820FD938h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000014) );
		/* 820FD938h case    1:*/		return 0x820FD93C;
		  /* 820FD93Ch */ case    2:  		/* rlwinm R11, R3, 2, 0, 29 */
		/* 820FD93Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R3);
		/* 820FD93Ch case    2:*/		return 0x820FD940;
		  /* 820FD940h */ case    3:  		/* rlwinm R9, R4, 2, 0, 29 */
		/* 820FD940h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R4);
		/* 820FD940h case    3:*/		return 0x820FD944;
		  /* 820FD944h */ case    4:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820FD944h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FD944h case    4:*/		return 0x820FD948;
		  /* 820FD948h */ case    5:  		/* lwzx R10, <#[R9 + R10]> */
		/* 820FD948h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FD948h case    5:*/		return 0x820FD94C;
		  /* 820FD94Ch */ case    6:  		/* lwz R9, <#[R11 + 56]> */
		/* 820FD94Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000038) );
		/* 820FD94Ch case    6:*/		return 0x820FD950;
		  /* 820FD950h */ case    7:  		/* lwz R8, <#[R10 + 56]> */
		/* 820FD950h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000038) );
		/* 820FD950h case    7:*/		return 0x820FD954;
		  /* 820FD954h */ case    8:  		/* cmplw CR6, R9, R8 */
		/* 820FD954h case    8:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820FD954h case    8:*/		return 0x820FD958;
	}
	return 0x820FD958;
} // Block from 820FD934h-820FD958h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820FD958h
// Function '??0CBaseProgram@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD958);
		  /* 820FD958h */ case    0:  		/* bc 4, CR6_LT, 12 */
		/* 820FD958h case    0:*/		if ( !regs.CR[6].lt ) { return 0x820FD964;  }
		/* 820FD958h case    0:*/		return 0x820FD95C;
		  /* 820FD95Ch */ case    1:  		/* li R3, -1 */
		/* 820FD95Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820FD95Ch case    1:*/		return 0x820FD960;
		  /* 820FD960h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820FD960h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FD960h case    2:*/		return 0x820FD964;
	}
	return 0x820FD964;
} // Block from 820FD958h-820FD964h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FD964h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD964( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD964) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD964);
		  /* 820FD964h */ case    0:  		/* bc 4, CR6_GT, 12 */
		/* 820FD964h case    0:*/		if ( !regs.CR[6].gt ) { return 0x820FD970;  }
		/* 820FD964h case    0:*/		return 0x820FD968;
		  /* 820FD968h */ case    1:  		/* li R3, 1 */
		/* 820FD968h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FD968h case    1:*/		return 0x820FD96C;
		  /* 820FD96Ch */ case    2:  		/* bclr 20, CR0_LT */
		/* 820FD96Ch case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FD96Ch case    2:*/		return 0x820FD970;
	}
	return 0x820FD970;
} // Block from 820FD964h-820FD970h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FD970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD970);
		  /* 820FD970h */ case    0:  		/* lwz R9, <#[R11 + 60]> */
		/* 820FD970h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000003C) );
		/* 820FD970h case    0:*/		return 0x820FD974;
		  /* 820FD974h */ case    1:  		/* lwz R8, <#[R10 + 60]> */
		/* 820FD974h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x0000003C) );
		/* 820FD974h case    1:*/		return 0x820FD978;
		  /* 820FD978h */ case    2:  		/* cmplw CR6, R9, R8 */
		/* 820FD978h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820FD978h case    2:*/		return 0x820FD97C;
		  /* 820FD97Ch */ case    3:  		/* bc 12, CR6_LT, -32 */
		/* 820FD97Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x820FD95C;  }
		/* 820FD97Ch case    3:*/		return 0x820FD980;
		  /* 820FD980h */ case    4:  		/* bc 12, CR6_GT, -24 */
		/* 820FD980h case    4:*/		if ( regs.CR[6].gt ) { return 0x820FD968;  }
		/* 820FD980h case    4:*/		return 0x820FD984;
		  /* 820FD984h */ case    5:  		/* lwz R9, <#[R11 + 4]> */
		/* 820FD984h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820FD984h case    5:*/		return 0x820FD988;
		  /* 820FD988h */ case    6:  		/* lwz R8, <#[R10 + 4]> */
		/* 820FD988h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 820FD988h case    6:*/		return 0x820FD98C;
		  /* 820FD98Ch */ case    7:  		/* cmplw CR6, R9, R8 */
		/* 820FD98Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820FD98Ch case    7:*/		return 0x820FD990;
	}
	return 0x820FD990;
} // Block from 820FD970h-820FD990h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820FD990h
// Function '?GetArgumentType@CBaseProgram@D3DXShader@@IAAPBDPAVCArgument@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD990);
		  /* 820FD990h */ case    0:  		/* bc 12, CR6_LT, -52 */
		/* 820FD990h case    0:*/		if ( regs.CR[6].lt ) { return 0x820FD95C;  }
		/* 820FD990h case    0:*/		return 0x820FD994;
		  /* 820FD994h */ case    1:  		/* bc 12, CR6_GT, -44 */
		/* 820FD994h case    1:*/		if ( regs.CR[6].gt ) { return 0x820FD968;  }
		/* 820FD994h case    1:*/		return 0x820FD998;
		  /* 820FD998h */ case    2:  		/* lwz R9, <#[R11 + 12]> */
		/* 820FD998h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 820FD998h case    2:*/		return 0x820FD99C;
		  /* 820FD99Ch */ case    3:  		/* lwz R8, <#[R10 + 12]> */
		/* 820FD99Ch case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x0000000C) );
		/* 820FD99Ch case    3:*/		return 0x820FD9A0;
		  /* 820FD9A0h */ case    4:  		/* cmplw CR6, R9, R8 */
		/* 820FD9A0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820FD9A0h case    4:*/		return 0x820FD9A4;
		  /* 820FD9A4h */ case    5:  		/* bc 12, CR6_LT, -72 */
		/* 820FD9A4h case    5:*/		if ( regs.CR[6].lt ) { return 0x820FD95C;  }
		/* 820FD9A4h case    5:*/		return 0x820FD9A8;
		  /* 820FD9A8h */ case    6:  		/* bc 12, CR6_GT, -64 */
		/* 820FD9A8h case    6:*/		if ( regs.CR[6].gt ) { return 0x820FD968;  }
		/* 820FD9A8h case    6:*/		return 0x820FD9AC;
		  /* 820FD9ACh */ case    7:  		/* lwz R9, <#[R11 + 8]> */
		/* 820FD9ACh case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 820FD9ACh case    7:*/		return 0x820FD9B0;
		  /* 820FD9B0h */ case    8:  		/* lwz R8, <#[R10 + 8]> */
		/* 820FD9B0h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 820FD9B0h case    8:*/		return 0x820FD9B4;
		  /* 820FD9B4h */ case    9:  		/* cmplw CR6, R9, R8 */
		/* 820FD9B4h case    9:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820FD9B4h case    9:*/		return 0x820FD9B8;
		  /* 820FD9B8h */ case   10:  		/* bc 12, CR6_LT, -92 */
		/* 820FD9B8h case   10:*/		if ( regs.CR[6].lt ) { return 0x820FD95C;  }
		/* 820FD9B8h case   10:*/		return 0x820FD9BC;
		  /* 820FD9BCh */ case   11:  		/* bc 12, CR6_GT, -84 */
		/* 820FD9BCh case   11:*/		if ( regs.CR[6].gt ) { return 0x820FD968;  }
		/* 820FD9BCh case   11:*/		return 0x820FD9C0;
	}
	return 0x820FD9C0;
} // Block from 820FD990h-820FD9C0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820FD9C0h
// Function '?AddPool@CBaseProgram@D3DXShader@@QAAIPAVCPool@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FD9C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FD9C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FD9C0);
		  /* 820FD9C0h */ case    0:  		/* lwz R9, <#[R11 + 16]> */
		/* 820FD9C0h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 820FD9C0h case    0:*/		return 0x820FD9C4;
		  /* 820FD9C4h */ case    1:  		/* lwz R8, <#[R10 + 16]> */
		/* 820FD9C4h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000010) );
		/* 820FD9C4h case    1:*/		return 0x820FD9C8;
		  /* 820FD9C8h */ case    2:  		/* cmplw CR6, R9, R8 */
		/* 820FD9C8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820FD9C8h case    2:*/		return 0x820FD9CC;
		  /* 820FD9CCh */ case    3:  		/* bc 12, CR6_LT, -112 */
		/* 820FD9CCh case    3:*/		if ( regs.CR[6].lt ) { return 0x820FD95C;  }
		/* 820FD9CCh case    3:*/		return 0x820FD9D0;
		  /* 820FD9D0h */ case    4:  		/* bc 12, CR6_GT, -104 */
		/* 820FD9D0h case    4:*/		if ( regs.CR[6].gt ) { return 0x820FD968;  }
		/* 820FD9D0h case    4:*/		return 0x820FD9D4;
		  /* 820FD9D4h */ case    5:  		/* lwz R9, <#[R11 + 20]> */
		/* 820FD9D4h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 820FD9D4h case    5:*/		return 0x820FD9D8;
		  /* 820FD9D8h */ case    6:  		/* lwz R8, <#[R10 + 20]> */
		/* 820FD9D8h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000014) );
		/* 820FD9D8h case    6:*/		return 0x820FD9DC;
		  /* 820FD9DCh */ case    7:  		/* cmplw CR6, R9, R8 */
		/* 820FD9DCh case    7:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820FD9DCh case    7:*/		return 0x820FD9E0;
		  /* 820FD9E0h */ case    8:  		/* bc 12, CR6_LT, -132 */
		/* 820FD9E0h case    8:*/		if ( regs.CR[6].lt ) { return 0x820FD95C;  }
		/* 820FD9E0h case    8:*/		return 0x820FD9E4;
		  /* 820FD9E4h */ case    9:  		/* bc 12, CR6_GT, -124 */
		/* 820FD9E4h case    9:*/		if ( regs.CR[6].gt ) { return 0x820FD968;  }
		/* 820FD9E4h case    9:*/		return 0x820FD9E8;
		  /* 820FD9E8h */ case   10:  		/* lwz R11, <#[R11 + 24]> */
		/* 820FD9E8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820FD9E8h case   10:*/		return 0x820FD9EC;
		  /* 820FD9ECh */ case   11:  		/* lwz R10, <#[R10 + 24]> */
		/* 820FD9ECh case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000018) );
		/* 820FD9ECh case   11:*/		return 0x820FD9F0;
		  /* 820FD9F0h */ case   12:  		/* cmpw CR6, R11, R10 */
		/* 820FD9F0h case   12:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820FD9F0h case   12:*/		return 0x820FD9F4;
		  /* 820FD9F4h */ case   13:  		/* bc 12, CR6_LT, -152 */
		/* 820FD9F4h case   13:*/		if ( regs.CR[6].lt ) { return 0x820FD95C;  }
		/* 820FD9F4h case   13:*/		return 0x820FD9F8;
		  /* 820FD9F8h */ case   14:  		/* subfc R9, R11, R10 */
		/* 820FD9F8h case   14:*/		cpu::op::subfc<0>(regs,&regs.R9,regs.R11,regs.R10);
		/* 820FD9F8h case   14:*/		return 0x820FD9FC;
		  /* 820FD9FCh */ case   15:  		/* eqv R11, R11, R10 */
		/* 820FD9FCh case   15:*/		cpu::op::eqv<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820FD9FCh case   15:*/		return 0x820FDA00;
		  /* 820FDA00h */ case   16:  		/* rlwinm R11, R11, 1, 31, 31 */
		/* 820FDA00h case   16:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R11);
		/* 820FDA00h case   16:*/		return 0x820FDA04;
		  /* 820FDA04h */ case   17:  		/* addze R11, R11 */
		/* 820FDA04h case   17:*/		cpu::op::addze<0>(regs,&regs.R11,regs.R11);
		/* 820FDA04h case   17:*/		return 0x820FDA08;
		  /* 820FDA08h */ case   18:  		/* rlwinm R3, R11, 0, 31, 31 */
		/* 820FDA08h case   18:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R3,regs.R11);
		/* 820FDA08h case   18:*/		return 0x820FDA0C;
		  /* 820FDA0Ch */ case   19:  		/* bclr 20, CR0_LT */
		/* 820FDA0Ch case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FDA0Ch case   19:*/		return 0x820FDA10;
	}
	return 0x820FDA10;
} // Block from 820FD9C0h-820FDA10h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820FDA10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDA10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDA10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDA10);
		  /* 820FDA10h */ case    0:  		/* cmplw CR6, R3, R4 */
		/* 820FDA10h case    0:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R4);
		/* 820FDA10h case    0:*/		return 0x820FDA14;
		  /* 820FDA14h */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 820FDA14h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820FDA20;  }
		/* 820FDA14h case    1:*/		return 0x820FDA18;
		  /* 820FDA18h */ case    2:  		/* li R3, -1 */
		/* 820FDA18h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820FDA18h case    2:*/		return 0x820FDA1C;
		  /* 820FDA1Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 820FDA1Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FDA1Ch case    3:*/		return 0x820FDA20;
	}
	return 0x820FDA20;
} // Block from 820FDA10h-820FDA20h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FDA20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDA20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDA20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDA20);
		  /* 820FDA20h */ case    0:  		/* subfc R11, R3, R4 */
		/* 820FDA20h case    0:*/		cpu::op::subfc<0>(regs,&regs.R11,regs.R3,regs.R4);
		/* 820FDA20h case    0:*/		return 0x820FDA24;
		  /* 820FDA24h */ case    1:  		/* subfe R11, R11, R11 */
		/* 820FDA24h case    1:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820FDA24h case    1:*/		return 0x820FDA28;
		  /* 820FDA28h */ case    2:  		/* rlwinm R3, R11, 0, 31, 31 */
		/* 820FDA28h case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R3,regs.R11);
		/* 820FDA28h case    2:*/		return 0x820FDA2C;
		  /* 820FDA2Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 820FDA2Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FDA2Ch case    3:*/		return 0x820FDA30;
	}
	return 0x820FDA30;
} // Block from 820FDA20h-820FDA30h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FDA30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDA30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDA30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDA30);
		  /* 820FDA30h */ case    0:  		/* lwz R11, <#[R5 + 24]> */
		/* 820FDA30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000018) );
		/* 820FDA30h case    0:*/		return 0x820FDA34;
		  /* 820FDA34h */ case    1:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820FDA34h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820FDA34h case    1:*/		return 0x820FDA38;
		  /* 820FDA38h */ case    2:  		/* rlwinm R9, R4, 2, 0, 29 */
		/* 820FDA38h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R4);
		/* 820FDA38h case    2:*/		return 0x820FDA3C;
		  /* 820FDA3Ch */ case    3:  		/* lwzx R10, <#[R10 + R11]> */
		/* 820FDA3Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820FDA3Ch case    3:*/		return 0x820FDA40;
		  /* 820FDA40h */ case    4:  		/* lwzx R9, <#[R9 + R11]> */
		/* 820FDA40h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820FDA40h case    4:*/		return 0x820FDA44;
		  /* 820FDA44h */ case    5:  		/* lwz R11, <#[R10 + 48]> */
		/* 820FDA44h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000030) );
		/* 820FDA44h case    5:*/		return 0x820FDA48;
		  /* 820FDA48h */ case    6:  		/* lwz R10, <#[R9 + 48]> */
		/* 820FDA48h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000030) );
		/* 820FDA48h case    6:*/		return 0x820FDA4C;
		  /* 820FDA4Ch */ case    7:  		/* cmpw CR6, R11, R10 */
		/* 820FDA4Ch case    7:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820FDA4Ch case    7:*/		return 0x820FDA50;
		  /* 820FDA50h */ case    8:  		/* bc 4, CR6_LT, 12 */
		/* 820FDA50h case    8:*/		if ( !regs.CR[6].lt ) { return 0x820FDA5C;  }
		/* 820FDA50h case    8:*/		return 0x820FDA54;
		  /* 820FDA54h */ case    9:  		/* li R3, -1 */
		/* 820FDA54h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820FDA54h case    9:*/		return 0x820FDA58;
		  /* 820FDA58h */ case   10:  		/* bclr 20, CR0_LT */
		/* 820FDA58h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FDA58h case   10:*/		return 0x820FDA5C;
	}
	return 0x820FDA5C;
} // Block from 820FDA30h-820FDA5Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FDA5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDA5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDA5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDA5C);
		  /* 820FDA5Ch */ case    0:  		/* bc 4, CR6_GT, 12 */
		/* 820FDA5Ch case    0:*/		if ( !regs.CR[6].gt ) { return 0x820FDA68;  }
		/* 820FDA5Ch case    0:*/		return 0x820FDA60;
		  /* 820FDA60h */ case    1:  		/* li R3, 1 */
		/* 820FDA60h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FDA60h case    1:*/		return 0x820FDA64;
		  /* 820FDA64h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820FDA64h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FDA64h case    2:*/		return 0x820FDA68;
	}
	return 0x820FDA68;
} // Block from 820FDA5Ch-820FDA68h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FDA68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDA68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDA68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDA68);
		  /* 820FDA68h */ case    0:  		/* cmplw CR6, R3, R4 */
		/* 820FDA68h case    0:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R4);
		/* 820FDA68h case    0:*/		return 0x820FDA6C;
		  /* 820FDA6Ch */ case    1:  		/* bc 12, CR6_LT, -24 */
		/* 820FDA6Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x820FDA54;  }
		/* 820FDA6Ch case    1:*/		return 0x820FDA70;
		  /* 820FDA70h */ case    2:  		/* subfc R11, R3, R4 */
		/* 820FDA70h case    2:*/		cpu::op::subfc<0>(regs,&regs.R11,regs.R3,regs.R4);
		/* 820FDA70h case    2:*/		return 0x820FDA74;
		  /* 820FDA74h */ case    3:  		/* subfe R11, R11, R11 */
		/* 820FDA74h case    3:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820FDA74h case    3:*/		return 0x820FDA78;
		  /* 820FDA78h */ case    4:  		/* rlwinm R3, R11, 0, 31, 31 */
		/* 820FDA78h case    4:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R3,regs.R11);
		/* 820FDA78h case    4:*/		return 0x820FDA7C;
		  /* 820FDA7Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 820FDA7Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FDA7Ch case    5:*/		return 0x820FDA80;
	}
	return 0x820FDA80;
} // Block from 820FDA68h-820FDA80h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FDA80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDA80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDA80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDA80);
		  /* 820FDA80h */ case    0:  		/* mfspr R12, LR */
		/* 820FDA80h case    0:*/		regs.R12 = regs.LR;
		/* 820FDA80h case    0:*/		return 0x820FDA84;
		  /* 820FDA84h */ case    1:  		/* bl -444468 */
		/* 820FDA84h case    1:*/		regs.LR = 0x820FDA88; return 0x82091250;
		/* 820FDA84h case    1:*/		return 0x820FDA88;
		  /* 820FDA88h */ case    2:  		/* lwz R10, <#[R5 + 24]> */
		/* 820FDA88h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000018) );
		/* 820FDA88h case    2:*/		return 0x820FDA8C;
		  /* 820FDA8Ch */ case    3:  		/* rlwinm R9, R3, 2, 0, 29 */
		/* 820FDA8Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R3);
		/* 820FDA8Ch case    3:*/		return 0x820FDA90;
		  /* 820FDA90h */ case    4:  		/* rlwinm R7, R4, 2, 0, 29 */
		/* 820FDA90h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R4);
		/* 820FDA90h case    4:*/		return 0x820FDA94;
		  /* 820FDA94h */ case    5:  		/* li R11, 0 */
		/* 820FDA94h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820FDA94h case    5:*/		return 0x820FDA98;
	}
	return 0x820FDA98;
} // Block from 820FDA80h-820FDA98h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FDA98h
// Function '?AddArgument@CBaseProgram@D3DXShader@@QAAIPAVCArgument@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDA98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDA98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDA98);
		  /* 820FDA98h */ case    0:  		/* li R8, 0 */
		/* 820FDA98h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820FDA98h case    0:*/		return 0x820FDA9C;
		  /* 820FDA9Ch */ case    1:  		/* lwzx R27, <#[R9 + R10]> */
		/* 820FDA9Ch case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FDA9Ch case    1:*/		return 0x820FDAA0;
		  /* 820FDAA0h */ case    2:  		/* lwzx R26, <#[R7 + R10]> */
		/* 820FDAA0h case    2:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 820FDAA0h case    2:*/		return 0x820FDAA4;
		  /* 820FDAA4h */ case    3:  		/* lwz R9, <#[R27 + 52]> */
		/* 820FDAA4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000034) );
		/* 820FDAA4h case    3:*/		return 0x820FDAA8;
		  /* 820FDAA8h */ case    4:  		/* lwz R30, <#[R26 + 52]> */
		/* 820FDAA8h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + 0x00000034) );
		/* 820FDAA8h case    4:*/		return 0x820FDAAC;
		  /* 820FDAACh */ case    5:  		/* mr R6, R9 */
		/* 820FDAACh case    5:*/		regs.R6 = regs.R9;
		/* 820FDAACh case    5:*/		return 0x820FDAB0;
		  /* 820FDAB0h */ case    6:  		/* mr R7, R30 */
		/* 820FDAB0h case    6:*/		regs.R7 = regs.R30;
		/* 820FDAB0h case    6:*/		return 0x820FDAB4;
		  /* 820FDAB4h */ case    7:  		/* mr R10, R9 */
		/* 820FDAB4h case    7:*/		regs.R10 = regs.R9;
		/* 820FDAB4h case    7:*/		return 0x820FDAB8;
		  /* 820FDAB8h */ case    8:  		/* cmpwi CR6, R9, -1 */
		/* 820FDAB8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 820FDAB8h case    8:*/		return 0x820FDABC;
		  /* 820FDABCh */ case    9:  		/* bc 12, CR6_EQ, 32 */
		/* 820FDABCh case    9:*/		if ( regs.CR[6].eq ) { return 0x820FDADC;  }
		/* 820FDABCh case    9:*/		return 0x820FDAC0;
		  /* 820FDAC0h */ case   10:  		/* lwz R31, <#[R5 + 20]> */
		/* 820FDAC0h case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R5 + 0x00000014) );
		/* 820FDAC0h case   10:*/		return 0x820FDAC4;
		  /* 820FDAC4h */ case   11:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FDAC4h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FDAC4h case   11:*/		return 0x820FDAC8;
		  /* 820FDAC8h */ case   12:  		/* addi R11, R11, 1 */
		/* 820FDAC8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820FDAC8h case   12:*/		return 0x820FDACC;
		  /* 820FDACCh */ case   13:  		/* lwzx R10, <#[R10 + R31]> */
		/* 820FDACCh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 820FDACCh case   13:*/		return 0x820FDAD0;
		  /* 820FDAD0h */ case   14:  		/* lwz R10, <#[R10 + 20]> */
		/* 820FDAD0h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 820FDAD0h case   14:*/		return 0x820FDAD4;
		  /* 820FDAD4h */ case   15:  		/* cmpwi CR6, R10, -1 */
		/* 820FDAD4h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820FDAD4h case   15:*/		return 0x820FDAD8;
		  /* 820FDAD8h */ case   16:  		/* bc 4, CR6_EQ, -20 */
		/* 820FDAD8h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820FDAC4;  }
		/* 820FDAD8h case   16:*/		return 0x820FDADC;
	}
	return 0x820FDADC;
} // Block from 820FDA98h-820FDADCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 820FDADCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDADC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDADC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDADC);
		  /* 820FDADCh */ case    0:  		/* mr R10, R7 */
		/* 820FDADCh case    0:*/		regs.R10 = regs.R7;
		/* 820FDADCh case    0:*/		return 0x820FDAE0;
		  /* 820FDAE0h */ case    1:  		/* cmpwi CR6, R7, -1 */
		/* 820FDAE0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R7,0xFFFFFFFF);
		/* 820FDAE0h case    1:*/		return 0x820FDAE4;
		  /* 820FDAE4h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 820FDAE4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FDB04;  }
		/* 820FDAE4h case    2:*/		return 0x820FDAE8;
		  /* 820FDAE8h */ case    3:  		/* lwz R31, <#[R5 + 20]> */
		/* 820FDAE8h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R5 + 0x00000014) );
		/* 820FDAE8h case    3:*/		return 0x820FDAEC;
		  /* 820FDAECh */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FDAECh case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FDAECh case    4:*/		return 0x820FDAF0;
		  /* 820FDAF0h */ case    5:  		/* addi R8, R8, 1 */
		/* 820FDAF0h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820FDAF0h case    5:*/		return 0x820FDAF4;
		  /* 820FDAF4h */ case    6:  		/* lwzx R10, <#[R10 + R31]> */
		/* 820FDAF4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 820FDAF4h case    6:*/		return 0x820FDAF8;
		  /* 820FDAF8h */ case    7:  		/* lwz R10, <#[R10 + 20]> */
		/* 820FDAF8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 820FDAF8h case    7:*/		return 0x820FDAFC;
		  /* 820FDAFCh */ case    8:  		/* cmpwi CR6, R10, -1 */
		/* 820FDAFCh case    8:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820FDAFCh case    8:*/		return 0x820FDB00;
		  /* 820FDB00h */ case    9:  		/* bc 4, CR6_EQ, -20 */
		/* 820FDB00h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820FDAEC;  }
		/* 820FDB00h case    9:*/		return 0x820FDB04;
	}
	return 0x820FDB04;
} // Block from 820FDADCh-820FDB04h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FDB04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDB04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDB04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDB04);
		  /* 820FDB04h */ case    0:  		/* mr R31, R11 */
		/* 820FDB04h case    0:*/		regs.R31 = regs.R11;
		/* 820FDB04h case    0:*/		return 0x820FDB08;
		  /* 820FDB08h */ case    1:  		/* mr R28, R8 */
		/* 820FDB08h case    1:*/		regs.R28 = regs.R8;
		/* 820FDB08h case    1:*/		return 0x820FDB0C;
		  /* 820FDB0Ch */ case    2:  		/* cmplw CR6, R8, R11 */
		/* 820FDB0Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 820FDB0Ch case    2:*/		return 0x820FDB10;
		  /* 820FDB10h */ case    3:  		/* bc 4, CR6_LT, 40 */
		/* 820FDB10h case    3:*/		if ( !regs.CR[6].lt ) { return 0x820FDB38;  }
		/* 820FDB10h case    3:*/		return 0x820FDB14;
		  /* 820FDB14h */ case    4:  		/* subf R29, R8, R11 */
		/* 820FDB14h case    4:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R8,regs.R11);
		/* 820FDB14h case    4:*/		return 0x820FDB18;
		  /* 820FDB18h */ case    5:  		/* lwz R10, <#[R5 + 20]> */
		/* 820FDB18h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000014) );
		/* 820FDB18h case    5:*/		return 0x820FDB1C;
		  /* 820FDB1Ch */ case    6:  		/* mtspr CTR, R29 */
		/* 820FDB1Ch case    6:*/		regs.CTR = regs.R29;
		/* 820FDB1Ch case    6:*/		return 0x820FDB20;
		  /* 820FDB20h */ case    7:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820FDB20h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820FDB20h case    7:*/		return 0x820FDB24;
		  /* 820FDB24h */ case    8:  		/* addi R11, R11, -1 */
		/* 820FDB24h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820FDB24h case    8:*/		return 0x820FDB28;
		  /* 820FDB28h */ case    9:  		/* lwzx R6, <#[R6 + R10]> */
		/* 820FDB28h case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R10 + 0x00000000) );
		/* 820FDB28h case    9:*/		return 0x820FDB2C;
		  /* 820FDB2Ch */ case   10:  		/* lwz R6, <#[R6 + 20]> */
		/* 820FDB2Ch case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000014) );
		/* 820FDB2Ch case   10:*/		return 0x820FDB30;
		  /* 820FDB30h */ case   11:  		/* bc 16, CR0_LT, -16 */
		/* 820FDB30h case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820FDB20;  }
		/* 820FDB30h case   11:*/		return 0x820FDB34;
		  /* 820FDB34h */ case   12:  		/* cmplw CR6, R8, R11 */
		/* 820FDB34h case   12:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 820FDB34h case   12:*/		return 0x820FDB38;
	}
	return 0x820FDB38;
} // Block from 820FDB04h-820FDB38h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FDB38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDB38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDB38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDB38);
		  /* 820FDB38h */ case    0:  		/* bc 4, CR6_GT, 36 */
		/* 820FDB38h case    0:*/		if ( !regs.CR[6].gt ) { return 0x820FDB5C;  }
		/* 820FDB38h case    0:*/		return 0x820FDB3C;
		  /* 820FDB3Ch */ case    1:  		/* subf R29, R11, R8 */
		/* 820FDB3Ch case    1:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R11,regs.R8);
		/* 820FDB3Ch case    1:*/		return 0x820FDB40;
		  /* 820FDB40h */ case    2:  		/* lwz R10, <#[R5 + 20]> */
		/* 820FDB40h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000014) );
		/* 820FDB40h case    2:*/		return 0x820FDB44;
		  /* 820FDB44h */ case    3:  		/* mtspr CTR, R29 */
		/* 820FDB44h case    3:*/		regs.CTR = regs.R29;
		/* 820FDB44h case    3:*/		return 0x820FDB48;
		  /* 820FDB48h */ case    4:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 820FDB48h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 820FDB48h case    4:*/		return 0x820FDB4C;
		  /* 820FDB4Ch */ case    5:  		/* addi R8, R8, -1 */
		/* 820FDB4Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 820FDB4Ch case    5:*/		return 0x820FDB50;
		  /* 820FDB50h */ case    6:  		/* lwzx R7, <#[R7 + R10]> */
		/* 820FDB50h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 820FDB50h case    6:*/		return 0x820FDB54;
		  /* 820FDB54h */ case    7:  		/* lwz R7, <#[R7 + 20]> */
		/* 820FDB54h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000014) );
		/* 820FDB54h case    7:*/		return 0x820FDB58;
		  /* 820FDB58h */ case    8:  		/* bc 16, CR0_LT, -16 */
		/* 820FDB58h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820FDB48;  }
		/* 820FDB58h case    8:*/		return 0x820FDB5C;
	}
	return 0x820FDB5C;
} // Block from 820FDB38h-820FDB5Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820FDB5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDB5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDB5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDB5C);
		  /* 820FDB5Ch */ case    0:  		/* cmplw CR6, R6, R7 */
		/* 820FDB5Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R7);
		/* 820FDB5Ch case    0:*/		return 0x820FDB60;
		  /* 820FDB60h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 820FDB60h case    1:*/		if ( regs.CR[6].eq ) { return 0x820FDB90;  }
		/* 820FDB60h case    1:*/		return 0x820FDB64;
		  /* 820FDB64h */ case    2:  		/* lwz R10, <#[R5 + 20]> */
		/* 820FDB64h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000014) );
		/* 820FDB64h case    2:*/		return 0x820FDB68;
		  /* 820FDB68h */ case    3:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820FDB68h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820FDB68h case    3:*/		return 0x820FDB6C;
		  /* 820FDB6Ch */ case    4:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 820FDB6Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 820FDB6Ch case    4:*/		return 0x820FDB70;
		  /* 820FDB70h */ case    5:  		/* addi R11, R11, -1 */
		/* 820FDB70h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820FDB70h case    5:*/		return 0x820FDB74;
		  /* 820FDB74h */ case    6:  		/* addi R8, R8, -1 */
		/* 820FDB74h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 820FDB74h case    6:*/		return 0x820FDB78;
		  /* 820FDB78h */ case    7:  		/* lwzx R6, <#[R6 + R10]> */
		/* 820FDB78h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R10 + 0x00000000) );
		/* 820FDB78h case    7:*/		return 0x820FDB7C;
		  /* 820FDB7Ch */ case    8:  		/* lwzx R7, <#[R7 + R10]> */
		/* 820FDB7Ch case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 820FDB7Ch case    8:*/		return 0x820FDB80;
		  /* 820FDB80h */ case    9:  		/* lwz R6, <#[R6 + 20]> */
		/* 820FDB80h case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000014) );
		/* 820FDB80h case    9:*/		return 0x820FDB84;
		  /* 820FDB84h */ case   10:  		/* lwz R7, <#[R7 + 20]> */
		/* 820FDB84h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000014) );
		/* 820FDB84h case   10:*/		return 0x820FDB88;
		  /* 820FDB88h */ case   11:  		/* cmplw CR6, R6, R7 */
		/* 820FDB88h case   11:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R7);
		/* 820FDB88h case   11:*/		return 0x820FDB8C;
		  /* 820FDB8Ch */ case   12:  		/* bc 4, CR6_EQ, -36 */
		/* 820FDB8Ch case   12:*/		if ( !regs.CR[6].eq ) { return 0x820FDB68;  }
		/* 820FDB8Ch case   12:*/		return 0x820FDB90;
	}
	return 0x820FDB90;
} // Block from 820FDB5Ch-820FDB90h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FDB90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDB90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDB90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDB90);
		  /* 820FDB90h */ case    0:  		/* mr R6, R3 */
		/* 820FDB90h case    0:*/		regs.R6 = regs.R3;
		/* 820FDB90h case    0:*/		return 0x820FDB94;
		  /* 820FDB94h */ case    1:  		/* mr R29, R3 */
		/* 820FDB94h case    1:*/		regs.R29 = regs.R3;
		/* 820FDB94h case    1:*/		return 0x820FDB98;
		  /* 820FDB98h */ case    2:  		/* cmplw CR6, R11, R31 */
		/* 820FDB98h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 820FDB98h case    2:*/		return 0x820FDB9C;
		  /* 820FDB9Ch */ case    3:  		/* bc 4, CR6_LT, 64 */
		/* 820FDB9Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x820FDBDC;  }
		/* 820FDB9Ch case    3:*/		return 0x820FDBA0;
		  /* 820FDBA0h */ case    4:  		/* subf R11, R11, R31 */
		/* 820FDBA0h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 820FDBA0h case    4:*/		return 0x820FDBA4;
		  /* 820FDBA4h */ case    5:  		/* lwz R7, <#[R5 + 20]> */
		/* 820FDBA4h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R5 + 0x00000014) );
		/* 820FDBA4h case    5:*/		return 0x820FDBA8;
		  /* 820FDBA8h */ case    6:  		/* mtspr CTR, R11 */
		/* 820FDBA8h case    6:*/		regs.CTR = regs.R11;
		/* 820FDBA8h case    6:*/		return 0x820FDBAC;
		  /* 820FDBACh */ case    7:  		/* rlwinm R11, R9, 2, 0, 29 */
		/* 820FDBACh case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R9);
		/* 820FDBACh case    7:*/		return 0x820FDBB0;
		  /* 820FDBB0h */ case    8:  		/* lwzx R10, <#[R11 + R7]> */
		/* 820FDBB0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820FDBB0h case    8:*/		return 0x820FDBB4;
		  /* 820FDBB4h */ case    9:  		/* lwz R11, <#[R10 + 72]> */
		/* 820FDBB4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000048) );
		/* 820FDBB4h case    9:*/		return 0x820FDBB8;
		  /* 820FDBB8h */ case   10:  		/* cmplw CR6, R6, R11 */
		/* 820FDBB8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 820FDBB8h case   10:*/		return 0x820FDBBC;
		  /* 820FDBBCh */ case   11:  		/* bc 4, CR6_GT, 8 */
		/* 820FDBBCh case   11:*/		if ( !regs.CR[6].gt ) { return 0x820FDBC4;  }
		/* 820FDBBCh case   11:*/		return 0x820FDBC0;
		  /* 820FDBC0h */ case   12:  		/* mr R6, R11 */
		/* 820FDBC0h case   12:*/		regs.R6 = regs.R11;
		/* 820FDBC0h case   12:*/		return 0x820FDBC4;
	}
	return 0x820FDBC4;
} // Block from 820FDB90h-820FDBC4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FDBC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDBC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDBC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDBC4);
		  /* 820FDBC4h */ case    0:  		/* lwz R11, <#[R10 + 88]> */
		/* 820FDBC4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000058) );
		/* 820FDBC4h case    0:*/		return 0x820FDBC8;
		  /* 820FDBC8h */ case    1:  		/* cmplw CR6, R29, R11 */
		/* 820FDBC8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820FDBC8h case    1:*/		return 0x820FDBCC;
		  /* 820FDBCCh */ case    2:  		/* bc 4, CR6_LT, 8 */
		/* 820FDBCCh case    2:*/		if ( !regs.CR[6].lt ) { return 0x820FDBD4;  }
		/* 820FDBCCh case    2:*/		return 0x820FDBD0;
		  /* 820FDBD0h */ case    3:  		/* mr R29, R11 */
		/* 820FDBD0h case    3:*/		regs.R29 = regs.R11;
		/* 820FDBD0h case    3:*/		return 0x820FDBD4;
	}
	return 0x820FDBD4;
} // Block from 820FDBC4h-820FDBD4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FDBD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDBD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDBD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDBD4);
		  /* 820FDBD4h */ case    0:  		/* lwz R9, <#[R10 + 20]> */
		/* 820FDBD4h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000014) );
		/* 820FDBD4h case    0:*/		return 0x820FDBD8;
		  /* 820FDBD8h */ case    1:  		/* bc 16, CR0_LT, -44 */
		/* 820FDBD8h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820FDBAC;  }
		/* 820FDBD8h case    1:*/		return 0x820FDBDC;
	}
	return 0x820FDBDC;
} // Block from 820FDBD4h-820FDBDCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FDBDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDBDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDBDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDBDC);
		  /* 820FDBDCh */ case    0:  		/* mr R9, R4 */
		/* 820FDBDCh case    0:*/		regs.R9 = regs.R4;
		/* 820FDBDCh case    0:*/		return 0x820FDBE0;
		  /* 820FDBE0h */ case    1:  		/* mr R7, R4 */
		/* 820FDBE0h case    1:*/		regs.R7 = regs.R4;
		/* 820FDBE0h case    1:*/		return 0x820FDBE4;
		  /* 820FDBE4h */ case    2:  		/* cmplw CR6, R8, R28 */
		/* 820FDBE4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R28);
		/* 820FDBE4h case    2:*/		return 0x820FDBE8;
		  /* 820FDBE8h */ case    3:  		/* bc 4, CR6_LT, 64 */
		/* 820FDBE8h case    3:*/		if ( !regs.CR[6].lt ) { return 0x820FDC28;  }
		/* 820FDBE8h case    3:*/		return 0x820FDBEC;
		  /* 820FDBECh */ case    4:  		/* subf R11, R8, R28 */
		/* 820FDBECh case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R8,regs.R28);
		/* 820FDBECh case    4:*/		return 0x820FDBF0;
		  /* 820FDBF0h */ case    5:  		/* lwz R8, <#[R5 + 20]> */
		/* 820FDBF0h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + 0x00000014) );
		/* 820FDBF0h case    5:*/		return 0x820FDBF4;
		  /* 820FDBF4h */ case    6:  		/* mtspr CTR, R11 */
		/* 820FDBF4h case    6:*/		regs.CTR = regs.R11;
		/* 820FDBF4h case    6:*/		return 0x820FDBF8;
		  /* 820FDBF8h */ case    7:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 820FDBF8h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 820FDBF8h case    7:*/		return 0x820FDBFC;
		  /* 820FDBFCh */ case    8:  		/* lwzx R10, <#[R11 + R8]> */
		/* 820FDBFCh case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820FDBFCh case    8:*/		return 0x820FDC00;
		  /* 820FDC00h */ case    9:  		/* lwz R11, <#[R10 + 72]> */
		/* 820FDC00h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000048) );
		/* 820FDC00h case    9:*/		return 0x820FDC04;
		  /* 820FDC04h */ case   10:  		/* cmplw CR6, R9, R11 */
		/* 820FDC04h case   10:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820FDC04h case   10:*/		return 0x820FDC08;
		  /* 820FDC08h */ case   11:  		/* bc 4, CR6_GT, 8 */
		/* 820FDC08h case   11:*/		if ( !regs.CR[6].gt ) { return 0x820FDC10;  }
		/* 820FDC08h case   11:*/		return 0x820FDC0C;
		  /* 820FDC0Ch */ case   12:  		/* mr R9, R11 */
		/* 820FDC0Ch case   12:*/		regs.R9 = regs.R11;
		/* 820FDC0Ch case   12:*/		return 0x820FDC10;
	}
	return 0x820FDC10;
} // Block from 820FDBDCh-820FDC10h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FDC10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDC10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDC10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDC10);
		  /* 820FDC10h */ case    0:  		/* lwz R11, <#[R10 + 88]> */
		/* 820FDC10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000058) );
		/* 820FDC10h case    0:*/		return 0x820FDC14;
		  /* 820FDC14h */ case    1:  		/* cmplw CR6, R7, R11 */
		/* 820FDC14h case    1:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820FDC14h case    1:*/		return 0x820FDC18;
		  /* 820FDC18h */ case    2:  		/* bc 4, CR6_LT, 8 */
		/* 820FDC18h case    2:*/		if ( !regs.CR[6].lt ) { return 0x820FDC20;  }
		/* 820FDC18h case    2:*/		return 0x820FDC1C;
		  /* 820FDC1Ch */ case    3:  		/* mr R7, R11 */
		/* 820FDC1Ch case    3:*/		regs.R7 = regs.R11;
		/* 820FDC1Ch case    3:*/		return 0x820FDC20;
	}
	return 0x820FDC20;
} // Block from 820FDC10h-820FDC20h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FDC20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDC20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDC20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDC20);
		  /* 820FDC20h */ case    0:  		/* lwz R30, <#[R10 + 20]> */
		/* 820FDC20h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + 0x00000014) );
		/* 820FDC20h case    0:*/		return 0x820FDC24;
		  /* 820FDC24h */ case    1:  		/* bc 16, CR0_LT, -44 */
		/* 820FDC24h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820FDBF8;  }
		/* 820FDC24h case    1:*/		return 0x820FDC28;
	}
	return 0x820FDC28;
} // Block from 820FDC20h-820FDC28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FDC28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDC28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDC28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDC28);
		  /* 820FDC28h */ case    0:  		/* cmplw CR6, R3, R9 */
		/* 820FDC28h case    0:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R9);
		/* 820FDC28h case    0:*/		return 0x820FDC2C;
		  /* 820FDC2Ch */ case    1:  		/* bc 12, CR6_LT, 12 */
		/* 820FDC2Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x820FDC38;  }
		/* 820FDC2Ch case    1:*/		return 0x820FDC30;
		  /* 820FDC30h */ case    2:  		/* cmplw CR6, R3, R7 */
		/* 820FDC30h case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R7);
		/* 820FDC30h case    2:*/		return 0x820FDC34;
		  /* 820FDC34h */ case    3:  		/* bc 4, CR6_GT, 20 */
		/* 820FDC34h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820FDC48;  }
		/* 820FDC34h case    3:*/		return 0x820FDC38;
	}
	return 0x820FDC38;
} // Block from 820FDC28h-820FDC38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FDC38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDC38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDC38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDC38);
		  /* 820FDC38h */ case    0:  		/* cmplw CR6, R4, R6 */
		/* 820FDC38h case    0:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R6);
		/* 820FDC38h case    0:*/		return 0x820FDC3C;
		  /* 820FDC3Ch */ case    1:  		/* bc 12, CR6_LT, 40 */
		/* 820FDC3Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x820FDC64;  }
		/* 820FDC3Ch case    1:*/		return 0x820FDC40;
		  /* 820FDC40h */ case    2:  		/* cmplw CR6, R4, R29 */
		/* 820FDC40h case    2:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R29);
		/* 820FDC40h case    2:*/		return 0x820FDC44;
		  /* 820FDC44h */ case    3:  		/* bc 12, CR6_GT, 32 */
		/* 820FDC44h case    3:*/		if ( regs.CR[6].gt ) { return 0x820FDC64;  }
		/* 820FDC44h case    3:*/		return 0x820FDC48;
	}
	return 0x820FDC48;
} // Block from 820FDC38h-820FDC48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FDC48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDC48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDC48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDC48);
		  /* 820FDC48h */ case    0:  		/* cmplw CR6, R6, R9 */
		/* 820FDC48h case    0:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R9);
		/* 820FDC48h case    0:*/		return 0x820FDC4C;
		  /* 820FDC4Ch */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 820FDC4Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x820FDC58;  }
		/* 820FDC4Ch case    1:*/		return 0x820FDC50;
	}
	return 0x820FDC50;
} // Block from 820FDC48h-820FDC50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FDC50h
// Function '?AddInstruction@CBaseProgram@D3DXShader@@QAAIPAVCInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDC50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDC50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDC50);
		  /* 820FDC50h */ case    0:  		/* li R3, 1 */
		/* 820FDC50h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FDC50h case    0:*/		return 0x820FDC54;
		  /* 820FDC54h */ case    1:  		/* b 340 */
		/* 820FDC54h case    1:*/		return 0x820FDDA8;
		/* 820FDC54h case    1:*/		return 0x820FDC58;
	}
	return 0x820FDC58;
} // Block from 820FDC50h-820FDC58h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FDC58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDC58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDC58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDC58);
		  /* 820FDC58h */ case    0:  		/* bc 4, CR6_GT, 12 */
		/* 820FDC58h case    0:*/		if ( !regs.CR[6].gt ) { return 0x820FDC64;  }
		/* 820FDC58h case    0:*/		return 0x820FDC5C;
		  /* 820FDC5Ch */ case    1:  		/* li R3, -1 */
		/* 820FDC5Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820FDC5Ch case    1:*/		return 0x820FDC60;
		  /* 820FDC60h */ case    2:  		/* b 328 */
		/* 820FDC60h case    2:*/		return 0x820FDDA8;
		/* 820FDC60h case    2:*/		return 0x820FDC64;
	}
	return 0x820FDC64;
} // Block from 820FDC58h-820FDC64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FDC64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDC64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDC64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDC64);
		  /* 820FDC64h */ case    0:  		/* lwz R11, <#[R27 + 16]> */
		/* 820FDC64h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 820FDC64h case    0:*/		return 0x820FDC68;
		  /* 820FDC68h */ case    1:  		/* li R10, 0 */
		/* 820FDC68h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820FDC68h case    1:*/		return 0x820FDC6C;
		  /* 820FDC6Ch */ case    2:  		/* lwz R9, <#[R26 + 16]> */
		/* 820FDC6Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000010) );
		/* 820FDC6Ch case    2:*/		return 0x820FDC70;
		  /* 820FDC70h */ case    3:  		/* li R8, 0 */
		/* 820FDC70h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820FDC70h case    3:*/		return 0x820FDC74;
		  /* 820FDC74h */ case    4:  		/* lwz R7, <#[R5 + 20]> */
		/* 820FDC74h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R5 + 0x00000014) );
		/* 820FDC74h case    4:*/		return 0x820FDC78;
		  /* 820FDC78h */ case    5:  		/* lwz R11, <#[R11]> */
		/* 820FDC78h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FDC78h case    5:*/		return 0x820FDC7C;
		  /* 820FDC7Ch */ case    6:  		/* lwz R9, <#[R9]> */
		/* 820FDC7Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 820FDC7Ch case    6:*/		return 0x820FDC80;
		  /* 820FDC80h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FDC80h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FDC80h case    7:*/		return 0x820FDC84;
		  /* 820FDC84h */ case    8:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820FDC84h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820FDC84h case    8:*/		return 0x820FDC88;
		  /* 820FDC88h */ case    9:  		/* lwzx R6, <#[R11 + R7]> */
		/* 820FDC88h case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820FDC88h case    9:*/		return 0x820FDC8C;
		  /* 820FDC8Ch */ case   10:  		/* lwzx R7, <#[R9 + R7]> */
		/* 820FDC8Ch case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 820FDC8Ch case   10:*/		return 0x820FDC90;
		  /* 820FDC90h */ case   11:  		/* lwz R11, <#[R6 + 20]> */
		/* 820FDC90h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000014) );
		/* 820FDC90h case   11:*/		return 0x820FDC94;
		  /* 820FDC94h */ case   12:  		/* lwz R30, <#[R7 + 24]> */
		/* 820FDC94h case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R7 + 0x00000018) );
		/* 820FDC94h case   12:*/		return 0x820FDC98;
		  /* 820FDC98h */ case   13:  		/* lwz R31, <#[R6 + 24]> */
		/* 820FDC98h case   13:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R6 + 0x00000018) );
		/* 820FDC98h case   13:*/		return 0x820FDC9C;
		  /* 820FDC9Ch */ case   14:  		/* mr R9, R11 */
		/* 820FDC9Ch case   14:*/		regs.R9 = regs.R11;
		/* 820FDC9Ch case   14:*/		return 0x820FDCA0;
		  /* 820FDCA0h */ case   15:  		/* lwz R7, <#[R7 + 20]> */
		/* 820FDCA0h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000014) );
		/* 820FDCA0h case   15:*/		return 0x820FDCA4;
		  /* 820FDCA4h */ case   16:  		/* cmpwi CR6, R11, -1 */
		/* 820FDCA4h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FDCA4h case   16:*/		return 0x820FDCA8;
		  /* 820FDCA8h */ case   17:  		/* bc 12, CR6_EQ, 32 */
		/* 820FDCA8h case   17:*/		if ( regs.CR[6].eq ) { return 0x820FDCC8;  }
		/* 820FDCA8h case   17:*/		return 0x820FDCAC;
		  /* 820FDCACh */ case   18:  		/* lwz R6, <#[R5 + 20]> */
		/* 820FDCACh case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R5 + 0x00000014) );
		/* 820FDCACh case   18:*/		return 0x820FDCB0;
		  /* 820FDCB0h */ case   19:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820FDCB0h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820FDCB0h case   19:*/		return 0x820FDCB4;
		  /* 820FDCB4h */ case   20:  		/* addi R10, R10, 1 */
		/* 820FDCB4h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820FDCB4h case   20:*/		return 0x820FDCB8;
		  /* 820FDCB8h */ case   21:  		/* lwzx R9, <#[R9 + R6]> */
		/* 820FDCB8h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 820FDCB8h case   21:*/		return 0x820FDCBC;
		  /* 820FDCBCh */ case   22:  		/* lwz R9, <#[R9 + 20]> */
		/* 820FDCBCh case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000014) );
		/* 820FDCBCh case   22:*/		return 0x820FDCC0;
		  /* 820FDCC0h */ case   23:  		/* cmpwi CR6, R9, -1 */
		/* 820FDCC0h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 820FDCC0h case   23:*/		return 0x820FDCC4;
		  /* 820FDCC4h */ case   24:  		/* bc 4, CR6_EQ, -20 */
		/* 820FDCC4h case   24:*/		if ( !regs.CR[6].eq ) { return 0x820FDCB0;  }
		/* 820FDCC4h case   24:*/		return 0x820FDCC8;
	}
	return 0x820FDCC8;
} // Block from 820FDC64h-820FDCC8h (25 instructions)

//////////////////////////////////////////////////////
// Block at 820FDCC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDCC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDCC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDCC8);
		  /* 820FDCC8h */ case    0:  		/* mr R9, R7 */
		/* 820FDCC8h case    0:*/		regs.R9 = regs.R7;
		/* 820FDCC8h case    0:*/		return 0x820FDCCC;
		  /* 820FDCCCh */ case    1:  		/* cmpwi CR6, R7, -1 */
		/* 820FDCCCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R7,0xFFFFFFFF);
		/* 820FDCCCh case    1:*/		return 0x820FDCD0;
		  /* 820FDCD0h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 820FDCD0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FDCF0;  }
		/* 820FDCD0h case    2:*/		return 0x820FDCD4;
		  /* 820FDCD4h */ case    3:  		/* lwz R6, <#[R5 + 20]> */
		/* 820FDCD4h case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R5 + 0x00000014) );
		/* 820FDCD4h case    3:*/		return 0x820FDCD8;
		  /* 820FDCD8h */ case    4:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820FDCD8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820FDCD8h case    4:*/		return 0x820FDCDC;
		  /* 820FDCDCh */ case    5:  		/* addi R8, R8, 1 */
		/* 820FDCDCh case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820FDCDCh case    5:*/		return 0x820FDCE0;
		  /* 820FDCE0h */ case    6:  		/* lwzx R9, <#[R9 + R6]> */
		/* 820FDCE0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 820FDCE0h case    6:*/		return 0x820FDCE4;
		  /* 820FDCE4h */ case    7:  		/* lwz R9, <#[R9 + 20]> */
		/* 820FDCE4h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000014) );
		/* 820FDCE4h case    7:*/		return 0x820FDCE8;
		  /* 820FDCE8h */ case    8:  		/* cmpwi CR6, R9, -1 */
		/* 820FDCE8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 820FDCE8h case    8:*/		return 0x820FDCEC;
		  /* 820FDCECh */ case    9:  		/* bc 4, CR6_EQ, -20 */
		/* 820FDCECh case    9:*/		if ( !regs.CR[6].eq ) { return 0x820FDCD8;  }
		/* 820FDCECh case    9:*/		return 0x820FDCF0;
	}
	return 0x820FDCF0;
} // Block from 820FDCC8h-820FDCF0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FDCF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDCF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDCF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDCF0);
		  /* 820FDCF0h */ case    0:  		/* cmplw CR6, R8, R10 */
		/* 820FDCF0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 820FDCF0h case    0:*/		return 0x820FDCF4;
		  /* 820FDCF4h */ case    1:  		/* bc 4, CR6_LT, 44 */
		/* 820FDCF4h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820FDD20;  }
		/* 820FDCF4h case    1:*/		return 0x820FDCF8;
		  /* 820FDCF8h */ case    2:  		/* subf R6, R8, R10 */
		/* 820FDCF8h case    2:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R8,regs.R10);
		/* 820FDCF8h case    2:*/		return 0x820FDCFC;
		  /* 820FDCFCh */ case    3:  		/* lwz R9, <#[R5 + 20]> */
		/* 820FDCFCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000014) );
		/* 820FDCFCh case    3:*/		return 0x820FDD00;
		  /* 820FDD00h */ case    4:  		/* mtspr CTR, R6 */
		/* 820FDD00h case    4:*/		regs.CTR = regs.R6;
		/* 820FDD00h case    4:*/		return 0x820FDD04;
		  /* 820FDD04h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FDD04h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FDD04h case    5:*/		return 0x820FDD08;
		  /* 820FDD08h */ case    6:  		/* addi R10, R10, -1 */
		/* 820FDD08h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820FDD08h case    6:*/		return 0x820FDD0C;
		  /* 820FDD0Ch */ case    7:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820FDD0Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FDD0Ch case    7:*/		return 0x820FDD10;
		  /* 820FDD10h */ case    8:  		/* lwz R31, <#[R11 + 24]> */
		/* 820FDD10h case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000018) );
		/* 820FDD10h case    8:*/		return 0x820FDD14;
		  /* 820FDD14h */ case    9:  		/* lwz R11, <#[R11 + 20]> */
		/* 820FDD14h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820FDD14h case    9:*/		return 0x820FDD18;
		  /* 820FDD18h */ case   10:  		/* bc 16, CR0_LT, -20 */
		/* 820FDD18h case   10:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820FDD04;  }
		/* 820FDD18h case   10:*/		return 0x820FDD1C;
		  /* 820FDD1Ch */ case   11:  		/* cmplw CR6, R8, R10 */
		/* 820FDD1Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 820FDD1Ch case   11:*/		return 0x820FDD20;
	}
	return 0x820FDD20;
} // Block from 820FDCF0h-820FDD20h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820FDD20h
// Function '?AddPool@CBaseProgram@D3DXShader@@QAAIPBDKII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDD20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDD20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDD20);
		  /* 820FDD20h */ case    0:  		/* bc 4, CR6_GT, 36 */
		/* 820FDD20h case    0:*/		if ( !regs.CR[6].gt ) { return 0x820FDD44;  }
		/* 820FDD20h case    0:*/		return 0x820FDD24;
		  /* 820FDD24h */ case    1:  		/* subf R9, R10, R8 */
		/* 820FDD24h case    1:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R10,regs.R8);
		/* 820FDD24h case    1:*/		return 0x820FDD28;
		  /* 820FDD28h */ case    2:  		/* lwz R10, <#[R5 + 20]> */
		/* 820FDD28h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000014) );
		/* 820FDD28h case    2:*/		return 0x820FDD2C;
		  /* 820FDD2Ch */ case    3:  		/* mtspr CTR, R9 */
		/* 820FDD2Ch case    3:*/		regs.CTR = regs.R9;
		/* 820FDD2Ch case    3:*/		return 0x820FDD30;
		  /* 820FDD30h */ case    4:  		/* rlwinm R9, R7, 2, 0, 29 */
		/* 820FDD30h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R7);
		/* 820FDD30h case    4:*/		return 0x820FDD34;
		  /* 820FDD34h */ case    5:  		/* lwzx R9, <#[R9 + R10]> */
		/* 820FDD34h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FDD34h case    5:*/		return 0x820FDD38;
		  /* 820FDD38h */ case    6:  		/* lwz R30, <#[R9 + 24]> */
		/* 820FDD38h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + 0x00000018) );
		/* 820FDD38h case    6:*/		return 0x820FDD3C;
		  /* 820FDD3Ch */ case    7:  		/* lwz R7, <#[R9 + 20]> */
		/* 820FDD3Ch case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000014) );
		/* 820FDD3Ch case    7:*/		return 0x820FDD40;
		  /* 820FDD40h */ case    8:  		/* bc 16, CR0_LT, -16 */
		/* 820FDD40h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820FDD30;  }
		/* 820FDD40h case    8:*/		return 0x820FDD44;
	}
	return 0x820FDD44;
} // Block from 820FDD20h-820FDD44h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820FDD44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDD44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDD44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDD44);
		  /* 820FDD44h */ case    0:  		/* cmplw CR6, R11, R7 */
		/* 820FDD44h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 820FDD44h case    0:*/		return 0x820FDD48;
		  /* 820FDD48h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 820FDD48h case    1:*/		if ( regs.CR[6].eq ) { return 0x820FDD78;  }
		/* 820FDD48h case    1:*/		return 0x820FDD4C;
		  /* 820FDD4Ch */ case    2:  		/* lwz R10, <#[R5 + 20]> */
		/* 820FDD4Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000014) );
		/* 820FDD4Ch case    2:*/		return 0x820FDD50;
		  /* 820FDD50h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FDD50h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FDD50h case    3:*/		return 0x820FDD54;
		  /* 820FDD54h */ case    4:  		/* rlwinm R9, R7, 2, 0, 29 */
		/* 820FDD54h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R7);
		/* 820FDD54h case    4:*/		return 0x820FDD58;
		  /* 820FDD58h */ case    5:  		/* lwzx R8, <#[R11 + R10]> */
		/* 820FDD58h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FDD58h case    5:*/		return 0x820FDD5C;
		  /* 820FDD5Ch */ case    6:  		/* lwzx R9, <#[R9 + R10]> */
		/* 820FDD5Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FDD5Ch case    6:*/		return 0x820FDD60;
		  /* 820FDD60h */ case    7:  		/* lwz R11, <#[R8 + 20]> */
		/* 820FDD60h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000014) );
		/* 820FDD60h case    7:*/		return 0x820FDD64;
		  /* 820FDD64h */ case    8:  		/* lwz R7, <#[R9 + 20]> */
		/* 820FDD64h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000014) );
		/* 820FDD64h case    8:*/		return 0x820FDD68;
		  /* 820FDD68h */ case    9:  		/* lwz R31, <#[R8 + 24]> */
		/* 820FDD68h case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R8 + 0x00000018) );
		/* 820FDD68h case    9:*/		return 0x820FDD6C;
		  /* 820FDD6Ch */ case   10:  		/* lwz R30, <#[R9 + 24]> */
		/* 820FDD6Ch case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + 0x00000018) );
		/* 820FDD6Ch case   10:*/		return 0x820FDD70;
		  /* 820FDD70h */ case   11:  		/* cmplw CR6, R11, R7 */
		/* 820FDD70h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 820FDD70h case   11:*/		return 0x820FDD74;
		  /* 820FDD74h */ case   12:  		/* bc 4, CR6_EQ, -36 */
		/* 820FDD74h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820FDD50;  }
		/* 820FDD74h case   12:*/		return 0x820FDD78;
	}
	return 0x820FDD78;
} // Block from 820FDD44h-820FDD78h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FDD78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDD78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDD78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDD78);
		  /* 820FDD78h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820FDD78h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820FDD78h case    0:*/		return 0x820FDD7C;
		  /* 820FDD7Ch */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820FDD7Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820FDD8C;  }
		/* 820FDD7Ch case    1:*/		return 0x820FDD80;
		  /* 820FDD80h */ case    2:  		/* cmplwi CR6, R30, 0 */
		/* 820FDD80h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820FDD80h case    2:*/		return 0x820FDD84;
		  /* 820FDD84h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 820FDD84h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820FDD94;  }
		/* 820FDD84h case    3:*/		return 0x820FDD88;
		  /* 820FDD88h */ case    4:  		/* b -300 */
		/* 820FDD88h case    4:*/		return 0x820FDC5C;
		/* 820FDD88h case    4:*/		return 0x820FDD8C;
	}
	return 0x820FDD8C;
} // Block from 820FDD78h-820FDD8Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FDD8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDD8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDD8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDD8C);
		  /* 820FDD8Ch */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820FDD8Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820FDD8Ch case    0:*/		return 0x820FDD90;
		  /* 820FDD90h */ case    1:  		/* bc 4, CR6_EQ, -320 */
		/* 820FDD90h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820FDC50;  }
		/* 820FDD90h case    1:*/		return 0x820FDD94;
	}
	return 0x820FDD94;
} // Block from 820FDD8Ch-820FDD94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FDD94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDD94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDD94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDD94);
		  /* 820FDD94h */ case    0:  		/* cmplw CR6, R3, R4 */
		/* 820FDD94h case    0:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R4);
		/* 820FDD94h case    0:*/		return 0x820FDD98;
		  /* 820FDD98h */ case    1:  		/* bc 12, CR6_LT, -316 */
		/* 820FDD98h case    1:*/		if ( regs.CR[6].lt ) { return 0x820FDC5C;  }
		/* 820FDD98h case    1:*/		return 0x820FDD9C;
		  /* 820FDD9Ch */ case    2:  		/* subfc R11, R3, R4 */
		/* 820FDD9Ch case    2:*/		cpu::op::subfc<0>(regs,&regs.R11,regs.R3,regs.R4);
		/* 820FDD9Ch case    2:*/		return 0x820FDDA0;
		  /* 820FDDA0h */ case    3:  		/* subfe R11, R11, R11 */
		/* 820FDDA0h case    3:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820FDDA0h case    3:*/		return 0x820FDDA4;
		  /* 820FDDA4h */ case    4:  		/* rlwinm R3, R11, 0, 31, 31 */
		/* 820FDDA4h case    4:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R3,regs.R11);
		/* 820FDDA4h case    4:*/		return 0x820FDDA8;
	}
	return 0x820FDDA8;
} // Block from 820FDD94h-820FDDA8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FDDA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDDA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDDA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDDA8);
		  /* 820FDDA8h */ case    0:  		/* b -445192 */
		/* 820FDDA8h case    0:*/		return 0x820912A0;
		/* 820FDDA8h case    0:*/		return 0x820FDDAC;
		  /* 820FDDACh */ case    1:  		/* nop */
		/* 820FDDACh case    1:*/		cpu::op::nop();
		/* 820FDDACh case    1:*/		return 0x820FDDB0;
		  /* 820FDDB0h */ case    2:  		/* lwz R11, <#[R5 + 188]> */
		/* 820FDDB0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x000000BC) );
		/* 820FDDB0h case    2:*/		return 0x820FDDB4;
		  /* 820FDDB4h */ case    3:  		/* mulli R10, R3, 12 */
		/* 820FDDB4h case    3:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R3,0xC);
		/* 820FDDB4h case    3:*/		return 0x820FDDB8;
		  /* 820FDDB8h */ case    4:  		/* lwz R11, <#[R11 + 88]> */
		/* 820FDDB8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000058) );
		/* 820FDDB8h case    4:*/		return 0x820FDDBC;
		  /* 820FDDBCh */ case    5:  		/* mulli R9, R4, 12 */
		/* 820FDDBCh case    5:*/		cpu::op::mulli<0>(regs,&regs.R9,regs.R4,0xC);
		/* 820FDDBCh case    5:*/		return 0x820FDDC0;
	}
	return 0x820FDDC0;
} // Block from 820FDDA8h-820FDDC0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FDDC0h
// Function '?AddArgument@CBaseProgram@D3DXShader@@QAAIIIIN@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDDC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDDC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDDC0);
		  /* 820FDDC0h */ case    0:  		/* lwzx R10, <#[R10 + R11]> */
		/* 820FDDC0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820FDDC0h case    0:*/		return 0x820FDDC4;
		  /* 820FDDC4h */ case    1:  		/* lwzx R11, <#[R9 + R11]> */
		/* 820FDDC4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820FDDC4h case    1:*/		return 0x820FDDC8;
		  /* 820FDDC8h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820FDDC8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FDDC8h case    2:*/		return 0x820FDDCC;
		  /* 820FDDCCh */ case    3:  		/* bc 4, CR6_LT, 12 */
		/* 820FDDCCh case    3:*/		if ( !regs.CR[6].lt ) { return 0x820FDDD8;  }
		/* 820FDDCCh case    3:*/		return 0x820FDDD0;
		  /* 820FDDD0h */ case    4:  		/* li R3, -1 */
		/* 820FDDD0h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820FDDD0h case    4:*/		return 0x820FDDD4;
		  /* 820FDDD4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820FDDD4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FDDD4h case    5:*/		return 0x820FDDD8;
	}
	return 0x820FDDD8;
} // Block from 820FDDC0h-820FDDD8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FDDD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDDD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDDD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDDD8);
		  /* 820FDDD8h */ case    0:  		/* subfc R11, R11, R10 */
		/* 820FDDD8h case    0:*/		cpu::op::subfc<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820FDDD8h case    0:*/		return 0x820FDDDC;
		  /* 820FDDDCh */ case    1:  		/* subfe R11, R11, R11 */
		/* 820FDDDCh case    1:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820FDDDCh case    1:*/		return 0x820FDDE0;
		  /* 820FDDE0h */ case    2:  		/* rlwinm R3, R11, 0, 31, 31 */
		/* 820FDDE0h case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R3,regs.R11);
		/* 820FDDE0h case    2:*/		return 0x820FDDE4;
		  /* 820FDDE4h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820FDDE4h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FDDE4h case    3:*/		return 0x820FDDE8;
	}
	return 0x820FDDE8;
} // Block from 820FDDD8h-820FDDE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FDDE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDDE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDDE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDDE8);
		  /* 820FDDE8h */ case    0:  		/* lwz R11, <#[R5 + 188]> */
		/* 820FDDE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x000000BC) );
		/* 820FDDE8h case    0:*/		return 0x820FDDEC;
		  /* 820FDDECh */ case    1:  		/* mulli R10, R3, 12 */
		/* 820FDDECh case    1:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R3,0xC);
		/* 820FDDECh case    1:*/		return 0x820FDDF0;
		  /* 820FDDF0h */ case    2:  		/* lwz R11, <#[R11 + 88]> */
		/* 820FDDF0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000058) );
		/* 820FDDF0h case    2:*/		return 0x820FDDF4;
		  /* 820FDDF4h */ case    3:  		/* mulli R9, R4, 12 */
		/* 820FDDF4h case    3:*/		cpu::op::mulli<0>(regs,&regs.R9,regs.R4,0xC);
		/* 820FDDF4h case    3:*/		return 0x820FDDF8;
		  /* 820FDDF8h */ case    4:  		/* add R8, R11, R10 */
		/* 820FDDF8h case    4:*/		cpu::op::add<0>(regs,&regs.R8,regs.R11,regs.R10);
		/* 820FDDF8h case    4:*/		return 0x820FDDFC;
		  /* 820FDDFCh */ case    5:  		/* add R11, R11, R9 */
		/* 820FDDFCh case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820FDDFCh case    5:*/		return 0x820FDE00;
		  /* 820FDE00h */ case    6:  		/* lwz R7, <#[R8 + 4]> */
		/* 820FDE00h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x00000004) );
		/* 820FDE00h case    6:*/		return 0x820FDE04;
		  /* 820FDE04h */ case    7:  		/* lwz R6, <#[R11 + 4]> */
		/* 820FDE04h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 820FDE04h case    7:*/		return 0x820FDE08;
		  /* 820FDE08h */ case    8:  		/* cmplw CR6, R7, R6 */
		/* 820FDE08h case    8:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 820FDE08h case    8:*/		return 0x820FDE0C;
		  /* 820FDE0Ch */ case    9:  		/* bc 4, CR6_LT, 12 */
		/* 820FDE0Ch case    9:*/		if ( !regs.CR[6].lt ) { return 0x820FDE18;  }
		/* 820FDE0Ch case    9:*/		return 0x820FDE10;
		  /* 820FDE10h */ case   10:  		/* li R3, -1 */
		/* 820FDE10h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820FDE10h case   10:*/		return 0x820FDE14;
		  /* 820FDE14h */ case   11:  		/* bclr 20, CR0_LT */
		/* 820FDE14h case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FDE14h case   11:*/		return 0x820FDE18;
	}
	return 0x820FDE18;
} // Block from 820FDDE8h-820FDE18h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820FDE18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDE18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDE18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDE18);
		  /* 820FDE18h */ case    0:  		/* bc 12, CR6_GT, 24 */
		/* 820FDE18h case    0:*/		if ( regs.CR[6].gt ) { return 0x820FDE30;  }
		/* 820FDE18h case    0:*/		return 0x820FDE1C;
		  /* 820FDE1Ch */ case    1:  		/* lwz R8, <#[R8 + 8]> */
		/* 820FDE1Ch case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000008) );
		/* 820FDE1Ch case    1:*/		return 0x820FDE20;
		  /* 820FDE20h */ case    2:  		/* lwz R11, <#[R11 + 8]> */
		/* 820FDE20h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820FDE20h case    2:*/		return 0x820FDE24;
		  /* 820FDE24h */ case    3:  		/* cmpw CR6, R8, R11 */
		/* 820FDE24h case    3:*/		cpu::op::cmpw<6>(regs,regs.R8,regs.R11);
		/* 820FDE24h case    3:*/		return 0x820FDE28;
		  /* 820FDE28h */ case    4:  		/* bc 12, CR6_LT, -24 */
		/* 820FDE28h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FDE10;  }
		/* 820FDE28h case    4:*/		return 0x820FDE2C;
		  /* 820FDE2Ch */ case    5:  		/* bc 4, CR6_GT, 12 */
		/* 820FDE2Ch case    5:*/		if ( !regs.CR[6].gt ) { return 0x820FDE38;  }
		/* 820FDE2Ch case    5:*/		return 0x820FDE30;
	}
	return 0x820FDE30;
} // Block from 820FDE18h-820FDE30h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FDE30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDE30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDE30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDE30);
		  /* 820FDE30h */ case    0:  		/* li R3, 1 */
		/* 820FDE30h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FDE30h case    0:*/		return 0x820FDE34;
		  /* 820FDE34h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820FDE34h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FDE34h case    1:*/		return 0x820FDE38;
	}
	return 0x820FDE38;
} // Block from 820FDE30h-820FDE38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FDE38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDE38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDE38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDE38);
		  /* 820FDE38h */ case    0:  		/* lwz R11, <#[R5 + 188]> */
		/* 820FDE38h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x000000BC) );
		/* 820FDE38h case    0:*/		return 0x820FDE3C;
		  /* 820FDE3Ch */ case    1:  		/* lwz R8, <#[R11 + 88]> */
		/* 820FDE3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000058) );
		/* 820FDE3Ch case    1:*/		return 0x820FDE40;
		  /* 820FDE40h */ case    2:  		/* lwzx R11, <#[R8 + R9]> */
		/* 820FDE40h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 820FDE40h case    2:*/		return 0x820FDE44;
		  /* 820FDE44h */ case    3:  		/* lwzx R10, <#[R8 + R10]> */
		/* 820FDE44h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 820FDE44h case    3:*/		return 0x820FDE48;
		  /* 820FDE48h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820FDE48h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FDE48h case    4:*/		return 0x820FDE4C;
		  /* 820FDE4Ch */ case    5:  		/* bc 12, CR6_LT, -60 */
		/* 820FDE4Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x820FDE10;  }
		/* 820FDE4Ch case    5:*/		return 0x820FDE50;
		  /* 820FDE50h */ case    6:  		/* li R3, 1 */
		/* 820FDE50h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FDE50h case    6:*/		return 0x820FDE54;
		  /* 820FDE54h */ case    7:  		/* bclr 12, CR6_GT */
		/* 820FDE54h case    7:*/		if ( regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 820FDE54h case    7:*/		return 0x820FDE58;
	}
	return 0x820FDE58;
} // Block from 820FDE38h-820FDE58h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820FDE58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDE58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDE58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDE58);
		  /* 820FDE58h */ case    0:  		/* li R3, 0 */
		/* 820FDE58h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FDE58h case    0:*/		return 0x820FDE5C;
		  /* 820FDE5Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 820FDE5Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FDE5Ch case    1:*/		return 0x820FDE60;
	}
	return 0x820FDE60;
} // Block from 820FDE58h-820FDE60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FDE60h
// Function '?AddInstruction@CBaseProgram@D3DXShader@@QAAIKII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDE60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDE60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDE60);
		  /* 820FDE60h */ case    0:  		/* lwz R11, <#[R5 + 20]> */
		/* 820FDE60h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000014) );
		/* 820FDE60h case    0:*/		return 0x820FDE64;
		  /* 820FDE64h */ case    1:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820FDE64h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820FDE64h case    1:*/		return 0x820FDE68;
		  /* 820FDE68h */ case    2:  		/* rlwinm R9, R4, 2, 0, 29 */
		/* 820FDE68h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R4);
		/* 820FDE68h case    2:*/		return 0x820FDE6C;
		  /* 820FDE6Ch */ case    3:  		/* lwzx R10, <#[R10 + R11]> */
		/* 820FDE6Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820FDE6Ch case    3:*/		return 0x820FDE70;
		  /* 820FDE70h */ case    4:  		/* lwzx R9, <#[R9 + R11]> */
		/* 820FDE70h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820FDE70h case    4:*/		return 0x820FDE74;
		  /* 820FDE74h */ case    5:  		/* lwz R11, <#[R10 + 64]> */
		/* 820FDE74h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000040) );
		/* 820FDE74h case    5:*/		return 0x820FDE78;
		  /* 820FDE78h */ case    6:  		/* lwz R10, <#[R9 + 64]> */
		/* 820FDE78h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000040) );
		/* 820FDE78h case    6:*/		return 0x820FDE7C;
		  /* 820FDE7Ch */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820FDE7Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FDE7Ch case    7:*/		return 0x820FDE80;
		  /* 820FDE80h */ case    8:  		/* bc 4, CR6_LT, 12 */
		/* 820FDE80h case    8:*/		if ( !regs.CR[6].lt ) { return 0x820FDE8C;  }
		/* 820FDE80h case    8:*/		return 0x820FDE84;
		  /* 820FDE84h */ case    9:  		/* li R3, -1 */
		/* 820FDE84h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820FDE84h case    9:*/		return 0x820FDE88;
		  /* 820FDE88h */ case   10:  		/* bclr 20, CR0_LT */
		/* 820FDE88h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FDE88h case   10:*/		return 0x820FDE8C;
	}
	return 0x820FDE8C;
} // Block from 820FDE60h-820FDE8Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FDE8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDE8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDE8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDE8C);
		  /* 820FDE8Ch */ case    0:  		/* subfc R11, R11, R10 */
		/* 820FDE8Ch case    0:*/		cpu::op::subfc<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820FDE8Ch case    0:*/		return 0x820FDE90;
		  /* 820FDE90h */ case    1:  		/* subfe R11, R11, R11 */
		/* 820FDE90h case    1:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820FDE90h case    1:*/		return 0x820FDE94;
		  /* 820FDE94h */ case    2:  		/* rlwinm R3, R11, 0, 31, 31 */
		/* 820FDE94h case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R3,regs.R11);
		/* 820FDE94h case    2:*/		return 0x820FDE98;
		  /* 820FDE98h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820FDE98h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FDE98h case    3:*/		return 0x820FDE9C;
	}
	return 0x820FDE9C;
} // Block from 820FDE8Ch-820FDE9Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FDE9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDE9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDE9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDE9C);
		  /* 820FDE9Ch */ case    0:  		/* nop */
		/* 820FDE9Ch case    0:*/		cpu::op::nop();
		/* 820FDE9Ch case    0:*/		return 0x820FDEA0;
	}
	return 0x820FDEA0;
} // Block from 820FDE9Ch-820FDEA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FDEA0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDEA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDEA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDEA0);
		  /* 820FDEA0h */ case    0:  		/* mfspr R12, LR */
		/* 820FDEA0h case    0:*/		regs.R12 = regs.LR;
		/* 820FDEA0h case    0:*/		return 0x820FDEA4;
		  /* 820FDEA4h */ case    1:  		/* bl -445552 */
		/* 820FDEA4h case    1:*/		regs.LR = 0x820FDEA8; return 0x82091234;
		/* 820FDEA4h case    1:*/		return 0x820FDEA8;
		  /* 820FDEA8h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 820FDEA8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 820FDEA8h case    2:*/		return 0x820FDEAC;
		  /* 820FDEACh */ case    3:  		/* mr R20, R3 */
		/* 820FDEACh case    3:*/		regs.R20 = regs.R3;
		/* 820FDEACh case    3:*/		return 0x820FDEB0;
		  /* 820FDEB0h */ case    4:  		/* mr R29, R4 */
		/* 820FDEB0h case    4:*/		regs.R29 = regs.R4;
		/* 820FDEB0h case    4:*/		return 0x820FDEB4;
		  /* 820FDEB4h */ case    5:  		/* mr R25, R5 */
		/* 820FDEB4h case    5:*/		regs.R25 = regs.R5;
		/* 820FDEB4h case    5:*/		return 0x820FDEB8;
		  /* 820FDEB8h */ case    6:  		/* mr R19, R6 */
		/* 820FDEB8h case    6:*/		regs.R19 = regs.R6;
		/* 820FDEB8h case    6:*/		return 0x820FDEBC;
		  /* 820FDEBCh */ case    7:  		/* cmplwi CR6, R5, 1 */
		/* 820FDEBCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000001);
		/* 820FDEBCh case    7:*/		return 0x820FDEC0;
		  /* 820FDEC0h */ case    8:  		/* bc 4, CR6_GT, 392 */
		/* 820FDEC0h case    8:*/		if ( !regs.CR[6].gt ) { return 0x820FE048;  }
		/* 820FDEC0h case    8:*/		return 0x820FDEC4;
		  /* 820FDEC4h */ case    9:  		/* rlwinm. R28, R5, 31, 1, 31 */
		/* 820FDEC4h case    9:*/		cpu::op::rlwinm<1,31,1,31>(regs,&regs.R28,regs.R5);
		/* 820FDEC4h case    9:*/		return 0x820FDEC8;
		  /* 820FDEC8h */ case   10:  		/* bc 12, CR0_EQ, 192 */
		/* 820FDEC8h case   10:*/		if ( regs.CR[0].eq ) { return 0x820FDF88;  }
		/* 820FDEC8h case   10:*/		return 0x820FDECC;
		  /* 820FDECCh */ case   11:  		/* rlwinm R11, R28, 2, 0, 29 */
		/* 820FDECCh case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R28);
		/* 820FDECCh case   11:*/		return 0x820FDED0;
		  /* 820FDED0h */ case   12:  		/* rlwinm R10, R28, 1, 0, 30 */
		/* 820FDED0h case   12:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R28);
		/* 820FDED0h case   12:*/		return 0x820FDED4;
		  /* 820FDED4h */ case   13:  		/* add R21, R11, R4 */
		/* 820FDED4h case   13:*/		cpu::op::add<0>(regs,&regs.R21,regs.R11,regs.R4);
		/* 820FDED4h case   13:*/		return 0x820FDED8;
		  /* 820FDED8h */ case   14:  		/* addi R24, R10, 1 */
		/* 820FDED8h case   14:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R10,0x1);
		/* 820FDED8h case   14:*/		return 0x820FDEDC;
		  /* 820FDEDCh */ case   15:  		/* addi R24, R24, -2 */
		/* 820FDEDCh case   15:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0xFFFFFFFE);
		/* 820FDEDCh case   15:*/		return 0x820FDEE0;
		  /* 820FDEE0h */ case   16:  		/* lwzu R22, <#[R21 - 4]> */
		/* 820FDEE0h case   16:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R21 + 0xFFFFFFFC) );
		regs.R21 = (uint32)(regs.R21 + 0xFFFFFFFC);
		/* 820FDEE0h case   16:*/		return 0x820FDEE4;
		  /* 820FDEE4h */ case   17:  		/* addi R28, R28, -1 */
		/* 820FDEE4h case   17:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0xFFFFFFFF);
		/* 820FDEE4h case   17:*/		return 0x820FDEE8;
		  /* 820FDEE8h */ case   18:  		/* mr R31, R24 */
		/* 820FDEE8h case   18:*/		regs.R31 = regs.R24;
		/* 820FDEE8h case   18:*/		return 0x820FDEEC;
		  /* 820FDEECh */ case   19:  		/* mr R23, R28 */
		/* 820FDEECh case   19:*/		regs.R23 = regs.R28;
		/* 820FDEECh case   19:*/		return 0x820FDEF0;
		  /* 820FDEF0h */ case   20:  		/* cmplw CR6, R24, R25 */
		/* 820FDEF0h case   20:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R25);
		/* 820FDEF0h case   20:*/		return 0x820FDEF4;
		  /* 820FDEF4h */ case   21:  		/* bc 4, CR6_LT, 132 */
		/* 820FDEF4h case   21:*/		if ( !regs.CR[6].lt ) { return 0x820FDF78;  }
		/* 820FDEF4h case   21:*/		return 0x820FDEF8;
	}
	return 0x820FDEF8;
} // Block from 820FDEA0h-820FDEF8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820FDEF8h
// Function '?CopyPool@CBaseProgram@D3DXShader@@QAAIPAVCPool@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDEF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDEF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDEF8);
		  /* 820FDEF8h */ case    0:  		/* rlwinm R11, R31, 2, 0, 29 */
		/* 820FDEF8h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R31);
		/* 820FDEF8h case    0:*/		return 0x820FDEFC;
		  /* 820FDEFCh */ case    1:  		/* addi R26, R31, 1 */
		/* 820FDEFCh case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R31,0x1);
		/* 820FDEFCh case    1:*/		return 0x820FDF00;
		  /* 820FDF00h */ case    2:  		/* add R11, R11, R29 */
		/* 820FDF00h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 820FDF00h case    2:*/		return 0x820FDF04;
		  /* 820FDF04h */ case    3:  		/* cmplw CR6, R26, R25 */
		/* 820FDF04h case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R25);
		/* 820FDF04h case    3:*/		return 0x820FDF08;
		  /* 820FDF08h */ case    4:  		/* lwz R30, <#[R11]> */
		/* 820FDF08h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 820FDF08h case    4:*/		return 0x820FDF0C;
		  /* 820FDF0Ch */ case    5:  		/* bc 4, CR6_LT, 44 */
		/* 820FDF0Ch case    5:*/		if ( !regs.CR[6].lt ) { return 0x820FDF38;  }
		/* 820FDF0Ch case    5:*/		return 0x820FDF10;
		  /* 820FDF10h */ case    6:  		/* lwz R27, <#[R11 + 4]> */
		/* 820FDF10h case    6:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000004) );
		/* 820FDF10h case    6:*/		return 0x820FDF14;
		  /* 820FDF14h */ case    7:  		/* mr R5, R19 */
		/* 820FDF14h case    7:*/		regs.R5 = regs.R19;
		/* 820FDF14h case    7:*/		return 0x820FDF18;
		  /* 820FDF18h */ case    8:  		/* mr R4, R30 */
		/* 820FDF18h case    8:*/		regs.R4 = regs.R30;
		/* 820FDF18h case    8:*/		return 0x820FDF1C;
		  /* 820FDF1Ch */ case    9:  		/* mtspr CTR, R20 */
		/* 820FDF1Ch case    9:*/		regs.CTR = regs.R20;
		/* 820FDF1Ch case    9:*/		return 0x820FDF20;
		  /* 820FDF20h */ case   10:  		/* mr R3, R27 */
		/* 820FDF20h case   10:*/		regs.R3 = regs.R27;
		/* 820FDF20h case   10:*/		return 0x820FDF24;
		  /* 820FDF24h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 820FDF24h case   11:*/		if ( 1 ) { regs.LR = 0x820FDF28; return (uint32)regs.CTR; }
		/* 820FDF24h case   11:*/		return 0x820FDF28;
		  /* 820FDF28h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820FDF28h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FDF28h case   12:*/		return 0x820FDF2C;
		  /* 820FDF2Ch */ case   13:  		/* bc 4, CR0_GT, 12 */
		/* 820FDF2Ch case   13:*/		if ( !regs.CR[0].gt ) { return 0x820FDF38;  }
		/* 820FDF2Ch case   13:*/		return 0x820FDF30;
		  /* 820FDF30h */ case   14:  		/* mr R31, R26 */
		/* 820FDF30h case   14:*/		regs.R31 = regs.R26;
		/* 820FDF30h case   14:*/		return 0x820FDF34;
		  /* 820FDF34h */ case   15:  		/* mr R30, R27 */
		/* 820FDF34h case   15:*/		regs.R30 = regs.R27;
		/* 820FDF34h case   15:*/		return 0x820FDF38;
	}
	return 0x820FDF38;
} // Block from 820FDEF8h-820FDF38h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820FDF38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDF38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDF38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDF38);
		  /* 820FDF38h */ case    0:  		/* mr R5, R19 */
		/* 820FDF38h case    0:*/		regs.R5 = regs.R19;
		/* 820FDF38h case    0:*/		return 0x820FDF3C;
		  /* 820FDF3Ch */ case    1:  		/* mtspr CTR, R20 */
		/* 820FDF3Ch case    1:*/		regs.CTR = regs.R20;
		/* 820FDF3Ch case    1:*/		return 0x820FDF40;
		  /* 820FDF40h */ case    2:  		/* mr R4, R22 */
		/* 820FDF40h case    2:*/		regs.R4 = regs.R22;
		/* 820FDF40h case    2:*/		return 0x820FDF44;
		  /* 820FDF44h */ case    3:  		/* mr R3, R30 */
		/* 820FDF44h case    3:*/		regs.R3 = regs.R30;
		/* 820FDF44h case    3:*/		return 0x820FDF48;
		  /* 820FDF48h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 820FDF48h case    4:*/		if ( 1 ) { regs.LR = 0x820FDF4C; return (uint32)regs.CTR; }
		/* 820FDF48h case    4:*/		return 0x820FDF4C;
		  /* 820FDF4Ch */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820FDF4Ch case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FDF4Ch case    5:*/		return 0x820FDF50;
		  /* 820FDF50h */ case    6:  		/* bc 4, CR0_GT, 40 */
		/* 820FDF50h case    6:*/		if ( !regs.CR[0].gt ) { return 0x820FDF78;  }
		/* 820FDF50h case    6:*/		return 0x820FDF54;
		  /* 820FDF54h */ case    7:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 820FDF54h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 820FDF54h case    7:*/		return 0x820FDF58;
		  /* 820FDF58h */ case    8:  		/* rlwinm R11, R31, 1, 0, 30 */
		/* 820FDF58h case    8:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R31);
		/* 820FDF58h case    8:*/		return 0x820FDF5C;
		  /* 820FDF5Ch */ case    9:  		/* rlwinm R9, R23, 2, 0, 29 */
		/* 820FDF5Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R23);
		/* 820FDF5Ch case    9:*/		return 0x820FDF60;
		  /* 820FDF60h */ case   10:  		/* mr R23, R31 */
		/* 820FDF60h case   10:*/		regs.R23 = regs.R31;
		/* 820FDF60h case   10:*/		return 0x820FDF64;
		  /* 820FDF64h */ case   11:  		/* addi R31, R11, 1 */
		/* 820FDF64h case   11:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x1);
		/* 820FDF64h case   11:*/		return 0x820FDF68;
		  /* 820FDF68h */ case   12:  		/* lwzx R11, <#[R10 + R29]> */
		/* 820FDF68h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 820FDF68h case   12:*/		return 0x820FDF6C;
		  /* 820FDF6Ch */ case   13:  		/* cmplw CR6, R31, R25 */
		/* 820FDF6Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R25);
		/* 820FDF6Ch case   13:*/		return 0x820FDF70;
		  /* 820FDF70h */ case   14:  		/* stwx R11, <#[R9 + R29]> */
		/* 820FDF70h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + regs.R29 + 0x00000000) );
		/* 820FDF70h case   14:*/		return 0x820FDF74;
		  /* 820FDF74h */ case   15:  		/* bc 12, CR6_LT, -124 */
		/* 820FDF74h case   15:*/		if ( regs.CR[6].lt ) { return 0x820FDEF8;  }
		/* 820FDF74h case   15:*/		return 0x820FDF78;
	}
	return 0x820FDF78;
} // Block from 820FDF38h-820FDF78h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820FDF78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDF78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDF78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDF78);
		  /* 820FDF78h */ case    0:  		/* rlwinm R11, R23, 2, 0, 29 */
		/* 820FDF78h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R23);
		/* 820FDF78h case    0:*/		return 0x820FDF7C;
		  /* 820FDF7Ch */ case    1:  		/* cmplwi CR6, R28, 0 */
		/* 820FDF7Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820FDF7Ch case    1:*/		return 0x820FDF80;
	}
	return 0x820FDF80;
} // Block from 820FDF78h-820FDF80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FDF80h
// Function '?CopyArgument@CBaseProgram@D3DXShader@@QAAIPAVCArgument@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDF80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDF80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDF80);
		  /* 820FDF80h */ case    0:  		/* stwx R22, <#[R11 + R29]> */
		/* 820FDF80h case    0:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 820FDF80h case    0:*/		return 0x820FDF84;
		  /* 820FDF84h */ case    1:  		/* bc 4, CR6_EQ, -168 */
		/* 820FDF84h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820FDEDC;  }
		/* 820FDF84h case    1:*/		return 0x820FDF88;
	}
	return 0x820FDF88;
} // Block from 820FDF80h-820FDF88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FDF88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDF88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDF88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDF88);
		  /* 820FDF88h */ case    0:  		/* addic. R30, R25, -1 */
		/* 820FDF88h case    0:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R25,0xFFFFFFFF);
		/* 820FDF88h case    0:*/		return 0x820FDF8C;
		  /* 820FDF8Ch */ case    1:  		/* bc 12, CR0_EQ, 188 */
		/* 820FDF8Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820FE048;  }
		/* 820FDF8Ch case    1:*/		return 0x820FDF90;
		  /* 820FDF90h */ case    2:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 820FDF90h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 820FDF90h case    2:*/		return 0x820FDF94;
		  /* 820FDF94h */ case    3:  		/* add R25, R11, R29 */
		/* 820FDF94h case    3:*/		cpu::op::add<0>(regs,&regs.R25,regs.R11,regs.R29);
		/* 820FDF94h case    3:*/		return 0x820FDF98;
		  /* 820FDF98h */ case    4:  		/* lwz R11, <#[R29]> */
		/* 820FDF98h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820FDF98h case    4:*/		return 0x820FDF9C;
		  /* 820FDF9Ch */ case    5:  		/* li R24, 0 */
		/* 820FDF9Ch case    5:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 820FDF9Ch case    5:*/		return 0x820FDFA0;
		  /* 820FDFA0h */ case    6:  		/* lwz R23, <#[R25]> */
		/* 820FDFA0h case    6:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R25 + 0x00000000) );
		/* 820FDFA0h case    6:*/		return 0x820FDFA4;
		  /* 820FDFA4h */ case    7:  		/* li R31, 1 */
		/* 820FDFA4h case    7:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 820FDFA4h case    7:*/		return 0x820FDFA8;
		  /* 820FDFA8h */ case    8:  		/* cmplwi CR6, R30, 1 */
		/* 820FDFA8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000001);
		/* 820FDFA8h case    8:*/		return 0x820FDFAC;
		  /* 820FDFACh */ case    9:  		/* stw R11, <#[R25]> */
		/* 820FDFACh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820FDFACh case    9:*/		return 0x820FDFB0;
		  /* 820FDFB0h */ case   10:  		/* bc 4, CR6_GT, 132 */
		/* 820FDFB0h case   10:*/		if ( !regs.CR[6].gt ) { return 0x820FE034;  }
		/* 820FDFB0h case   10:*/		return 0x820FDFB4;
		  /* 820FDFB4h */ case   11:  		/* rlwinm R11, R31, 2, 0, 29 */
		/* 820FDFB4h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R31);
		/* 820FDFB4h case   11:*/		return 0x820FDFB8;
		  /* 820FDFB8h */ case   12:  		/* addi R26, R31, 1 */
		/* 820FDFB8h case   12:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R31,0x1);
		/* 820FDFB8h case   12:*/		return 0x820FDFBC;
		  /* 820FDFBCh */ case   13:  		/* add R11, R11, R29 */
		/* 820FDFBCh case   13:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 820FDFBCh case   13:*/		return 0x820FDFC0;
		  /* 820FDFC0h */ case   14:  		/* cmplw CR6, R26, R30 */
		/* 820FDFC0h case   14:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R30);
		/* 820FDFC0h case   14:*/		return 0x820FDFC4;
		  /* 820FDFC4h */ case   15:  		/* lwz R28, <#[R11]> */
		/* 820FDFC4h case   15:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 820FDFC4h case   15:*/		return 0x820FDFC8;
		  /* 820FDFC8h */ case   16:  		/* bc 4, CR6_LT, 44 */
		/* 820FDFC8h case   16:*/		if ( !regs.CR[6].lt ) { return 0x820FDFF4;  }
		/* 820FDFC8h case   16:*/		return 0x820FDFCC;
		  /* 820FDFCCh */ case   17:  		/* lwz R27, <#[R11 + 4]> */
		/* 820FDFCCh case   17:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000004) );
		/* 820FDFCCh case   17:*/		return 0x820FDFD0;
		  /* 820FDFD0h */ case   18:  		/* mr R5, R19 */
		/* 820FDFD0h case   18:*/		regs.R5 = regs.R19;
		/* 820FDFD0h case   18:*/		return 0x820FDFD4;
		  /* 820FDFD4h */ case   19:  		/* mr R4, R28 */
		/* 820FDFD4h case   19:*/		regs.R4 = regs.R28;
		/* 820FDFD4h case   19:*/		return 0x820FDFD8;
		  /* 820FDFD8h */ case   20:  		/* mtspr CTR, R20 */
		/* 820FDFD8h case   20:*/		regs.CTR = regs.R20;
		/* 820FDFD8h case   20:*/		return 0x820FDFDC;
		  /* 820FDFDCh */ case   21:  		/* mr R3, R27 */
		/* 820FDFDCh case   21:*/		regs.R3 = regs.R27;
		/* 820FDFDCh case   21:*/		return 0x820FDFE0;
		  /* 820FDFE0h */ case   22:  		/* bcctrl 20, CR0_LT */
		/* 820FDFE0h case   22:*/		if ( 1 ) { regs.LR = 0x820FDFE4; return (uint32)regs.CTR; }
		/* 820FDFE0h case   22:*/		return 0x820FDFE4;
		  /* 820FDFE4h */ case   23:  		/* cmpwi CR0, R3, 0 */
		/* 820FDFE4h case   23:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FDFE4h case   23:*/		return 0x820FDFE8;
		  /* 820FDFE8h */ case   24:  		/* bc 4, CR0_GT, 12 */
		/* 820FDFE8h case   24:*/		if ( !regs.CR[0].gt ) { return 0x820FDFF4;  }
		/* 820FDFE8h case   24:*/		return 0x820FDFEC;
		  /* 820FDFECh */ case   25:  		/* mr R31, R26 */
		/* 820FDFECh case   25:*/		regs.R31 = regs.R26;
		/* 820FDFECh case   25:*/		return 0x820FDFF0;
		  /* 820FDFF0h */ case   26:  		/* mr R28, R27 */
		/* 820FDFF0h case   26:*/		regs.R28 = regs.R27;
		/* 820FDFF0h case   26:*/		return 0x820FDFF4;
	}
	return 0x820FDFF4;
} // Block from 820FDF88h-820FDFF4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820FDFF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FDFF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FDFF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FDFF4);
		  /* 820FDFF4h */ case    0:  		/* mr R5, R19 */
		/* 820FDFF4h case    0:*/		regs.R5 = regs.R19;
		/* 820FDFF4h case    0:*/		return 0x820FDFF8;
		  /* 820FDFF8h */ case    1:  		/* mtspr CTR, R20 */
		/* 820FDFF8h case    1:*/		regs.CTR = regs.R20;
		/* 820FDFF8h case    1:*/		return 0x820FDFFC;
		  /* 820FDFFCh */ case    2:  		/* mr R4, R23 */
		/* 820FDFFCh case    2:*/		regs.R4 = regs.R23;
		/* 820FDFFCh case    2:*/		return 0x820FE000;
	}
	return 0x820FE000;
} // Block from 820FDFF4h-820FE000h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FE000h
// Function '?CopyInstruction@CBaseProgram@D3DXShader@@QAAIPAVCInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE000);
		  /* 820FE000h */ case    0:  		/* mr R3, R28 */
		/* 820FE000h case    0:*/		regs.R3 = regs.R28;
		/* 820FE000h case    0:*/		return 0x820FE004;
		  /* 820FE004h */ case    1:  		/* bcctrl 20, CR0_LT */
		/* 820FE004h case    1:*/		if ( 1 ) { regs.LR = 0x820FE008; return (uint32)regs.CTR; }
		/* 820FE004h case    1:*/		return 0x820FE008;
		  /* 820FE008h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820FE008h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FE008h case    2:*/		return 0x820FE00C;
		  /* 820FE00Ch */ case    3:  		/* bc 4, CR0_GT, 40 */
		/* 820FE00Ch case    3:*/		if ( !regs.CR[0].gt ) { return 0x820FE034;  }
		/* 820FE00Ch case    3:*/		return 0x820FE010;
		  /* 820FE010h */ case    4:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 820FE010h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 820FE010h case    4:*/		return 0x820FE014;
		  /* 820FE014h */ case    5:  		/* rlwinm R11, R31, 1, 0, 30 */
		/* 820FE014h case    5:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R31);
		/* 820FE014h case    5:*/		return 0x820FE018;
		  /* 820FE018h */ case    6:  		/* rlwinm R9, R24, 2, 0, 29 */
		/* 820FE018h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R24);
		/* 820FE018h case    6:*/		return 0x820FE01C;
		  /* 820FE01Ch */ case    7:  		/* mr R24, R31 */
		/* 820FE01Ch case    7:*/		regs.R24 = regs.R31;
		/* 820FE01Ch case    7:*/		return 0x820FE020;
		  /* 820FE020h */ case    8:  		/* addi R31, R11, 1 */
		/* 820FE020h case    8:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x1);
		/* 820FE020h case    8:*/		return 0x820FE024;
		  /* 820FE024h */ case    9:  		/* lwzx R11, <#[R10 + R29]> */
		/* 820FE024h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 820FE024h case    9:*/		return 0x820FE028;
		  /* 820FE028h */ case   10:  		/* cmplw CR6, R31, R30 */
		/* 820FE028h case   10:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 820FE028h case   10:*/		return 0x820FE02C;
		  /* 820FE02Ch */ case   11:  		/* stwx R11, <#[R9 + R29]> */
		/* 820FE02Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + regs.R29 + 0x00000000) );
		/* 820FE02Ch case   11:*/		return 0x820FE030;
		  /* 820FE030h */ case   12:  		/* bc 12, CR6_LT, -124 */
		/* 820FE030h case   12:*/		if ( regs.CR[6].lt ) { return 0x820FDFB4;  }
		/* 820FE030h case   12:*/		return 0x820FE034;
	}
	return 0x820FE034;
} // Block from 820FE000h-820FE034h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FE034h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE034( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE034) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE034);
		  /* 820FE034h */ case    0:  		/* rlwinm R11, R24, 2, 0, 29 */
		/* 820FE034h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R24);
		/* 820FE034h case    0:*/		return 0x820FE038;
		  /* 820FE038h */ case    1:  		/* addic. R30, R30, -1 */
		/* 820FE038h case    1:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 820FE038h case    1:*/		return 0x820FE03C;
		  /* 820FE03Ch */ case    2:  		/* addi R25, R25, -4 */
		/* 820FE03Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0xFFFFFFFC);
		/* 820FE03Ch case    2:*/		return 0x820FE040;
		  /* 820FE040h */ case    3:  		/* stwx R23, <#[R11 + R29]> */
		/* 820FE040h case    3:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 820FE040h case    3:*/		return 0x820FE044;
		  /* 820FE044h */ case    4:  		/* bc 4, CR0_EQ, -172 */
		/* 820FE044h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820FDF98;  }
		/* 820FE044h case    4:*/		return 0x820FE048;
	}
	return 0x820FE048;
} // Block from 820FE034h-820FE048h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FE048h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE048( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE048) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE048);
		  /* 820FE048h */ case    0:  		/* addi R1, R1, 192 */
		/* 820FE048h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 820FE048h case    0:*/		return 0x820FE04C;
		  /* 820FE04Ch */ case    1:  		/* b -445896 */
		/* 820FE04Ch case    1:*/		return 0x82091284;
		/* 820FE04Ch case    1:*/		return 0x820FE050;
	}
	return 0x820FE050;
} // Block from 820FE048h-820FE050h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FE050h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE050);
		  /* 820FE050h */ case    0:  		/* mfspr R12, LR */
		/* 820FE050h case    0:*/		regs.R12 = regs.LR;
		/* 820FE050h case    0:*/		return 0x820FE054;
		  /* 820FE054h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820FE054h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FE054h case    1:*/		return 0x820FE058;
		  /* 820FE058h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820FE058h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820FE058h case    2:*/		return 0x820FE05C;
		  /* 820FE05Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820FE05Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FE05Ch case    3:*/		return 0x820FE060;
		  /* 820FE060h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820FE060h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820FE060h case    4:*/		return 0x820FE064;
		  /* 820FE064h */ case    5:  		/* mr R31, R3 */
		/* 820FE064h case    5:*/		regs.R31 = regs.R3;
		/* 820FE064h case    5:*/		return 0x820FE068;
		  /* 820FE068h */ case    6:  		/* mr R30, R4 */
		/* 820FE068h case    6:*/		regs.R30 = regs.R4;
		/* 820FE068h case    6:*/		return 0x820FE06C;
		  /* 820FE06Ch */ case    7:  		/* bl -4780 */
		/* 820FE06Ch case    7:*/		regs.LR = 0x820FE070; return 0x820FCDC0;
		/* 820FE06Ch case    7:*/		return 0x820FE070;
		  /* 820FE070h */ case    8:  		/* lis R9, -32254 */
		/* 820FE070h case    8:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8202);
		/* 820FE070h case    8:*/		return 0x820FE074;
		  /* 820FE074h */ case    9:  		/* stw R30, <#[R31 + 224]> */
		/* 820FE074h case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x000000E0) );
		/* 820FE074h case    9:*/		return 0x820FE078;
		  /* 820FE078h */ case   10:  		/* li R11, -1 */
		/* 820FE078h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820FE078h case   10:*/		return 0x820FE07C;
		  /* 820FE07Ch */ case   11:  		/* li R10, 0 */
		/* 820FE07Ch case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820FE07Ch case   11:*/		return 0x820FE080;
	}
	return 0x820FE080;
} // Block from 820FE050h-820FE080h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820FE080h
// Function '??1CBaseProgram@D3DXShader@@UAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE080);
		  /* 820FE080h */ case    0:  		/* addi R9, R9, -14372 */
		/* 820FE080h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFC7DC);
		/* 820FE080h case    0:*/		return 0x820FE084;
		  /* 820FE084h */ case    1:  		/* stw R11, <#[R31 + 116]> */
		/* 820FE084h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000074) );
		/* 820FE084h case    1:*/		return 0x820FE088;
		  /* 820FE088h */ case    2:  		/* stw R10, <#[R31 + 192]> */
		/* 820FE088h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x000000C0) );
		/* 820FE088h case    2:*/		return 0x820FE08C;
		  /* 820FE08Ch */ case    3:  		/* mr R3, R31 */
		/* 820FE08Ch case    3:*/		regs.R3 = regs.R31;
		/* 820FE08Ch case    3:*/		return 0x820FE090;
		  /* 820FE090h */ case    4:  		/* stw R9, <#[R31]> */
		/* 820FE090h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 820FE090h case    4:*/		return 0x820FE094;
		  /* 820FE094h */ case    5:  		/* stw R10, <#[R31 + 196]> */
		/* 820FE094h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x000000C4) );
		/* 820FE094h case    5:*/		return 0x820FE098;
		  /* 820FE098h */ case    6:  		/* stw R10, <#[R31 + 200]> */
		/* 820FE098h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x000000C8) );
		/* 820FE098h case    6:*/		return 0x820FE09C;
		  /* 820FE09Ch */ case    7:  		/* stw R10, <#[R31 + 204]> */
		/* 820FE09Ch case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x000000CC) );
		/* 820FE09Ch case    7:*/		return 0x820FE0A0;
		  /* 820FE0A0h */ case    8:  		/* stw R10, <#[R31 + 208]> */
		/* 820FE0A0h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x000000D0) );
		/* 820FE0A0h case    8:*/		return 0x820FE0A4;
		  /* 820FE0A4h */ case    9:  		/* stw R10, <#[R31 + 228]> */
		/* 820FE0A4h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x000000E4) );
		/* 820FE0A4h case    9:*/		return 0x820FE0A8;
		  /* 820FE0A8h */ case   10:  		/* stw R10, <#[R31 + 216]> */
		/* 820FE0A8h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x000000D8) );
		/* 820FE0A8h case   10:*/		return 0x820FE0AC;
		  /* 820FE0ACh */ case   11:  		/* stw R10, <#[R31 + 220]> */
		/* 820FE0ACh case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x000000DC) );
		/* 820FE0ACh case   11:*/		return 0x820FE0B0;
		  /* 820FE0B0h */ case   12:  		/* stw R11, <#[R31 + 120]> */
		/* 820FE0B0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000078) );
		/* 820FE0B0h case   12:*/		return 0x820FE0B4;
		  /* 820FE0B4h */ case   13:  		/* stw R11, <#[R31 + 124]> */
		/* 820FE0B4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000007C) );
		/* 820FE0B4h case   13:*/		return 0x820FE0B8;
		  /* 820FE0B8h */ case   14:  		/* stw R11, <#[R31 + 128]> */
		/* 820FE0B8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000080) );
		/* 820FE0B8h case   14:*/		return 0x820FE0BC;
		  /* 820FE0BCh */ case   15:  		/* stw R11, <#[R31 + 132]> */
		/* 820FE0BCh case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 820FE0BCh case   15:*/		return 0x820FE0C0;
		  /* 820FE0C0h */ case   16:  		/* stw R11, <#[R31 + 136]> */
		/* 820FE0C0h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000088) );
		/* 820FE0C0h case   16:*/		return 0x820FE0C4;
		  /* 820FE0C4h */ case   17:  		/* stw R11, <#[R31 + 140]> */
		/* 820FE0C4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000008C) );
		/* 820FE0C4h case   17:*/		return 0x820FE0C8;
		  /* 820FE0C8h */ case   18:  		/* stw R11, <#[R31 + 144]> */
		/* 820FE0C8h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000090) );
		/* 820FE0C8h case   18:*/		return 0x820FE0CC;
		  /* 820FE0CCh */ case   19:  		/* stw R11, <#[R31 + 148]> */
		/* 820FE0CCh case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000094) );
		/* 820FE0CCh case   19:*/		return 0x820FE0D0;
		  /* 820FE0D0h */ case   20:  		/* stw R11, <#[R31 + 152]> */
		/* 820FE0D0h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000098) );
		/* 820FE0D0h case   20:*/		return 0x820FE0D4;
		  /* 820FE0D4h */ case   21:  		/* stw R11, <#[R31 + 156]> */
		/* 820FE0D4h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000009C) );
		/* 820FE0D4h case   21:*/		return 0x820FE0D8;
		  /* 820FE0D8h */ case   22:  		/* stw R11, <#[R31 + 160]> */
		/* 820FE0D8h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000A0) );
		/* 820FE0D8h case   22:*/		return 0x820FE0DC;
		  /* 820FE0DCh */ case   23:  		/* stw R11, <#[R31 + 168]> */
		/* 820FE0DCh case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000A8) );
		/* 820FE0DCh case   23:*/		return 0x820FE0E0;
		  /* 820FE0E0h */ case   24:  		/* stw R11, <#[R31 + 172]> */
		/* 820FE0E0h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000AC) );
		/* 820FE0E0h case   24:*/		return 0x820FE0E4;
		  /* 820FE0E4h */ case   25:  		/* stw R11, <#[R31 + 176]> */
		/* 820FE0E4h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000B0) );
		/* 820FE0E4h case   25:*/		return 0x820FE0E8;
		  /* 820FE0E8h */ case   26:  		/* stw R11, <#[R31 + 180]> */
		/* 820FE0E8h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000B4) );
		/* 820FE0E8h case   26:*/		return 0x820FE0EC;
		  /* 820FE0ECh */ case   27:  		/* stw R11, <#[R31 + 184]> */
		/* 820FE0ECh case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000B8) );
		/* 820FE0ECh case   27:*/		return 0x820FE0F0;
		  /* 820FE0F0h */ case   28:  		/* addi R1, R1, 112 */
		/* 820FE0F0h case   28:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820FE0F0h case   28:*/		return 0x820FE0F4;
		  /* 820FE0F4h */ case   29:  		/* lwz R12, <#[R1 - 8]> */
		/* 820FE0F4h case   29:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FE0F4h case   29:*/		return 0x820FE0F8;
		  /* 820FE0F8h */ case   30:  		/* mtspr LR, R12 */
		/* 820FE0F8h case   30:*/		regs.LR = regs.R12;
		/* 820FE0F8h case   30:*/		return 0x820FE0FC;
		  /* 820FE0FCh */ case   31:  		/* ld R30, <#[R1 - 24]> */
		/* 820FE0FCh case   31:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820FE0FCh case   31:*/		return 0x820FE100;
		  /* 820FE100h */ case   32:  		/* ld R31, <#[R1 - 16]> */
		/* 820FE100h case   32:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820FE100h case   32:*/		return 0x820FE104;
		  /* 820FE104h */ case   33:  		/* bclr 20, CR0_LT */
		/* 820FE104h case   33:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FE104h case   33:*/		return 0x820FE108;
	}
	return 0x820FE108;
} // Block from 820FE080h-820FE108h (34 instructions)

//////////////////////////////////////////////////////
// Block at 820FE108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE108);
		  /* 820FE108h */ case    0:  		/* li R11, 64 */
		/* 820FE108h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x40);
		/* 820FE108h case    0:*/		return 0x820FE10C;
		  /* 820FE10Ch */ case    1:  		/* lwz R9, <#[R3 + 108]> */
		/* 820FE10Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x0000006C) );
		/* 820FE10Ch case    1:*/		return 0x820FE110;
		  /* 820FE110h */ case    2:  		/* lwz R8, <#[R3 + 112]> */
		/* 820FE110h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000070) );
		/* 820FE110h case    2:*/		return 0x820FE114;
		  /* 820FE114h */ case    3:  		/* mr R10, R3 */
		/* 820FE114h case    3:*/		regs.R10 = regs.R3;
		/* 820FE114h case    3:*/		return 0x820FE118;
		  /* 820FE118h */ case    4:  		/* stw R11, <#[R3 + 40]> */
		/* 820FE118h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 820FE118h case    4:*/		return 0x820FE11C;
		  /* 820FE11Ch */ case    5:  		/* li R7, 0 */
		/* 820FE11Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820FE11Ch case    5:*/		return 0x820FE120;
		  /* 820FE120h */ case    6:  		/* stw R11, <#[R3 + 44]> */
		/* 820FE120h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 820FE120h case    6:*/		return 0x820FE124;
		  /* 820FE124h */ case    7:  		/* li R6, 8192 */
		/* 820FE124h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x2000);
		/* 820FE124h case    7:*/		return 0x820FE128;
		  /* 820FE128h */ case    8:  		/* rlwinm R9, R9, 0, 3, 0 */
		/* 820FE128h case    8:*/		cpu::op::rlwinm<0,0,3,0>(regs,&regs.R9,regs.R9);
		/* 820FE128h case    8:*/		return 0x820FE12C;
		  /* 820FE12Ch */ case    9:  		/* stw R7, <#[R3 + 48]> */
		/* 820FE12Ch case    9:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000030) );
		/* 820FE12Ch case    9:*/		return 0x820FE130;
		  /* 820FE130h */ case   10:  		/* oris R11, R8, 32 */
		/* 820FE130h case   10:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R8,0x20);
		/* 820FE130h case   10:*/		return 0x820FE134;
		  /* 820FE134h */ case   11:  		/* stw R6, <#[R3 + 56]> */
		/* 820FE134h case   11:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000038) );
		/* 820FE134h case   11:*/		return 0x820FE138;
		  /* 820FE138h */ case   12:  		/* li R3, 0 */
		/* 820FE138h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FE138h case   12:*/		return 0x820FE13C;
		  /* 820FE13Ch */ case   13:  		/* stw R9, <#[R10 + 108]> */
		/* 820FE13Ch case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x0000006C) );
		/* 820FE13Ch case   13:*/		return 0x820FE140;
		  /* 820FE140h */ case   14:  		/* stw R11, <#[R10 + 112]> */
		/* 820FE140h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000070) );
		/* 820FE140h case   14:*/		return 0x820FE144;
		  /* 820FE144h */ case   15:  		/* bclr 20, CR0_LT */
		/* 820FE144h case   15:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FE144h case   15:*/		return 0x820FE148;
	}
	return 0x820FE148;
} // Block from 820FE108h-820FE148h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820FE148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE148);
		  /* 820FE148h */ case    0:  		/* lwz R11, <#[R4 + 12]> */
		/* 820FE148h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 820FE148h case    0:*/		return 0x820FE14C;
		  /* 820FE14Ch */ case    1:  		/* cmpwi CR6, R7, 0 */
		/* 820FE14Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 820FE14Ch case    1:*/		return 0x820FE150;
		  /* 820FE150h */ case    2:  		/* bc 12, CR6_EQ, 64 */
		/* 820FE150h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FE190;  }
		/* 820FE150h case    2:*/		return 0x820FE154;
		  /* 820FE154h */ case    3:  		/* add R11, R11, R6 */
		/* 820FE154h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 820FE154h case    3:*/		return 0x820FE158;
		  /* 820FE158h */ case    4:  		/* lwz R9, <#[R4 + 8]> */
		/* 820FE158h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000008) );
		/* 820FE158h case    4:*/		return 0x820FE15C;
		  /* 820FE15Ch */ case    5:  		/* rlwinm R10, R6, 2, 0, 29 */
		/* 820FE15Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R6);
		/* 820FE15Ch case    5:*/		return 0x820FE160;
		  /* 820FE160h */ case    6:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 820FE160h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 820FE160h case    6:*/		return 0x820FE164;
		  /* 820FE164h */ case    7:  		/* cmplwi CR6, R5, 0 */
		/* 820FE164h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820FE164h case    7:*/		return 0x820FE168;
		  /* 820FE168h */ case    8:  		/* lwzx R11, <#[R10 + R9]> */
		/* 820FE168h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820FE168h case    8:*/		return 0x820FE16C;
		  /* 820FE16Ch */ case    9:  		/* lwzx R10, <#[R8 + R9]> */
		/* 820FE16Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 820FE16Ch case    9:*/		return 0x820FE170;
		  /* 820FE170h */ case   10:  		/* bc 12, CR6_EQ, 16 */
		/* 820FE170h case   10:*/		if ( regs.CR[6].eq ) { return 0x820FE180;  }
		/* 820FE170h case   10:*/		return 0x820FE174;
		  /* 820FE174h */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 820FE174h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FE174h case   11:*/		return 0x820FE178;
		  /* 820FE178h */ case   12:  		/* bc 12, CR6_GT, 44 */
		/* 820FE178h case   12:*/		if ( regs.CR[6].gt ) { return 0x820FE1A4;  }
		/* 820FE178h case   12:*/		return 0x820FE17C;
		  /* 820FE17Ch */ case   13:  		/* b 12 */
		/* 820FE17Ch case   13:*/		return 0x820FE188;
		/* 820FE17Ch case   13:*/		return 0x820FE180;
	}
	return 0x820FE180;
} // Block from 820FE148h-820FE180h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820FE180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE180);
		  /* 820FE180h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 820FE180h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FE180h case    0:*/		return 0x820FE184;
		  /* 820FE184h */ case    1:  		/* bc 4, CR6_GT, 32 */
		/* 820FE184h case    1:*/		if ( !regs.CR[6].gt ) { return 0x820FE1A4;  }
		/* 820FE184h case    1:*/		return 0x820FE188;
	}
	return 0x820FE188;
} // Block from 820FE180h-820FE188h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FE188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE188);
		  /* 820FE188h */ case    0:  		/* mr R11, R10 */
		/* 820FE188h case    0:*/		regs.R11 = regs.R10;
		/* 820FE188h case    0:*/		return 0x820FE18C;
		  /* 820FE18Ch */ case    1:  		/* b 24 */
		/* 820FE18Ch case    1:*/		return 0x820FE1A4;
		/* 820FE18Ch case    1:*/		return 0x820FE190;
	}
	return 0x820FE190;
} // Block from 820FE188h-820FE190h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FE190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE190);
		  /* 820FE190h */ case    0:  		/* mullw R11, R11, R5 */
		/* 820FE190h case    0:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 820FE190h case    0:*/		return 0x820FE194;
		  /* 820FE194h */ case    1:  		/* lwz R10, <#[R4 + 8]> */
		/* 820FE194h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 820FE194h case    1:*/		return 0x820FE198;
		  /* 820FE198h */ case    2:  		/* add R11, R11, R6 */
		/* 820FE198h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 820FE198h case    2:*/		return 0x820FE19C;
		  /* 820FE19Ch */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FE19Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FE19Ch case    3:*/		return 0x820FE1A0;
		  /* 820FE1A0h */ case    4:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820FE1A0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FE1A0h case    4:*/		return 0x820FE1A4;
	}
	return 0x820FE1A4;
} // Block from 820FE190h-820FE1A4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FE1A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE1A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE1A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE1A4);
		  /* 820FE1A4h */ case    0:  		/* lwz R9, <#[R3 + 20]> */
		/* 820FE1A4h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 820FE1A4h case    0:*/		return 0x820FE1A8;
		  /* 820FE1A8h */ case    1:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 820FE1A8h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 820FE1A8h case    1:*/		return 0x820FE1AC;
		  /* 820FE1ACh */ case    2:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820FE1ACh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820FE1ACh case    2:*/		return 0x820FE1B0;
		  /* 820FE1B0h */ case    3:  		/* b 16 */
		/* 820FE1B0h case    3:*/		return 0x820FE1C0;
		/* 820FE1B0h case    3:*/		return 0x820FE1B4;
		  /* 820FE1B4h */ case    4:  		/* rlwinm R8, R10, 2, 0, 29 */
		/* 820FE1B4h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R10);
		/* 820FE1B4h case    4:*/		return 0x820FE1B8;
		  /* 820FE1B8h */ case    5:  		/* mr R11, R10 */
		/* 820FE1B8h case    5:*/		regs.R11 = regs.R10;
		/* 820FE1B8h case    5:*/		return 0x820FE1BC;
		  /* 820FE1BCh */ case    6:  		/* lwzx R10, <#[R8 + R9]> */
		/* 820FE1BCh case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 820FE1BCh case    6:*/		return 0x820FE1C0;
	}
	return 0x820FE1C0;
} // Block from 820FE1A4h-820FE1C0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820FE1C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE1C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE1C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE1C0);
		  /* 820FE1C0h */ case    0:  		/* lwz R10, <#[R10 + 48]> */
		/* 820FE1C0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 820FE1C0h case    0:*/		return 0x820FE1C4;
		  /* 820FE1C4h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820FE1C4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FE1C4h case    1:*/		return 0x820FE1C8;
	}
	return 0x820FE1C8;
} // Block from 820FE1C0h-820FE1C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FE1C8h
// Function '?Initialize@CBaseProgram@D3DXShader@@QAAJPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE1C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE1C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE1C8);
		  /* 820FE1C8h */ case    0:  		/* bc 4, CR6_EQ, -20 */
		/* 820FE1C8h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820FE1B4;  }
		/* 820FE1C8h case    0:*/		return 0x820FE1CC;
		  /* 820FE1CCh */ case    1:  		/* mr R3, R11 */
		/* 820FE1CCh case    1:*/		regs.R3 = regs.R11;
		/* 820FE1CCh case    1:*/		return 0x820FE1D0;
		  /* 820FE1D0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820FE1D0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FE1D0h case    2:*/		return 0x820FE1D4;
	}
	return 0x820FE1D4;
} // Block from 820FE1C8h-820FE1D4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FE1D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE1D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE1D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE1D4);
		  /* 820FE1D4h */ case    0:  		/* nop */
		/* 820FE1D4h case    0:*/		cpu::op::nop();
		/* 820FE1D4h case    0:*/		return 0x820FE1D8;
		  /* 820FE1D8h */ case    1:  		/* cmpwi CR6, R4, -1 */
		/* 820FE1D8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 820FE1D8h case    1:*/		return 0x820FE1DC;
		  /* 820FE1DCh */ case    2:  		/* bc 12, CR6_EQ, 72 */
		/* 820FE1DCh case    2:*/		if ( regs.CR[6].eq ) { return 0x820FE224;  }
		/* 820FE1DCh case    2:*/		return 0x820FE1E0;
		  /* 820FE1E0h */ case    3:  		/* lwz R9, <#[R3 + 20]> */
		/* 820FE1E0h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 820FE1E0h case    3:*/		return 0x820FE1E4;
		  /* 820FE1E4h */ case    4:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 820FE1E4h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 820FE1E4h case    4:*/		return 0x820FE1E8;
		  /* 820FE1E8h */ case    5:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820FE1E8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FE1E8h case    5:*/		return 0x820FE1EC;
		  /* 820FE1ECh */ case    6:  		/* lwz R10, <#[R11]> */
		/* 820FE1ECh case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820FE1ECh case    6:*/		return 0x820FE1F0;
		  /* 820FE1F0h */ case    7:  		/* rlwinm. R10, R10, 0, 26, 26 */
		/* 820FE1F0h case    7:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R10,regs.R10);
		/* 820FE1F0h case    7:*/		return 0x820FE1F4;
		  /* 820FE1F4h */ case    8:  		/* bc 4, CR0_EQ, 56 */
		/* 820FE1F4h case    8:*/		if ( !regs.CR[0].eq ) { return 0x820FE22C;  }
		/* 820FE1F4h case    8:*/		return 0x820FE1F8;
		  /* 820FE1F8h */ case    9:  		/* lwz R10, <#[R11 + 56]> */
		/* 820FE1F8h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000038) );
		/* 820FE1F8h case    9:*/		return 0x820FE1FC;
		  /* 820FE1FCh */ case   10:  		/* cmpwi CR6, R10, -1 */
		/* 820FE1FCh case   10:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820FE1FCh case   10:*/		return 0x820FE200;
		  /* 820FE200h */ case   11:  		/* bc 12, CR6_EQ, 24 */
		/* 820FE200h case   11:*/		if ( regs.CR[6].eq ) { return 0x820FE218;  }
		/* 820FE200h case   11:*/		return 0x820FE204;
		  /* 820FE204h */ case   12:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FE204h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FE204h case   12:*/		return 0x820FE208;
		  /* 820FE208h */ case   13:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820FE208h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820FE208h case   13:*/		return 0x820FE20C;
		  /* 820FE20Ch */ case   14:  		/* lwz R10, <#[R10]> */
		/* 820FE20Ch case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820FE20Ch case   14:*/		return 0x820FE210;
		  /* 820FE210h */ case   15:  		/* rlwinm. R10, R10, 0, 26, 26 */
		/* 820FE210h case   15:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R10,regs.R10);
		/* 820FE210h case   15:*/		return 0x820FE214;
		  /* 820FE214h */ case   16:  		/* bc 4, CR0_EQ, 24 */
		/* 820FE214h case   16:*/		if ( !regs.CR[0].eq ) { return 0x820FE22C;  }
		/* 820FE214h case   16:*/		return 0x820FE218;
	}
	return 0x820FE218;
} // Block from 820FE1D4h-820FE218h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820FE218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE218);
		  /* 820FE218h */ case    0:  		/* lwz R4, <#[R11 + 8]> */
		/* 820FE218h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000008) );
		/* 820FE218h case    0:*/		return 0x820FE21C;
		  /* 820FE21Ch */ case    1:  		/* cmpwi CR6, R4, -1 */
		/* 820FE21Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 820FE21Ch case    1:*/		return 0x820FE220;
		  /* 820FE220h */ case    2:  		/* bc 4, CR6_EQ, -60 */
		/* 820FE220h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FE1E4;  }
		/* 820FE220h case    2:*/		return 0x820FE224;
	}
	return 0x820FE224;
} // Block from 820FE218h-820FE224h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FE224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE224);
		  /* 820FE224h */ case    0:  		/* li R3, 0 */
		/* 820FE224h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FE224h case    0:*/		return 0x820FE228;
		  /* 820FE228h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820FE228h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FE228h case    1:*/		return 0x820FE22C;
	}
	return 0x820FE22C;
} // Block from 820FE224h-820FE22Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FE22Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE22C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE22C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE22C);
		  /* 820FE22Ch */ case    0:  		/* li R3, 1 */
		/* 820FE22Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FE22Ch case    0:*/		return 0x820FE230;
		  /* 820FE230h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820FE230h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FE230h case    1:*/		return 0x820FE234;
	}
	return 0x820FE234;
} // Block from 820FE22Ch-820FE234h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FE234h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE234( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE234) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE234);
		  /* 820FE234h */ case    0:  		/* nop */
		/* 820FE234h case    0:*/		cpu::op::nop();
		/* 820FE234h case    0:*/		return 0x820FE238;
	}
	return 0x820FE238;
} // Block from 820FE234h-820FE238h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FE238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE238);
		  /* 820FE238h */ case    0:  		/* mfspr R12, LR */
		/* 820FE238h case    0:*/		regs.R12 = regs.LR;
		/* 820FE238h case    0:*/		return 0x820FE23C;
		  /* 820FE23Ch */ case    1:  		/* bl -446432 */
		/* 820FE23Ch case    1:*/		regs.LR = 0x820FE240; return 0x8209125C;
		/* 820FE23Ch case    1:*/		return 0x820FE240;
		  /* 820FE240h */ case    2:  		/* lwz R31, <#[R4]> */
		/* 820FE240h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R4 + 0x00000000) );
		/* 820FE240h case    2:*/		return 0x820FE244;
		  /* 820FE244h */ case    3:  		/* mr R10, R6 */
		/* 820FE244h case    3:*/		regs.R10 = regs.R6;
		/* 820FE244h case    3:*/		return 0x820FE248;
		  /* 820FE248h */ case    4:  		/* mr R8, R7 */
		/* 820FE248h case    4:*/		regs.R8 = regs.R7;
		/* 820FE248h case    4:*/		return 0x820FE24C;
		  /* 820FE24Ch */ case    5:  		/* cmpwi CR6, R31, -1 */
		/* 820FE24Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R31,0xFFFFFFFF);
		/* 820FE24Ch case    5:*/		return 0x820FE250;
		  /* 820FE250h */ case    6:  		/* bc 4, CR6_EQ, 24 */
		/* 820FE250h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820FE268;  }
		/* 820FE250h case    6:*/		return 0x820FE254;
		  /* 820FE254h */ case    7:  		/* lwz R11, <#[R5]> */
		/* 820FE254h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820FE254h case    7:*/		return 0x820FE258;
		  /* 820FE258h */ case    8:  		/* cmpwi CR6, R11, 0 */
		/* 820FE258h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820FE258h case    8:*/		return 0x820FE25C;
		  /* 820FE25Ch */ case    9:  		/* bc 4, CR6_EQ, 12 */
		/* 820FE25Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x820FE268;  }
		/* 820FE25Ch case    9:*/		return 0x820FE260;
		  /* 820FE260h */ case   10:  		/* stw R7, <#[R5]> */
		/* 820FE260h case   10:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R5 + 0x00000000) );
		/* 820FE260h case   10:*/		return 0x820FE264;
		  /* 820FE264h */ case   11:  		/* b 292 */
		/* 820FE264h case   11:*/		return 0x820FE388;
		/* 820FE264h case   11:*/		return 0x820FE268;
	}
	return 0x820FE268;
} // Block from 820FE238h-820FE268h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820FE268h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE268);
		  /* 820FE268h */ case    0:  		/* cmpwi CR6, R10, -1 */
		/* 820FE268h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820FE268h case    0:*/		return 0x820FE26C;
		  /* 820FE26Ch */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820FE26Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820FE278;  }
		/* 820FE26Ch case    1:*/		return 0x820FE270;
		  /* 820FE270h */ case    2:  		/* cmpwi CR6, R8, 0 */
		/* 820FE270h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820FE270h case    2:*/		return 0x820FE274;
		  /* 820FE274h */ case    3:  		/* bc 12, CR6_EQ, 280 */
		/* 820FE274h case    3:*/		if ( regs.CR[6].eq ) { return 0x820FE38C;  }
		/* 820FE274h case    3:*/		return 0x820FE278;
	}
	return 0x820FE278;
} // Block from 820FE268h-820FE278h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FE278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE278);
		  /* 820FE278h */ case    0:  		/* li R11, 0 */
		/* 820FE278h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820FE278h case    0:*/		return 0x820FE27C;
		  /* 820FE27Ch */ case    1:  		/* li R9, 0 */
		/* 820FE27Ch case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820FE27Ch case    1:*/		return 0x820FE280;
		  /* 820FE280h */ case    2:  		/* mr R30, R31 */
		/* 820FE280h case    2:*/		regs.R30 = regs.R31;
		/* 820FE280h case    2:*/		return 0x820FE284;
		  /* 820FE284h */ case    3:  		/* cmpwi CR6, R31, -1 */
		/* 820FE284h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R31,0xFFFFFFFF);
		/* 820FE284h case    3:*/		return 0x820FE288;
		  /* 820FE288h */ case    4:  		/* bc 12, CR6_EQ, 32 */
		/* 820FE288h case    4:*/		if ( regs.CR[6].eq ) { return 0x820FE2A8;  }
		/* 820FE288h case    4:*/		return 0x820FE28C;
		  /* 820FE28Ch */ case    5:  		/* lwz R29, <#[R3 + 20]> */
		/* 820FE28Ch case    5:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000014) );
		/* 820FE28Ch case    5:*/		return 0x820FE290;
		  /* 820FE290h */ case    6:  		/* rlwinm R7, R30, 2, 0, 29 */
		/* 820FE290h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R30);
		/* 820FE290h case    6:*/		return 0x820FE294;
		  /* 820FE294h */ case    7:  		/* addi R11, R11, 1 */
		/* 820FE294h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820FE294h case    7:*/		return 0x820FE298;
		  /* 820FE298h */ case    8:  		/* lwzx R7, <#[R7 + R29]> */
		/* 820FE298h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R29 + 0x00000000) );
		/* 820FE298h case    8:*/		return 0x820FE29C;
		  /* 820FE29Ch */ case    9:  		/* lwz R30, <#[R7 + 20]> */
		/* 820FE29Ch case    9:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R7 + 0x00000014) );
		/* 820FE29Ch case    9:*/		return 0x820FE2A0;
		  /* 820FE2A0h */ case   10:  		/* cmpwi CR6, R30, -1 */
		/* 820FE2A0h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R30,0xFFFFFFFF);
		/* 820FE2A0h case   10:*/		return 0x820FE2A4;
		  /* 820FE2A4h */ case   11:  		/* bc 4, CR6_EQ, -20 */
		/* 820FE2A4h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820FE290;  }
		/* 820FE2A4h case   11:*/		return 0x820FE2A8;
	}
	return 0x820FE2A8;
} // Block from 820FE278h-820FE2A8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820FE2A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE2A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE2A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE2A8);
		  /* 820FE2A8h */ case    0:  		/* mr R30, R10 */
		/* 820FE2A8h case    0:*/		regs.R30 = regs.R10;
		/* 820FE2A8h case    0:*/		return 0x820FE2AC;
		  /* 820FE2ACh */ case    1:  		/* cmpwi CR6, R10, -1 */
		/* 820FE2ACh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820FE2ACh case    1:*/		return 0x820FE2B0;
		  /* 820FE2B0h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 820FE2B0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FE2D0;  }
		/* 820FE2B0h case    2:*/		return 0x820FE2B4;
		  /* 820FE2B4h */ case    3:  		/* lwz R29, <#[R3 + 20]> */
		/* 820FE2B4h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000014) );
		/* 820FE2B4h case    3:*/		return 0x820FE2B8;
		  /* 820FE2B8h */ case    4:  		/* rlwinm R7, R30, 2, 0, 29 */
		/* 820FE2B8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R30);
		/* 820FE2B8h case    4:*/		return 0x820FE2BC;
		  /* 820FE2BCh */ case    5:  		/* addi R9, R9, 1 */
		/* 820FE2BCh case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820FE2BCh case    5:*/		return 0x820FE2C0;
		  /* 820FE2C0h */ case    6:  		/* lwzx R7, <#[R7 + R29]> */
		/* 820FE2C0h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R29 + 0x00000000) );
		/* 820FE2C0h case    6:*/		return 0x820FE2C4;
		  /* 820FE2C4h */ case    7:  		/* lwz R30, <#[R7 + 20]> */
		/* 820FE2C4h case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R7 + 0x00000014) );
		/* 820FE2C4h case    7:*/		return 0x820FE2C8;
		  /* 820FE2C8h */ case    8:  		/* cmpwi CR6, R30, -1 */
		/* 820FE2C8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R30,0xFFFFFFFF);
		/* 820FE2C8h case    8:*/		return 0x820FE2CC;
		  /* 820FE2CCh */ case    9:  		/* bc 4, CR6_EQ, -20 */
		/* 820FE2CCh case    9:*/		if ( !regs.CR[6].eq ) { return 0x820FE2B8;  }
		/* 820FE2CCh case    9:*/		return 0x820FE2D0;
	}
	return 0x820FE2D0;
} // Block from 820FE2A8h-820FE2D0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FE2D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE2D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE2D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE2D0);
		  /* 820FE2D0h */ case    0:  		/* lwz R29, <#[R5]> */
		/* 820FE2D0h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R5 + 0x00000000) );
		/* 820FE2D0h case    0:*/		return 0x820FE2D4;
		  /* 820FE2D4h */ case    1:  		/* cmplw CR6, R9, R11 */
		/* 820FE2D4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820FE2D4h case    1:*/		return 0x820FE2D8;
		  /* 820FE2D8h */ case    2:  		/* bc 4, CR6_LT, 44 */
		/* 820FE2D8h case    2:*/		if ( !regs.CR[6].lt ) { return 0x820FE304;  }
		/* 820FE2D8h case    2:*/		return 0x820FE2DC;
		  /* 820FE2DCh */ case    3:  		/* subf R7, R9, R11 */
		/* 820FE2DCh case    3:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R9,regs.R11);
		/* 820FE2DCh case    3:*/		return 0x820FE2E0;
		  /* 820FE2E0h */ case    4:  		/* lwz R30, <#[R3 + 20]> */
		/* 820FE2E0h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000014) );
		/* 820FE2E0h case    4:*/		return 0x820FE2E4;
		  /* 820FE2E4h */ case    5:  		/* mtspr CTR, R7 */
		/* 820FE2E4h case    5:*/		regs.CTR = regs.R7;
		/* 820FE2E4h case    5:*/		return 0x820FE2E8;
		  /* 820FE2E8h */ case    6:  		/* rlwinm R7, R31, 2, 0, 29 */
		/* 820FE2E8h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R31);
		/* 820FE2E8h case    6:*/		return 0x820FE2EC;
		  /* 820FE2ECh */ case    7:  		/* addi R11, R11, -1 */
		/* 820FE2ECh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820FE2ECh case    7:*/		return 0x820FE2F0;
		  /* 820FE2F0h */ case    8:  		/* lwzx R7, <#[R7 + R30]> */
		/* 820FE2F0h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R30 + 0x00000000) );
		/* 820FE2F0h case    8:*/		return 0x820FE2F4;
		  /* 820FE2F4h */ case    9:  		/* lwz R29, <#[R7 + 24]> */
		/* 820FE2F4h case    9:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R7 + 0x00000018) );
		/* 820FE2F4h case    9:*/		return 0x820FE2F8;
		  /* 820FE2F8h */ case   10:  		/* lwz R31, <#[R7 + 20]> */
		/* 820FE2F8h case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R7 + 0x00000014) );
		/* 820FE2F8h case   10:*/		return 0x820FE2FC;
		  /* 820FE2FCh */ case   11:  		/* bc 16, CR0_LT, -20 */
		/* 820FE2FCh case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820FE2E8;  }
		/* 820FE2FCh case   11:*/		return 0x820FE300;
		  /* 820FE300h */ case   12:  		/* cmplw CR6, R9, R11 */
		/* 820FE300h case   12:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820FE300h case   12:*/		return 0x820FE304;
	}
	return 0x820FE304;
} // Block from 820FE2D0h-820FE304h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FE304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE304);
		  /* 820FE304h */ case    0:  		/* bc 4, CR6_GT, 36 */
		/* 820FE304h case    0:*/		if ( !regs.CR[6].gt ) { return 0x820FE328;  }
		/* 820FE304h case    0:*/		return 0x820FE308;
		  /* 820FE308h */ case    1:  		/* subf R9, R11, R9 */
		/* 820FE308h case    1:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 820FE308h case    1:*/		return 0x820FE30C;
		  /* 820FE30Ch */ case    2:  		/* lwz R11, <#[R3 + 20]> */
		/* 820FE30Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820FE30Ch case    2:*/		return 0x820FE310;
		  /* 820FE310h */ case    3:  		/* mtspr CTR, R9 */
		/* 820FE310h case    3:*/		regs.CTR = regs.R9;
		/* 820FE310h case    3:*/		return 0x820FE314;
		  /* 820FE314h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FE314h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FE314h case    4:*/		return 0x820FE318;
		  /* 820FE318h */ case    5:  		/* lwzx R10, <#[R10 + R11]> */
		/* 820FE318h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820FE318h case    5:*/		return 0x820FE31C;
		  /* 820FE31Ch */ case    6:  		/* lwz R8, <#[R10 + 24]> */
		/* 820FE31Ch case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000018) );
		/* 820FE31Ch case    6:*/		return 0x820FE320;
		  /* 820FE320h */ case    7:  		/* lwz R10, <#[R10 + 20]> */
		/* 820FE320h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 820FE320h case    7:*/		return 0x820FE324;
		  /* 820FE324h */ case    8:  		/* bc 16, CR0_LT, -16 */
		/* 820FE324h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820FE314;  }
		/* 820FE324h case    8:*/		return 0x820FE328;
	}
	return 0x820FE328;
} // Block from 820FE304h-820FE328h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820FE328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE328);
		  /* 820FE328h */ case    0:  		/* cmpw CR6, R29, R8 */
		/* 820FE328h case    0:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R8);
		/* 820FE328h case    0:*/		return 0x820FE32C;
		  /* 820FE32Ch */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820FE32Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820FE338;  }
		/* 820FE32Ch case    1:*/		return 0x820FE330;
		  /* 820FE330h */ case    2:  		/* cmplw CR6, R31, R10 */
		/* 820FE330h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R10);
		/* 820FE330h case    2:*/		return 0x820FE334;
		  /* 820FE334h */ case    3:  		/* bc 12, CR6_EQ, 60 */
		/* 820FE334h case    3:*/		if ( regs.CR[6].eq ) { return 0x820FE370;  }
		/* 820FE334h case    3:*/		return 0x820FE338;
	}
	return 0x820FE338;
} // Block from 820FE328h-820FE338h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FE338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE338);
		  /* 820FE338h */ case    0:  		/* cmpwi CR6, R31, -1 */
		/* 820FE338h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0xFFFFFFFF);
		/* 820FE338h case    0:*/		return 0x820FE33C;
		  /* 820FE33Ch */ case    1:  		/* bc 12, CR6_EQ, 64 */
		/* 820FE33Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820FE37C;  }
		/* 820FE33Ch case    1:*/		return 0x820FE340;
		  /* 820FE340h */ case    2:  		/* cmpwi CR6, R10, -1 */
		/* 820FE340h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820FE340h case    2:*/		return 0x820FE344;
		  /* 820FE344h */ case    3:  		/* bc 12, CR6_EQ, 56 */
		/* 820FE344h case    3:*/		if ( regs.CR[6].eq ) { return 0x820FE37C;  }
		/* 820FE344h case    3:*/		return 0x820FE348;
	}
	return 0x820FE348;
} // Block from 820FE338h-820FE348h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FE348h
// Function '?CreateArgumentErrorString@CBaseProgram@D3DXShader@@IAAJPAVCArgument@2@PADH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE348);
		  /* 820FE348h */ case    0:  		/* lwz R11, <#[R3 + 20]> */
		/* 820FE348h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820FE348h case    0:*/		return 0x820FE34C;
		  /* 820FE34Ch */ case    1:  		/* rlwinm R9, R31, 2, 0, 29 */
		/* 820FE34Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R31);
		/* 820FE34Ch case    1:*/		return 0x820FE350;
		  /* 820FE350h */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FE350h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FE350h case    2:*/		return 0x820FE354;
		  /* 820FE354h */ case    3:  		/* lwzx R9, <#[R9 + R11]> */
		/* 820FE354h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820FE354h case    3:*/		return 0x820FE358;
		  /* 820FE358h */ case    4:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820FE358h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820FE358h case    4:*/		return 0x820FE35C;
		  /* 820FE35Ch */ case    5:  		/* lwz R29, <#[R9 + 24]> */
		/* 820FE35Ch case    5:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R9 + 0x00000018) );
		/* 820FE35Ch case    5:*/		return 0x820FE360;
		  /* 820FE360h */ case    6:  		/* lwz R31, <#[R9 + 20]> */
		/* 820FE360h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R9 + 0x00000014) );
		/* 820FE360h case    6:*/		return 0x820FE364;
		  /* 820FE364h */ case    7:  		/* lwz R8, <#[R11 + 24]> */
		/* 820FE364h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000018) );
		/* 820FE364h case    7:*/		return 0x820FE368;
		  /* 820FE368h */ case    8:  		/* lwz R10, <#[R11 + 20]> */
		/* 820FE368h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 820FE368h case    8:*/		return 0x820FE36C;
		  /* 820FE36Ch */ case    9:  		/* b -68 */
		/* 820FE36Ch case    9:*/		return 0x820FE328;
		/* 820FE36Ch case    9:*/		return 0x820FE370;
	}
	return 0x820FE370;
} // Block from 820FE348h-820FE370h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FE370h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE370);
		  /* 820FE370h */ case    0:  		/* stw R29, <#[R5]> */
		/* 820FE370h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R5 + 0x00000000) );
		/* 820FE370h case    0:*/		return 0x820FE374;
		  /* 820FE374h */ case    1:  		/* stw R31, <#[R4]> */
		/* 820FE374h case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R4 + 0x00000000) );
		/* 820FE374h case    1:*/		return 0x820FE378;
		  /* 820FE378h */ case    2:  		/* b 20 */
		/* 820FE378h case    2:*/		return 0x820FE38C;
		/* 820FE378h case    2:*/		return 0x820FE37C;
	}
	return 0x820FE37C;
} // Block from 820FE370h-820FE37Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FE37Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE37C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE37C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE37C);
		  /* 820FE37Ch */ case    0:  		/* li R11, 0 */
		/* 820FE37Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820FE37Ch case    0:*/		return 0x820FE380;
		  /* 820FE380h */ case    1:  		/* li R10, -1 */
		/* 820FE380h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820FE380h case    1:*/		return 0x820FE384;
		  /* 820FE384h */ case    2:  		/* stw R11, <#[R5]> */
		/* 820FE384h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820FE384h case    2:*/		return 0x820FE388;
	}
	return 0x820FE388;
} // Block from 820FE37Ch-820FE388h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FE388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE388);
		  /* 820FE388h */ case    0:  		/* stw R10, <#[R4]> */
		/* 820FE388h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 820FE388h case    0:*/		return 0x820FE38C;
	}
	return 0x820FE38C;
} // Block from 820FE388h-820FE38Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FE38Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE38C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE38C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE38C);
		  /* 820FE38Ch */ case    0:  		/* li R3, 0 */
		/* 820FE38Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FE38Ch case    0:*/		return 0x820FE390;
		  /* 820FE390h */ case    1:  		/* b -446692 */
		/* 820FE390h case    1:*/		return 0x820912AC;
		/* 820FE390h case    1:*/		return 0x820FE394;
		  /* 820FE394h */ case    2:  		/* nop */
		/* 820FE394h case    2:*/		cpu::op::nop();
		/* 820FE394h case    2:*/		return 0x820FE398;
	}
	return 0x820FE398;
} // Block from 820FE38Ch-820FE398h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FE398h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE398);
		  /* 820FE398h */ case    0:  		/* mfspr R12, LR */
		/* 820FE398h case    0:*/		regs.R12 = regs.LR;
		/* 820FE398h case    0:*/		return 0x820FE39C;
		  /* 820FE39Ch */ case    1:  		/* bl -446792 */
		/* 820FE39Ch case    1:*/		regs.LR = 0x820FE3A0; return 0x82091254;
		/* 820FE39Ch case    1:*/		return 0x820FE3A0;
		  /* 820FE3A0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820FE3A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820FE3A0h case    2:*/		return 0x820FE3A4;
		  /* 820FE3A4h */ case    3:  		/* lwz R9, <#[R3 + 20]> */
		/* 820FE3A4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 820FE3A4h case    3:*/		return 0x820FE3A8;
		  /* 820FE3A8h */ case    4:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 820FE3A8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 820FE3A8h case    4:*/		return 0x820FE3AC;
		  /* 820FE3ACh */ case    5:  		/* rlwinm R10, R5, 2, 0, 29 */
		/* 820FE3ACh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R5);
		/* 820FE3ACh case    5:*/		return 0x820FE3B0;
		  /* 820FE3B0h */ case    6:  		/* mr R29, R3 */
		/* 820FE3B0h case    6:*/		regs.R29 = regs.R3;
		/* 820FE3B0h case    6:*/		return 0x820FE3B4;
		  /* 820FE3B4h */ case    7:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820FE3B4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FE3B4h case    7:*/		return 0x820FE3B8;
		  /* 820FE3B8h */ case    8:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820FE3B8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820FE3B8h case    8:*/		return 0x820FE3BC;
		  /* 820FE3BCh */ case    9:  		/* lwz R27, <#[R11 + 48]> */
		/* 820FE3BCh case    9:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000030) );
		/* 820FE3BCh case    9:*/		return 0x820FE3C0;
		  /* 820FE3C0h */ case   10:  		/* lwz R28, <#[R10 + 48]> */
		/* 820FE3C0h case   10:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + 0x00000030) );
		/* 820FE3C0h case   10:*/		return 0x820FE3C4;
		  /* 820FE3C4h */ case   11:  		/* cmplw CR6, R27, R28 */
		/* 820FE3C4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R28);
		/* 820FE3C4h case   11:*/		return 0x820FE3C8;
		  /* 820FE3C8h */ case   12:  		/* bc 4, CR6_EQ, 12 */
		/* 820FE3C8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820FE3D4;  }
		/* 820FE3C8h case   12:*/		return 0x820FE3CC;
		  /* 820FE3CCh */ case   13:  		/* li R3, 1 */
		/* 820FE3CCh case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FE3CCh case   13:*/		return 0x820FE3D0;
		  /* 820FE3D0h */ case   14:  		/* b 316 */
		/* 820FE3D0h case   14:*/		return 0x820FE50C;
		/* 820FE3D0h case   14:*/		return 0x820FE3D4;
	}
	return 0x820FE3D4;
} // Block from 820FE398h-820FE3D4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820FE3D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE3D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE3D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE3D4);
		  /* 820FE3D4h */ case    0:  		/* lwz R11, <#[R29 + 20]> */
		/* 820FE3D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000014) );
		/* 820FE3D4h case    0:*/		return 0x820FE3D8;
		  /* 820FE3D8h */ case    1:  		/* rlwinm R10, R28, 2, 0, 29 */
		/* 820FE3D8h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R28);
		/* 820FE3D8h case    1:*/		return 0x820FE3DC;
		  /* 820FE3DCh */ case    2:  		/* lwz R9, <#[R29 + 16]> */
		/* 820FE3DCh case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000010) );
		/* 820FE3DCh case    2:*/		return 0x820FE3E0;
		  /* 820FE3E0h */ case    3:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820FE3E0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820FE3E0h case    3:*/		return 0x820FE3E4;
		  /* 820FE3E4h */ case    4:  		/* lwz R10, <#[R11 + 4]> */
		/* 820FE3E4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820FE3E4h case    4:*/		return 0x820FE3E8;
		  /* 820FE3E8h */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FE3E8h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FE3E8h case    5:*/		return 0x820FE3EC;
		  /* 820FE3ECh */ case    6:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820FE3ECh case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820FE3ECh case    6:*/		return 0x820FE3F0;
		  /* 820FE3F0h */ case    7:  		/* lwz R10, <#[R10 + 4]> */
		/* 820FE3F0h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820FE3F0h case    7:*/		return 0x820FE3F4;
		  /* 820FE3F4h */ case    8:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 820FE3F4h case    8:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 820FE3F4h case    8:*/		return 0x820FE3F8;
	}
	return 0x820FE3F8;
} // Block from 820FE3D4h-820FE3F8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820FE3F8h
// Function '??_GCBaseProgram@D3DXShader@@UAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE3F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE3F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE3F8);
		  /* 820FE3F8h */ case    0:  		/* bc 12, CR0_EQ, 272 */
		/* 820FE3F8h case    0:*/		if ( regs.CR[0].eq ) { return 0x820FE508;  }
		/* 820FE3F8h case    0:*/		return 0x820FE3FC;
		  /* 820FE3FCh */ case    1:  		/* lwz R11, <#[R11 + 72]> */
		/* 820FE3FCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 820FE3FCh case    1:*/		return 0x820FE400;
		  /* 820FE400h */ case    2:  		/* lis R10, 4096 */
		/* 820FE400h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0x1000);
		/* 820FE400h case    2:*/		return 0x820FE404;
		  /* 820FE404h */ case    3:  		/* lwz R9, <#[R29 + 24]> */
		/* 820FE404h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000018) );
		/* 820FE404h case    3:*/		return 0x820FE408;
		  /* 820FE408h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FE408h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FE408h case    4:*/		return 0x820FE40C;
		  /* 820FE40Ch */ case    5:  		/* lwzx R31, <#[R11 + R9]> */
		/* 820FE40Ch case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FE40Ch case    5:*/		return 0x820FE410;
		  /* 820FE410h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 820FE410h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FE410h case    6:*/		return 0x820FE414;
		  /* 820FE414h */ case    7:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FE414h case    7:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FE414h case    7:*/		return 0x820FE418;
		  /* 820FE418h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 820FE418h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FE418h case    8:*/		return 0x820FE41C;
		  /* 820FE41Ch */ case    9:  		/* bc 4, CR6_EQ, 88 */
		/* 820FE41Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x820FE474;  }
		/* 820FE41Ch case    9:*/		return 0x820FE420;
		  /* 820FE420h */ case   10:  		/* lwz R8, <#[R31 + 12]> */
		/* 820FE420h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FE420h case   10:*/		return 0x820FE424;
		  /* 820FE424h */ case   11:  		/* li R10, 0 */
		/* 820FE424h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820FE424h case   11:*/		return 0x820FE428;
		  /* 820FE428h */ case   12:  		/* cmplwi CR6, R8, 0 */
		/* 820FE428h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820FE428h case   12:*/		return 0x820FE42C;
		  /* 820FE42Ch */ case   13:  		/* bc 12, CR6_EQ, 40 */
		/* 820FE42Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x820FE454;  }
		/* 820FE42Ch case   13:*/		return 0x820FE430;
		  /* 820FE430h */ case   14:  		/* lwz R9, <#[R31 + 16]> */
		/* 820FE430h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 820FE430h case   14:*/		return 0x820FE434;
		  /* 820FE434h */ case   15:  		/* li R11, 0 */
		/* 820FE434h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820FE434h case   15:*/		return 0x820FE438;
		  /* 820FE438h */ case   16:  		/* lwzx R7, <#[R11 + R9]> */
		/* 820FE438h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FE438h case   16:*/		return 0x820FE43C;
		  /* 820FE43Ch */ case   17:  		/* cmplw CR6, R7, R28 */
		/* 820FE43Ch case   17:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R28);
		/* 820FE43Ch case   17:*/		return 0x820FE440;
		  /* 820FE440h */ case   18:  		/* bc 12, CR6_EQ, 20 */
		/* 820FE440h case   18:*/		if ( regs.CR[6].eq ) { return 0x820FE454;  }
		/* 820FE440h case   18:*/		return 0x820FE444;
		  /* 820FE444h */ case   19:  		/* addi R10, R10, 1 */
		/* 820FE444h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820FE444h case   19:*/		return 0x820FE448;
	}
	return 0x820FE448;
} // Block from 820FE3F8h-820FE448h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820FE448h
// Function '?CompareValue@D3DXShader@@YAHIIPBX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE448);
		  /* 820FE448h */ case    0:  		/* addi R11, R11, 4 */
		/* 820FE448h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820FE448h case    0:*/		return 0x820FE44C;
		  /* 820FE44Ch */ case    1:  		/* cmplw CR6, R10, R8 */
		/* 820FE44Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 820FE44Ch case    1:*/		return 0x820FE450;
		  /* 820FE450h */ case    2:  		/* bc 12, CR6_LT, -24 */
		/* 820FE450h case    2:*/		if ( regs.CR[6].lt ) { return 0x820FE438;  }
		/* 820FE450h case    2:*/		return 0x820FE454;
	}
	return 0x820FE454;
} // Block from 820FE448h-820FE454h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FE454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE454);
		  /* 820FE454h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820FE454h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820FE454h case    0:*/		return 0x820FE458;
		  /* 820FE458h */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FE458h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FE458h case    1:*/		return 0x820FE45C;
		  /* 820FE45Ch */ case    2:  		/* mr R4, R27 */
		/* 820FE45Ch case    2:*/		regs.R4 = regs.R27;
		/* 820FE45Ch case    2:*/		return 0x820FE460;
		  /* 820FE460h */ case    3:  		/* mr R3, R29 */
		/* 820FE460h case    3:*/		regs.R3 = regs.R29;
		/* 820FE460h case    3:*/		return 0x820FE464;
		  /* 820FE464h */ case    4:  		/* lwzx R5, <#[R10 + R11]> */
		/* 820FE464h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820FE464h case    4:*/		return 0x820FE468;
		  /* 820FE468h */ case    5:  		/* bl -208 */
		/* 820FE468h case    5:*/		regs.LR = 0x820FE46C; return 0x820FE398;
		/* 820FE468h case    5:*/		return 0x820FE46C;
		  /* 820FE46Ch */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820FE46Ch case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FE46Ch case    6:*/		return 0x820FE470;
		  /* 820FE470h */ case    7:  		/* bc 4, CR0_EQ, -164 */
		/* 820FE470h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820FE3CC;  }
		/* 820FE470h case    7:*/		return 0x820FE474;
	}
	return 0x820FE474;
} // Block from 820FE454h-820FE474h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820FE474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE474);
		  /* 820FE474h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820FE474h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FE474h case    0:*/		return 0x820FE478;
		  /* 820FE478h */ case    1:  		/* lis R10, 8272 */
		/* 820FE478h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x2050);
		/* 820FE478h case    1:*/		return 0x820FE47C;
		  /* 820FE47Ch */ case    2:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820FE47Ch case    2:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820FE47Ch case    2:*/		return 0x820FE480;
		  /* 820FE480h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820FE480h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820FE480h case    3:*/		return 0x820FE484;
		  /* 820FE484h */ case    4:  		/* bc 4, CR6_EQ, 132 */
		/* 820FE484h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820FE508;  }
		/* 820FE484h case    4:*/		return 0x820FE488;
		  /* 820FE488h */ case    5:  		/* lwz R9, <#[R31 + 12]> */
		/* 820FE488h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FE488h case    5:*/		return 0x820FE48C;
		  /* 820FE48Ch */ case    6:  		/* li R30, 0 */
		/* 820FE48Ch case    6:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820FE48Ch case    6:*/		return 0x820FE490;
		  /* 820FE490h */ case    7:  		/* cmplwi CR6, R9, 0 */
		/* 820FE490h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820FE490h case    7:*/		return 0x820FE494;
		  /* 820FE494h */ case    8:  		/* bc 12, CR6_EQ, 40 */
		/* 820FE494h case    8:*/		if ( regs.CR[6].eq ) { return 0x820FE4BC;  }
		/* 820FE494h case    8:*/		return 0x820FE498;
		  /* 820FE498h */ case    9:  		/* lwz R10, <#[R31 + 16]> */
		/* 820FE498h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820FE498h case    9:*/		return 0x820FE49C;
		  /* 820FE49Ch */ case   10:  		/* li R11, 0 */
		/* 820FE49Ch case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820FE49Ch case   10:*/		return 0x820FE4A0;
		  /* 820FE4A0h */ case   11:  		/* lwzx R8, <#[R11 + R10]> */
		/* 820FE4A0h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FE4A0h case   11:*/		return 0x820FE4A4;
		  /* 820FE4A4h */ case   12:  		/* cmplw CR6, R8, R28 */
		/* 820FE4A4h case   12:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R28);
		/* 820FE4A4h case   12:*/		return 0x820FE4A8;
		  /* 820FE4A8h */ case   13:  		/* bc 12, CR6_EQ, 20 */
		/* 820FE4A8h case   13:*/		if ( regs.CR[6].eq ) { return 0x820FE4BC;  }
		/* 820FE4A8h case   13:*/		return 0x820FE4AC;
		  /* 820FE4ACh */ case   14:  		/* addi R30, R30, 1 */
		/* 820FE4ACh case   14:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820FE4ACh case   14:*/		return 0x820FE4B0;
		  /* 820FE4B0h */ case   15:  		/* addi R11, R11, 4 */
		/* 820FE4B0h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820FE4B0h case   15:*/		return 0x820FE4B4;
		  /* 820FE4B4h */ case   16:  		/* cmplw CR6, R30, R9 */
		/* 820FE4B4h case   16:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R9);
		/* 820FE4B4h case   16:*/		return 0x820FE4B8;
		  /* 820FE4B8h */ case   17:  		/* bc 12, CR6_LT, -24 */
		/* 820FE4B8h case   17:*/		if ( regs.CR[6].lt ) { return 0x820FE4A0;  }
		/* 820FE4B8h case   17:*/		return 0x820FE4BC;
	}
	return 0x820FE4BC;
} // Block from 820FE474h-820FE4BCh (18 instructions)

//////////////////////////////////////////////////////
// Block at 820FE4BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE4BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE4BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE4BC);
		  /* 820FE4BCh */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820FE4BCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820FE4BCh case    0:*/		return 0x820FE4C0;
		  /* 820FE4C0h */ case    1:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 820FE4C0h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 820FE4C0h case    1:*/		return 0x820FE4C4;
		  /* 820FE4C4h */ case    2:  		/* mr R4, R27 */
		/* 820FE4C4h case    2:*/		regs.R4 = regs.R27;
		/* 820FE4C4h case    2:*/		return 0x820FE4C8;
		  /* 820FE4C8h */ case    3:  		/* mr R3, R29 */
		/* 820FE4C8h case    3:*/		regs.R3 = regs.R29;
		/* 820FE4C8h case    3:*/		return 0x820FE4CC;
		  /* 820FE4CCh */ case    4:  		/* lwzx R5, <#[R10 + R11]> */
		/* 820FE4CCh case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820FE4CCh case    4:*/		return 0x820FE4D0;
	}
	return 0x820FE4D0;
} // Block from 820FE4BCh-820FE4D0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FE4D0h
// Function '?CompareRegister@D3DXShader@@YAHIIPBX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE4D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE4D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE4D0);
		  /* 820FE4D0h */ case    0:  		/* bl -312 */
		/* 820FE4D0h case    0:*/		regs.LR = 0x820FE4D4; return 0x820FE398;
		/* 820FE4D0h case    0:*/		return 0x820FE4D4;
		  /* 820FE4D4h */ case    1:  		/* cmpwi CR0, R3, 0 */
		/* 820FE4D4h case    1:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FE4D4h case    1:*/		return 0x820FE4D8;
		  /* 820FE4D8h */ case    2:  		/* bc 4, CR0_EQ, -268 */
		/* 820FE4D8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820FE3CC;  }
		/* 820FE4D8h case    2:*/		return 0x820FE4DC;
		  /* 820FE4DCh */ case    3:  		/* lwz R11, <#[R31 + 12]> */
		/* 820FE4DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FE4DCh case    3:*/		return 0x820FE4E0;
		  /* 820FE4E0h */ case    4:  		/* mr R4, R27 */
		/* 820FE4E0h case    4:*/		regs.R4 = regs.R27;
		/* 820FE4E0h case    4:*/		return 0x820FE4E4;
		  /* 820FE4E4h */ case    5:  		/* lwz R10, <#[R31 + 8]> */
		/* 820FE4E4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820FE4E4h case    5:*/		return 0x820FE4E8;
		  /* 820FE4E8h */ case    6:  		/* mr R3, R29 */
		/* 820FE4E8h case    6:*/		regs.R3 = regs.R29;
		/* 820FE4E8h case    6:*/		return 0x820FE4EC;
		  /* 820FE4ECh */ case    7:  		/* add R11, R30, R11 */
		/* 820FE4ECh case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 820FE4ECh case    7:*/		return 0x820FE4F0;
		  /* 820FE4F0h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FE4F0h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FE4F0h case    8:*/		return 0x820FE4F4;
		  /* 820FE4F4h */ case    9:  		/* lwzx R5, <#[R11 + R10]> */
		/* 820FE4F4h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FE4F4h case    9:*/		return 0x820FE4F8;
		  /* 820FE4F8h */ case   10:  		/* bl -352 */
		/* 820FE4F8h case   10:*/		regs.LR = 0x820FE4FC; return 0x820FE398;
		/* 820FE4F8h case   10:*/		return 0x820FE4FC;
		  /* 820FE4FCh */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820FE4FCh case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FE4FCh case   11:*/		return 0x820FE500;
		  /* 820FE500h */ case   12:  		/* li R3, 1 */
		/* 820FE500h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FE500h case   12:*/		return 0x820FE504;
		  /* 820FE504h */ case   13:  		/* bc 4, CR0_EQ, 8 */
		/* 820FE504h case   13:*/		if ( !regs.CR[0].eq ) { return 0x820FE50C;  }
		/* 820FE504h case   13:*/		return 0x820FE508;
	}
	return 0x820FE508;
} // Block from 820FE4D0h-820FE508h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820FE508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE508);
		  /* 820FE508h */ case    0:  		/* li R3, 0 */
		/* 820FE508h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FE508h case    0:*/		return 0x820FE50C;
	}
	return 0x820FE50C;
} // Block from 820FE508h-820FE50Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FE50Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE50C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE50C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE50C);
		  /* 820FE50Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 820FE50Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820FE50Ch case    0:*/		return 0x820FE510;
		  /* 820FE510h */ case    1:  		/* b -447084 */
		/* 820FE510h case    1:*/		return 0x820912A4;
		/* 820FE510h case    1:*/		return 0x820FE514;
		  /* 820FE514h */ case    2:  		/* nop */
		/* 820FE514h case    2:*/		cpu::op::nop();
		/* 820FE514h case    2:*/		return 0x820FE518;
	}
	return 0x820FE518;
} // Block from 820FE50Ch-820FE518h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FE518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE518);
		  /* 820FE518h */ case    0:  		/* mfspr R12, LR */
		/* 820FE518h case    0:*/		regs.R12 = regs.LR;
		/* 820FE518h case    0:*/		return 0x820FE51C;
		  /* 820FE51Ch */ case    1:  		/* bl -447192 */
		/* 820FE51Ch case    1:*/		regs.LR = 0x820FE520; return 0x82091244;
		/* 820FE51Ch case    1:*/		return 0x820FE520;
		  /* 820FE520h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 820FE520h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 820FE520h case    2:*/		return 0x820FE524;
		  /* 820FE524h */ case    3:  		/* mr R24, R5 */
		/* 820FE524h case    3:*/		regs.R24 = regs.R5;
		/* 820FE524h case    3:*/		return 0x820FE528;
		  /* 820FE528h */ case    4:  		/* lwz R5, <#[R3 + 20]> */
		/* 820FE528h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000014) );
		/* 820FE528h case    4:*/		return 0x820FE52C;
		  /* 820FE52Ch */ case    5:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 820FE52Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 820FE52Ch case    5:*/		return 0x820FE530;
		  /* 820FE530h */ case    6:  		/* mr R31, R3 */
		/* 820FE530h case    6:*/		regs.R31 = regs.R3;
		/* 820FE530h case    6:*/		return 0x820FE534;
		  /* 820FE534h */ case    7:  		/* mr R26, R4 */
		/* 820FE534h case    7:*/		regs.R26 = regs.R4;
		/* 820FE534h case    7:*/		return 0x820FE538;
		  /* 820FE538h */ case    8:  		/* mr R23, R6 */
		/* 820FE538h case    8:*/		regs.R23 = regs.R6;
		/* 820FE538h case    8:*/		return 0x820FE53C;
		  /* 820FE53Ch */ case    9:  		/* lwz R10, <#[R24]> */
		/* 820FE53Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000000) );
		/* 820FE53Ch case    9:*/		return 0x820FE540;
		  /* 820FE540h */ case   10:  		/* lwzx R25, <#[R11 + R5]> */
		/* 820FE540h case   10:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 820FE540h case   10:*/		return 0x820FE544;
		  /* 820FE544h */ case   11:  		/* cmplw CR6, R4, R10 */
		/* 820FE544h case   11:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 820FE544h case   11:*/		return 0x820FE548;
		  /* 820FE548h */ case   12:  		/* bc 12, CR6_EQ, 740 */
		/* 820FE548h case   12:*/		if ( regs.CR[6].eq ) { return 0x820FE82C;  }
		/* 820FE548h case   12:*/		return 0x820FE54C;
		  /* 820FE54Ch */ case   13:  		/* lwz R11, <#[R25 + 64]> */
		/* 820FE54Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000040) );
		/* 820FE54Ch case   13:*/		return 0x820FE550;
		  /* 820FE550h */ case   14:  		/* cmpwi CR6, R11, -1 */
		/* 820FE550h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FE550h case   14:*/		return 0x820FE554;
		  /* 820FE554h */ case   15:  		/* bc 12, CR6_EQ, 16 */
		/* 820FE554h case   15:*/		if ( regs.CR[6].eq ) { return 0x820FE564;  }
		/* 820FE554h case   15:*/		return 0x820FE558;
		  /* 820FE558h */ case   16:  		/* stw R11, <#[R1 + 80]> */
		/* 820FE558h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820FE558h case   16:*/		return 0x820FE55C;
		  /* 820FE55Ch */ case   17:  		/* lfd FR0, <#[R25 + 40]> */
		/* 820FE55Ch case   17:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R25 + 0x00000028) );
		/* 820FE55Ch case   17:*/		return 0x820FE560;
		  /* 820FE560h */ case   18:  		/* b 728 */
		/* 820FE560h case   18:*/		return 0x820FE838;
		/* 820FE560h case   18:*/		return 0x820FE564;
	}
	return 0x820FE564;
} // Block from 820FE518h-820FE564h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820FE564h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE564( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE564) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE564);
		  /* 820FE564h */ case    0:  		/* lwz R11, <#[R25 + 8]> */
		/* 820FE564h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 820FE564h case    0:*/		return 0x820FE568;
		  /* 820FE568h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 820FE568h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FE568h case    1:*/		return 0x820FE56C;
		  /* 820FE56Ch */ case    2:  		/* bc 4, CR6_EQ, 704 */
		/* 820FE56Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FE82C;  }
		/* 820FE56Ch case    2:*/		return 0x820FE570;
		  /* 820FE570h */ case    3:  		/* lwz R11, <#[R25 + 4]> */
		/* 820FE570h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820FE570h case    3:*/		return 0x820FE574;
		  /* 820FE574h */ case    4:  		/* lwz R6, <#[R31 + 16]> */
		/* 820FE574h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000010) );
		/* 820FE574h case    4:*/		return 0x820FE578;
		  /* 820FE578h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FE578h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FE578h case    5:*/		return 0x820FE57C;
		  /* 820FE57Ch */ case    6:  		/* lwzx R11, <#[R11 + R6]> */
		/* 820FE57Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 820FE57Ch case    6:*/		return 0x820FE580;
		  /* 820FE580h */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 820FE580h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820FE580h case    7:*/		return 0x820FE584;
		  /* 820FE584h */ case    8:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 820FE584h case    8:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 820FE584h case    8:*/		return 0x820FE588;
		  /* 820FE588h */ case    9:  		/* bc 12, CR0_EQ, 676 */
		/* 820FE588h case    9:*/		if ( regs.CR[0].eq ) { return 0x820FE82C;  }
		/* 820FE588h case    9:*/		return 0x820FE58C;
		  /* 820FE58Ch */ case   10:  		/* lwz R10, <#[R25 + 72]> */
		/* 820FE58Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000048) );
		/* 820FE58Ch case   10:*/		return 0x820FE590;
		  /* 820FE590h */ case   11:  		/* li R11, 0 */
		/* 820FE590h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820FE590h case   11:*/		return 0x820FE594;
		  /* 820FE594h */ case   12:  		/* lwz R9, <#[R31 + 24]> */
		/* 820FE594h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 820FE594h case   12:*/		return 0x820FE598;
		  /* 820FE598h */ case   13:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FE598h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FE598h case   13:*/		return 0x820FE59C;
		  /* 820FE59Ch */ case   14:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820FE59Ch case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820FE59Ch case   14:*/		return 0x820FE5A0;
		  /* 820FE5A0h */ case   15:  		/* lwz R9, <#[R10 + 12]> */
		/* 820FE5A0h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		/* 820FE5A0h case   15:*/		return 0x820FE5A4;
		  /* 820FE5A4h */ case   16:  		/* cmplwi CR6, R9, 0 */
		/* 820FE5A4h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820FE5A4h case   16:*/		return 0x820FE5A8;
	}
	return 0x820FE5A8;
} // Block from 820FE564h-820FE5A8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820FE5A8h
// Function '?CompareDependency@D3DXShader@@YAHIIPBX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE5A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE5A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE5A8);
		  /* 820FE5A8h */ case    0:  		/* bc 12, CR6_EQ, 40 */
		/* 820FE5A8h case    0:*/		if ( regs.CR[6].eq ) { return 0x820FE5D0;  }
		/* 820FE5A8h case    0:*/		return 0x820FE5AC;
		  /* 820FE5ACh */ case    1:  		/* lwz R7, <#[R10 + 16]> */
		/* 820FE5ACh case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000010) );
		/* 820FE5ACh case    1:*/		return 0x820FE5B0;
		  /* 820FE5B0h */ case    2:  		/* li R8, 0 */
		/* 820FE5B0h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820FE5B0h case    2:*/		return 0x820FE5B4;
		  /* 820FE5B4h */ case    3:  		/* lwzx R4, <#[R8 + R7]> */
		/* 820FE5B4h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 820FE5B4h case    3:*/		return 0x820FE5B8;
		  /* 820FE5B8h */ case    4:  		/* cmplw CR6, R4, R26 */
		/* 820FE5B8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R26);
		/* 820FE5B8h case    4:*/		return 0x820FE5BC;
		  /* 820FE5BCh */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 820FE5BCh case    5:*/		if ( regs.CR[6].eq ) { return 0x820FE5D0;  }
		/* 820FE5BCh case    5:*/		return 0x820FE5C0;
		  /* 820FE5C0h */ case    6:  		/* addi R11, R11, 1 */
		/* 820FE5C0h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820FE5C0h case    6:*/		return 0x820FE5C4;
		  /* 820FE5C4h */ case    7:  		/* addi R8, R8, 4 */
		/* 820FE5C4h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820FE5C4h case    7:*/		return 0x820FE5C8;
		  /* 820FE5C8h */ case    8:  		/* cmplw CR6, R11, R9 */
		/* 820FE5C8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820FE5C8h case    8:*/		return 0x820FE5CC;
		  /* 820FE5CCh */ case    9:  		/* bc 12, CR6_LT, -24 */
		/* 820FE5CCh case    9:*/		if ( regs.CR[6].lt ) { return 0x820FE5B4;  }
		/* 820FE5CCh case    9:*/		return 0x820FE5D0;
	}
	return 0x820FE5D0;
} // Block from 820FE5A8h-820FE5D0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FE5D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE5D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE5D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE5D0);
		  /* 820FE5D0h */ case    0:  		/* cmplw CR6, R11, R9 */
		/* 820FE5D0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820FE5D0h case    0:*/		return 0x820FE5D4;
		  /* 820FE5D4h */ case    1:  		/* bc 12, CR6_EQ, 600 */
		/* 820FE5D4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820FE82C;  }
		/* 820FE5D4h case    1:*/		return 0x820FE5D8;
		  /* 820FE5D8h */ case    2:  		/* lwz R8, <#[R10]> */
		/* 820FE5D8h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820FE5D8h case    2:*/		return 0x820FE5DC;
		  /* 820FE5DCh */ case    3:  		/* lis R7, 4096 */
		/* 820FE5DCh case    3:*/		cpu::op::lis<0>(regs,&regs.R7,0x1000);
		/* 820FE5DCh case    3:*/		return 0x820FE5E0;
		  /* 820FE5E0h */ case    4:  		/* rlwinm R8, R8, 0, 0, 11 */
		/* 820FE5E0h case    4:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R8,regs.R8);
		/* 820FE5E0h case    4:*/		return 0x820FE5E4;
		  /* 820FE5E4h */ case    5:  		/* cmplw CR6, R8, R7 */
		/* 820FE5E4h case    5:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 820FE5E4h case    5:*/		return 0x820FE5E8;
		  /* 820FE5E8h */ case    6:  		/* bc 4, CR6_EQ, 52 */
		/* 820FE5E8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820FE61C;  }
		/* 820FE5E8h case    6:*/		return 0x820FE5EC;
		  /* 820FE5ECh */ case    7:  		/* li R9, -1 */
		/* 820FE5ECh case    7:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 820FE5ECh case    7:*/		return 0x820FE5F0;
		  /* 820FE5F0h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FE5F0h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FE5F0h case    8:*/		return 0x820FE5F4;
		  /* 820FE5F4h */ case    9:  		/* stw R9, <#[R1 + 80]> */
		/* 820FE5F4h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820FE5F4h case    9:*/		return 0x820FE5F8;
	}
	return 0x820FE5F8;
} // Block from 820FE5D0h-820FE5F8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FE5F8h
// Function '?ComparePredicate@D3DXShader@@YAHIIPBX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE5F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE5F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE5F8);
		  /* 820FE5F8h */ case    0:  		/* addi R6, R1, 88 */
		/* 820FE5F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x58);
		/* 820FE5F8h case    0:*/		return 0x820FE5FC;
		  /* 820FE5FCh */ case    1:  		/* addi R5, R1, 80 */
		/* 820FE5FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820FE5FCh case    1:*/		return 0x820FE600;
		  /* 820FE600h */ case    2:  		/* lwz R10, <#[R10 + 8]> */
		/* 820FE600h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820FE600h case    2:*/		return 0x820FE604;
		  /* 820FE604h */ case    3:  		/* mr R3, R31 */
		/* 820FE604h case    3:*/		regs.R3 = regs.R31;
		/* 820FE604h case    3:*/		return 0x820FE608;
		  /* 820FE608h */ case    4:  		/* lwzx R4, <#[R11 + R10]> */
		/* 820FE608h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FE608h case    4:*/		return 0x820FE60C;
		  /* 820FE60Ch */ case    5:  		/* bl -244 */
		/* 820FE60Ch case    5:*/		regs.LR = 0x820FE610; return 0x820FE518;
		/* 820FE60Ch case    5:*/		return 0x820FE610;
		  /* 820FE610h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820FE610h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FE610h case    6:*/		return 0x820FE614;
		  /* 820FE614h */ case    7:  		/* bc 4, CR0_LT, 552 */
		/* 820FE614h case    7:*/		if ( !regs.CR[0].lt ) { return 0x820FE83C;  }
		/* 820FE614h case    7:*/		return 0x820FE618;
		  /* 820FE618h */ case    8:  		/* b 532 */
		/* 820FE618h case    8:*/		return 0x820FE82C;
		/* 820FE618h case    8:*/		return 0x820FE61C;
	}
	return 0x820FE61C;
} // Block from 820FE5F8h-820FE61Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820FE61Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE61C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE61C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE61C);
		  /* 820FE61Ch */ case    0:  		/* lis R7, 4112 */
		/* 820FE61Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R7,0x1010);
		/* 820FE61Ch case    0:*/		return 0x820FE620;
		  /* 820FE620h */ case    1:  		/* cmplw CR6, R8, R7 */
		/* 820FE620h case    1:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 820FE620h case    1:*/		return 0x820FE624;
		  /* 820FE624h */ case    2:  		/* bc 4, CR6_EQ, 60 */
		/* 820FE624h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FE660;  }
		/* 820FE624h case    2:*/		return 0x820FE628;
		  /* 820FE628h */ case    3:  		/* li R9, -1 */
		/* 820FE628h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 820FE628h case    3:*/		return 0x820FE62C;
		  /* 820FE62Ch */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FE62Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FE62Ch case    4:*/		return 0x820FE630;
		  /* 820FE630h */ case    5:  		/* stw R9, <#[R1 + 80]> */
		/* 820FE630h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820FE630h case    5:*/		return 0x820FE634;
		  /* 820FE634h */ case    6:  		/* addi R6, R1, 88 */
		/* 820FE634h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x58);
		/* 820FE634h case    6:*/		return 0x820FE638;
		  /* 820FE638h */ case    7:  		/* addi R5, R1, 80 */
		/* 820FE638h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820FE638h case    7:*/		return 0x820FE63C;
		  /* 820FE63Ch */ case    8:  		/* lwz R10, <#[R10 + 8]> */
		/* 820FE63Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820FE63Ch case    8:*/		return 0x820FE640;
		  /* 820FE640h */ case    9:  		/* mr R3, R31 */
		/* 820FE640h case    9:*/		regs.R3 = regs.R31;
		/* 820FE640h case    9:*/		return 0x820FE644;
		  /* 820FE644h */ case   10:  		/* lwzx R4, <#[R11 + R10]> */
		/* 820FE644h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FE644h case   10:*/		return 0x820FE648;
		  /* 820FE648h */ case   11:  		/* bl -304 */
		/* 820FE648h case   11:*/		regs.LR = 0x820FE64C; return 0x820FE518;
		/* 820FE648h case   11:*/		return 0x820FE64C;
		  /* 820FE64Ch */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820FE64Ch case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FE64Ch case   12:*/		return 0x820FE650;
		  /* 820FE650h */ case   13:  		/* bc 12, CR0_LT, 476 */
		/* 820FE650h case   13:*/		if ( regs.CR[0].lt ) { return 0x820FE82C;  }
		/* 820FE650h case   13:*/		return 0x820FE654;
		  /* 820FE654h */ case   14:  		/* lfd FR0, <#[R1 + 88]> */
		/* 820FE654h case   14:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 820FE654h case   14:*/		return 0x820FE658;
		  /* 820FE658h */ case   15:  		/* fneg FR0, FR0 */
		/* 820FE658h case   15:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR0);
		/* 820FE658h case   15:*/		return 0x820FE65C;
		  /* 820FE65Ch */ case   16:  		/* b 476 */
		/* 820FE65Ch case   16:*/		return 0x820FE838;
		/* 820FE65Ch case   16:*/		return 0x820FE660;
	}
	return 0x820FE660;
} // Block from 820FE61Ch-820FE660h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820FE660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE660);
		  /* 820FE660h */ case    0:  		/* lis R7, 8256 */
		/* 820FE660h case    0:*/		cpu::op::lis<0>(regs,&regs.R7,0x2040);
		/* 820FE660h case    0:*/		return 0x820FE664;
		  /* 820FE664h */ case    1:  		/* cmplw CR6, R8, R7 */
		/* 820FE664h case    1:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 820FE664h case    1:*/		return 0x820FE668;
		  /* 820FE668h */ case    2:  		/* bc 4, CR6_EQ, 224 */
		/* 820FE668h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FE748;  }
		/* 820FE668h case    2:*/		return 0x820FE66C;
		  /* 820FE66Ch */ case    3:  		/* add R9, R9, R11 */
		/* 820FE66Ch case    3:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 820FE66Ch case    3:*/		return 0x820FE670;
		  /* 820FE670h */ case    4:  		/* lwz R10, <#[R10 + 8]> */
		/* 820FE670h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820FE670h case    4:*/		return 0x820FE674;
		  /* 820FE674h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FE674h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FE674h case    5:*/		return 0x820FE678;
		  /* 820FE678h */ case    6:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820FE678h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820FE678h case    6:*/		return 0x820FE67C;
		  /* 820FE67Ch */ case    7:  		/* addi R5, R1, 80 */
		/* 820FE67Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820FE67Ch case    7:*/		return 0x820FE680;
		  /* 820FE680h */ case    8:  		/* mr R3, R31 */
		/* 820FE680h case    8:*/		regs.R3 = regs.R31;
		/* 820FE680h case    8:*/		return 0x820FE684;
		  /* 820FE684h */ case    9:  		/* lwzx R29, <#[R11 + R10]> */
		/* 820FE684h case    9:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FE684h case    9:*/		return 0x820FE688;
		  /* 820FE688h */ case   10:  		/* lwzx R28, <#[R9 + R10]> */
		/* 820FE688h case   10:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FE688h case   10:*/		return 0x820FE68C;
		  /* 820FE68Ch */ case   11:  		/* mr R4, R29 */
		/* 820FE68Ch case   11:*/		regs.R4 = regs.R29;
		/* 820FE68Ch case   11:*/		return 0x820FE690;
		  /* 820FE690h */ case   12:  		/* cmplw CR6, R29, R28 */
		/* 820FE690h case   12:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R28);
		/* 820FE690h case   12:*/		return 0x820FE694;
		  /* 820FE694h */ case   13:  		/* bc 4, CR6_EQ, 48 */
		/* 820FE694h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820FE6C4;  }
		/* 820FE694h case   13:*/		return 0x820FE698;
		  /* 820FE698h */ case   14:  		/* li R11, -1 */
		/* 820FE698h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820FE698h case   14:*/		return 0x820FE69C;
		  /* 820FE69Ch */ case   15:  		/* addi R6, R1, 88 */
		/* 820FE69Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x58);
		/* 820FE69Ch case   15:*/		return 0x820FE6A0;
		  /* 820FE6A0h */ case   16:  		/* stw R11, <#[R1 + 80]> */
		/* 820FE6A0h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820FE6A0h case   16:*/		return 0x820FE6A4;
		  /* 820FE6A4h */ case   17:  		/* bl -396 */
		/* 820FE6A4h case   17:*/		regs.LR = 0x820FE6A8; return 0x820FE518;
		/* 820FE6A4h case   17:*/		return 0x820FE6A8;
		  /* 820FE6A8h */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 820FE6A8h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FE6A8h case   18:*/		return 0x820FE6AC;
		  /* 820FE6ACh */ case   19:  		/* bc 12, CR0_LT, 384 */
		/* 820FE6ACh case   19:*/		if ( regs.CR[0].lt ) { return 0x820FE82C;  }
		/* 820FE6ACh case   19:*/		return 0x820FE6B0;
		  /* 820FE6B0h */ case   20:  		/* lis R11, -32255 */
		/* 820FE6B0h case   20:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820FE6B0h case   20:*/		return 0x820FE6B4;
		  /* 820FE6B4h */ case   21:  		/* lfd FR13, <#[R1 + 88]> */
		/* 820FE6B4h case   21:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 820FE6B4h case   21:*/		return 0x820FE6B8;
		  /* 820FE6B8h */ case   22:  		/* lfd FR0, <#[R11 - 24504]> */
		/* 820FE6B8h case   22:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFA048) );
		/* 820FE6B8h case   22:*/		return 0x820FE6BC;
		  /* 820FE6BCh */ case   23:  		/* fmul FR0, FR13, FR0 */
		/* 820FE6BCh case   23:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 820FE6BCh case   23:*/		return 0x820FE6C0;
		  /* 820FE6C0h */ case   24:  		/* b 376 */
		/* 820FE6C0h case   24:*/		return 0x820FE838;
		/* 820FE6C0h case   24:*/		return 0x820FE6C4;
	}
	return 0x820FE6C4;
} // Block from 820FE660h-820FE6C4h (25 instructions)

//////////////////////////////////////////////////////
// Block at 820FE6C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE6C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE6C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE6C4);
		  /* 820FE6C4h */ case    0:  		/* li R30, -1 */
		/* 820FE6C4h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0xFFFFFFFF);
		/* 820FE6C4h case    0:*/		return 0x820FE6C8;
		  /* 820FE6C8h */ case    1:  		/* addi R6, R1, 96 */
		/* 820FE6C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x60);
		/* 820FE6C8h case    1:*/		return 0x820FE6CC;
		  /* 820FE6CCh */ case    2:  		/* stw R30, <#[R1 + 80]> */
		/* 820FE6CCh case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 820FE6CCh case    2:*/		return 0x820FE6D0;
		  /* 820FE6D0h */ case    3:  		/* bl -440 */
		/* 820FE6D0h case    3:*/		regs.LR = 0x820FE6D4; return 0x820FE518;
		/* 820FE6D0h case    3:*/		return 0x820FE6D4;
		  /* 820FE6D4h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820FE6D4h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FE6D4h case    4:*/		return 0x820FE6D8;
		  /* 820FE6D8h */ case    5:  		/* bc 12, CR0_LT, 48 */
		/* 820FE6D8h case    5:*/		if ( regs.CR[0].lt ) { return 0x820FE708;  }
		/* 820FE6D8h case    5:*/		return 0x820FE6DC;
		  /* 820FE6DCh */ case    6:  		/* addi R6, R1, 104 */
		/* 820FE6DCh case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x68);
		/* 820FE6DCh case    6:*/		return 0x820FE6E0;
		  /* 820FE6E0h */ case    7:  		/* addi R5, R1, 80 */
		/* 820FE6E0h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820FE6E0h case    7:*/		return 0x820FE6E4;
		  /* 820FE6E4h */ case    8:  		/* mr R4, R28 */
		/* 820FE6E4h case    8:*/		regs.R4 = regs.R28;
		/* 820FE6E4h case    8:*/		return 0x820FE6E8;
		  /* 820FE6E8h */ case    9:  		/* mr R3, R31 */
		/* 820FE6E8h case    9:*/		regs.R3 = regs.R31;
		/* 820FE6E8h case    9:*/		return 0x820FE6EC;
		  /* 820FE6ECh */ case   10:  		/* bl -468 */
		/* 820FE6ECh case   10:*/		regs.LR = 0x820FE6F0; return 0x820FE518;
		/* 820FE6ECh case   10:*/		return 0x820FE6F0;
		  /* 820FE6F0h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820FE6F0h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FE6F0h case   11:*/		return 0x820FE6F4;
		  /* 820FE6F4h */ case   12:  		/* bc 12, CR0_LT, 20 */
		/* 820FE6F4h case   12:*/		if ( regs.CR[0].lt ) { return 0x820FE708;  }
		/* 820FE6F4h case   12:*/		return 0x820FE6F8;
		  /* 820FE6F8h */ case   13:  		/* lfd FR0, <#[R1 + 96]> */
		/* 820FE6F8h case   13:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000060) );
		/* 820FE6F8h case   13:*/		return 0x820FE6FC;
		  /* 820FE6FCh */ case   14:  		/* lfd FR13, <#[R1 + 104]> */
		/* 820FE6FCh case   14:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000068) );
		/* 820FE6FCh case   14:*/		return 0x820FE700;
		  /* 820FE700h */ case   15:  		/* fadd FR0, FR13, FR0 */
		/* 820FE700h case   15:*/		cpu::op::fadd<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 820FE700h case   15:*/		return 0x820FE704;
		  /* 820FE704h */ case   16:  		/* b 308 */
		/* 820FE704h case   16:*/		return 0x820FE838;
		/* 820FE704h case   16:*/		return 0x820FE708;
	}
	return 0x820FE708;
} // Block from 820FE6C4h-820FE708h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820FE708h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE708);
		  /* 820FE708h */ case    0:  		/* stw R30, <#[R1 + 80]> */
		/* 820FE708h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 820FE708h case    0:*/		return 0x820FE70C;
		  /* 820FE70Ch */ case    1:  		/* addi R6, R1, 104 */
		/* 820FE70Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x68);
		/* 820FE70Ch case    1:*/		return 0x820FE710;
		  /* 820FE710h */ case    2:  		/* addi R5, R1, 80 */
		/* 820FE710h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820FE710h case    2:*/		return 0x820FE714;
		  /* 820FE714h */ case    3:  		/* mr R4, R28 */
		/* 820FE714h case    3:*/		regs.R4 = regs.R28;
		/* 820FE714h case    3:*/		return 0x820FE718;
		  /* 820FE718h */ case    4:  		/* mr R3, R31 */
		/* 820FE718h case    4:*/		regs.R3 = regs.R31;
		/* 820FE718h case    4:*/		return 0x820FE71C;
		  /* 820FE71Ch */ case    5:  		/* bl -516 */
		/* 820FE71Ch case    5:*/		regs.LR = 0x820FE720; return 0x820FE518;
		/* 820FE71Ch case    5:*/		return 0x820FE720;
		  /* 820FE720h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820FE720h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FE720h case    6:*/		return 0x820FE724;
		  /* 820FE724h */ case    7:  		/* bc 12, CR0_LT, 264 */
		/* 820FE724h case    7:*/		if ( regs.CR[0].lt ) { return 0x820FE82C;  }
		/* 820FE724h case    7:*/		return 0x820FE728;
		  /* 820FE728h */ case    8:  		/* addi R6, R1, 96 */
		/* 820FE728h case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x60);
		/* 820FE728h case    8:*/		return 0x820FE72C;
		  /* 820FE72Ch */ case    9:  		/* addi R5, R1, 80 */
		/* 820FE72Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820FE72Ch case    9:*/		return 0x820FE730;
		  /* 820FE730h */ case   10:  		/* mr R4, R29 */
		/* 820FE730h case   10:*/		regs.R4 = regs.R29;
		/* 820FE730h case   10:*/		return 0x820FE734;
		  /* 820FE734h */ case   11:  		/* mr R3, R31 */
		/* 820FE734h case   11:*/		regs.R3 = regs.R31;
		/* 820FE734h case   11:*/		return 0x820FE738;
		  /* 820FE738h */ case   12:  		/* bl -544 */
		/* 820FE738h case   12:*/		regs.LR = 0x820FE73C; return 0x820FE518;
		/* 820FE738h case   12:*/		return 0x820FE73C;
		  /* 820FE73Ch */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 820FE73Ch case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FE73Ch case   13:*/		return 0x820FE740;
		  /* 820FE740h */ case   14:  		/* bc 12, CR0_LT, 236 */
		/* 820FE740h case   14:*/		if ( regs.CR[0].lt ) { return 0x820FE82C;  }
		/* 820FE740h case   14:*/		return 0x820FE744;
		  /* 820FE744h */ case   15:  		/* b -76 */
		/* 820FE744h case   15:*/		return 0x820FE6F8;
		/* 820FE744h case   15:*/		return 0x820FE748;
	}
	return 0x820FE748;
} // Block from 820FE708h-820FE748h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820FE748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE748);
		  /* 820FE748h */ case    0:  		/* lis R7, 8272 */
		/* 820FE748h case    0:*/		cpu::op::lis<0>(regs,&regs.R7,0x2050);
		/* 820FE748h case    0:*/		return 0x820FE74C;
		  /* 820FE74Ch */ case    1:  		/* cmplw CR6, R8, R7 */
		/* 820FE74Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 820FE74Ch case    1:*/		return 0x820FE750;
		  /* 820FE750h */ case    2:  		/* bc 4, CR6_EQ, 220 */
		/* 820FE750h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FE82C;  }
		/* 820FE750h case    2:*/		return 0x820FE754;
		  /* 820FE754h */ case    3:  		/* add R9, R9, R11 */
		/* 820FE754h case    3:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 820FE754h case    3:*/		return 0x820FE758;
		  /* 820FE758h */ case    4:  		/* lwz R10, <#[R10 + 8]> */
		/* 820FE758h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820FE758h case    4:*/		return 0x820FE75C;
		  /* 820FE75Ch */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FE75Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FE75Ch case    5:*/		return 0x820FE760;
		  /* 820FE760h */ case    6:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820FE760h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820FE760h case    6:*/		return 0x820FE764;
		  /* 820FE764h */ case    7:  		/* lwzx R28, <#[R11 + R10]> */
		/* 820FE764h case    7:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FE764h case    7:*/		return 0x820FE768;
		  /* 820FE768h */ case    8:  		/* lwzx R27, <#[R9 + R10]> */
		/* 820FE768h case    8:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FE768h case    8:*/		return 0x820FE76C;
		  /* 820FE76Ch */ case    9:  		/* cmplw CR6, R28, R27 */
		/* 820FE76Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R27);
		/* 820FE76Ch case    9:*/		return 0x820FE770;
		  /* 820FE770h */ case   10:  		/* bc 12, CR6_EQ, 188 */
		/* 820FE770h case   10:*/		if ( regs.CR[6].eq ) { return 0x820FE82C;  }
		/* 820FE770h case   10:*/		return 0x820FE774;
		  /* 820FE774h */ case   11:  		/* rlwinm R29, R27, 2, 0, 29 */
		/* 820FE774h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R27);
		/* 820FE774h case   11:*/		return 0x820FE778;
		  /* 820FE778h */ case   12:  		/* li R30, -1 */
		/* 820FE778h case   12:*/		cpu::op::li<0>(regs,&regs.R30,0xFFFFFFFF);
		/* 820FE778h case   12:*/		return 0x820FE77C;
		  /* 820FE77Ch */ case   13:  		/* lwzx R11, <#[R29 + R5]> */
		/* 820FE77Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R5 + 0x00000000) );
		/* 820FE77Ch case   13:*/		return 0x820FE780;
		  /* 820FE780h */ case   14:  		/* lwz R10, <#[R11 + 4]> */
		/* 820FE780h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820FE780h case   14:*/		return 0x820FE784;
		  /* 820FE784h */ case   15:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FE784h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FE784h case   15:*/		return 0x820FE788;
		  /* 820FE788h */ case   16:  		/* lwzx R10, <#[R10 + R6]> */
		/* 820FE788h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 820FE788h case   16:*/		return 0x820FE78C;
		  /* 820FE78Ch */ case   17:  		/* lwz R10, <#[R10 + 4]> */
		/* 820FE78Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820FE78Ch case   17:*/		return 0x820FE790;
		  /* 820FE790h */ case   18:  		/* rlwinm. R10, R10, 0, 23, 23 */
		/* 820FE790h case   18:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R10);
		/* 820FE790h case   18:*/		return 0x820FE794;
		  /* 820FE794h */ case   19:  		/* bc 12, CR0_EQ, 68 */
		/* 820FE794h case   19:*/		if ( regs.CR[0].eq ) { return 0x820FE7D8;  }
		/* 820FE794h case   19:*/		return 0x820FE798;
		  /* 820FE798h */ case   20:  		/* lwz R11, <#[R11 + 8]> */
		/* 820FE798h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820FE798h case   20:*/		return 0x820FE79C;
		  /* 820FE79Ch */ case   21:  		/* cmpwi CR6, R11, -1 */
		/* 820FE79Ch case   21:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FE79Ch case   21:*/		return 0x820FE7A0;
		  /* 820FE7A0h */ case   22:  		/* bc 4, CR6_EQ, 56 */
		/* 820FE7A0h case   22:*/		if ( !regs.CR[6].eq ) { return 0x820FE7D8;  }
		/* 820FE7A0h case   22:*/		return 0x820FE7A4;
		  /* 820FE7A4h */ case   23:  		/* stw R30, <#[R1 + 80]> */
		/* 820FE7A4h case   23:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 820FE7A4h case   23:*/		return 0x820FE7A8;
		  /* 820FE7A8h */ case   24:  		/* addi R6, R1, 88 */
		/* 820FE7A8h case   24:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x58);
		/* 820FE7A8h case   24:*/		return 0x820FE7AC;
		  /* 820FE7ACh */ case   25:  		/* addi R5, R1, 80 */
		/* 820FE7ACh case   25:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820FE7ACh case   25:*/		return 0x820FE7B0;
		  /* 820FE7B0h */ case   26:  		/* mr R4, R28 */
		/* 820FE7B0h case   26:*/		regs.R4 = regs.R28;
		/* 820FE7B0h case   26:*/		return 0x820FE7B4;
		  /* 820FE7B4h */ case   27:  		/* mr R3, R31 */
		/* 820FE7B4h case   27:*/		regs.R3 = regs.R31;
		/* 820FE7B4h case   27:*/		return 0x820FE7B8;
		  /* 820FE7B8h */ case   28:  		/* bl -672 */
		/* 820FE7B8h case   28:*/		regs.LR = 0x820FE7BC; return 0x820FE518;
		/* 820FE7B8h case   28:*/		return 0x820FE7BC;
		  /* 820FE7BCh */ case   29:  		/* cmpwi CR0, R3, 0 */
		/* 820FE7BCh case   29:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FE7BCh case   29:*/		return 0x820FE7C0;
		  /* 820FE7C0h */ case   30:  		/* bc 12, CR0_LT, 24 */
		/* 820FE7C0h case   30:*/		if ( regs.CR[0].lt ) { return 0x820FE7D8;  }
		/* 820FE7C0h case   30:*/		return 0x820FE7C4;
		  /* 820FE7C4h */ case   31:  		/* lwz R11, <#[R31 + 20]> */
		/* 820FE7C4h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820FE7C4h case   31:*/		return 0x820FE7C8;
		  /* 820FE7C8h */ case   32:  		/* lfd FR0, <#[R1 + 88]> */
		/* 820FE7C8h case   32:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 820FE7C8h case   32:*/		return 0x820FE7CC;
		  /* 820FE7CCh */ case   33:  		/* lwzx R11, <#[R29 + R11]> */
		/* 820FE7CCh case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820FE7CCh case   33:*/		return 0x820FE7D0;
		  /* 820FE7D0h */ case   34:  		/* lfd FR13, <#[R11 + 32]> */
		/* 820FE7D0h case   34:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 820FE7D0h case   34:*/		return 0x820FE7D4;
		  /* 820FE7D4h */ case   35:  		/* b -280 */
		/* 820FE7D4h case   35:*/		return 0x820FE6BC;
		/* 820FE7D4h case   35:*/		return 0x820FE7D8;
	}
	return 0x820FE7D8;
} // Block from 820FE748h-820FE7D8h (36 instructions)

//////////////////////////////////////////////////////
// Block at 820FE7D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE7D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE7D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE7D8);
		  /* 820FE7D8h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 820FE7D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820FE7D8h case    0:*/		return 0x820FE7DC;
		  /* 820FE7DCh */ case    1:  		/* rlwinm R29, R28, 2, 0, 29 */
		/* 820FE7DCh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R28);
		/* 820FE7DCh case    1:*/		return 0x820FE7E0;
		  /* 820FE7E0h */ case    2:  		/* lwz R10, <#[R31 + 16]> */
		/* 820FE7E0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820FE7E0h case    2:*/		return 0x820FE7E4;
		  /* 820FE7E4h */ case    3:  		/* lwzx R11, <#[R29 + R11]> */
		/* 820FE7E4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820FE7E4h case    3:*/		return 0x820FE7E8;
		  /* 820FE7E8h */ case    4:  		/* lwz R9, <#[R11 + 4]> */
		/* 820FE7E8h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820FE7E8h case    4:*/		return 0x820FE7EC;
		  /* 820FE7ECh */ case    5:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820FE7ECh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820FE7ECh case    5:*/		return 0x820FE7F0;
		  /* 820FE7F0h */ case    6:  		/* lwzx R10, <#[R9 + R10]> */
		/* 820FE7F0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FE7F0h case    6:*/		return 0x820FE7F4;
		  /* 820FE7F4h */ case    7:  		/* lwz R10, <#[R10 + 4]> */
		/* 820FE7F4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820FE7F4h case    7:*/		return 0x820FE7F8;
		  /* 820FE7F8h */ case    8:  		/* rlwinm. R10, R10, 0, 23, 23 */
		/* 820FE7F8h case    8:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R10);
		/* 820FE7F8h case    8:*/		return 0x820FE7FC;
		  /* 820FE7FCh */ case    9:  		/* bc 12, CR0_EQ, 48 */
		/* 820FE7FCh case    9:*/		if ( regs.CR[0].eq ) { return 0x820FE82C;  }
		/* 820FE7FCh case    9:*/		return 0x820FE800;
		  /* 820FE800h */ case   10:  		/* lwz R11, <#[R11 + 8]> */
		/* 820FE800h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820FE800h case   10:*/		return 0x820FE804;
		  /* 820FE804h */ case   11:  		/* cmpwi CR6, R11, -1 */
		/* 820FE804h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FE804h case   11:*/		return 0x820FE808;
		  /* 820FE808h */ case   12:  		/* bc 4, CR6_EQ, 36 */
		/* 820FE808h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820FE82C;  }
		/* 820FE808h case   12:*/		return 0x820FE80C;
		  /* 820FE80Ch */ case   13:  		/* stw R30, <#[R1 + 80]> */
		/* 820FE80Ch case   13:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 820FE80Ch case   13:*/		return 0x820FE810;
		  /* 820FE810h */ case   14:  		/* addi R6, R1, 88 */
		/* 820FE810h case   14:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x58);
		/* 820FE810h case   14:*/		return 0x820FE814;
		  /* 820FE814h */ case   15:  		/* addi R5, R1, 80 */
		/* 820FE814h case   15:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820FE814h case   15:*/		return 0x820FE818;
		  /* 820FE818h */ case   16:  		/* mr R4, R27 */
		/* 820FE818h case   16:*/		regs.R4 = regs.R27;
		/* 820FE818h case   16:*/		return 0x820FE81C;
		  /* 820FE81Ch */ case   17:  		/* mr R3, R31 */
		/* 820FE81Ch case   17:*/		regs.R3 = regs.R31;
		/* 820FE81Ch case   17:*/		return 0x820FE820;
		  /* 820FE820h */ case   18:  		/* bl -776 */
		/* 820FE820h case   18:*/		regs.LR = 0x820FE824; return 0x820FE518;
		/* 820FE820h case   18:*/		return 0x820FE824;
		  /* 820FE824h */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 820FE824h case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FE824h case   19:*/		return 0x820FE828;
		  /* 820FE828h */ case   20:  		/* bc 4, CR0_LT, -100 */
		/* 820FE828h case   20:*/		if ( !regs.CR[0].lt ) { return 0x820FE7C4;  }
		/* 820FE828h case   20:*/		return 0x820FE82C;
	}
	return 0x820FE82C;
} // Block from 820FE7D8h-820FE82Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 820FE82Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE82C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE82C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE82C);
		  /* 820FE82Ch */ case    0:  		/* lis R11, -32256 */
		/* 820FE82Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820FE82Ch case    0:*/		return 0x820FE830;
		  /* 820FE830h */ case    1:  		/* stw R26, <#[R1 + 80]> */
		/* 820FE830h case    1:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 820FE830h case    1:*/		return 0x820FE834;
		  /* 820FE834h */ case    2:  		/* lfd FR0, <#[R11 + 1848]> */
		/* 820FE834h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000738) );
		/* 820FE834h case    2:*/		return 0x820FE838;
	}
	return 0x820FE838;
} // Block from 820FE82Ch-820FE838h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FE838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE838);
		  /* 820FE838h */ case    0:  		/* stfd FR0, <#[R1 + 88]> */
		/* 820FE838h case    0:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 820FE838h case    0:*/		return 0x820FE83C;
	}
	return 0x820FE83C;
} // Block from 820FE838h-820FE83Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FE83Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE83C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE83C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE83C);
		  /* 820FE83Ch */ case    0:  		/* lwz R11, <#[R24]> */
		/* 820FE83Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 820FE83Ch case    0:*/		return 0x820FE840;
		  /* 820FE840h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 820FE840h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FE840h case    1:*/		return 0x820FE844;
		  /* 820FE844h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 820FE844h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FE860;  }
		/* 820FE844h case    2:*/		return 0x820FE848;
		  /* 820FE848h */ case    3:  		/* lwz R10, <#[R1 + 80]> */
		/* 820FE848h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820FE848h case    3:*/		return 0x820FE84C;
		  /* 820FE84Ch */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 820FE84Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820FE84Ch case    4:*/		return 0x820FE850;
		  /* 820FE850h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 820FE850h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FE860;  }
		/* 820FE850h case    5:*/		return 0x820FE854;
		  /* 820FE854h */ case    6:  		/* lis R3, -32768 */
		/* 820FE854h case    6:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820FE854h case    6:*/		return 0x820FE858;
		  /* 820FE858h */ case    7:  		/* ori R3, R3, 16389 */
		/* 820FE858h case    7:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820FE858h case    7:*/		return 0x820FE85C;
		  /* 820FE85Ch */ case    8:  		/* b 40 */
		/* 820FE85Ch case    8:*/		return 0x820FE884;
		/* 820FE85Ch case    8:*/		return 0x820FE860;
	}
	return 0x820FE860;
} // Block from 820FE83Ch-820FE860h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820FE860h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE860);
		  /* 820FE860h */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 820FE860h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820FE860h case    0:*/		return 0x820FE864;
		  /* 820FE864h */ case    1:  		/* li R3, 0 */
		/* 820FE864h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FE864h case    1:*/		return 0x820FE868;
		  /* 820FE868h */ case    2:  		/* stw R11, <#[R25 + 64]> */
		/* 820FE868h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000040) );
		/* 820FE868h case    2:*/		return 0x820FE86C;
		  /* 820FE86Ch */ case    3:  		/* lfd FR0, <#[R1 + 88]> */
		/* 820FE86Ch case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 820FE86Ch case    3:*/		return 0x820FE870;
		  /* 820FE870h */ case    4:  		/* lwz R11, <#[R1 + 80]> */
		/* 820FE870h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820FE870h case    4:*/		return 0x820FE874;
		  /* 820FE874h */ case    5:  		/* stw R11, <#[R24]> */
		/* 820FE874h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 820FE874h case    5:*/		return 0x820FE878;
		  /* 820FE878h */ case    6:  		/* stfd FR0, <#[R25 + 40]> */
		/* 820FE878h case    6:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R25 + 0x00000028) );
		/* 820FE878h case    6:*/		return 0x820FE87C;
		  /* 820FE87Ch */ case    7:  		/* lfd FR0, <#[R1 + 88]> */
		/* 820FE87Ch case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 820FE87Ch case    7:*/		return 0x820FE880;
		  /* 820FE880h */ case    8:  		/* stfd FR0, <#[R23]> */
		/* 820FE880h case    8:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R23 + 0x00000000) );
		/* 820FE880h case    8:*/		return 0x820FE884;
	}
	return 0x820FE884;
} // Block from 820FE860h-820FE884h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820FE884h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE884( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE884) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE884);
		  /* 820FE884h */ case    0:  		/* addi R1, R1, 192 */
		/* 820FE884h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 820FE884h case    0:*/		return 0x820FE888;
		  /* 820FE888h */ case    1:  		/* b -447988 */
		/* 820FE888h case    1:*/		return 0x82091294;
		/* 820FE888h case    1:*/		return 0x820FE88C;
		  /* 820FE88Ch */ case    2:  		/* nop */
		/* 820FE88Ch case    2:*/		cpu::op::nop();
		/* 820FE88Ch case    2:*/		return 0x820FE890;
	}
	return 0x820FE890;
} // Block from 820FE884h-820FE890h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FE890h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE890);
		  /* 820FE890h */ case    0:  		/* mfspr R12, LR */
		/* 820FE890h case    0:*/		regs.R12 = regs.LR;
		/* 820FE890h case    0:*/		return 0x820FE894;
		  /* 820FE894h */ case    1:  		/* bl -448096 */
		/* 820FE894h case    1:*/		regs.LR = 0x820FE898; return 0x82091234;
		/* 820FE894h case    1:*/		return 0x820FE898;
		  /* 820FE898h */ case    2:  		/* stfd FR31, <#[R1 - 120]> */
		/* 820FE898h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF88) );
		/* 820FE898h case    2:*/		return 0x820FE89C;
		  /* 820FE89Ch */ case    3:  		/* stwu R1, <#[R1 - 208]> */
		/* 820FE89Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 820FE89Ch case    3:*/		return 0x820FE8A0;
		  /* 820FE8A0h */ case    4:  		/* lwz R26, <#[R3 + 20]> */
		/* 820FE8A0h case    4:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R3 + 0x00000014) );
		/* 820FE8A0h case    4:*/		return 0x820FE8A4;
		  /* 820FE8A4h */ case    5:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 820FE8A4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 820FE8A4h case    5:*/		return 0x820FE8A8;
		  /* 820FE8A8h */ case    6:  		/* mr R25, R3 */
		/* 820FE8A8h case    6:*/		regs.R25 = regs.R3;
		/* 820FE8A8h case    6:*/		return 0x820FE8AC;
		  /* 820FE8ACh */ case    7:  		/* mr R19, R5 */
		/* 820FE8ACh case    7:*/		regs.R19 = regs.R5;
		/* 820FE8ACh case    7:*/		return 0x820FE8B0;
		  /* 820FE8B0h */ case    8:  		/* mr R23, R6 */
		/* 820FE8B0h case    8:*/		regs.R23 = regs.R6;
		/* 820FE8B0h case    8:*/		return 0x820FE8B4;
		  /* 820FE8B4h */ case    9:  		/* mr R21, R7 */
		/* 820FE8B4h case    9:*/		regs.R21 = regs.R7;
		/* 820FE8B4h case    9:*/		return 0x820FE8B8;
		  /* 820FE8B8h */ case   10:  		/* lwzx R11, <#[R11 + R26]> */
		/* 820FE8B8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 820FE8B8h case   10:*/		return 0x820FE8BC;
		  /* 820FE8BCh */ case   11:  		/* mr R22, R8 */
		/* 820FE8BCh case   11:*/		regs.R22 = regs.R8;
		/* 820FE8BCh case   11:*/		return 0x820FE8C0;
		  /* 820FE8C0h */ case   12:  		/* mr R20, R9 */
		/* 820FE8C0h case   12:*/		regs.R20 = regs.R9;
		/* 820FE8C0h case   12:*/		return 0x820FE8C4;
		  /* 820FE8C4h */ case   13:  		/* lwz R10, <#[R11 + 8]> */
		/* 820FE8C4h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820FE8C4h case   13:*/		return 0x820FE8C8;
		  /* 820FE8C8h */ case   14:  		/* cmpwi CR6, R10, -1 */
		/* 820FE8C8h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820FE8C8h case   14:*/		return 0x820FE8CC;
		  /* 820FE8CCh */ case   15:  		/* bc 4, CR6_EQ, 1852 */
		/* 820FE8CCh case   15:*/		if ( !regs.CR[6].eq ) { return 0x820FF008;  }
		/* 820FE8CCh case   15:*/		return 0x820FE8D0;
		  /* 820FE8D0h */ case   16:  		/* lwz R10, <#[R11]> */
		/* 820FE8D0h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820FE8D0h case   16:*/		return 0x820FE8D4;
		  /* 820FE8D4h */ case   17:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 820FE8D4h case   17:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 820FE8D4h case   17:*/		return 0x820FE8D8;
		  /* 820FE8D8h */ case   18:  		/* bc 12, CR0_EQ, 1840 */
		/* 820FE8D8h case   18:*/		if ( regs.CR[0].eq ) { return 0x820FF008;  }
		/* 820FE8D8h case   18:*/		return 0x820FE8DC;
		  /* 820FE8DCh */ case   19:  		/* lwz R10, <#[R11 + 4]> */
		/* 820FE8DCh case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820FE8DCh case   19:*/		return 0x820FE8E0;
		  /* 820FE8E0h */ case   20:  		/* lwz R28, <#[R3 + 16]> */
		/* 820FE8E0h case   20:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R3 + 0x00000010) );
		/* 820FE8E0h case   20:*/		return 0x820FE8E4;
		  /* 820FE8E4h */ case   21:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FE8E4h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FE8E4h case   21:*/		return 0x820FE8E8;
		  /* 820FE8E8h */ case   22:  		/* lwzx R10, <#[R10 + R28]> */
		/* 820FE8E8h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 820FE8E8h case   22:*/		return 0x820FE8EC;
		  /* 820FE8ECh */ case   23:  		/* lwz R10, <#[R10 + 4]> */
		/* 820FE8ECh case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820FE8ECh case   23:*/		return 0x820FE8F0;
		  /* 820FE8F0h */ case   24:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 820FE8F0h case   24:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 820FE8F0h case   24:*/		return 0x820FE8F4;
		  /* 820FE8F4h */ case   25:  		/* bc 12, CR0_EQ, 1812 */
		/* 820FE8F4h case   25:*/		if ( regs.CR[0].eq ) { return 0x820FF008;  }
		/* 820FE8F4h case   25:*/		return 0x820FE8F8;
		  /* 820FE8F8h */ case   26:  		/* lwz R10, <#[R11 + 72]> */
		/* 820FE8F8h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000048) );
		/* 820FE8F8h case   26:*/		return 0x820FE8FC;
		  /* 820FE8FCh */ case   27:  		/* li R11, 0 */
		/* 820FE8FCh case   27:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820FE8FCh case   27:*/		return 0x820FE900;
		  /* 820FE900h */ case   28:  		/* lwz R27, <#[R3 + 24]> */
		/* 820FE900h case   28:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R3 + 0x00000018) );
		/* 820FE900h case   28:*/		return 0x820FE904;
		  /* 820FE904h */ case   29:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FE904h case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FE904h case   29:*/		return 0x820FE908;
		  /* 820FE908h */ case   30:  		/* lwzx R10, <#[R10 + R27]> */
		/* 820FE908h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 820FE908h case   30:*/		return 0x820FE90C;
		  /* 820FE90Ch */ case   31:  		/* lwz R9, <#[R10 + 12]> */
		/* 820FE90Ch case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		/* 820FE90Ch case   31:*/		return 0x820FE910;
		  /* 820FE910h */ case   32:  		/* cmplwi CR6, R9, 0 */
		/* 820FE910h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820FE910h case   32:*/		return 0x820FE914;
		  /* 820FE914h */ case   33:  		/* bc 12, CR6_EQ, 40 */
		/* 820FE914h case   33:*/		if ( regs.CR[6].eq ) { return 0x820FE93C;  }
		/* 820FE914h case   33:*/		return 0x820FE918;
		  /* 820FE918h */ case   34:  		/* lwz R7, <#[R10 + 16]> */
		/* 820FE918h case   34:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000010) );
		/* 820FE918h case   34:*/		return 0x820FE91C;
		  /* 820FE91Ch */ case   35:  		/* li R8, 0 */
		/* 820FE91Ch case   35:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820FE91Ch case   35:*/		return 0x820FE920;
		  /* 820FE920h */ case   36:  		/* lwzx R6, <#[R7 + R8]> */
		/* 820FE920h case   36:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 820FE920h case   36:*/		return 0x820FE924;
		  /* 820FE924h */ case   37:  		/* cmplw CR6, R6, R4 */
		/* 820FE924h case   37:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R4);
		/* 820FE924h case   37:*/		return 0x820FE928;
	}
	return 0x820FE928;
} // Block from 820FE890h-820FE928h (38 instructions)

//////////////////////////////////////////////////////
// Block at 820FE928h
// Function '?CompareReadIndex@D3DXShader@@YAHIIPBX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE928);
		  /* 820FE928h */ case    0:  		/* bc 12, CR6_EQ, 20 */
		/* 820FE928h case    0:*/		if ( regs.CR[6].eq ) { return 0x820FE93C;  }
		/* 820FE928h case    0:*/		return 0x820FE92C;
		  /* 820FE92Ch */ case    1:  		/* addi R11, R11, 1 */
		/* 820FE92Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820FE92Ch case    1:*/		return 0x820FE930;
		  /* 820FE930h */ case    2:  		/* addi R8, R8, 4 */
		/* 820FE930h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820FE930h case    2:*/		return 0x820FE934;
		  /* 820FE934h */ case    3:  		/* cmplw CR6, R11, R9 */
		/* 820FE934h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820FE934h case    3:*/		return 0x820FE938;
		  /* 820FE938h */ case    4:  		/* bc 12, CR6_LT, -24 */
		/* 820FE938h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FE920;  }
		/* 820FE938h case    4:*/		return 0x820FE93C;
	}
	return 0x820FE93C;
} // Block from 820FE928h-820FE93Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FE93Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE93C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE93C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE93C);
		  /* 820FE93Ch */ case    0:  		/* cmplw CR6, R11, R9 */
		/* 820FE93Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820FE93Ch case    0:*/		return 0x820FE940;
		  /* 820FE940h */ case    1:  		/* bc 12, CR6_EQ, 1736 */
		/* 820FE940h case    1:*/		if ( regs.CR[6].eq ) { return 0x820FF008;  }
		/* 820FE940h case    1:*/		return 0x820FE944;
		  /* 820FE944h */ case    2:  		/* lwz R8, <#[R10]> */
		/* 820FE944h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820FE944h case    2:*/		return 0x820FE948;
		  /* 820FE948h */ case    3:  		/* lis R7, 4096 */
		/* 820FE948h case    3:*/		cpu::op::lis<0>(regs,&regs.R7,0x1000);
		/* 820FE948h case    3:*/		return 0x820FE94C;
		  /* 820FE94Ch */ case    4:  		/* rlwinm R8, R8, 0, 0, 11 */
		/* 820FE94Ch case    4:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R8,regs.R8);
		/* 820FE94Ch case    4:*/		return 0x820FE950;
		  /* 820FE950h */ case    5:  		/* cmplw CR6, R8, R7 */
		/* 820FE950h case    5:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 820FE950h case    5:*/		return 0x820FE954;
		  /* 820FE954h */ case    6:  		/* bc 4, CR6_EQ, 56 */
		/* 820FE954h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820FE98C;  }
		/* 820FE954h case    6:*/		return 0x820FE958;
		  /* 820FE958h */ case    7:  		/* lwz R10, <#[R10 + 8]> */
		/* 820FE958h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820FE958h case    7:*/		return 0x820FE95C;
		  /* 820FE95Ch */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FE95Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FE95Ch case    8:*/		return 0x820FE960;
	}
	return 0x820FE960;
} // Block from 820FE93Ch-820FE960h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820FE960h
// Function '?CompareReadStable@D3DXShader@@YAHIIPBX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE960);
		  /* 820FE960h */ case    0:  		/* mr R9, R20 */
		/* 820FE960h case    0:*/		regs.R9 = regs.R20;
		/* 820FE960h case    0:*/		return 0x820FE964;
		  /* 820FE964h */ case    1:  		/* mr R8, R22 */
		/* 820FE964h case    1:*/		regs.R8 = regs.R22;
		/* 820FE964h case    1:*/		return 0x820FE968;
		  /* 820FE968h */ case    2:  		/* mr R7, R21 */
		/* 820FE968h case    2:*/		regs.R7 = regs.R21;
		/* 820FE968h case    2:*/		return 0x820FE96C;
		  /* 820FE96Ch */ case    3:  		/* mr R6, R23 */
		/* 820FE96Ch case    3:*/		regs.R6 = regs.R23;
		/* 820FE96Ch case    3:*/		return 0x820FE970;
		  /* 820FE970h */ case    4:  		/* mr R5, R19 */
		/* 820FE970h case    4:*/		regs.R5 = regs.R19;
		/* 820FE970h case    4:*/		return 0x820FE974;
		  /* 820FE974h */ case    5:  		/* lwzx R4, <#[R11 + R10]> */
		/* 820FE974h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FE974h case    5:*/		return 0x820FE978;
		  /* 820FE978h */ case    6:  		/* mr R3, R25 */
		/* 820FE978h case    6:*/		regs.R3 = regs.R25;
		/* 820FE978h case    6:*/		return 0x820FE97C;
		  /* 820FE97Ch */ case    7:  		/* bl -236 */
		/* 820FE97Ch case    7:*/		regs.LR = 0x820FE980; return 0x820FE890;
		/* 820FE97Ch case    7:*/		return 0x820FE980;
		  /* 820FE980h */ case    8:  		/* srawi R11, R3, 31 */
		/* 820FE980h case    8:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 820FE980h case    8:*/		return 0x820FE984;
		  /* 820FE984h */ case    9:  		/* and R3, R11, R3 */
		/* 820FE984h case    9:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820FE984h case    9:*/		return 0x820FE988;
		  /* 820FE988h */ case   10:  		/* b 1672 */
		/* 820FE988h case   10:*/		return 0x820FF010;
		/* 820FE988h case   10:*/		return 0x820FE98C;
	}
	return 0x820FE98C;
} // Block from 820FE960h-820FE98Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FE98Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE98C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE98C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE98C);
		  /* 820FE98Ch */ case    0:  		/* lis R7, 8272 */
		/* 820FE98Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R7,0x2050);
		/* 820FE98Ch case    0:*/		return 0x820FE990;
		  /* 820FE990h */ case    1:  		/* cmplw CR6, R8, R7 */
		/* 820FE990h case    1:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 820FE990h case    1:*/		return 0x820FE994;
		  /* 820FE994h */ case    2:  		/* bc 4, CR6_EQ, 124 */
		/* 820FE994h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FEA10;  }
		/* 820FE994h case    2:*/		return 0x820FE998;
		  /* 820FE998h */ case    3:  		/* lwz R10, <#[R10 + 8]> */
		/* 820FE998h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820FE998h case    3:*/		return 0x820FE99C;
		  /* 820FE99Ch */ case    4:  		/* rlwinm R7, R11, 2, 0, 29 */
		/* 820FE99Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R11);
		/* 820FE99Ch case    4:*/		return 0x820FE9A0;
		  /* 820FE9A0h */ case    5:  		/* add R11, R9, R11 */
		/* 820FE9A0h case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820FE9A0h case    5:*/		return 0x820FE9A4;
		  /* 820FE9A4h */ case    6:  		/* mr R9, R20 */
		/* 820FE9A4h case    6:*/		regs.R9 = regs.R20;
		/* 820FE9A4h case    6:*/		return 0x820FE9A8;
		  /* 820FE9A8h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FE9A8h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FE9A8h case    7:*/		return 0x820FE9AC;
		  /* 820FE9ACh */ case    8:  		/* mr R8, R22 */
		/* 820FE9ACh case    8:*/		regs.R8 = regs.R22;
		/* 820FE9ACh case    8:*/		return 0x820FE9B0;
		  /* 820FE9B0h */ case    9:  		/* lwzx R31, <#[R7 + R10]> */
		/* 820FE9B0h case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 820FE9B0h case    9:*/		return 0x820FE9B4;
		  /* 820FE9B4h */ case   10:  		/* mr R7, R21 */
		/* 820FE9B4h case   10:*/		regs.R7 = regs.R21;
		/* 820FE9B4h case   10:*/		return 0x820FE9B8;
		  /* 820FE9B8h */ case   11:  		/* mr R6, R23 */
		/* 820FE9B8h case   11:*/		regs.R6 = regs.R23;
		/* 820FE9B8h case   11:*/		return 0x820FE9BC;
		  /* 820FE9BCh */ case   12:  		/* mr R5, R19 */
		/* 820FE9BCh case   12:*/		regs.R5 = regs.R19;
		/* 820FE9BCh case   12:*/		return 0x820FE9C0;
		  /* 820FE9C0h */ case   13:  		/* mr R4, R31 */
		/* 820FE9C0h case   13:*/		regs.R4 = regs.R31;
		/* 820FE9C0h case   13:*/		return 0x820FE9C4;
		  /* 820FE9C4h */ case   14:  		/* lwzx R30, <#[R11 + R10]> */
		/* 820FE9C4h case   14:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FE9C4h case   14:*/		return 0x820FE9C8;
		  /* 820FE9C8h */ case   15:  		/* mr R3, R25 */
		/* 820FE9C8h case   15:*/		regs.R3 = regs.R25;
		/* 820FE9C8h case   15:*/		return 0x820FE9CC;
		  /* 820FE9CCh */ case   16:  		/* bl -316 */
		/* 820FE9CCh case   16:*/		regs.LR = 0x820FE9D0; return 0x820FE890;
		/* 820FE9CCh case   16:*/		return 0x820FE9D0;
		  /* 820FE9D0h */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 820FE9D0h case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FE9D0h case   17:*/		return 0x820FE9D4;
		  /* 820FE9D4h */ case   18:  		/* bc 12, CR0_LT, 1596 */
		/* 820FE9D4h case   18:*/		if ( regs.CR[0].lt ) { return 0x820FF010;  }
		/* 820FE9D4h case   18:*/		return 0x820FE9D8;
	}
	return 0x820FE9D8;
} // Block from 820FE98Ch-820FE9D8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820FE9D8h
// Function '?CompareHash@D3DXShader@@YAHIIPBX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FE9D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FE9D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FE9D8);
		  /* 820FE9D8h */ case    0:  		/* cmplw CR6, R31, R30 */
		/* 820FE9D8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 820FE9D8h case    0:*/		return 0x820FE9DC;
		  /* 820FE9DCh */ case    1:  		/* bc 12, CR6_EQ, 44 */
		/* 820FE9DCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820FEA08;  }
		/* 820FE9DCh case    1:*/		return 0x820FE9E0;
		  /* 820FE9E0h */ case    2:  		/* mr R9, R20 */
		/* 820FE9E0h case    2:*/		regs.R9 = regs.R20;
		/* 820FE9E0h case    2:*/		return 0x820FE9E4;
		  /* 820FE9E4h */ case    3:  		/* mr R8, R22 */
		/* 820FE9E4h case    3:*/		regs.R8 = regs.R22;
		/* 820FE9E4h case    3:*/		return 0x820FE9E8;
		  /* 820FE9E8h */ case    4:  		/* mr R7, R21 */
		/* 820FE9E8h case    4:*/		regs.R7 = regs.R21;
		/* 820FE9E8h case    4:*/		return 0x820FE9EC;
		  /* 820FE9ECh */ case    5:  		/* mr R6, R23 */
		/* 820FE9ECh case    5:*/		regs.R6 = regs.R23;
		/* 820FE9ECh case    5:*/		return 0x820FE9F0;
		  /* 820FE9F0h */ case    6:  		/* mr R5, R19 */
		/* 820FE9F0h case    6:*/		regs.R5 = regs.R19;
		/* 820FE9F0h case    6:*/		return 0x820FE9F4;
		  /* 820FE9F4h */ case    7:  		/* mr R4, R30 */
		/* 820FE9F4h case    7:*/		regs.R4 = regs.R30;
		/* 820FE9F4h case    7:*/		return 0x820FE9F8;
		  /* 820FE9F8h */ case    8:  		/* mr R3, R25 */
		/* 820FE9F8h case    8:*/		regs.R3 = regs.R25;
		/* 820FE9F8h case    8:*/		return 0x820FE9FC;
		  /* 820FE9FCh */ case    9:  		/* bl -364 */
		/* 820FE9FCh case    9:*/		regs.LR = 0x820FEA00; return 0x820FE890;
		/* 820FE9FCh case    9:*/		return 0x820FEA00;
		  /* 820FEA00h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 820FEA00h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820FEA00h case   10:*/		return 0x820FEA04;
		  /* 820FEA04h */ case   11:  		/* bc 12, CR0_LT, 1548 */
		/* 820FEA04h case   11:*/		if ( regs.CR[0].lt ) { return 0x820FF010;  }
		/* 820FEA04h case   11:*/		return 0x820FEA08;
	}
	return 0x820FEA08;
} // Block from 820FE9D8h-820FEA08h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820FEA08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEA08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEA08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEA08);
		  /* 820FEA08h */ case    0:  		/* li R3, 0 */
		/* 820FEA08h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FEA08h case    0:*/		return 0x820FEA0C;
		  /* 820FEA0Ch */ case    1:  		/* b 1540 */
		/* 820FEA0Ch case    1:*/		return 0x820FF010;
		/* 820FEA0Ch case    1:*/		return 0x820FEA10;
	}
	return 0x820FEA10;
} // Block from 820FEA08h-820FEA10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FEA10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEA10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEA10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEA10);
		  /* 820FEA10h */ case    0:  		/* lis R7, 8224 */
		/* 820FEA10h case    0:*/		cpu::op::lis<0>(regs,&regs.R7,0x2020);
		/* 820FEA10h case    0:*/		return 0x820FEA14;
		  /* 820FEA14h */ case    1:  		/* cmplw CR6, R8, R7 */
		/* 820FEA14h case    1:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 820FEA14h case    1:*/		return 0x820FEA18;
	}
	return 0x820FEA18;
} // Block from 820FEA10h-820FEA18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FEA18h
// Function '?HeapSort@D3DXShader@@YAXP6AHIIPBX@ZPAII0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEA18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEA18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEA18);
		  /* 820FEA18h */ case    0:  		/* bc 4, CR6_EQ, 260 */
		/* 820FEA18h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820FEB1C;  }
		/* 820FEA18h case    0:*/		return 0x820FEA1C;
		  /* 820FEA1Ch */ case    1:  		/* add R9, R9, R11 */
		/* 820FEA1Ch case    1:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 820FEA1Ch case    1:*/		return 0x820FEA20;
		  /* 820FEA20h */ case    2:  		/* lwz R10, <#[R10 + 8]> */
		/* 820FEA20h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820FEA20h case    2:*/		return 0x820FEA24;
		  /* 820FEA24h */ case    3:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 820FEA24h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 820FEA24h case    3:*/		return 0x820FEA28;
		  /* 820FEA28h */ case    4:  		/* lwz R11, <#[R19]> */
		/* 820FEA28h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 820FEA28h case    4:*/		return 0x820FEA2C;
		  /* 820FEA2Ch */ case    5:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820FEA2Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820FEA2Ch case    5:*/		return 0x820FEA30;
		  /* 820FEA30h */ case    6:  		/* cmpwi CR6, R11, -1 */
		/* 820FEA30h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FEA30h case    6:*/		return 0x820FEA34;
		  /* 820FEA34h */ case    7:  		/* lwzx R8, <#[R8 + R10]> */
		/* 820FEA34h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 820FEA34h case    7:*/		return 0x820FEA38;
		  /* 820FEA38h */ case    8:  		/* lwzx R7, <#[R9 + R10]> */
		/* 820FEA38h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FEA38h case    8:*/		return 0x820FEA3C;
		  /* 820FEA3Ch */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 820FEA3Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820FEA48;  }
		/* 820FEA3Ch case    9:*/		return 0x820FEA40;
		  /* 820FEA40h */ case   10:  		/* cmplw CR6, R7, R11 */
		/* 820FEA40h case   10:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820FEA40h case   10:*/		return 0x820FEA44;
		  /* 820FEA44h */ case   11:  		/* bc 4, CR6_EQ, 104 */
		/* 820FEA44h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820FEAAC;  }
		/* 820FEA44h case   11:*/		return 0x820FEA48;
	}
	return 0x820FEA48;
} // Block from 820FEA18h-820FEA48h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820FEA48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEA48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEA48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEA48);
		  /* 820FEA48h */ case    0:  		/* rlwinm R9, R8, 2, 0, 29 */
		/* 820FEA48h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 820FEA48h case    0:*/		return 0x820FEA4C;
		  /* 820FEA4Ch */ case    1:  		/* lwzx R10, <#[R26 + R9]> */
		/* 820FEA4Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + regs.R9 + 0x00000000) );
		/* 820FEA4Ch case    1:*/		return 0x820FEA50;
		  /* 820FEA50h */ case    2:  		/* lwz R6, <#[R10 + 4]> */
		/* 820FEA50h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 820FEA50h case    2:*/		return 0x820FEA54;
		  /* 820FEA54h */ case    3:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820FEA54h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820FEA54h case    3:*/		return 0x820FEA58;
		  /* 820FEA58h */ case    4:  		/* lwzx R6, <#[R6 + R28]> */
		/* 820FEA58h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R28 + 0x00000000) );
		/* 820FEA58h case    4:*/		return 0x820FEA5C;
		  /* 820FEA5Ch */ case    5:  		/* lwz R6, <#[R6 + 4]> */
		/* 820FEA5Ch case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000004) );
		/* 820FEA5Ch case    5:*/		return 0x820FEA60;
		  /* 820FEA60h */ case    6:  		/* rlwinm. R6, R6, 0, 23, 23 */
		/* 820FEA60h case    6:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R6,regs.R6);
		/* 820FEA60h case    6:*/		return 0x820FEA64;
		  /* 820FEA64h */ case    7:  		/* bc 12, CR0_EQ, 72 */
		/* 820FEA64h case    7:*/		if ( regs.CR[0].eq ) { return 0x820FEAAC;  }
		/* 820FEA64h case    7:*/		return 0x820FEA68;
		  /* 820FEA68h */ case    8:  		/* lwz R10, <#[R10 + 8]> */
		/* 820FEA68h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820FEA68h case    8:*/		return 0x820FEA6C;
		  /* 820FEA6Ch */ case    9:  		/* cmpwi CR6, R10, -1 */
		/* 820FEA6Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820FEA6Ch case    9:*/		return 0x820FEA70;
		  /* 820FEA70h */ case   10:  		/* bc 4, CR6_EQ, 60 */
		/* 820FEA70h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820FEAAC;  }
		/* 820FEA70h case   10:*/		return 0x820FEA74;
		  /* 820FEA74h */ case   11:  		/* lwz R11, <#[R23]> */
		/* 820FEA74h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 820FEA74h case   11:*/		return 0x820FEA78;
		  /* 820FEA78h */ case   12:  		/* cmpwi CR6, R11, -1 */
		/* 820FEA78h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FEA78h case   12:*/		return 0x820FEA7C;
		  /* 820FEA7Ch */ case   13:  		/* bc 12, CR6_EQ, 36 */
		/* 820FEA7Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x820FEAA0;  }
		/* 820FEA7Ch case   13:*/		return 0x820FEA80;
		  /* 820FEA80h */ case   14:  		/* lwz R10, <#[R25 + 20]> */
		/* 820FEA80h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000014) );
		/* 820FEA80h case   14:*/		return 0x820FEA84;
		  /* 820FEA84h */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FEA84h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FEA84h case   15:*/		return 0x820FEA88;
		  /* 820FEA88h */ case   16:  		/* lwzx R9, <#[R10 + R9]> */
		/* 820FEA88h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820FEA88h case   16:*/		return 0x820FEA8C;
		  /* 820FEA8Ch */ case   17:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820FEA8Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FEA8Ch case   17:*/		return 0x820FEA90;
		  /* 820FEA90h */ case   18:  		/* lfd FR0, <#[R9 + 32]> */
		/* 820FEA90h case   18:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000020) );
		/* 820FEA90h case   18:*/		return 0x820FEA94;
		  /* 820FEA94h */ case   19:  		/* lfd FR13, <#[R11 + 32]> */
		/* 820FEA94h case   19:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 820FEA94h case   19:*/		return 0x820FEA98;
		  /* 820FEA98h */ case   20:  		/* fcmpu CR6, FR13, FR0 */
		/* 820FEA98h case   20:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820FEA98h case   20:*/		return 0x820FEA9C;
		  /* 820FEA9Ch */ case   21:  		/* bc 4, CR6_LT, -148 */
		/* 820FEA9Ch case   21:*/		if ( !regs.CR[6].lt ) { return 0x820FEA08;  }
		/* 820FEA9Ch case   21:*/		return 0x820FEAA0;
	}
	return 0x820FEAA0;
} // Block from 820FEA48h-820FEAA0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820FEAA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEAA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEAA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEAA0);
		  /* 820FEAA0h */ case    0:  		/* stw R7, <#[R19]> */
		/* 820FEAA0h case    0:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R19 + 0x00000000) );
		/* 820FEAA0h case    0:*/		return 0x820FEAA4;
		  /* 820FEAA4h */ case    1:  		/* stw R8, <#[R23]> */
		/* 820FEAA4h case    1:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R23 + 0x00000000) );
		/* 820FEAA4h case    1:*/		return 0x820FEAA8;
		  /* 820FEAA8h */ case    2:  		/* b -160 */
		/* 820FEAA8h case    2:*/		return 0x820FEA08;
		/* 820FEAA8h case    2:*/		return 0x820FEAAC;
	}
	return 0x820FEAAC;
} // Block from 820FEAA0h-820FEAACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FEAACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEAAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEAAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEAAC);
		  /* 820FEAACh */ case    0:  		/* cmpwi CR6, R11, -1 */
		/* 820FEAACh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FEAACh case    0:*/		return 0x820FEAB0;
		  /* 820FEAB0h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820FEAB0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820FEABC;  }
		/* 820FEAB0h case    1:*/		return 0x820FEAB4;
		  /* 820FEAB4h */ case    2:  		/* cmplw CR6, R8, R11 */
		/* 820FEAB4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 820FEAB4h case    2:*/		return 0x820FEAB8;
		  /* 820FEAB8h */ case    3:  		/* bc 4, CR6_EQ, 1360 */
		/* 820FEAB8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820FF008;  }
		/* 820FEAB8h case    3:*/		return 0x820FEABC;
	}
	return 0x820FEABC;
} // Block from 820FEAACh-820FEABCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FEABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEABC);
		  /* 820FEABCh */ case    0:  		/* rlwinm R10, R7, 2, 0, 29 */
		/* 820FEABCh case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R7);
		/* 820FEABCh case    0:*/		return 0x820FEAC0;
		  /* 820FEAC0h */ case    1:  		/* lwzx R11, <#[R26 + R10]> */
		/* 820FEAC0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + regs.R10 + 0x00000000) );
		/* 820FEAC0h case    1:*/		return 0x820FEAC4;
		  /* 820FEAC4h */ case    2:  		/* lwz R9, <#[R11 + 4]> */
		/* 820FEAC4h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820FEAC4h case    2:*/		return 0x820FEAC8;
		  /* 820FEAC8h */ case    3:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820FEAC8h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820FEAC8h case    3:*/		return 0x820FEACC;
		  /* 820FEACCh */ case    4:  		/* lwzx R9, <#[R9 + R28]> */
		/* 820FEACCh case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R28 + 0x00000000) );
		/* 820FEACCh case    4:*/		return 0x820FEAD0;
		  /* 820FEAD0h */ case    5:  		/* lwz R9, <#[R9 + 4]> */
		/* 820FEAD0h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 820FEAD0h case    5:*/		return 0x820FEAD4;
		  /* 820FEAD4h */ case    6:  		/* rlwinm. R9, R9, 0, 23, 23 */
		/* 820FEAD4h case    6:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R9,regs.R9);
		/* 820FEAD4h case    6:*/		return 0x820FEAD8;
		  /* 820FEAD8h */ case    7:  		/* bc 12, CR0_EQ, 1328 */
		/* 820FEAD8h case    7:*/		if ( regs.CR[0].eq ) { return 0x820FF008;  }
		/* 820FEAD8h case    7:*/		return 0x820FEADC;
		  /* 820FEADCh */ case    8:  		/* lwz R11, <#[R11 + 8]> */
		/* 820FEADCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820FEADCh case    8:*/		return 0x820FEAE0;
		  /* 820FEAE0h */ case    9:  		/* cmpwi CR6, R11, -1 */
		/* 820FEAE0h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FEAE0h case    9:*/		return 0x820FEAE4;
		  /* 820FEAE4h */ case   10:  		/* bc 4, CR6_EQ, 1316 */
		/* 820FEAE4h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820FF008;  }
		/* 820FEAE4h case   10:*/		return 0x820FEAE8;
		  /* 820FEAE8h */ case   11:  		/* lwz R11, <#[R20]> */
		/* 820FEAE8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 820FEAE8h case   11:*/		return 0x820FEAEC;
		  /* 820FEAECh */ case   12:  		/* cmpwi CR6, R11, -1 */
		/* 820FEAECh case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FEAECh case   12:*/		return 0x820FEAF0;
		  /* 820FEAF0h */ case   13:  		/* bc 12, CR6_EQ, 36 */
		/* 820FEAF0h case   13:*/		if ( regs.CR[6].eq ) { return 0x820FEB14;  }
		/* 820FEAF0h case   13:*/		return 0x820FEAF4;
		  /* 820FEAF4h */ case   14:  		/* lwz R9, <#[R25 + 20]> */
		/* 820FEAF4h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000014) );
		/* 820FEAF4h case   14:*/		return 0x820FEAF8;
		  /* 820FEAF8h */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FEAF8h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FEAF8h case   15:*/		return 0x820FEAFC;
		  /* 820FEAFCh */ case   16:  		/* lwzx R10, <#[R9 + R10]> */
		/* 820FEAFCh case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FEAFCh case   16:*/		return 0x820FEB00;
		  /* 820FEB00h */ case   17:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820FEB00h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FEB00h case   17:*/		return 0x820FEB04;
		  /* 820FEB04h */ case   18:  		/* lfd FR0, <#[R10 + 32]> */
		/* 820FEB04h case   18:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 820FEB04h case   18:*/		return 0x820FEB08;
		  /* 820FEB08h */ case   19:  		/* lfd FR13, <#[R11 + 32]> */
		/* 820FEB08h case   19:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 820FEB08h case   19:*/		return 0x820FEB0C;
		  /* 820FEB0Ch */ case   20:  		/* fcmpu CR6, FR13, FR0 */
		/* 820FEB0Ch case   20:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820FEB0Ch case   20:*/		return 0x820FEB10;
		  /* 820FEB10h */ case   21:  		/* bc 4, CR6_GT, -264 */
		/* 820FEB10h case   21:*/		if ( !regs.CR[6].gt ) { return 0x820FEA08;  }
		/* 820FEB10h case   21:*/		return 0x820FEB14;
	}
	return 0x820FEB14;
} // Block from 820FEABCh-820FEB14h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820FEB14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEB14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEB14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEB14);
		  /* 820FEB14h */ case    0:  		/* stw R8, <#[R19]> */
		/* 820FEB14h case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R19 + 0x00000000) );
		/* 820FEB14h case    0:*/		return 0x820FEB18;
		  /* 820FEB18h */ case    1:  		/* b 1064 */
		/* 820FEB18h case    1:*/		return 0x820FEF40;
		/* 820FEB18h case    1:*/		return 0x820FEB1C;
	}
	return 0x820FEB1C;
} // Block from 820FEB14h-820FEB1Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FEB1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEB1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEB1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEB1C);
		  /* 820FEB1Ch */ case    0:  		/* lis R7, 8240 */
		/* 820FEB1Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R7,0x2030);
		/* 820FEB1Ch case    0:*/		return 0x820FEB20;
		  /* 820FEB20h */ case    1:  		/* cmplw CR6, R8, R7 */
		/* 820FEB20h case    1:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 820FEB20h case    1:*/		return 0x820FEB24;
		  /* 820FEB24h */ case    2:  		/* bc 4, CR6_EQ, 260 */
		/* 820FEB24h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FEC28;  }
		/* 820FEB24h case    2:*/		return 0x820FEB28;
		  /* 820FEB28h */ case    3:  		/* add R9, R9, R11 */
		/* 820FEB28h case    3:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 820FEB28h case    3:*/		return 0x820FEB2C;
		  /* 820FEB2Ch */ case    4:  		/* lwz R10, <#[R10 + 8]> */
		/* 820FEB2Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820FEB2Ch case    4:*/		return 0x820FEB30;
		  /* 820FEB30h */ case    5:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 820FEB30h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 820FEB30h case    5:*/		return 0x820FEB34;
		  /* 820FEB34h */ case    6:  		/* lwz R11, <#[R19]> */
		/* 820FEB34h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 820FEB34h case    6:*/		return 0x820FEB38;
		  /* 820FEB38h */ case    7:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820FEB38h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820FEB38h case    7:*/		return 0x820FEB3C;
		  /* 820FEB3Ch */ case    8:  		/* cmpwi CR6, R11, -1 */
		/* 820FEB3Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FEB3Ch case    8:*/		return 0x820FEB40;
		  /* 820FEB40h */ case    9:  		/* lwzx R8, <#[R8 + R10]> */
		/* 820FEB40h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 820FEB40h case    9:*/		return 0x820FEB44;
		  /* 820FEB44h */ case   10:  		/* lwzx R7, <#[R9 + R10]> */
		/* 820FEB44h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FEB44h case   10:*/		return 0x820FEB48;
		  /* 820FEB48h */ case   11:  		/* bc 12, CR6_EQ, 12 */
		/* 820FEB48h case   11:*/		if ( regs.CR[6].eq ) { return 0x820FEB54;  }
		/* 820FEB48h case   11:*/		return 0x820FEB4C;
		  /* 820FEB4Ch */ case   12:  		/* cmplw CR6, R7, R11 */
		/* 820FEB4Ch case   12:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820FEB4Ch case   12:*/		return 0x820FEB50;
		  /* 820FEB50h */ case   13:  		/* bc 4, CR6_EQ, 104 */
		/* 820FEB50h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820FEBB8;  }
		/* 820FEB50h case   13:*/		return 0x820FEB54;
	}
	return 0x820FEB54;
} // Block from 820FEB1Ch-820FEB54h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820FEB54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEB54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEB54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEB54);
		  /* 820FEB54h */ case    0:  		/* rlwinm R9, R8, 2, 0, 29 */
		/* 820FEB54h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 820FEB54h case    0:*/		return 0x820FEB58;
		  /* 820FEB58h */ case    1:  		/* lwzx R10, <#[R26 + R9]> */
		/* 820FEB58h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + regs.R9 + 0x00000000) );
		/* 820FEB58h case    1:*/		return 0x820FEB5C;
		  /* 820FEB5Ch */ case    2:  		/* lwz R6, <#[R10 + 4]> */
		/* 820FEB5Ch case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 820FEB5Ch case    2:*/		return 0x820FEB60;
		  /* 820FEB60h */ case    3:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820FEB60h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820FEB60h case    3:*/		return 0x820FEB64;
		  /* 820FEB64h */ case    4:  		/* lwzx R6, <#[R6 + R28]> */
		/* 820FEB64h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R28 + 0x00000000) );
		/* 820FEB64h case    4:*/		return 0x820FEB68;
		  /* 820FEB68h */ case    5:  		/* lwz R6, <#[R6 + 4]> */
		/* 820FEB68h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000004) );
		/* 820FEB68h case    5:*/		return 0x820FEB6C;
		  /* 820FEB6Ch */ case    6:  		/* rlwinm. R6, R6, 0, 23, 23 */
		/* 820FEB6Ch case    6:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R6,regs.R6);
		/* 820FEB6Ch case    6:*/		return 0x820FEB70;
		  /* 820FEB70h */ case    7:  		/* bc 12, CR0_EQ, 72 */
		/* 820FEB70h case    7:*/		if ( regs.CR[0].eq ) { return 0x820FEBB8;  }
		/* 820FEB70h case    7:*/		return 0x820FEB74;
		  /* 820FEB74h */ case    8:  		/* lwz R10, <#[R10 + 8]> */
		/* 820FEB74h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820FEB74h case    8:*/		return 0x820FEB78;
		  /* 820FEB78h */ case    9:  		/* cmpwi CR6, R10, -1 */
		/* 820FEB78h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820FEB78h case    9:*/		return 0x820FEB7C;
		  /* 820FEB7Ch */ case   10:  		/* bc 4, CR6_EQ, 60 */
		/* 820FEB7Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x820FEBB8;  }
		/* 820FEB7Ch case   10:*/		return 0x820FEB80;
		  /* 820FEB80h */ case   11:  		/* lwz R11, <#[R22]> */
		/* 820FEB80h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 820FEB80h case   11:*/		return 0x820FEB84;
		  /* 820FEB84h */ case   12:  		/* cmpwi CR6, R11, -1 */
		/* 820FEB84h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FEB84h case   12:*/		return 0x820FEB88;
		  /* 820FEB88h */ case   13:  		/* bc 12, CR6_EQ, 36 */
		/* 820FEB88h case   13:*/		if ( regs.CR[6].eq ) { return 0x820FEBAC;  }
		/* 820FEB88h case   13:*/		return 0x820FEB8C;
		  /* 820FEB8Ch */ case   14:  		/* lwz R10, <#[R25 + 20]> */
		/* 820FEB8Ch case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000014) );
		/* 820FEB8Ch case   14:*/		return 0x820FEB90;
		  /* 820FEB90h */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FEB90h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FEB90h case   15:*/		return 0x820FEB94;
		  /* 820FEB94h */ case   16:  		/* lwzx R9, <#[R10 + R9]> */
		/* 820FEB94h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820FEB94h case   16:*/		return 0x820FEB98;
		  /* 820FEB98h */ case   17:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820FEB98h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FEB98h case   17:*/		return 0x820FEB9C;
		  /* 820FEB9Ch */ case   18:  		/* lfd FR0, <#[R9 + 32]> */
		/* 820FEB9Ch case   18:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000020) );
		/* 820FEB9Ch case   18:*/		return 0x820FEBA0;
		  /* 820FEBA0h */ case   19:  		/* lfd FR13, <#[R11 + 32]> */
		/* 820FEBA0h case   19:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 820FEBA0h case   19:*/		return 0x820FEBA4;
		  /* 820FEBA4h */ case   20:  		/* fcmpu CR6, FR13, FR0 */
		/* 820FEBA4h case   20:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820FEBA4h case   20:*/		return 0x820FEBA8;
		  /* 820FEBA8h */ case   21:  		/* bc 4, CR6_GT, -416 */
		/* 820FEBA8h case   21:*/		if ( !regs.CR[6].gt ) { return 0x820FEA08;  }
		/* 820FEBA8h case   21:*/		return 0x820FEBAC;
	}
	return 0x820FEBAC;
} // Block from 820FEB54h-820FEBACh (22 instructions)

//////////////////////////////////////////////////////
// Block at 820FEBACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEBAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEBAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEBAC);
		  /* 820FEBACh */ case    0:  		/* stw R7, <#[R19]> */
		/* 820FEBACh case    0:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R19 + 0x00000000) );
		/* 820FEBACh case    0:*/		return 0x820FEBB0;
		  /* 820FEBB0h */ case    1:  		/* stw R8, <#[R22]> */
		/* 820FEBB0h case    1:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R22 + 0x00000000) );
		/* 820FEBB0h case    1:*/		return 0x820FEBB4;
		  /* 820FEBB4h */ case    2:  		/* b -428 */
		/* 820FEBB4h case    2:*/		return 0x820FEA08;
		/* 820FEBB4h case    2:*/		return 0x820FEBB8;
	}
	return 0x820FEBB8;
} // Block from 820FEBACh-820FEBB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FEBB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEBB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEBB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEBB8);
		  /* 820FEBB8h */ case    0:  		/* cmpwi CR6, R11, -1 */
		/* 820FEBB8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FEBB8h case    0:*/		return 0x820FEBBC;
		  /* 820FEBBCh */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820FEBBCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820FEBC8;  }
		/* 820FEBBCh case    1:*/		return 0x820FEBC0;
		  /* 820FEBC0h */ case    2:  		/* cmplw CR6, R8, R11 */
		/* 820FEBC0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 820FEBC0h case    2:*/		return 0x820FEBC4;
		  /* 820FEBC4h */ case    3:  		/* bc 4, CR6_EQ, 1092 */
		/* 820FEBC4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820FF008;  }
		/* 820FEBC4h case    3:*/		return 0x820FEBC8;
	}
	return 0x820FEBC8;
} // Block from 820FEBB8h-820FEBC8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FEBC8h
// Function '??0CProgram@D3DXShader@@QAA@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEBC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEBC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEBC8);
		  /* 820FEBC8h */ case    0:  		/* rlwinm R10, R7, 2, 0, 29 */
		/* 820FEBC8h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R7);
		/* 820FEBC8h case    0:*/		return 0x820FEBCC;
		  /* 820FEBCCh */ case    1:  		/* lwzx R11, <#[R26 + R10]> */
		/* 820FEBCCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + regs.R10 + 0x00000000) );
		/* 820FEBCCh case    1:*/		return 0x820FEBD0;
		  /* 820FEBD0h */ case    2:  		/* lwz R9, <#[R11 + 4]> */
		/* 820FEBD0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820FEBD0h case    2:*/		return 0x820FEBD4;
		  /* 820FEBD4h */ case    3:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820FEBD4h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820FEBD4h case    3:*/		return 0x820FEBD8;
		  /* 820FEBD8h */ case    4:  		/* lwzx R9, <#[R9 + R28]> */
		/* 820FEBD8h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R28 + 0x00000000) );
		/* 820FEBD8h case    4:*/		return 0x820FEBDC;
		  /* 820FEBDCh */ case    5:  		/* lwz R9, <#[R9 + 4]> */
		/* 820FEBDCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 820FEBDCh case    5:*/		return 0x820FEBE0;
		  /* 820FEBE0h */ case    6:  		/* rlwinm. R9, R9, 0, 23, 23 */
		/* 820FEBE0h case    6:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R9,regs.R9);
		/* 820FEBE0h case    6:*/		return 0x820FEBE4;
		  /* 820FEBE4h */ case    7:  		/* bc 12, CR0_EQ, 1060 */
		/* 820FEBE4h case    7:*/		if ( regs.CR[0].eq ) { return 0x820FF008;  }
		/* 820FEBE4h case    7:*/		return 0x820FEBE8;
		  /* 820FEBE8h */ case    8:  		/* lwz R11, <#[R11 + 8]> */
		/* 820FEBE8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820FEBE8h case    8:*/		return 0x820FEBEC;
		  /* 820FEBECh */ case    9:  		/* cmpwi CR6, R11, -1 */
		/* 820FEBECh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FEBECh case    9:*/		return 0x820FEBF0;
		  /* 820FEBF0h */ case   10:  		/* bc 4, CR6_EQ, 1048 */
		/* 820FEBF0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820FF008;  }
		/* 820FEBF0h case   10:*/		return 0x820FEBF4;
		  /* 820FEBF4h */ case   11:  		/* lwz R11, <#[R21]> */
		/* 820FEBF4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820FEBF4h case   11:*/		return 0x820FEBF8;
		  /* 820FEBF8h */ case   12:  		/* cmpwi CR6, R11, -1 */
		/* 820FEBF8h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FEBF8h case   12:*/		return 0x820FEBFC;
		  /* 820FEBFCh */ case   13:  		/* bc 12, CR6_EQ, 36 */
		/* 820FEBFCh case   13:*/		if ( regs.CR[6].eq ) { return 0x820FEC20;  }
		/* 820FEBFCh case   13:*/		return 0x820FEC00;
		  /* 820FEC00h */ case   14:  		/* lwz R9, <#[R25 + 20]> */
		/* 820FEC00h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000014) );
		/* 820FEC00h case   14:*/		return 0x820FEC04;
		  /* 820FEC04h */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FEC04h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FEC04h case   15:*/		return 0x820FEC08;
		  /* 820FEC08h */ case   16:  		/* lwzx R10, <#[R9 + R10]> */
		/* 820FEC08h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FEC08h case   16:*/		return 0x820FEC0C;
		  /* 820FEC0Ch */ case   17:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820FEC0Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FEC0Ch case   17:*/		return 0x820FEC10;
		  /* 820FEC10h */ case   18:  		/* lfd FR0, <#[R10 + 32]> */
		/* 820FEC10h case   18:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 820FEC10h case   18:*/		return 0x820FEC14;
		  /* 820FEC14h */ case   19:  		/* lfd FR13, <#[R11 + 32]> */
		/* 820FEC14h case   19:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 820FEC14h case   19:*/		return 0x820FEC18;
		  /* 820FEC18h */ case   20:  		/* fcmpu CR6, FR13, FR0 */
		/* 820FEC18h case   20:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820FEC18h case   20:*/		return 0x820FEC1C;
		  /* 820FEC1Ch */ case   21:  		/* bc 4, CR6_LT, -532 */
		/* 820FEC1Ch case   21:*/		if ( !regs.CR[6].lt ) { return 0x820FEA08;  }
		/* 820FEC1Ch case   21:*/		return 0x820FEC20;
	}
	return 0x820FEC20;
} // Block from 820FEBC8h-820FEC20h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820FEC20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEC20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEC20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEC20);
		  /* 820FEC20h */ case    0:  		/* stw R8, <#[R19]> */
		/* 820FEC20h case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R19 + 0x00000000) );
		/* 820FEC20h case    0:*/		return 0x820FEC24;
		  /* 820FEC24h */ case    1:  		/* b 740 */
		/* 820FEC24h case    1:*/		return 0x820FEF08;
		/* 820FEC24h case    1:*/		return 0x820FEC28;
	}
	return 0x820FEC28;
} // Block from 820FEC20h-820FEC28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FEC28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEC28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEC28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEC28);
		  /* 820FEC28h */ case    0:  		/* lis R9, 12288 */
		/* 820FEC28h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0x3000);
		/* 820FEC28h case    0:*/		return 0x820FEC2C;
		  /* 820FEC2Ch */ case    1:  		/* cmplw CR6, R8, R9 */
		/* 820FEC2Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 820FEC2Ch case    1:*/		return 0x820FEC30;
		  /* 820FEC30h */ case    2:  		/* bc 4, CR6_EQ, 984 */
		/* 820FEC30h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FF008;  }
		/* 820FEC30h case    2:*/		return 0x820FEC34;
		  /* 820FEC34h */ case    3:  		/* lwz R9, <#[R10 + 12]> */
		/* 820FEC34h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		/* 820FEC34h case    3:*/		return 0x820FEC38;
		  /* 820FEC38h */ case    4:  		/* lwz R8, <#[R10 + 8]> */
		/* 820FEC38h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 820FEC38h case    4:*/		return 0x820FEC3C;
		  /* 820FEC3Ch */ case    5:  		/* add R7, R9, R11 */
		/* 820FEC3Ch case    5:*/		cpu::op::add<0>(regs,&regs.R7,regs.R9,regs.R11);
		/* 820FEC3Ch case    5:*/		return 0x820FEC40;
		  /* 820FEC40h */ case    6:  		/* lwz R6, <#[R25 + 20]> */
		/* 820FEC40h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R25 + 0x00000014) );
		/* 820FEC40h case    6:*/		return 0x820FEC44;
		  /* 820FEC44h */ case    7:  		/* rlwinm R9, R9, 1, 0, 30 */
		/* 820FEC44h case    7:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R9);
		/* 820FEC44h case    7:*/		return 0x820FEC48;
		  /* 820FEC48h */ case    8:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 820FEC48h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 820FEC48h case    8:*/		return 0x820FEC4C;
		  /* 820FEC4Ch */ case    9:  		/* add R9, R9, R11 */
		/* 820FEC4Ch case    9:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 820FEC4Ch case    9:*/		return 0x820FEC50;
		  /* 820FEC50h */ case   10:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820FEC50h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820FEC50h case   10:*/		return 0x820FEC54;
		  /* 820FEC54h */ case   11:  		/* lwzx R7, <#[R7 + R8]> */
		/* 820FEC54h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 820FEC54h case   11:*/		return 0x820FEC58;
		  /* 820FEC58h */ case   12:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 820FEC58h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 820FEC58h case   12:*/		return 0x820FEC5C;
		  /* 820FEC5Ch */ case   13:  		/* lwzx R9, <#[R9 + R8]> */
		/* 820FEC5Ch case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820FEC5Ch case   13:*/		return 0x820FEC60;
		  /* 820FEC60h */ case   14:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820FEC60h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820FEC60h case   14:*/		return 0x820FEC64;
		  /* 820FEC64h */ case   15:  		/* lwzx R24, <#[R7 + R6]> */
		/* 820FEC64h case   15:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R7 + regs.R6 + 0x00000000) );
		/* 820FEC64h case   15:*/		return 0x820FEC68;
		  /* 820FEC68h */ case   16:  		/* lwzx R9, <#[R9 + R6]> */
		/* 820FEC68h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 820FEC68h case   16:*/		return 0x820FEC6C;
		  /* 820FEC6Ch */ case   17:  		/* lwz R8, <#[R24 + 4]> */
		/* 820FEC6Ch case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R24 + 0x00000004) );
		/* 820FEC6Ch case   17:*/		return 0x820FEC70;
		  /* 820FEC70h */ case   18:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820FEC70h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820FEC70h case   18:*/		return 0x820FEC74;
		  /* 820FEC74h */ case   19:  		/* lwzx R8, <#[R8 + R28]> */
		/* 820FEC74h case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R28 + 0x00000000) );
		/* 820FEC74h case   19:*/		return 0x820FEC78;
		  /* 820FEC78h */ case   20:  		/* lwz R8, <#[R8 + 4]> */
		/* 820FEC78h case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 820FEC78h case   20:*/		return 0x820FEC7C;
		  /* 820FEC7Ch */ case   21:  		/* rlwinm. R8, R8, 0, 23, 23 */
		/* 820FEC7Ch case   21:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R8,regs.R8);
		/* 820FEC7Ch case   21:*/		return 0x820FEC80;
	}
	return 0x820FEC80;
} // Block from 820FEC28h-820FEC80h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820FEC80h
// Function '?InitCaps@CProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEC80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEC80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEC80);
		  /* 820FEC80h */ case    0:  		/* bc 12, CR0_EQ, 904 */
		/* 820FEC80h case    0:*/		if ( regs.CR[0].eq ) { return 0x820FF008;  }
		/* 820FEC80h case    0:*/		return 0x820FEC84;
		  /* 820FEC84h */ case    1:  		/* lwz R8, <#[R24 + 8]> */
		/* 820FEC84h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R24 + 0x00000008) );
		/* 820FEC84h case    1:*/		return 0x820FEC88;
		  /* 820FEC88h */ case    2:  		/* cmpwi CR6, R8, -1 */
		/* 820FEC88h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 820FEC88h case    2:*/		return 0x820FEC8C;
		  /* 820FEC8Ch */ case    3:  		/* bc 4, CR6_EQ, 892 */
		/* 820FEC8Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820FF008;  }
		/* 820FEC8Ch case    3:*/		return 0x820FEC90;
		  /* 820FEC90h */ case    4:  		/* lwz R8, <#[R9 + 4]> */
		/* 820FEC90h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000004) );
		/* 820FEC90h case    4:*/		return 0x820FEC94;
		  /* 820FEC94h */ case    5:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820FEC94h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820FEC94h case    5:*/		return 0x820FEC98;
		  /* 820FEC98h */ case    6:  		/* lwzx R8, <#[R8 + R28]> */
		/* 820FEC98h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R28 + 0x00000000) );
		/* 820FEC98h case    6:*/		return 0x820FEC9C;
		  /* 820FEC9Ch */ case    7:  		/* lwz R8, <#[R8 + 4]> */
		/* 820FEC9Ch case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 820FEC9Ch case    7:*/		return 0x820FECA0;
		  /* 820FECA0h */ case    8:  		/* rlwinm. R8, R8, 0, 23, 23 */
		/* 820FECA0h case    8:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R8,regs.R8);
		/* 820FECA0h case    8:*/		return 0x820FECA4;
		  /* 820FECA4h */ case    9:  		/* bc 12, CR0_EQ, 868 */
		/* 820FECA4h case    9:*/		if ( regs.CR[0].eq ) { return 0x820FF008;  }
		/* 820FECA4h case    9:*/		return 0x820FECA8;
		  /* 820FECA8h */ case   10:  		/* lwz R8, <#[R9 + 8]> */
		/* 820FECA8h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000008) );
		/* 820FECA8h case   10:*/		return 0x820FECAC;
		  /* 820FECACh */ case   11:  		/* cmpwi CR6, R8, -1 */
		/* 820FECACh case   11:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 820FECACh case   11:*/		return 0x820FECB0;
		  /* 820FECB0h */ case   12:  		/* bc 4, CR6_EQ, 856 */
		/* 820FECB0h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820FF008;  }
		/* 820FECB0h case   12:*/		return 0x820FECB4;
		  /* 820FECB4h */ case   13:  		/* lis R8, -32256 */
		/* 820FECB4h case   13:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 820FECB4h case   13:*/		return 0x820FECB8;
		  /* 820FECB8h */ case   14:  		/* lfd FR0, <#[R24 + 32]> */
		/* 820FECB8h case   14:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R24 + 0x00000020) );
		/* 820FECB8h case   14:*/		return 0x820FECBC;
		  /* 820FECBCh */ case   15:  		/* lis R7, -32256 */
		/* 820FECBCh case   15:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8200);
		/* 820FECBCh case   15:*/		return 0x820FECC0;
	}
	return 0x820FECC0;
} // Block from 820FEC80h-820FECC0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820FECC0h
// Function '?MergeInstructions_Input@CProgram@D3DXShader@@AAAIPAVCInstruction@2@IIH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FECC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FECC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FECC0);
		  /* 820FECC0h */ case    0:  		/* lfd FR1, <#[R8 + 1808]> */
		/* 820FECC0h case    0:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R8 + 0x00000710) );
		/* 820FECC0h case    0:*/		return 0x820FECC4;
		  /* 820FECC4h */ case    1:  		/* lfd FR31, <#[R7 + 1848]> */
		/* 820FECC4h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R7 + 0x00000738) );
		/* 820FECC4h case    1:*/		return 0x820FECC8;
		  /* 820FECC8h */ case    2:  		/* fcmpu CR6, FR0, FR1 */
		/* 820FECC8h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR1);
		/* 820FECC8h case    2:*/		return 0x820FECCC;
		  /* 820FECCCh */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 820FECCCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x820FECDC;  }
		/* 820FECCCh case    3:*/		return 0x820FECD0;
		  /* 820FECD0h */ case    4:  		/* lfd FR13, <#[R9 + 32]> */
		/* 820FECD0h case    4:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R9 + 0x00000020) );
		/* 820FECD0h case    4:*/		return 0x820FECD4;
		  /* 820FECD4h */ case    5:  		/* fcmpu CR6, FR13, FR31 */
		/* 820FECD4h case    5:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR31);
		/* 820FECD4h case    5:*/		return 0x820FECD8;
		  /* 820FECD8h */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 820FECD8h case    6:*/		if ( regs.CR[6].eq ) { return 0x820FECF0;  }
		/* 820FECD8h case    6:*/		return 0x820FECDC;
	}
	return 0x820FECDC;
} // Block from 820FECC0h-820FECDCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820FECDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FECDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FECDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FECDC);
		  /* 820FECDCh */ case    0:  		/* fcmpu CR6, FR0, FR31 */
		/* 820FECDCh case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 820FECDCh case    0:*/		return 0x820FECE0;
		  /* 820FECE0h */ case    1:  		/* bc 4, CR6_EQ, 808 */
		/* 820FECE0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820FF008;  }
		/* 820FECE0h case    1:*/		return 0x820FECE4;
		  /* 820FECE4h */ case    2:  		/* lfd FR0, <#[R9 + 32]> */
		/* 820FECE4h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000020) );
		/* 820FECE4h case    2:*/		return 0x820FECE8;
		  /* 820FECE8h */ case    3:  		/* fcmpu CR6, FR0, FR1 */
		/* 820FECE8h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR1);
		/* 820FECE8h case    3:*/		return 0x820FECEC;
		  /* 820FECECh */ case    4:  		/* bc 4, CR6_EQ, 796 */
		/* 820FECECh case    4:*/		if ( !regs.CR[6].eq ) { return 0x820FF008;  }
		/* 820FECECh case    4:*/		return 0x820FECF0;
	}
	return 0x820FECF0;
} // Block from 820FECDCh-820FECF0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FECF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FECF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FECF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FECF0);
		  /* 820FECF0h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 820FECF0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820FECF0h case    0:*/		return 0x820FECF4;
		  /* 820FECF4h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FECF4h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FECF4h case    1:*/		return 0x820FECF8;
		  /* 820FECF8h */ case    2:  		/* lwzx R8, <#[R11 + R10]> */
		/* 820FECF8h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FECF8h case    2:*/		return 0x820FECFC;
		  /* 820FECFCh */ case    3:  		/* rlwinm R11, R8, 2, 0, 29 */
		/* 820FECFCh case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R8);
		/* 820FECFCh case    3:*/		return 0x820FED00;
		  /* 820FED00h */ case    4:  		/* lwzx R11, <#[R11 + R26]> */
		/* 820FED00h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 820FED00h case    4:*/		return 0x820FED04;
		  /* 820FED04h */ case    5:  		/* lwz R10, <#[R11 + 4]> */
		/* 820FED04h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820FED04h case    5:*/		return 0x820FED08;
		  /* 820FED08h */ case    6:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FED08h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FED08h case    6:*/		return 0x820FED0C;
		  /* 820FED0Ch */ case    7:  		/* lwzx R10, <#[R10 + R28]> */
		/* 820FED0Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 820FED0Ch case    7:*/		return 0x820FED10;
		  /* 820FED10h */ case    8:  		/* lwz R10, <#[R10 + 4]> */
		/* 820FED10h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820FED10h case    8:*/		return 0x820FED14;
		  /* 820FED14h */ case    9:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 820FED14h case    9:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 820FED14h case    9:*/		return 0x820FED18;
		  /* 820FED18h */ case   10:  		/* bc 12, CR0_EQ, 752 */
		/* 820FED18h case   10:*/		if ( regs.CR[0].eq ) { return 0x820FF008;  }
		/* 820FED18h case   10:*/		return 0x820FED1C;
		  /* 820FED1Ch */ case   11:  		/* lwz R11, <#[R11 + 72]> */
		/* 820FED1Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 820FED1Ch case   11:*/		return 0x820FED20;
		  /* 820FED20h */ case   12:  		/* lis R10, 8256 */
		/* 820FED20h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0x2040);
		/* 820FED20h case   12:*/		return 0x820FED24;
		  /* 820FED24h */ case   13:  		/* lis R6, 4112 */
		/* 820FED24h case   13:*/		cpu::op::lis<0>(regs,&regs.R6,0x1010);
		/* 820FED24h case   13:*/		return 0x820FED28;
		  /* 820FED28h */ case   14:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FED28h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FED28h case   14:*/		return 0x820FED2C;
		  /* 820FED2Ch */ case   15:  		/* lwzx R31, <#[R11 + R27]> */
		/* 820FED2Ch case   15:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 820FED2Ch case   15:*/		return 0x820FED30;
		  /* 820FED30h */ case   16:  		/* lwz R11, <#[R31]> */
		/* 820FED30h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820FED30h case   16:*/		return 0x820FED34;
		  /* 820FED34h */ case   17:  		/* rlwinm R9, R11, 0, 0, 11 */
		/* 820FED34h case   17:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R9,regs.R11);
		/* 820FED34h case   17:*/		return 0x820FED38;
		  /* 820FED38h */ case   18:  		/* cmplw CR6, R9, R10 */
		/* 820FED38h case   18:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 820FED38h case   18:*/		return 0x820FED3C;
		  /* 820FED3Ch */ case   19:  		/* bc 12, CR6_EQ, 12 */
		/* 820FED3Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x820FED48;  }
		/* 820FED3Ch case   19:*/		return 0x820FED40;
		  /* 820FED40h */ case   20:  		/* cmplw CR6, R9, R6 */
		/* 820FED40h case   20:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R6);
		/* 820FED40h case   20:*/		return 0x820FED44;
		  /* 820FED44h */ case   21:  		/* bc 4, CR6_EQ, 708 */
		/* 820FED44h case   21:*/		if ( !regs.CR[6].eq ) { return 0x820FF008;  }
		/* 820FED44h case   21:*/		return 0x820FED48;
	}
	return 0x820FED48;
} // Block from 820FECF0h-820FED48h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820FED48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FED48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FED48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FED48);
		  /* 820FED48h */ case    0:  		/* lwz R29, <#[R31 + 12]> */
		/* 820FED48h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FED48h case    0:*/		return 0x820FED4C;
		  /* 820FED4Ch */ case    1:  		/* li R30, 0 */
		/* 820FED4Ch case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820FED4Ch case    1:*/		return 0x820FED50;
	}
	return 0x820FED50;
} // Block from 820FED48h-820FED50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FED50h
// Function '?IsVarying@CProgram@D3DXShader@@AAAHI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FED50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FED50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FED50);
		  /* 820FED50h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 820FED50h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820FED50h case    0:*/		return 0x820FED54;
		  /* 820FED54h */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 820FED54h case    1:*/		if ( regs.CR[6].eq ) { return 0x820FED7C;  }
		/* 820FED54h case    1:*/		return 0x820FED58;
		  /* 820FED58h */ case    2:  		/* lwz R10, <#[R31 + 16]> */
		/* 820FED58h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820FED58h case    2:*/		return 0x820FED5C;
		  /* 820FED5Ch */ case    3:  		/* li R11, 0 */
		/* 820FED5Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820FED5Ch case    3:*/		return 0x820FED60;
		  /* 820FED60h */ case    4:  		/* lwzx R7, <#[R11 + R10]> */
		/* 820FED60h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FED60h case    4:*/		return 0x820FED64;
		  /* 820FED64h */ case    5:  		/* cmplw CR6, R7, R8 */
		/* 820FED64h case    5:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 820FED64h case    5:*/		return 0x820FED68;
		  /* 820FED68h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 820FED68h case    6:*/		if ( regs.CR[6].eq ) { return 0x820FED7C;  }
		/* 820FED68h case    6:*/		return 0x820FED6C;
		  /* 820FED6Ch */ case    7:  		/* addi R30, R30, 1 */
		/* 820FED6Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820FED6Ch case    7:*/		return 0x820FED70;
		  /* 820FED70h */ case    8:  		/* addi R11, R11, 4 */
		/* 820FED70h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820FED70h case    8:*/		return 0x820FED74;
		  /* 820FED74h */ case    9:  		/* cmplw CR6, R30, R29 */
		/* 820FED74h case    9:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R29);
		/* 820FED74h case    9:*/		return 0x820FED78;
		  /* 820FED78h */ case   10:  		/* bc 12, CR6_LT, -24 */
		/* 820FED78h case   10:*/		if ( regs.CR[6].lt ) { return 0x820FED60;  }
		/* 820FED78h case   10:*/		return 0x820FED7C;
	}
	return 0x820FED7C;
} // Block from 820FED50h-820FED7Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FED7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FED7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FED7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FED7C);
		  /* 820FED7Ch */ case    0:  		/* li R3, 0 */
		/* 820FED7Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FED7Ch case    0:*/		return 0x820FED80;
		  /* 820FED80h */ case    1:  		/* li R7, 0 */
		/* 820FED80h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820FED80h case    1:*/		return 0x820FED84;
		  /* 820FED84h */ case    2:  		/* cmplw CR6, R9, R6 */
		/* 820FED84h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R6);
		/* 820FED84h case    2:*/		return 0x820FED88;
		  /* 820FED88h */ case    3:  		/* bc 4, CR6_EQ, 56 */
		/* 820FED88h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820FEDC0;  }
		/* 820FED88h case    3:*/		return 0x820FED8C;
		  /* 820FED8Ch */ case    4:  		/* li R6, 0 */
		/* 820FED8Ch case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820FED8Ch case    4:*/		return 0x820FED90;
		  /* 820FED90h */ case    5:  		/* lwz R4, <#[R25 + 120]> */
		/* 820FED90h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R25 + 0x00000078) );
		/* 820FED90h case    5:*/		return 0x820FED94;
		  /* 820FED94h */ case    6:  		/* li R5, 0 */
		/* 820FED94h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820FED94h case    6:*/		return 0x820FED98;
		  /* 820FED98h */ case    7:  		/* mr R3, R25 */
		/* 820FED98h case    7:*/		regs.R3 = regs.R25;
		/* 820FED98h case    7:*/		return 0x820FED9C;
		  /* 820FED9Ch */ case    8:  		/* bl -7028 */
		/* 820FED9Ch case    8:*/		regs.LR = 0x820FEDA0; return 0x820FD228;
		/* 820FED9Ch case    8:*/		return 0x820FEDA0;
		  /* 820FEDA0h */ case    9:  		/* lwz R11, <#[R31 + 8]> */
		/* 820FEDA0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820FEDA0h case    9:*/		return 0x820FEDA4;
		  /* 820FEDA4h */ case   10:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 820FEDA4h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 820FEDA4h case   10:*/		return 0x820FEDA8;
		  /* 820FEDA8h */ case   11:  		/* cmpwi CR6, R3, -1 */
		/* 820FEDA8h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820FEDA8h case   11:*/		return 0x820FEDAC;
		  /* 820FEDACh */ case   12:  		/* lwzx R7, <#[R10 + R11]> */
		/* 820FEDACh case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820FEDACh case   12:*/		return 0x820FEDB0;
	}
	return 0x820FEDB0;
} // Block from 820FED7Ch-820FEDB0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FEDB0h
// Function '?MergePredicates@CProgram@D3DXShader@@AAAJPAIPAHIH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEDB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEDB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEDB0);
		  /* 820FEDB0h */ case    0:  		/* bc 4, CR6_EQ, 212 */
		/* 820FEDB0h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820FEE84;  }
		/* 820FEDB0h case    0:*/		return 0x820FEDB4;
		  /* 820FEDB4h */ case    1:  		/* lis R3, -32761 */
		/* 820FEDB4h case    1:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820FEDB4h case    1:*/		return 0x820FEDB8;
		  /* 820FEDB8h */ case    2:  		/* ori R3, R3, 14 */
		/* 820FEDB8h case    2:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820FEDB8h case    2:*/		return 0x820FEDBC;
		  /* 820FEDBCh */ case    3:  		/* b 596 */
		/* 820FEDBCh case    3:*/		return 0x820FF010;
		/* 820FEDBCh case    3:*/		return 0x820FEDC0;
	}
	return 0x820FEDC0;
} // Block from 820FEDB0h-820FEDC0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FEDC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEDC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEDC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEDC0);
		  /* 820FEDC0h */ case    0:  		/* lwz R5, <#[R31 + 8]> */
		/* 820FEDC0h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000008) );
		/* 820FEDC0h case    0:*/		return 0x820FEDC4;
		  /* 820FEDC4h */ case    1:  		/* li R4, 0 */
		/* 820FEDC4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820FEDC4h case    1:*/		return 0x820FEDC8;
		  /* 820FEDC8h */ case    2:  		/* li R10, 1 */
		/* 820FEDC8h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820FEDC8h case    2:*/		return 0x820FEDCC;
		  /* 820FEDCCh */ case    3:  		/* mullw R11, R10, R29 */
		/* 820FEDCCh case    3:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R10,regs.R29);
		/* 820FEDCCh case    3:*/		return 0x820FEDD0;
		  /* 820FEDD0h */ case    4:  		/* add R11, R11, R30 */
		/* 820FEDD0h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 820FEDD0h case    4:*/		return 0x820FEDD4;
		  /* 820FEDD4h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FEDD4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FEDD4h case    5:*/		return 0x820FEDD8;
		  /* 820FEDD8h */ case    6:  		/* lwzx R8, <#[R11 + R5]> */
		/* 820FEDD8h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 820FEDD8h case    6:*/		return 0x820FEDDC;
		  /* 820FEDDCh */ case    7:  		/* rlwinm R11, R8, 2, 0, 29 */
		/* 820FEDDCh case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R8);
		/* 820FEDDCh case    7:*/		return 0x820FEDE0;
		  /* 820FEDE0h */ case    8:  		/* lwzx R11, <#[R11 + R26]> */
		/* 820FEDE0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 820FEDE0h case    8:*/		return 0x820FEDE4;
		  /* 820FEDE4h */ case    9:  		/* lwz R9, <#[R11 + 4]> */
		/* 820FEDE4h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820FEDE4h case    9:*/		return 0x820FEDE8;
		  /* 820FEDE8h */ case   10:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820FEDE8h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820FEDE8h case   10:*/		return 0x820FEDEC;
		  /* 820FEDECh */ case   11:  		/* lwzx R9, <#[R9 + R28]> */
		/* 820FEDECh case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R28 + 0x00000000) );
		/* 820FEDECh case   11:*/		return 0x820FEDF0;
		  /* 820FEDF0h */ case   12:  		/* lwz R9, <#[R9 + 4]> */
		/* 820FEDF0h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 820FEDF0h case   12:*/		return 0x820FEDF4;
		  /* 820FEDF4h */ case   13:  		/* rlwinm. R9, R9, 0, 30, 30 */
		/* 820FEDF4h case   13:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R9);
		/* 820FEDF4h case   13:*/		return 0x820FEDF8;
		  /* 820FEDF8h */ case   14:  		/* bc 12, CR0_EQ, 32 */
		/* 820FEDF8h case   14:*/		if ( regs.CR[0].eq ) { return 0x820FEE18;  }
		/* 820FEDF8h case   14:*/		return 0x820FEDFC;
		  /* 820FEDFCh */ case   15:  		/* lwz R11, <#[R11 + 72]> */
		/* 820FEDFCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 820FEDFCh case   15:*/		return 0x820FEE00;
		  /* 820FEE00h */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FEE00h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FEE00h case   16:*/		return 0x820FEE04;
		  /* 820FEE04h */ case   17:  		/* lwzx R11, <#[R11 + R27]> */
		/* 820FEE04h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 820FEE04h case   17:*/		return 0x820FEE08;
		  /* 820FEE08h */ case   18:  		/* lwz R9, <#[R11]> */
		/* 820FEE08h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820FEE08h case   18:*/		return 0x820FEE0C;
		  /* 820FEE0Ch */ case   19:  		/* rlwinm R9, R9, 0, 0, 11 */
		/* 820FEE0Ch case   19:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R9,regs.R9);
		/* 820FEE0Ch case   19:*/		return 0x820FEE10;
		  /* 820FEE10h */ case   20:  		/* cmplw CR6, R9, R6 */
		/* 820FEE10h case   20:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R6);
		/* 820FEE10h case   20:*/		return 0x820FEE14;
		  /* 820FEE14h */ case   21:  		/* bc 12, CR6_EQ, 24 */
		/* 820FEE14h case   21:*/		if ( regs.CR[6].eq ) { return 0x820FEE2C;  }
		/* 820FEE14h case   21:*/		return 0x820FEE18;
	}
	return 0x820FEE18;
} // Block from 820FEDC0h-820FEE18h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820FEE18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEE18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEE18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEE18);
		  /* 820FEE18h */ case    0:  		/* addi R4, R4, 1 */
		/* 820FEE18h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820FEE18h case    0:*/		return 0x820FEE1C;
		  /* 820FEE1Ch */ case    1:  		/* addi R10, R10, -1 */
		/* 820FEE1Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820FEE1Ch case    1:*/		return 0x820FEE20;
		  /* 820FEE20h */ case    2:  		/* cmplwi CR6, R4, 2 */
		/* 820FEE20h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000002);
		/* 820FEE20h case    2:*/		return 0x820FEE24;
		  /* 820FEE24h */ case    3:  		/* bc 12, CR6_LT, -88 */
		/* 820FEE24h case    3:*/		if ( regs.CR[6].lt ) { return 0x820FEDCC;  }
		/* 820FEE24h case    3:*/		return 0x820FEE28;
		  /* 820FEE28h */ case    4:  		/* b 84 */
		/* 820FEE28h case    4:*/		return 0x820FEE7C;
		/* 820FEE28h case    4:*/		return 0x820FEE2C;
	}
	return 0x820FEE2C;
} // Block from 820FEE18h-820FEE2Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FEE2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEE2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEE2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEE2C);
		  /* 820FEE2Ch */ case    0:  		/* lwz R6, <#[R11 + 12]> */
		/* 820FEE2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x0000000C) );
		/* 820FEE2Ch case    0:*/		return 0x820FEE30;
		  /* 820FEE30h */ case    1:  		/* li R9, 0 */
		/* 820FEE30h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820FEE30h case    1:*/		return 0x820FEE34;
		  /* 820FEE34h */ case    2:  		/* cmplwi CR6, R6, 0 */
		/* 820FEE34h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820FEE34h case    2:*/		return 0x820FEE38;
		  /* 820FEE38h */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 820FEE38h case    3:*/		if ( regs.CR[6].eq ) { return 0x820FEE60;  }
		/* 820FEE38h case    3:*/		return 0x820FEE3C;
		  /* 820FEE3Ch */ case    4:  		/* lwz R7, <#[R11 + 16]> */
		/* 820FEE3Ch case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000010) );
		/* 820FEE3Ch case    4:*/		return 0x820FEE40;
		  /* 820FEE40h */ case    5:  		/* li R10, 0 */
		/* 820FEE40h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820FEE40h case    5:*/		return 0x820FEE44;
		  /* 820FEE44h */ case    6:  		/* lwzx R3, <#[R10 + R7]> */
		/* 820FEE44h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 820FEE44h case    6:*/		return 0x820FEE48;
		  /* 820FEE48h */ case    7:  		/* cmplw CR6, R8, R3 */
		/* 820FEE48h case    7:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R3);
		/* 820FEE48h case    7:*/		return 0x820FEE4C;
		  /* 820FEE4Ch */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 820FEE4Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x820FEE60;  }
		/* 820FEE4Ch case    8:*/		return 0x820FEE50;
		  /* 820FEE50h */ case    9:  		/* addi R9, R9, 1 */
		/* 820FEE50h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820FEE50h case    9:*/		return 0x820FEE54;
		  /* 820FEE54h */ case   10:  		/* addi R10, R10, 4 */
		/* 820FEE54h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820FEE54h case   10:*/		return 0x820FEE58;
		  /* 820FEE58h */ case   11:  		/* cmplw CR6, R9, R6 */
		/* 820FEE58h case   11:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R6);
		/* 820FEE58h case   11:*/		return 0x820FEE5C;
		  /* 820FEE5Ch */ case   12:  		/* bc 12, CR6_LT, -24 */
		/* 820FEE5Ch case   12:*/		if ( regs.CR[6].lt ) { return 0x820FEE44;  }
		/* 820FEE5Ch case   12:*/		return 0x820FEE60;
	}
	return 0x820FEE60;
} // Block from 820FEE2Ch-820FEE60h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FEE60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEE60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEE60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEE60);
		  /* 820FEE60h */ case    0:  		/* mullw R10, R29, R4 */
		/* 820FEE60h case    0:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R29,regs.R4);
		/* 820FEE60h case    0:*/		return 0x820FEE64;
		  /* 820FEE64h */ case    1:  		/* lwz R11, <#[R11 + 8]> */
		/* 820FEE64h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820FEE64h case    1:*/		return 0x820FEE68;
		  /* 820FEE68h */ case    2:  		/* add R10, R10, R30 */
		/* 820FEE68h case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R30);
		/* 820FEE68h case    2:*/		return 0x820FEE6C;
		  /* 820FEE6Ch */ case    3:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820FEE6Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820FEE6Ch case    3:*/		return 0x820FEE70;
		  /* 820FEE70h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FEE70h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FEE70h case    4:*/		return 0x820FEE74;
		  /* 820FEE74h */ case    5:  		/* lwzx R7, <#[R9 + R11]> */
		/* 820FEE74h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820FEE74h case    5:*/		return 0x820FEE78;
		  /* 820FEE78h */ case    6:  		/* lwzx R3, <#[R10 + R5]> */
		/* 820FEE78h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 820FEE78h case    6:*/		return 0x820FEE7C;
	}
	return 0x820FEE7C;
} // Block from 820FEE60h-820FEE7Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820FEE7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEE7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEE7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEE7C);
		  /* 820FEE7Ch */ case    0:  		/* cmplwi CR6, R4, 2 */
		/* 820FEE7Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000002);
		/* 820FEE7Ch case    0:*/		return 0x820FEE80;
		  /* 820FEE80h */ case    1:  		/* bc 12, CR6_EQ, 392 */
		/* 820FEE80h case    1:*/		if ( regs.CR[6].eq ) { return 0x820FF008;  }
		/* 820FEE80h case    1:*/		return 0x820FEE84;
	}
	return 0x820FEE84;
} // Block from 820FEE7Ch-820FEE84h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FEE84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEE84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEE84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEE84);
		  /* 820FEE84h */ case    0:  		/* lwz R9, <#[R19]> */
		/* 820FEE84h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R19 + 0x00000000) );
		/* 820FEE84h case    0:*/		return 0x820FEE88;
		  /* 820FEE88h */ case    1:  		/* cmpwi CR6, R9, -1 */
		/* 820FEE88h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 820FEE88h case    1:*/		return 0x820FEE8C;
		  /* 820FEE8Ch */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 820FEE8Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820FEE98;  }
		/* 820FEE8Ch case    2:*/		return 0x820FEE90;
		  /* 820FEE90h */ case    3:  		/* cmplw CR6, R3, R9 */
		/* 820FEE90h case    3:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R9);
		/* 820FEE90h case    3:*/		return 0x820FEE94;
		  /* 820FEE94h */ case    4:  		/* bc 4, CR6_EQ, 180 */
		/* 820FEE94h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820FEF48;  }
		/* 820FEE94h case    4:*/		return 0x820FEE98;
	}
	return 0x820FEE98;
} // Block from 820FEE84h-820FEE98h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FEE98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEE98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEE98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEE98);
		  /* 820FEE98h */ case    0:  		/* lwz R11, <#[R25 + 20]> */
		/* 820FEE98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000014) );
		/* 820FEE98h case    0:*/		return 0x820FEE9C;
		  /* 820FEE9Ch */ case    1:  		/* rlwinm R10, R7, 2, 0, 29 */
		/* 820FEE9Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R7);
		/* 820FEE9Ch case    1:*/		return 0x820FEEA0;
		  /* 820FEEA0h */ case    2:  		/* lwz R8, <#[R25 + 16]> */
		/* 820FEEA0h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R25 + 0x00000010) );
		/* 820FEEA0h case    2:*/		return 0x820FEEA4;
		  /* 820FEEA4h */ case    3:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820FEEA4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820FEEA4h case    3:*/		return 0x820FEEA8;
		  /* 820FEEA8h */ case    4:  		/* lwz R6, <#[R11 + 4]> */
		/* 820FEEA8h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 820FEEA8h case    4:*/		return 0x820FEEAC;
		  /* 820FEEACh */ case    5:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820FEEACh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820FEEACh case    5:*/		return 0x820FEEB0;
		  /* 820FEEB0h */ case    6:  		/* lwzx R8, <#[R6 + R8]> */
		/* 820FEEB0h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + regs.R8 + 0x00000000) );
		/* 820FEEB0h case    6:*/		return 0x820FEEB4;
		  /* 820FEEB4h */ case    7:  		/* lwz R8, <#[R8 + 4]> */
		/* 820FEEB4h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 820FEEB4h case    7:*/		return 0x820FEEB8;
		  /* 820FEEB8h */ case    8:  		/* rlwinm. R8, R8, 0, 23, 23 */
		/* 820FEEB8h case    8:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R8,regs.R8);
		/* 820FEEB8h case    8:*/		return 0x820FEEBC;
		  /* 820FEEBCh */ case    9:  		/* bc 12, CR0_EQ, 140 */
		/* 820FEEBCh case    9:*/		if ( regs.CR[0].eq ) { return 0x820FEF48;  }
		/* 820FEEBCh case    9:*/		return 0x820FEEC0;
		  /* 820FEEC0h */ case   10:  		/* lwz R11, <#[R11 + 8]> */
		/* 820FEEC0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820FEEC0h case   10:*/		return 0x820FEEC4;
		  /* 820FEEC4h */ case   11:  		/* cmpwi CR6, R11, -1 */
		/* 820FEEC4h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FEEC4h case   11:*/		return 0x820FEEC8;
		  /* 820FEEC8h */ case   12:  		/* bc 4, CR6_EQ, 128 */
		/* 820FEEC8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820FEF48;  }
		/* 820FEEC8h case   12:*/		return 0x820FEECC;
		  /* 820FEECCh */ case   13:  		/* lfd FR0, <#[R24 + 32]> */
		/* 820FEECCh case   13:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R24 + 0x00000020) );
		/* 820FEECCh case   13:*/		return 0x820FEED0;
		  /* 820FEED0h */ case   14:  		/* fcmpu CR6, FR0, FR31 */
		/* 820FEED0h case   14:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 820FEED0h case   14:*/		return 0x820FEED4;
		  /* 820FEED4h */ case   15:  		/* bc 4, CR6_EQ, 60 */
		/* 820FEED4h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820FEF10;  }
		/* 820FEED4h case   15:*/		return 0x820FEED8;
		  /* 820FEED8h */ case   16:  		/* lwz R11, <#[R21]> */
		/* 820FEED8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820FEED8h case   16:*/		return 0x820FEEDC;
		  /* 820FEEDCh */ case   17:  		/* cmpwi CR6, R11, -1 */
		/* 820FEEDCh case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FEEDCh case   17:*/		return 0x820FEEE0;
		  /* 820FEEE0h */ case   18:  		/* bc 12, CR6_EQ, 36 */
		/* 820FEEE0h case   18:*/		if ( regs.CR[6].eq ) { return 0x820FEF04;  }
		/* 820FEEE0h case   18:*/		return 0x820FEEE4;
		  /* 820FEEE4h */ case   19:  		/* lwz R9, <#[R25 + 20]> */
		/* 820FEEE4h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000014) );
		/* 820FEEE4h case   19:*/		return 0x820FEEE8;
		  /* 820FEEE8h */ case   20:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FEEE8h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FEEE8h case   20:*/		return 0x820FEEEC;
		  /* 820FEEECh */ case   21:  		/* lwzx R10, <#[R9 + R10]> */
		/* 820FEEECh case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FEEECh case   21:*/		return 0x820FEEF0;
		  /* 820FEEF0h */ case   22:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820FEEF0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FEEF0h case   22:*/		return 0x820FEEF4;
		  /* 820FEEF4h */ case   23:  		/* lfd FR0, <#[R10 + 32]> */
		/* 820FEEF4h case   23:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 820FEEF4h case   23:*/		return 0x820FEEF8;
		  /* 820FEEF8h */ case   24:  		/* lfd FR13, <#[R11 + 32]> */
		/* 820FEEF8h case   24:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 820FEEF8h case   24:*/		return 0x820FEEFC;
		  /* 820FEEFCh */ case   25:  		/* fcmpu CR6, FR13, FR0 */
		/* 820FEEFCh case   25:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820FEEFCh case   25:*/		return 0x820FEF00;
		  /* 820FEF00h */ case   26:  		/* bc 4, CR6_LT, -1272 */
		/* 820FEF00h case   26:*/		if ( !regs.CR[6].lt ) { return 0x820FEA08;  }
		/* 820FEF00h case   26:*/		return 0x820FEF04;
	}
	return 0x820FEF04;
} // Block from 820FEE98h-820FEF04h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820FEF04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEF04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEF04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEF04);
		  /* 820FEF04h */ case    0:  		/* stw R3, <#[R19]> */
		/* 820FEF04h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R19 + 0x00000000) );
		/* 820FEF04h case    0:*/		return 0x820FEF08;
	}
	return 0x820FEF08;
} // Block from 820FEF04h-820FEF08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FEF08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEF08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEF08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEF08);
		  /* 820FEF08h */ case    0:  		/* stw R7, <#[R21]> */
		/* 820FEF08h case    0:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R21 + 0x00000000) );
		/* 820FEF08h case    0:*/		return 0x820FEF0C;
		  /* 820FEF0Ch */ case    1:  		/* b -1284 */
		/* 820FEF0Ch case    1:*/		return 0x820FEA08;
		/* 820FEF0Ch case    1:*/		return 0x820FEF10;
	}
	return 0x820FEF10;
} // Block from 820FEF08h-820FEF10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FEF10h
// Function '?MulSequence@CProgram@D3DXShader@@AAAHII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEF10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEF10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEF10);
		  /* 820FEF10h */ case    0:  		/* lwz R11, <#[R20]> */
		/* 820FEF10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 820FEF10h case    0:*/		return 0x820FEF14;
		  /* 820FEF14h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 820FEF14h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FEF14h case    1:*/		return 0x820FEF18;
		  /* 820FEF18h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820FEF18h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FEF3C;  }
		/* 820FEF18h case    2:*/		return 0x820FEF1C;
		  /* 820FEF1Ch */ case    3:  		/* lwz R9, <#[R25 + 20]> */
		/* 820FEF1Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000014) );
		/* 820FEF1Ch case    3:*/		return 0x820FEF20;
		  /* 820FEF20h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FEF20h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FEF20h case    4:*/		return 0x820FEF24;
		  /* 820FEF24h */ case    5:  		/* lwzx R10, <#[R9 + R10]> */
		/* 820FEF24h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FEF24h case    5:*/		return 0x820FEF28;
		  /* 820FEF28h */ case    6:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820FEF28h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FEF28h case    6:*/		return 0x820FEF2C;
		  /* 820FEF2Ch */ case    7:  		/* lfd FR0, <#[R10 + 32]> */
		/* 820FEF2Ch case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 820FEF2Ch case    7:*/		return 0x820FEF30;
		  /* 820FEF30h */ case    8:  		/* lfd FR13, <#[R11 + 32]> */
		/* 820FEF30h case    8:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 820FEF30h case    8:*/		return 0x820FEF34;
		  /* 820FEF34h */ case    9:  		/* fcmpu CR6, FR13, FR0 */
		/* 820FEF34h case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820FEF34h case    9:*/		return 0x820FEF38;
		  /* 820FEF38h */ case   10:  		/* bc 4, CR6_GT, -1328 */
		/* 820FEF38h case   10:*/		if ( !regs.CR[6].gt ) { return 0x820FEA08;  }
		/* 820FEF38h case   10:*/		return 0x820FEF3C;
	}
	return 0x820FEF3C;
} // Block from 820FEF10h-820FEF3Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FEF3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEF3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEF3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEF3C);
		  /* 820FEF3Ch */ case    0:  		/* stw R3, <#[R19]> */
		/* 820FEF3Ch case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R19 + 0x00000000) );
		/* 820FEF3Ch case    0:*/		return 0x820FEF40;
	}
	return 0x820FEF40;
} // Block from 820FEF3Ch-820FEF40h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FEF40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEF40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEF40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEF40);
		  /* 820FEF40h */ case    0:  		/* stw R7, <#[R20]> */
		/* 820FEF40h case    0:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R20 + 0x00000000) );
		/* 820FEF40h case    0:*/		return 0x820FEF44;
		  /* 820FEF44h */ case    1:  		/* b -1340 */
		/* 820FEF44h case    1:*/		return 0x820FEA08;
		/* 820FEF44h case    1:*/		return 0x820FEF48;
	}
	return 0x820FEF48;
} // Block from 820FEF40h-820FEF48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FEF48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEF48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEF48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEF48);
		  /* 820FEF48h */ case    0:  		/* cmpwi CR6, R9, -1 */
		/* 820FEF48h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 820FEF48h case    0:*/		return 0x820FEF4C;
		  /* 820FEF4Ch */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820FEF4Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820FEF58;  }
		/* 820FEF4Ch case    1:*/		return 0x820FEF50;
		  /* 820FEF50h */ case    2:  		/* cmplw CR6, R7, R9 */
		/* 820FEF50h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R9);
		/* 820FEF50h case    2:*/		return 0x820FEF54;
		  /* 820FEF54h */ case    3:  		/* bc 4, CR6_EQ, 180 */
		/* 820FEF54h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820FF008;  }
		/* 820FEF54h case    3:*/		return 0x820FEF58;
	}
	return 0x820FEF58;
} // Block from 820FEF48h-820FEF58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FEF58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEF58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEF58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEF58);
		  /* 820FEF58h */ case    0:  		/* lwz R11, <#[R25 + 20]> */
		/* 820FEF58h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000014) );
		/* 820FEF58h case    0:*/		return 0x820FEF5C;
		  /* 820FEF5Ch */ case    1:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820FEF5Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820FEF5Ch case    1:*/		return 0x820FEF60;
		  /* 820FEF60h */ case    2:  		/* lwz R9, <#[R25 + 16]> */
		/* 820FEF60h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000010) );
		/* 820FEF60h case    2:*/		return 0x820FEF64;
		  /* 820FEF64h */ case    3:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820FEF64h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820FEF64h case    3:*/		return 0x820FEF68;
		  /* 820FEF68h */ case    4:  		/* lwz R8, <#[R11 + 4]> */
		/* 820FEF68h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 820FEF68h case    4:*/		return 0x820FEF6C;
		  /* 820FEF6Ch */ case    5:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820FEF6Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820FEF6Ch case    5:*/		return 0x820FEF70;
		  /* 820FEF70h */ case    6:  		/* lwzx R9, <#[R8 + R9]> */
		/* 820FEF70h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 820FEF70h case    6:*/		return 0x820FEF74;
		  /* 820FEF74h */ case    7:  		/* lwz R9, <#[R9 + 4]> */
		/* 820FEF74h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 820FEF74h case    7:*/		return 0x820FEF78;
		  /* 820FEF78h */ case    8:  		/* rlwinm. R9, R9, 0, 23, 23 */
		/* 820FEF78h case    8:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R9,regs.R9);
		/* 820FEF78h case    8:*/		return 0x820FEF7C;
		  /* 820FEF7Ch */ case    9:  		/* bc 12, CR0_EQ, 140 */
		/* 820FEF7Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x820FF008;  }
		/* 820FEF7Ch case    9:*/		return 0x820FEF80;
		  /* 820FEF80h */ case   10:  		/* lwz R11, <#[R11 + 8]> */
		/* 820FEF80h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820FEF80h case   10:*/		return 0x820FEF84;
		  /* 820FEF84h */ case   11:  		/* cmpwi CR6, R11, -1 */
		/* 820FEF84h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FEF84h case   11:*/		return 0x820FEF88;
		  /* 820FEF88h */ case   12:  		/* bc 4, CR6_EQ, 128 */
		/* 820FEF88h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820FF008;  }
		/* 820FEF88h case   12:*/		return 0x820FEF8C;
		  /* 820FEF8Ch */ case   13:  		/* lfd FR0, <#[R24 + 32]> */
		/* 820FEF8Ch case   13:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R24 + 0x00000020) );
		/* 820FEF8Ch case   13:*/		return 0x820FEF90;
		  /* 820FEF90h */ case   14:  		/* fcmpu CR6, FR0, FR31 */
		/* 820FEF90h case   14:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 820FEF90h case   14:*/		return 0x820FEF94;
		  /* 820FEF94h */ case   15:  		/* bc 4, CR6_EQ, 60 */
		/* 820FEF94h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820FEFD0;  }
		/* 820FEF94h case   15:*/		return 0x820FEF98;
		  /* 820FEF98h */ case   16:  		/* lwz R11, <#[R22]> */
		/* 820FEF98h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 820FEF98h case   16:*/		return 0x820FEF9C;
		  /* 820FEF9Ch */ case   17:  		/* cmpwi CR6, R11, -1 */
		/* 820FEF9Ch case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FEF9Ch case   17:*/		return 0x820FEFA0;
		  /* 820FEFA0h */ case   18:  		/* bc 12, CR6_EQ, 36 */
		/* 820FEFA0h case   18:*/		if ( regs.CR[6].eq ) { return 0x820FEFC4;  }
		/* 820FEFA0h case   18:*/		return 0x820FEFA4;
		  /* 820FEFA4h */ case   19:  		/* lwz R9, <#[R25 + 20]> */
		/* 820FEFA4h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000014) );
		/* 820FEFA4h case   19:*/		return 0x820FEFA8;
		  /* 820FEFA8h */ case   20:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FEFA8h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FEFA8h case   20:*/		return 0x820FEFAC;
		  /* 820FEFACh */ case   21:  		/* lwzx R10, <#[R9 + R10]> */
		/* 820FEFACh case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FEFACh case   21:*/		return 0x820FEFB0;
		  /* 820FEFB0h */ case   22:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820FEFB0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FEFB0h case   22:*/		return 0x820FEFB4;
		  /* 820FEFB4h */ case   23:  		/* lfd FR0, <#[R10 + 32]> */
		/* 820FEFB4h case   23:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 820FEFB4h case   23:*/		return 0x820FEFB8;
		  /* 820FEFB8h */ case   24:  		/* lfd FR13, <#[R11 + 32]> */
		/* 820FEFB8h case   24:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 820FEFB8h case   24:*/		return 0x820FEFBC;
		  /* 820FEFBCh */ case   25:  		/* fcmpu CR6, FR13, FR0 */
		/* 820FEFBCh case   25:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820FEFBCh case   25:*/		return 0x820FEFC0;
		  /* 820FEFC0h */ case   26:  		/* bc 4, CR6_GT, -1464 */
		/* 820FEFC0h case   26:*/		if ( !regs.CR[6].gt ) { return 0x820FEA08;  }
		/* 820FEFC0h case   26:*/		return 0x820FEFC4;
	}
	return 0x820FEFC4;
} // Block from 820FEF58h-820FEFC4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820FEFC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEFC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEFC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEFC4);
		  /* 820FEFC4h */ case    0:  		/* stw R7, <#[R19]> */
		/* 820FEFC4h case    0:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R19 + 0x00000000) );
		/* 820FEFC4h case    0:*/		return 0x820FEFC8;
		  /* 820FEFC8h */ case    1:  		/* stw R3, <#[R22]> */
		/* 820FEFC8h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R22 + 0x00000000) );
		/* 820FEFC8h case    1:*/		return 0x820FEFCC;
		  /* 820FEFCCh */ case    2:  		/* b -1476 */
		/* 820FEFCCh case    2:*/		return 0x820FEA08;
		/* 820FEFCCh case    2:*/		return 0x820FEFD0;
	}
	return 0x820FEFD0;
} // Block from 820FEFC4h-820FEFD0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FEFD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEFD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEFD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEFD0);
		  /* 820FEFD0h */ case    0:  		/* lwz R11, <#[R23]> */
		/* 820FEFD0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 820FEFD0h case    0:*/		return 0x820FEFD4;
		  /* 820FEFD4h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 820FEFD4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FEFD4h case    1:*/		return 0x820FEFD8;
		  /* 820FEFD8h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820FEFD8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FEFFC;  }
		/* 820FEFD8h case    2:*/		return 0x820FEFDC;
		  /* 820FEFDCh */ case    3:  		/* lwz R9, <#[R25 + 20]> */
		/* 820FEFDCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000014) );
		/* 820FEFDCh case    3:*/		return 0x820FEFE0;
		  /* 820FEFE0h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FEFE0h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FEFE0h case    4:*/		return 0x820FEFE4;
		  /* 820FEFE4h */ case    5:  		/* lwzx R10, <#[R9 + R10]> */
		/* 820FEFE4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FEFE4h case    5:*/		return 0x820FEFE8;
		  /* 820FEFE8h */ case    6:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820FEFE8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FEFE8h case    6:*/		return 0x820FEFEC;
		  /* 820FEFECh */ case    7:  		/* lfd FR0, <#[R10 + 32]> */
		/* 820FEFECh case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 820FEFECh case    7:*/		return 0x820FEFF0;
		  /* 820FEFF0h */ case    8:  		/* lfd FR13, <#[R11 + 32]> */
		/* 820FEFF0h case    8:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 820FEFF0h case    8:*/		return 0x820FEFF4;
		  /* 820FEFF4h */ case    9:  		/* fcmpu CR6, FR13, FR0 */
		/* 820FEFF4h case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820FEFF4h case    9:*/		return 0x820FEFF8;
		  /* 820FEFF8h */ case   10:  		/* bc 4, CR6_LT, -1520 */
		/* 820FEFF8h case   10:*/		if ( !regs.CR[6].lt ) { return 0x820FEA08;  }
		/* 820FEFF8h case   10:*/		return 0x820FEFFC;
	}
	return 0x820FEFFC;
} // Block from 820FEFD0h-820FEFFCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FEFFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FEFFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FEFFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FEFFC);
		  /* 820FEFFCh */ case    0:  		/* stw R7, <#[R19]> */
		/* 820FEFFCh case    0:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R19 + 0x00000000) );
		/* 820FEFFCh case    0:*/		return 0x820FF000;
		  /* 820FF000h */ case    1:  		/* stw R3, <#[R23]> */
		/* 820FF000h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R23 + 0x00000000) );
		/* 820FF000h case    1:*/		return 0x820FF004;
		  /* 820FF004h */ case    2:  		/* b -1532 */
		/* 820FF004h case    2:*/		return 0x820FEA08;
		/* 820FF004h case    2:*/		return 0x820FF008;
	}
	return 0x820FF008;
} // Block from 820FEFFCh-820FF008h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FF008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF008);
		  /* 820FF008h */ case    0:  		/* lis R3, -32768 */
		/* 820FF008h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820FF008h case    0:*/		return 0x820FF00C;
		  /* 820FF00Ch */ case    1:  		/* ori R3, R3, 16389 */
		/* 820FF00Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820FF00Ch case    1:*/		return 0x820FF010;
	}
	return 0x820FF010;
} // Block from 820FF008h-820FF010h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FF010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF010);
		  /* 820FF010h */ case    0:  		/* addi R1, R1, 208 */
		/* 820FF010h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 820FF010h case    0:*/		return 0x820FF014;
		  /* 820FF014h */ case    1:  		/* lfd FR31, <#[R1 - 120]> */
		/* 820FF014h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF88) );
		/* 820FF014h case    1:*/		return 0x820FF018;
		  /* 820FF018h */ case    2:  		/* b -449940 */
		/* 820FF018h case    2:*/		return 0x82091284;
		/* 820FF018h case    2:*/		return 0x820FF01C;
		  /* 820FF01Ch */ case    3:  		/* nop */
		/* 820FF01Ch case    3:*/		cpu::op::nop();
		/* 820FF01Ch case    3:*/		return 0x820FF020;
		  /* 820FF020h */ case    4:  		/* lwz R9, <#[R3 + 20]> */
		/* 820FF020h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 820FF020h case    4:*/		return 0x820FF024;
		  /* 820FF024h */ case    5:  		/* rlwinm R10, R5, 2, 0, 29 */
		/* 820FF024h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R5);
		/* 820FF024h case    5:*/		return 0x820FF028;
		  /* 820FF028h */ case    6:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 820FF028h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 820FF028h case    6:*/		return 0x820FF02C;
		  /* 820FF02Ch */ case    7:  		/* lwzx R8, <#[R10 + R9]> */
		/* 820FF02Ch case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820FF02Ch case    7:*/		return 0x820FF030;
		  /* 820FF030h */ case    8:  		/* lwzx R9, <#[R9 + R11]> */
		/* 820FF030h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820FF030h case    8:*/		return 0x820FF034;
		  /* 820FF034h */ case    9:  		/* lwz R8, <#[R8 + 4]> */
		/* 820FF034h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 820FF034h case    9:*/		return 0x820FF038;
		  /* 820FF038h */ case   10:  		/* lwz R9, <#[R9 + 4]> */
		/* 820FF038h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 820FF038h case   10:*/		return 0x820FF03C;
		  /* 820FF03Ch */ case   11:  		/* cmplw CR6, R9, R8 */
		/* 820FF03Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820FF03Ch case   11:*/		return 0x820FF040;
		  /* 820FF040h */ case   12:  		/* bc 4, CR6_EQ, 120 */
		/* 820FF040h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820FF0B8;  }
		/* 820FF040h case   12:*/		return 0x820FF044;
		  /* 820FF044h */ case   13:  		/* lwz R9, <#[R3 + 20]> */
		/* 820FF044h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 820FF044h case   13:*/		return 0x820FF048;
		  /* 820FF048h */ case   14:  		/* lwzx R8, <#[R9 + R10]> */
		/* 820FF048h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FF048h case   14:*/		return 0x820FF04C;
		  /* 820FF04Ch */ case   15:  		/* lwzx R9, <#[R9 + R11]> */
		/* 820FF04Ch case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820FF04Ch case   15:*/		return 0x820FF050;
		  /* 820FF050h */ case   16:  		/* lwz R8, <#[R8 + 8]> */
		/* 820FF050h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000008) );
		/* 820FF050h case   16:*/		return 0x820FF054;
		  /* 820FF054h */ case   17:  		/* lwz R9, <#[R9 + 8]> */
		/* 820FF054h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 820FF054h case   17:*/		return 0x820FF058;
		  /* 820FF058h */ case   18:  		/* cmplw CR6, R9, R8 */
		/* 820FF058h case   18:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820FF058h case   18:*/		return 0x820FF05C;
		  /* 820FF05Ch */ case   19:  		/* bc 4, CR6_EQ, 92 */
		/* 820FF05Ch case   19:*/		if ( !regs.CR[6].eq ) { return 0x820FF0B8;  }
		/* 820FF05Ch case   19:*/		return 0x820FF060;
		  /* 820FF060h */ case   20:  		/* lwz R9, <#[R3 + 20]> */
		/* 820FF060h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 820FF060h case   20:*/		return 0x820FF064;
		  /* 820FF064h */ case   21:  		/* lwzx R8, <#[R9 + R10]> */
		/* 820FF064h case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FF064h case   21:*/		return 0x820FF068;
		  /* 820FF068h */ case   22:  		/* lwzx R9, <#[R9 + R11]> */
		/* 820FF068h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820FF068h case   22:*/		return 0x820FF06C;
		  /* 820FF06Ch */ case   23:  		/* lwz R8, <#[R8 + 12]> */
		/* 820FF06Ch case   23:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x0000000C) );
		/* 820FF06Ch case   23:*/		return 0x820FF070;
		  /* 820FF070h */ case   24:  		/* lwz R9, <#[R9 + 12]> */
		/* 820FF070h case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000000C) );
		/* 820FF070h case   24:*/		return 0x820FF074;
		  /* 820FF074h */ case   25:  		/* cmplw CR6, R9, R8 */
		/* 820FF074h case   25:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820FF074h case   25:*/		return 0x820FF078;
		  /* 820FF078h */ case   26:  		/* bc 4, CR6_EQ, 64 */
		/* 820FF078h case   26:*/		if ( !regs.CR[6].eq ) { return 0x820FF0B8;  }
		/* 820FF078h case   26:*/		return 0x820FF07C;
		  /* 820FF07Ch */ case   27:  		/* lwz R9, <#[R3 + 20]> */
		/* 820FF07Ch case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 820FF07Ch case   27:*/		return 0x820FF080;
		  /* 820FF080h */ case   28:  		/* lwzx R8, <#[R9 + R10]> */
		/* 820FF080h case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FF080h case   28:*/		return 0x820FF084;
		  /* 820FF084h */ case   29:  		/* lwzx R9, <#[R9 + R11]> */
		/* 820FF084h case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820FF084h case   29:*/		return 0x820FF088;
		  /* 820FF088h */ case   30:  		/* lwz R8, <#[R8 + 20]> */
		/* 820FF088h case   30:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000014) );
		/* 820FF088h case   30:*/		return 0x820FF08C;
		  /* 820FF08Ch */ case   31:  		/* lwz R9, <#[R9 + 20]> */
		/* 820FF08Ch case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000014) );
		/* 820FF08Ch case   31:*/		return 0x820FF090;
	}
	return 0x820FF090;
} // Block from 820FF010h-820FF090h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820FF090h
// Function '?AddSequence@CProgram@D3DXShader@@AAAJIPAIPAN@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF090);
		  /* 820FF090h */ case    0:  		/* cmplw CR6, R9, R8 */
		/* 820FF090h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820FF090h case    0:*/		return 0x820FF094;
		  /* 820FF094h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 820FF094h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820FF0B8;  }
		/* 820FF094h case    1:*/		return 0x820FF098;
		  /* 820FF098h */ case    2:  		/* lwz R9, <#[R3 + 20]> */
		/* 820FF098h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 820FF098h case    2:*/		return 0x820FF09C;
		  /* 820FF09Ch */ case    3:  		/* li R3, 1 */
		/* 820FF09Ch case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FF09Ch case    3:*/		return 0x820FF0A0;
		  /* 820FF0A0h */ case    4:  		/* lwzx R10, <#[R9 + R10]> */
		/* 820FF0A0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FF0A0h case    4:*/		return 0x820FF0A4;
		  /* 820FF0A4h */ case    5:  		/* lwzx R11, <#[R9 + R11]> */
		/* 820FF0A4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820FF0A4h case    5:*/		return 0x820FF0A8;
		  /* 820FF0A8h */ case    6:  		/* lwz R10, <#[R10 + 24]> */
		/* 820FF0A8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000018) );
		/* 820FF0A8h case    6:*/		return 0x820FF0AC;
		  /* 820FF0ACh */ case    7:  		/* lwz R11, <#[R11 + 24]> */
		/* 820FF0ACh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820FF0ACh case    7:*/		return 0x820FF0B0;
		  /* 820FF0B0h */ case    8:  		/* cmpw CR6, R11, R10 */
		/* 820FF0B0h case    8:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820FF0B0h case    8:*/		return 0x820FF0B4;
		  /* 820FF0B4h */ case    9:  		/* bclr 12, CR6_EQ */
		/* 820FF0B4h case    9:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820FF0B4h case    9:*/		return 0x820FF0B8;
	}
	return 0x820FF0B8;
} // Block from 820FF090h-820FF0B8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FF0B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF0B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF0B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF0B8);
		  /* 820FF0B8h */ case    0:  		/* li R3, 0 */
		/* 820FF0B8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FF0B8h case    0:*/		return 0x820FF0BC;
		  /* 820FF0BCh */ case    1:  		/* bclr 20, CR0_LT */
		/* 820FF0BCh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FF0BCh case    1:*/		return 0x820FF0C0;
	}
	return 0x820FF0C0;
} // Block from 820FF0B8h-820FF0C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FF0C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF0C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF0C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF0C0);
		  /* 820FF0C0h */ case    0:  		/* mfspr R12, LR */
		/* 820FF0C0h case    0:*/		regs.R12 = regs.LR;
		/* 820FF0C0h case    0:*/		return 0x820FF0C4;
		  /* 820FF0C4h */ case    1:  		/* bl -450212 */
		/* 820FF0C4h case    1:*/		regs.LR = 0x820FF0C8; return 0x82091220;
		/* 820FF0C4h case    1:*/		return 0x820FF0C8;
		  /* 820FF0C8h */ case    2:  		/* stfd FR31, <#[R1 - 160]> */
		/* 820FF0C8h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 820FF0C8h case    2:*/		return 0x820FF0CC;
		  /* 820FF0CCh */ case    3:  		/* stwu R1, <#[R1 - 256]> */
		/* 820FF0CCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 820FF0CCh case    3:*/		return 0x820FF0D0;
		  /* 820FF0D0h */ case    4:  		/* lwz R11, <#[R4]> */
		/* 820FF0D0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820FF0D0h case    4:*/		return 0x820FF0D4;
		  /* 820FF0D4h */ case    5:  		/* li R10, 0 */
		/* 820FF0D4h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820FF0D4h case    5:*/		return 0x820FF0D8;
		  /* 820FF0D8h */ case    6:  		/* mr R27, R3 */
		/* 820FF0D8h case    6:*/		regs.R27 = regs.R3;
		/* 820FF0D8h case    6:*/		return 0x820FF0DC;
		  /* 820FF0DCh */ case    7:  		/* rlwinm. R28, R11, 0, 12, 31 */
		/* 820FF0DCh case    7:*/		cpu::op::rlwinm<1,0,12,31>(regs,&regs.R28,regs.R11);
		/* 820FF0DCh case    7:*/		return 0x820FF0E0;
		  /* 820FF0E0h */ case    8:  		/* stw R10, <#[R1 + 80]> */
		/* 820FF0E0h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820FF0E0h case    8:*/		return 0x820FF0E4;
		  /* 820FF0E4h */ case    9:  		/* mr R25, R4 */
		/* 820FF0E4h case    9:*/		regs.R25 = regs.R4;
		/* 820FF0E4h case    9:*/		return 0x820FF0E8;
		  /* 820FF0E8h */ case   10:  		/* stw R28, <#[R1 + 84]> */
		/* 820FF0E8h case   10:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 820FF0E8h case   10:*/		return 0x820FF0EC;
		  /* 820FF0ECh */ case   11:  		/* mr R15, R28 */
		/* 820FF0ECh case   11:*/		regs.R15 = regs.R28;
		/* 820FF0ECh case   11:*/		return 0x820FF0F0;
		  /* 820FF0F0h */ case   12:  		/* bc 12, CR0_EQ, 1476 */
		/* 820FF0F0h case   12:*/		if ( regs.CR[0].eq ) { return 0x820FF6B4;  }
		/* 820FF0F0h case   12:*/		return 0x820FF0F4;
		  /* 820FF0F4h */ case   13:  		/* lis R11, -32256 */
		/* 820FF0F4h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820FF0F4h case   13:*/		return 0x820FF0F8;
		  /* 820FF0F8h */ case   14:  		/* li R14, -1 */
		/* 820FF0F8h case   14:*/		cpu::op::li<0>(regs,&regs.R14,0xFFFFFFFF);
		/* 820FF0F8h case   14:*/		return 0x820FF0FC;
		  /* 820FF0FCh */ case   15:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 820FF0FCh case   15:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 820FF0FCh case   15:*/		return 0x820FF100;
		  /* 820FF100h */ case   16:  		/* li R23, 0 */
		/* 820FF100h case   16:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 820FF100h case   16:*/		return 0x820FF104;
		  /* 820FF104h */ case   17:  		/* li R22, 0 */
		/* 820FF104h case   17:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 820FF104h case   17:*/		return 0x820FF108;
		  /* 820FF108h */ case   18:  		/* li R21, 0 */
		/* 820FF108h case   18:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 820FF108h case   18:*/		return 0x820FF10C;
		  /* 820FF10Ch */ case   19:  		/* li R20, 0 */
		/* 820FF10Ch case   19:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 820FF10Ch case   19:*/		return 0x820FF110;
		  /* 820FF110h */ case   20:  		/* li R19, 0 */
		/* 820FF110h case   20:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 820FF110h case   20:*/		return 0x820FF114;
		  /* 820FF114h */ case   21:  		/* li R18, 0 */
		/* 820FF114h case   21:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 820FF114h case   21:*/		return 0x820FF118;
		  /* 820FF118h */ case   22:  		/* li R17, 0 */
		/* 820FF118h case   22:*/		cpu::op::li<0>(regs,&regs.R17,0x0);
		/* 820FF118h case   22:*/		return 0x820FF11C;
		  /* 820FF11Ch */ case   23:  		/* li R16, 0 */
		/* 820FF11Ch case   23:*/		cpu::op::li<0>(regs,&regs.R16,0x0);
		/* 820FF11Ch case   23:*/		return 0x820FF120;
		  /* 820FF120h */ case   24:  		/* li R24, 0 */
		/* 820FF120h case   24:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 820FF120h case   24:*/		return 0x820FF124;
		  /* 820FF124h */ case   25:  		/* cmplwi CR6, R15, 4 */
		/* 820FF124h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R15,0x00000004);
		/* 820FF124h case   25:*/		return 0x820FF128;
		  /* 820FF128h */ case   26:  		/* bc 4, CR6_GT, 416 */
		/* 820FF128h case   26:*/		if ( !regs.CR[6].gt ) { return 0x820FF2C8;  }
		/* 820FF128h case   26:*/		return 0x820FF12C;
		  /* 820FF12Ch */ case   27:  		/* cmplwi CR6, R28, 0 */
		/* 820FF12Ch case   27:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820FF12Ch case   27:*/		return 0x820FF130;
		  /* 820FF130h */ case   28:  		/* bc 12, CR6_EQ, 412 */
		/* 820FF130h case   28:*/		if ( regs.CR[6].eq ) { return 0x820FF2CC;  }
		/* 820FF130h case   28:*/		return 0x820FF134;
		  /* 820FF134h */ case   29:  		/* lwz R29, <#[R25 + 8]> */
		/* 820FF134h case   29:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R25 + 0x00000008) );
		/* 820FF134h case   29:*/		return 0x820FF138;
		  /* 820FF138h */ case   30:  		/* li R4, 1 */
		/* 820FF138h case   30:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820FF138h case   30:*/		return 0x820FF13C;
		  /* 820FF13Ch */ case   31:  		/* li R31, 4 */
		/* 820FF13Ch case   31:*/		cpu::op::li<0>(regs,&regs.R31,0x4);
		/* 820FF13Ch case   31:*/		return 0x820FF140;
		  /* 820FF140h */ case   32:  		/* rlwinm R30, R28, 2, 0, 29 */
		/* 820FF140h case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R28);
		/* 820FF140h case   32:*/		return 0x820FF144;
		  /* 820FF144h */ case   33:  		/* addi R26, R29, -4 */
		/* 820FF144h case   33:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R29,0xFFFFFFFC);
		/* 820FF144h case   33:*/		return 0x820FF148;
		  /* 820FF148h */ case   34:  		/* lwzx R11, <#[R26 + R31]> */
		/* 820FF148h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + regs.R31 + 0x00000000) );
		/* 820FF148h case   34:*/		return 0x820FF14C;
		  /* 820FF14Ch */ case   35:  		/* cmpwi CR6, R11, -1 */
		/* 820FF14Ch case   35:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FF14Ch case   35:*/		return 0x820FF150;
		  /* 820FF150h */ case   36:  		/* bc 12, CR6_EQ, 348 */
		/* 820FF150h case   36:*/		if ( regs.CR[6].eq ) { return 0x820FF2AC;  }
		/* 820FF150h case   36:*/		return 0x820FF154;
		  /* 820FF154h */ case   37:  		/* lwz R11, <#[R25 + 8]> */
		/* 820FF154h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 820FF154h case   37:*/		return 0x820FF158;
		  /* 820FF158h */ case   38:  		/* li R5, 1 */
		/* 820FF158h case   38:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820FF158h case   38:*/		return 0x820FF15C;
		  /* 820FF15Ch */ case   39:  		/* lwz R9, <#[R27 + 20]> */
		/* 820FF15Ch case   39:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000014) );
		/* 820FF15Ch case   39:*/		return 0x820FF160;
		  /* 820FF160h */ case   40:  		/* mr R3, R4 */
		/* 820FF160h case   40:*/		regs.R3 = regs.R4;
		/* 820FF160h case   40:*/		return 0x820FF164;
		  /* 820FF164h */ case   41:  		/* add R10, R11, R31 */
		/* 820FF164h case   41:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R31);
		/* 820FF164h case   41:*/		return 0x820FF168;
		  /* 820FF168h */ case   42:  		/* cmplw CR6, R4, R28 */
		/* 820FF168h case   42:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R28);
		/* 820FF168h case   42:*/		return 0x820FF16C;
		  /* 820FF16Ch */ case   43:  		/* lwzx R11, <#[R11 + R30]> */
		/* 820FF16Ch case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820FF16Ch case   43:*/		return 0x820FF170;
		  /* 820FF170h */ case   44:  		/* lwz R10, <#[R10 - 4]> */
		/* 820FF170h case   44:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 820FF170h case   44:*/		return 0x820FF174;
		  /* 820FF174h */ case   45:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FF174h case   45:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FF174h case   45:*/		return 0x820FF178;
		  /* 820FF178h */ case   46:  		/* rlwinm R8, R10, 2, 0, 29 */
		/* 820FF178h case   46:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R10);
		/* 820FF178h case   46:*/		return 0x820FF17C;
		  /* 820FF17Ch */ case   47:  		/* lwzx R10, <#[R11 + R9]> */
		/* 820FF17Ch case   47:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FF17Ch case   47:*/		return 0x820FF180;
		  /* 820FF180h */ case   48:  		/* lwzx R11, <#[R8 + R9]> */
		/* 820FF180h case   48:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 820FF180h case   48:*/		return 0x820FF184;
		  /* 820FF184h */ case   49:  		/* bc 4, CR6_LT, 244 */
		/* 820FF184h case   49:*/		if ( !regs.CR[6].lt ) { return 0x820FF278;  }
		/* 820FF184h case   49:*/		return 0x820FF188;
		  /* 820FF188h */ case   50:  		/* mr R6, R31 */
		/* 820FF188h case   50:*/		regs.R6 = regs.R31;
		/* 820FF188h case   50:*/		return 0x820FF18C;
		  /* 820FF18Ch */ case   51:  		/* addi R7, R30, 4 */
		/* 820FF18Ch case   51:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R30,0x4);
		/* 820FF18Ch case   51:*/		return 0x820FF190;
		  /* 820FF190h */ case   52:  		/* lwzx R9, <#[R29 + R7]> */
		/* 820FF190h case   52:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + regs.R7 + 0x00000000) );
		/* 820FF190h case   52:*/		return 0x820FF194;
		  /* 820FF194h */ case   53:  		/* cmpwi CR6, R9, -1 */
		/* 820FF194h case   53:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 820FF194h case   53:*/		return 0x820FF198;
		  /* 820FF198h */ case   54:  		/* bc 12, CR6_EQ, 192 */
		/* 820FF198h case   54:*/		if ( regs.CR[6].eq ) { return 0x820FF258;  }
		/* 820FF198h case   54:*/		return 0x820FF19C;
		  /* 820FF19Ch */ case   55:  		/* lwz R9, <#[R25 + 8]> */
		/* 820FF19Ch case   55:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000008) );
		/* 820FF19Ch case   55:*/		return 0x820FF1A0;
		  /* 820FF1A0h */ case   56:  		/* lwz R8, <#[R27 + 20]> */
		/* 820FF1A0h case   56:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000014) );
		/* 820FF1A0h case   56:*/		return 0x820FF1A4;
		  /* 820FF1A4h */ case   57:  		/* lwz R15, <#[R11 + 4]> */
		/* 820FF1A4h case   57:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R11 + 0x00000004) );
		/* 820FF1A4h case   57:*/		return 0x820FF1A8;
		  /* 820FF1A8h */ case   58:  		/* lwzx R14, <#[R9 + R6]> */
		/* 820FF1A8h case   58:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 820FF1A8h case   58:*/		return 0x820FF1AC;
		  /* 820FF1ACh */ case   59:  		/* lwzx R9, <#[R9 + R7]> */
		/* 820FF1ACh case   59:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 820FF1ACh case   59:*/		return 0x820FF1B0;
		  /* 820FF1B0h */ case   60:  		/* rlwinm R14, R14, 2, 0, 29 */
		/* 820FF1B0h case   60:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R14,regs.R14);
		/* 820FF1B0h case   60:*/		return 0x820FF1B4;
		  /* 820FF1B4h */ case   61:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820FF1B4h case   61:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820FF1B4h case   61:*/		return 0x820FF1B8;
		  /* 820FF1B8h */ case   62:  		/* stw R9, <#[R1 + 88]> */
		/* 820FF1B8h case   62:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 820FF1B8h case   62:*/		return 0x820FF1BC;
		  /* 820FF1BCh */ case   63:  		/* lwzx R9, <#[R14 + R8]> */
		/* 820FF1BCh case   63:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R14 + regs.R8 + 0x00000000) );
		/* 820FF1BCh case   63:*/		return 0x820FF1C0;
		  /* 820FF1C0h */ case   64:  		/* lwz R14, <#[R1 + 88]> */
		/* 820FF1C0h case   64:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R1 + 0x00000058) );
		/* 820FF1C0h case   64:*/		return 0x820FF1C4;
		  /* 820FF1C4h */ case   65:  		/* lwzx R8, <#[R14 + R8]> */
		/* 820FF1C4h case   65:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R14 + regs.R8 + 0x00000000) );
		/* 820FF1C4h case   65:*/		return 0x820FF1C8;
		  /* 820FF1C8h */ case   66:  		/* lwz R14, <#[R9 + 4]> */
		/* 820FF1C8h case   66:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R9 + 0x00000004) );
		/* 820FF1C8h case   66:*/		return 0x820FF1CC;
		  /* 820FF1CCh */ case   67:  		/* cmplw CR6, R15, R14 */
		/* 820FF1CCh case   67:*/		cpu::op::cmplw<6>(regs,regs.R15,regs.R14);
		/* 820FF1CCh case   67:*/		return 0x820FF1D0;
		  /* 820FF1D0h */ case   68:  		/* bc 4, CR6_EQ, 128 */
		/* 820FF1D0h case   68:*/		if ( !regs.CR[6].eq ) { return 0x820FF250;  }
		/* 820FF1D0h case   68:*/		return 0x820FF1D4;
		  /* 820FF1D4h */ case   69:  		/* lwz R15, <#[R11 + 8]> */
		/* 820FF1D4h case   69:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R11 + 0x00000008) );
		/* 820FF1D4h case   69:*/		return 0x820FF1D8;
		  /* 820FF1D8h */ case   70:  		/* lwz R14, <#[R9 + 8]> */
		/* 820FF1D8h case   70:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R9 + 0x00000008) );
		/* 820FF1D8h case   70:*/		return 0x820FF1DC;
		  /* 820FF1DCh */ case   71:  		/* cmplw CR6, R15, R14 */
		/* 820FF1DCh case   71:*/		cpu::op::cmplw<6>(regs,regs.R15,regs.R14);
		/* 820FF1DCh case   71:*/		return 0x820FF1E0;
		  /* 820FF1E0h */ case   72:  		/* bc 4, CR6_EQ, 112 */
		/* 820FF1E0h case   72:*/		if ( !regs.CR[6].eq ) { return 0x820FF250;  }
		/* 820FF1E0h case   72:*/		return 0x820FF1E4;
		  /* 820FF1E4h */ case   73:  		/* lwz R15, <#[R11 + 12]> */
		/* 820FF1E4h case   73:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R11 + 0x0000000C) );
		/* 820FF1E4h case   73:*/		return 0x820FF1E8;
		  /* 820FF1E8h */ case   74:  		/* lwz R14, <#[R9 + 12]> */
		/* 820FF1E8h case   74:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R9 + 0x0000000C) );
		/* 820FF1E8h case   74:*/		return 0x820FF1EC;
		  /* 820FF1ECh */ case   75:  		/* cmplw CR6, R15, R14 */
		/* 820FF1ECh case   75:*/		cpu::op::cmplw<6>(regs,regs.R15,regs.R14);
		/* 820FF1ECh case   75:*/		return 0x820FF1F0;
		  /* 820FF1F0h */ case   76:  		/* bc 4, CR6_EQ, 96 */
		/* 820FF1F0h case   76:*/		if ( !regs.CR[6].eq ) { return 0x820FF250;  }
		/* 820FF1F0h case   76:*/		return 0x820FF1F4;
		  /* 820FF1F4h */ case   77:  		/* lwz R15, <#[R11 + 72]> */
		/* 820FF1F4h case   77:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R11 + 0x00000048) );
		/* 820FF1F4h case   77:*/		return 0x820FF1F8;
		  /* 820FF1F8h */ case   78:  		/* lwz R9, <#[R9 + 72]> */
		/* 820FF1F8h case   78:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000048) );
		/* 820FF1F8h case   78:*/		return 0x820FF1FC;
		  /* 820FF1FCh */ case   79:  		/* cmplw CR6, R15, R9 */
		/* 820FF1FCh case   79:*/		cpu::op::cmplw<6>(regs,regs.R15,regs.R9);
		/* 820FF1FCh case   79:*/		return 0x820FF200;
		  /* 820FF200h */ case   80:  		/* bc 4, CR6_EQ, 80 */
		/* 820FF200h case   80:*/		if ( !regs.CR[6].eq ) { return 0x820FF250;  }
		/* 820FF200h case   80:*/		return 0x820FF204;
		  /* 820FF204h */ case   81:  		/* lwz R9, <#[R10 + 4]> */
		/* 820FF204h case   81:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 820FF204h case   81:*/		return 0x820FF208;
		  /* 820FF208h */ case   82:  		/* lwz R15, <#[R8 + 4]> */
		/* 820FF208h case   82:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R8 + 0x00000004) );
		/* 820FF208h case   82:*/		return 0x820FF20C;
		  /* 820FF20Ch */ case   83:  		/* cmplw CR6, R9, R15 */
		/* 820FF20Ch case   83:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R15);
		/* 820FF20Ch case   83:*/		return 0x820FF210;
		  /* 820FF210h */ case   84:  		/* bc 4, CR6_EQ, 64 */
		/* 820FF210h case   84:*/		if ( !regs.CR[6].eq ) { return 0x820FF250;  }
		/* 820FF210h case   84:*/		return 0x820FF214;
		  /* 820FF214h */ case   85:  		/* lwz R9, <#[R10 + 8]> */
		/* 820FF214h case   85:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 820FF214h case   85:*/		return 0x820FF218;
		  /* 820FF218h */ case   86:  		/* lwz R15, <#[R8 + 8]> */
		/* 820FF218h case   86:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R8 + 0x00000008) );
		/* 820FF218h case   86:*/		return 0x820FF21C;
		  /* 820FF21Ch */ case   87:  		/* cmplw CR6, R9, R15 */
		/* 820FF21Ch case   87:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R15);
		/* 820FF21Ch case   87:*/		return 0x820FF220;
		  /* 820FF220h */ case   88:  		/* bc 4, CR6_EQ, 48 */
		/* 820FF220h case   88:*/		if ( !regs.CR[6].eq ) { return 0x820FF250;  }
		/* 820FF220h case   88:*/		return 0x820FF224;
		  /* 820FF224h */ case   89:  		/* lwz R9, <#[R10 + 12]> */
		/* 820FF224h case   89:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		/* 820FF224h case   89:*/		return 0x820FF228;
		  /* 820FF228h */ case   90:  		/* lwz R15, <#[R8 + 12]> */
		/* 820FF228h case   90:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R8 + 0x0000000C) );
		/* 820FF228h case   90:*/		return 0x820FF22C;
		  /* 820FF22Ch */ case   91:  		/* cmplw CR6, R9, R15 */
		/* 820FF22Ch case   91:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R15);
		/* 820FF22Ch case   91:*/		return 0x820FF230;
		  /* 820FF230h */ case   92:  		/* bc 4, CR6_EQ, 32 */
		/* 820FF230h case   92:*/		if ( !regs.CR[6].eq ) { return 0x820FF250;  }
		/* 820FF230h case   92:*/		return 0x820FF234;
		  /* 820FF234h */ case   93:  		/* lwz R9, <#[R10 + 72]> */
		/* 820FF234h case   93:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000048) );
		/* 820FF234h case   93:*/		return 0x820FF238;
		  /* 820FF238h */ case   94:  		/* lwz R8, <#[R8 + 72]> */
		/* 820FF238h case   94:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000048) );
		/* 820FF238h case   94:*/		return 0x820FF23C;
		  /* 820FF23Ch */ case   95:  		/* cmplw CR6, R9, R8 */
		/* 820FF23Ch case   95:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820FF23Ch case   95:*/		return 0x820FF240;
		  /* 820FF240h */ case   96:  		/* bc 4, CR6_EQ, 16 */
		/* 820FF240h case   96:*/		if ( !regs.CR[6].eq ) { return 0x820FF250;  }
		/* 820FF240h case   96:*/		return 0x820FF244;
		  /* 820FF244h */ case   97:  		/* addi R5, R5, 1 */
		/* 820FF244h case   97:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820FF244h case   97:*/		return 0x820FF248;
		  /* 820FF248h */ case   98:  		/* cmplwi CR6, R5, 4 */
		/* 820FF248h case   98:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000004);
		/* 820FF248h case   98:*/		return 0x820FF24C;
		  /* 820FF24Ch */ case   99:  		/* bc 12, CR6_EQ, 36 */
		/* 820FF24Ch case   99:*/		if ( regs.CR[6].eq ) { return 0x820FF270;  }
		/* 820FF24Ch case   99:*/		return 0x820FF250;
	}
	return 0x820FF250;
} // Block from 820FF0C0h-820FF250h (100 instructions)

//////////////////////////////////////////////////////
// Block at 820FF250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF250);
		  /* 820FF250h */ case    0:  		/* lwz R15, <#[R1 + 84]> */
		/* 820FF250h case    0:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R1 + 0x00000054) );
		/* 820FF250h case    0:*/		return 0x820FF254;
		  /* 820FF254h */ case    1:  		/* li R14, -1 */
		/* 820FF254h case    1:*/		cpu::op::li<0>(regs,&regs.R14,0xFFFFFFFF);
		/* 820FF254h case    1:*/		return 0x820FF258;
	}
	return 0x820FF258;
} // Block from 820FF250h-820FF258h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FF258h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF258);
		  /* 820FF258h */ case    0:  		/* addi R3, R3, 1 */
		/* 820FF258h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 820FF258h case    0:*/		return 0x820FF25C;
		  /* 820FF25Ch */ case    1:  		/* addi R6, R6, 4 */
		/* 820FF25Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x4);
		/* 820FF25Ch case    1:*/		return 0x820FF260;
		  /* 820FF260h */ case    2:  		/* addi R7, R7, 4 */
		/* 820FF260h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 820FF260h case    2:*/		return 0x820FF264;
		  /* 820FF264h */ case    3:  		/* cmplw CR6, R3, R28 */
		/* 820FF264h case    3:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R28);
		/* 820FF264h case    3:*/		return 0x820FF268;
		  /* 820FF268h */ case    4:  		/* bc 12, CR6_LT, -216 */
		/* 820FF268h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FF190;  }
		/* 820FF268h case    4:*/		return 0x820FF26C;
		  /* 820FF26Ch */ case    5:  		/* b 12 */
		/* 820FF26Ch case    5:*/		return 0x820FF278;
		/* 820FF26Ch case    5:*/		return 0x820FF270;
	}
	return 0x820FF270;
} // Block from 820FF258h-820FF270h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FF270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF270);
		  /* 820FF270h */ case    0:  		/* lwz R15, <#[R1 + 84]> */
		/* 820FF270h case    0:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R1 + 0x00000054) );
		/* 820FF270h case    0:*/		return 0x820FF274;
		  /* 820FF274h */ case    1:  		/* li R14, -1 */
		/* 820FF274h case    1:*/		cpu::op::li<0>(regs,&regs.R14,0xFFFFFFFF);
		/* 820FF274h case    1:*/		return 0x820FF278;
	}
	return 0x820FF278;
} // Block from 820FF270h-820FF278h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FF278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF278);
		  /* 820FF278h */ case    0:  		/* cmplw CR6, R5, R24 */
		/* 820FF278h case    0:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R24);
		/* 820FF278h case    0:*/		return 0x820FF27C;
		  /* 820FF27Ch */ case    1:  		/* bc 4, CR6_GT, 40 */
		/* 820FF27Ch case    1:*/		if ( !regs.CR[6].gt ) { return 0x820FF2A4;  }
		/* 820FF27Ch case    1:*/		return 0x820FF280;
		  /* 820FF280h */ case    2:  		/* lwz R23, <#[R11 + 4]> */
		/* 820FF280h case    2:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R11 + 0x00000004) );
		/* 820FF280h case    2:*/		return 0x820FF284;
		  /* 820FF284h */ case    3:  		/* mr R24, R5 */
		/* 820FF284h case    3:*/		regs.R24 = regs.R5;
		/* 820FF284h case    3:*/		return 0x820FF288;
		  /* 820FF288h */ case    4:  		/* lwz R22, <#[R10 + 4]> */
		/* 820FF288h case    4:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R10 + 0x00000004) );
		/* 820FF288h case    4:*/		return 0x820FF28C;
		  /* 820FF28Ch */ case    5:  		/* lwz R21, <#[R11 + 8]> */
		/* 820FF28Ch case    5:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R11 + 0x00000008) );
		/* 820FF28Ch case    5:*/		return 0x820FF290;
		  /* 820FF290h */ case    6:  		/* lwz R20, <#[R10 + 8]> */
		/* 820FF290h case    6:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R10 + 0x00000008) );
		/* 820FF290h case    6:*/		return 0x820FF294;
		  /* 820FF294h */ case    7:  		/* lwz R19, <#[R11 + 12]> */
		/* 820FF294h case    7:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R11 + 0x0000000C) );
		/* 820FF294h case    7:*/		return 0x820FF298;
		  /* 820FF298h */ case    8:  		/* lwz R18, <#[R10 + 12]> */
		/* 820FF298h case    8:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R10 + 0x0000000C) );
		/* 820FF298h case    8:*/		return 0x820FF29C;
		  /* 820FF29Ch */ case    9:  		/* lwz R17, <#[R11 + 72]> */
		/* 820FF29Ch case    9:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R11 + 0x00000048) );
		/* 820FF29Ch case    9:*/		return 0x820FF2A0;
		  /* 820FF2A0h */ case   10:  		/* lwz R16, <#[R10 + 72]> */
		/* 820FF2A0h case   10:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R10 + 0x00000048) );
		/* 820FF2A0h case   10:*/		return 0x820FF2A4;
	}
	return 0x820FF2A4;
} // Block from 820FF278h-820FF2A4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FF2A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF2A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF2A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF2A4);
		  /* 820FF2A4h */ case    0:  		/* cmplwi CR6, R24, 4 */
		/* 820FF2A4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000004);
		/* 820FF2A4h case    0:*/		return 0x820FF2A8;
		  /* 820FF2A8h */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 820FF2A8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820FF2CC;  }
		/* 820FF2A8h case    1:*/		return 0x820FF2AC;
	}
	return 0x820FF2AC;
} // Block from 820FF2A4h-820FF2ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FF2ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF2AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF2AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF2AC);
		  /* 820FF2ACh */ case    0:  		/* addi R4, R4, 1 */
		/* 820FF2ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820FF2ACh case    0:*/		return 0x820FF2B0;
		  /* 820FF2B0h */ case    1:  		/* addi R30, R30, 4 */
		/* 820FF2B0h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820FF2B0h case    1:*/		return 0x820FF2B4;
		  /* 820FF2B4h */ case    2:  		/* addi R11, R4, -1 */
		/* 820FF2B4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0xFFFFFFFF);
		/* 820FF2B4h case    2:*/		return 0x820FF2B8;
		  /* 820FF2B8h */ case    3:  		/* addi R31, R31, 4 */
		/* 820FF2B8h case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820FF2B8h case    3:*/		return 0x820FF2BC;
		  /* 820FF2BCh */ case    4:  		/* cmplw CR6, R11, R28 */
		/* 820FF2BCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 820FF2BCh case    4:*/		return 0x820FF2C0;
		  /* 820FF2C0h */ case    5:  		/* bc 12, CR6_LT, -376 */
		/* 820FF2C0h case    5:*/		if ( regs.CR[6].lt ) { return 0x820FF148;  }
		/* 820FF2C0h case    5:*/		return 0x820FF2C4;
		  /* 820FF2C4h */ case    6:  		/* b 8 */
		/* 820FF2C4h case    6:*/		return 0x820FF2CC;
		/* 820FF2C4h case    6:*/		return 0x820FF2C8;
	}
	return 0x820FF2C8;
} // Block from 820FF2ACh-820FF2C8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820FF2C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF2C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF2C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF2C8);
		  /* 820FF2C8h */ case    0:  		/* mr R24, R15 */
		/* 820FF2C8h case    0:*/		regs.R24 = regs.R15;
		/* 820FF2C8h case    0:*/		return 0x820FF2CC;
	}
	return 0x820FF2CC;
} // Block from 820FF2C8h-820FF2CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FF2CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF2CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF2CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF2CC);
		  /* 820FF2CCh */ case    0:  		/* li R11, 5 */
		/* 820FF2CCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820FF2CCh case    0:*/		return 0x820FF2D0;
		  /* 820FF2D0h */ case    1:  		/* mr R4, R24 */
		/* 820FF2D0h case    1:*/		regs.R4 = regs.R24;
		/* 820FF2D0h case    1:*/		return 0x820FF2D4;
		  /* 820FF2D4h */ case    2:  		/* mr R6, R14 */
		/* 820FF2D4h case    2:*/		regs.R6 = regs.R14;
		/* 820FF2D4h case    2:*/		return 0x820FF2D8;
		  /* 820FF2D8h */ case    3:  		/* rlwimi R4, R11, 28, 0, 11 */
		/* 820FF2D8h case    3:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R4,regs.R11);
		/* 820FF2D8h case    3:*/		return 0x820FF2DC;
		  /* 820FF2DCh */ case    4:  		/* mr R5, R14 */
		/* 820FF2DCh case    4:*/		regs.R5 = regs.R14;
		/* 820FF2DCh case    4:*/		return 0x820FF2E0;
		  /* 820FF2E0h */ case    5:  		/* mr R3, R27 */
		/* 820FF2E0h case    5:*/		regs.R3 = regs.R27;
		/* 820FF2E0h case    5:*/		return 0x820FF2E4;
		  /* 820FF2E4h */ case    6:  		/* bl -8220 */
		/* 820FF2E4h case    6:*/		regs.LR = 0x820FF2E8; return 0x820FD2C8;
		/* 820FF2E4h case    6:*/		return 0x820FF2E8;
		  /* 820FF2E8h */ case    7:  		/* cmpwi CR6, R3, -1 */
		/* 820FF2E8h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820FF2E8h case    7:*/		return 0x820FF2EC;
		  /* 820FF2ECh */ case    8:  		/* bc 12, CR6_EQ, 540 */
		/* 820FF2ECh case    8:*/		if ( regs.CR[6].eq ) { return 0x820FF508;  }
		/* 820FF2ECh case    8:*/		return 0x820FF2F0;
		  /* 820FF2F0h */ case    9:  		/* lwz R11, <#[R27 + 24]> */
		/* 820FF2F0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000018) );
		/* 820FF2F0h case    9:*/		return 0x820FF2F4;
		  /* 820FF2F4h */ case   10:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820FF2F4h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820FF2F4h case   10:*/		return 0x820FF2F8;
		  /* 820FF2F8h */ case   11:  		/* mr R4, R25 */
		/* 820FF2F8h case   11:*/		regs.R4 = regs.R25;
		/* 820FF2F8h case   11:*/		return 0x820FF2FC;
		  /* 820FF2FCh */ case   12:  		/* lwzx R31, <#[R10 + R11]> */
		/* 820FF2FCh case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820FF2FCh case   12:*/		return 0x820FF300;
		  /* 820FF300h */ case   13:  		/* mr R3, R31 */
		/* 820FF300h case   13:*/		regs.R3 = regs.R31;
		/* 820FF300h case   13:*/		return 0x820FF304;
		  /* 820FF304h */ case   14:  		/* bl -13332 */
		/* 820FF304h case   14:*/		regs.LR = 0x820FF308; return 0x820FBEF0;
		/* 820FF304h case   14:*/		return 0x820FF308;
		  /* 820FF308h */ case   15:  		/* li R5, 0 */
		/* 820FF308h case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820FF308h case   15:*/		return 0x820FF30C;
		  /* 820FF30Ch */ case   16:  		/* li R4, 0 */
		/* 820FF30Ch case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820FF30Ch case   16:*/		return 0x820FF310;
		  /* 820FF310h */ case   17:  		/* cmplwi CR6, R28, 0 */
		/* 820FF310h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820FF310h case   17:*/		return 0x820FF314;
		  /* 820FF314h */ case   18:  		/* bc 12, CR6_EQ, 260 */
		/* 820FF314h case   18:*/		if ( regs.CR[6].eq ) { return 0x820FF418;  }
		/* 820FF314h case   18:*/		return 0x820FF318;
		  /* 820FF318h */ case   19:  		/* li R11, 0 */
		/* 820FF318h case   19:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820FF318h case   19:*/		return 0x820FF31C;
		  /* 820FF31Ch */ case   20:  		/* li R7, 0 */
		/* 820FF31Ch case   20:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820FF31Ch case   20:*/		return 0x820FF320;
		  /* 820FF320h */ case   21:  		/* rlwinm R10, R28, 2, 0, 29 */
		/* 820FF320h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R28);
		/* 820FF320h case   21:*/		return 0x820FF324;
		  /* 820FF324h */ case   22:  		/* rlwinm R6, R24, 2, 0, 29 */
		/* 820FF324h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R24);
		/* 820FF324h case   22:*/		return 0x820FF328;
		  /* 820FF328h */ case   23:  		/* cmplw CR6, R5, R24 */
		/* 820FF328h case   23:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R24);
		/* 820FF328h case   23:*/		return 0x820FF32C;
		  /* 820FF32Ch */ case   24:  		/* bc 4, CR6_LT, 236 */
		/* 820FF32Ch case   24:*/		if ( !regs.CR[6].lt ) { return 0x820FF418;  }
		/* 820FF32Ch case   24:*/		return 0x820FF330;
		  /* 820FF330h */ case   25:  		/* lwz R9, <#[R25 + 8]> */
		/* 820FF330h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000008) );
		/* 820FF330h case   25:*/		return 0x820FF334;
		  /* 820FF334h */ case   26:  		/* lwzx R9, <#[R9 + R11]> */
		/* 820FF334h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820FF334h case   26:*/		return 0x820FF338;
		  /* 820FF338h */ case   27:  		/* cmpwi CR6, R9, -1 */
		/* 820FF338h case   27:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 820FF338h case   27:*/		return 0x820FF33C;
		  /* 820FF33Ch */ case   28:  		/* bc 12, CR6_EQ, 200 */
		/* 820FF33Ch case   28:*/		if ( regs.CR[6].eq ) { return 0x820FF404;  }
		/* 820FF33Ch case   28:*/		return 0x820FF340;
		  /* 820FF340h */ case   29:  		/* lwz R9, <#[R25 + 8]> */
		/* 820FF340h case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000008) );
		/* 820FF340h case   29:*/		return 0x820FF344;
		  /* 820FF344h */ case   30:  		/* cmplwi CR6, R15, 4 */
		/* 820FF344h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R15,0x00000004);
		/* 820FF344h case   30:*/		return 0x820FF348;
		  /* 820FF348h */ case   31:  		/* lwz R8, <#[R27 + 20]> */
		/* 820FF348h case   31:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000014) );
		/* 820FF348h case   31:*/		return 0x820FF34C;
		  /* 820FF34Ch */ case   32:  		/* lwzx R3, <#[R9 + R11]> */
		/* 820FF34Ch case   32:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820FF34Ch case   32:*/		return 0x820FF350;
		  /* 820FF350h */ case   33:  		/* lwzx R9, <#[R9 + R10]> */
		/* 820FF350h case   33:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FF350h case   33:*/		return 0x820FF354;
		  /* 820FF354h */ case   34:  		/* rlwinm R3, R3, 2, 0, 29 */
		/* 820FF354h case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R3);
		/* 820FF354h case   34:*/		return 0x820FF358;
		  /* 820FF358h */ case   35:  		/* rlwinm R30, R9, 2, 0, 29 */
		/* 820FF358h case   35:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R9);
		/* 820FF358h case   35:*/		return 0x820FF35C;
		  /* 820FF35Ch */ case   36:  		/* lwzx R9, <#[R3 + R8]> */
		/* 820FF35Ch case   36:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + regs.R8 + 0x00000000) );
		/* 820FF35Ch case   36:*/		return 0x820FF360;
		  /* 820FF360h */ case   37:  		/* lwzx R8, <#[R30 + R8]> */
		/* 820FF360h case   37:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + regs.R8 + 0x00000000) );
		/* 820FF360h case   37:*/		return 0x820FF364;
		  /* 820FF364h */ case   38:  		/* bc 4, CR6_GT, 100 */
		/* 820FF364h case   38:*/		if ( !regs.CR[6].gt ) { return 0x820FF3C8;  }
		/* 820FF364h case   38:*/		return 0x820FF368;
		  /* 820FF368h */ case   39:  		/* lwz R3, <#[R9 + 4]> */
		/* 820FF368h case   39:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R9 + 0x00000004) );
		/* 820FF368h case   39:*/		return 0x820FF36C;
		  /* 820FF36Ch */ case   40:  		/* cmplw CR6, R23, R3 */
		/* 820FF36Ch case   40:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R3);
		/* 820FF36Ch case   40:*/		return 0x820FF370;
		  /* 820FF370h */ case   41:  		/* bc 4, CR6_EQ, 148 */
		/* 820FF370h case   41:*/		if ( !regs.CR[6].eq ) { return 0x820FF404;  }
		/* 820FF370h case   41:*/		return 0x820FF374;
		  /* 820FF374h */ case   42:  		/* lwz R3, <#[R9 + 8]> */
		/* 820FF374h case   42:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R9 + 0x00000008) );
		/* 820FF374h case   42:*/		return 0x820FF378;
		  /* 820FF378h */ case   43:  		/* cmplw CR6, R21, R3 */
		/* 820FF378h case   43:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R3);
		/* 820FF378h case   43:*/		return 0x820FF37C;
		  /* 820FF37Ch */ case   44:  		/* bc 4, CR6_EQ, 136 */
		/* 820FF37Ch case   44:*/		if ( !regs.CR[6].eq ) { return 0x820FF404;  }
		/* 820FF37Ch case   44:*/		return 0x820FF380;
		  /* 820FF380h */ case   45:  		/* lwz R3, <#[R9 + 12]> */
		/* 820FF380h case   45:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R9 + 0x0000000C) );
		/* 820FF380h case   45:*/		return 0x820FF384;
		  /* 820FF384h */ case   46:  		/* cmplw CR6, R19, R3 */
		/* 820FF384h case   46:*/		cpu::op::cmplw<6>(regs,regs.R19,regs.R3);
		/* 820FF384h case   46:*/		return 0x820FF388;
		  /* 820FF388h */ case   47:  		/* bc 4, CR6_EQ, 124 */
		/* 820FF388h case   47:*/		if ( !regs.CR[6].eq ) { return 0x820FF404;  }
		/* 820FF388h case   47:*/		return 0x820FF38C;
		  /* 820FF38Ch */ case   48:  		/* lwz R9, <#[R9 + 72]> */
		/* 820FF38Ch case   48:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000048) );
		/* 820FF38Ch case   48:*/		return 0x820FF390;
		  /* 820FF390h */ case   49:  		/* cmplw CR6, R17, R9 */
		/* 820FF390h case   49:*/		cpu::op::cmplw<6>(regs,regs.R17,regs.R9);
		/* 820FF390h case   49:*/		return 0x820FF394;
		  /* 820FF394h */ case   50:  		/* bc 4, CR6_EQ, 112 */
		/* 820FF394h case   50:*/		if ( !regs.CR[6].eq ) { return 0x820FF404;  }
		/* 820FF394h case   50:*/		return 0x820FF398;
		  /* 820FF398h */ case   51:  		/* lwz R9, <#[R8 + 4]> */
		/* 820FF398h case   51:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000004) );
		/* 820FF398h case   51:*/		return 0x820FF39C;
		  /* 820FF39Ch */ case   52:  		/* cmplw CR6, R22, R9 */
		/* 820FF39Ch case   52:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R9);
		/* 820FF39Ch case   52:*/		return 0x820FF3A0;
		  /* 820FF3A0h */ case   53:  		/* bc 4, CR6_EQ, 100 */
		/* 820FF3A0h case   53:*/		if ( !regs.CR[6].eq ) { return 0x820FF404;  }
		/* 820FF3A0h case   53:*/		return 0x820FF3A4;
		  /* 820FF3A4h */ case   54:  		/* lwz R9, <#[R8 + 8]> */
		/* 820FF3A4h case   54:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000008) );
		/* 820FF3A4h case   54:*/		return 0x820FF3A8;
		  /* 820FF3A8h */ case   55:  		/* cmplw CR6, R20, R9 */
		/* 820FF3A8h case   55:*/		cpu::op::cmplw<6>(regs,regs.R20,regs.R9);
		/* 820FF3A8h case   55:*/		return 0x820FF3AC;
		  /* 820FF3ACh */ case   56:  		/* bc 4, CR6_EQ, 88 */
		/* 820FF3ACh case   56:*/		if ( !regs.CR[6].eq ) { return 0x820FF404;  }
		/* 820FF3ACh case   56:*/		return 0x820FF3B0;
		  /* 820FF3B0h */ case   57:  		/* lwz R9, <#[R8 + 12]> */
		/* 820FF3B0h case   57:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x0000000C) );
		/* 820FF3B0h case   57:*/		return 0x820FF3B4;
		  /* 820FF3B4h */ case   58:  		/* cmplw CR6, R18, R9 */
		/* 820FF3B4h case   58:*/		cpu::op::cmplw<6>(regs,regs.R18,regs.R9);
		/* 820FF3B4h case   58:*/		return 0x820FF3B8;
		  /* 820FF3B8h */ case   59:  		/* bc 4, CR6_EQ, 76 */
		/* 820FF3B8h case   59:*/		if ( !regs.CR[6].eq ) { return 0x820FF404;  }
		/* 820FF3B8h case   59:*/		return 0x820FF3BC;
		  /* 820FF3BCh */ case   60:  		/* lwz R9, <#[R8 + 72]> */
		/* 820FF3BCh case   60:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000048) );
		/* 820FF3BCh case   60:*/		return 0x820FF3C0;
		  /* 820FF3C0h */ case   61:  		/* cmplw CR6, R16, R9 */
		/* 820FF3C0h case   61:*/		cpu::op::cmplw<6>(regs,regs.R16,regs.R9);
		/* 820FF3C0h case   61:*/		return 0x820FF3C4;
		  /* 820FF3C4h */ case   62:  		/* bc 4, CR6_EQ, 64 */
		/* 820FF3C4h case   62:*/		if ( !regs.CR[6].eq ) { return 0x820FF404;  }
		/* 820FF3C4h case   62:*/		return 0x820FF3C8;
	}
	return 0x820FF3C8;
} // Block from 820FF2CCh-820FF3C8h (63 instructions)

//////////////////////////////////////////////////////
// Block at 820FF3C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF3C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF3C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF3C8);
		  /* 820FF3C8h */ case    0:  		/* lwz R9, <#[R25 + 8]> */
		/* 820FF3C8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000008) );
		/* 820FF3C8h case    0:*/		return 0x820FF3CC;
		  /* 820FF3CCh */ case    1:  		/* addi R5, R5, 1 */
		/* 820FF3CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820FF3CCh case    1:*/		return 0x820FF3D0;
		  /* 820FF3D0h */ case    2:  		/* lwz R8, <#[R31 + 8]> */
		/* 820FF3D0h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 820FF3D0h case    2:*/		return 0x820FF3D4;
		  /* 820FF3D4h */ case    3:  		/* lwzx R9, <#[R9 + R11]> */
		/* 820FF3D4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820FF3D4h case    3:*/		return 0x820FF3D8;
		  /* 820FF3D8h */ case    4:  		/* stwx R9, <#[R8 + R7]> */
		/* 820FF3D8h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 820FF3D8h case    4:*/		return 0x820FF3DC;
		  /* 820FF3DCh */ case    5:  		/* addi R7, R7, 4 */
		/* 820FF3DCh case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 820FF3DCh case    5:*/		return 0x820FF3E0;
		  /* 820FF3E0h */ case    6:  		/* lwz R9, <#[R25 + 8]> */
		/* 820FF3E0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000008) );
		/* 820FF3E0h case    6:*/		return 0x820FF3E4;
		  /* 820FF3E4h */ case    7:  		/* lwzx R9, <#[R9 + R10]> */
		/* 820FF3E4h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FF3E4h case    7:*/		return 0x820FF3E8;
		  /* 820FF3E8h */ case    8:  		/* lwz R8, <#[R31 + 8]> */
		/* 820FF3E8h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 820FF3E8h case    8:*/		return 0x820FF3EC;
		  /* 820FF3ECh */ case    9:  		/* stwx R9, <#[R8 + R6]> */
		/* 820FF3ECh case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + regs.R6 + 0x00000000) );
		/* 820FF3ECh case    9:*/		return 0x820FF3F0;
		  /* 820FF3F0h */ case   10:  		/* addi R6, R6, 4 */
		/* 820FF3F0h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x4);
		/* 820FF3F0h case   10:*/		return 0x820FF3F4;
		  /* 820FF3F4h */ case   11:  		/* lwz R9, <#[R25 + 8]> */
		/* 820FF3F4h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000008) );
		/* 820FF3F4h case   11:*/		return 0x820FF3F8;
		  /* 820FF3F8h */ case   12:  		/* stwx R14, <#[R9 + R11]> */
		/* 820FF3F8h case   12:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820FF3F8h case   12:*/		return 0x820FF3FC;
		  /* 820FF3FCh */ case   13:  		/* lwz R9, <#[R25 + 8]> */
		/* 820FF3FCh case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000008) );
		/* 820FF3FCh case   13:*/		return 0x820FF400;
		  /* 820FF400h */ case   14:  		/* stwx R14, <#[R9 + R10]> */
		/* 820FF400h case   14:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FF400h case   14:*/		return 0x820FF404;
	}
	return 0x820FF404;
} // Block from 820FF3C8h-820FF404h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820FF404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF404);
		  /* 820FF404h */ case    0:  		/* addi R4, R4, 1 */
		/* 820FF404h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820FF404h case    0:*/		return 0x820FF408;
	}
	return 0x820FF408;
} // Block from 820FF404h-820FF408h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FF408h
// Function '?RangeSequence@CProgram@D3DXShader@@AAAJIPAI0000@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF408);
		  /* 820FF408h */ case    0:  		/* addi R11, R11, 4 */
		/* 820FF408h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820FF408h case    0:*/		return 0x820FF40C;
		  /* 820FF40Ch */ case    1:  		/* addi R10, R10, 4 */
		/* 820FF40Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820FF40Ch case    1:*/		return 0x820FF410;
		  /* 820FF410h */ case    2:  		/* cmplw CR6, R4, R28 */
		/* 820FF410h case    2:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R28);
		/* 820FF410h case    2:*/		return 0x820FF414;
		  /* 820FF414h */ case    3:  		/* bc 12, CR6_LT, -236 */
		/* 820FF414h case    3:*/		if ( regs.CR[6].lt ) { return 0x820FF328;  }
		/* 820FF414h case    3:*/		return 0x820FF418;
	}
	return 0x820FF418;
} // Block from 820FF408h-820FF418h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FF418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF418);
		  /* 820FF418h */ case    0:  		/* cmplwi CR6, R28, 4 */
		/* 820FF418h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000004);
		/* 820FF418h case    0:*/		return 0x820FF41C;
		  /* 820FF41Ch */ case    1:  		/* bc 4, CR6_GT, 144 */
		/* 820FF41Ch case    1:*/		if ( !regs.CR[6].gt ) { return 0x820FF4AC;  }
		/* 820FF41Ch case    1:*/		return 0x820FF420;
		  /* 820FF420h */ case    2:  		/* mr R6, R14 */
		/* 820FF420h case    2:*/		regs.R6 = regs.R14;
		/* 820FF420h case    2:*/		return 0x820FF424;
		  /* 820FF424h */ case    3:  		/* lwz R4, <#[R27 + 136]> */
		/* 820FF424h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x00000088) );
		/* 820FF424h case    3:*/		return 0x820FF428;
		  /* 820FF428h */ case    4:  		/* mr R5, R14 */
		/* 820FF428h case    4:*/		regs.R5 = regs.R14;
		/* 820FF428h case    4:*/		return 0x820FF42C;
		  /* 820FF42Ch */ case    5:  		/* fmr FR1, FR31 */
		/* 820FF42Ch case    5:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820FF42Ch case    5:*/		return 0x820FF430;
		  /* 820FF430h */ case    6:  		/* mr R3, R27 */
		/* 820FF430h case    6:*/		regs.R3 = regs.R27;
		/* 820FF430h case    6:*/		return 0x820FF434;
		  /* 820FF434h */ case    7:  		/* bl -8716 */
		/* 820FF434h case    7:*/		regs.LR = 0x820FF438; return 0x820FD228;
		/* 820FF434h case    7:*/		return 0x820FF438;
		  /* 820FF438h */ case    8:  		/* lwz R11, <#[R31 + 16]> */
		/* 820FF438h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820FF438h case    8:*/		return 0x820FF43C;
		  /* 820FF43Ch */ case    9:  		/* stw R3, <#[R11]> */
		/* 820FF43Ch case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 820FF43Ch case    9:*/		return 0x820FF440;
		  /* 820FF440h */ case   10:  		/* lwz R11, <#[R31 + 16]> */
		/* 820FF440h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820FF440h case   10:*/		return 0x820FF444;
		  /* 820FF444h */ case   11:  		/* lwz R11, <#[R11]> */
		/* 820FF444h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FF444h case   11:*/		return 0x820FF448;
		  /* 820FF448h */ case   12:  		/* cmpwi CR6, R11, -1 */
		/* 820FF448h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FF448h case   12:*/		return 0x820FF44C;
		  /* 820FF44Ch */ case   13:  		/* bc 12, CR6_EQ, 188 */
		/* 820FF44Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x820FF508;  }
		/* 820FF44Ch case   13:*/		return 0x820FF450;
		  /* 820FF450h */ case   14:  		/* lwz R11, <#[R25 + 16]> */
		/* 820FF450h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000010) );
		/* 820FF450h case   14:*/		return 0x820FF454;
		  /* 820FF454h */ case   15:  		/* lwz R10, <#[R31 + 16]> */
		/* 820FF454h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820FF454h case   15:*/		return 0x820FF458;
		  /* 820FF458h */ case   16:  		/* lwz R9, <#[R27 + 20]> */
		/* 820FF458h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000014) );
		/* 820FF458h case   16:*/		return 0x820FF45C;
		  /* 820FF45Ch */ case   17:  		/* lwz R11, <#[R11]> */
		/* 820FF45Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FF45Ch case   17:*/		return 0x820FF460;
		  /* 820FF460h */ case   18:  		/* lwz R10, <#[R10]> */
		/* 820FF460h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820FF460h case   18:*/		return 0x820FF464;
		  /* 820FF464h */ case   19:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FF464h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FF464h case   19:*/		return 0x820FF468;
		  /* 820FF468h */ case   20:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FF468h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FF468h case   20:*/		return 0x820FF46C;
		  /* 820FF46Ch */ case   21:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820FF46Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FF46Ch case   21:*/		return 0x820FF470;
		  /* 820FF470h */ case   22:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820FF470h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820FF470h case   22:*/		return 0x820FF474;
		  /* 820FF474h */ case   23:  		/* lwz R11, <#[R11 + 20]> */
		/* 820FF474h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820FF474h case   23:*/		return 0x820FF478;
		  /* 820FF478h */ case   24:  		/* stw R11, <#[R10 + 20]> */
		/* 820FF478h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 820FF478h case   24:*/		return 0x820FF47C;
		  /* 820FF47Ch */ case   25:  		/* lwz R9, <#[R25 + 16]> */
		/* 820FF47Ch case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000010) );
		/* 820FF47Ch case   25:*/		return 0x820FF480;
		  /* 820FF480h */ case   26:  		/* lwz R11, <#[R31 + 16]> */
		/* 820FF480h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820FF480h case   26:*/		return 0x820FF484;
		  /* 820FF484h */ case   27:  		/* lwz R10, <#[R27 + 20]> */
		/* 820FF484h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000014) );
		/* 820FF484h case   27:*/		return 0x820FF488;
		  /* 820FF488h */ case   28:  		/* lwz R9, <#[R9]> */
		/* 820FF488h case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 820FF488h case   28:*/		return 0x820FF48C;
		  /* 820FF48Ch */ case   29:  		/* lwz R11, <#[R11]> */
		/* 820FF48Ch case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FF48Ch case   29:*/		return 0x820FF490;
		  /* 820FF490h */ case   30:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FF490h case   30:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FF490h case   30:*/		return 0x820FF494;
		  /* 820FF494h */ case   31:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820FF494h case   31:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820FF494h case   31:*/		return 0x820FF498;
		  /* 820FF498h */ case   32:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820FF498h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FF498h case   32:*/		return 0x820FF49C;
		  /* 820FF49Ch */ case   33:  		/* lwzx R10, <#[R9 + R10]> */
		/* 820FF49Ch case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FF49Ch case   33:*/		return 0x820FF4A0;
		  /* 820FF4A0h */ case   34:  		/* lwz R10, <#[R10 + 24]> */
		/* 820FF4A0h case   34:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000018) );
		/* 820FF4A0h case   34:*/		return 0x820FF4A4;
		  /* 820FF4A4h */ case   35:  		/* stw R10, <#[R11 + 24]> */
		/* 820FF4A4h case   35:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 820FF4A4h case   35:*/		return 0x820FF4A8;
		  /* 820FF4A8h */ case   36:  		/* b 20 */
		/* 820FF4A8h case   36:*/		return 0x820FF4BC;
		/* 820FF4A8h case   36:*/		return 0x820FF4AC;
	}
	return 0x820FF4AC;
} // Block from 820FF418h-820FF4ACh (37 instructions)

//////////////////////////////////////////////////////
// Block at 820FF4ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF4AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF4AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF4AC);
		  /* 820FF4ACh */ case    0:  		/* lwz R11, <#[R25 + 16]> */
		/* 820FF4ACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000010) );
		/* 820FF4ACh case    0:*/		return 0x820FF4B0;
		  /* 820FF4B0h */ case    1:  		/* lwz R10, <#[R31 + 16]> */
		/* 820FF4B0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820FF4B0h case    1:*/		return 0x820FF4B4;
		  /* 820FF4B4h */ case    2:  		/* lwz R11, <#[R11]> */
		/* 820FF4B4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FF4B4h case    2:*/		return 0x820FF4B8;
		  /* 820FF4B8h */ case    3:  		/* stw R11, <#[R10]> */
		/* 820FF4B8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820FF4B8h case    3:*/		return 0x820FF4BC;
	}
	return 0x820FF4BC;
} // Block from 820FF4ACh-820FF4BCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FF4BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF4BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF4BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF4BC);
		  /* 820FF4BCh */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 820FF4BCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820FF4BCh case    0:*/		return 0x820FF4C0;
		  /* 820FF4C0h */ case    1:  		/* subf. R15, R24, R15 */
		/* 820FF4C0h case    1:*/		cpu::op::subf<1>(regs,&regs.R15,regs.R24,regs.R15);
		/* 820FF4C0h case    1:*/		return 0x820FF4C4;
		  /* 820FF4C4h */ case    2:  		/* addi R11, R11, 1 */
		/* 820FF4C4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820FF4C4h case    2:*/		return 0x820FF4C8;
		  /* 820FF4C8h */ case    3:  		/* stw R15, <#[R1 + 84]> */
		/* 820FF4C8h case    3:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x00000054) );
		/* 820FF4C8h case    3:*/		return 0x820FF4CC;
		  /* 820FF4CCh */ case    4:  		/* stw R11, <#[R1 + 80]> */
		/* 820FF4CCh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820FF4CCh case    4:*/		return 0x820FF4D0;
		  /* 820FF4D0h */ case    5:  		/* bc 4, CR0_EQ, -976 */
		/* 820FF4D0h case    5:*/		if ( !regs.CR[0].eq ) { return 0x820FF100;  }
		/* 820FF4D0h case    5:*/		return 0x820FF4D4;
		  /* 820FF4D4h */ case    6:  		/* rlwinm R24, R11, 0, 0, 31 */
		/* 820FF4D4h case    6:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R24,regs.R11);
		/* 820FF4D4h case    6:*/		return 0x820FF4D8;
		  /* 820FF4D8h */ case    7:  		/* cmplwi CR6, R24, 1 */
		/* 820FF4D8h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000001);
		/* 820FF4D8h case    7:*/		return 0x820FF4DC;
		  /* 820FF4DCh */ case    8:  		/* bc 4, CR6_GT, 472 */
		/* 820FF4DCh case    8:*/		if ( !regs.CR[6].gt ) { return 0x820FF6B4;  }
		/* 820FF4DCh case    8:*/		return 0x820FF4E0;
		  /* 820FF4E0h */ case    9:  		/* lis R11, -32256 */
		/* 820FF4E0h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820FF4E0h case    9:*/		return 0x820FF4E4;
		  /* 820FF4E4h */ case   10:  		/* lwz R4, <#[R27 + 120]> */
		/* 820FF4E4h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x00000078) );
		/* 820FF4E4h case   10:*/		return 0x820FF4E8;
		  /* 820FF4E8h */ case   11:  		/* li R6, 0 */
		/* 820FF4E8h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820FF4E8h case   11:*/		return 0x820FF4EC;
		  /* 820FF4ECh */ case   12:  		/* mr R5, R14 */
		/* 820FF4ECh case   12:*/		regs.R5 = regs.R14;
		/* 820FF4ECh case   12:*/		return 0x820FF4F0;
		  /* 820FF4F0h */ case   13:  		/* mr R3, R27 */
		/* 820FF4F0h case   13:*/		regs.R3 = regs.R27;
		/* 820FF4F0h case   13:*/		return 0x820FF4F4;
		  /* 820FF4F4h */ case   14:  		/* lfd FR1, <#[R11 + 1848]> */
		/* 820FF4F4h case   14:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000738) );
		/* 820FF4F4h case   14:*/		return 0x820FF4F8;
		  /* 820FF4F8h */ case   15:  		/* bl -8912 */
		/* 820FF4F8h case   15:*/		regs.LR = 0x820FF4FC; return 0x820FD228;
		/* 820FF4F8h case   15:*/		return 0x820FF4FC;
		  /* 820FF4FCh */ case   16:  		/* mr R26, R3 */
		/* 820FF4FCh case   16:*/		regs.R26 = regs.R3;
		/* 820FF4FCh case   16:*/		return 0x820FF500;
		  /* 820FF500h */ case   17:  		/* cmpwi CR6, R3, -1 */
		/* 820FF500h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820FF500h case   17:*/		return 0x820FF504;
		  /* 820FF504h */ case   18:  		/* bc 4, CR6_EQ, 20 */
		/* 820FF504h case   18:*/		if ( !regs.CR[6].eq ) { return 0x820FF518;  }
		/* 820FF504h case   18:*/		return 0x820FF508;
	}
	return 0x820FF508;
} // Block from 820FF4BCh-820FF508h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820FF508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF508);
		  /* 820FF508h */ case    0:  		/* lis R3, -32761 */
		/* 820FF508h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820FF508h case    0:*/		return 0x820FF50C;
		  /* 820FF50Ch */ case    1:  		/* ori R3, R3, 14 */
		/* 820FF50Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820FF50Ch case    1:*/		return 0x820FF510;
		  /* 820FF510h */ case    2:  		/* b 424 */
		/* 820FF510h case    2:*/		return 0x820FF6B8;
		/* 820FF510h case    2:*/		return 0x820FF514;
		  /* 820FF514h */ case    3:  		/* lwz R24, <#[R1 + 80]> */
		/* 820FF514h case    3:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000050) );
		/* 820FF514h case    3:*/		return 0x820FF518;
	}
	return 0x820FF518;
} // Block from 820FF508h-820FF518h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FF518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF518);
		  /* 820FF518h */ case    0:  		/* lwz R11, <#[R27 + 12]> */
		/* 820FF518h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 820FF518h case    0:*/		return 0x820FF51C;
		  /* 820FF51Ch */ case    1:  		/* li R28, 0 */
		/* 820FF51Ch case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820FF51Ch case    1:*/		return 0x820FF520;
		  /* 820FF520h */ case    2:  		/* cmplwi CR6, R24, 0 */
		/* 820FF520h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820FF520h case    2:*/		return 0x820FF524;
		  /* 820FF524h */ case    3:  		/* subf R29, R24, R11 */
		/* 820FF524h case    3:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R24,regs.R11);
		/* 820FF524h case    3:*/		return 0x820FF528;
		  /* 820FF528h */ case    4:  		/* bc 12, CR6_EQ, 384 */
		/* 820FF528h case    4:*/		if ( regs.CR[6].eq ) { return 0x820FF6A8;  }
		/* 820FF528h case    4:*/		return 0x820FF52C;
		  /* 820FF52Ch */ case    5:  		/* li R11, 0 */
		/* 820FF52Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820FF52Ch case    5:*/		return 0x820FF530;
		  /* 820FF530h */ case    6:  		/* subf R30, R11, R24 */
		/* 820FF530h case    6:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R11,regs.R24);
		/* 820FF530h case    6:*/		return 0x820FF534;
		  /* 820FF534h */ case    7:  		/* cmplwi CR6, R30, 4 */
		/* 820FF534h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000004);
		/* 820FF534h case    7:*/		return 0x820FF538;
		  /* 820FF538h */ case    8:  		/* bc 4, CR6_GT, 8 */
		/* 820FF538h case    8:*/		if ( !regs.CR[6].gt ) { return 0x820FF540;  }
		/* 820FF538h case    8:*/		return 0x820FF53C;
		  /* 820FF53Ch */ case    9:  		/* li R30, 4 */
		/* 820FF53Ch case    9:*/		cpu::op::li<0>(regs,&regs.R30,0x4);
		/* 820FF53Ch case    9:*/		return 0x820FF540;
	}
	return 0x820FF540;
} // Block from 820FF518h-820FF540h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FF540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF540);
		  /* 820FF540h */ case    0:  		/* cmplwi CR6, R30, 1 */
		/* 820FF540h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000001);
		/* 820FF540h case    0:*/		return 0x820FF544;
		  /* 820FF544h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820FF544h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820FF554;  }
		/* 820FF544h case    1:*/		return 0x820FF548;
		  /* 820FF548h */ case    2:  		/* lis R4, 4096 */
		/* 820FF548h case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x1000);
		/* 820FF548h case    2:*/		return 0x820FF54C;
		  /* 820FF54Ch */ case    3:  		/* ori R4, R4, 1 */
		/* 820FF54Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820FF54Ch case    3:*/		return 0x820FF550;
		  /* 820FF550h */ case    4:  		/* b 32 */
		/* 820FF550h case    4:*/		return 0x820FF570;
		/* 820FF550h case    4:*/		return 0x820FF554;
	}
	return 0x820FF554;
} // Block from 820FF540h-820FF554h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FF554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF554);
		  /* 820FF554h */ case    0:  		/* cmplwi CR6, R30, 2 */
		/* 820FF554h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000002);
		/* 820FF554h case    0:*/		return 0x820FF558;
		  /* 820FF558h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820FF558h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820FF564;  }
		/* 820FF558h case    1:*/		return 0x820FF55C;
		  /* 820FF55Ch */ case    2:  		/* lis R4, 8256 */
		/* 820FF55Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x2040);
		/* 820FF55Ch case    2:*/		return 0x820FF560;
		  /* 820FF560h */ case    3:  		/* b -20 */
		/* 820FF560h case    3:*/		return 0x820FF54C;
		/* 820FF560h case    3:*/		return 0x820FF564;
	}
	return 0x820FF564;
} // Block from 820FF554h-820FF564h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FF564h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF564( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF564) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF564);
		  /* 820FF564h */ case    0:  		/* mr R4, R30 */
		/* 820FF564h case    0:*/		regs.R4 = regs.R30;
		/* 820FF564h case    0:*/		return 0x820FF568;
		  /* 820FF568h */ case    1:  		/* li R11, 5 */
		/* 820FF568h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820FF568h case    1:*/		return 0x820FF56C;
		  /* 820FF56Ch */ case    2:  		/* rlwimi R4, R11, 28, 0, 11 */
		/* 820FF56Ch case    2:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R4,regs.R11);
		/* 820FF56Ch case    2:*/		return 0x820FF570;
	}
	return 0x820FF570;
} // Block from 820FF564h-820FF570h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FF570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF570);
		  /* 820FF570h */ case    0:  		/* mr R6, R14 */
		/* 820FF570h case    0:*/		regs.R6 = regs.R14;
		/* 820FF570h case    0:*/		return 0x820FF574;
		  /* 820FF574h */ case    1:  		/* mr R5, R14 */
		/* 820FF574h case    1:*/		regs.R5 = regs.R14;
		/* 820FF574h case    1:*/		return 0x820FF578;
		  /* 820FF578h */ case    2:  		/* mr R3, R27 */
		/* 820FF578h case    2:*/		regs.R3 = regs.R27;
		/* 820FF578h case    2:*/		return 0x820FF57C;
		  /* 820FF57Ch */ case    3:  		/* bl -8884 */
		/* 820FF57Ch case    3:*/		regs.LR = 0x820FF580; return 0x820FD2C8;
		/* 820FF57Ch case    3:*/		return 0x820FF580;
		  /* 820FF580h */ case    4:  		/* cmpwi CR6, R3, -1 */
		/* 820FF580h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820FF580h case    4:*/		return 0x820FF584;
		  /* 820FF584h */ case    5:  		/* bc 12, CR6_EQ, -124 */
		/* 820FF584h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FF508;  }
		/* 820FF584h case    5:*/		return 0x820FF588;
		  /* 820FF588h */ case    6:  		/* lwz R11, <#[R27 + 24]> */
		/* 820FF588h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000018) );
		/* 820FF588h case    6:*/		return 0x820FF58C;
		  /* 820FF58Ch */ case    7:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820FF58Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820FF58Ch case    7:*/		return 0x820FF590;
		  /* 820FF590h */ case    8:  		/* mr R4, R25 */
		/* 820FF590h case    8:*/		regs.R4 = regs.R25;
		/* 820FF590h case    8:*/		return 0x820FF594;
		  /* 820FF594h */ case    9:  		/* lwzx R31, <#[R10 + R11]> */
		/* 820FF594h case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820FF594h case    9:*/		return 0x820FF598;
		  /* 820FF598h */ case   10:  		/* mr R3, R31 */
		/* 820FF598h case   10:*/		regs.R3 = regs.R31;
		/* 820FF598h case   10:*/		return 0x820FF59C;
		  /* 820FF59Ch */ case   11:  		/* bl -13996 */
		/* 820FF59Ch case   11:*/		regs.LR = 0x820FF5A0; return 0x820FBEF0;
		/* 820FF59Ch case   11:*/		return 0x820FF5A0;
		  /* 820FF5A0h */ case   12:  		/* cmplwi CR6, R30, 0 */
		/* 820FF5A0h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820FF5A0h case   12:*/		return 0x820FF5A4;
		  /* 820FF5A4h */ case   13:  		/* bc 12, CR6_EQ, 76 */
		/* 820FF5A4h case   13:*/		if ( regs.CR[6].eq ) { return 0x820FF5F0;  }
		/* 820FF5A4h case   13:*/		return 0x820FF5A8;
		  /* 820FF5A8h */ case   14:  		/* mtspr CTR, R30 */
		/* 820FF5A8h case   14:*/		regs.CTR = regs.R30;
		/* 820FF5A8h case   14:*/		return 0x820FF5AC;
		  /* 820FF5ACh */ case   15:  		/* li R11, 0 */
		/* 820FF5ACh case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820FF5ACh case   15:*/		return 0x820FF5B0;
		  /* 820FF5B0h */ case   16:  		/* rlwinm R9, R30, 2, 0, 29 */
		/* 820FF5B0h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R30);
		/* 820FF5B0h case   16:*/		return 0x820FF5B4;
		  /* 820FF5B4h */ case   17:  		/* rlwinm R10, R29, 2, 0, 29 */
		/* 820FF5B4h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R29);
		/* 820FF5B4h case   17:*/		return 0x820FF5B8;
		  /* 820FF5B8h */ case   18:  		/* lwz R8, <#[R27 + 24]> */
		/* 820FF5B8h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000018) );
		/* 820FF5B8h case   18:*/		return 0x820FF5BC;
		  /* 820FF5BCh */ case   19:  		/* cmplwi CR6, R30, 2 */
		/* 820FF5BCh case   19:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000002);
		/* 820FF5BCh case   19:*/		return 0x820FF5C0;
		  /* 820FF5C0h */ case   20:  		/* lwz R7, <#[R31 + 8]> */
		/* 820FF5C0h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000008) );
		/* 820FF5C0h case   20:*/		return 0x820FF5C4;
		  /* 820FF5C4h */ case   21:  		/* lwzx R8, <#[R10 + R8]> */
		/* 820FF5C4h case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820FF5C4h case   21:*/		return 0x820FF5C8;
		  /* 820FF5C8h */ case   22:  		/* lwz R8, <#[R8 + 16]> */
		/* 820FF5C8h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000010) );
		/* 820FF5C8h case   22:*/		return 0x820FF5CC;
		  /* 820FF5CCh */ case   23:  		/* lwz R8, <#[R8]> */
		/* 820FF5CCh case   23:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000000) );
		/* 820FF5CCh case   23:*/		return 0x820FF5D0;
		  /* 820FF5D0h */ case   24:  		/* stwx R8, <#[R11 + R7]> */
		/* 820FF5D0h case   24:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820FF5D0h case   24:*/		return 0x820FF5D4;
		  /* 820FF5D4h */ case   25:  		/* bc 4, CR6_GT, 12 */
		/* 820FF5D4h case   25:*/		if ( !regs.CR[6].gt ) { return 0x820FF5E0;  }
		/* 820FF5D4h case   25:*/		return 0x820FF5D8;
		  /* 820FF5D8h */ case   26:  		/* lwz R8, <#[R31 + 8]> */
		/* 820FF5D8h case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 820FF5D8h case   26:*/		return 0x820FF5DC;
		  /* 820FF5DCh */ case   27:  		/* stwx R26, <#[R9 + R8]> */
		/* 820FF5DCh case   27:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820FF5DCh case   27:*/		return 0x820FF5E0;
	}
	return 0x820FF5E0;
} // Block from 820FF570h-820FF5E0h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820FF5E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF5E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF5E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF5E0);
		  /* 820FF5E0h */ case    0:  		/* addi R11, R11, 4 */
		/* 820FF5E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820FF5E0h case    0:*/		return 0x820FF5E4;
		  /* 820FF5E4h */ case    1:  		/* addi R10, R10, 4 */
		/* 820FF5E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820FF5E4h case    1:*/		return 0x820FF5E8;
		  /* 820FF5E8h */ case    2:  		/* addi R9, R9, 4 */
		/* 820FF5E8h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820FF5E8h case    2:*/		return 0x820FF5EC;
		  /* 820FF5ECh */ case    3:  		/* bc 16, CR0_LT, -52 */
		/* 820FF5ECh case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820FF5B8;  }
		/* 820FF5ECh case    3:*/		return 0x820FF5F0;
	}
	return 0x820FF5F0;
} // Block from 820FF5E0h-820FF5F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FF5F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF5F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF5F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF5F0);
		  /* 820FF5F0h */ case    0:  		/* cmplwi CR6, R24, 4 */
		/* 820FF5F0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000004);
		/* 820FF5F0h case    0:*/		return 0x820FF5F4;
		  /* 820FF5F4h */ case    1:  		/* bc 4, CR6_GT, 144 */
		/* 820FF5F4h case    1:*/		if ( !regs.CR[6].gt ) { return 0x820FF684;  }
		/* 820FF5F4h case    1:*/		return 0x820FF5F8;
		  /* 820FF5F8h */ case    2:  		/* mr R6, R14 */
		/* 820FF5F8h case    2:*/		regs.R6 = regs.R14;
		/* 820FF5F8h case    2:*/		return 0x820FF5FC;
		  /* 820FF5FCh */ case    3:  		/* lwz R4, <#[R27 + 136]> */
		/* 820FF5FCh case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x00000088) );
		/* 820FF5FCh case    3:*/		return 0x820FF600;
		  /* 820FF600h */ case    4:  		/* mr R5, R14 */
		/* 820FF600h case    4:*/		regs.R5 = regs.R14;
		/* 820FF600h case    4:*/		return 0x820FF604;
		  /* 820FF604h */ case    5:  		/* fmr FR1, FR31 */
		/* 820FF604h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820FF604h case    5:*/		return 0x820FF608;
		  /* 820FF608h */ case    6:  		/* mr R3, R27 */
		/* 820FF608h case    6:*/		regs.R3 = regs.R27;
		/* 820FF608h case    6:*/		return 0x820FF60C;
		  /* 820FF60Ch */ case    7:  		/* bl -9188 */
		/* 820FF60Ch case    7:*/		regs.LR = 0x820FF610; return 0x820FD228;
		/* 820FF60Ch case    7:*/		return 0x820FF610;
		  /* 820FF610h */ case    8:  		/* lwz R11, <#[R31 + 16]> */
		/* 820FF610h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820FF610h case    8:*/		return 0x820FF614;
		  /* 820FF614h */ case    9:  		/* stw R3, <#[R11]> */
		/* 820FF614h case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 820FF614h case    9:*/		return 0x820FF618;
		  /* 820FF618h */ case   10:  		/* lwz R11, <#[R31 + 16]> */
		/* 820FF618h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820FF618h case   10:*/		return 0x820FF61C;
		  /* 820FF61Ch */ case   11:  		/* lwz R11, <#[R11]> */
		/* 820FF61Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FF61Ch case   11:*/		return 0x820FF620;
		  /* 820FF620h */ case   12:  		/* cmpwi CR6, R11, -1 */
		/* 820FF620h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FF620h case   12:*/		return 0x820FF624;
		  /* 820FF624h */ case   13:  		/* bc 12, CR6_EQ, -284 */
		/* 820FF624h case   13:*/		if ( regs.CR[6].eq ) { return 0x820FF508;  }
		/* 820FF624h case   13:*/		return 0x820FF628;
		  /* 820FF628h */ case   14:  		/* lwz R11, <#[R25 + 16]> */
		/* 820FF628h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000010) );
		/* 820FF628h case   14:*/		return 0x820FF62C;
		  /* 820FF62Ch */ case   15:  		/* lwz R10, <#[R31 + 16]> */
		/* 820FF62Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820FF62Ch case   15:*/		return 0x820FF630;
		  /* 820FF630h */ case   16:  		/* lwz R9, <#[R27 + 20]> */
		/* 820FF630h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000014) );
		/* 820FF630h case   16:*/		return 0x820FF634;
		  /* 820FF634h */ case   17:  		/* lwz R11, <#[R11]> */
		/* 820FF634h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FF634h case   17:*/		return 0x820FF638;
		  /* 820FF638h */ case   18:  		/* lwz R10, <#[R10]> */
		/* 820FF638h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820FF638h case   18:*/		return 0x820FF63C;
		  /* 820FF63Ch */ case   19:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FF63Ch case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FF63Ch case   19:*/		return 0x820FF640;
		  /* 820FF640h */ case   20:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FF640h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FF640h case   20:*/		return 0x820FF644;
		  /* 820FF644h */ case   21:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820FF644h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FF644h case   21:*/		return 0x820FF648;
		  /* 820FF648h */ case   22:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820FF648h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820FF648h case   22:*/		return 0x820FF64C;
		  /* 820FF64Ch */ case   23:  		/* lwz R11, <#[R11 + 20]> */
		/* 820FF64Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820FF64Ch case   23:*/		return 0x820FF650;
		  /* 820FF650h */ case   24:  		/* stw R11, <#[R10 + 20]> */
		/* 820FF650h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 820FF650h case   24:*/		return 0x820FF654;
		  /* 820FF654h */ case   25:  		/* lwz R10, <#[R25 + 16]> */
		/* 820FF654h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000010) );
		/* 820FF654h case   25:*/		return 0x820FF658;
		  /* 820FF658h */ case   26:  		/* lwz R11, <#[R31 + 16]> */
		/* 820FF658h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820FF658h case   26:*/		return 0x820FF65C;
		  /* 820FF65Ch */ case   27:  		/* lwz R9, <#[R27 + 20]> */
		/* 820FF65Ch case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000014) );
		/* 820FF65Ch case   27:*/		return 0x820FF660;
		  /* 820FF660h */ case   28:  		/* lwz R10, <#[R10]> */
		/* 820FF660h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820FF660h case   28:*/		return 0x820FF664;
		  /* 820FF664h */ case   29:  		/* lwz R11, <#[R11]> */
		/* 820FF664h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FF664h case   29:*/		return 0x820FF668;
		  /* 820FF668h */ case   30:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FF668h case   30:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FF668h case   30:*/		return 0x820FF66C;
		  /* 820FF66Ch */ case   31:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FF66Ch case   31:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FF66Ch case   31:*/		return 0x820FF670;
		  /* 820FF670h */ case   32:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820FF670h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820FF670h case   32:*/		return 0x820FF674;
		  /* 820FF674h */ case   33:  		/* lwz R10, <#[R10 + 24]> */
		/* 820FF674h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000018) );
		/* 820FF674h case   33:*/		return 0x820FF678;
		  /* 820FF678h */ case   34:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820FF678h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FF678h case   34:*/		return 0x820FF67C;
		  /* 820FF67Ch */ case   35:  		/* stw R10, <#[R11 + 24]> */
		/* 820FF67Ch case   35:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 820FF67Ch case   35:*/		return 0x820FF680;
		  /* 820FF680h */ case   36:  		/* b 20 */
		/* 820FF680h case   36:*/		return 0x820FF694;
		/* 820FF680h case   36:*/		return 0x820FF684;
	}
	return 0x820FF684;
} // Block from 820FF5F0h-820FF684h (37 instructions)

//////////////////////////////////////////////////////
// Block at 820FF684h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF684( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF684) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF684);
		  /* 820FF684h */ case    0:  		/* lwz R11, <#[R25 + 16]> */
		/* 820FF684h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000010) );
		/* 820FF684h case    0:*/		return 0x820FF688;
		  /* 820FF688h */ case    1:  		/* lwz R10, <#[R31 + 16]> */
		/* 820FF688h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820FF688h case    1:*/		return 0x820FF68C;
		  /* 820FF68Ch */ case    2:  		/* lwz R11, <#[R11]> */
		/* 820FF68Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FF68Ch case    2:*/		return 0x820FF690;
		  /* 820FF690h */ case    3:  		/* stw R11, <#[R10]> */
		/* 820FF690h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820FF690h case    3:*/		return 0x820FF694;
	}
	return 0x820FF694;
} // Block from 820FF684h-820FF694h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FF694h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF694( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF694) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF694);
		  /* 820FF694h */ case    0:  		/* addi R28, R28, 1 */
		/* 820FF694h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820FF694h case    0:*/		return 0x820FF698;
		  /* 820FF698h */ case    1:  		/* add R29, R30, R29 */
		/* 820FF698h case    1:*/		cpu::op::add<0>(regs,&regs.R29,regs.R30,regs.R29);
		/* 820FF698h case    1:*/		return 0x820FF69C;
		  /* 820FF69Ch */ case    2:  		/* rlwinm R11, R28, 2, 0, 29 */
		/* 820FF69Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R28);
		/* 820FF69Ch case    2:*/		return 0x820FF6A0;
		  /* 820FF6A0h */ case    3:  		/* cmplw CR6, R11, R24 */
		/* 820FF6A0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 820FF6A0h case    3:*/		return 0x820FF6A4;
		  /* 820FF6A4h */ case    4:  		/* bc 12, CR6_LT, -372 */
		/* 820FF6A4h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FF530;  }
		/* 820FF6A4h case    4:*/		return 0x820FF6A8;
	}
	return 0x820FF6A8;
} // Block from 820FF694h-820FF6A8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FF6A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF6A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF6A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF6A8);
		  /* 820FF6A8h */ case    0:  		/* stw R28, <#[R1 + 80]> */
		/* 820FF6A8h case    0:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 820FF6A8h case    0:*/		return 0x820FF6AC;
		  /* 820FF6ACh */ case    1:  		/* cmplwi CR6, R28, 1 */
		/* 820FF6ACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000001);
		/* 820FF6ACh case    1:*/		return 0x820FF6B0;
		  /* 820FF6B0h */ case    2:  		/* bc 12, CR6_GT, -412 */
		/* 820FF6B0h case    2:*/		if ( regs.CR[6].gt ) { return 0x820FF514;  }
		/* 820FF6B0h case    2:*/		return 0x820FF6B4;
	}
	return 0x820FF6B4;
} // Block from 820FF6A8h-820FF6B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FF6B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF6B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF6B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF6B4);
		  /* 820FF6B4h */ case    0:  		/* li R3, 0 */
		/* 820FF6B4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FF6B4h case    0:*/		return 0x820FF6B8;
	}
	return 0x820FF6B8;
} // Block from 820FF6B4h-820FF6B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FF6B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF6B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF6B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF6B8);
		  /* 820FF6B8h */ case    0:  		/* addi R1, R1, 256 */
		/* 820FF6B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 820FF6B8h case    0:*/		return 0x820FF6BC;
		  /* 820FF6BCh */ case    1:  		/* lfd FR31, <#[R1 - 160]> */
		/* 820FF6BCh case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 820FF6BCh case    1:*/		return 0x820FF6C0;
		  /* 820FF6C0h */ case    2:  		/* b -451664 */
		/* 820FF6C0h case    2:*/		return 0x82091270;
		/* 820FF6C0h case    2:*/		return 0x820FF6C4;
		  /* 820FF6C4h */ case    3:  		/* nop */
		/* 820FF6C4h case    3:*/		cpu::op::nop();
		/* 820FF6C4h case    3:*/		return 0x820FF6C8;
	}
	return 0x820FF6C8;
} // Block from 820FF6B8h-820FF6C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FF6C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF6C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF6C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF6C8);
		  /* 820FF6C8h */ case    0:  		/* mfspr R12, LR */
		/* 820FF6C8h case    0:*/		regs.R12 = regs.LR;
		/* 820FF6C8h case    0:*/		return 0x820FF6CC;
		  /* 820FF6CCh */ case    1:  		/* bl -451736 */
		/* 820FF6CCh case    1:*/		regs.LR = 0x820FF6D0; return 0x82091234;
		/* 820FF6CCh case    1:*/		return 0x820FF6D0;
		  /* 820FF6D0h */ case    2:  		/* stfd FR31, <#[R1 - 120]> */
		/* 820FF6D0h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF88) );
		/* 820FF6D0h case    2:*/		return 0x820FF6D4;
		  /* 820FF6D4h */ case    3:  		/* stwu R1, <#[R1 - 240]> */
		/* 820FF6D4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 820FF6D4h case    3:*/		return 0x820FF6D8;
		  /* 820FF6D8h */ case    4:  		/* lwz R11, <#[R3 + 24]> */
		/* 820FF6D8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820FF6D8h case    4:*/		return 0x820FF6DC;
		  /* 820FF6DCh */ case    5:  		/* rlwinm R26, R4, 2, 0, 29 */
		/* 820FF6DCh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R26,regs.R4);
		/* 820FF6DCh case    5:*/		return 0x820FF6E0;
		  /* 820FF6E0h */ case    6:  		/* lwz R9, <#[R3 + 20]> */
		/* 820FF6E0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 820FF6E0h case    6:*/		return 0x820FF6E4;
		  /* 820FF6E4h */ case    7:  		/* li R25, -1 */
		/* 820FF6E4h case    7:*/		cpu::op::li<0>(regs,&regs.R25,0xFFFFFFFF);
		/* 820FF6E4h case    7:*/		return 0x820FF6E8;
		  /* 820FF6E8h */ case    8:  		/* lwz R28, <#[R5]> */
		/* 820FF6E8h case    8:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R5 + 0x00000000) );
		/* 820FF6E8h case    8:*/		return 0x820FF6EC;
		  /* 820FF6ECh */ case    9:  		/* mr R29, R3 */
		/* 820FF6ECh case    9:*/		regs.R29 = regs.R3;
		/* 820FF6ECh case    9:*/		return 0x820FF6F0;
		  /* 820FF6F0h */ case   10:  		/* mr R21, R4 */
		/* 820FF6F0h case   10:*/		regs.R21 = regs.R4;
		/* 820FF6F0h case   10:*/		return 0x820FF6F4;
		  /* 820FF6F4h */ case   11:  		/* mr R22, R5 */
		/* 820FF6F4h case   11:*/		regs.R22 = regs.R5;
		/* 820FF6F4h case   11:*/		return 0x820FF6F8;
		  /* 820FF6F8h */ case   12:  		/* lwzx R11, <#[R26 + R11]> */
		/* 820FF6F8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 820FF6F8h case   12:*/		return 0x820FF6FC;
		  /* 820FF6FCh */ case   13:  		/* mr R24, R6 */
		/* 820FF6FCh case   13:*/		regs.R24 = regs.R6;
		/* 820FF6FCh case   13:*/		return 0x820FF700;
		  /* 820FF700h */ case   14:  		/* mr R19, R7 */
		/* 820FF700h case   14:*/		regs.R19 = regs.R7;
		/* 820FF700h case   14:*/		return 0x820FF704;
		  /* 820FF704h */ case   15:  		/* mr R30, R9 */
		/* 820FF704h case   15:*/		regs.R30 = regs.R9;
		/* 820FF704h case   15:*/		return 0x820FF708;
		  /* 820FF708h */ case   16:  		/* mr R27, R25 */
		/* 820FF708h case   16:*/		regs.R27 = regs.R25;
		/* 820FF708h case   16:*/		return 0x820FF70C;
		  /* 820FF70Ch */ case   17:  		/* mr R10, R28 */
		/* 820FF70Ch case   17:*/		regs.R10 = regs.R28;
		/* 820FF70Ch case   17:*/		return 0x820FF710;
		  /* 820FF710h */ case   18:  		/* lwz R11, <#[R11 + 16]> */
		/* 820FF710h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820FF710h case   18:*/		return 0x820FF714;
		  /* 820FF714h */ case   19:  		/* lwz R11, <#[R11]> */
		/* 820FF714h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820FF714h case   19:*/		return 0x820FF718;
		  /* 820FF718h */ case   20:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FF718h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FF718h case   20:*/		return 0x820FF71C;
		  /* 820FF71Ch */ case   21:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820FF71Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FF71Ch case   21:*/		return 0x820FF720;
		  /* 820FF720h */ case   22:  		/* lwz R20, <#[R11 + 24]> */
		/* 820FF720h case   22:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R11 + 0x00000018) );
		/* 820FF720h case   22:*/		return 0x820FF724;
		  /* 820FF724h */ case   23:  		/* lwz R23, <#[R11 + 20]> */
		/* 820FF724h case   23:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R11 + 0x00000014) );
		/* 820FF724h case   23:*/		return 0x820FF728;
		  /* 820FF728h */ case   24:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 820FF728h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 820FF728h case   24:*/		return 0x820FF72C;
		  /* 820FF72Ch */ case   25:  		/* lwzx R31, <#[R11 + R30]> */
		/* 820FF72Ch case   25:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820FF72Ch case   25:*/		return 0x820FF730;
		  /* 820FF730h */ case   26:  		/* lwz R11, <#[R31 + 16]> */
		/* 820FF730h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820FF730h case   26:*/		return 0x820FF734;
		  /* 820FF734h */ case   27:  		/* cmplwi CR6, R11, 0 */
		/* 820FF734h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FF734h case   27:*/		return 0x820FF738;
		  /* 820FF738h */ case   28:  		/* bc 4, CR6_EQ, 456 */
		/* 820FF738h case   28:*/		if ( !regs.CR[6].eq ) { return 0x820FF900;  }
		/* 820FF738h case   28:*/		return 0x820FF73C;
		  /* 820FF73Ch */ case   29:  		/* lwz R11, <#[R31 + 72]> */
		/* 820FF73Ch case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 820FF73Ch case   29:*/		return 0x820FF740;
		  /* 820FF740h */ case   30:  		/* cmpwi CR6, R11, -1 */
		/* 820FF740h case   30:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FF740h case   30:*/		return 0x820FF744;
		  /* 820FF744h */ case   31:  		/* bc 12, CR6_EQ, 12 */
		/* 820FF744h case   31:*/		if ( regs.CR[6].eq ) { return 0x820FF750;  }
		/* 820FF744h case   31:*/		return 0x820FF748;
		  /* 820FF748h */ case   32:  		/* cmplw CR6, R21, R11 */
		/* 820FF748h case   32:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R11);
		/* 820FF748h case   32:*/		return 0x820FF74C;
		  /* 820FF74Ch */ case   33:  		/* bc 4, CR6_GT, 436 */
		/* 820FF74Ch case   33:*/		if ( !regs.CR[6].gt ) { return 0x820FF900;  }
		/* 820FF74Ch case   33:*/		return 0x820FF750;
	}
	return 0x820FF750;
} // Block from 820FF6C8h-820FF750h (34 instructions)

//////////////////////////////////////////////////////
// Block at 820FF750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF750);
		  /* 820FF750h */ case    0:  		/* mr R9, R20 */
		/* 820FF750h case    0:*/		regs.R9 = regs.R20;
		/* 820FF750h case    0:*/		return 0x820FF754;
		  /* 820FF754h */ case    1:  		/* mr R11, R23 */
		/* 820FF754h case    1:*/		regs.R11 = regs.R23;
		/* 820FF754h case    1:*/		return 0x820FF758;
		  /* 820FF758h */ case    2:  		/* cmpwi CR6, R23, -1 */
		/* 820FF758h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R23,0xFFFFFFFF);
		/* 820FF758h case    2:*/		return 0x820FF75C;
		  /* 820FF75Ch */ case    3:  		/* bc 12, CR6_EQ, 44 */
		/* 820FF75Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820FF788;  }
		/* 820FF75Ch case    3:*/		return 0x820FF760;
		  /* 820FF760h */ case    4:  		/* lwz R8, <#[R31 + 20]> */
		/* 820FF760h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000014) );
		/* 820FF760h case    4:*/		return 0x820FF764;
		  /* 820FF764h */ case    5:  		/* cmplw CR6, R11, R8 */
		/* 820FF764h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820FF764h case    5:*/		return 0x820FF768;
		  /* 820FF768h */ case    6:  		/* bc 12, CR6_EQ, 32 */
		/* 820FF768h case    6:*/		if ( regs.CR[6].eq ) { return 0x820FF788;  }
		/* 820FF768h case    6:*/		return 0x820FF76C;
		  /* 820FF76Ch */ case    7:  		/* lwz R9, <#[R29 + 20]> */
		/* 820FF76Ch case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000014) );
		/* 820FF76Ch case    7:*/		return 0x820FF770;
		  /* 820FF770h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FF770h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FF770h case    8:*/		return 0x820FF774;
		  /* 820FF774h */ case    9:  		/* lwzx R9, <#[R11 + R9]> */
		/* 820FF774h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FF774h case    9:*/		return 0x820FF778;
		  /* 820FF778h */ case   10:  		/* lwz R11, <#[R9 + 20]> */
		/* 820FF778h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000014) );
		/* 820FF778h case   10:*/		return 0x820FF77C;
		  /* 820FF77Ch */ case   11:  		/* lwz R9, <#[R9 + 24]> */
		/* 820FF77Ch case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000018) );
		/* 820FF77Ch case   11:*/		return 0x820FF780;
		  /* 820FF780h */ case   12:  		/* cmpwi CR6, R11, -1 */
		/* 820FF780h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FF780h case   12:*/		return 0x820FF784;
		  /* 820FF784h */ case   13:  		/* bc 4, CR6_EQ, -32 */
		/* 820FF784h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820FF764;  }
		/* 820FF784h case   13:*/		return 0x820FF788;
	}
	return 0x820FF788;
} // Block from 820FF750h-820FF788h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820FF788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF788);
		  /* 820FF788h */ case    0:  		/* lwz R8, <#[R31 + 20]> */
		/* 820FF788h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000014) );
		/* 820FF788h case    0:*/		return 0x820FF78C;
		  /* 820FF78Ch */ case    1:  		/* cmplw CR6, R11, R8 */
		/* 820FF78Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820FF78Ch case    1:*/		return 0x820FF790;
		  /* 820FF790h */ case    2:  		/* bc 4, CR6_EQ, 368 */
		/* 820FF790h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FF900;  }
		/* 820FF790h case    2:*/		return 0x820FF794;
		  /* 820FF794h */ case    3:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FF794h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FF794h case    3:*/		return 0x820FF798;
		  /* 820FF798h */ case    4:  		/* cmpw CR6, R9, R11 */
		/* 820FF798h case    4:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R11);
		/* 820FF798h case    4:*/		return 0x820FF79C;
		  /* 820FF79Ch */ case    5:  		/* bc 4, CR6_EQ, 356 */
		/* 820FF79Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x820FF900;  }
		/* 820FF79Ch case    5:*/		return 0x820FF7A0;
		  /* 820FF7A0h */ case    6:  		/* stw R10, <#[R1 + 80]> */
		/* 820FF7A0h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820FF7A0h case    6:*/		return 0x820FF7A4;
		  /* 820FF7A4h */ case    7:  		/* li R6, 1 */
		/* 820FF7A4h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820FF7A4h case    7:*/		return 0x820FF7A8;
		  /* 820FF7A8h */ case    8:  		/* cmplwi CR6, R24, 1 */
		/* 820FF7A8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000001);
		/* 820FF7A8h case    8:*/		return 0x820FF7AC;
		  /* 820FF7ACh */ case    9:  		/* bc 4, CR6_GT, 228 */
		/* 820FF7ACh case    9:*/		if ( !regs.CR[6].gt ) { return 0x820FF890;  }
		/* 820FF7ACh case    9:*/		return 0x820FF7B0;
		  /* 820FF7B0h */ case   10:  		/* addi R11, R1, 80 */
		/* 820FF7B0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820FF7B0h case   10:*/		return 0x820FF7B4;
		  /* 820FF7B4h */ case   11:  		/* addi R5, R22, 4 */
		/* 820FF7B4h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R22,0x4);
		/* 820FF7B4h case   11:*/		return 0x820FF7B8;
		  /* 820FF7B8h */ case   12:  		/* subf R3, R22, R11 */
		/* 820FF7B8h case   12:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R22,regs.R11);
		/* 820FF7B8h case   12:*/		return 0x820FF7BC;
		  /* 820FF7BCh */ case   13:  		/* lwz R4, <#[R5]> */
		/* 820FF7BCh case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x00000000) );
		/* 820FF7BCh case   13:*/		return 0x820FF7C0;
		  /* 820FF7C0h */ case   14:  		/* mr R7, R4 */
		/* 820FF7C0h case   14:*/		regs.R7 = regs.R4;
		/* 820FF7C0h case   14:*/		return 0x820FF7C4;
		  /* 820FF7C4h */ case   15:  		/* rlwinm R11, R7, 2, 0, 29 */
		/* 820FF7C4h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R7);
		/* 820FF7C4h case   15:*/		return 0x820FF7C8;
		  /* 820FF7C8h */ case   16:  		/* lwzx R10, <#[R11 + R30]> */
		/* 820FF7C8h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820FF7C8h case   16:*/		return 0x820FF7CC;
		  /* 820FF7CCh */ case   17:  		/* lwz R11, <#[R10 + 16]> */
		/* 820FF7CCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 820FF7CCh case   17:*/		return 0x820FF7D0;
		  /* 820FF7D0h */ case   18:  		/* cmplw CR6, R11, R6 */
		/* 820FF7D0h case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820FF7D0h case   18:*/		return 0x820FF7D4;
		  /* 820FF7D4h */ case   19:  		/* bc 4, CR6_EQ, 152 */
		/* 820FF7D4h case   19:*/		if ( !regs.CR[6].eq ) { return 0x820FF86C;  }
		/* 820FF7D4h case   19:*/		return 0x820FF7D8;
		  /* 820FF7D8h */ case   20:  		/* lwz R11, <#[R10 + 72]> */
		/* 820FF7D8h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000048) );
		/* 820FF7D8h case   20:*/		return 0x820FF7DC;
		  /* 820FF7DCh */ case   21:  		/* cmpwi CR6, R11, -1 */
		/* 820FF7DCh case   21:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FF7DCh case   21:*/		return 0x820FF7E0;
		  /* 820FF7E0h */ case   22:  		/* bc 12, CR6_EQ, 12 */
		/* 820FF7E0h case   22:*/		if ( regs.CR[6].eq ) { return 0x820FF7EC;  }
		/* 820FF7E0h case   22:*/		return 0x820FF7E4;
		  /* 820FF7E4h */ case   23:  		/* cmplw CR6, R21, R11 */
		/* 820FF7E4h case   23:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R11);
		/* 820FF7E4h case   23:*/		return 0x820FF7E8;
		  /* 820FF7E8h */ case   24:  		/* bc 4, CR6_GT, 132 */
		/* 820FF7E8h case   24:*/		if ( !regs.CR[6].gt ) { return 0x820FF86C;  }
		/* 820FF7E8h case   24:*/		return 0x820FF7EC;
	}
	return 0x820FF7EC;
} // Block from 820FF788h-820FF7ECh (25 instructions)

//////////////////////////////////////////////////////
// Block at 820FF7ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF7EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF7EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF7EC);
		  /* 820FF7ECh */ case    0:  		/* lwz R11, <#[R10 + 4]> */
		/* 820FF7ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 820FF7ECh case    0:*/		return 0x820FF7F0;
		  /* 820FF7F0h */ case    1:  		/* lwz R9, <#[R31 + 4]> */
		/* 820FF7F0h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 820FF7F0h case    1:*/		return 0x820FF7F4;
		  /* 820FF7F4h */ case    2:  		/* cmplw CR6, R11, R9 */
		/* 820FF7F4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820FF7F4h case    2:*/		return 0x820FF7F8;
		  /* 820FF7F8h */ case    3:  		/* bc 4, CR6_EQ, 116 */
		/* 820FF7F8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820FF86C;  }
		/* 820FF7F8h case    3:*/		return 0x820FF7FC;
		  /* 820FF7FCh */ case    4:  		/* lwz R11, <#[R10 + 12]> */
		/* 820FF7FCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 820FF7FCh case    4:*/		return 0x820FF800;
		  /* 820FF800h */ case    5:  		/* lwz R9, <#[R31 + 12]> */
		/* 820FF800h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 820FF800h case    5:*/		return 0x820FF804;
		  /* 820FF804h */ case    6:  		/* cmplw CR6, R11, R9 */
		/* 820FF804h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820FF804h case    6:*/		return 0x820FF808;
		  /* 820FF808h */ case    7:  		/* bc 4, CR6_EQ, 100 */
		/* 820FF808h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820FF86C;  }
		/* 820FF808h case    7:*/		return 0x820FF80C;
		  /* 820FF80Ch */ case    8:  		/* lwz R11, <#[R10 + 8]> */
		/* 820FF80Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 820FF80Ch case    8:*/		return 0x820FF810;
		  /* 820FF810h */ case    9:  		/* lwz R9, <#[R31 + 8]> */
		/* 820FF810h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 820FF810h case    9:*/		return 0x820FF814;
		  /* 820FF814h */ case   10:  		/* cmplw CR6, R11, R9 */
		/* 820FF814h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820FF814h case   10:*/		return 0x820FF818;
		  /* 820FF818h */ case   11:  		/* bc 4, CR6_EQ, 84 */
		/* 820FF818h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820FF86C;  }
		/* 820FF818h case   11:*/		return 0x820FF81C;
		  /* 820FF81Ch */ case   12:  		/* mr R9, R20 */
		/* 820FF81Ch case   12:*/		regs.R9 = regs.R20;
		/* 820FF81Ch case   12:*/		return 0x820FF820;
		  /* 820FF820h */ case   13:  		/* mr R11, R23 */
		/* 820FF820h case   13:*/		regs.R11 = regs.R23;
		/* 820FF820h case   13:*/		return 0x820FF824;
		  /* 820FF824h */ case   14:  		/* cmpwi CR6, R23, -1 */
		/* 820FF824h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R23,0xFFFFFFFF);
		/* 820FF824h case   14:*/		return 0x820FF828;
		  /* 820FF828h */ case   15:  		/* bc 12, CR6_EQ, 44 */
		/* 820FF828h case   15:*/		if ( regs.CR[6].eq ) { return 0x820FF854;  }
		/* 820FF828h case   15:*/		return 0x820FF82C;
		  /* 820FF82Ch */ case   16:  		/* lwz R8, <#[R10 + 20]> */
		/* 820FF82Ch case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000014) );
		/* 820FF82Ch case   16:*/		return 0x820FF830;
		  /* 820FF830h */ case   17:  		/* cmplw CR6, R11, R8 */
		/* 820FF830h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820FF830h case   17:*/		return 0x820FF834;
		  /* 820FF834h */ case   18:  		/* bc 12, CR6_EQ, 32 */
		/* 820FF834h case   18:*/		if ( regs.CR[6].eq ) { return 0x820FF854;  }
		/* 820FF834h case   18:*/		return 0x820FF838;
		  /* 820FF838h */ case   19:  		/* lwz R9, <#[R29 + 20]> */
		/* 820FF838h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000014) );
		/* 820FF838h case   19:*/		return 0x820FF83C;
		  /* 820FF83Ch */ case   20:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FF83Ch case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FF83Ch case   20:*/		return 0x820FF840;
		  /* 820FF840h */ case   21:  		/* lwzx R9, <#[R11 + R9]> */
		/* 820FF840h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FF840h case   21:*/		return 0x820FF844;
		  /* 820FF844h */ case   22:  		/* lwz R11, <#[R9 + 20]> */
		/* 820FF844h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000014) );
		/* 820FF844h case   22:*/		return 0x820FF848;
		  /* 820FF848h */ case   23:  		/* lwz R9, <#[R9 + 24]> */
		/* 820FF848h case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000018) );
		/* 820FF848h case   23:*/		return 0x820FF84C;
		  /* 820FF84Ch */ case   24:  		/* cmpwi CR6, R11, -1 */
		/* 820FF84Ch case   24:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FF84Ch case   24:*/		return 0x820FF850;
		  /* 820FF850h */ case   25:  		/* bc 4, CR6_EQ, -32 */
		/* 820FF850h case   25:*/		if ( !regs.CR[6].eq ) { return 0x820FF830;  }
		/* 820FF850h case   25:*/		return 0x820FF854;
	}
	return 0x820FF854;
} // Block from 820FF7ECh-820FF854h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820FF854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF854);
		  /* 820FF854h */ case    0:  		/* lwz R8, <#[R10 + 20]> */
		/* 820FF854h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000014) );
		/* 820FF854h case    0:*/		return 0x820FF858;
		  /* 820FF858h */ case    1:  		/* cmplw CR6, R11, R8 */
		/* 820FF858h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820FF858h case    1:*/		return 0x820FF85C;
		  /* 820FF85Ch */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820FF85Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FF86C;  }
		/* 820FF85Ch case    2:*/		return 0x820FF860;
		  /* 820FF860h */ case    3:  		/* lwz R11, <#[R10 + 24]> */
		/* 820FF860h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000018) );
		/* 820FF860h case    3:*/		return 0x820FF864;
		  /* 820FF864h */ case    4:  		/* cmpw CR6, R9, R11 */
		/* 820FF864h case    4:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R11);
		/* 820FF864h case    4:*/		return 0x820FF868;
		  /* 820FF868h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 820FF868h case    5:*/		if ( regs.CR[6].eq ) { return 0x820FF87C;  }
		/* 820FF868h case    5:*/		return 0x820FF86C;
	}
	return 0x820FF86C;
} // Block from 820FF854h-820FF86Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FF86Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF86C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF86C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF86C);
		  /* 820FF86Ch */ case    0:  		/* lwz R7, <#[R10 + 52]> */
		/* 820FF86Ch case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000034) );
		/* 820FF86Ch case    0:*/		return 0x820FF870;
		  /* 820FF870h */ case    1:  		/* cmplw CR6, R7, R4 */
		/* 820FF870h case    1:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R4);
		/* 820FF870h case    1:*/		return 0x820FF874;
		  /* 820FF874h */ case    2:  		/* bc 4, CR6_EQ, -176 */
		/* 820FF874h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FF7C4;  }
		/* 820FF874h case    2:*/		return 0x820FF878;
		  /* 820FF878h */ case    3:  		/* b 24 */
		/* 820FF878h case    3:*/		return 0x820FF890;
		/* 820FF878h case    3:*/		return 0x820FF87C;
	}
	return 0x820FF87C;
} // Block from 820FF86Ch-820FF87Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FF87Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF87C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF87C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF87C);
		  /* 820FF87Ch */ case    0:  		/* addi R6, R6, 1 */
		/* 820FF87Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820FF87Ch case    0:*/		return 0x820FF880;
		  /* 820FF880h */ case    1:  		/* stwx R7, <#[R3 + R5]> */
		/* 820FF880h case    1:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + regs.R5 + 0x00000000) );
		/* 820FF880h case    1:*/		return 0x820FF884;
		  /* 820FF884h */ case    2:  		/* addi R5, R5, 4 */
		/* 820FF884h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 820FF884h case    2:*/		return 0x820FF888;
		  /* 820FF888h */ case    3:  		/* cmplw CR6, R6, R24 */
		/* 820FF888h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R24);
		/* 820FF888h case    3:*/		return 0x820FF88C;
		  /* 820FF88Ch */ case    4:  		/* bc 12, CR6_LT, -208 */
		/* 820FF88Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x820FF7BC;  }
		/* 820FF88Ch case    4:*/		return 0x820FF890;
	}
	return 0x820FF890;
} // Block from 820FF87Ch-820FF890h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FF890h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF890);
		  /* 820FF890h */ case    0:  		/* cmplw CR6, R6, R24 */
		/* 820FF890h case    0:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R24);
		/* 820FF890h case    0:*/		return 0x820FF894;
		  /* 820FF894h */ case    1:  		/* bc 4, CR6_EQ, 108 */
		/* 820FF894h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820FF900;  }
		/* 820FF894h case    1:*/		return 0x820FF898;
		  /* 820FF898h */ case    2:  		/* li R11, 0 */
		/* 820FF898h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820FF898h case    2:*/		return 0x820FF89C;
		  /* 820FF89Ch */ case    3:  		/* cmplwi CR6, R24, 0 */
		/* 820FF89Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820FF89Ch case    3:*/		return 0x820FF8A0;
		  /* 820FF8A0h */ case    4:  		/* bc 12, CR6_EQ, 68 */
		/* 820FF8A0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820FF8E4;  }
		/* 820FF8A0h case    4:*/		return 0x820FF8A4;
		  /* 820FF8A4h */ case    5:  		/* addi R9, R1, 80 */
		/* 820FF8A4h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x50);
		/* 820FF8A4h case    5:*/		return 0x820FF8A8;
		  /* 820FF8A8h */ case    6:  		/* mtspr CTR, R24 */
		/* 820FF8A8h case    6:*/		regs.CTR = regs.R24;
		/* 820FF8A8h case    6:*/		return 0x820FF8AC;
		  /* 820FF8ACh */ case    7:  		/* lwz R10, <#[R9]> */
		/* 820FF8ACh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 820FF8ACh case    7:*/		return 0x820FF8B0;
		  /* 820FF8B0h */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FF8B0h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FF8B0h case    8:*/		return 0x820FF8B4;
		  /* 820FF8B4h */ case    9:  		/* lwzx R8, <#[R30 + R10]> */
		/* 820FF8B4h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + regs.R10 + 0x00000000) );
		/* 820FF8B4h case    9:*/		return 0x820FF8B8;
		  /* 820FF8B8h */ case   10:  		/* lwz R8, <#[R8 + 72]> */
		/* 820FF8B8h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000048) );
		/* 820FF8B8h case   10:*/		return 0x820FF8BC;
		  /* 820FF8BCh */ case   11:  		/* cmplwi CR6, R8, 0 */
		/* 820FF8BCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820FF8BCh case   11:*/		return 0x820FF8C0;
		  /* 820FF8C0h */ case   12:  		/* bc 12, CR6_EQ, 28 */
		/* 820FF8C0h case   12:*/		if ( regs.CR[6].eq ) { return 0x820FF8DC;  }
		/* 820FF8C0h case   12:*/		return 0x820FF8C4;
		  /* 820FF8C4h */ case   13:  		/* lwz R8, <#[R29 + 20]> */
		/* 820FF8C4h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000014) );
		/* 820FF8C4h case   13:*/		return 0x820FF8C8;
		  /* 820FF8C8h */ case   14:  		/* lwzx R10, <#[R8 + R10]> */
		/* 820FF8C8h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 820FF8C8h case   14:*/		return 0x820FF8CC;
		  /* 820FF8CCh */ case   15:  		/* lwz R10, <#[R10 + 72]> */
		/* 820FF8CCh case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000048) );
		/* 820FF8CCh case   15:*/		return 0x820FF8D0;
		  /* 820FF8D0h */ case   16:  		/* subf R10, R10, R21 */
		/* 820FF8D0h case   16:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R21);
		/* 820FF8D0h case   16:*/		return 0x820FF8D4;
		  /* 820FF8D4h */ case   17:  		/* mullw R10, R10, R10 */
		/* 820FF8D4h case   17:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 820FF8D4h case   17:*/		return 0x820FF8D8;
		  /* 820FF8D8h */ case   18:  		/* add R11, R10, R11 */
		/* 820FF8D8h case   18:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820FF8D8h case   18:*/		return 0x820FF8DC;
	}
	return 0x820FF8DC;
} // Block from 820FF890h-820FF8DCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 820FF8DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF8DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF8DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF8DC);
		  /* 820FF8DCh */ case    0:  		/* addi R9, R9, 4 */
		/* 820FF8DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820FF8DCh case    0:*/		return 0x820FF8E0;
		  /* 820FF8E0h */ case    1:  		/* bc 16, CR0_LT, -52 */
		/* 820FF8E0h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820FF8AC;  }
		/* 820FF8E0h case    1:*/		return 0x820FF8E4;
	}
	return 0x820FF8E4;
} // Block from 820FF8DCh-820FF8E4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FF8E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF8E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF8E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF8E4);
		  /* 820FF8E4h */ case    0:  		/* cmplw CR6, R27, R11 */
		/* 820FF8E4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 820FF8E4h case    0:*/		return 0x820FF8E8;
		  /* 820FF8E8h */ case    1:  		/* bc 4, CR6_GT, 24 */
		/* 820FF8E8h case    1:*/		if ( !regs.CR[6].gt ) { return 0x820FF900;  }
		/* 820FF8E8h case    1:*/		return 0x820FF8EC;
		  /* 820FF8ECh */ case    2:  		/* rlwinm R5, R24, 2, 0, 29 */
		/* 820FF8ECh case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R24);
		/* 820FF8ECh case    2:*/		return 0x820FF8F0;
		  /* 820FF8F0h */ case    3:  		/* addi R4, R1, 80 */
		/* 820FF8F0h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820FF8F0h case    3:*/		return 0x820FF8F4;
		  /* 820FF8F4h */ case    4:  		/* addi R3, R1, 96 */
		/* 820FF8F4h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820FF8F4h case    4:*/		return 0x820FF8F8;
		  /* 820FF8F8h */ case    5:  		/* mr R27, R11 */
		/* 820FF8F8h case    5:*/		regs.R27 = regs.R11;
		/* 820FF8F8h case    5:*/		return 0x820FF8FC;
		  /* 820FF8FCh */ case    6:  		/* bl -450380 */
		/* 820FF8FCh case    6:*/		regs.LR = 0x820FF900; return 0x820919B0;
		/* 820FF8FCh case    6:*/		return 0x820FF900;
	}
	return 0x820FF900;
} // Block from 820FF8E4h-820FF900h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820FF900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF900);
		  /* 820FF900h */ case    0:  		/* lwz R10, <#[R31 + 52]> */
		/* 820FF900h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000034) );
		/* 820FF900h case    0:*/		return 0x820FF904;
		  /* 820FF904h */ case    1:  		/* cmplw CR6, R10, R28 */
		/* 820FF904h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R28);
		/* 820FF904h case    1:*/		return 0x820FF908;
		  /* 820FF908h */ case    2:  		/* bc 4, CR6_EQ, -480 */
		/* 820FF908h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FF728;  }
		/* 820FF908h case    2:*/		return 0x820FF90C;
		  /* 820FF90Ch */ case    3:  		/* cmpwi CR6, R27, -1 */
		/* 820FF90Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R27,0xFFFFFFFF);
		/* 820FF90Ch case    3:*/		return 0x820FF910;
		  /* 820FF910h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 820FF910h case    4:*/		if ( regs.CR[6].eq ) { return 0x820FF928;  }
		/* 820FF910h case    4:*/		return 0x820FF914;
		  /* 820FF914h */ case    5:  		/* rlwinm R5, R24, 2, 0, 29 */
		/* 820FF914h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R24);
		/* 820FF914h case    5:*/		return 0x820FF918;
		  /* 820FF918h */ case    6:  		/* addi R4, R1, 96 */
		/* 820FF918h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 820FF918h case    6:*/		return 0x820FF91C;
		  /* 820FF91Ch */ case    7:  		/* mr R3, R22 */
		/* 820FF91Ch case    7:*/		regs.R3 = regs.R22;
		/* 820FF91Ch case    7:*/		return 0x820FF920;
		  /* 820FF920h */ case    8:  		/* bl -450416 */
		/* 820FF920h case    8:*/		regs.LR = 0x820FF924; return 0x820919B0;
		/* 820FF920h case    8:*/		return 0x820FF924;
		  /* 820FF924h */ case    9:  		/* b 436 */
		/* 820FF924h case    9:*/		return 0x820FFAD8;
		/* 820FF924h case    9:*/		return 0x820FF928;
	}
	return 0x820FF928;
} // Block from 820FF900h-820FF928h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FF928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF928);
		  /* 820FF928h */ case    0:  		/* li R11, 1 */
		/* 820FF928h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820FF928h case    0:*/		return 0x820FF92C;
		  /* 820FF92Ch */ case    1:  		/* mr R4, R24 */
		/* 820FF92Ch case    1:*/		regs.R4 = regs.R24;
		/* 820FF92Ch case    1:*/		return 0x820FF930;
		  /* 820FF930h */ case    2:  		/* mr R6, R25 */
		/* 820FF930h case    2:*/		regs.R6 = regs.R25;
		/* 820FF930h case    2:*/		return 0x820FF934;
		  /* 820FF934h */ case    3:  		/* rlwimi R4, R11, 28, 0, 11 */
		/* 820FF934h case    3:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R4,regs.R11);
		/* 820FF934h case    3:*/		return 0x820FF938;
		  /* 820FF938h */ case    4:  		/* mr R5, R25 */
		/* 820FF938h case    4:*/		regs.R5 = regs.R25;
		/* 820FF938h case    4:*/		return 0x820FF93C;
		  /* 820FF93Ch */ case    5:  		/* mr R3, R29 */
		/* 820FF93Ch case    5:*/		regs.R3 = regs.R29;
		/* 820FF93Ch case    5:*/		return 0x820FF940;
		  /* 820FF940h */ case    6:  		/* bl -9848 */
		/* 820FF940h case    6:*/		regs.LR = 0x820FF944; return 0x820FD2C8;
		/* 820FF940h case    6:*/		return 0x820FF944;
		  /* 820FF944h */ case    7:  		/* mr R27, R3 */
		/* 820FF944h case    7:*/		regs.R27 = regs.R3;
		/* 820FF944h case    7:*/		return 0x820FF948;
		  /* 820FF948h */ case    8:  		/* cmpwi CR6, R3, -1 */
		/* 820FF948h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820FF948h case    8:*/		return 0x820FF94C;
		  /* 820FF94Ch */ case    9:  		/* bc 4, CR6_EQ, 16 */
		/* 820FF94Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x820FF95C;  }
		/* 820FF94Ch case    9:*/		return 0x820FF950;
		  /* 820FF950h */ case   10:  		/* lis R3, -32761 */
		/* 820FF950h case   10:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820FF950h case   10:*/		return 0x820FF954;
		  /* 820FF954h */ case   11:  		/* ori R3, R3, 14 */
		/* 820FF954h case   11:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820FF954h case   11:*/		return 0x820FF958;
		  /* 820FF958h */ case   12:  		/* b 388 */
		/* 820FF958h case   12:*/		return 0x820FFADC;
		/* 820FF958h case   12:*/		return 0x820FF95C;
	}
	return 0x820FF95C;
} // Block from 820FF928h-820FF95Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FF95Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FF95C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FF95C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FF95C);
		  /* 820FF95Ch */ case    0:  		/* lwz R11, <#[R29 + 24]> */
		/* 820FF95Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 820FF95Ch case    0:*/		return 0x820FF960;
		  /* 820FF960h */ case    1:  		/* rlwinm R25, R27, 2, 0, 29 */
		/* 820FF960h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R25,regs.R27);
		/* 820FF960h case    1:*/		return 0x820FF964;
		  /* 820FF964h */ case    2:  		/* lwzx R30, <#[R11 + R25]> */
		/* 820FF964h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 820FF964h case    2:*/		return 0x820FF968;
		  /* 820FF968h */ case    3:  		/* lwzx R4, <#[R11 + R26]> */
		/* 820FF968h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 820FF968h case    3:*/		return 0x820FF96C;
		  /* 820FF96Ch */ case    4:  		/* mr R3, R30 */
		/* 820FF96Ch case    4:*/		regs.R3 = regs.R30;
		/* 820FF96Ch case    4:*/		return 0x820FF970;
		  /* 820FF970h */ case    5:  		/* bl -14976 */
		/* 820FF970h case    5:*/		regs.LR = 0x820FF974; return 0x820FBEF0;
		/* 820FF970h case    5:*/		return 0x820FF974;
		  /* 820FF974h */ case    6:  		/* li R28, 0 */
		/* 820FF974h case    6:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820FF974h case    6:*/		return 0x820FF978;
		  /* 820FF978h */ case    7:  		/* cmplwi CR6, R24, 0 */
		/* 820FF978h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820FF978h case    7:*/		return 0x820FF97C;
		  /* 820FF97Ch */ case    8:  		/* bc 12, CR6_EQ, 276 */
		/* 820FF97Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x820FFA90;  }
		/* 820FF97Ch case    8:*/		return 0x820FF980;
		  /* 820FF980h */ case    9:  		/* lis R11, -32256 */
		/* 820FF980h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820FF980h case    9:*/		return 0x820FF984;
		  /* 820FF984h */ case   10:  		/* li R31, 0 */
		/* 820FF984h case   10:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820FF984h case   10:*/		return 0x820FF988;
		  /* 820FF988h */ case   11:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 820FF988h case   11:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 820FF988h case   11:*/		return 0x820FF98C;
		  /* 820FF98Ch */ case   12:  		/* lwz R11, <#[R30 + 8]> */
		/* 820FF98Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820FF98Ch case   12:*/		return 0x820FF990;
		  /* 820FF990h */ case   13:  		/* mr R6, R28 */
		/* 820FF990h case   13:*/		regs.R6 = regs.R28;
		/* 820FF990h case   13:*/		return 0x820FF994;
		  /* 820FF994h */ case   14:  		/* lwzx R10, <#[R31 + R22]> */
		/* 820FF994h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + regs.R22 + 0x00000000) );
		/* 820FF994h case   14:*/		return 0x820FF998;
		  /* 820FF998h */ case   15:  		/* mr R3, R29 */
		/* 820FF998h case   15:*/		regs.R3 = regs.R29;
		/* 820FF998h case   15:*/		return 0x820FF99C;
		  /* 820FF99Ch */ case   16:  		/* add R26, R31, R22 */
		/* 820FF99Ch case   16:*/		cpu::op::add<0>(regs,&regs.R26,regs.R31,regs.R22);
		/* 820FF99Ch case   16:*/		return 0x820FF9A0;
		  /* 820FF9A0h */ case   17:  		/* fmr FR1, FR31 */
		/* 820FF9A0h case   17:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820FF9A0h case   17:*/		return 0x820FF9A4;
		  /* 820FF9A4h */ case   18:  		/* stwx R10, <#[R11 + R31]> */
		/* 820FF9A4h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820FF9A4h case   18:*/		return 0x820FF9A8;
		  /* 820FF9A8h */ case   19:  		/* lwz R5, <#[R19]> */
		/* 820FF9A8h case   19:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R19 + 0x00000000) );
		/* 820FF9A8h case   19:*/		return 0x820FF9AC;
		  /* 820FF9ACh */ case   20:  		/* lwz R4, <#[R29 + 136]> */
		/* 820FF9ACh case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000088) );
		/* 820FF9ACh case   20:*/		return 0x820FF9B0;
		  /* 820FF9B0h */ case   21:  		/* bl -10120 */
		/* 820FF9B0h case   21:*/		regs.LR = 0x820FF9B4; return 0x820FD228;
		/* 820FF9B0h case   21:*/		return 0x820FF9B4;
		  /* 820FF9B4h */ case   22:  		/* lwz R11, <#[R30 + 16]> */
		/* 820FF9B4h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820FF9B4h case   22:*/		return 0x820FF9B8;
		  /* 820FF9B8h */ case   23:  		/* stwx R3, <#[R11 + R31]> */
		/* 820FF9B8h case   23:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820FF9B8h case   23:*/		return 0x820FF9BC;
		  /* 820FF9BCh */ case   24:  		/* lwz R11, <#[R30 + 16]> */
		/* 820FF9BCh case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820FF9BCh case   24:*/		return 0x820FF9C0;
		  /* 820FF9C0h */ case   25:  		/* lwzx R11, <#[R11 + R31]> */
		/* 820FF9C0h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820FF9C0h case   25:*/		return 0x820FF9C4;
		  /* 820FF9C4h */ case   26:  		/* cmpwi CR6, R11, -1 */
		/* 820FF9C4h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820FF9C4h case   26:*/		return 0x820FF9C8;
		  /* 820FF9C8h */ case   27:  		/* bc 12, CR6_EQ, -120 */
		/* 820FF9C8h case   27:*/		if ( regs.CR[6].eq ) { return 0x820FF950;  }
		/* 820FF9C8h case   27:*/		return 0x820FF9CC;
		  /* 820FF9CCh */ case   28:  		/* lwz R11, <#[R30 + 16]> */
		/* 820FF9CCh case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820FF9CCh case   28:*/		return 0x820FF9D0;
		  /* 820FF9D0h */ case   29:  		/* addi R28, R28, 1 */
		/* 820FF9D0h case   29:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820FF9D0h case   29:*/		return 0x820FF9D4;
		  /* 820FF9D4h */ case   30:  		/* lwz R10, <#[R29 + 20]> */
		/* 820FF9D4h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000014) );
		/* 820FF9D4h case   30:*/		return 0x820FF9D8;
		  /* 820FF9D8h */ case   31:  		/* cmplw CR6, R28, R24 */
		/* 820FF9D8h case   31:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R24);
		/* 820FF9D8h case   31:*/		return 0x820FF9DC;
		  /* 820FF9DCh */ case   32:  		/* lwzx R11, <#[R11 + R31]> */
		/* 820FF9DCh case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820FF9DCh case   32:*/		return 0x820FF9E0;
		  /* 820FF9E0h */ case   33:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FF9E0h case   33:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FF9E0h case   33:*/		return 0x820FF9E4;
		  /* 820FF9E4h */ case   34:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820FF9E4h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FF9E4h case   34:*/		return 0x820FF9E8;
		  /* 820FF9E8h */ case   35:  		/* stw R20, <#[R11 + 24]> */
		/* 820FF9E8h case   35:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R11 + 0x00000018) );
		/* 820FF9E8h case   35:*/		return 0x820FF9EC;
		  /* 820FF9ECh */ case   36:  		/* lwz R11, <#[R30 + 16]> */
		/* 820FF9ECh case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820FF9ECh case   36:*/		return 0x820FF9F0;
		  /* 820FF9F0h */ case   37:  		/* lwz R10, <#[R29 + 20]> */
		/* 820FF9F0h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000014) );
		/* 820FF9F0h case   37:*/		return 0x820FF9F4;
		  /* 820FF9F4h */ case   38:  		/* lwzx R11, <#[R11 + R31]> */
		/* 820FF9F4h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820FF9F4h case   38:*/		return 0x820FF9F8;
		  /* 820FF9F8h */ case   39:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FF9F8h case   39:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FF9F8h case   39:*/		return 0x820FF9FC;
		  /* 820FF9FCh */ case   40:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820FF9FCh case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FF9FCh case   40:*/		return 0x820FFA00;
		  /* 820FFA00h */ case   41:  		/* stw R23, <#[R11 + 20]> */
		/* 820FFA00h case   41:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000014) );
		/* 820FFA00h case   41:*/		return 0x820FFA04;
		  /* 820FFA04h */ case   42:  		/* lwz R11, <#[R30 + 16]> */
		/* 820FFA04h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820FFA04h case   42:*/		return 0x820FFA08;
		  /* 820FFA08h */ case   43:  		/* lwz R10, <#[R30 + 8]> */
		/* 820FFA08h case   43:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 820FFA08h case   43:*/		return 0x820FFA0C;
		  /* 820FFA0Ch */ case   44:  		/* lwz R9, <#[R29 + 20]> */
		/* 820FFA0Ch case   44:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000014) );
		/* 820FFA0Ch case   44:*/		return 0x820FFA10;
		  /* 820FFA10h */ case   45:  		/* lwzx R11, <#[R11 + R31]> */
		/* 820FFA10h case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820FFA10h case   45:*/		return 0x820FFA14;
		  /* 820FFA14h */ case   46:  		/* lwzx R10, <#[R10 + R31]> */
		/* 820FFA14h case   46:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 820FFA14h case   46:*/		return 0x820FFA18;
		  /* 820FFA18h */ case   47:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FFA18h case   47:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FFA18h case   47:*/		return 0x820FFA1C;
		  /* 820FFA1Ch */ case   48:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FFA1Ch case   48:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FFA1Ch case   48:*/		return 0x820FFA20;
		  /* 820FFA20h */ case   49:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820FFA20h case   49:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820FFA20h case   49:*/		return 0x820FFA24;
		  /* 820FFA24h */ case   50:  		/* lwz R10, <#[R10]> */
		/* 820FFA24h case   50:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820FFA24h case   50:*/		return 0x820FFA28;
		  /* 820FFA28h */ case   51:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820FFA28h case   51:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FFA28h case   51:*/		return 0x820FFA2C;
		  /* 820FFA2Ch */ case   52:  		/* stw R10, <#[R11]> */
		/* 820FFA2Ch case   52:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820FFA2Ch case   52:*/		return 0x820FFA30;
		  /* 820FFA30h */ case   53:  		/* lwz R11, <#[R30 + 16]> */
		/* 820FFA30h case   53:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820FFA30h case   53:*/		return 0x820FFA34;
		  /* 820FFA34h */ case   54:  		/* lwz R10, <#[R30 + 8]> */
		/* 820FFA34h case   54:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 820FFA34h case   54:*/		return 0x820FFA38;
		  /* 820FFA38h */ case   55:  		/* lwz R9, <#[R29 + 20]> */
		/* 820FFA38h case   55:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000014) );
		/* 820FFA38h case   55:*/		return 0x820FFA3C;
		  /* 820FFA3Ch */ case   56:  		/* lwzx R11, <#[R11 + R31]> */
		/* 820FFA3Ch case   56:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820FFA3Ch case   56:*/		return 0x820FFA40;
		  /* 820FFA40h */ case   57:  		/* lwzx R10, <#[R10 + R31]> */
		/* 820FFA40h case   57:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 820FFA40h case   57:*/		return 0x820FFA44;
		  /* 820FFA44h */ case   58:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FFA44h case   58:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FFA44h case   58:*/		return 0x820FFA48;
		  /* 820FFA48h */ case   59:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FFA48h case   59:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FFA48h case   59:*/		return 0x820FFA4C;
		  /* 820FFA4Ch */ case   60:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820FFA4Ch case   60:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820FFA4Ch case   60:*/		return 0x820FFA50;
		  /* 820FFA50h */ case   61:  		/* lwz R10, <#[R10 + 52]> */
		/* 820FFA50h case   61:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000034) );
		/* 820FFA50h case   61:*/		return 0x820FFA54;
		  /* 820FFA54h */ case   62:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820FFA54h case   62:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FFA54h case   62:*/		return 0x820FFA58;
		  /* 820FFA58h */ case   63:  		/* stw R10, <#[R11 + 52]> */
		/* 820FFA58h case   63:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000034) );
		/* 820FFA58h case   63:*/		return 0x820FFA5C;
		  /* 820FFA5Ch */ case   64:  		/* lwz R11, <#[R30 + 16]> */
		/* 820FFA5Ch case   64:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820FFA5Ch case   64:*/		return 0x820FFA60;
		  /* 820FFA60h */ case   65:  		/* lwz R10, <#[R30 + 8]> */
		/* 820FFA60h case   65:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 820FFA60h case   65:*/		return 0x820FFA64;
		  /* 820FFA64h */ case   66:  		/* lwz R9, <#[R29 + 20]> */
		/* 820FFA64h case   66:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000014) );
		/* 820FFA64h case   66:*/		return 0x820FFA68;
		  /* 820FFA68h */ case   67:  		/* lwzx R11, <#[R11 + R31]> */
		/* 820FFA68h case   67:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820FFA68h case   67:*/		return 0x820FFA6C;
		  /* 820FFA6Ch */ case   68:  		/* lwzx R10, <#[R10 + R31]> */
		/* 820FFA6Ch case   68:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 820FFA6Ch case   68:*/		return 0x820FFA70;
		  /* 820FFA70h */ case   69:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FFA70h case   69:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FFA70h case   69:*/		return 0x820FFA74;
		  /* 820FFA74h */ case   70:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820FFA74h case   70:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820FFA74h case   70:*/		return 0x820FFA78;
		  /* 820FFA78h */ case   71:  		/* stw R11, <#[R10 + 52]> */
		/* 820FFA78h case   71:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000034) );
		/* 820FFA78h case   71:*/		return 0x820FFA7C;
		  /* 820FFA7Ch */ case   72:  		/* lwz R11, <#[R30 + 16]> */
		/* 820FFA7Ch case   72:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820FFA7Ch case   72:*/		return 0x820FFA80;
		  /* 820FFA80h */ case   73:  		/* lwzx R11, <#[R11 + R31]> */
		/* 820FFA80h case   73:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820FFA80h case   73:*/		return 0x820FFA84;
		  /* 820FFA84h */ case   74:  		/* addi R31, R31, 4 */
		/* 820FFA84h case   74:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820FFA84h case   74:*/		return 0x820FFA88;
		  /* 820FFA88h */ case   75:  		/* stw R11, <#[R26]> */
		/* 820FFA88h case   75:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820FFA88h case   75:*/		return 0x820FFA8C;
		  /* 820FFA8Ch */ case   76:  		/* bc 12, CR6_LT, -256 */
		/* 820FFA8Ch case   76:*/		if ( regs.CR[6].lt ) { return 0x820FF98C;  }
		/* 820FFA8Ch case   76:*/		return 0x820FFA90;
	}
	return 0x820FFA90;
} // Block from 820FF95Ch-820FFA90h (77 instructions)

//////////////////////////////////////////////////////
// Block at 820FFA90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFA90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFA90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFA90);
		  /* 820FFA90h */ case    0:  		/* cmplw CR6, R27, R21 */
		/* 820FFA90h case    0:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R21);
		/* 820FFA90h case    0:*/		return 0x820FFA94;
		  /* 820FFA94h */ case    1:  		/* bc 4, CR6_GT, 44 */
		/* 820FFA94h case    1:*/		if ( !regs.CR[6].gt ) { return 0x820FFAC0;  }
		/* 820FFA94h case    1:*/		return 0x820FFA98;
		  /* 820FFA98h */ case    2:  		/* subf R10, R21, R27 */
		/* 820FFA98h case    2:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R21,regs.R27);
		/* 820FFA98h case    2:*/		return 0x820FFA9C;
		  /* 820FFA9Ch */ case    3:  		/* mr R11, R25 */
		/* 820FFA9Ch case    3:*/		regs.R11 = regs.R25;
		/* 820FFA9Ch case    3:*/		return 0x820FFAA0;
		  /* 820FFAA0h */ case    4:  		/* mtspr CTR, R10 */
		/* 820FFAA0h case    4:*/		regs.CTR = regs.R10;
		/* 820FFAA0h case    4:*/		return 0x820FFAA4;
		  /* 820FFAA4h */ case    5:  		/* lwz R10, <#[R29 + 24]> */
		/* 820FFAA4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000018) );
		/* 820FFAA4h case    5:*/		return 0x820FFAA8;
		  /* 820FFAA8h */ case    6:  		/* addi R27, R27, -1 */
		/* 820FFAA8h case    6:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0xFFFFFFFF);
		/* 820FFAA8h case    6:*/		return 0x820FFAAC;
		  /* 820FFAACh */ case    7:  		/* add R10, R10, R11 */
		/* 820FFAACh case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820FFAACh case    7:*/		return 0x820FFAB0;
		  /* 820FFAB0h */ case    8:  		/* addi R11, R11, -4 */
		/* 820FFAB0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 820FFAB0h case    8:*/		return 0x820FFAB4;
		  /* 820FFAB4h */ case    9:  		/* lwz R9, <#[R10 - 4]> */
		/* 820FFAB4h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 820FFAB4h case    9:*/		return 0x820FFAB8;
		  /* 820FFAB8h */ case   10:  		/* stw R9, <#[R10]> */
		/* 820FFAB8h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820FFAB8h case   10:*/		return 0x820FFABC;
		  /* 820FFABCh */ case   11:  		/* bc 16, CR0_LT, -24 */
		/* 820FFABCh case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820FFAA4;  }
		/* 820FFABCh case   11:*/		return 0x820FFAC0;
	}
	return 0x820FFAC0;
} // Block from 820FFA90h-820FFAC0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820FFAC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFAC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFAC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFAC0);
		  /* 820FFAC0h */ case    0:  		/* lwz R11, <#[R29 + 24]> */
		/* 820FFAC0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 820FFAC0h case    0:*/		return 0x820FFAC4;
		  /* 820FFAC4h */ case    1:  		/* rlwinm R10, R27, 2, 0, 29 */
		/* 820FFAC4h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R27);
		/* 820FFAC4h case    1:*/		return 0x820FFAC8;
		  /* 820FFAC8h */ case    2:  		/* stwx R30, <#[R10 + R11]> */
		/* 820FFAC8h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820FFAC8h case    2:*/		return 0x820FFACC;
		  /* 820FFACCh */ case    3:  		/* lwz R11, <#[R19]> */
		/* 820FFACCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 820FFACCh case    3:*/		return 0x820FFAD0;
		  /* 820FFAD0h */ case    4:  		/* addi R11, R11, 1 */
		/* 820FFAD0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820FFAD0h case    4:*/		return 0x820FFAD4;
		  /* 820FFAD4h */ case    5:  		/* stw R11, <#[R19]> */
		/* 820FFAD4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 820FFAD4h case    5:*/		return 0x820FFAD8;
	}
	return 0x820FFAD8;
} // Block from 820FFAC0h-820FFAD8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FFAD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFAD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFAD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFAD8);
		  /* 820FFAD8h */ case    0:  		/* li R3, 0 */
		/* 820FFAD8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FFAD8h case    0:*/		return 0x820FFADC;
	}
	return 0x820FFADC;
} // Block from 820FFAD8h-820FFADCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FFADCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFADC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFADC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFADC);
		  /* 820FFADCh */ case    0:  		/* addi R1, R1, 240 */
		/* 820FFADCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 820FFADCh case    0:*/		return 0x820FFAE0;
		  /* 820FFAE0h */ case    1:  		/* lfd FR31, <#[R1 - 120]> */
		/* 820FFAE0h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF88) );
		/* 820FFAE0h case    1:*/		return 0x820FFAE4;
		  /* 820FFAE4h */ case    2:  		/* b -452704 */
		/* 820FFAE4h case    2:*/		return 0x82091284;
		/* 820FFAE4h case    2:*/		return 0x820FFAE8;
		  /* 820FFAE8h */ case    3:  		/* lwz R11, <#[R3 + 108]> */
		/* 820FFAE8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000006C) );
		/* 820FFAE8h case    3:*/		return 0x820FFAEC;
		  /* 820FFAECh */ case    4:  		/* mr R6, R3 */
		/* 820FFAECh case    4:*/		regs.R6 = regs.R3;
		/* 820FFAECh case    4:*/		return 0x820FFAF0;
		  /* 820FFAF0h */ case    5:  		/* li R3, 0 */
		/* 820FFAF0h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FFAF0h case    5:*/		return 0x820FFAF4;
		  /* 820FFAF4h */ case    6:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 820FFAF4h case    6:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 820FFAF4h case    6:*/		return 0x820FFAF8;
		  /* 820FFAF8h */ case    7:  		/* bc 12, CR0_EQ, 128 */
		/* 820FFAF8h case    7:*/		if ( regs.CR[0].eq ) { return 0x820FFB78;  }
		/* 820FFAF8h case    7:*/		return 0x820FFAFC;
		  /* 820FFAFCh */ case    8:  		/* lwz R8, <#[R6 + 12]> */
		/* 820FFAFCh case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + 0x0000000C) );
		/* 820FFAFCh case    8:*/		return 0x820FFB00;
		  /* 820FFB00h */ case    9:  		/* cmplwi CR6, R8, 0 */
		/* 820FFB00h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820FFB00h case    9:*/		return 0x820FFB04;
		  /* 820FFB04h */ case   10:  		/* bclr 12, CR6_EQ */
		/* 820FFB04h case   10:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820FFB04h case   10:*/		return 0x820FFB08;
	}
	return 0x820FFB08;
} // Block from 820FFADCh-820FFB08h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820FFB08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFB08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFB08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFB08);
		  /* 820FFB08h */ case    0:  		/* lwz R7, <#[R6 + 24]> */
		/* 820FFB08h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R6 + 0x00000018) );
		/* 820FFB08h case    0:*/		return 0x820FFB0C;
		  /* 820FFB0Ch */ case    1:  		/* lwz R11, <#[R7]> */
		/* 820FFB0Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 820FFB0Ch case    1:*/		return 0x820FFB10;
		  /* 820FFB10h */ case    2:  		/* lwz R11, <#[R11 + 44]> */
		/* 820FFB10h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 820FFB10h case    2:*/		return 0x820FFB14;
		  /* 820FFB14h */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 820FFB14h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 820FFB14h case    3:*/		return 0x820FFB18;
		  /* 820FFB18h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 820FFB18h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820FFB20;  }
		/* 820FFB18h case    4:*/		return 0x820FFB1C;
		  /* 820FFB1Ch */ case    5:  		/* li R3, 1 */
		/* 820FFB1Ch case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FFB1Ch case    5:*/		return 0x820FFB20;
	}
	return 0x820FFB20;
} // Block from 820FFB08h-820FFB20h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FFB20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFB20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFB20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFB20);
		  /* 820FFB20h */ case    0:  		/* li R9, 1 */
		/* 820FFB20h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820FFB20h case    0:*/		return 0x820FFB24;
		  /* 820FFB24h */ case    1:  		/* cmplwi CR6, R8, 1 */
		/* 820FFB24h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000001);
		/* 820FFB24h case    1:*/		return 0x820FFB28;
		  /* 820FFB28h */ case    2:  		/* bclr 4, CR6_GT */
		/* 820FFB28h case    2:*/		if ( !regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 820FFB28h case    2:*/		return 0x820FFB2C;
	}
	return 0x820FFB2C;
} // Block from 820FFB20h-820FFB2Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FFB2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFB2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFB2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFB2C);
		  /* 820FFB2Ch */ case    0:  		/* li R11, 4 */
		/* 820FFB2Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 820FFB2Ch case    0:*/		return 0x820FFB30;
		  /* 820FFB30h */ case    1:  		/* lwzx R10, <#[R11 + R7]> */
		/* 820FFB30h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820FFB30h case    1:*/		return 0x820FFB34;
		  /* 820FFB34h */ case    2:  		/* lwz R10, <#[R10 + 44]> */
		/* 820FFB34h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000002C) );
		/* 820FFB34h case    2:*/		return 0x820FFB38;
		  /* 820FFB38h */ case    3:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 820FFB38h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 820FFB38h case    3:*/		return 0x820FFB3C;
		  /* 820FFB3Ch */ case    4:  		/* bc 12, CR0_EQ, 40 */
		/* 820FFB3Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x820FFB64;  }
		/* 820FFB3Ch case    4:*/		return 0x820FFB40;
		  /* 820FFB40h */ case    5:  		/* lwz R10, <#[R6 + 24]> */
		/* 820FFB40h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000018) );
		/* 820FFB40h case    5:*/		return 0x820FFB44;
		  /* 820FFB44h */ case    6:  		/* add R10, R10, R11 */
		/* 820FFB44h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820FFB44h case    6:*/		return 0x820FFB48;
		  /* 820FFB48h */ case    7:  		/* lwz R5, <#[R10 - 4]> */
		/* 820FFB48h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 820FFB48h case    7:*/		return 0x820FFB4C;
		  /* 820FFB4Ch */ case    8:  		/* lwz R10, <#[R10]> */
		/* 820FFB4Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820FFB4Ch case    8:*/		return 0x820FFB50;
		  /* 820FFB50h */ case    9:  		/* lwz R5, <#[R5 + 44]> */
		/* 820FFB50h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x0000002C) );
		/* 820FFB50h case    9:*/		return 0x820FFB54;
		  /* 820FFB54h */ case   10:  		/* lwz R10, <#[R10 + 44]> */
		/* 820FFB54h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000002C) );
		/* 820FFB54h case   10:*/		return 0x820FFB58;
		  /* 820FFB58h */ case   11:  		/* cmplw CR6, R10, R5 */
		/* 820FFB58h case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R5);
		/* 820FFB58h case   11:*/		return 0x820FFB5C;
		  /* 820FFB5Ch */ case   12:  		/* bc 12, CR6_EQ, 8 */
		/* 820FFB5Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x820FFB64;  }
		/* 820FFB5Ch case   12:*/		return 0x820FFB60;
		  /* 820FFB60h */ case   13:  		/* addi R3, R3, 1 */
		/* 820FFB60h case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 820FFB60h case   13:*/		return 0x820FFB64;
	}
	return 0x820FFB64;
} // Block from 820FFB2Ch-820FFB64h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820FFB64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFB64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFB64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFB64);
		  /* 820FFB64h */ case    0:  		/* addi R9, R9, 1 */
		/* 820FFB64h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820FFB64h case    0:*/		return 0x820FFB68;
		  /* 820FFB68h */ case    1:  		/* addi R11, R11, 4 */
		/* 820FFB68h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820FFB68h case    1:*/		return 0x820FFB6C;
		  /* 820FFB6Ch */ case    2:  		/* cmplw CR6, R9, R8 */
		/* 820FFB6Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820FFB6Ch case    2:*/		return 0x820FFB70;
		  /* 820FFB70h */ case    3:  		/* bc 12, CR6_LT, -64 */
		/* 820FFB70h case    3:*/		if ( regs.CR[6].lt ) { return 0x820FFB30;  }
		/* 820FFB70h case    3:*/		return 0x820FFB74;
		  /* 820FFB74h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820FFB74h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FFB74h case    4:*/		return 0x820FFB78;
	}
	return 0x820FFB78;
} // Block from 820FFB64h-820FFB78h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FFB78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFB78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFB78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFB78);
		  /* 820FFB78h */ case    0:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 820FFB78h case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 820FFB78h case    0:*/		return 0x820FFB7C;
		  /* 820FFB7Ch */ case    1:  		/* bclr 12, CR0_EQ */
		/* 820FFB7Ch case    1:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 820FFB7Ch case    1:*/		return 0x820FFB80;
	}
	return 0x820FFB80;
} // Block from 820FFB78h-820FFB80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FFB80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFB80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFB80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFB80);
		  /* 820FFB80h */ case    0:  		/* lwz R7, <#[R6 + 12]> */
		/* 820FFB80h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R6 + 0x0000000C) );
		/* 820FFB80h case    0:*/		return 0x820FFB84;
		  /* 820FFB84h */ case    1:  		/* li R8, 0 */
		/* 820FFB84h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820FFB84h case    1:*/		return 0x820FFB88;
		  /* 820FFB88h */ case    2:  		/* cmplwi CR6, R7, 0 */
		/* 820FFB88h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820FFB88h case    2:*/		return 0x820FFB8C;
		  /* 820FFB8Ch */ case    3:  		/* bclr 12, CR6_EQ */
		/* 820FFB8Ch case    3:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820FFB8Ch case    3:*/		return 0x820FFB90;
	}
	return 0x820FFB90;
} // Block from 820FFB80h-820FFB90h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FFB90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFB90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFB90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFB90);
		  /* 820FFB90h */ case    0:  		/* li R11, 0 */
		/* 820FFB90h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820FFB90h case    0:*/		return 0x820FFB94;
		  /* 820FFB94h */ case    1:  		/* li R10, 1 */
		/* 820FFB94h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820FFB94h case    1:*/		return 0x820FFB98;
	}
	return 0x820FFB98;
} // Block from 820FFB90h-820FFB98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FFB98h
// Function '?VectorizeLeft_IsSameRegister@CProgram@D3DXShader@@AAAHII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFB98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFB98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFB98);
		  /* 820FFB98h */ case    0:  		/* lwz R9, <#[R6 + 24]> */
		/* 820FFB98h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000018) );
		/* 820FFB98h case    0:*/		return 0x820FFB9C;
		  /* 820FFB9Ch */ case    1:  		/* lwzx R9, <#[R9 + R11]> */
		/* 820FFB9Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820FFB9Ch case    1:*/		return 0x820FFBA0;
		  /* 820FFBA0h */ case    2:  		/* lwz R9, <#[R9 + 44]> */
		/* 820FFBA0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000002C) );
		/* 820FFBA0h case    2:*/		return 0x820FFBA4;
		  /* 820FFBA4h */ case    3:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 820FFBA4h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 820FFBA4h case    3:*/		return 0x820FFBA8;
		  /* 820FFBA8h */ case    4:  		/* bc 12, CR0_EQ, 60 */
		/* 820FFBA8h case    4:*/		if ( regs.CR[0].eq ) { return 0x820FFBE4;  }
		/* 820FFBA8h case    4:*/		return 0x820FFBAC;
		  /* 820FFBACh */ case    5:  		/* addi R3, R3, 1 */
		/* 820FFBACh case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 820FFBACh case    5:*/		return 0x820FFBB0;
		  /* 820FFBB0h */ case    6:  		/* cmplw CR6, R10, R7 */
		/* 820FFBB0h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 820FFBB0h case    6:*/		return 0x820FFBB4;
		  /* 820FFBB4h */ case    7:  		/* bc 4, CR6_LT, 48 */
		/* 820FFBB4h case    7:*/		if ( !regs.CR[6].lt ) { return 0x820FFBE4;  }
		/* 820FFBB4h case    7:*/		return 0x820FFBB8;
		  /* 820FFBB8h */ case    8:  		/* lwz R9, <#[R6 + 24]> */
		/* 820FFBB8h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000018) );
		/* 820FFBB8h case    8:*/		return 0x820FFBBC;
		  /* 820FFBBCh */ case    9:  		/* add R9, R9, R11 */
		/* 820FFBBCh case    9:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 820FFBBCh case    9:*/		return 0x820FFBC0;
		  /* 820FFBC0h */ case   10:  		/* lwz R5, <#[R9 + 4]> */
		/* 820FFBC0h case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000004) );
		/* 820FFBC0h case   10:*/		return 0x820FFBC4;
		  /* 820FFBC4h */ case   11:  		/* lwz R9, <#[R9]> */
		/* 820FFBC4h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 820FFBC4h case   11:*/		return 0x820FFBC8;
		  /* 820FFBC8h */ case   12:  		/* lwz R5, <#[R5 + 44]> */
		/* 820FFBC8h case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x0000002C) );
		/* 820FFBC8h case   12:*/		return 0x820FFBCC;
		  /* 820FFBCCh */ case   13:  		/* lwz R9, <#[R9 + 44]> */
		/* 820FFBCCh case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000002C) );
		/* 820FFBCCh case   13:*/		return 0x820FFBD0;
		  /* 820FFBD0h */ case   14:  		/* cmplw CR6, R9, R5 */
		/* 820FFBD0h case   14:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R5);
		/* 820FFBD0h case   14:*/		return 0x820FFBD4;
		  /* 820FFBD4h */ case   15:  		/* bc 4, CR6_EQ, 16 */
		/* 820FFBD4h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820FFBE4;  }
		/* 820FFBD4h case   15:*/		return 0x820FFBD8;
		  /* 820FFBD8h */ case   16:  		/* addi R8, R8, 1 */
		/* 820FFBD8h case   16:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820FFBD8h case   16:*/		return 0x820FFBDC;
		  /* 820FFBDCh */ case   17:  		/* addi R10, R10, 1 */
		/* 820FFBDCh case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820FFBDCh case   17:*/		return 0x820FFBE0;
		  /* 820FFBE0h */ case   18:  		/* addi R11, R11, 4 */
		/* 820FFBE0h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820FFBE0h case   18:*/		return 0x820FFBE4;
	}
	return 0x820FFBE4;
} // Block from 820FFB98h-820FFBE4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820FFBE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFBE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFBE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFBE4);
		  /* 820FFBE4h */ case    0:  		/* addi R8, R8, 1 */
		/* 820FFBE4h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820FFBE4h case    0:*/		return 0x820FFBE8;
		  /* 820FFBE8h */ case    1:  		/* addi R10, R10, 1 */
		/* 820FFBE8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820FFBE8h case    1:*/		return 0x820FFBEC;
		  /* 820FFBECh */ case    2:  		/* addi R11, R11, 4 */
		/* 820FFBECh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820FFBECh case    2:*/		return 0x820FFBF0;
		  /* 820FFBF0h */ case    3:  		/* cmplw CR6, R8, R7 */
		/* 820FFBF0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 820FFBF0h case    3:*/		return 0x820FFBF4;
		  /* 820FFBF4h */ case    4:  		/* bc 12, CR6_LT, -92 */
		/* 820FFBF4h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FFB98;  }
		/* 820FFBF4h case    4:*/		return 0x820FFBF8;
		  /* 820FFBF8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820FFBF8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FFBF8h case    5:*/		return 0x820FFBFC;
	}
	return 0x820FFBFC;
} // Block from 820FFBE4h-820FFBFCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820FFBFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFBFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFBFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFBFC);
		  /* 820FFBFCh */ case    0:  		/* nop */
		/* 820FFBFCh case    0:*/		cpu::op::nop();
		/* 820FFBFCh case    0:*/		return 0x820FFC00;
	}
	return 0x820FFC00;
} // Block from 820FFBFCh-820FFC00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FFC00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFC00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFC00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFC00);
		  /* 820FFC00h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 820FFC00h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FFC00h case    0:*/		return 0x820FFC04;
		  /* 820FFC04h */ case    1:  		/* lwz R10, <#[R3 + 24]> */
		/* 820FFC04h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 820FFC04h case    1:*/		return 0x820FFC08;
		  /* 820FFC08h */ case    2:  		/* rlwinm R31, R4, 2, 0, 29 */
		/* 820FFC08h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R4);
		/* 820FFC08h case    2:*/		return 0x820FFC0C;
		  /* 820FFC0Ch */ case    3:  		/* mr R6, R3 */
		/* 820FFC0Ch case    3:*/		regs.R6 = regs.R3;
		/* 820FFC0Ch case    3:*/		return 0x820FFC10;
		  /* 820FFC10h */ case    4:  		/* lwzx R5, <#[R10 + R31]> */
		/* 820FFC10h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 820FFC10h case    4:*/		return 0x820FFC14;
		  /* 820FFC14h */ case    5:  		/* lwz R9, <#[R5 + 44]> */
		/* 820FFC14h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x0000002C) );
		/* 820FFC14h case    5:*/		return 0x820FFC18;
		  /* 820FFC18h */ case    6:  		/* rlwinm. R11, R9, 0, 31, 31 */
		/* 820FFC18h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R9);
		/* 820FFC18h case    6:*/		return 0x820FFC1C;
		  /* 820FFC1Ch */ case    7:  		/* bc 4, CR0_EQ, 12 */
		/* 820FFC1Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x820FFC28;  }
		/* 820FFC1Ch case    7:*/		return 0x820FFC20;
		  /* 820FFC20h */ case    8:  		/* li R3, 0 */
		/* 820FFC20h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820FFC20h case    8:*/		return 0x820FFC24;
		  /* 820FFC24h */ case    9:  		/* b 380 */
		/* 820FFC24h case    9:*/		return 0x820FFDA0;
		/* 820FFC24h case    9:*/		return 0x820FFC28;
	}
	return 0x820FFC28;
} // Block from 820FFC00h-820FFC28h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820FFC28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFC28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFC28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFC28);
		  /* 820FFC28h */ case    0:  		/* mr R8, R4 */
		/* 820FFC28h case    0:*/		regs.R8 = regs.R4;
		/* 820FFC28h case    0:*/		return 0x820FFC2C;
		  /* 820FFC2Ch */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 820FFC2Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820FFC2Ch case    1:*/		return 0x820FFC30;
		  /* 820FFC30h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820FFC30h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FFC58;  }
		/* 820FFC30h case    2:*/		return 0x820FFC34;
		  /* 820FFC34h */ case    3:  		/* mr R11, R31 */
		/* 820FFC34h case    3:*/		regs.R11 = regs.R31;
		/* 820FFC34h case    3:*/		return 0x820FFC38;
	}
	return 0x820FFC38;
} // Block from 820FFC28h-820FFC38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820FFC38h
// Function '?VectorizeLeft_DotProduct@CProgram@D3DXShader@@AAAJPAVCInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFC38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFC38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFC38);
		  /* 820FFC38h */ case    0:  		/* add R7, R11, R10 */
		/* 820FFC38h case    0:*/		cpu::op::add<0>(regs,&regs.R7,regs.R11,regs.R10);
		/* 820FFC38h case    0:*/		return 0x820FFC3C;
		  /* 820FFC3Ch */ case    1:  		/* lwz R7, <#[R7 - 4]> */
		/* 820FFC3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0xFFFFFFFC) );
		/* 820FFC3Ch case    1:*/		return 0x820FFC40;
		  /* 820FFC40h */ case    2:  		/* lwz R7, <#[R7 + 44]> */
		/* 820FFC40h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x0000002C) );
		/* 820FFC40h case    2:*/		return 0x820FFC44;
		  /* 820FFC44h */ case    3:  		/* cmplw CR6, R9, R7 */
		/* 820FFC44h case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 820FFC44h case    3:*/		return 0x820FFC48;
		  /* 820FFC48h */ case    4:  		/* bc 4, CR6_LT, 16 */
		/* 820FFC48h case    4:*/		if ( !regs.CR[6].lt ) { return 0x820FFC58;  }
		/* 820FFC48h case    4:*/		return 0x820FFC4C;
		  /* 820FFC4Ch */ case    5:  		/* addic. R8, R8, -1 */
		/* 820FFC4Ch case    5:*/		cpu::op::addic<1>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 820FFC4Ch case    5:*/		return 0x820FFC50;
		  /* 820FFC50h */ case    6:  		/* addi R11, R11, -4 */
		/* 820FFC50h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 820FFC50h case    6:*/		return 0x820FFC54;
		  /* 820FFC54h */ case    7:  		/* bc 4, CR0_EQ, -28 */
		/* 820FFC54h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820FFC38;  }
		/* 820FFC54h case    7:*/		return 0x820FFC58;
	}
	return 0x820FFC58;
} // Block from 820FFC38h-820FFC58h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820FFC58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFC58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFC58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFC58);
		  /* 820FFC58h */ case    0:  		/* subf R11, R8, R4 */
		/* 820FFC58h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R8,regs.R4);
		/* 820FFC58h case    0:*/		return 0x820FFC5C;
		  /* 820FFC5Ch */ case    1:  		/* rlwinm. R10, R11, 31, 1, 31 */
		/* 820FFC5Ch case    1:*/		cpu::op::rlwinm<1,31,1,31>(regs,&regs.R10,regs.R11);
		/* 820FFC5Ch case    1:*/		return 0x820FFC60;
		  /* 820FFC60h */ case    2:  		/* bc 12, CR0_EQ, 60 */
		/* 820FFC60h case    2:*/		if ( regs.CR[0].eq ) { return 0x820FFC9C;  }
		/* 820FFC60h case    2:*/		return 0x820FFC64;
		  /* 820FFC64h */ case    3:  		/* mtspr CTR, R10 */
		/* 820FFC64h case    3:*/		regs.CTR = regs.R10;
		/* 820FFC64h case    3:*/		return 0x820FFC68;
		  /* 820FFC68h */ case    4:  		/* rlwinm R11, R8, 2, 0, 29 */
		/* 820FFC68h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R8);
		/* 820FFC68h case    4:*/		return 0x820FFC6C;
		  /* 820FFC6Ch */ case    5:  		/* mr R10, R31 */
		/* 820FFC6Ch case    5:*/		regs.R10 = regs.R31;
		/* 820FFC6Ch case    5:*/		return 0x820FFC70;
		  /* 820FFC70h */ case    6:  		/* lwz R9, <#[R6 + 24]> */
		/* 820FFC70h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000018) );
		/* 820FFC70h case    6:*/		return 0x820FFC74;
		  /* 820FFC74h */ case    7:  		/* add R7, R10, R9 */
		/* 820FFC74h case    7:*/		cpu::op::add<0>(regs,&regs.R7,regs.R10,regs.R9);
		/* 820FFC74h case    7:*/		return 0x820FFC78;
		  /* 820FFC78h */ case    8:  		/* lwzx R3, <#[R11 + R9]> */
		/* 820FFC78h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FFC78h case    8:*/		return 0x820FFC7C;
		  /* 820FFC7Ch */ case    9:  		/* lwz R7, <#[R7 - 4]> */
		/* 820FFC7Ch case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0xFFFFFFFC) );
		/* 820FFC7Ch case    9:*/		return 0x820FFC80;
		  /* 820FFC80h */ case   10:  		/* stwx R7, <#[R11 + R9]> */
		/* 820FFC80h case   10:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FFC80h case   10:*/		return 0x820FFC84;
		  /* 820FFC84h */ case   11:  		/* addi R11, R11, 4 */
		/* 820FFC84h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820FFC84h case   11:*/		return 0x820FFC88;
		  /* 820FFC88h */ case   12:  		/* lwz R9, <#[R6 + 24]> */
		/* 820FFC88h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000018) );
		/* 820FFC88h case   12:*/		return 0x820FFC8C;
		  /* 820FFC8Ch */ case   13:  		/* add R9, R10, R9 */
		/* 820FFC8Ch case   13:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 820FFC8Ch case   13:*/		return 0x820FFC90;
		  /* 820FFC90h */ case   14:  		/* addi R10, R10, -4 */
		/* 820FFC90h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 820FFC90h case   14:*/		return 0x820FFC94;
		  /* 820FFC94h */ case   15:  		/* stw R3, <#[R9 - 4]> */
		/* 820FFC94h case   15:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R9 + 0xFFFFFFFC) );
		/* 820FFC94h case   15:*/		return 0x820FFC98;
		  /* 820FFC98h */ case   16:  		/* bc 16, CR0_LT, -40 */
		/* 820FFC98h case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820FFC70;  }
		/* 820FFC98h case   16:*/		return 0x820FFC9C;
	}
	return 0x820FFC9C;
} // Block from 820FFC58h-820FFC9Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 820FFC9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFC9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFC9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFC9C);
		  /* 820FFC9Ch */ case    0:  		/* mr R7, R8 */
		/* 820FFC9Ch case    0:*/		regs.R7 = regs.R8;
		/* 820FFC9Ch case    0:*/		return 0x820FFCA0;
		  /* 820FFCA0h */ case    1:  		/* cmplwi CR6, R8, 0 */
		/* 820FFCA0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820FFCA0h case    1:*/		return 0x820FFCA4;
		  /* 820FFCA4h */ case    2:  		/* bc 12, CR6_EQ, 76 */
		/* 820FFCA4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820FFCF0;  }
		/* 820FFCA4h case    2:*/		return 0x820FFCA8;
		  /* 820FFCA8h */ case    3:  		/* lwz R10, <#[R6 + 24]> */
		/* 820FFCA8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000018) );
		/* 820FFCA8h case    3:*/		return 0x820FFCAC;
		  /* 820FFCACh */ case    4:  		/* rlwinm R11, R8, 2, 0, 29 */
		/* 820FFCACh case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R8);
		/* 820FFCACh case    4:*/		return 0x820FFCB0;
		  /* 820FFCB0h */ case    5:  		/* lwz R9, <#[R5 + 44]> */
		/* 820FFCB0h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x0000002C) );
		/* 820FFCB0h case    5:*/		return 0x820FFCB4;
		  /* 820FFCB4h */ case    6:  		/* add R5, R11, R10 */
		/* 820FFCB4h case    6:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R10);
		/* 820FFCB4h case    6:*/		return 0x820FFCB8;
		  /* 820FFCB8h */ case    7:  		/* lwz R5, <#[R5 - 4]> */
		/* 820FFCB8h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0xFFFFFFFC) );
		/* 820FFCB8h case    7:*/		return 0x820FFCBC;
		  /* 820FFCBCh */ case    8:  		/* lwz R5, <#[R5 + 44]> */
		/* 820FFCBCh case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x0000002C) );
		/* 820FFCBCh case    8:*/		return 0x820FFCC0;
		  /* 820FFCC0h */ case    9:  		/* cmplw CR6, R9, R5 */
		/* 820FFCC0h case    9:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R5);
		/* 820FFCC0h case    9:*/		return 0x820FFCC4;
		  /* 820FFCC4h */ case   10:  		/* bc 4, CR6_GT, 12 */
		/* 820FFCC4h case   10:*/		if ( !regs.CR[6].gt ) { return 0x820FFCD0;  }
		/* 820FFCC4h case   10:*/		return 0x820FFCC8;
		  /* 820FFCC8h */ case   11:  		/* addi R7, R8, -1 */
		/* 820FFCC8h case   11:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R8,0xFFFFFFFF);
		/* 820FFCC8h case   11:*/		return 0x820FFCCC;
		  /* 820FFCCCh */ case   12:  		/* b 104 */
		/* 820FFCCCh case   12:*/		return 0x820FFD34;
		/* 820FFCCCh case   12:*/		return 0x820FFCD0;
	}
	return 0x820FFCD0;
} // Block from 820FFC9Ch-820FFCD0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820FFCD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFCD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFCD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFCD0);
		  /* 820FFCD0h */ case    0:  		/* add R5, R11, R10 */
		/* 820FFCD0h case    0:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R10);
		/* 820FFCD0h case    0:*/		return 0x820FFCD4;
		  /* 820FFCD4h */ case    1:  		/* lwz R5, <#[R5 - 4]> */
		/* 820FFCD4h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0xFFFFFFFC) );
		/* 820FFCD4h case    1:*/		return 0x820FFCD8;
		  /* 820FFCD8h */ case    2:  		/* lwz R5, <#[R5 + 44]> */
		/* 820FFCD8h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x0000002C) );
		/* 820FFCD8h case    2:*/		return 0x820FFCDC;
		  /* 820FFCDCh */ case    3:  		/* cmplw CR6, R9, R5 */
		/* 820FFCDCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R5);
		/* 820FFCDCh case    3:*/		return 0x820FFCE0;
		  /* 820FFCE0h */ case    4:  		/* bc 4, CR6_EQ, 16 */
		/* 820FFCE0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820FFCF0;  }
		/* 820FFCE0h case    4:*/		return 0x820FFCE4;
		  /* 820FFCE4h */ case    5:  		/* addic. R7, R7, -1 */
		/* 820FFCE4h case    5:*/		cpu::op::addic<1>(regs,&regs.R7,regs.R7,0xFFFFFFFF);
		/* 820FFCE4h case    5:*/		return 0x820FFCE8;
		  /* 820FFCE8h */ case    6:  		/* addi R11, R11, -4 */
		/* 820FFCE8h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 820FFCE8h case    6:*/		return 0x820FFCEC;
		  /* 820FFCECh */ case    7:  		/* bc 4, CR0_EQ, -28 */
		/* 820FFCECh case    7:*/		if ( !regs.CR[0].eq ) { return 0x820FFCD0;  }
		/* 820FFCECh case    7:*/		return 0x820FFCF0;
	}
	return 0x820FFCF0;
} // Block from 820FFCD0h-820FFCF0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820FFCF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFCF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFCF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFCF0);
		  /* 820FFCF0h */ case    0:  		/* subf R11, R7, R8 */
		/* 820FFCF0h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R7,regs.R8);
		/* 820FFCF0h case    0:*/		return 0x820FFCF4;
		  /* 820FFCF4h */ case    1:  		/* rlwinm. R10, R11, 31, 1, 31 */
		/* 820FFCF4h case    1:*/		cpu::op::rlwinm<1,31,1,31>(regs,&regs.R10,regs.R11);
		/* 820FFCF4h case    1:*/		return 0x820FFCF8;
		  /* 820FFCF8h */ case    2:  		/* bc 12, CR0_EQ, 60 */
		/* 820FFCF8h case    2:*/		if ( regs.CR[0].eq ) { return 0x820FFD34;  }
		/* 820FFCF8h case    2:*/		return 0x820FFCFC;
		  /* 820FFCFCh */ case    3:  		/* mtspr CTR, R10 */
		/* 820FFCFCh case    3:*/		regs.CTR = regs.R10;
		/* 820FFCFCh case    3:*/		return 0x820FFD00;
		  /* 820FFD00h */ case    4:  		/* rlwinm R11, R7, 2, 0, 29 */
		/* 820FFD00h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R7);
		/* 820FFD00h case    4:*/		return 0x820FFD04;
		  /* 820FFD04h */ case    5:  		/* rlwinm R10, R8, 2, 0, 29 */
		/* 820FFD04h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R8);
		/* 820FFD04h case    5:*/		return 0x820FFD08;
		  /* 820FFD08h */ case    6:  		/* lwz R9, <#[R6 + 24]> */
		/* 820FFD08h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000018) );
		/* 820FFD08h case    6:*/		return 0x820FFD0C;
		  /* 820FFD0Ch */ case    7:  		/* add R5, R10, R9 */
		/* 820FFD0Ch case    7:*/		cpu::op::add<0>(regs,&regs.R5,regs.R10,regs.R9);
		/* 820FFD0Ch case    7:*/		return 0x820FFD10;
		  /* 820FFD10h */ case    8:  		/* lwzx R3, <#[R11 + R9]> */
		/* 820FFD10h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FFD10h case    8:*/		return 0x820FFD14;
		  /* 820FFD14h */ case    9:  		/* lwz R5, <#[R5 - 4]> */
		/* 820FFD14h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0xFFFFFFFC) );
		/* 820FFD14h case    9:*/		return 0x820FFD18;
		  /* 820FFD18h */ case   10:  		/* stwx R5, <#[R11 + R9]> */
		/* 820FFD18h case   10:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FFD18h case   10:*/		return 0x820FFD1C;
		  /* 820FFD1Ch */ case   11:  		/* addi R11, R11, 4 */
		/* 820FFD1Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820FFD1Ch case   11:*/		return 0x820FFD20;
		  /* 820FFD20h */ case   12:  		/* lwz R9, <#[R6 + 24]> */
		/* 820FFD20h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000018) );
		/* 820FFD20h case   12:*/		return 0x820FFD24;
		  /* 820FFD24h */ case   13:  		/* add R9, R10, R9 */
		/* 820FFD24h case   13:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 820FFD24h case   13:*/		return 0x820FFD28;
		  /* 820FFD28h */ case   14:  		/* addi R10, R10, -4 */
		/* 820FFD28h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 820FFD28h case   14:*/		return 0x820FFD2C;
		  /* 820FFD2Ch */ case   15:  		/* stw R3, <#[R9 - 4]> */
		/* 820FFD2Ch case   15:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R9 + 0xFFFFFFFC) );
		/* 820FFD2Ch case   15:*/		return 0x820FFD30;
		  /* 820FFD30h */ case   16:  		/* bc 16, CR0_LT, -40 */
		/* 820FFD30h case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820FFD08;  }
		/* 820FFD30h case   16:*/		return 0x820FFD34;
	}
	return 0x820FFD34;
} // Block from 820FFCF0h-820FFD34h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820FFD34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFD34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFD34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFD34);
		  /* 820FFD34h */ case    0:  		/* cmplw CR6, R7, R8 */
		/* 820FFD34h case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 820FFD34h case    0:*/		return 0x820FFD38;
		  /* 820FFD38h */ case    1:  		/* bc 12, CR6_EQ, -280 */
		/* 820FFD38h case    1:*/		if ( regs.CR[6].eq ) { return 0x820FFC20;  }
		/* 820FFD38h case    1:*/		return 0x820FFD3C;
		  /* 820FFD3Ch */ case    2:  		/* subf R11, R7, R4 */
		/* 820FFD3Ch case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R7,regs.R4);
		/* 820FFD3Ch case    2:*/		return 0x820FFD40;
		  /* 820FFD40h */ case    3:  		/* rlwinm. R10, R11, 31, 1, 31 */
		/* 820FFD40h case    3:*/		cpu::op::rlwinm<1,31,1,31>(regs,&regs.R10,regs.R11);
		/* 820FFD40h case    3:*/		return 0x820FFD44;
		  /* 820FFD44h */ case    4:  		/* bc 12, CR0_EQ, 60 */
		/* 820FFD44h case    4:*/		if ( regs.CR[0].eq ) { return 0x820FFD80;  }
		/* 820FFD44h case    4:*/		return 0x820FFD48;
		  /* 820FFD48h */ case    5:  		/* mtspr CTR, R10 */
		/* 820FFD48h case    5:*/		regs.CTR = regs.R10;
		/* 820FFD48h case    5:*/		return 0x820FFD4C;
		  /* 820FFD4Ch */ case    6:  		/* rlwinm R11, R7, 2, 0, 29 */
		/* 820FFD4Ch case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R7);
		/* 820FFD4Ch case    6:*/		return 0x820FFD50;
		  /* 820FFD50h */ case    7:  		/* mr R10, R31 */
		/* 820FFD50h case    7:*/		regs.R10 = regs.R31;
		/* 820FFD50h case    7:*/		return 0x820FFD54;
		  /* 820FFD54h */ case    8:  		/* lwz R9, <#[R6 + 24]> */
		/* 820FFD54h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000018) );
		/* 820FFD54h case    8:*/		return 0x820FFD58;
		  /* 820FFD58h */ case    9:  		/* add R8, R10, R9 */
		/* 820FFD58h case    9:*/		cpu::op::add<0>(regs,&regs.R8,regs.R10,regs.R9);
		/* 820FFD58h case    9:*/		return 0x820FFD5C;
		  /* 820FFD5Ch */ case   10:  		/* lwzx R7, <#[R11 + R9]> */
		/* 820FFD5Ch case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FFD5Ch case   10:*/		return 0x820FFD60;
		  /* 820FFD60h */ case   11:  		/* lwz R8, <#[R8 - 4]> */
		/* 820FFD60h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0xFFFFFFFC) );
		/* 820FFD60h case   11:*/		return 0x820FFD64;
		  /* 820FFD64h */ case   12:  		/* stwx R8, <#[R11 + R9]> */
		/* 820FFD64h case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820FFD64h case   12:*/		return 0x820FFD68;
		  /* 820FFD68h */ case   13:  		/* addi R11, R11, 4 */
		/* 820FFD68h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820FFD68h case   13:*/		return 0x820FFD6C;
		  /* 820FFD6Ch */ case   14:  		/* lwz R9, <#[R6 + 24]> */
		/* 820FFD6Ch case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000018) );
		/* 820FFD6Ch case   14:*/		return 0x820FFD70;
		  /* 820FFD70h */ case   15:  		/* add R9, R10, R9 */
		/* 820FFD70h case   15:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 820FFD70h case   15:*/		return 0x820FFD74;
		  /* 820FFD74h */ case   16:  		/* addi R10, R10, -4 */
		/* 820FFD74h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 820FFD74h case   16:*/		return 0x820FFD78;
		  /* 820FFD78h */ case   17:  		/* stw R7, <#[R9 - 4]> */
		/* 820FFD78h case   17:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0xFFFFFFFC) );
		/* 820FFD78h case   17:*/		return 0x820FFD7C;
		  /* 820FFD7Ch */ case   18:  		/* bc 16, CR0_LT, -40 */
		/* 820FFD7Ch case   18:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820FFD54;  }
		/* 820FFD7Ch case   18:*/		return 0x820FFD80;
	}
	return 0x820FFD80;
} // Block from 820FFD34h-820FFD80h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820FFD80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFD80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFD80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFD80);
		  /* 820FFD80h */ case    0:  		/* lwz R11, <#[R6 + 24]> */
		/* 820FFD80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000018) );
		/* 820FFD80h case    0:*/		return 0x820FFD84;
		  /* 820FFD84h */ case    1:  		/* li R3, 1 */
		/* 820FFD84h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820FFD84h case    1:*/		return 0x820FFD88;
		  /* 820FFD88h */ case    2:  		/* add R11, R31, R11 */
		/* 820FFD88h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 820FFD88h case    2:*/		return 0x820FFD8C;
		  /* 820FFD8Ch */ case    3:  		/* lwz R10, <#[R11]> */
		/* 820FFD8Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820FFD8Ch case    3:*/		return 0x820FFD90;
		  /* 820FFD90h */ case    4:  		/* lwz R9, <#[R11 - 4]> */
		/* 820FFD90h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 820FFD90h case    4:*/		return 0x820FFD94;
		  /* 820FFD94h */ case    5:  		/* stw R10, <#[R11 - 4]> */
		/* 820FFD94h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 820FFD94h case    5:*/		return 0x820FFD98;
		  /* 820FFD98h */ case    6:  		/* lwz R11, <#[R6 + 24]> */
		/* 820FFD98h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000018) );
		/* 820FFD98h case    6:*/		return 0x820FFD9C;
		  /* 820FFD9Ch */ case    7:  		/* stwx R9, <#[R31 + R11]> */
		/* 820FFD9Ch case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 820FFD9Ch case    7:*/		return 0x820FFDA0;
	}
	return 0x820FFDA0;
} // Block from 820FFD80h-820FFDA0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820FFDA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFDA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFDA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFDA0);
		  /* 820FFDA0h */ case    0:  		/* ld R31, <#[R1 - 8]> */
		/* 820FFDA0h case    0:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820FFDA0h case    0:*/		return 0x820FFDA4;
		  /* 820FFDA4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820FFDA4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820FFDA4h case    1:*/		return 0x820FFDA8;
	}
	return 0x820FFDA8;
} // Block from 820FFDA0h-820FFDA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820FFDA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFDA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFDA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFDA8);
		  /* 820FFDA8h */ case    0:  		/* mfspr R12, LR */
		/* 820FFDA8h case    0:*/		regs.R12 = regs.LR;
		/* 820FFDA8h case    0:*/		return 0x820FFDAC;
		  /* 820FFDACh */ case    1:  		/* bl -453468 */
		/* 820FFDACh case    1:*/		regs.LR = 0x820FFDB0; return 0x82091250;
		/* 820FFDACh case    1:*/		return 0x820FFDB0;
		  /* 820FFDB0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820FFDB0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820FFDB0h case    2:*/		return 0x820FFDB4;
		  /* 820FFDB4h */ case    3:  		/* lwz R11, <#[R4 + 56]> */
		/* 820FFDB4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000038) );
		/* 820FFDB4h case    3:*/		return 0x820FFDB8;
		  /* 820FFDB8h */ case    4:  		/* mr R26, R3 */
		/* 820FFDB8h case    4:*/		regs.R26 = regs.R3;
		/* 820FFDB8h case    4:*/		return 0x820FFDBC;
		  /* 820FFDBCh */ case    5:  		/* mr R31, R4 */
		/* 820FFDBCh case    5:*/		regs.R31 = regs.R4;
		/* 820FFDBCh case    5:*/		return 0x820FFDC0;
		  /* 820FFDC0h */ case    6:  		/* mr R28, R5 */
		/* 820FFDC0h case    6:*/		regs.R28 = regs.R5;
		/* 820FFDC0h case    6:*/		return 0x820FFDC4;
		  /* 820FFDC4h */ case    7:  		/* mr R27, R6 */
		/* 820FFDC4h case    7:*/		regs.R27 = regs.R6;
		/* 820FFDC4h case    7:*/		return 0x820FFDC8;
		  /* 820FFDC8h */ case    8:  		/* cmplw CR6, R11, R6 */
		/* 820FFDC8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820FFDC8h case    8:*/		return 0x820FFDCC;
		  /* 820FFDCCh */ case    9:  		/* bc 12, CR6_EQ, 96 */
		/* 820FFDCCh case    9:*/		if ( regs.CR[6].eq ) { return 0x820FFE2C;  }
		/* 820FFDCCh case    9:*/		return 0x820FFDD0;
		  /* 820FFDD0h */ case   10:  		/* stw R6, <#[R4 + 56]> */
		/* 820FFDD0h case   10:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R4 + 0x00000038) );
		/* 820FFDD0h case   10:*/		return 0x820FFDD4;
		  /* 820FFDD4h */ case   11:  		/* li R30, 0 */
		/* 820FFDD4h case   11:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820FFDD4h case   11:*/		return 0x820FFDD8;
		  /* 820FFDD8h */ case   12:  		/* lwz R11, <#[R5]> */
		/* 820FFDD8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820FFDD8h case   12:*/		return 0x820FFDDC;
		  /* 820FFDDCh */ case   13:  		/* addi R11, R11, 1 */
		/* 820FFDDCh case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820FFDDCh case   13:*/		return 0x820FFDE0;
		  /* 820FFDE0h */ case   14:  		/* stw R11, <#[R5]> */
		/* 820FFDE0h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820FFDE0h case   14:*/		return 0x820FFDE4;
		  /* 820FFDE4h */ case   15:  		/* lwz R11, <#[R4 + 20]> */
		/* 820FFDE4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000014) );
		/* 820FFDE4h case   15:*/		return 0x820FFDE8;
		  /* 820FFDE8h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 820FFDE8h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FFDE8h case   16:*/		return 0x820FFDEC;
		  /* 820FFDECh */ case   17:  		/* bc 4, CR6_GT, 64 */
		/* 820FFDECh case   17:*/		if ( !regs.CR[6].gt ) { return 0x820FFE2C;  }
		/* 820FFDECh case   17:*/		return 0x820FFDF0;
		  /* 820FFDF0h */ case   18:  		/* li R29, 0 */
		/* 820FFDF0h case   18:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820FFDF0h case   18:*/		return 0x820FFDF4;
		  /* 820FFDF4h */ case   19:  		/* lwz R11, <#[R31 + 24]> */
		/* 820FFDF4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820FFDF4h case   19:*/		return 0x820FFDF8;
		  /* 820FFDF8h */ case   20:  		/* mr R6, R27 */
		/* 820FFDF8h case   20:*/		regs.R6 = regs.R27;
		/* 820FFDF8h case   20:*/		return 0x820FFDFC;
		  /* 820FFDFCh */ case   21:  		/* lwz R10, <#[R26 + 24]> */
		/* 820FFDFCh case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000018) );
		/* 820FFDFCh case   21:*/		return 0x820FFE00;
		  /* 820FFE00h */ case   22:  		/* mr R5, R28 */
		/* 820FFE00h case   22:*/		regs.R5 = regs.R28;
		/* 820FFE00h case   22:*/		return 0x820FFE04;
		  /* 820FFE04h */ case   23:  		/* mr R3, R26 */
		/* 820FFE04h case   23:*/		regs.R3 = regs.R26;
		/* 820FFE04h case   23:*/		return 0x820FFE08;
		  /* 820FFE08h */ case   24:  		/* lwzx R11, <#[R11 + R29]> */
		/* 820FFE08h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 820FFE08h case   24:*/		return 0x820FFE0C;
		  /* 820FFE0Ch */ case   25:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820FFE0Ch case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820FFE0Ch case   25:*/		return 0x820FFE10;
		  /* 820FFE10h */ case   26:  		/* lwzx R4, <#[R11 + R10]> */
		/* 820FFE10h case   26:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FFE10h case   26:*/		return 0x820FFE14;
		  /* 820FFE14h */ case   27:  		/* bl -108 */
		/* 820FFE14h case   27:*/		regs.LR = 0x820FFE18; return 0x820FFDA8;
		/* 820FFE14h case   27:*/		return 0x820FFE18;
		  /* 820FFE18h */ case   28:  		/* lwz R11, <#[R31 + 20]> */
		/* 820FFE18h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820FFE18h case   28:*/		return 0x820FFE1C;
		  /* 820FFE1Ch */ case   29:  		/* addi R30, R30, 1 */
		/* 820FFE1Ch case   29:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820FFE1Ch case   29:*/		return 0x820FFE20;
		  /* 820FFE20h */ case   30:  		/* addi R29, R29, 4 */
		/* 820FFE20h case   30:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820FFE20h case   30:*/		return 0x820FFE24;
		  /* 820FFE24h */ case   31:  		/* cmplw CR6, R30, R11 */
		/* 820FFE24h case   31:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820FFE24h case   31:*/		return 0x820FFE28;
		  /* 820FFE28h */ case   32:  		/* bc 12, CR6_LT, -52 */
		/* 820FFE28h case   32:*/		if ( regs.CR[6].lt ) { return 0x820FFDF4;  }
		/* 820FFE28h case   32:*/		return 0x820FFE2C;
	}
	return 0x820FFE2C;
} // Block from 820FFDA8h-820FFE2Ch (33 instructions)

//////////////////////////////////////////////////////
// Block at 820FFE2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFE2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFE2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFE2C);
		  /* 820FFE2Ch */ case    0:  		/* addi R1, R1, 144 */
		/* 820FFE2Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820FFE2Ch case    0:*/		return 0x820FFE30;
		  /* 820FFE30h */ case    1:  		/* b -453520 */
		/* 820FFE30h case    1:*/		return 0x820912A0;
		/* 820FFE30h case    1:*/		return 0x820FFE34;
		  /* 820FFE34h */ case    2:  		/* nop */
		/* 820FFE34h case    2:*/		cpu::op::nop();
		/* 820FFE34h case    2:*/		return 0x820FFE38;
	}
	return 0x820FFE38;
} // Block from 820FFE2Ch-820FFE38h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FFE38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFE38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFE38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFE38);
		  /* 820FFE38h */ case    0:  		/* mfspr R12, LR */
		/* 820FFE38h case    0:*/		regs.R12 = regs.LR;
		/* 820FFE38h case    0:*/		return 0x820FFE3C;
		  /* 820FFE3Ch */ case    1:  		/* bl -453600 */
		/* 820FFE3Ch case    1:*/		regs.LR = 0x820FFE40; return 0x8209125C;
		/* 820FFE3Ch case    1:*/		return 0x820FFE40;
		  /* 820FFE40h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820FFE40h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820FFE40h case    2:*/		return 0x820FFE44;
		  /* 820FFE44h */ case    3:  		/* mr R31, R6 */
		/* 820FFE44h case    3:*/		regs.R31 = regs.R6;
		/* 820FFE44h case    3:*/		return 0x820FFE48;
		  /* 820FFE48h */ case    4:  		/* mr R6, R7 */
		/* 820FFE48h case    4:*/		regs.R6 = regs.R7;
		/* 820FFE48h case    4:*/		return 0x820FFE4C;
		  /* 820FFE4Ch */ case    5:  		/* mr R9, R3 */
		/* 820FFE4Ch case    5:*/		regs.R9 = regs.R3;
		/* 820FFE4Ch case    5:*/		return 0x820FFE50;
		  /* 820FFE50h */ case    6:  		/* bl -168 */
		/* 820FFE50h case    6:*/		regs.LR = 0x820FFE54; return 0x820FFDA8;
		/* 820FFE50h case    6:*/		return 0x820FFE54;
		  /* 820FFE54h */ case    7:  		/* lwz R11, <#[R9 + 12]> */
		/* 820FFE54h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 820FFE54h case    7:*/		return 0x820FFE58;
		  /* 820FFE58h */ case    8:  		/* li R4, 0 */
		/* 820FFE58h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820FFE58h case    8:*/		return 0x820FFE5C;
		  /* 820FFE5Ch */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820FFE5Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FFE5Ch case    9:*/		return 0x820FFE60;
		  /* 820FFE60h */ case   10:  		/* bc 4, CR6_GT, 172 */
		/* 820FFE60h case   10:*/		if ( !regs.CR[6].gt ) { return 0x820FFF0C;  }
		/* 820FFE60h case   10:*/		return 0x820FFE64;
		  /* 820FFE64h */ case   11:  		/* li R5, 0 */
		/* 820FFE64h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820FFE64h case   11:*/		return 0x820FFE68;
		  /* 820FFE68h */ case   12:  		/* lis R3, 1 */
		/* 820FFE68h case   12:*/		cpu::op::lis<0>(regs,&regs.R3,0x1);
		/* 820FFE68h case   12:*/		return 0x820FFE6C;
		  /* 820FFE6Ch */ case   13:  		/* lwz R11, <#[R9 + 24]> */
		/* 820FFE6Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000018) );
		/* 820FFE6Ch case   13:*/		return 0x820FFE70;
		  /* 820FFE70h */ case   14:  		/* lwzx R11, <#[R11 + R5]> */
		/* 820FFE70h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 820FFE70h case   14:*/		return 0x820FFE74;
		  /* 820FFE74h */ case   15:  		/* lwz R10, <#[R11 + 36]> */
		/* 820FFE74h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000024) );
		/* 820FFE74h case   15:*/		return 0x820FFE78;
		  /* 820FFE78h */ case   16:  		/* cmplwi CR6, R10, 0 */
		/* 820FFE78h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820FFE78h case   16:*/		return 0x820FFE7C;
		  /* 820FFE7Ch */ case   17:  		/* bc 4, CR6_EQ, 124 */
		/* 820FFE7Ch case   17:*/		if ( !regs.CR[6].eq ) { return 0x820FFEF8;  }
		/* 820FFE7Ch case   17:*/		return 0x820FFE80;
		  /* 820FFE80h */ case   18:  		/* lwz R10, <#[R11 + 20]> */
		/* 820FFE80h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 820FFE80h case   18:*/		return 0x820FFE84;
		  /* 820FFE84h */ case   19:  		/* li R6, 0 */
		/* 820FFE84h case   19:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820FFE84h case   19:*/		return 0x820FFE88;
		  /* 820FFE88h */ case   20:  		/* cmplwi CR6, R10, 0 */
		/* 820FFE88h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820FFE88h case   20:*/		return 0x820FFE8C;
		  /* 820FFE8Ch */ case   21:  		/* bc 4, CR6_GT, 108 */
		/* 820FFE8Ch case   21:*/		if ( !regs.CR[6].gt ) { return 0x820FFEF8;  }
		/* 820FFE8Ch case   21:*/		return 0x820FFE90;
		  /* 820FFE90h */ case   22:  		/* li R8, 0 */
		/* 820FFE90h case   22:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820FFE90h case   22:*/		return 0x820FFE94;
		  /* 820FFE94h */ case   23:  		/* lwz R10, <#[R11 + 24]> */
		/* 820FFE94h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 820FFE94h case   23:*/		return 0x820FFE98;
		  /* 820FFE98h */ case   24:  		/* lwz R30, <#[R9 + 24]> */
		/* 820FFE98h case   24:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + 0x00000018) );
		/* 820FFE98h case   24:*/		return 0x820FFE9C;
		  /* 820FFE9Ch */ case   25:  		/* lwz R29, <#[R11 + 56]> */
		/* 820FFE9Ch case   25:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000038) );
		/* 820FFE9Ch case   25:*/		return 0x820FFEA0;
		  /* 820FFEA0h */ case   26:  		/* cmplw CR6, R7, R29 */
		/* 820FFEA0h case   26:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R29);
		/* 820FFEA0h case   26:*/		return 0x820FFEA4;
		  /* 820FFEA4h */ case   27:  		/* lwzx R10, <#[R10 + R8]> */
		/* 820FFEA4h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820FFEA4h case   27:*/		return 0x820FFEA8;
		  /* 820FFEA8h */ case   28:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820FFEA8h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820FFEA8h case   28:*/		return 0x820FFEAC;
		  /* 820FFEACh */ case   29:  		/* lwzx R10, <#[R10 + R30]> */
		/* 820FFEACh case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 820FFEACh case   29:*/		return 0x820FFEB0;
		  /* 820FFEB0h */ case   30:  		/* bc 4, CR6_EQ, 28 */
		/* 820FFEB0h case   30:*/		if ( !regs.CR[6].eq ) { return 0x820FFECC;  }
		/* 820FFEB0h case   30:*/		return 0x820FFEB4;
		  /* 820FFEB4h */ case   31:  		/* lwz R10, <#[R10 + 36]> */
		/* 820FFEB4h case   31:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000024) );
		/* 820FFEB4h case   31:*/		return 0x820FFEB8;
		  /* 820FFEB8h */ case   32:  		/* cmplwi CR6, R10, 0 */
		/* 820FFEB8h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820FFEB8h case   32:*/		return 0x820FFEBC;
		  /* 820FFEBCh */ case   33:  		/* bc 12, CR6_EQ, 40 */
		/* 820FFEBCh case   33:*/		if ( regs.CR[6].eq ) { return 0x820FFEE4;  }
		/* 820FFEBCh case   33:*/		return 0x820FFEC0;
		  /* 820FFEC0h */ case   34:  		/* lwz R10, <#[R31]> */
		/* 820FFEC0h case   34:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820FFEC0h case   34:*/		return 0x820FFEC4;
		  /* 820FFEC4h */ case   35:  		/* subf R10, R3, R10 */
		/* 820FFEC4h case   35:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R3,regs.R10);
		/* 820FFEC4h case   35:*/		return 0x820FFEC8;
		  /* 820FFEC8h */ case   36:  		/* b 24 */
		/* 820FFEC8h case   36:*/		return 0x820FFEE0;
		/* 820FFEC8h case   36:*/		return 0x820FFECC;
	}
	return 0x820FFECC;
} // Block from 820FFE38h-820FFECCh (37 instructions)

//////////////////////////////////////////////////////
// Block at 820FFECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFECC);
		  /* 820FFECCh */ case    0:  		/* lwz R10, <#[R10 + 56]> */
		/* 820FFECCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000038) );
		/* 820FFECCh case    0:*/		return 0x820FFED0;
		  /* 820FFED0h */ case    1:  		/* cmplw CR6, R7, R10 */
		/* 820FFED0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 820FFED0h case    1:*/		return 0x820FFED4;
		  /* 820FFED4h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820FFED4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820FFEE4;  }
		/* 820FFED4h case    2:*/		return 0x820FFED8;
		  /* 820FFED8h */ case    3:  		/* lwz R10, <#[R31]> */
		/* 820FFED8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820FFED8h case    3:*/		return 0x820FFEDC;
		  /* 820FFEDCh */ case    4:  		/* add R10, R10, R3 */
		/* 820FFEDCh case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 820FFEDCh case    4:*/		return 0x820FFEE0;
	}
	return 0x820FFEE0;
} // Block from 820FFECCh-820FFEE0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FFEE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFEE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFEE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFEE0);
		  /* 820FFEE0h */ case    0:  		/* stw R10, <#[R31]> */
		/* 820FFEE0h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820FFEE0h case    0:*/		return 0x820FFEE4;
	}
	return 0x820FFEE4;
} // Block from 820FFEE0h-820FFEE4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820FFEE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFEE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFEE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFEE4);
		  /* 820FFEE4h */ case    0:  		/* lwz R10, <#[R11 + 20]> */
		/* 820FFEE4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 820FFEE4h case    0:*/		return 0x820FFEE8;
		  /* 820FFEE8h */ case    1:  		/* addi R6, R6, 1 */
		/* 820FFEE8h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820FFEE8h case    1:*/		return 0x820FFEEC;
		  /* 820FFEECh */ case    2:  		/* addi R8, R8, 4 */
		/* 820FFEECh case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820FFEECh case    2:*/		return 0x820FFEF0;
		  /* 820FFEF0h */ case    3:  		/* cmplw CR6, R6, R10 */
		/* 820FFEF0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 820FFEF0h case    3:*/		return 0x820FFEF4;
		  /* 820FFEF4h */ case    4:  		/* bc 12, CR6_LT, -96 */
		/* 820FFEF4h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FFE94;  }
		/* 820FFEF4h case    4:*/		return 0x820FFEF8;
	}
	return 0x820FFEF8;
} // Block from 820FFEE4h-820FFEF8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FFEF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFEF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFEF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFEF8);
		  /* 820FFEF8h */ case    0:  		/* lwz R11, <#[R9 + 12]> */
		/* 820FFEF8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 820FFEF8h case    0:*/		return 0x820FFEFC;
		  /* 820FFEFCh */ case    1:  		/* addi R4, R4, 1 */
		/* 820FFEFCh case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820FFEFCh case    1:*/		return 0x820FFF00;
		  /* 820FFF00h */ case    2:  		/* addi R5, R5, 4 */
		/* 820FFF00h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 820FFF00h case    2:*/		return 0x820FFF04;
		  /* 820FFF04h */ case    3:  		/* cmplw CR6, R4, R11 */
		/* 820FFF04h case    3:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 820FFF04h case    3:*/		return 0x820FFF08;
		  /* 820FFF08h */ case    4:  		/* bc 12, CR6_LT, -156 */
		/* 820FFF08h case    4:*/		if ( regs.CR[6].lt ) { return 0x820FFE6C;  }
		/* 820FFF08h case    4:*/		return 0x820FFF0C;
	}
	return 0x820FFF0C;
} // Block from 820FFEF8h-820FFF0Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820FFF0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFF0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFF0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFF0C);
		  /* 820FFF0Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 820FFF0Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820FFF0Ch case    0:*/		return 0x820FFF10;
		  /* 820FFF10h */ case    1:  		/* b -453732 */
		/* 820FFF10h case    1:*/		return 0x820912AC;
		/* 820FFF10h case    1:*/		return 0x820FFF14;
		  /* 820FFF14h */ case    2:  		/* nop */
		/* 820FFF14h case    2:*/		cpu::op::nop();
		/* 820FFF14h case    2:*/		return 0x820FFF18;
	}
	return 0x820FFF18;
} // Block from 820FFF0Ch-820FFF18h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820FFF18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFF18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFF18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFF18);
		  /* 820FFF18h */ case    0:  		/* mfspr R12, LR */
		/* 820FFF18h case    0:*/		regs.R12 = regs.LR;
		/* 820FFF18h case    0:*/		return 0x820FFF1C;
		  /* 820FFF1Ch */ case    1:  		/* bl -453848 */
		/* 820FFF1Ch case    1:*/		regs.LR = 0x820FFF20; return 0x82091244;
		/* 820FFF1Ch case    1:*/		return 0x820FFF20;
		  /* 820FFF20h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820FFF20h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820FFF20h case    2:*/		return 0x820FFF24;
		  /* 820FFF24h */ case    3:  		/* lwz R10, <#[R3 + 24]> */
		/* 820FFF24h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 820FFF24h case    3:*/		return 0x820FFF28;
		  /* 820FFF28h */ case    4:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 820FFF28h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 820FFF28h case    4:*/		return 0x820FFF2C;
		  /* 820FFF2Ch */ case    5:  		/* mr R28, R3 */
		/* 820FFF2Ch case    5:*/		regs.R28 = regs.R3;
		/* 820FFF2Ch case    5:*/		return 0x820FFF30;
		  /* 820FFF30h */ case    6:  		/* mr R27, R4 */
		/* 820FFF30h case    6:*/		regs.R27 = regs.R4;
		/* 820FFF30h case    6:*/		return 0x820FFF34;
		  /* 820FFF34h */ case    7:  		/* mr R24, R5 */
		/* 820FFF34h case    7:*/		regs.R24 = regs.R5;
		/* 820FFF34h case    7:*/		return 0x820FFF38;
		  /* 820FFF38h */ case    8:  		/* mr R25, R6 */
		/* 820FFF38h case    8:*/		regs.R25 = regs.R6;
		/* 820FFF38h case    8:*/		return 0x820FFF3C;
		  /* 820FFF3Ch */ case    9:  		/* lwzx R30, <#[R11 + R10]> */
		/* 820FFF3Ch case    9:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820FFF3Ch case    9:*/		return 0x820FFF40;
		  /* 820FFF40h */ case   10:  		/* lwz R11, <#[R30 + 36]> */
		/* 820FFF40h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 820FFF40h case   10:*/		return 0x820FFF44;
		  /* 820FFF44h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 820FFF44h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FFF44h case   11:*/		return 0x820FFF48;
		  /* 820FFF48h */ case   12:  		/* bc 4, CR6_EQ, 548 */
		/* 820FFF48h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8210016C;  }
		/* 820FFF48h case   12:*/		return 0x820FFF4C;
		  /* 820FFF4Ch */ case   13:  		/* lwz R11, <#[R30 + 20]> */
		/* 820FFF4Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820FFF4Ch case   13:*/		return 0x820FFF50;
		  /* 820FFF50h */ case   14:  		/* li R26, 0 */
		/* 820FFF50h case   14:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820FFF50h case   14:*/		return 0x820FFF54;
		  /* 820FFF54h */ case   15:  		/* mr R29, R26 */
		/* 820FFF54h case   15:*/		regs.R29 = regs.R26;
		/* 820FFF54h case   15:*/		return 0x820FFF58;
		  /* 820FFF58h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 820FFF58h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FFF58h case   16:*/		return 0x820FFF5C;
		  /* 820FFF5Ch */ case   17:  		/* bc 4, CR6_GT, 120 */
		/* 820FFF5Ch case   17:*/		if ( !regs.CR[6].gt ) { return 0x820FFFD4;  }
		/* 820FFF5Ch case   17:*/		return 0x820FFF60;
		  /* 820FFF60h */ case   18:  		/* mr R31, R26 */
		/* 820FFF60h case   18:*/		regs.R31 = regs.R26;
		/* 820FFF60h case   18:*/		return 0x820FFF64;
		  /* 820FFF64h */ case   19:  		/* lwz R11, <#[R30 + 24]> */
		/* 820FFF64h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820FFF64h case   19:*/		return 0x820FFF68;
		  /* 820FFF68h */ case   20:  		/* addi R6, R1, 80 */
		/* 820FFF68h case   20:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 820FFF68h case   20:*/		return 0x820FFF6C;
		  /* 820FFF6Ch */ case   21:  		/* lwz R10, <#[R28 + 24]> */
		/* 820FFF6Ch case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000018) );
		/* 820FFF6Ch case   21:*/		return 0x820FFF70;
		  /* 820FFF70h */ case   22:  		/* addi R5, R1, 84 */
		/* 820FFF70h case   22:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 820FFF70h case   22:*/		return 0x820FFF74;
		  /* 820FFF74h */ case   23:  		/* stw R26, <#[R1 + 80]> */
		/* 820FFF74h case   23:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 820FFF74h case   23:*/		return 0x820FFF78;
		  /* 820FFF78h */ case   24:  		/* mr R3, R28 */
		/* 820FFF78h case   24:*/		regs.R3 = regs.R28;
		/* 820FFF78h case   24:*/		return 0x820FFF7C;
		  /* 820FFF7Ch */ case   25:  		/* lwzx R9, <#[R11 + R31]> */
		/* 820FFF7Ch case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820FFF7Ch case   25:*/		return 0x820FFF80;
		  /* 820FFF80h */ case   26:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820FFF80h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820FFF80h case   26:*/		return 0x820FFF84;
		  /* 820FFF84h */ case   27:  		/* lwzx R23, <#[R9 + R10]> */
		/* 820FFF84h case   27:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820FFF84h case   27:*/		return 0x820FFF88;
		  /* 820FFF88h */ case   28:  		/* stw R26, <#[R1 + 84]> */
		/* 820FFF88h case   28:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000054) );
		/* 820FFF88h case   28:*/		return 0x820FFF8C;
		  /* 820FFF8Ch */ case   29:  		/* mr R4, R23 */
		/* 820FFF8Ch case   29:*/		regs.R4 = regs.R23;
		/* 820FFF8Ch case   29:*/		return 0x820FFF90;
		  /* 820FFF90h */ case   30:  		/* lwzx R7, <#[R11 + R31]> */
		/* 820FFF90h case   30:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820FFF90h case   30:*/		return 0x820FFF94;
		  /* 820FFF94h */ case   31:  		/* bl -348 */
		/* 820FFF94h case   31:*/		regs.LR = 0x820FFF98; return 0x820FFE38;
		/* 820FFF94h case   31:*/		return 0x820FFF98;
		  /* 820FFF98h */ case   32:  		/* lwz R11, <#[R1 + 80]> */
		/* 820FFF98h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820FFF98h case   32:*/		return 0x820FFF9C;
		  /* 820FFF9Ch */ case   33:  		/* lwz R9, <#[R1 + 84]> */
		/* 820FFF9Ch case   33:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 820FFF9Ch case   33:*/		return 0x820FFFA0;
		  /* 820FFFA0h */ case   34:  		/* rlwinm R10, R11, 1, 0, 31 */
		/* 820FFFA0h case   34:*/		cpu::op::rlwinm<0,1,0,31>(regs,&regs.R10,regs.R11);
		/* 820FFFA0h case   34:*/		return 0x820FFFA4;
		  /* 820FFFA4h */ case   35:  		/* addi R29, R29, 1 */
		/* 820FFFA4h case   35:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820FFFA4h case   35:*/		return 0x820FFFA8;
		  /* 820FFFA8h */ case   36:  		/* addi R9, R9, 1 */
		/* 820FFFA8h case   36:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820FFFA8h case   36:*/		return 0x820FFFAC;
		  /* 820FFFACh */ case   37:  		/* addi R10, R10, -1 */
		/* 820FFFACh case   37:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820FFFACh case   37:*/		return 0x820FFFB0;
		  /* 820FFFB0h */ case   38:  		/* divw R11, R11, R9 */
		/* 820FFFB0h case   38:*/		cpu::op::divw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820FFFB0h case   38:*/		return 0x820FFFB4;
		  /* 820FFFB4h */ case   39:  		/* andc R10, R9, R10 */
		/* 820FFFB4h case   39:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820FFFB4h case   39:*/		return 0x820FFFB8;
		  /* 820FFFB8h */ case   40:  		/* stw R11, <#[R23 + 48]> */
		/* 820FFFB8h case   40:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000030) );
		/* 820FFFB8h case   40:*/		return 0x820FFFBC;
		  /* 820FFFBCh */ case   41:  		/* twi 6, R9, 0 */
		/* 820FFFBCh case   41:*/		cpu::op::tw<6>(regs, 0x820FFFBC, regs.R9, 0x00000000);
		/* 820FFFBCh case   41:*/		return 0x820FFFC0;
		  /* 820FFFC0h */ case   42:  		/* lwz R11, <#[R30 + 20]> */
		/* 820FFFC0h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820FFFC0h case   42:*/		return 0x820FFFC4;
		  /* 820FFFC4h */ case   43:  		/* addi R31, R31, 4 */
		/* 820FFFC4h case   43:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820FFFC4h case   43:*/		return 0x820FFFC8;
		  /* 820FFFC8h */ case   44:  		/* twi 5, R10, -1 */
		/* 820FFFC8h case   44:*/		cpu::op::tw<5>(regs, 0x820FFFC8, regs.R10, 0xFFFFFFFF);
		/* 820FFFC8h case   44:*/		return 0x820FFFCC;
		  /* 820FFFCCh */ case   45:  		/* cmplw CR6, R29, R11 */
		/* 820FFFCCh case   45:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820FFFCCh case   45:*/		return 0x820FFFD0;
		  /* 820FFFD0h */ case   46:  		/* bc 12, CR6_LT, -108 */
		/* 820FFFD0h case   46:*/		if ( regs.CR[6].lt ) { return 0x820FFF64;  }
		/* 820FFFD0h case   46:*/		return 0x820FFFD4;
	}
	return 0x820FFFD4;
} // Block from 820FFF18h-820FFFD4h (47 instructions)

//////////////////////////////////////////////////////
// Block at 820FFFD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820FFFD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820FFFD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820FFFD4);
		  /* 820FFFD4h */ case    0:  		/* lis R11, -32240 */
		/* 820FFFD4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8210);
		/* 820FFFD4h case    0:*/		return 0x820FFFD8;
		  /* 820FFFD8h */ case    1:  		/* lwz R5, <#[R30 + 20]> */
		/* 820FFFD8h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000014) );
		/* 820FFFD8h case    1:*/		return 0x820FFFDC;
		  /* 820FFFDCh */ case    2:  		/* mr R6, R28 */
		/* 820FFFDCh case    2:*/		regs.R6 = regs.R28;
		/* 820FFFDCh case    2:*/		return 0x820FFFE0;
		  /* 820FFFE0h */ case    3:  		/* lwz R4, <#[R30 + 24]> */
		/* 820FFFE0h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000018) );
		/* 820FFFE0h case    3:*/		return 0x820FFFE4;
		  /* 820FFFE4h */ case    4:  		/* addi R3, R11, -9680 */
		/* 820FFFE4h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFDA30);
		/* 820FFFE4h case    4:*/		return 0x820FFFE8;
		  /* 820FFFE8h */ case    5:  		/* bl -8520 */
		/* 820FFFE8h case    5:*/		regs.LR = 0x820FFFEC; return 0x820FDEA0;
		/* 820FFFE8h case    5:*/		return 0x820FFFEC;
		  /* 820FFFECh */ case    6:  		/* lwz R11, <#[R30 + 20]> */
		/* 820FFFECh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820FFFECh case    6:*/		return 0x820FFFF0;
		  /* 820FFFF0h */ case    7:  		/* mr R29, R26 */
		/* 820FFFF0h case    7:*/		regs.R29 = regs.R26;
		/* 820FFFF0h case    7:*/		return 0x820FFFF4;
		  /* 820FFFF4h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 820FFFF4h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820FFFF4h case    8:*/		return 0x820FFFF8;
		  /* 820FFFF8h */ case    9:  		/* bc 4, CR6_GT, 60 */
		/* 820FFFF8h case    9:*/		if ( !regs.CR[6].gt ) { return 0x82100034;  }
		/* 820FFFF8h case    9:*/		return 0x820FFFFC;
		  /* 820FFFFCh */ case   10:  		/* mr R31, R26 */
		/* 820FFFFCh case   10:*/		regs.R31 = regs.R26;
		/* 820FFFFCh case   10:*/		return 0x82100000;
		  /* 82100000h */ case   11:  		/* lwz R11, <#[R30 + 24]> */
		/* 82100000h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 82100000h case   11:*/		return 0x82100004;
		  /* 82100004h */ case   12:  		/* mr R6, R25 */
		/* 82100004h case   12:*/		regs.R6 = regs.R25;
		/* 82100004h case   12:*/		return 0x82100008;
		  /* 82100008h */ case   13:  		/* mr R5, R24 */
		/* 82100008h case   13:*/		regs.R5 = regs.R24;
		/* 82100008h case   13:*/		return 0x8210000C;
		  /* 8210000Ch */ case   14:  		/* mr R3, R28 */
		/* 8210000Ch case   14:*/		regs.R3 = regs.R28;
		/* 8210000Ch case   14:*/		return 0x82100010;
		  /* 82100010h */ case   15:  		/* lwzx R4, <#[R11 + R31]> */
		/* 82100010h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82100010h case   15:*/		return 0x82100014;
		  /* 82100014h */ case   16:  		/* bl -252 */
		/* 82100014h case   16:*/		regs.LR = 0x82100018; return 0x820FFF18;
		/* 82100014h case   16:*/		return 0x82100018;
		  /* 82100018h */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 82100018h case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82100018h case   17:*/		return 0x8210001C;
		  /* 8210001Ch */ case   18:  		/* bc 12, CR0_LT, 340 */
		/* 8210001Ch case   18:*/		if ( regs.CR[0].lt ) { return 0x82100170;  }
		/* 8210001Ch case   18:*/		return 0x82100020;
		  /* 82100020h */ case   19:  		/* lwz R11, <#[R30 + 20]> */
		/* 82100020h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 82100020h case   19:*/		return 0x82100024;
		  /* 82100024h */ case   20:  		/* addi R29, R29, 1 */
		/* 82100024h case   20:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82100024h case   20:*/		return 0x82100028;
		  /* 82100028h */ case   21:  		/* addi R31, R31, 4 */
		/* 82100028h case   21:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82100028h case   21:*/		return 0x8210002C;
		  /* 8210002Ch */ case   22:  		/* cmplw CR6, R29, R11 */
		/* 8210002Ch case   22:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8210002Ch case   22:*/		return 0x82100030;
		  /* 82100030h */ case   23:  		/* bc 12, CR6_LT, -48 */
		/* 82100030h case   23:*/		if ( regs.CR[6].lt ) { return 0x82100000;  }
		/* 82100030h case   23:*/		return 0x82100034;
	}
	return 0x82100034;
} // Block from 820FFFD4h-82100034h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82100034h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100034( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100034) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100034);
		  /* 82100034h */ case    0:  		/* lwz R11, <#[R30 + 36]> */
		/* 82100034h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 82100034h case    0:*/		return 0x82100038;
		  /* 82100038h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82100038h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82100038h case    1:*/		return 0x8210003C;
		  /* 8210003Ch */ case    2:  		/* bc 4, CR6_EQ, 304 */
		/* 8210003Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x8210016C;  }
		/* 8210003Ch case    2:*/		return 0x82100040;
		  /* 82100040h */ case    3:  		/* li R11, 1 */
		/* 82100040h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82100040h case    3:*/		return 0x82100044;
		  /* 82100044h */ case    4:  		/* mr R29, R26 */
		/* 82100044h case    4:*/		regs.R29 = regs.R26;
		/* 82100044h case    4:*/		return 0x82100048;
		  /* 82100048h */ case    5:  		/* stw R11, <#[R30 + 36]> */
		/* 82100048h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 82100048h case    5:*/		return 0x8210004C;
		  /* 8210004Ch */ case    6:  		/* lwz R11, <#[R25]> */
		/* 8210004Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 8210004Ch case    6:*/		return 0x82100050;
		  /* 82100050h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82100050h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82100050h case    7:*/		return 0x82100054;
		  /* 82100054h */ case    8:  		/* stwx R27, <#[R11 + R24]> */
		/* 82100054h case    8:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + regs.R24 + 0x00000000) );
		/* 82100054h case    8:*/		return 0x82100058;
		  /* 82100058h */ case    9:  		/* lwz R11, <#[R25]> */
		/* 82100058h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 82100058h case    9:*/		return 0x8210005C;
		  /* 8210005Ch */ case   10:  		/* addi R11, R11, 1 */
		/* 8210005Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210005Ch case   10:*/		return 0x82100060;
		  /* 82100060h */ case   11:  		/* stw R11, <#[R25]> */
		/* 82100060h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 82100060h case   11:*/		return 0x82100064;
		  /* 82100064h */ case   12:  		/* lwz R11, <#[R30 + 20]> */
		/* 82100064h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 82100064h case   12:*/		return 0x82100068;
		  /* 82100068h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 82100068h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82100068h case   13:*/		return 0x8210006C;
		  /* 8210006Ch */ case   14:  		/* bc 4, CR6_GT, 256 */
		/* 8210006Ch case   14:*/		if ( !regs.CR[6].gt ) { return 0x8210016C;  }
		/* 8210006Ch case   14:*/		return 0x82100070;
		  /* 82100070h */ case   15:  		/* mr R31, R26 */
		/* 82100070h case   15:*/		regs.R31 = regs.R26;
		/* 82100070h case   15:*/		return 0x82100074;
		  /* 82100074h */ case   16:  		/* lwz R11, <#[R30 + 24]> */
		/* 82100074h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 82100074h case   16:*/		return 0x82100078;
		  /* 82100078h */ case   17:  		/* li R7, -1 */
		/* 82100078h case   17:*/		cpu::op::li<0>(regs,&regs.R7,0xFFFFFFFF);
		/* 82100078h case   17:*/		return 0x8210007C;
		  /* 8210007Ch */ case   18:  		/* lwz R8, <#[R28 + 24]> */
		/* 8210007Ch case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R28 + 0x00000018) );
		/* 8210007Ch case   18:*/		return 0x82100080;
		  /* 82100080h */ case   19:  		/* mr R10, R26 */
		/* 82100080h case   19:*/		regs.R10 = regs.R26;
		/* 82100080h case   19:*/		return 0x82100084;
		  /* 82100084h */ case   20:  		/* lwzx R11, <#[R11 + R31]> */
		/* 82100084h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82100084h case   20:*/		return 0x82100088;
		  /* 82100088h */ case   21:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82100088h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82100088h case   21:*/		return 0x8210008C;
		  /* 8210008Ch */ case   22:  		/* lwzx R11, <#[R11 + R8]> */
		/* 8210008Ch case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8210008Ch case   22:*/		return 0x82100090;
		  /* 82100090h */ case   23:  		/* lwz R9, <#[R11 + 28]> */
		/* 82100090h case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000001C) );
		/* 82100090h case   23:*/		return 0x82100094;
		  /* 82100094h */ case   24:  		/* cmplwi CR6, R9, 0 */
		/* 82100094h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82100094h case   24:*/		return 0x82100098;
		  /* 82100098h */ case   25:  		/* bc 12, CR6_EQ, 192 */
		/* 82100098h case   25:*/		if ( regs.CR[6].eq ) { return 0x82100158;  }
		/* 82100098h case   25:*/		return 0x8210009C;
		  /* 8210009Ch */ case   26:  		/* lwz R6, <#[R11 + 32]> */
		/* 8210009Ch case   26:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000020) );
		/* 8210009Ch case   26:*/		return 0x821000A0;
		  /* 821000A0h */ case   27:  		/* mr R11, R26 */
		/* 821000A0h case   27:*/		regs.R11 = regs.R26;
		/* 821000A0h case   27:*/		return 0x821000A4;
		  /* 821000A4h */ case   28:  		/* lwzx R5, <#[R11 + R6]> */
		/* 821000A4h case   28:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 821000A4h case   28:*/		return 0x821000A8;
		  /* 821000A8h */ case   29:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 821000A8h case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 821000A8h case   29:*/		return 0x821000AC;
		  /* 821000ACh */ case   30:  		/* lwzx R5, <#[R5 + R8]> */
		/* 821000ACh case   30:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R8 + 0x00000000) );
		/* 821000ACh case   30:*/		return 0x821000B0;
		  /* 821000B0h */ case   31:  		/* lwz R5, <#[R5 + 36]> */
		/* 821000B0h case   31:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000024) );
		/* 821000B0h case   31:*/		return 0x821000B4;
		  /* 821000B4h */ case   32:  		/* cmplwi CR6, R5, 0 */
		/* 821000B4h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821000B4h case   32:*/		return 0x821000B8;
		  /* 821000B8h */ case   33:  		/* bc 4, CR6_EQ, 16 */
		/* 821000B8h case   33:*/		if ( !regs.CR[6].eq ) { return 0x821000C8;  }
		/* 821000B8h case   33:*/		return 0x821000BC;
		  /* 821000BCh */ case   34:  		/* cmpwi CR6, R7, -1 */
		/* 821000BCh case   34:*/		cpu::op::cmpwi<6>(regs,regs.R7,0xFFFFFFFF);
		/* 821000BCh case   34:*/		return 0x821000C0;
		  /* 821000C0h */ case   35:  		/* bc 4, CR6_EQ, 32 */
		/* 821000C0h case   35:*/		if ( !regs.CR[6].eq ) { return 0x821000E0;  }
		/* 821000C0h case   35:*/		return 0x821000C4;
		  /* 821000C4h */ case   36:  		/* mr R7, R10 */
		/* 821000C4h case   36:*/		regs.R7 = regs.R10;
		/* 821000C4h case   36:*/		return 0x821000C8;
	}
	return 0x821000C8;
} // Block from 82100034h-821000C8h (37 instructions)

//////////////////////////////////////////////////////
// Block at 821000C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821000C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821000C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821000C8);
		  /* 821000C8h */ case    0:  		/* addi R10, R10, 1 */
		/* 821000C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821000C8h case    0:*/		return 0x821000CC;
		  /* 821000CCh */ case    1:  		/* addi R11, R11, 4 */
		/* 821000CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821000CCh case    1:*/		return 0x821000D0;
		  /* 821000D0h */ case    2:  		/* cmplw CR6, R10, R9 */
		/* 821000D0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821000D0h case    2:*/		return 0x821000D4;
		  /* 821000D4h */ case    3:  		/* bc 12, CR6_LT, -48 */
		/* 821000D4h case    3:*/		if ( regs.CR[6].lt ) { return 0x821000A4;  }
		/* 821000D4h case    3:*/		return 0x821000D8;
		  /* 821000D8h */ case    4:  		/* cmpwi CR6, R7, -1 */
		/* 821000D8h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R7,0xFFFFFFFF);
		/* 821000D8h case    4:*/		return 0x821000DC;
		  /* 821000DCh */ case    5:  		/* bc 12, CR6_EQ, 124 */
		/* 821000DCh case    5:*/		if ( regs.CR[6].eq ) { return 0x82100158;  }
		/* 821000DCh case    5:*/		return 0x821000E0;
	}
	return 0x821000E0;
} // Block from 821000C8h-821000E0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821000E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821000E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821000E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821000E0);
		  /* 821000E0h */ case    0:  		/* cmplw CR6, R10, R9 */
		/* 821000E0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821000E0h case    0:*/		return 0x821000E4;
		  /* 821000E4h */ case    1:  		/* bc 4, CR6_EQ, 116 */
		/* 821000E4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82100158;  }
		/* 821000E4h case    1:*/		return 0x821000E8;
		  /* 821000E8h */ case    2:  		/* rlwinm R11, R7, 2, 0, 29 */
		/* 821000E8h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R7);
		/* 821000E8h case    2:*/		return 0x821000EC;
		  /* 821000ECh */ case    3:  		/* mr R9, R26 */
		/* 821000ECh case    3:*/		regs.R9 = regs.R26;
		/* 821000ECh case    3:*/		return 0x821000F0;
		  /* 821000F0h */ case    4:  		/* lwzx R4, <#[R11 + R6]> */
		/* 821000F0h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 821000F0h case    4:*/		return 0x821000F4;
		  /* 821000F4h */ case    5:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 821000F4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 821000F4h case    5:*/		return 0x821000F8;
		  /* 821000F8h */ case    6:  		/* lwzx R11, <#[R11 + R8]> */
		/* 821000F8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 821000F8h case    6:*/		return 0x821000FC;
		  /* 821000FCh */ case    7:  		/* lwz R10, <#[R11 + 20]> */
		/* 821000FCh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 821000FCh case    7:*/		return 0x82100100;
		  /* 82100100h */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 82100100h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82100100h case    8:*/		return 0x82100104;
		  /* 82100104h */ case    9:  		/* bc 12, CR6_EQ, 52 */
		/* 82100104h case    9:*/		if ( regs.CR[6].eq ) { return 0x82100138;  }
		/* 82100104h case    9:*/		return 0x82100108;
		  /* 82100108h */ case   10:  		/* lwz R7, <#[R11 + 24]> */
		/* 82100108h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000018) );
		/* 82100108h case   10:*/		return 0x8210010C;
		  /* 8210010Ch */ case   11:  		/* mr R11, R26 */
		/* 8210010Ch case   11:*/		regs.R11 = regs.R26;
		/* 8210010Ch case   11:*/		return 0x82100110;
		  /* 82100110h */ case   12:  		/* lwzx R6, <#[R11 + R7]> */
		/* 82100110h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82100110h case   12:*/		return 0x82100114;
		  /* 82100114h */ case   13:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 82100114h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 82100114h case   13:*/		return 0x82100118;
		  /* 82100118h */ case   14:  		/* lwzx R6, <#[R6 + R8]> */
		/* 82100118h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R8 + 0x00000000) );
		/* 82100118h case   14:*/		return 0x8210011C;
		  /* 8210011Ch */ case   15:  		/* lwz R6, <#[R6 + 36]> */
		/* 8210011Ch case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000024) );
		/* 8210011Ch case   15:*/		return 0x82100120;
		  /* 82100120h */ case   16:  		/* cmplwi CR6, R6, 0 */
		/* 82100120h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82100120h case   16:*/		return 0x82100124;
		  /* 82100124h */ case   17:  		/* bc 12, CR6_EQ, 20 */
		/* 82100124h case   17:*/		if ( regs.CR[6].eq ) { return 0x82100138;  }
		/* 82100124h case   17:*/		return 0x82100128;
		  /* 82100128h */ case   18:  		/* addi R9, R9, 1 */
		/* 82100128h case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82100128h case   18:*/		return 0x8210012C;
		  /* 8210012Ch */ case   19:  		/* addi R11, R11, 4 */
		/* 8210012Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210012Ch case   19:*/		return 0x82100130;
		  /* 82100130h */ case   20:  		/* cmplw CR6, R9, R10 */
		/* 82100130h case   20:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82100130h case   20:*/		return 0x82100134;
		  /* 82100134h */ case   21:  		/* bc 12, CR6_LT, -36 */
		/* 82100134h case   21:*/		if ( regs.CR[6].lt ) { return 0x82100110;  }
		/* 82100134h case   21:*/		return 0x82100138;
	}
	return 0x82100138;
} // Block from 821000E0h-82100138h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82100138h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100138);
		  /* 82100138h */ case    0:  		/* cmplw CR6, R9, R10 */
		/* 82100138h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82100138h case    0:*/		return 0x8210013C;
		  /* 8210013Ch */ case    1:  		/* bc 12, CR6_LT, 28 */
		/* 8210013Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x82100158;  }
		/* 8210013Ch case    1:*/		return 0x82100140;
		  /* 82100140h */ case    2:  		/* mr R6, R25 */
		/* 82100140h case    2:*/		regs.R6 = regs.R25;
		/* 82100140h case    2:*/		return 0x82100144;
		  /* 82100144h */ case    3:  		/* mr R5, R24 */
		/* 82100144h case    3:*/		regs.R5 = regs.R24;
		/* 82100144h case    3:*/		return 0x82100148;
		  /* 82100148h */ case    4:  		/* mr R3, R28 */
		/* 82100148h case    4:*/		regs.R3 = regs.R28;
		/* 82100148h case    4:*/		return 0x8210014C;
		  /* 8210014Ch */ case    5:  		/* bl -564 */
		/* 8210014Ch case    5:*/		regs.LR = 0x82100150; return 0x820FFF18;
		/* 8210014Ch case    5:*/		return 0x82100150;
		  /* 82100150h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 82100150h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82100150h case    6:*/		return 0x82100154;
		  /* 82100154h */ case    7:  		/* bc 12, CR0_LT, 28 */
		/* 82100154h case    7:*/		if ( regs.CR[0].lt ) { return 0x82100170;  }
		/* 82100154h case    7:*/		return 0x82100158;
	}
	return 0x82100158;
} // Block from 82100138h-82100158h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82100158h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100158);
		  /* 82100158h */ case    0:  		/* lwz R11, <#[R30 + 20]> */
		/* 82100158h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 82100158h case    0:*/		return 0x8210015C;
		  /* 8210015Ch */ case    1:  		/* addi R29, R29, 1 */
		/* 8210015Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8210015Ch case    1:*/		return 0x82100160;
		  /* 82100160h */ case    2:  		/* addi R31, R31, 4 */
		/* 82100160h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82100160h case    2:*/		return 0x82100164;
		  /* 82100164h */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 82100164h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82100164h case    3:*/		return 0x82100168;
		  /* 82100168h */ case    4:  		/* bc 12, CR6_LT, -244 */
		/* 82100168h case    4:*/		if ( regs.CR[6].lt ) { return 0x82100074;  }
		/* 82100168h case    4:*/		return 0x8210016C;
	}
	return 0x8210016C;
} // Block from 82100158h-8210016Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210016Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210016C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210016C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210016C);
		  /* 8210016Ch */ case    0:  		/* li R3, 0 */
		/* 8210016Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8210016Ch case    0:*/		return 0x82100170;
	}
	return 0x82100170;
} // Block from 8210016Ch-82100170h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82100170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100170);
		  /* 82100170h */ case    0:  		/* addi R1, R1, 176 */
		/* 82100170h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82100170h case    0:*/		return 0x82100174;
		  /* 82100174h */ case    1:  		/* b -454368 */
		/* 82100174h case    1:*/		return 0x82091294;
		/* 82100174h case    1:*/		return 0x82100178;
	}
	return 0x82100178;
} // Block from 82100170h-82100178h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82100178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100178);
		  /* 82100178h */ case    0:  		/* mfspr R12, LR */
		/* 82100178h case    0:*/		regs.R12 = regs.LR;
		/* 82100178h case    0:*/		return 0x8210017C;
		  /* 8210017Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8210017Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8210017Ch case    1:*/		return 0x82100180;
		  /* 82100180h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82100180h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82100180h case    2:*/		return 0x82100184;
		  /* 82100184h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82100184h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82100184h case    3:*/		return 0x82100188;
		  /* 82100188h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82100188h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82100188h case    4:*/		return 0x8210018C;
		  /* 8210018Ch */ case    5:  		/* lwz R10, <#[R3 + 20]> */
		/* 8210018Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 8210018Ch case    5:*/		return 0x82100190;
		  /* 82100190h */ case    6:  		/* rlwinm R9, R6, 2, 0, 29 */
		/* 82100190h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R6);
		/* 82100190h case    6:*/		return 0x82100194;
		  /* 82100194h */ case    7:  		/* mr R11, R4 */
		/* 82100194h case    7:*/		regs.R11 = regs.R4;
		/* 82100194h case    7:*/		return 0x82100198;
		  /* 82100198h */ case    8:  		/* lwz R4, <#[R3 + 120]> */
		/* 82100198h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000078) );
		/* 82100198h case    8:*/		return 0x8210019C;
		  /* 8210019Ch */ case    9:  		/* mr R30, R6 */
		/* 8210019Ch case    9:*/		regs.R30 = regs.R6;
		/* 8210019Ch case    9:*/		return 0x821001A0;
		  /* 821001A0h */ case   10:  		/* mr R6, R5 */
		/* 821001A0h case   10:*/		regs.R6 = regs.R5;
		/* 821001A0h case   10:*/		return 0x821001A4;
		  /* 821001A4h */ case   11:  		/* mr R5, R11 */
		/* 821001A4h case   11:*/		regs.R5 = regs.R11;
		/* 821001A4h case   11:*/		return 0x821001A8;
		  /* 821001A8h */ case   12:  		/* lwzx R11, <#[R9 + R10]> */
		/* 821001A8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821001A8h case   12:*/		return 0x821001AC;
		  /* 821001ACh */ case   13:  		/* mr R31, R3 */
		/* 821001ACh case   13:*/		regs.R31 = regs.R3;
		/* 821001ACh case   13:*/		return 0x821001B0;
		  /* 821001B0h */ case   14:  		/* lfd FR1, <#[R11 + 32]> */
		/* 821001B0h case   14:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000020) );
		/* 821001B0h case   14:*/		return 0x821001B4;
		  /* 821001B4h */ case   15:  		/* bl -12172 */
		/* 821001B4h case   15:*/		regs.LR = 0x821001B8; return 0x820FD228;
		/* 821001B4h case   15:*/		return 0x821001B8;
		  /* 821001B8h */ case   16:  		/* cmpwi CR6, R3, -1 */
		/* 821001B8h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 821001B8h case   16:*/		return 0x821001BC;
		  /* 821001BCh */ case   17:  		/* bc 4, CR6_EQ, 12 */
		/* 821001BCh case   17:*/		if ( !regs.CR[6].eq ) { return 0x821001C8;  }
		/* 821001BCh case   17:*/		return 0x821001C0;
		  /* 821001C0h */ case   18:  		/* li R3, -1 */
		/* 821001C0h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 821001C0h case   18:*/		return 0x821001C4;
		  /* 821001C4h */ case   19:  		/* b 40 */
		/* 821001C4h case   19:*/		return 0x821001EC;
		/* 821001C4h case   19:*/		return 0x821001C8;
	}
	return 0x821001C8;
} // Block from 82100178h-821001C8h (20 instructions)

