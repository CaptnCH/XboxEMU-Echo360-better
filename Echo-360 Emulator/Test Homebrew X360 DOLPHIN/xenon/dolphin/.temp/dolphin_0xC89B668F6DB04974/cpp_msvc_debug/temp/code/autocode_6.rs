#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 82095670h
// Function '_woutput_s_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095670);
		  /* 82095670h */ case    0:  		/* b -592 */
		/* 82095670h case    0:*/		return 0x82095420;
		/* 82095670h case    0:*/		return 0x82095674;
		  /* 82095674h */ case    1:  		/* ori R25, R25, 64 */
		/* 82095674h case    1:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x40);
		/* 82095674h case    1:*/		return 0x82095678;
		  /* 82095678h */ case    2:  		/* li R8, 10 */
		/* 82095678h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0xA);
		/* 82095678h case    2:*/		return 0x8209567C;
		  /* 8209567Ch */ case    3:  		/* b 76 */
		/* 8209567Ch case    3:*/		return 0x820956C8;
		/* 8209567Ch case    3:*/		return 0x82095680;
		  /* 82095680h */ case    4:  		/* li R23, 8 */
		/* 82095680h case    4:*/		cpu::op::li<0>(regs,&regs.R23,0x8);
		/* 82095680h case    4:*/		return 0x82095684;
		  /* 82095684h */ case    5:  		/* li R11, 7 */
		/* 82095684h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 82095684h case    5:*/		return 0x82095688;
		  /* 82095688h */ case    6:  		/* b 8 */
		/* 82095688h case    6:*/		return 0x82095690;
		/* 82095688h case    6:*/		return 0x8209568C;
		  /* 8209568Ch */ case    7:  		/* li R11, 39 */
		/* 8209568Ch case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x27);
		/* 8209568Ch case    7:*/		return 0x82095690;
	}
	return 0x82095690;
} // Block from 82095670h-82095690h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82095690h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095690);
		  /* 82095690h */ case    0:  		/* stw R11, <#[R1 + 100]> */
		/* 82095690h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82095690h case    0:*/		return 0x82095694;
		  /* 82095694h */ case    1:  		/* rlwinm. R10, R25, 0, 24, 24 */
		/* 82095694h case    1:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R10,regs.R25);
		/* 82095694h case    1:*/		return 0x82095698;
		  /* 82095698h */ case    2:  		/* li R8, 16 */
		/* 82095698h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x10);
		/* 82095698h case    2:*/		return 0x8209569C;
		  /* 8209569Ch */ case    3:  		/* bc 12, CR0_EQ, 44 */
		/* 8209569Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x820956C8;  }
		/* 8209569Ch case    3:*/		return 0x820956A0;
		  /* 820956A0h */ case    4:  		/* addi R11, R11, 81 */
		/* 820956A0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x51);
		/* 820956A0h case    4:*/		return 0x820956A4;
		  /* 820956A4h */ case    5:  		/* li R10, 48 */
		/* 820956A4h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x30);
		/* 820956A4h case    5:*/		return 0x820956A8;
		  /* 820956A8h */ case    6:  		/* li R15, 2 */
		/* 820956A8h case    6:*/		cpu::op::li<0>(regs,&regs.R15,0x2);
		/* 820956A8h case    6:*/		return 0x820956AC;
		  /* 820956ACh */ case    7:  		/* sth R11, <#[R1 + 90]> */
		/* 820956ACh case    7:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x0000005A) );
		/* 820956ACh case    7:*/		return 0x820956B0;
		  /* 820956B0h */ case    8:  		/* sth R10, <#[R1 + 88]> */
		/* 820956B0h case    8:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 820956B0h case    8:*/		return 0x820956B4;
		  /* 820956B4h */ case    9:  		/* b 20 */
		/* 820956B4h case    9:*/		return 0x820956C8;
		/* 820956B4h case    9:*/		return 0x820956B8;
		  /* 820956B8h */ case   10:  		/* rlwinm. R11, R25, 0, 24, 24 */
		/* 820956B8h case   10:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R11,regs.R25);
		/* 820956B8h case   10:*/		return 0x820956BC;
		  /* 820956BCh */ case   11:  		/* li R8, 8 */
		/* 820956BCh case   11:*/		cpu::op::li<0>(regs,&regs.R8,0x8);
		/* 820956BCh case   11:*/		return 0x820956C0;
		  /* 820956C0h */ case   12:  		/* bc 12, CR0_EQ, 8 */
		/* 820956C0h case   12:*/		if ( regs.CR[0].eq ) { return 0x820956C8;  }
		/* 820956C0h case   12:*/		return 0x820956C4;
		  /* 820956C4h */ case   13:  		/* ori R25, R25, 512 */
		/* 820956C4h case   13:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x200);
		/* 820956C4h case   13:*/		return 0x820956C8;
	}
	return 0x820956C8;
} // Block from 82095690h-820956C8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820956C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820956C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820956C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820956C8);
		  /* 820956C8h */ case    0:  		/* rlwinm. R11, R25, 0, 16, 16 */
		/* 820956C8h case    0:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R11,regs.R25);
		/* 820956C8h case    0:*/		return 0x820956CC;
		  /* 820956CCh */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820956CCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x820956D8;  }
		/* 820956CCh case    1:*/		return 0x820956D0;
		  /* 820956D0h */ case    2:  		/* rlwinm. R11, R25, 0, 19, 19 */
		/* 820956D0h case    2:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R11,regs.R25);
		/* 820956D0h case    2:*/		return 0x820956D4;
		  /* 820956D4h */ case    3:  		/* bc 12, CR0_EQ, 24 */
		/* 820956D4h case    3:*/		if ( regs.CR[0].eq ) { return 0x820956EC;  }
		/* 820956D4h case    3:*/		return 0x820956D8;
	}
	return 0x820956D8;
} // Block from 820956C8h-820956D8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820956D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820956D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820956D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820956D8);
		  /* 820956D8h */ case    0:  		/* addi R11, R24, 7 */
		/* 820956D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x7);
		/* 820956D8h case    0:*/		return 0x820956DC;
		  /* 820956DCh */ case    1:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 820956DCh case    1:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 820956DCh case    1:*/		return 0x820956E0;
		  /* 820956E0h */ case    2:  		/* addi R24, R11, 8 */
		/* 820956E0h case    2:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x8);
		/* 820956E0h case    2:*/		return 0x820956E4;
		  /* 820956E4h */ case    3:  		/* ld R11, <#[R11]> */
		/* 820956E4h case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820956E4h case    3:*/		return 0x820956E8;
		  /* 820956E8h */ case    4:  		/* b 84 */
		/* 820956E8h case    4:*/		return 0x8209573C;
		/* 820956E8h case    4:*/		return 0x820956EC;
	}
	return 0x820956EC;
} // Block from 820956D8h-820956ECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820956ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820956EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820956EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820956EC);
		  /* 820956ECh */ case    0:  		/* rlwinm. R11, R25, 0, 26, 26 */
		/* 820956ECh case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R25);
		/* 820956ECh case    0:*/		return 0x820956F0;
		  /* 820956F0h */ case    1:  		/* bc 12, CR0_EQ, 44 */
		/* 820956F0h case    1:*/		if ( regs.CR[0].eq ) { return 0x8209571C;  }
		/* 820956F0h case    1:*/		return 0x820956F4;
		  /* 820956F4h */ case    2:  		/* rlwinm. R11, R25, 0, 25, 25 */
		/* 820956F4h case    2:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R25);
		/* 820956F4h case    2:*/		return 0x820956F8;
		  /* 820956F8h */ case    3:  		/* addi R11, R24, 7 */
		/* 820956F8h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x7);
		/* 820956F8h case    3:*/		return 0x820956FC;
		  /* 820956FCh */ case    4:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 820956FCh case    4:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 820956FCh case    4:*/		return 0x82095700;
		  /* 82095700h */ case    5:  		/* addi R24, R11, 8 */
		/* 82095700h case    5:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x8);
		/* 82095700h case    5:*/		return 0x82095704;
		  /* 82095704h */ case    6:  		/* lwz R11, <#[R11 + 4]> */
		/* 82095704h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82095704h case    6:*/		return 0x82095708;
		  /* 82095708h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 82095708h case    7:*/		if ( regs.CR[0].eq ) { return 0x82095714;  }
		/* 82095708h case    7:*/		return 0x8209570C;
		  /* 8209570Ch */ case    8:  		/* extsh R11, R11 */
		/* 8209570Ch case    8:*/		cpu::op::extsh<0>(regs,&regs.R11,regs.R11);
		/* 8209570Ch case    8:*/		return 0x82095710;
		  /* 82095710h */ case    9:  		/* b 44 */
		/* 82095710h case    9:*/		return 0x8209573C;
		/* 82095710h case    9:*/		return 0x82095714;
	}
	return 0x82095714;
} // Block from 820956ECh-82095714h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82095714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095714);
		  /* 82095714h */ case    0:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 82095714h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 82095714h case    0:*/		return 0x82095718;
		  /* 82095718h */ case    1:  		/* b 36 */
		/* 82095718h case    1:*/		return 0x8209573C;
		/* 82095718h case    1:*/		return 0x8209571C;
	}
	return 0x8209571C;
} // Block from 82095714h-8209571Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209571Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209571C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209571C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209571C);
		  /* 8209571Ch */ case    0:  		/* rlwinm. R11, R25, 0, 25, 25 */
		/* 8209571Ch case    0:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R25);
		/* 8209571Ch case    0:*/		return 0x82095720;
		  /* 82095720h */ case    1:  		/* addi R11, R24, 7 */
		/* 82095720h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x7);
		/* 82095720h case    1:*/		return 0x82095724;
		  /* 82095724h */ case    2:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82095724h case    2:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82095724h case    2:*/		return 0x82095728;
		  /* 82095728h */ case    3:  		/* addi R24, R11, 8 */
		/* 82095728h case    3:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x8);
		/* 82095728h case    3:*/		return 0x8209572C;
		  /* 8209572Ch */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 8209572Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x82095738;  }
		/* 8209572Ch case    4:*/		return 0x82095730;
		  /* 82095730h */ case    5:  		/* lwa R11, <#[R11 + 4]> */
		/* 82095730h case    5:*/		cpu::mem::load32a( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82095730h case    5:*/		return 0x82095734;
		  /* 82095734h */ case    6:  		/* b 8 */
		/* 82095734h case    6:*/		return 0x8209573C;
		/* 82095734h case    6:*/		return 0x82095738;
	}
	return 0x82095738;
} // Block from 8209571Ch-82095738h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82095738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095738);
		  /* 82095738h */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 82095738h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82095738h case    0:*/		return 0x8209573C;
	}
	return 0x8209573C;
} // Block from 82095738h-8209573Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209573Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209573C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209573C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209573C);
		  /* 8209573Ch */ case    0:  		/* rlwinm. R10, R25, 0, 25, 25 */
		/* 8209573Ch case    0:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R25);
		/* 8209573Ch case    0:*/		return 0x82095740;
		  /* 82095740h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 82095740h case    1:*/		if ( regs.CR[0].eq ) { return 0x82095754;  }
		/* 82095740h case    1:*/		return 0x82095744;
		  /* 82095744h */ case    2:  		/* cmpdi CR6, R11, 0 */
		/* 82095744h case    2:*/		cpu::op::cmpdi<6>(regs,regs.R11,0x00000000);
		/* 82095744h case    2:*/		return 0x82095748;
		  /* 82095748h */ case    3:  		/* bc 4, CR6_LT, 12 */
		/* 82095748h case    3:*/		if ( !regs.CR[6].lt ) { return 0x82095754;  }
		/* 82095748h case    3:*/		return 0x8209574C;
		  /* 8209574Ch */ case    4:  		/* neg R11, R11 */
		/* 8209574Ch case    4:*/		cpu::op::neg<0>(regs,&regs.R11,regs.R11);
		/* 8209574Ch case    4:*/		return 0x82095750;
		  /* 82095750h */ case    5:  		/* ori R25, R25, 256 */
		/* 82095750h case    5:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x100);
		/* 82095750h case    5:*/		return 0x82095754;
	}
	return 0x82095754;
} // Block from 8209573Ch-82095754h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82095754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095754);
		  /* 82095754h */ case    0:  		/* rlwinm. R10, R25, 0, 16, 16 */
		/* 82095754h case    0:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R10,regs.R25);
		/* 82095754h case    0:*/		return 0x82095758;
		  /* 82095758h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 82095758h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82095768;  }
		/* 82095758h case    1:*/		return 0x8209575C;
		  /* 8209575Ch */ case    2:  		/* rlwinm. R10, R25, 0, 19, 19 */
		/* 8209575Ch case    2:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R10,regs.R25);
		/* 8209575Ch case    2:*/		return 0x82095760;
		  /* 82095760h */ case    3:  		/* bc 4, CR0_EQ, 8 */
		/* 82095760h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82095768;  }
		/* 82095760h case    3:*/		return 0x82095764;
		  /* 82095764h */ case    4:  		/* rldicl R11, R11, 0, 32 */
		/* 82095764h case    4:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R11);
		/* 82095764h case    4:*/		return 0x82095768;
	}
	return 0x82095768;
} // Block from 82095754h-82095768h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82095768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095768);
		  /* 82095768h */ case    0:  		/* cmpwi CR6, R23, 0 */
		/* 82095768h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 82095768h case    0:*/		return 0x8209576C;
		  /* 8209576Ch */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 8209576Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x82095778;  }
		/* 8209576Ch case    1:*/		return 0x82095770;
		  /* 82095770h */ case    2:  		/* li R23, 1 */
		/* 82095770h case    2:*/		cpu::op::li<0>(regs,&regs.R23,0x1);
		/* 82095770h case    2:*/		return 0x82095774;
		  /* 82095774h */ case    3:  		/* b 20 */
		/* 82095774h case    3:*/		return 0x82095788;
		/* 82095774h case    3:*/		return 0x82095778;
	}
	return 0x82095778;
} // Block from 82095768h-82095778h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82095778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095778);
		  /* 82095778h */ case    0:  		/* rlwinm R25, R25, 0, 29, 27 */
		/* 82095778h case    0:*/		cpu::op::rlwinm<0,0,29,27>(regs,&regs.R25,regs.R25);
		/* 82095778h case    0:*/		return 0x8209577C;
		  /* 8209577Ch */ case    1:  		/* cmpwi CR6, R23, 512 */
		/* 8209577Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000200);
		/* 8209577Ch case    1:*/		return 0x82095780;
		  /* 82095780h */ case    2:  		/* bc 4, CR6_GT, 8 */
		/* 82095780h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82095788;  }
		/* 82095780h case    2:*/		return 0x82095784;
		  /* 82095784h */ case    3:  		/* li R23, 512 */
		/* 82095784h case    3:*/		cpu::op::li<0>(regs,&regs.R23,0x200);
		/* 82095784h case    3:*/		return 0x82095788;
	}
	return 0x82095788;
} // Block from 82095778h-82095788h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82095788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095788);
		  /* 82095788h */ case    0:  		/* cmpldi CR6, R11, 0 */
		/* 82095788h case    0:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82095788h case    0:*/		return 0x8209578C;
		  /* 8209578Ch */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 8209578Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82095794;  }
		/* 8209578Ch case    1:*/		return 0x82095790;
		  /* 82095790h */ case    2:  		/* li R15, 0 */
		/* 82095790h case    2:*/		cpu::op::li<0>(regs,&regs.R15,0x0);
		/* 82095790h case    2:*/		return 0x82095794;
	}
	return 0x82095794;
} // Block from 82095788h-82095794h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82095794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095794);
		  /* 82095794h */ case    0:  		/* addi R9, R1, 639 */
		/* 82095794h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x27F);
		/* 82095794h case    0:*/		return 0x82095798;
		  /* 82095798h */ case    1:  		/* cmpwi CR6, R23, 0 */
		/* 82095798h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 82095798h case    1:*/		return 0x8209579C;
		  /* 8209579Ch */ case    2:  		/* addi R23, R23, -1 */
		/* 8209579Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0xFFFFFFFF);
		/* 8209579Ch case    2:*/		return 0x820957A0;
		  /* 820957A0h */ case    3:  		/* bc 12, CR6_GT, 12 */
		/* 820957A0h case    3:*/		if ( regs.CR[6].gt ) { return 0x820957AC;  }
		/* 820957A0h case    3:*/		return 0x820957A4;
		  /* 820957A4h */ case    4:  		/* cmpldi CR6, R11, 0 */
		/* 820957A4h case    4:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 820957A4h case    4:*/		return 0x820957A8;
		  /* 820957A8h */ case    5:  		/* bc 12, CR6_EQ, 72 */
		/* 820957A8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820957F0;  }
		/* 820957A8h case    5:*/		return 0x820957AC;
	}
	return 0x820957AC;
} // Block from 82095794h-820957ACh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820957ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820957AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820957AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820957AC);
		  /* 820957ACh */ case    0:  		/* extsw R10, R8 */
		/* 820957ACh case    0:*/		cpu::op::extsw<0>(regs,&regs.R10,regs.R8);
		/* 820957ACh case    0:*/		return 0x820957B0;
		  /* 820957B0h */ case    1:  		/* divdu R7, R11, R10 */
		/* 820957B0h case    1:*/		cpu::op::divdu<0>(regs,&regs.R7,regs.R11,regs.R10);
		/* 820957B0h case    1:*/		return 0x820957B4;
		  /* 820957B4h */ case    2:  		/* tdi 6, R10, 0 */
		/* 820957B4h case    2:*/		cpu::op::td<6>(regs, 0x820957B4, regs.R10, 0x00000000);
		/* 820957B4h case    2:*/		return 0x820957B8;
		  /* 820957B8h */ case    3:  		/* mulld R7, R7, R10 */
		/* 820957B8h case    3:*/		cpu::op::mulld<0>(regs,&regs.R7,regs.R7,regs.R10);
		/* 820957B8h case    3:*/		return 0x820957BC;
		  /* 820957BCh */ case    4:  		/* subf R7, R7, R11 */
		/* 820957BCh case    4:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R7,regs.R11);
		/* 820957BCh case    4:*/		return 0x820957C0;
		  /* 820957C0h */ case    5:  		/* divdu R11, R11, R10 */
		/* 820957C0h case    5:*/		cpu::op::divdu<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820957C0h case    5:*/		return 0x820957C4;
		  /* 820957C4h */ case    6:  		/* tdi 6, R10, 0 */
		/* 820957C4h case    6:*/		cpu::op::td<6>(regs, 0x820957C4, regs.R10, 0x00000000);
		/* 820957C4h case    6:*/		return 0x820957C8;
		  /* 820957C8h */ case    7:  		/* rlwinm R10, R7, 0, 0, 31 */
		/* 820957C8h case    7:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R7);
		/* 820957C8h case    7:*/		return 0x820957CC;
		  /* 820957CCh */ case    8:  		/* addi R10, R10, 48 */
		/* 820957CCh case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x30);
		/* 820957CCh case    8:*/		return 0x820957D0;
		  /* 820957D0h */ case    9:  		/* cmpwi CR6, R10, 57 */
		/* 820957D0h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000039);
		/* 820957D0h case    9:*/		return 0x820957D4;
		  /* 820957D4h */ case   10:  		/* bc 4, CR6_GT, 12 */
		/* 820957D4h case   10:*/		if ( !regs.CR[6].gt ) { return 0x820957E0;  }
		/* 820957D4h case   10:*/		return 0x820957D8;
		  /* 820957D8h */ case   11:  		/* lwz R7, <#[R1 + 100]> */
		/* 820957D8h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000064) );
		/* 820957D8h case   11:*/		return 0x820957DC;
		  /* 820957DCh */ case   12:  		/* add R10, R10, R7 */
		/* 820957DCh case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 820957DCh case   12:*/		return 0x820957E0;
	}
	return 0x820957E0;
} // Block from 820957ACh-820957E0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820957E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820957E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820957E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820957E0);
		  /* 820957E0h */ case    0:  		/* extsb R10, R10 */
		/* 820957E0h case    0:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 820957E0h case    0:*/		return 0x820957E4;
		  /* 820957E4h */ case    1:  		/* stb R10, <#[R9]> */
		/* 820957E4h case    1:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 820957E4h case    1:*/		return 0x820957E8;
		  /* 820957E8h */ case    2:  		/* addi R9, R9, -1 */
		/* 820957E8h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 820957E8h case    2:*/		return 0x820957EC;
		  /* 820957ECh */ case    3:  		/* b -84 */
		/* 820957ECh case    3:*/		return 0x82095798;
		/* 820957ECh case    3:*/		return 0x820957F0;
	}
	return 0x820957F0;
} // Block from 820957E0h-820957F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820957F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820957F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820957F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820957F0);
		  /* 820957F0h */ case    0:  		/* addi R11, R1, 639 */
		/* 820957F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x27F);
		/* 820957F0h case    0:*/		return 0x820957F4;
		  /* 820957F4h */ case    1:  		/* rlwinm. R10, R25, 0, 22, 22 */
		/* 820957F4h case    1:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R10,regs.R25);
		/* 820957F4h case    1:*/		return 0x820957F8;
		  /* 820957F8h */ case    2:  		/* subf R26, R9, R11 */
		/* 820957F8h case    2:*/		cpu::op::subf<0>(regs,&regs.R26,regs.R9,regs.R11);
		/* 820957F8h case    2:*/		return 0x820957FC;
		  /* 820957FCh */ case    3:  		/* addi R27, R9, 1 */
		/* 820957FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R9,0x1);
		/* 820957FCh case    3:*/		return 0x82095800;
		  /* 82095800h */ case    4:  		/* bc 12, CR0_EQ, 36 */
		/* 82095800h case    4:*/		if ( regs.CR[0].eq ) { return 0x82095824;  }
		/* 82095800h case    4:*/		return 0x82095804;
		  /* 82095804h */ case    5:  		/* cmpwi CR6, R26, 0 */
		/* 82095804h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 82095804h case    5:*/		return 0x82095808;
		  /* 82095808h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 82095808h case    6:*/		if ( regs.CR[6].eq ) { return 0x82095818;  }
		/* 82095808h case    6:*/		return 0x8209580C;
		  /* 8209580Ch */ case    7:  		/* lbz R11, <#[R27]> */
		/* 8209580Ch case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8209580Ch case    7:*/		return 0x82095810;
		  /* 82095810h */ case    8:  		/* cmplwi CR6, R11, 48 */
		/* 82095810h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 82095810h case    8:*/		return 0x82095814;
		  /* 82095814h */ case    9:  		/* bc 12, CR6_EQ, 16 */
		/* 82095814h case    9:*/		if ( regs.CR[6].eq ) { return 0x82095824;  }
		/* 82095814h case    9:*/		return 0x82095818;
	}
	return 0x82095818;
} // Block from 820957F0h-82095818h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82095818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095818);
		  /* 82095818h */ case    0:  		/* li R11, 48 */
		/* 82095818h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x30);
		/* 82095818h case    0:*/		return 0x8209581C;
		  /* 8209581Ch */ case    1:  		/* addi R26, R26, 1 */
		/* 8209581Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 8209581Ch case    1:*/		return 0x82095820;
		  /* 82095820h */ case    2:  		/* stbu R11, <#[R27 - 1]> */
		/* 82095820h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R27 + 0xFFFFFFFF) );
		regs.R27 = (uint32)(regs.R27 + 0xFFFFFFFF);
		/* 82095820h case    2:*/		return 0x82095824;
	}
	return 0x82095824;
} // Block from 82095818h-82095824h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82095824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095824);
		  /* 82095824h */ case    0:  		/* lwz R11, <#[R1 + 96]> */
		/* 82095824h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82095824h case    0:*/		return 0x82095828;
		  /* 82095828h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82095828h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82095828h case    1:*/		return 0x8209582C;
		  /* 8209582Ch */ case    2:  		/* bc 4, CR6_EQ, 416 */
		/* 8209582Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820959CC;  }
		/* 8209582Ch case    2:*/		return 0x82095830;
		  /* 82095830h */ case    3:  		/* rlwinm. R11, R25, 0, 25, 25 */
		/* 82095830h case    3:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R25);
		/* 82095830h case    3:*/		return 0x82095834;
		  /* 82095834h */ case    4:  		/* bc 12, CR0_EQ, 56 */
		/* 82095834h case    4:*/		if ( regs.CR[0].eq ) { return 0x8209586C;  }
		/* 82095834h case    4:*/		return 0x82095838;
		  /* 82095838h */ case    5:  		/* rlwinm. R11, R25, 0, 23, 23 */
		/* 82095838h case    5:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R25);
		/* 82095838h case    5:*/		return 0x8209583C;
		  /* 8209583Ch */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 8209583Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x82095848;  }
		/* 8209583Ch case    6:*/		return 0x82095840;
		  /* 82095840h */ case    7:  		/* li R11, 45 */
		/* 82095840h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x2D);
		/* 82095840h case    7:*/		return 0x82095844;
		  /* 82095844h */ case    8:  		/* b 32 */
		/* 82095844h case    8:*/		return 0x82095864;
		/* 82095844h case    8:*/		return 0x82095848;
	}
	return 0x82095848;
} // Block from 82095824h-82095848h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82095848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095848);
		  /* 82095848h */ case    0:  		/* rlwinm. R11, R25, 0, 31, 31 */
		/* 82095848h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R25);
		/* 82095848h case    0:*/		return 0x8209584C;
		  /* 8209584Ch */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8209584Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82095858;  }
		/* 8209584Ch case    1:*/		return 0x82095850;
		  /* 82095850h */ case    2:  		/* li R11, 43 */
		/* 82095850h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x2B);
		/* 82095850h case    2:*/		return 0x82095854;
		  /* 82095854h */ case    3:  		/* b 16 */
		/* 82095854h case    3:*/		return 0x82095864;
		/* 82095854h case    3:*/		return 0x82095858;
	}
	return 0x82095858;
} // Block from 82095848h-82095858h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82095858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095858);
		  /* 82095858h */ case    0:  		/* rlwinm. R11, R25, 0, 30, 30 */
		/* 82095858h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R25);
		/* 82095858h case    0:*/		return 0x8209585C;
		  /* 8209585Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8209585Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8209586C;  }
		/* 8209585Ch case    1:*/		return 0x82095860;
		  /* 82095860h */ case    2:  		/* li R11, 32 */
		/* 82095860h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x20);
		/* 82095860h case    2:*/		return 0x82095864;
	}
	return 0x82095864;
} // Block from 82095858h-82095864h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82095864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095864);
		  /* 82095864h */ case    0:  		/* li R15, 1 */
		/* 82095864h case    0:*/		cpu::op::li<0>(regs,&regs.R15,0x1);
		/* 82095864h case    0:*/		return 0x82095868;
		  /* 82095868h */ case    1:  		/* sth R11, <#[R1 + 88]> */
		/* 82095868h case    1:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82095868h case    1:*/		return 0x8209586C;
	}
	return 0x8209586C;
} // Block from 82095864h-8209586Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209586Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209586C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209586C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209586C);
		  /* 8209586Ch */ case    0:  		/* subf R11, R26, R14 */
		/* 8209586Ch case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R26,regs.R14);
		/* 8209586Ch case    0:*/		return 0x82095870;
		  /* 82095870h */ case    1:  		/* rlwinm. R10, R25, 0, 28, 29 */
		/* 82095870h case    1:*/		cpu::op::rlwinm<1,0,28,29>(regs,&regs.R10,regs.R25);
		/* 82095870h case    1:*/		return 0x82095874;
		  /* 82095874h */ case    2:  		/* subf R28, R15, R11 */
		/* 82095874h case    2:*/		cpu::op::subf<0>(regs,&regs.R28,regs.R15,regs.R11);
		/* 82095874h case    2:*/		return 0x82095878;
		  /* 82095878h */ case    3:  		/* bc 4, CR0_EQ, 56 */
		/* 82095878h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820958B0;  }
		/* 82095878h case    3:*/		return 0x8209587C;
		  /* 8209587Ch */ case    4:  		/* mr R31, R28 */
		/* 8209587Ch case    4:*/		regs.R31 = regs.R28;
		/* 8209587Ch case    4:*/		return 0x82095880;
		  /* 82095880h */ case    5:  		/* cmpwi CR6, R28, 0 */
		/* 82095880h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 82095880h case    5:*/		return 0x82095884;
		  /* 82095884h */ case    6:  		/* bc 4, CR6_GT, 44 */
		/* 82095884h case    6:*/		if ( !regs.CR[6].gt ) { return 0x820958B0;  }
		/* 82095884h case    6:*/		return 0x82095888;
		  /* 82095888h */ case    7:  		/* addi R5, R1, 80 */
		/* 82095888h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82095888h case    7:*/		return 0x8209588C;
		  /* 8209588Ch */ case    8:  		/* mr R4, R16 */
		/* 8209588Ch case    8:*/		regs.R4 = regs.R16;
		/* 8209588Ch case    8:*/		return 0x82095890;
		  /* 82095890h */ case    9:  		/* li R3, 32 */
		/* 82095890h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x20);
		/* 82095890h case    9:*/		return 0x82095894;
		  /* 82095894h */ case   10:  		/* addi R31, R31, -1 */
		/* 82095894h case   10:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82095894h case   10:*/		return 0x82095898;
		  /* 82095898h */ case   11:  		/* bl 432 */
		/* 82095898h case   11:*/		regs.LR = 0x8209589C; return 0x82095A48;
		/* 82095898h case   11:*/		return 0x8209589C;
		  /* 8209589Ch */ case   12:  		/* lwz R11, <#[R1 + 80]> */
		/* 8209589Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8209589Ch case   12:*/		return 0x820958A0;
		  /* 820958A0h */ case   13:  		/* cmpwi CR6, R11, -1 */
		/* 820958A0h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820958A0h case   13:*/		return 0x820958A4;
		  /* 820958A4h */ case   14:  		/* bc 12, CR6_EQ, 12 */
		/* 820958A4h case   14:*/		if ( regs.CR[6].eq ) { return 0x820958B0;  }
		/* 820958A4h case   14:*/		return 0x820958A8;
		  /* 820958A8h */ case   15:  		/* cmpwi CR6, R31, 0 */
		/* 820958A8h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 820958A8h case   15:*/		return 0x820958AC;
		  /* 820958ACh */ case   16:  		/* bc 12, CR6_GT, -36 */
		/* 820958ACh case   16:*/		if ( regs.CR[6].gt ) { return 0x82095888;  }
		/* 820958ACh case   16:*/		return 0x820958B0;
	}
	return 0x820958B0;
} // Block from 8209586Ch-820958B0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820958B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820958B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820958B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820958B0);
		  /* 820958B0h */ case    0:  		/* addi R6, R1, 80 */
		/* 820958B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 820958B0h case    0:*/		return 0x820958B4;
		  /* 820958B4h */ case    1:  		/* mr R5, R16 */
		/* 820958B4h case    1:*/		regs.R5 = regs.R16;
		/* 820958B4h case    1:*/		return 0x820958B8;
		  /* 820958B8h */ case    2:  		/* mr R4, R15 */
		/* 820958B8h case    2:*/		regs.R4 = regs.R15;
		/* 820958B8h case    2:*/		return 0x820958BC;
		  /* 820958BCh */ case    3:  		/* addi R3, R1, 88 */
		/* 820958BCh case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 820958BCh case    3:*/		return 0x820958C0;
		  /* 820958C0h */ case    4:  		/* bl 496 */
		/* 820958C0h case    4:*/		regs.LR = 0x820958C4; return 0x82095AB0;
		/* 820958C0h case    4:*/		return 0x820958C4;
		  /* 820958C4h */ case    5:  		/* rlwinm. R11, R25, 0, 28, 28 */
		/* 820958C4h case    5:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R25);
		/* 820958C4h case    5:*/		return 0x820958C8;
		  /* 820958C8h */ case    6:  		/* bc 12, CR0_EQ, 64 */
		/* 820958C8h case    6:*/		if ( regs.CR[0].eq ) { return 0x82095908;  }
		/* 820958C8h case    6:*/		return 0x820958CC;
		  /* 820958CCh */ case    7:  		/* rlwinm. R11, R25, 0, 29, 29 */
		/* 820958CCh case    7:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R25);
		/* 820958CCh case    7:*/		return 0x820958D0;
		  /* 820958D0h */ case    8:  		/* bc 4, CR0_EQ, 56 */
		/* 820958D0h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82095908;  }
		/* 820958D0h case    8:*/		return 0x820958D4;
		  /* 820958D4h */ case    9:  		/* mr R31, R28 */
		/* 820958D4h case    9:*/		regs.R31 = regs.R28;
		/* 820958D4h case    9:*/		return 0x820958D8;
		  /* 820958D8h */ case   10:  		/* cmpwi CR6, R28, 0 */
		/* 820958D8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 820958D8h case   10:*/		return 0x820958DC;
		  /* 820958DCh */ case   11:  		/* bc 4, CR6_GT, 44 */
		/* 820958DCh case   11:*/		if ( !regs.CR[6].gt ) { return 0x82095908;  }
		/* 820958DCh case   11:*/		return 0x820958E0;
		  /* 820958E0h */ case   12:  		/* addi R5, R1, 80 */
		/* 820958E0h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820958E0h case   12:*/		return 0x820958E4;
		  /* 820958E4h */ case   13:  		/* mr R4, R16 */
		/* 820958E4h case   13:*/		regs.R4 = regs.R16;
		/* 820958E4h case   13:*/		return 0x820958E8;
		  /* 820958E8h */ case   14:  		/* li R3, 48 */
		/* 820958E8h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x30);
		/* 820958E8h case   14:*/		return 0x820958EC;
		  /* 820958ECh */ case   15:  		/* addi R31, R31, -1 */
		/* 820958ECh case   15:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 820958ECh case   15:*/		return 0x820958F0;
		  /* 820958F0h */ case   16:  		/* bl 344 */
		/* 820958F0h case   16:*/		regs.LR = 0x820958F4; return 0x82095A48;
		/* 820958F0h case   16:*/		return 0x820958F4;
		  /* 820958F4h */ case   17:  		/* lwz R11, <#[R1 + 80]> */
		/* 820958F4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820958F4h case   17:*/		return 0x820958F8;
		  /* 820958F8h */ case   18:  		/* cmpwi CR6, R11, -1 */
		/* 820958F8h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820958F8h case   18:*/		return 0x820958FC;
		  /* 820958FCh */ case   19:  		/* bc 12, CR6_EQ, 12 */
		/* 820958FCh case   19:*/		if ( regs.CR[6].eq ) { return 0x82095908;  }
		/* 820958FCh case   19:*/		return 0x82095900;
		  /* 82095900h */ case   20:  		/* cmpwi CR6, R31, 0 */
		/* 82095900h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82095900h case   20:*/		return 0x82095904;
		  /* 82095904h */ case   21:  		/* bc 12, CR6_GT, -36 */
		/* 82095904h case   21:*/		if ( regs.CR[6].gt ) { return 0x820958E0;  }
		/* 82095904h case   21:*/		return 0x82095908;
	}
	return 0x82095908;
} // Block from 820958B0h-82095908h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82095908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095908);
		  /* 82095908h */ case    0:  		/* cmpwi CR6, R20, 0 */
		/* 82095908h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 82095908h case    0:*/		return 0x8209590C;
		  /* 8209590Ch */ case    1:  		/* bc 4, CR6_EQ, 100 */
		/* 8209590Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82095970;  }
		/* 8209590Ch case    1:*/		return 0x82095910;
		  /* 82095910h */ case    2:  		/* cmpwi CR6, R26, 0 */
		/* 82095910h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 82095910h case    2:*/		return 0x82095914;
		  /* 82095914h */ case    3:  		/* bc 4, CR6_GT, 92 */
		/* 82095914h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82095970;  }
		/* 82095914h case    3:*/		return 0x82095918;
		  /* 82095918h */ case    4:  		/* mr R30, R27 */
		/* 82095918h case    4:*/		regs.R30 = regs.R27;
		/* 82095918h case    4:*/		return 0x8209591C;
		  /* 8209591Ch */ case    5:  		/* mr R31, R26 */
		/* 8209591Ch case    5:*/		regs.R31 = regs.R26;
		/* 8209591Ch case    5:*/		return 0x82095920;
		  /* 82095920h */ case    6:  		/* lwz R11, <#[R22]> */
		/* 82095920h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 82095920h case    6:*/		return 0x82095924;
		  /* 82095924h */ case    7:  		/* mr R6, R22 */
		/* 82095924h case    7:*/		regs.R6 = regs.R22;
		/* 82095924h case    7:*/		return 0x82095928;
		  /* 82095928h */ case    8:  		/* mr R4, R30 */
		/* 82095928h case    8:*/		regs.R4 = regs.R30;
		/* 82095928h case    8:*/		return 0x8209592C;
		  /* 8209592Ch */ case    9:  		/* addi R3, R1, 92 */
		/* 8209592Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x5C);
		/* 8209592Ch case    9:*/		return 0x82095930;
		  /* 82095930h */ case   10:  		/* addi R31, R31, -1 */
		/* 82095930h case   10:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82095930h case   10:*/		return 0x82095934;
		  /* 82095934h */ case   11:  		/* lwz R5, <#[R11 + 172]> */
		/* 82095934h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x000000AC) );
		/* 82095934h case   11:*/		return 0x82095938;
		  /* 82095938h */ case   12:  		/* bl 21856 */
		/* 82095938h case   12:*/		regs.LR = 0x8209593C; return 0x8209AE98;
		/* 82095938h case   12:*/		return 0x8209593C;
		  /* 8209593Ch */ case   13:  		/* or. R29, R3, R3 */
		/* 8209593Ch case   13:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 8209593Ch case   13:*/		return 0x82095940;
		  /* 82095940h */ case   14:  		/* bc 4, CR0_GT, 36 */
		/* 82095940h case   14:*/		if ( !regs.CR[0].gt ) { return 0x82095964;  }
		/* 82095940h case   14:*/		return 0x82095944;
		  /* 82095944h */ case   15:  		/* addi R5, R1, 80 */
		/* 82095944h case   15:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82095944h case   15:*/		return 0x82095948;
		  /* 82095948h */ case   16:  		/* lhz R3, <#[R1 + 92]> */
		/* 82095948h case   16:*/		cpu::mem::load16z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000005C) );
		/* 82095948h case   16:*/		return 0x8209594C;
		  /* 8209594Ch */ case   17:  		/* mr R4, R16 */
		/* 8209594Ch case   17:*/		regs.R4 = regs.R16;
		/* 8209594Ch case   17:*/		return 0x82095950;
		  /* 82095950h */ case   18:  		/* bl 248 */
		/* 82095950h case   18:*/		regs.LR = 0x82095954; return 0x82095A48;
		/* 82095950h case   18:*/		return 0x82095954;
		  /* 82095954h */ case   19:  		/* add R30, R29, R30 */
		/* 82095954h case   19:*/		cpu::op::add<0>(regs,&regs.R30,regs.R29,regs.R30);
		/* 82095954h case   19:*/		return 0x82095958;
		  /* 82095958h */ case   20:  		/* cmpwi CR6, R31, 0 */
		/* 82095958h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82095958h case   20:*/		return 0x8209595C;
		  /* 8209595Ch */ case   21:  		/* bc 12, CR6_GT, -60 */
		/* 8209595Ch case   21:*/		if ( regs.CR[6].gt ) { return 0x82095920;  }
		/* 8209595Ch case   21:*/		return 0x82095960;
		  /* 82095960h */ case   22:  		/* b 36 */
		/* 82095960h case   22:*/		return 0x82095984;
		/* 82095960h case   22:*/		return 0x82095964;
	}
	return 0x82095964;
} // Block from 82095908h-82095964h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82095964h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095964( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095964) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095964);
		  /* 82095964h */ case    0:  		/* li R21, -1 */
		/* 82095964h case    0:*/		cpu::op::li<0>(regs,&regs.R21,0xFFFFFFFF);
		/* 82095964h case    0:*/		return 0x82095968;
		  /* 82095968h */ case    1:  		/* stw R21, <#[R1 + 80]> */
		/* 82095968h case    1:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000050) );
		/* 82095968h case    1:*/		return 0x8209596C;
		  /* 8209596Ch */ case    2:  		/* b 28 */
		/* 8209596Ch case    2:*/		return 0x82095988;
		/* 8209596Ch case    2:*/		return 0x82095970;
	}
	return 0x82095970;
} // Block from 82095964h-82095970h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82095970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095970);
		  /* 82095970h */ case    0:  		/* addi R6, R1, 80 */
		/* 82095970h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 82095970h case    0:*/		return 0x82095974;
		  /* 82095974h */ case    1:  		/* mr R5, R16 */
		/* 82095974h case    1:*/		regs.R5 = regs.R16;
		/* 82095974h case    1:*/		return 0x82095978;
		  /* 82095978h */ case    2:  		/* mr R4, R26 */
		/* 82095978h case    2:*/		regs.R4 = regs.R26;
		/* 82095978h case    2:*/		return 0x8209597C;
		  /* 8209597Ch */ case    3:  		/* mr R3, R27 */
		/* 8209597Ch case    3:*/		regs.R3 = regs.R27;
		/* 8209597Ch case    3:*/		return 0x82095980;
		  /* 82095980h */ case    4:  		/* bl 304 */
		/* 82095980h case    4:*/		regs.LR = 0x82095984; return 0x82095AB0;
		/* 82095980h case    4:*/		return 0x82095984;
	}
	return 0x82095984;
} // Block from 82095970h-82095984h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82095984h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095984( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095984) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095984);
		  /* 82095984h */ case    0:  		/* lwz R21, <#[R1 + 80]> */
		/* 82095984h case    0:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000050) );
		/* 82095984h case    0:*/		return 0x82095988;
	}
	return 0x82095988;
} // Block from 82095984h-82095988h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82095988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095988);
		  /* 82095988h */ case    0:  		/* cmpwi CR6, R21, 0 */
		/* 82095988h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 82095988h case    0:*/		return 0x8209598C;
		  /* 8209598Ch */ case    1:  		/* bc 12, CR6_LT, 64 */
		/* 8209598Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x820959CC;  }
		/* 8209598Ch case    1:*/		return 0x82095990;
		  /* 82095990h */ case    2:  		/* rlwinm. R11, R25, 0, 29, 29 */
		/* 82095990h case    2:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R25);
		/* 82095990h case    2:*/		return 0x82095994;
		  /* 82095994h */ case    3:  		/* bc 12, CR0_EQ, 56 */
		/* 82095994h case    3:*/		if ( regs.CR[0].eq ) { return 0x820959CC;  }
		/* 82095994h case    3:*/		return 0x82095998;
		  /* 82095998h */ case    4:  		/* mr R31, R28 */
		/* 82095998h case    4:*/		regs.R31 = regs.R28;
		/* 82095998h case    4:*/		return 0x8209599C;
		  /* 8209599Ch */ case    5:  		/* cmpwi CR6, R28, 0 */
		/* 8209599Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 8209599Ch case    5:*/		return 0x820959A0;
		  /* 820959A0h */ case    6:  		/* bc 4, CR6_GT, 44 */
		/* 820959A0h case    6:*/		if ( !regs.CR[6].gt ) { return 0x820959CC;  }
		/* 820959A0h case    6:*/		return 0x820959A4;
		  /* 820959A4h */ case    7:  		/* addi R5, R1, 80 */
		/* 820959A4h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820959A4h case    7:*/		return 0x820959A8;
		  /* 820959A8h */ case    8:  		/* mr R4, R16 */
		/* 820959A8h case    8:*/		regs.R4 = regs.R16;
		/* 820959A8h case    8:*/		return 0x820959AC;
		  /* 820959ACh */ case    9:  		/* li R3, 32 */
		/* 820959ACh case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x20);
		/* 820959ACh case    9:*/		return 0x820959B0;
		  /* 820959B0h */ case   10:  		/* addi R31, R31, -1 */
		/* 820959B0h case   10:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 820959B0h case   10:*/		return 0x820959B4;
		  /* 820959B4h */ case   11:  		/* bl 148 */
		/* 820959B4h case   11:*/		regs.LR = 0x820959B8; return 0x82095A48;
		/* 820959B4h case   11:*/		return 0x820959B8;
		  /* 820959B8h */ case   12:  		/* lwz R21, <#[R1 + 80]> */
		/* 820959B8h case   12:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000050) );
		/* 820959B8h case   12:*/		return 0x820959BC;
		  /* 820959BCh */ case   13:  		/* cmpwi CR6, R21, -1 */
		/* 820959BCh case   13:*/		cpu::op::cmpwi<6>(regs,regs.R21,0xFFFFFFFF);
		/* 820959BCh case   13:*/		return 0x820959C0;
		  /* 820959C0h */ case   14:  		/* bc 12, CR6_EQ, 12 */
		/* 820959C0h case   14:*/		if ( regs.CR[6].eq ) { return 0x820959CC;  }
		/* 820959C0h case   14:*/		return 0x820959C4;
		  /* 820959C4h */ case   15:  		/* cmpwi CR6, R31, 0 */
		/* 820959C4h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 820959C4h case   15:*/		return 0x820959C8;
		  /* 820959C8h */ case   16:  		/* bc 12, CR6_GT, -36 */
		/* 820959C8h case   16:*/		if ( regs.CR[6].gt ) { return 0x820959A4;  }
		/* 820959C8h case   16:*/		return 0x820959CC;
	}
	return 0x820959CC;
} // Block from 82095988h-820959CCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 820959CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820959CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820959CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820959CC);
		  /* 820959CCh */ case    0:  		/* lwz R3, <#[R1 + 112]> */
		/* 820959CCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000070) );
		/* 820959CCh case    0:*/		return 0x820959D0;
		  /* 820959D0h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820959D0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820959D0h case    1:*/		return 0x820959D4;
		  /* 820959D4h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 820959D4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820959E4;  }
		/* 820959D4h case    2:*/		return 0x820959D8;
		  /* 820959D8h */ case    3:  		/* bl -8624 */
		/* 820959D8h case    3:*/		regs.LR = 0x820959DC; return 0x82093828;
		/* 820959D8h case    3:*/		return 0x820959DC;
		  /* 820959DCh */ case    4:  		/* li R11, 0 */
		/* 820959DCh case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820959DCh case    4:*/		return 0x820959E0;
		  /* 820959E0h */ case    5:  		/* stw R11, <#[R1 + 112]> */
		/* 820959E0h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820959E0h case    5:*/		return 0x820959E4;
	}
	return 0x820959E4;
} // Block from 820959CCh-820959E4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820959E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820959E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820959E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820959E4);
		  /* 820959E4h */ case    0:  		/* lhz R29, <#[R17]> */
		/* 820959E4h case    0:*/		cpu::mem::load16z( regs, &regs.R29, (uint32)(regs.R17 + 0x00000000) );
		/* 820959E4h case    0:*/		return 0x820959E8;
		  /* 820959E8h */ case    1:  		/* or. R8, R29, R29 */
		/* 820959E8h case    1:*/		cpu::op::or<1>(regs,&regs.R8,regs.R29,regs.R29);
		/* 820959E8h case    1:*/		return 0x820959EC;
		  /* 820959ECh */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 820959ECh case    2:*/		if ( regs.CR[0].eq ) { return 0x82095A00;  }
		/* 820959ECh case    2:*/		return 0x820959F0;
		  /* 820959F0h */ case    3:  		/* lwz R7, <#[R1 + 108]> */
		/* 820959F0h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x0000006C) );
		/* 820959F0h case    3:*/		return 0x820959F4;
		  /* 820959F4h */ case    4:  		/* li R30, 0 */
		/* 820959F4h case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820959F4h case    4:*/		return 0x820959F8;
		  /* 820959F8h */ case    5:  		/* lwz R10, <#[R1 + 104]> */
		/* 820959F8h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000068) );
		/* 820959F8h case    5:*/		return 0x820959FC;
		  /* 820959FCh */ case    6:  		/* b -2384 */
		/* 820959FCh case    6:*/		return 0x820950AC;
		/* 820959FCh case    6:*/		return 0x82095A00;
	}
	return 0x82095A00;
} // Block from 820959E4h-82095A00h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82095A00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095A00);
		  /* 82095A00h */ case    0:  		/* mr R3, R21 */
		/* 82095A00h case    0:*/		regs.R3 = regs.R21;
		/* 82095A00h case    0:*/		return 0x82095A04;
		  /* 82095A04h */ case    1:  		/* b 56 */
		/* 82095A04h case    1:*/		return 0x82095A3C;
		/* 82095A04h case    1:*/		return 0x82095A08;
	}
	return 0x82095A08;
} // Block from 82095A00h-82095A08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82095A08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095A08);
		  /* 82095A08h */ case    0:  		/* mr R6, R24 */
		/* 82095A08h case    0:*/		regs.R6 = regs.R24;
		/* 82095A08h case    0:*/		return 0x82095A0C;
		  /* 82095A0Ch */ case    1:  		/* mr R5, R17 */
		/* 82095A0Ch case    1:*/		regs.R5 = regs.R17;
		/* 82095A0Ch case    1:*/		return 0x82095A10;
		  /* 82095A10h */ case    2:  		/* li R4, 512 */
		/* 82095A10h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x200);
		/* 82095A10h case    2:*/		return 0x82095A14;
		  /* 82095A14h */ case    3:  		/* addi R3, R1, 1152 */
		/* 82095A14h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x480);
		/* 82095A14h case    3:*/		return 0x82095A18;
		  /* 82095A18h */ case    4:  		/* bl 21288 */
		/* 82095A18h case    4:*/		regs.LR = 0x82095A1C; return 0x8209AD40;
		/* 82095A18h case    4:*/		return 0x82095A1C;
		  /* 82095A1Ch */ case    5:  		/* mr R31, R3 */
		/* 82095A1Ch case    5:*/		regs.R31 = regs.R3;
		/* 82095A1Ch case    5:*/		return 0x82095A20;
		  /* 82095A20h */ case    6:  		/* cmpwi CR6, R3, -1 */
		/* 82095A20h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82095A20h case    6:*/		return 0x82095A24;
		  /* 82095A24h */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 82095A24h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82095A30;  }
		/* 82095A24h case    7:*/		return 0x82095A28;
		  /* 82095A28h */ case    8:  		/* li R31, 511 */
		/* 82095A28h case    8:*/		cpu::op::li<0>(regs,&regs.R31,0x1FF);
		/* 82095A28h case    8:*/		return 0x82095A2C;
		  /* 82095A2Ch */ case    9:  		/* sth R30, <#[R1 + 2174]> */
		/* 82095A2Ch case    9:*/		cpu::mem::store16( regs, regs.R30, (uint32)(regs.R1 + 0x0000087E) );
		/* 82095A2Ch case    9:*/		return 0x82095A30;
	}
	return 0x82095A30;
} // Block from 82095A08h-82095A30h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82095A30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095A30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095A30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095A30);
		  /* 82095A30h */ case    0:  		/* addi R3, R1, 1152 */
		/* 82095A30h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x480);
		/* 82095A30h case    0:*/		return 0x82095A34;
		  /* 82095A34h */ case    1:  		/* bl 1907204 */
		/* 82095A34h case    1:*/		regs.LR = 0x82095A38; return 0x82267438;
		/* 82095A34h case    1:*/		return 0x82095A38;
		  /* 82095A38h */ case    2:  		/* mr R3, R31 */
		/* 82095A38h case    2:*/		regs.R3 = regs.R31;
		/* 82095A38h case    2:*/		return 0x82095A3C;
	}
	return 0x82095A3C;
} // Block from 82095A30h-82095A3Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82095A3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095A3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095A3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095A3C);
		  /* 82095A3Ch */ case    0:  		/* addi R1, R1, 2336 */
		/* 82095A3Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x920);
		/* 82095A3Ch case    0:*/		return 0x82095A40;
		  /* 82095A40h */ case    1:  		/* b -18384 */
		/* 82095A40h case    1:*/		return 0x82091270;
		/* 82095A40h case    1:*/		return 0x82095A44;
		  /* 82095A44h */ case    2:  		/* nop */
		/* 82095A44h case    2:*/		cpu::op::nop();
		/* 82095A44h case    2:*/		return 0x82095A48;
	}
	return 0x82095A48;
} // Block from 82095A3Ch-82095A48h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82095A48h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095A48);
		  /* 82095A48h */ case    0:  		/* mfspr R12, LR */
		/* 82095A48h case    0:*/		regs.R12 = regs.LR;
		/* 82095A48h case    0:*/		return 0x82095A4C;
		  /* 82095A4Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82095A4Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82095A4Ch case    1:*/		return 0x82095A50;
		  /* 82095A50h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82095A50h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82095A50h case    2:*/		return 0x82095A54;
		  /* 82095A54h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82095A54h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82095A54h case    3:*/		return 0x82095A58;
		  /* 82095A58h */ case    4:  		/* lwz R11, <#[R4 + 12]> */
		/* 82095A58h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 82095A58h case    4:*/		return 0x82095A5C;
		  /* 82095A5Ch */ case    5:  		/* mr R31, R5 */
		/* 82095A5Ch case    5:*/		regs.R31 = regs.R5;
		/* 82095A5Ch case    5:*/		return 0x82095A60;
		  /* 82095A60h */ case    6:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 82095A60h case    6:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 82095A60h case    6:*/		return 0x82095A64;
		  /* 82095A64h */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 82095A64h case    7:*/		if ( regs.CR[0].eq ) { return 0x82095A74;  }
		/* 82095A64h case    7:*/		return 0x82095A68;
		  /* 82095A68h */ case    8:  		/* lwz R11, <#[R4 + 8]> */
		/* 82095A68h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 82095A68h case    8:*/		return 0x82095A6C;
		  /* 82095A6Ch */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 82095A6Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82095A6Ch case    9:*/		return 0x82095A70;
		  /* 82095A70h */ case   10:  		/* bc 12, CR6_EQ, 28 */
		/* 82095A70h case   10:*/		if ( regs.CR[6].eq ) { return 0x82095A8C;  }
		/* 82095A70h case   10:*/		return 0x82095A74;
	}
	return 0x82095A74;
} // Block from 82095A48h-82095A74h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82095A74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095A74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095A74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095A74);
		  /* 82095A74h */ case    0:  		/* bl 20300 */
		/* 82095A74h case    0:*/		regs.LR = 0x82095A78; return 0x8209A9C0;
		/* 82095A74h case    0:*/		return 0x82095A78;
		  /* 82095A78h */ case    1:  		/* rlwinm R11, R3, 0, 16, 31 */
		/* 82095A78h case    1:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R3);
		/* 82095A78h case    1:*/		return 0x82095A7C;
		  /* 82095A7Ch */ case    2:  		/* cmplwi CR6, R11, 65535 */
		/* 82095A7Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000FFFF);
		/* 82095A7Ch case    2:*/		return 0x82095A80;
		  /* 82095A80h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 82095A80h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82095A8C;  }
		/* 82095A80h case    3:*/		return 0x82095A84;
		  /* 82095A84h */ case    4:  		/* li R11, -1 */
		/* 82095A84h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 82095A84h case    4:*/		return 0x82095A88;
		  /* 82095A88h */ case    5:  		/* b 12 */
		/* 82095A88h case    5:*/		return 0x82095A94;
		/* 82095A88h case    5:*/		return 0x82095A8C;
	}
	return 0x82095A8C;
} // Block from 82095A74h-82095A8Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82095A8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095A8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095A8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095A8C);
		  /* 82095A8Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82095A8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82095A8Ch case    0:*/		return 0x82095A90;
		  /* 82095A90h */ case    1:  		/* addi R11, R11, 1 */
		/* 82095A90h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82095A90h case    1:*/		return 0x82095A94;
	}
	return 0x82095A94;
} // Block from 82095A8Ch-82095A94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82095A94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095A94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095A94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095A94);
		  /* 82095A94h */ case    0:  		/* stw R11, <#[R31]> */
		/* 82095A94h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82095A94h case    0:*/		return 0x82095A98;
		  /* 82095A98h */ case    1:  		/* addi R1, R1, 96 */
		/* 82095A98h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82095A98h case    1:*/		return 0x82095A9C;
		  /* 82095A9Ch */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82095A9Ch case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82095A9Ch case    2:*/		return 0x82095AA0;
		  /* 82095AA0h */ case    3:  		/* mtspr LR, R12 */
		/* 82095AA0h case    3:*/		regs.LR = regs.R12;
		/* 82095AA0h case    3:*/		return 0x82095AA4;
		  /* 82095AA4h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82095AA4h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82095AA4h case    4:*/		return 0x82095AA8;
		  /* 82095AA8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82095AA8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82095AA8h case    5:*/		return 0x82095AAC;
	}
	return 0x82095AAC;
} // Block from 82095A94h-82095AACh (6 instructions)

//////////////////////////////////////////////////////
// Block at 82095AACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095AAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095AAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095AAC);
		  /* 82095AACh */ case    0:  		/* nop */
		/* 82095AACh case    0:*/		cpu::op::nop();
		/* 82095AACh case    0:*/		return 0x82095AB0;
	}
	return 0x82095AB0;
} // Block from 82095AACh-82095AB0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82095AB0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095AB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095AB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095AB0);
		  /* 82095AB0h */ case    0:  		/* mfspr R12, LR */
		/* 82095AB0h case    0:*/		regs.R12 = regs.LR;
		/* 82095AB0h case    0:*/		return 0x82095AB4;
		  /* 82095AB4h */ case    1:  		/* bl -18528 */
		/* 82095AB4h case    1:*/		regs.LR = 0x82095AB8; return 0x82091254;
		/* 82095AB4h case    1:*/		return 0x82095AB8;
		  /* 82095AB8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82095AB8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82095AB8h case    2:*/		return 0x82095ABC;
		  /* 82095ABCh */ case    3:  		/* mr R28, R3 */
		/* 82095ABCh case    3:*/		regs.R28 = regs.R3;
		/* 82095ABCh case    3:*/		return 0x82095AC0;
		  /* 82095AC0h */ case    4:  		/* mr R30, R4 */
		/* 82095AC0h case    4:*/		regs.R30 = regs.R4;
		/* 82095AC0h case    4:*/		return 0x82095AC4;
		  /* 82095AC4h */ case    5:  		/* mr R29, R5 */
		/* 82095AC4h case    5:*/		regs.R29 = regs.R5;
		/* 82095AC4h case    5:*/		return 0x82095AC8;
		  /* 82095AC8h */ case    6:  		/* mr R31, R6 */
		/* 82095AC8h case    6:*/		regs.R31 = regs.R6;
		/* 82095AC8h case    6:*/		return 0x82095ACC;
		  /* 82095ACCh */ case    7:  		/* bl -3012 */
		/* 82095ACCh case    7:*/		regs.LR = 0x82095AD0; return 0x82094F08;
		/* 82095ACCh case    7:*/		return 0x82095AD0;
		  /* 82095AD0h */ case    8:  		/* lwz R11, <#[R29 + 12]> */
		/* 82095AD0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 82095AD0h case    8:*/		return 0x82095AD4;
		  /* 82095AD4h */ case    9:  		/* lwz R27, <#[R3]> */
		/* 82095AD4h case    9:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 82095AD4h case    9:*/		return 0x82095AD8;
		  /* 82095AD8h */ case   10:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 82095AD8h case   10:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 82095AD8h case   10:*/		return 0x82095ADC;
		  /* 82095ADCh */ case   11:  		/* bc 12, CR0_EQ, 32 */
		/* 82095ADCh case   11:*/		if ( regs.CR[0].eq ) { return 0x82095AFC;  }
		/* 82095ADCh case   11:*/		return 0x82095AE0;
		  /* 82095AE0h */ case   12:  		/* lwz R11, <#[R29 + 8]> */
		/* 82095AE0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82095AE0h case   12:*/		return 0x82095AE4;
		  /* 82095AE4h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 82095AE4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82095AE4h case   13:*/		return 0x82095AE8;
		  /* 82095AE8h */ case   14:  		/* bc 4, CR6_EQ, 20 */
		/* 82095AE8h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82095AFC;  }
		/* 82095AE8h case   14:*/		return 0x82095AEC;
		  /* 82095AECh */ case   15:  		/* lwz R11, <#[R31]> */
		/* 82095AECh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82095AECh case   15:*/		return 0x82095AF0;
		  /* 82095AF0h */ case   16:  		/* add R11, R11, R30 */
		/* 82095AF0h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 82095AF0h case   16:*/		return 0x82095AF4;
		  /* 82095AF4h */ case   17:  		/* stw R11, <#[R31]> */
		/* 82095AF4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82095AF4h case   17:*/		return 0x82095AF8;
		  /* 82095AF8h */ case   18:  		/* b 124 */
		/* 82095AF8h case   18:*/		return 0x82095B74;
		/* 82095AF8h case   18:*/		return 0x82095AFC;
	}
	return 0x82095AFC;
} // Block from 82095AB0h-82095AFCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 82095AFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095AFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095AFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095AFC);
		  /* 82095AFCh */ case    0:  		/* bl -3060 */
		/* 82095AFCh case    0:*/		regs.LR = 0x82095B00; return 0x82094F08;
		/* 82095AFCh case    0:*/		return 0x82095B00;
		  /* 82095B00h */ case    1:  		/* li R11, 0 */
		/* 82095B00h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82095B00h case    1:*/		return 0x82095B04;
		  /* 82095B04h */ case    2:  		/* cmpwi CR6, R30, 0 */
		/* 82095B04h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82095B04h case    2:*/		return 0x82095B08;
		  /* 82095B08h */ case    3:  		/* stw R11, <#[R3]> */
		/* 82095B08h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82095B08h case    3:*/		return 0x82095B0C;
		  /* 82095B0Ch */ case    4:  		/* bc 4, CR6_GT, 80 */
		/* 82095B0Ch case    4:*/		if ( !regs.CR[6].gt ) { return 0x82095B5C;  }
		/* 82095B0Ch case    4:*/		return 0x82095B10;
		  /* 82095B10h */ case    5:  		/* addi R28, R28, -2 */
		/* 82095B10h case    5:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0xFFFFFFFE);
		/* 82095B10h case    5:*/		return 0x82095B14;
		  /* 82095B14h */ case    6:  		/* mr R5, R31 */
		/* 82095B14h case    6:*/		regs.R5 = regs.R31;
		/* 82095B14h case    6:*/		return 0x82095B18;
		  /* 82095B18h */ case    7:  		/* lhzu R3, <#[R28 + 2]> */
		/* 82095B18h case    7:*/		cpu::mem::load16z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000002) );
		regs.R28 = (uint32)(regs.R28 + 0x00000002);
		/* 82095B18h case    7:*/		return 0x82095B1C;
		  /* 82095B1Ch */ case    8:  		/* mr R4, R29 */
		/* 82095B1Ch case    8:*/		regs.R4 = regs.R29;
		/* 82095B1Ch case    8:*/		return 0x82095B20;
		  /* 82095B20h */ case    9:  		/* addi R30, R30, -1 */
		/* 82095B20h case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 82095B20h case    9:*/		return 0x82095B24;
		  /* 82095B24h */ case   10:  		/* bl -220 */
		/* 82095B24h case   10:*/		regs.LR = 0x82095B28; return 0x82095A48;
		/* 82095B24h case   10:*/		return 0x82095B28;
		  /* 82095B28h */ case   11:  		/* lwz R11, <#[R31]> */
		/* 82095B28h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82095B28h case   11:*/		return 0x82095B2C;
		  /* 82095B2Ch */ case   12:  		/* cmpwi CR6, R11, -1 */
		/* 82095B2Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82095B2Ch case   12:*/		return 0x82095B30;
		  /* 82095B30h */ case   13:  		/* bc 4, CR6_EQ, 36 */
		/* 82095B30h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82095B54;  }
		/* 82095B30h case   13:*/		return 0x82095B34;
		  /* 82095B34h */ case   14:  		/* bl -3116 */
		/* 82095B34h case   14:*/		regs.LR = 0x82095B38; return 0x82094F08;
		/* 82095B34h case   14:*/		return 0x82095B38;
		  /* 82095B38h */ case   15:  		/* lwz R11, <#[R3]> */
		/* 82095B38h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82095B38h case   15:*/		return 0x82095B3C;
		  /* 82095B3Ch */ case   16:  		/* cmpwi CR6, R11, 42 */
		/* 82095B3Ch case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002A);
		/* 82095B3Ch case   16:*/		return 0x82095B40;
		  /* 82095B40h */ case   17:  		/* bc 4, CR6_EQ, 28 */
		/* 82095B40h case   17:*/		if ( !regs.CR[6].eq ) { return 0x82095B5C;  }
		/* 82095B40h case   17:*/		return 0x82095B44;
		  /* 82095B44h */ case   18:  		/* mr R5, R31 */
		/* 82095B44h case   18:*/		regs.R5 = regs.R31;
		/* 82095B44h case   18:*/		return 0x82095B48;
		  /* 82095B48h */ case   19:  		/* mr R4, R29 */
		/* 82095B48h case   19:*/		regs.R4 = regs.R29;
		/* 82095B48h case   19:*/		return 0x82095B4C;
		  /* 82095B4Ch */ case   20:  		/* li R3, 63 */
		/* 82095B4Ch case   20:*/		cpu::op::li<0>(regs,&regs.R3,0x3F);
		/* 82095B4Ch case   20:*/		return 0x82095B50;
		  /* 82095B50h */ case   21:  		/* bl -264 */
		/* 82095B50h case   21:*/		regs.LR = 0x82095B54; return 0x82095A48;
		/* 82095B50h case   21:*/		return 0x82095B54;
	}
	return 0x82095B54;
} // Block from 82095AFCh-82095B54h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82095B54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095B54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095B54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095B54);
		  /* 82095B54h */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 82095B54h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82095B54h case    0:*/		return 0x82095B58;
		  /* 82095B58h */ case    1:  		/* bc 12, CR6_GT, -68 */
		/* 82095B58h case    1:*/		if ( regs.CR[6].gt ) { return 0x82095B14;  }
		/* 82095B58h case    1:*/		return 0x82095B5C;
	}
	return 0x82095B5C;
} // Block from 82095B54h-82095B5Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82095B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095B5C);
		  /* 82095B5Ch */ case    0:  		/* bl -3156 */
		/* 82095B5Ch case    0:*/		regs.LR = 0x82095B60; return 0x82094F08;
		/* 82095B5Ch case    0:*/		return 0x82095B60;
		  /* 82095B60h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 82095B60h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82095B60h case    1:*/		return 0x82095B64;
		  /* 82095B64h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 82095B64h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82095B64h case    2:*/		return 0x82095B68;
		  /* 82095B68h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 82095B68h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82095B74;  }
		/* 82095B68h case    3:*/		return 0x82095B6C;
		  /* 82095B6Ch */ case    4:  		/* bl -3172 */
		/* 82095B6Ch case    4:*/		regs.LR = 0x82095B70; return 0x82094F08;
		/* 82095B6Ch case    4:*/		return 0x82095B70;
		  /* 82095B70h */ case    5:  		/* stw R27, <#[R3]> */
		/* 82095B70h case    5:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 82095B70h case    5:*/		return 0x82095B74;
	}
	return 0x82095B74;
} // Block from 82095B5Ch-82095B74h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82095B74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095B74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095B74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095B74);
		  /* 82095B74h */ case    0:  		/* addi R1, R1, 128 */
		/* 82095B74h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82095B74h case    0:*/		return 0x82095B78;
		  /* 82095B78h */ case    1:  		/* b -18644 */
		/* 82095B78h case    1:*/		return 0x820912A4;
		/* 82095B78h case    1:*/		return 0x82095B7C;
		  /* 82095B7Ch */ case    2:  		/* nop */
		/* 82095B7Ch case    2:*/		cpu::op::nop();
		/* 82095B7Ch case    2:*/		return 0x82095B80;
	}
	return 0x82095B80;
} // Block from 82095B74h-82095B80h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82095B80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095B80);
		  /* 82095B80h */ case    0:  		/* mfspr R12, LR */
		/* 82095B80h case    0:*/		regs.R12 = regs.LR;
		/* 82095B80h case    0:*/		return 0x82095B84;
		  /* 82095B84h */ case    1:  		/* bl -18788 */
		/* 82095B84h case    1:*/		regs.LR = 0x82095B88; return 0x82091220;
		/* 82095B84h case    1:*/		return 0x82095B88;
		  /* 82095B88h */ case    2:  		/* stwu R1, <#[R1 - 2336]> */
		/* 82095B88h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFF6E0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFF6E0);
		/* 82095B88h case    2:*/		return 0x82095B8C;
		  /* 82095B8Ch */ case    3:  		/* li R30, 0 */
		/* 82095B8Ch case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82095B8Ch case    3:*/		return 0x82095B90;
		  /* 82095B90h */ case    4:  		/* mr R16, R3 */
		/* 82095B90h case    4:*/		regs.R16 = regs.R3;
		/* 82095B90h case    4:*/		return 0x82095B94;
		  /* 82095B94h */ case    5:  		/* mr R17, R4 */
		/* 82095B94h case    5:*/		regs.R17 = regs.R4;
		/* 82095B94h case    5:*/		return 0x82095B98;
		  /* 82095B98h */ case    6:  		/* stw R30, <#[R1 + 112]> */
		/* 82095B98h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000070) );
		/* 82095B98h case    6:*/		return 0x82095B9C;
		  /* 82095B9Ch */ case    7:  		/* mr R24, R6 */
		/* 82095B9Ch case    7:*/		regs.R24 = regs.R6;
		/* 82095B9Ch case    7:*/		return 0x82095BA0;
		  /* 82095BA0h */ case    8:  		/* stw R30, <#[R1 + 100]> */
		/* 82095BA0h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000064) );
		/* 82095BA0h case    8:*/		return 0x82095BA4;
		  /* 82095BA4h */ case    9:  		/* cmplwi CR6, R3, 0 */
		/* 82095BA4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82095BA4h case    9:*/		return 0x82095BA8;
		  /* 82095BA8h */ case   10:  		/* mr R25, R30 */
		/* 82095BA8h case   10:*/		regs.R25 = regs.R30;
		/* 82095BA8h case   10:*/		return 0x82095BAC;
		  /* 82095BACh */ case   11:  		/* mr R14, R30 */
		/* 82095BACh case   11:*/		regs.R14 = regs.R30;
		/* 82095BACh case   11:*/		return 0x82095BB0;
		  /* 82095BB0h */ case   12:  		/* mr R23, R30 */
		/* 82095BB0h case   12:*/		regs.R23 = regs.R30;
		/* 82095BB0h case   12:*/		return 0x82095BB4;
		  /* 82095BB4h */ case   13:  		/* mr R15, R30 */
		/* 82095BB4h case   13:*/		regs.R15 = regs.R30;
		/* 82095BB4h case   13:*/		return 0x82095BB8;
		  /* 82095BB8h */ case   14:  		/* mr R20, R30 */
		/* 82095BB8h case   14:*/		regs.R20 = regs.R30;
		/* 82095BB8h case   14:*/		return 0x82095BBC;
		  /* 82095BBCh */ case   15:  		/* bc 4, CR6_EQ, 28 */
		/* 82095BBCh case   15:*/		if ( !regs.CR[6].eq ) { return 0x82095BD8;  }
		/* 82095BBCh case   15:*/		return 0x82095BC0;
		  /* 82095BC0h */ case   16:  		/* bl -3256 */
		/* 82095BC0h case   16:*/		regs.LR = 0x82095BC4; return 0x82094F08;
		/* 82095BC0h case   16:*/		return 0x82095BC4;
		  /* 82095BC4h */ case   17:  		/* li R11, 22 */
		/* 82095BC4h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 82095BC4h case   17:*/		return 0x82095BC8;
		  /* 82095BC8h */ case   18:  		/* stw R11, <#[R3]> */
		/* 82095BC8h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82095BC8h case   18:*/		return 0x82095BCC;
		  /* 82095BCCh */ case   19:  		/* bl -8812 */
		/* 82095BCCh case   19:*/		regs.LR = 0x82095BD0; return 0x82093960;
		/* 82095BCCh case   19:*/		return 0x82095BD0;
		  /* 82095BD0h */ case   20:  		/* li R3, -1 */
		/* 82095BD0h case   20:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82095BD0h case   20:*/		return 0x82095BD4;
		  /* 82095BD4h */ case   21:  		/* b 2584 */
		/* 82095BD4h case   21:*/		return 0x820965EC;
		/* 82095BD4h case   21:*/		return 0x82095BD8;
	}
	return 0x82095BD8;
} // Block from 82095B80h-82095BD8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82095BD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095BD8);
		  /* 82095BD8h */ case    0:  		/* cmplwi CR6, R17, 0 */
		/* 82095BD8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 82095BD8h case    0:*/		return 0x82095BDC;
		  /* 82095BDCh */ case    1:  		/* bc 12, CR6_EQ, -28 */
		/* 82095BDCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82095BC0;  }
		/* 82095BDCh case    1:*/		return 0x82095BE0;
		  /* 82095BE0h */ case    2:  		/* bl 19200 */
		/* 82095BE0h case    2:*/		regs.LR = 0x82095BE4; return 0x8209A6E0;
		/* 82095BE0h case    2:*/		return 0x82095BE4;
		  /* 82095BE4h */ case    3:  		/* addi R11, R3, 32 */
		/* 82095BE4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x20);
		/* 82095BE4h case    3:*/		return 0x82095BE8;
		  /* 82095BE8h */ case    4:  		/* cmplw CR6, R16, R11 */
		/* 82095BE8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R16,regs.R11);
		/* 82095BE8h case    4:*/		return 0x82095BEC;
		  /* 82095BECh */ case    5:  		/* bc 12, CR6_EQ, 2508 */
		/* 82095BECh case    5:*/		if ( regs.CR[6].eq ) { return 0x820965B8;  }
		/* 82095BECh case    5:*/		return 0x82095BF0;
		  /* 82095BF0h */ case    6:  		/* bl 19184 */
		/* 82095BF0h case    6:*/		regs.LR = 0x82095BF4; return 0x8209A6E0;
		/* 82095BF0h case    6:*/		return 0x82095BF4;
		  /* 82095BF4h */ case    7:  		/* addi R11, R3, 64 */
		/* 82095BF4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x40);
		/* 82095BF4h case    7:*/		return 0x82095BF8;
		  /* 82095BF8h */ case    8:  		/* cmplw CR6, R16, R11 */
		/* 82095BF8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R16,regs.R11);
		/* 82095BF8h case    8:*/		return 0x82095BFC;
		  /* 82095BFCh */ case    9:  		/* bc 12, CR6_EQ, 2492 */
		/* 82095BFCh case    9:*/		if ( regs.CR[6].eq ) { return 0x820965B8;  }
		/* 82095BFCh case    9:*/		return 0x82095C00;
		  /* 82095C00h */ case   10:  		/* lhz R29, <#[R17]> */
		/* 82095C00h case   10:*/		cpu::mem::load16z( regs, &regs.R29, (uint32)(regs.R17 + 0x00000000) );
		/* 82095C00h case   10:*/		return 0x82095C04;
		  /* 82095C04h */ case   11:  		/* mr R21, R30 */
		/* 82095C04h case   11:*/		regs.R21 = regs.R30;
		/* 82095C04h case   11:*/		return 0x82095C08;
		  /* 82095C08h */ case   12:  		/* mr R26, R30 */
		/* 82095C08h case   12:*/		regs.R26 = regs.R30;
		/* 82095C08h case   12:*/		return 0x82095C0C;
		  /* 82095C0Ch */ case   13:  		/* stw R30, <#[R1 + 96]> */
		/* 82095C0Ch case   13:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000060) );
		/* 82095C0Ch case   13:*/		return 0x82095C10;
		  /* 82095C10h */ case   14:  		/* or. R8, R29, R29 */
		/* 82095C10h case   14:*/		cpu::op::or<1>(regs,&regs.R8,regs.R29,regs.R29);
		/* 82095C10h case   14:*/		return 0x82095C14;
		  /* 82095C14h */ case   15:  		/* stw R30, <#[R1 + 80]> */
		/* 82095C14h case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 82095C14h case   15:*/		return 0x82095C18;
		  /* 82095C18h */ case   16:  		/* stw R30, <#[R1 + 108]> */
		/* 82095C18h case   16:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000006C) );
		/* 82095C18h case   16:*/		return 0x82095C1C;
		  /* 82095C1Ch */ case   17:  		/* bc 12, CR0_EQ, 2452 */
		/* 82095C1Ch case   17:*/		if ( regs.CR[0].eq ) { return 0x820965B0;  }
		/* 82095C1Ch case   17:*/		return 0x82095C20;
		  /* 82095C20h */ case   18:  		/* lis R10, -32217 */
		/* 82095C20h case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 82095C20h case   18:*/		return 0x82095C24;
		  /* 82095C24h */ case   19:  		/* lwz R18, <#[R1 + 104]> */
		/* 82095C24h case   19:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R1 + 0x00000068) );
		/* 82095C24h case   19:*/		return 0x82095C28;
		  /* 82095C28h */ case   20:  		/* lis R9, -32255 */
		/* 82095C28h case   20:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 82095C28h case   20:*/		return 0x82095C2C;
		  /* 82095C2Ch */ case   21:  		/* lwz R27, <#[R1 + 104]> */
		/* 82095C2Ch case   21:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000068) );
		/* 82095C2Ch case   21:*/		return 0x82095C30;
		  /* 82095C30h */ case   22:  		/* addi R19, R10, 7288 */
		/* 82095C30h case   22:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R10,0x1C78);
		/* 82095C30h case   22:*/		return 0x82095C34;
		  /* 82095C34h */ case   23:  		/* lis R11, -32217 */
		/* 82095C34h case   23:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82095C34h case   23:*/		return 0x82095C38;
		  /* 82095C38h */ case   24:  		/* addi R10, R9, -21592 */
		/* 82095C38h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFABA8);
		/* 82095C38h case   24:*/		return 0x82095C3C;
		  /* 82095C3Ch */ case   25:  		/* addi R22, R11, 8856 */
		/* 82095C3Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R11,0x2298);
		/* 82095C3Ch case   25:*/		return 0x82095C40;
		  /* 82095C40h */ case   26:  		/* stw R10, <#[R1 + 104]> */
		/* 82095C40h case   26:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000068) );
		/* 82095C40h case   26:*/		return 0x82095C44;
		  /* 82095C44h */ case   27:  		/* addi R17, R17, 2 */
		/* 82095C44h case   27:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x2);
		/* 82095C44h case   27:*/		return 0x82095C48;
		  /* 82095C48h */ case   28:  		/* cmpwi CR6, R21, 0 */
		/* 82095C48h case   28:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 82095C48h case   28:*/		return 0x82095C4C;
		  /* 82095C4Ch */ case   29:  		/* bc 12, CR6_LT, 2384 */
		/* 82095C4Ch case   29:*/		if ( regs.CR[6].lt ) { return 0x8209659C;  }
		/* 82095C4Ch case   29:*/		return 0x82095C50;
		  /* 82095C50h */ case   30:  		/* cmplwi CR6, R8, 32 */
		/* 82095C50h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000020);
		/* 82095C50h case   30:*/		return 0x82095C54;
		  /* 82095C54h */ case   31:  		/* bc 12, CR6_LT, 28 */
		/* 82095C54h case   31:*/		if ( regs.CR[6].lt ) { return 0x82095C70;  }
		/* 82095C54h case   31:*/		return 0x82095C58;
		  /* 82095C58h */ case   32:  		/* cmplwi CR6, R8, 120 */
		/* 82095C58h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000078);
		/* 82095C58h case   32:*/		return 0x82095C5C;
		  /* 82095C5Ch */ case   33:  		/* bc 12, CR6_GT, 20 */
		/* 82095C5Ch case   33:*/		if ( regs.CR[6].gt ) { return 0x82095C70;  }
		/* 82095C5Ch case   33:*/		return 0x82095C60;
		  /* 82095C60h */ case   34:  		/* add R11, R8, R10 */
		/* 82095C60h case   34:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R10);
		/* 82095C60h case   34:*/		return 0x82095C64;
		  /* 82095C64h */ case   35:  		/* lbz R11, <#[R11 - 32]> */
		/* 82095C64h case   35:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFE0) );
		/* 82095C64h case   35:*/		return 0x82095C68;
		  /* 82095C68h */ case   36:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 82095C68h case   36:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 82095C68h case   36:*/		return 0x82095C6C;
		  /* 82095C6Ch */ case   37:  		/* b 8 */
		/* 82095C6Ch case   37:*/		return 0x82095C74;
		/* 82095C6Ch case   37:*/		return 0x82095C70;
	}
	return 0x82095C70;
} // Block from 82095BD8h-82095C70h (38 instructions)

//////////////////////////////////////////////////////
// Block at 82095C70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095C70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095C70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095C70);
		  /* 82095C70h */ case    0:  		/* mr R11, R30 */
		/* 82095C70h case    0:*/		regs.R11 = regs.R30;
		/* 82095C70h case    0:*/		return 0x82095C74;
	}
	return 0x82095C74;
} // Block from 82095C70h-82095C74h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82095C74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095C74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095C74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095C74);
		  /* 82095C74h */ case    0:  		/* lwz R9, <#[R1 + 96]> */
		/* 82095C74h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000060) );
		/* 82095C74h case    0:*/		return 0x82095C78;
		  /* 82095C78h */ case    1:  		/* mulli R11, R11, 9 */
		/* 82095C78h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x9);
		/* 82095C78h case    1:*/		return 0x82095C7C;
		  /* 82095C7Ch */ case    2:  		/* add R11, R11, R9 */
		/* 82095C7Ch case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82095C7Ch case    2:*/		return 0x82095C80;
		  /* 82095C80h */ case    3:  		/* lbzx R11, <#[R11 + R10]> */
		/* 82095C80h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82095C80h case    3:*/		return 0x82095C84;
		  /* 82095C84h */ case    4:  		/* rlwinm R11, R11, 28, 4, 31 */
		/* 82095C84h case    4:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R11,regs.R11);
		/* 82095C84h case    4:*/		return 0x82095C88;
		  /* 82095C88h */ case    5:  		/* stw R11, <#[R1 + 96]> */
		/* 82095C88h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82095C88h case    5:*/		return 0x82095C8C;
		  /* 82095C8Ch */ case    6:  		/* cmpwi CR6, R11, 8 */
		/* 82095C8Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000008);
		/* 82095C8Ch case    6:*/		return 0x82095C90;
		  /* 82095C90h */ case    7:  		/* bc 12, CR6_EQ, -208 */
		/* 82095C90h case    7:*/		if ( regs.CR[6].eq ) { return 0x82095BC0;  }
		/* 82095C90h case    7:*/		return 0x82095C94;
		  /* 82095C94h */ case    8:  		/* cmplwi CR6, R11, 7 */
		/* 82095C94h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000007);
		/* 82095C94h case    8:*/		return 0x82095C98;
		  /* 82095C98h */ case    9:  		/* bc 12, CR6_GT, 2284 */
		/* 82095C98h case    9:*/		if ( regs.CR[6].gt ) { return 0x82096584;  }
		/* 82095C98h case    9:*/		return 0x82095C9C;
		  /* 82095C9Ch */ case   10:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 82095C9Ch case   10:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 82095C9Ch case   10:*/		return 0x82095CA0;
		  /* 82095CA0h */ case   11:  		/* mtspr CTR, R11 */
		/* 82095CA0h case   11:*/		regs.CTR = regs.R11;
		/* 82095CA0h case   11:*/		return 0x82095CA4;
		  /* 82095CA4h */ case   12:  		/* cmpwi CR6, R11, 0 */
		/* 82095CA4h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82095CA4h case   12:*/		return 0x82095CA8;
		  /* 82095CA8h */ case   13:  		/* bc 12, CR6_EQ, 472 */
		/* 82095CA8h case   13:*/		if ( regs.CR[6].eq ) { return 0x82095E80;  }
		/* 82095CA8h case   13:*/		return 0x82095CAC;
		  /* 82095CACh */ case   14:  		/* bc 18, CR0_LT, 28 */
		/* 82095CACh case   14:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x82095CC8;  }
		/* 82095CACh case   14:*/		return 0x82095CB0;
		  /* 82095CB0h */ case   15:  		/* bc 18, CR0_LT, 56 */
		/* 82095CB0h case   15:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x82095CE8;  }
		/* 82095CB0h case   15:*/		return 0x82095CB4;
		  /* 82095CB4h */ case   16:  		/* bc 18, CR0_LT, 132 */
		/* 82095CB4h case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x82095D38;  }
		/* 82095CB4h case   16:*/		return 0x82095CB8;
		  /* 82095CB8h */ case   17:  		/* bc 18, CR0_LT, 188 */
		/* 82095CB8h case   17:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x82095D74;  }
		/* 82095CB8h case   17:*/		return 0x82095CBC;
		  /* 82095CBCh */ case   18:  		/* bc 18, CR0_LT, 192 */
		/* 82095CBCh case   18:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x82095D7C;  }
		/* 82095CBCh case   18:*/		return 0x82095CC0;
		  /* 82095CC0h */ case   19:  		/* bc 18, CR0_LT, 244 */
		/* 82095CC0h case   19:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x82095DB4;  }
		/* 82095CC0h case   19:*/		return 0x82095CC4;
		  /* 82095CC4h */ case   20:  		/* b 472 */
		/* 82095CC4h case   20:*/		return 0x82095E9C;
		/* 82095CC4h case   20:*/		return 0x82095CC8;
	}
	return 0x82095CC8;
} // Block from 82095C74h-82095CC8h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82095CC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095CC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095CC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095CC8);
		  /* 82095CC8h */ case    0:  		/* li R20, 0 */
		/* 82095CC8h case    0:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 82095CC8h case    0:*/		return 0x82095CCC;
		  /* 82095CCCh */ case    1:  		/* li R23, -1 */
		/* 82095CCCh case    1:*/		cpu::op::li<0>(regs,&regs.R23,0xFFFFFFFF);
		/* 82095CCCh case    1:*/		return 0x82095CD0;
		  /* 82095CD0h */ case    2:  		/* mr R18, R20 */
		/* 82095CD0h case    2:*/		regs.R18 = regs.R20;
		/* 82095CD0h case    2:*/		return 0x82095CD4;
		  /* 82095CD4h */ case    3:  		/* stw R20, <#[R1 + 100]> */
		/* 82095CD4h case    3:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x00000064) );
		/* 82095CD4h case    3:*/		return 0x82095CD8;
		  /* 82095CD8h */ case    4:  		/* mr R14, R20 */
		/* 82095CD8h case    4:*/		regs.R14 = regs.R20;
		/* 82095CD8h case    4:*/		return 0x82095CDC;
		  /* 82095CDCh */ case    5:  		/* mr R15, R20 */
		/* 82095CDCh case    5:*/		regs.R15 = regs.R20;
		/* 82095CDCh case    5:*/		return 0x82095CE0;
		  /* 82095CE0h */ case    6:  		/* mr R25, R20 */
		/* 82095CE0h case    6:*/		regs.R25 = regs.R20;
		/* 82095CE0h case    6:*/		return 0x82095CE4;
		  /* 82095CE4h */ case    7:  		/* b 2208 */
		/* 82095CE4h case    7:*/		return 0x82096584;
		/* 82095CE4h case    7:*/		return 0x82095CE8;
	}
	return 0x82095CE8;
} // Block from 82095CC8h-82095CE8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82095CE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095CE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095CE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095CE8);
		  /* 82095CE8h */ case    0:  		/* cmpwi CR6, R8, 32 */
		/* 82095CE8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000020);
		/* 82095CE8h case    0:*/		return 0x82095CEC;
		  /* 82095CECh */ case    1:  		/* bc 12, CR6_EQ, 68 */
		/* 82095CECh case    1:*/		if ( regs.CR[6].eq ) { return 0x82095D30;  }
		/* 82095CECh case    1:*/		return 0x82095CF0;
		  /* 82095CF0h */ case    2:  		/* cmpwi CR6, R8, 35 */
		/* 82095CF0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000023);
		/* 82095CF0h case    2:*/		return 0x82095CF4;
		  /* 82095CF4h */ case    3:  		/* bc 12, CR6_EQ, 52 */
		/* 82095CF4h case    3:*/		if ( regs.CR[6].eq ) { return 0x82095D28;  }
		/* 82095CF4h case    3:*/		return 0x82095CF8;
		  /* 82095CF8h */ case    4:  		/* cmpwi CR6, R8, 43 */
		/* 82095CF8h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000002B);
		/* 82095CF8h case    4:*/		return 0x82095CFC;
		  /* 82095CFCh */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 82095CFCh case    5:*/		if ( regs.CR[6].eq ) { return 0x82095D20;  }
		/* 82095CFCh case    5:*/		return 0x82095D00;
		  /* 82095D00h */ case    6:  		/* cmpwi CR6, R8, 45 */
		/* 82095D00h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000002D);
		/* 82095D00h case    6:*/		return 0x82095D04;
		  /* 82095D04h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 82095D04h case    7:*/		if ( regs.CR[6].eq ) { return 0x82095D18;  }
		/* 82095D04h case    7:*/		return 0x82095D08;
		  /* 82095D08h */ case    8:  		/* cmpwi CR6, R8, 48 */
		/* 82095D08h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000030);
		/* 82095D08h case    8:*/		return 0x82095D0C;
		  /* 82095D0Ch */ case    9:  		/* bc 4, CR6_EQ, 2168 */
		/* 82095D0Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x82096584;  }
		/* 82095D0Ch case    9:*/		return 0x82095D10;
		  /* 82095D10h */ case   10:  		/* ori R25, R25, 8 */
		/* 82095D10h case   10:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x8);
		/* 82095D10h case   10:*/		return 0x82095D14;
		  /* 82095D14h */ case   11:  		/* b 2160 */
		/* 82095D14h case   11:*/		return 0x82096584;
		/* 82095D14h case   11:*/		return 0x82095D18;
	}
	return 0x82095D18;
} // Block from 82095CE8h-82095D18h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82095D18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095D18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095D18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095D18);
		  /* 82095D18h */ case    0:  		/* ori R25, R25, 4 */
		/* 82095D18h case    0:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x4);
		/* 82095D18h case    0:*/		return 0x82095D1C;
		  /* 82095D1Ch */ case    1:  		/* b 2152 */
		/* 82095D1Ch case    1:*/		return 0x82096584;
		/* 82095D1Ch case    1:*/		return 0x82095D20;
	}
	return 0x82095D20;
} // Block from 82095D18h-82095D20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82095D20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095D20);
		  /* 82095D20h */ case    0:  		/* ori R25, R25, 1 */
		/* 82095D20h case    0:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x1);
		/* 82095D20h case    0:*/		return 0x82095D24;
		  /* 82095D24h */ case    1:  		/* b 2144 */
		/* 82095D24h case    1:*/		return 0x82096584;
		/* 82095D24h case    1:*/		return 0x82095D28;
	}
	return 0x82095D28;
} // Block from 82095D20h-82095D28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82095D28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095D28);
		  /* 82095D28h */ case    0:  		/* ori R25, R25, 128 */
		/* 82095D28h case    0:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x80);
		/* 82095D28h case    0:*/		return 0x82095D2C;
		  /* 82095D2Ch */ case    1:  		/* b 2136 */
		/* 82095D2Ch case    1:*/		return 0x82096584;
		/* 82095D2Ch case    1:*/		return 0x82095D30;
	}
	return 0x82095D30;
} // Block from 82095D28h-82095D30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82095D30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095D30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095D30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095D30);
		  /* 82095D30h */ case    0:  		/* ori R25, R25, 2 */
		/* 82095D30h case    0:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x2);
		/* 82095D30h case    0:*/		return 0x82095D34;
		  /* 82095D34h */ case    1:  		/* b 2128 */
		/* 82095D34h case    1:*/		return 0x82096584;
		/* 82095D34h case    1:*/		return 0x82095D38;
	}
	return 0x82095D38;
} // Block from 82095D30h-82095D38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82095D38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095D38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095D38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095D38);
		  /* 82095D38h */ case    0:  		/* cmplwi CR6, R8, 42 */
		/* 82095D38h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000002A);
		/* 82095D38h case    0:*/		return 0x82095D3C;
		  /* 82095D3Ch */ case    1:  		/* bc 4, CR6_EQ, 40 */
		/* 82095D3Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82095D64;  }
		/* 82095D3Ch case    1:*/		return 0x82095D40;
		  /* 82095D40h */ case    2:  		/* addi R11, R24, 7 */
		/* 82095D40h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x7);
		/* 82095D40h case    2:*/		return 0x82095D44;
		  /* 82095D44h */ case    3:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82095D44h case    3:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82095D44h case    3:*/		return 0x82095D48;
		  /* 82095D48h */ case    4:  		/* addi R24, R11, 8 */
		/* 82095D48h case    4:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x8);
		/* 82095D48h case    4:*/		return 0x82095D4C;
		  /* 82095D4Ch */ case    5:  		/* lwz R14, <#[R11 + 4]> */
		/* 82095D4Ch case    5:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R11 + 0x00000004) );
		/* 82095D4Ch case    5:*/		return 0x82095D50;
		  /* 82095D50h */ case    6:  		/* cmpwi CR6, R14, 0 */
		/* 82095D50h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 82095D50h case    6:*/		return 0x82095D54;
		  /* 82095D54h */ case    7:  		/* bc 4, CR6_LT, 2096 */
		/* 82095D54h case    7:*/		if ( !regs.CR[6].lt ) { return 0x82096584;  }
		/* 82095D54h case    7:*/		return 0x82095D58;
		  /* 82095D58h */ case    8:  		/* ori R25, R25, 4 */
		/* 82095D58h case    8:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x4);
		/* 82095D58h case    8:*/		return 0x82095D5C;
		  /* 82095D5Ch */ case    9:  		/* neg R14, R14 */
		/* 82095D5Ch case    9:*/		cpu::op::neg<0>(regs,&regs.R14,regs.R14);
		/* 82095D5Ch case    9:*/		return 0x82095D60;
		  /* 82095D60h */ case   10:  		/* b 2084 */
		/* 82095D60h case   10:*/		return 0x82096584;
		/* 82095D60h case   10:*/		return 0x82095D64;
	}
	return 0x82095D64;
} // Block from 82095D38h-82095D64h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82095D64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095D64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095D64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095D64);
		  /* 82095D64h */ case    0:  		/* mulli R11, R14, 10 */
		/* 82095D64h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R14,0xA);
		/* 82095D64h case    0:*/		return 0x82095D68;
		  /* 82095D68h */ case    1:  		/* add R11, R11, R8 */
		/* 82095D68h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 82095D68h case    1:*/		return 0x82095D6C;
		  /* 82095D6Ch */ case    2:  		/* addi R14, R11, -48 */
		/* 82095D6Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R14,regs.R11,0xFFFFFFD0);
		/* 82095D6Ch case    2:*/		return 0x82095D70;
		  /* 82095D70h */ case    3:  		/* b 2068 */
		/* 82095D70h case    3:*/		return 0x82096584;
		/* 82095D70h case    3:*/		return 0x82095D74;
	}
	return 0x82095D74;
} // Block from 82095D64h-82095D74h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82095D74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095D74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095D74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095D74);
		  /* 82095D74h */ case    0:  		/* li R23, 0 */
		/* 82095D74h case    0:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 82095D74h case    0:*/		return 0x82095D78;
		  /* 82095D78h */ case    1:  		/* b 2060 */
		/* 82095D78h case    1:*/		return 0x82096584;
		/* 82095D78h case    1:*/		return 0x82095D7C;
	}
	return 0x82095D7C;
} // Block from 82095D74h-82095D7Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82095D7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095D7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095D7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095D7C);
		  /* 82095D7Ch */ case    0:  		/* cmplwi CR6, R8, 42 */
		/* 82095D7Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000002A);
		/* 82095D7Ch case    0:*/		return 0x82095D80;
		  /* 82095D80h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 82095D80h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82095DA4;  }
		/* 82095D80h case    1:*/		return 0x82095D84;
		  /* 82095D84h */ case    2:  		/* addi R11, R24, 7 */
		/* 82095D84h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x7);
		/* 82095D84h case    2:*/		return 0x82095D88;
		  /* 82095D88h */ case    3:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82095D88h case    3:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82095D88h case    3:*/		return 0x82095D8C;
		  /* 82095D8Ch */ case    4:  		/* addi R24, R11, 8 */
		/* 82095D8Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x8);
		/* 82095D8Ch case    4:*/		return 0x82095D90;
		  /* 82095D90h */ case    5:  		/* lwz R23, <#[R11 + 4]> */
		/* 82095D90h case    5:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R11 + 0x00000004) );
		/* 82095D90h case    5:*/		return 0x82095D94;
		  /* 82095D94h */ case    6:  		/* cmpwi CR6, R23, 0 */
		/* 82095D94h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 82095D94h case    6:*/		return 0x82095D98;
		  /* 82095D98h */ case    7:  		/* bc 4, CR6_LT, 2028 */
		/* 82095D98h case    7:*/		if ( !regs.CR[6].lt ) { return 0x82096584;  }
		/* 82095D98h case    7:*/		return 0x82095D9C;
		  /* 82095D9Ch */ case    8:  		/* li R23, -1 */
		/* 82095D9Ch case    8:*/		cpu::op::li<0>(regs,&regs.R23,0xFFFFFFFF);
		/* 82095D9Ch case    8:*/		return 0x82095DA0;
		  /* 82095DA0h */ case    9:  		/* b 2020 */
		/* 82095DA0h case    9:*/		return 0x82096584;
		/* 82095DA0h case    9:*/		return 0x82095DA4;
	}
	return 0x82095DA4;
} // Block from 82095D7Ch-82095DA4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82095DA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095DA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095DA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095DA4);
		  /* 82095DA4h */ case    0:  		/* mulli R11, R23, 10 */
		/* 82095DA4h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R23,0xA);
		/* 82095DA4h case    0:*/		return 0x82095DA8;
		  /* 82095DA8h */ case    1:  		/* add R11, R11, R8 */
		/* 82095DA8h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 82095DA8h case    1:*/		return 0x82095DAC;
		  /* 82095DACh */ case    2:  		/* addi R23, R11, -48 */
		/* 82095DACh case    2:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R11,0xFFFFFFD0);
		/* 82095DACh case    2:*/		return 0x82095DB0;
		  /* 82095DB0h */ case    3:  		/* b 2004 */
		/* 82095DB0h case    3:*/		return 0x82096584;
		/* 82095DB0h case    3:*/		return 0x82095DB4;
	}
	return 0x82095DB4;
} // Block from 82095DA4h-82095DB4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82095DB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095DB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095DB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095DB4);
		  /* 82095DB4h */ case    0:  		/* cmpwi CR6, R8, 73 */
		/* 82095DB4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000049);
		/* 82095DB4h case    0:*/		return 0x82095DB8;
		  /* 82095DB8h */ case    1:  		/* bc 12, CR6_EQ, 76 */
		/* 82095DB8h case    1:*/		if ( regs.CR[6].eq ) { return 0x82095E04;  }
		/* 82095DB8h case    1:*/		return 0x82095DBC;
		  /* 82095DBCh */ case    2:  		/* cmpwi CR6, R8, 104 */
		/* 82095DBCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000068);
		/* 82095DBCh case    2:*/		return 0x82095DC0;
		  /* 82095DC0h */ case    3:  		/* bc 12, CR6_EQ, 60 */
		/* 82095DC0h case    3:*/		if ( regs.CR[6].eq ) { return 0x82095DFC;  }
		/* 82095DC0h case    3:*/		return 0x82095DC4;
		  /* 82095DC4h */ case    4:  		/* cmpwi CR6, R8, 108 */
		/* 82095DC4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000006C);
		/* 82095DC4h case    4:*/		return 0x82095DC8;
		  /* 82095DC8h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 82095DC8h case    5:*/		if ( regs.CR[6].eq ) { return 0x82095DDC;  }
		/* 82095DC8h case    5:*/		return 0x82095DCC;
		  /* 82095DCCh */ case    6:  		/* cmpwi CR6, R8, 119 */
		/* 82095DCCh case    6:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000077);
		/* 82095DCCh case    6:*/		return 0x82095DD0;
		  /* 82095DD0h */ case    7:  		/* bc 4, CR6_EQ, 1972 */
		/* 82095DD0h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82096584;  }
		/* 82095DD0h case    7:*/		return 0x82095DD4;
		  /* 82095DD4h */ case    8:  		/* ori R25, R25, 2048 */
		/* 82095DD4h case    8:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x800);
		/* 82095DD4h case    8:*/		return 0x82095DD8;
		  /* 82095DD8h */ case    9:  		/* b 1964 */
		/* 82095DD8h case    9:*/		return 0x82096584;
		/* 82095DD8h case    9:*/		return 0x82095DDC;
	}
	return 0x82095DDC;
} // Block from 82095DB4h-82095DDCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 82095DDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095DDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095DDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095DDC);
		  /* 82095DDCh */ case    0:  		/* lhz R11, <#[R17]> */
		/* 82095DDCh case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82095DDCh case    0:*/		return 0x82095DE0;
		  /* 82095DE0h */ case    1:  		/* cmplwi CR6, R11, 108 */
		/* 82095DE0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000006C);
		/* 82095DE0h case    1:*/		return 0x82095DE4;
		  /* 82095DE4h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 82095DE4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82095DF4;  }
		/* 82095DE4h case    2:*/		return 0x82095DE8;
		  /* 82095DE8h */ case    3:  		/* addi R17, R17, 2 */
		/* 82095DE8h case    3:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x2);
		/* 82095DE8h case    3:*/		return 0x82095DEC;
		  /* 82095DECh */ case    4:  		/* ori R25, R25, 4096 */
		/* 82095DECh case    4:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x1000);
		/* 82095DECh case    4:*/		return 0x82095DF0;
		  /* 82095DF0h */ case    5:  		/* b 1940 */
		/* 82095DF0h case    5:*/		return 0x82096584;
		/* 82095DF0h case    5:*/		return 0x82095DF4;
	}
	return 0x82095DF4;
} // Block from 82095DDCh-82095DF4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82095DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095DF4);
		  /* 82095DF4h */ case    0:  		/* ori R25, R25, 16 */
		/* 82095DF4h case    0:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x10);
		/* 82095DF4h case    0:*/		return 0x82095DF8;
		  /* 82095DF8h */ case    1:  		/* b 1932 */
		/* 82095DF8h case    1:*/		return 0x82096584;
		/* 82095DF8h case    1:*/		return 0x82095DFC;
	}
	return 0x82095DFC;
} // Block from 82095DF4h-82095DFCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82095DFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095DFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095DFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095DFC);
		  /* 82095DFCh */ case    0:  		/* ori R25, R25, 32 */
		/* 82095DFCh case    0:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x20);
		/* 82095DFCh case    0:*/		return 0x82095E00;
		  /* 82095E00h */ case    1:  		/* b 1924 */
		/* 82095E00h case    1:*/		return 0x82096584;
		/* 82095E00h case    1:*/		return 0x82095E04;
	}
	return 0x82095E04;
} // Block from 82095DFCh-82095E04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82095E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095E04);
		  /* 82095E04h */ case    0:  		/* lhz R11, <#[R17]> */
		/* 82095E04h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82095E04h case    0:*/		return 0x82095E08;
		  /* 82095E08h */ case    1:  		/* cmplwi CR6, R11, 54 */
		/* 82095E08h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000036);
		/* 82095E08h case    1:*/		return 0x82095E0C;
		  /* 82095E0Ch */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 82095E0Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82095E28;  }
		/* 82095E0Ch case    2:*/		return 0x82095E10;
		  /* 82095E10h */ case    3:  		/* lhz R10, <#[R17 + 2]> */
		/* 82095E10h case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000002) );
		/* 82095E10h case    3:*/		return 0x82095E14;
		  /* 82095E14h */ case    4:  		/* cmplwi CR6, R10, 52 */
		/* 82095E14h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000034);
		/* 82095E14h case    4:*/		return 0x82095E18;
		  /* 82095E18h */ case    5:  		/* bc 4, CR6_EQ, 16 */
		/* 82095E18h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82095E28;  }
		/* 82095E18h case    5:*/		return 0x82095E1C;
		  /* 82095E1Ch */ case    6:  		/* addi R17, R17, 4 */
		/* 82095E1Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x4);
		/* 82095E1Ch case    6:*/		return 0x82095E20;
		  /* 82095E20h */ case    7:  		/* ori R25, R25, 32768 */
		/* 82095E20h case    7:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x8000);
		/* 82095E20h case    7:*/		return 0x82095E24;
		  /* 82095E24h */ case    8:  		/* b 1888 */
		/* 82095E24h case    8:*/		return 0x82096584;
		/* 82095E24h case    8:*/		return 0x82095E28;
	}
	return 0x82095E28;
} // Block from 82095E04h-82095E28h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82095E28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095E28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095E28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095E28);
		  /* 82095E28h */ case    0:  		/* cmplwi CR6, R11, 51 */
		/* 82095E28h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000033);
		/* 82095E28h case    0:*/		return 0x82095E2C;
		  /* 82095E2Ch */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 82095E2Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82095E48;  }
		/* 82095E2Ch case    1:*/		return 0x82095E30;
		  /* 82095E30h */ case    2:  		/* lhz R10, <#[R17 + 2]> */
		/* 82095E30h case    2:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000002) );
		/* 82095E30h case    2:*/		return 0x82095E34;
		  /* 82095E34h */ case    3:  		/* cmplwi CR6, R10, 50 */
		/* 82095E34h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000032);
		/* 82095E34h case    3:*/		return 0x82095E38;
		  /* 82095E38h */ case    4:  		/* bc 4, CR6_EQ, 16 */
		/* 82095E38h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82095E48;  }
		/* 82095E38h case    4:*/		return 0x82095E3C;
		  /* 82095E3Ch */ case    5:  		/* addi R17, R17, 4 */
		/* 82095E3Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x4);
		/* 82095E3Ch case    5:*/		return 0x82095E40;
		  /* 82095E40h */ case    6:  		/* rlwinm R25, R25, 0, 17, 15 */
		/* 82095E40h case    6:*/		cpu::op::rlwinm<0,0,17,15>(regs,&regs.R25,regs.R25);
		/* 82095E40h case    6:*/		return 0x82095E44;
		  /* 82095E44h */ case    7:  		/* b 1856 */
		/* 82095E44h case    7:*/		return 0x82096584;
		/* 82095E44h case    7:*/		return 0x82095E48;
	}
	return 0x82095E48;
} // Block from 82095E28h-82095E48h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82095E48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095E48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095E48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095E48);
		  /* 82095E48h */ case    0:  		/* cmplwi CR6, R11, 100 */
		/* 82095E48h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000064);
		/* 82095E48h case    0:*/		return 0x82095E4C;
		  /* 82095E4Ch */ case    1:  		/* bc 12, CR6_EQ, 1848 */
		/* 82095E4Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82096584;  }
		/* 82095E4Ch case    1:*/		return 0x82095E50;
		  /* 82095E50h */ case    2:  		/* cmplwi CR6, R11, 105 */
		/* 82095E50h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000069);
		/* 82095E50h case    2:*/		return 0x82095E54;
		  /* 82095E54h */ case    3:  		/* bc 12, CR6_EQ, 1840 */
		/* 82095E54h case    3:*/		if ( regs.CR[6].eq ) { return 0x82096584;  }
		/* 82095E54h case    3:*/		return 0x82095E58;
		  /* 82095E58h */ case    4:  		/* cmplwi CR6, R11, 111 */
		/* 82095E58h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000006F);
		/* 82095E58h case    4:*/		return 0x82095E5C;
		  /* 82095E5Ch */ case    5:  		/* bc 12, CR6_EQ, 1832 */
		/* 82095E5Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82096584;  }
		/* 82095E5Ch case    5:*/		return 0x82095E60;
		  /* 82095E60h */ case    6:  		/* cmplwi CR6, R11, 117 */
		/* 82095E60h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000075);
		/* 82095E60h case    6:*/		return 0x82095E64;
		  /* 82095E64h */ case    7:  		/* bc 12, CR6_EQ, 1824 */
		/* 82095E64h case    7:*/		if ( regs.CR[6].eq ) { return 0x82096584;  }
		/* 82095E64h case    7:*/		return 0x82095E68;
		  /* 82095E68h */ case    8:  		/* cmplwi CR6, R11, 120 */
		/* 82095E68h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000078);
		/* 82095E68h case    8:*/		return 0x82095E6C;
		  /* 82095E6Ch */ case    9:  		/* bc 12, CR6_EQ, 1816 */
		/* 82095E6Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x82096584;  }
		/* 82095E6Ch case    9:*/		return 0x82095E70;
		  /* 82095E70h */ case   10:  		/* cmplwi CR6, R11, 88 */
		/* 82095E70h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000058);
		/* 82095E70h case   10:*/		return 0x82095E74;
		  /* 82095E74h */ case   11:  		/* bc 12, CR6_EQ, 1808 */
		/* 82095E74h case   11:*/		if ( regs.CR[6].eq ) { return 0x82096584;  }
		/* 82095E74h case   11:*/		return 0x82095E78;
		  /* 82095E78h */ case   12:  		/* li R11, 0 */
		/* 82095E78h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82095E78h case   12:*/		return 0x82095E7C;
		  /* 82095E7Ch */ case   13:  		/* stw R11, <#[R1 + 96]> */
		/* 82095E7Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82095E7Ch case   13:*/		return 0x82095E80;
	}
	return 0x82095E80;
} // Block from 82095E48h-82095E80h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82095E80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095E80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095E80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095E80);
		  /* 82095E80h */ case    0:  		/* addi R5, R1, 80 */
		/* 82095E80h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82095E80h case    0:*/		return 0x82095E84;
		  /* 82095E84h */ case    1:  		/* mr R4, R16 */
		/* 82095E84h case    1:*/		regs.R4 = regs.R16;
		/* 82095E84h case    1:*/		return 0x82095E88;
		  /* 82095E88h */ case    2:  		/* mr R3, R29 */
		/* 82095E88h case    2:*/		regs.R3 = regs.R29;
		/* 82095E88h case    2:*/		return 0x82095E8C;
		  /* 82095E8Ch */ case    3:  		/* li R20, 1 */
		/* 82095E8Ch case    3:*/		cpu::op::li<0>(regs,&regs.R20,0x1);
		/* 82095E8Ch case    3:*/		return 0x82095E90;
		  /* 82095E90h */ case    4:  		/* bl -1096 */
		/* 82095E90h case    4:*/		regs.LR = 0x82095E94; return 0x82095A48;
		/* 82095E90h case    4:*/		return 0x82095E94;
		  /* 82095E94h */ case    5:  		/* lwz R21, <#[R1 + 80]> */
		/* 82095E94h case    5:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000050) );
		/* 82095E94h case    5:*/		return 0x82095E98;
		  /* 82095E98h */ case    6:  		/* b 1772 */
		/* 82095E98h case    6:*/		return 0x82096584;
		/* 82095E98h case    6:*/		return 0x82095E9C;
	}
	return 0x82095E9C;
} // Block from 82095E80h-82095E9Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82095E9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095E9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095E9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095E9C);
		  /* 82095E9Ch */ case    0:  		/* addi R11, R8, -65 */
		/* 82095E9Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0xFFFFFFBF);
		/* 82095E9Ch case    0:*/		return 0x82095EA0;
		  /* 82095EA0h */ case    1:  		/* cmplwi CR6, R11, 55 */
		/* 82095EA0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000037);
		/* 82095EA0h case    1:*/		return 0x82095EA4;
		  /* 82095EA4h */ case    2:  		/* bc 12, CR6_GT, 1312 */
		/* 82095EA4h case    2:*/		if ( regs.CR[6].gt ) { return 0x820963C4;  }
		/* 82095EA4h case    2:*/		return 0x82095EA8;
		  /* 82095EA8h */ case    3:  		/* lis R12, -32255 */
		/* 82095EA8h case    3:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8201);
		/* 82095EA8h case    3:*/		return 0x82095EAC;
		  /* 82095EACh */ case    4:  		/* rlwinm R0, R11, 1, 0, 30 */
		/* 82095EACh case    4:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R0,regs.R11);
		/* 82095EACh case    4:*/		return 0x82095EB0;
		  /* 82095EB0h */ case    5:  		/* addi R12, R12, -22056 */
		/* 82095EB0h case    5:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFA9D8);
		/* 82095EB0h case    5:*/		return 0x82095EB4;
		  /* 82095EB4h */ case    6:  		/* lhzx R0, <#[R12 + R0]> */
		/* 82095EB4h case    6:*/		cpu::mem::load16z( regs, &regs.R0, (uint32)(regs.R12 + regs.R0 + 0x00000000) );
		/* 82095EB4h case    6:*/		return 0x82095EB8;
		  /* 82095EB8h */ case    7:  		/* lis R12, -32247 */
		/* 82095EB8h case    7:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8209);
		/* 82095EB8h case    7:*/		return 0x82095EBC;
		  /* 82095EBCh */ case    8:  		/* addi R12, R12, 24272 */
		/* 82095EBCh case    8:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x5ED0);
		/* 82095EBCh case    8:*/		return 0x82095EC0;
		  /* 82095EC0h */ case    9:  		/* ori R0, R0, 0 */
		/* 82095EC0h case    9:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82095EC0h case    9:*/		return 0x82095EC4;
		  /* 82095EC4h */ case   10:  		/* add R12, R12, R0 */
		/* 82095EC4h case   10:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 82095EC4h case   10:*/		return 0x82095EC8;
		  /* 82095EC8h */ case   11:  		/* mtspr CTR, R12 */
		/* 82095EC8h case   11:*/		regs.CTR = regs.R12;
		/* 82095EC8h case   11:*/		return 0x82095ECC;
		  /* 82095ECCh */ case   12:  		/* bcctr 20, CR0_LT */
		/* 82095ECCh case   12:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 82095ECCh case   12:*/		return 0x82095ED0;
		  /* 82095ED0h */ case   13:  		/* andi. R11, R25, 2096 */
		/* 82095ED0h case   13:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R25,0x830);
		/* 82095ED0h case   13:*/		return 0x82095ED4;
		  /* 82095ED4h */ case   14:  		/* cmpwi CR0, R11, 0 */
		/* 82095ED4h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 82095ED4h case   14:*/		return 0x82095ED8;
		  /* 82095ED8h */ case   15:  		/* bc 4, CR0_EQ, 8 */
		/* 82095ED8h case   15:*/		if ( !regs.CR[0].eq ) { return 0x82095EE0;  }
		/* 82095ED8h case   15:*/		return 0x82095EDC;
		  /* 82095EDCh */ case   16:  		/* ori R25, R25, 32 */
		/* 82095EDCh case   16:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x20);
		/* 82095EDCh case   16:*/		return 0x82095EE0;
	}
	return 0x82095EE0;
} // Block from 82095E9Ch-82095EE0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82095EE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095EE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095EE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095EE0);
		  /* 82095EE0h */ case    0:  		/* addi R11, R24, 7 */
		/* 82095EE0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x7);
		/* 82095EE0h case    0:*/		return 0x82095EE4;
		  /* 82095EE4h */ case    1:  		/* li R26, 1 */
		/* 82095EE4h case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 82095EE4h case    1:*/		return 0x82095EE8;
		  /* 82095EE8h */ case    2:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82095EE8h case    2:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82095EE8h case    2:*/		return 0x82095EEC;
		  /* 82095EECh */ case    3:  		/* rlwinm. R10, R25, 0, 26, 26 */
		/* 82095EECh case    3:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R10,regs.R25);
		/* 82095EECh case    3:*/		return 0x82095EF0;
		  /* 82095EF0h */ case    4:  		/* addi R24, R11, 8 */
		/* 82095EF0h case    4:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x8);
		/* 82095EF0h case    4:*/		return 0x82095EF4;
		  /* 82095EF4h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 82095EF4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82095EF4h case    5:*/		return 0x82095EF8;
		  /* 82095EF8h */ case    6:  		/* mr R20, R26 */
		/* 82095EF8h case    6:*/		regs.R20 = regs.R26;
		/* 82095EF8h case    6:*/		return 0x82095EFC;
		  /* 82095EFCh */ case    7:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 82095EFCh case    7:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 82095EFCh case    7:*/		return 0x82095F00;
		  /* 82095F00h */ case    8:  		/* sth R11, <#[R1 + 92]> */
		/* 82095F00h case    8:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 82095F00h case    8:*/		return 0x82095F04;
		  /* 82095F04h */ case    9:  		/* bc 12, CR0_EQ, 60 */
		/* 82095F04h case    9:*/		if ( regs.CR[0].eq ) { return 0x82095F40;  }
		/* 82095F04h case    9:*/		return 0x82095F08;
		  /* 82095F08h */ case   10:  		/* mr R10, R11 */
		/* 82095F08h case   10:*/		regs.R10 = regs.R11;
		/* 82095F08h case   10:*/		return 0x82095F0C;
		  /* 82095F0Ch */ case   11:  		/* lwz R11, <#[R22]> */
		/* 82095F0Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 82095F0Ch case   11:*/		return 0x82095F10;
		  /* 82095F10h */ case   12:  		/* li R9, 0 */
		/* 82095F10h case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82095F10h case   12:*/		return 0x82095F14;
		  /* 82095F14h */ case   13:  		/* stb R10, <#[R1 + 84]> */
		/* 82095F14h case   13:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82095F14h case   13:*/		return 0x82095F18;
		  /* 82095F18h */ case   14:  		/* mr R6, R22 */
		/* 82095F18h case   14:*/		regs.R6 = regs.R22;
		/* 82095F18h case   14:*/		return 0x82095F1C;
		  /* 82095F1Ch */ case   15:  		/* stb R9, <#[R1 + 85]> */
		/* 82095F1Ch case   15:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R1 + 0x00000055) );
		/* 82095F1Ch case   15:*/		return 0x82095F20;
		  /* 82095F20h */ case   16:  		/* addi R4, R1, 84 */
		/* 82095F20h case   16:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x54);
		/* 82095F20h case   16:*/		return 0x82095F24;
		  /* 82095F24h */ case   17:  		/* addi R3, R1, 128 */
		/* 82095F24h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 82095F24h case   17:*/		return 0x82095F28;
		  /* 82095F28h */ case   18:  		/* lwz R5, <#[R11 + 172]> */
		/* 82095F28h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x000000AC) );
		/* 82095F28h case   18:*/		return 0x82095F2C;
		  /* 82095F2Ch */ case   19:  		/* bl 20332 */
		/* 82095F2Ch case   19:*/		regs.LR = 0x82095F30; return 0x8209AE98;
		/* 82095F2Ch case   19:*/		return 0x82095F30;
		  /* 82095F30h */ case   20:  		/* cmpwi CR0, R3, 0 */
		/* 82095F30h case   20:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82095F30h case   20:*/		return 0x82095F34;
		  /* 82095F34h */ case   21:  		/* bc 4, CR0_LT, 16 */
		/* 82095F34h case   21:*/		if ( !regs.CR[0].lt ) { return 0x82095F44;  }
		/* 82095F34h case   21:*/		return 0x82095F38;
		  /* 82095F38h */ case   22:  		/* stw R26, <#[R1 + 100]> */
		/* 82095F38h case   22:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000064) );
		/* 82095F38h case   22:*/		return 0x82095F3C;
		  /* 82095F3Ch */ case   23:  		/* b 8 */
		/* 82095F3Ch case   23:*/		return 0x82095F44;
		/* 82095F3Ch case   23:*/		return 0x82095F40;
	}
	return 0x82095F40;
} // Block from 82095EE0h-82095F40h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82095F40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095F40);
		  /* 82095F40h */ case    0:  		/* sth R11, <#[R1 + 128]> */
		/* 82095F40h case    0:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 82095F40h case    0:*/		return 0x82095F44;
	}
	return 0x82095F44;
} // Block from 82095F40h-82095F44h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82095F44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095F44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095F44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095F44);
		  /* 82095F44h */ case    0:  		/* addi R27, R1, 128 */
		/* 82095F44h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R1,0x80);
		/* 82095F44h case    0:*/		return 0x82095F48;
		  /* 82095F48h */ case    1:  		/* b 1148 */
		/* 82095F48h case    1:*/		return 0x820963C4;
		/* 82095F48h case    1:*/		return 0x82095F4C;
		  /* 82095F4Ch */ case    2:  		/* addi R11, R24, 7 */
		/* 82095F4Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x7);
		/* 82095F4Ch case    2:*/		return 0x82095F50;
		  /* 82095F50h */ case    3:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82095F50h case    3:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82095F50h case    3:*/		return 0x82095F54;
		  /* 82095F54h */ case    4:  		/* addi R24, R11, 8 */
		/* 82095F54h case    4:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x8);
		/* 82095F54h case    4:*/		return 0x82095F58;
		  /* 82095F58h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 82095F58h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82095F58h case    5:*/		return 0x82095F5C;
		  /* 82095F5Ch */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82095F5Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82095F5Ch case    6:*/		return 0x82095F60;
		  /* 82095F60h */ case    7:  		/* bc 12, CR6_EQ, 60 */
		/* 82095F60h case    7:*/		if ( regs.CR[6].eq ) { return 0x82095F9C;  }
		/* 82095F60h case    7:*/		return 0x82095F64;
		  /* 82095F64h */ case    8:  		/* lwz R10, <#[R11 + 4]> */
		/* 82095F64h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82095F64h case    8:*/		return 0x82095F68;
		  /* 82095F68h */ case    9:  		/* cmplwi CR6, R10, 0 */
		/* 82095F68h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82095F68h case    9:*/		return 0x82095F6C;
		  /* 82095F6Ch */ case   10:  		/* bc 12, CR6_EQ, 48 */
		/* 82095F6Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x82095F9C;  }
		/* 82095F6Ch case   10:*/		return 0x82095F70;
		  /* 82095F70h */ case   11:  		/* rlwinm. R9, R25, 0, 20, 20 */
		/* 82095F70h case   11:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R9,regs.R25);
		/* 82095F70h case   11:*/		return 0x82095F74;
		  /* 82095F74h */ case   12:  		/* mr R27, R10 */
		/* 82095F74h case   12:*/		regs.R27 = regs.R10;
		/* 82095F74h case   12:*/		return 0x82095F78;
		  /* 82095F78h */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 82095F78h case   13:*/		if ( regs.CR[0].eq ) { return 0x82095F90;  }
		/* 82095F78h case   13:*/		return 0x82095F7C;
		  /* 82095F7Ch */ case   14:  		/* lha R11, <#[R11]> */
		/* 82095F7Ch case   14:*/		cpu::mem::load16a( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82095F7Ch case   14:*/		return 0x82095F80;
		  /* 82095F80h */ case   15:  		/* li R20, 1 */
		/* 82095F80h case   15:*/		cpu::op::li<0>(regs,&regs.R20,0x1);
		/* 82095F80h case   15:*/		return 0x82095F84;
		  /* 82095F84h */ case   16:  		/* srawi R11, R11, 1 */
		/* 82095F84h case   16:*/		cpu::op::srawi<0,1>(regs,&regs.R11,regs.R11);
		/* 82095F84h case   16:*/		return 0x82095F88;
		  /* 82095F88h */ case   17:  		/* addze R26, R11 */
		/* 82095F88h case   17:*/		cpu::op::addze<0>(regs,&regs.R26,regs.R11);
		/* 82095F88h case   17:*/		return 0x82095F8C;
		  /* 82095F8Ch */ case   18:  		/* b 1080 */
		/* 82095F8Ch case   18:*/		return 0x820963C4;
		/* 82095F8Ch case   18:*/		return 0x82095F90;
	}
	return 0x82095F90;
} // Block from 82095F44h-82095F90h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82095F90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095F90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095F90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095F90);
		  /* 82095F90h */ case    0:  		/* lha R26, <#[R11]> */
		/* 82095F90h case    0:*/		cpu::mem::load16a( regs, &regs.R26, (uint32)(regs.R11 + 0x00000000) );
		/* 82095F90h case    0:*/		return 0x82095F94;
		  /* 82095F94h */ case    1:  		/* li R20, 0 */
		/* 82095F94h case    1:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 82095F94h case    1:*/		return 0x82095F98;
		  /* 82095F98h */ case    2:  		/* b 1068 */
		/* 82095F98h case    2:*/		return 0x820963C4;
		/* 82095F98h case    2:*/		return 0x82095F9C;
	}
	return 0x82095F9C;
} // Block from 82095F90h-82095F9Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82095F9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095F9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095F9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095F9C);
		  /* 82095F9Ch */ case    0:  		/* lis R10, -32255 */
		/* 82095F9Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 82095F9Ch case    0:*/		return 0x82095FA0;
		  /* 82095FA0h */ case    1:  		/* lwz R27, <#[R10 - 21808]> */
		/* 82095FA0h case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R10 + 0xFFFFAAD0) );
		/* 82095FA0h case    1:*/		return 0x82095FA4;
		  /* 82095FA4h */ case    2:  		/* mr R11, R27 */
		/* 82095FA4h case    2:*/		regs.R11 = regs.R27;
		/* 82095FA4h case    2:*/		return 0x82095FA8;
		  /* 82095FA8h */ case    3:  		/* mr R10, R27 */
		/* 82095FA8h case    3:*/		regs.R10 = regs.R27;
		/* 82095FA8h case    3:*/		return 0x82095FAC;
		  /* 82095FACh */ case    4:  		/* lbz R9, <#[R11]> */
		/* 82095FACh case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82095FACh case    4:*/		return 0x82095FB0;
		  /* 82095FB0h */ case    5:  		/* addi R11, R11, 1 */
		/* 82095FB0h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82095FB0h case    5:*/		return 0x82095FB4;
		  /* 82095FB4h */ case    6:  		/* cmplwi CR6, R9, 0 */
		/* 82095FB4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82095FB4h case    6:*/		return 0x82095FB8;
		  /* 82095FB8h */ case    7:  		/* bc 4, CR6_EQ, -12 */
		/* 82095FB8h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82095FAC;  }
		/* 82095FB8h case    7:*/		return 0x82095FBC;
		  /* 82095FBCh */ case    8:  		/* subf R11, R10, R11 */
		/* 82095FBCh case    8:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82095FBCh case    8:*/		return 0x82095FC0;
		  /* 82095FC0h */ case    9:  		/* addi R11, R11, -1 */
		/* 82095FC0h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82095FC0h case    9:*/		return 0x82095FC4;
		  /* 82095FC4h */ case   10:  		/* rlwinm R26, R11, 0, 0, 31 */
		/* 82095FC4h case   10:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R26,regs.R11);
		/* 82095FC4h case   10:*/		return 0x82095FC8;
		  /* 82095FC8h */ case   11:  		/* b 1020 */
		/* 82095FC8h case   11:*/		return 0x820963C4;
		/* 82095FC8h case   11:*/		return 0x82095FCC;
		  /* 82095FCCh */ case   12:  		/* andi. R11, R25, 2096 */
		/* 82095FCCh case   12:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R25,0x830);
		/* 82095FCCh case   12:*/		return 0x82095FD0;
		  /* 82095FD0h */ case   13:  		/* cmpwi CR0, R11, 0 */
		/* 82095FD0h case   13:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 82095FD0h case   13:*/		return 0x82095FD4;
		  /* 82095FD4h */ case   14:  		/* bc 4, CR0_EQ, 8 */
		/* 82095FD4h case   14:*/		if ( !regs.CR[0].eq ) { return 0x82095FDC;  }
		/* 82095FD4h case   14:*/		return 0x82095FD8;
		  /* 82095FD8h */ case   15:  		/* ori R25, R25, 32 */
		/* 82095FD8h case   15:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x20);
		/* 82095FD8h case   15:*/		return 0x82095FDC;
	}
	return 0x82095FDC;
} // Block from 82095F9Ch-82095FDCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 82095FDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095FDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095FDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095FDC);
		  /* 82095FDCh */ case    0:  		/* cmpwi CR6, R23, -1 */
		/* 82095FDCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R23,0xFFFFFFFF);
		/* 82095FDCh case    0:*/		return 0x82095FE0;
		  /* 82095FE0h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 82095FE0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82095FF0;  }
		/* 82095FE0h case    1:*/		return 0x82095FE4;
		  /* 82095FE4h */ case    2:  		/* lis R30, 32767 */
		/* 82095FE4h case    2:*/		cpu::op::lis<0>(regs,&regs.R30,0x7FFF);
		/* 82095FE4h case    2:*/		return 0x82095FE8;
		  /* 82095FE8h */ case    3:  		/* ori R30, R30, 65535 */
		/* 82095FE8h case    3:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0xFFFF);
		/* 82095FE8h case    3:*/		return 0x82095FEC;
		  /* 82095FECh */ case    4:  		/* b 8 */
		/* 82095FECh case    4:*/		return 0x82095FF4;
		/* 82095FECh case    4:*/		return 0x82095FF0;
	}
	return 0x82095FF0;
} // Block from 82095FDCh-82095FF0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82095FF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095FF0);
		  /* 82095FF0h */ case    0:  		/* mr R30, R23 */
		/* 82095FF0h case    0:*/		regs.R30 = regs.R23;
		/* 82095FF0h case    0:*/		return 0x82095FF4;
	}
	return 0x82095FF4;
} // Block from 82095FF0h-82095FF4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82095FF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82095FF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82095FF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82095FF4);
		  /* 82095FF4h */ case    0:  		/* addi R11, R24, 7 */
		/* 82095FF4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x7);
		/* 82095FF4h case    0:*/		return 0x82095FF8;
		  /* 82095FF8h */ case    1:  		/* rlwinm. R10, R25, 0, 26, 26 */
		/* 82095FF8h case    1:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R10,regs.R25);
		/* 82095FF8h case    1:*/		return 0x82095FFC;
		  /* 82095FFCh */ case    2:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82095FFCh case    2:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82095FFCh case    2:*/		return 0x82096000;
		  /* 82096000h */ case    3:  		/* addi R24, R11, 8 */
		/* 82096000h case    3:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x8);
		/* 82096000h case    3:*/		return 0x82096004;
		  /* 82096004h */ case    4:  		/* lwz R27, <#[R11 + 4]> */
		/* 82096004h case    4:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000004) );
		/* 82096004h case    4:*/		return 0x82096008;
		  /* 82096008h */ case    5:  		/* cmplwi CR6, R27, 0 */
		/* 82096008h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82096008h case    5:*/		return 0x8209600C;
		  /* 8209600Ch */ case    6:  		/* bc 12, CR0_EQ, 88 */
		/* 8209600Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x82096064;  }
		/* 8209600Ch case    6:*/		return 0x82096010;
		  /* 82096010h */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 82096010h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8209601C;  }
		/* 82096010h case    7:*/		return 0x82096014;
		  /* 82096014h */ case    8:  		/* lis R11, -32255 */
		/* 82096014h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82096014h case    8:*/		return 0x82096018;
		  /* 82096018h */ case    9:  		/* lwz R27, <#[R11 - 21808]> */
		/* 82096018h case    9:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0xFFFFAAD0) );
		/* 82096018h case    9:*/		return 0x8209601C;
	}
	return 0x8209601C;
} // Block from 82095FF4h-8209601Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209601Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209601C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209601C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209601C);
		  /* 8209601Ch */ case    0:  		/* mr R31, R27 */
		/* 8209601Ch case    0:*/		regs.R31 = regs.R27;
		/* 8209601Ch case    0:*/		return 0x82096020;
		  /* 82096020h */ case    1:  		/* li R26, 0 */
		/* 82096020h case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82096020h case    1:*/		return 0x82096024;
		  /* 82096024h */ case    2:  		/* cmpwi CR6, R30, 0 */
		/* 82096024h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82096024h case    2:*/		return 0x82096028;
		  /* 82096028h */ case    3:  		/* bc 4, CR6_GT, 924 */
		/* 82096028h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820963C4;  }
		/* 82096028h case    3:*/		return 0x8209602C;
		  /* 8209602Ch */ case    4:  		/* lbz R11, <#[R31]> */
		/* 8209602Ch case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209602Ch case    4:*/		return 0x82096030;
		  /* 82096030h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 82096030h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82096030h case    5:*/		return 0x82096034;
		  /* 82096034h */ case    6:  		/* bc 12, CR0_EQ, 912 */
		/* 82096034h case    6:*/		if ( regs.CR[0].eq ) { return 0x820963C4;  }
		/* 82096034h case    6:*/		return 0x82096038;
		  /* 82096038h */ case    7:  		/* mr R4, R22 */
		/* 82096038h case    7:*/		regs.R4 = regs.R22;
		/* 82096038h case    7:*/		return 0x8209603C;
		  /* 8209603Ch */ case    8:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 8209603Ch case    8:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 8209603Ch case    8:*/		return 0x82096040;
		  /* 82096040h */ case    9:  		/* bl 20024 */
		/* 82096040h case    9:*/		regs.LR = 0x82096044; return 0x8209AE78;
		/* 82096040h case    9:*/		return 0x82096044;
		  /* 82096044h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 82096044h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82096044h case   10:*/		return 0x82096048;
		  /* 82096048h */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 82096048h case   11:*/		if ( regs.CR[0].eq ) { return 0x82096050;  }
		/* 82096048h case   11:*/		return 0x8209604C;
		  /* 8209604Ch */ case   12:  		/* addi R31, R31, 1 */
		/* 8209604Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8209604Ch case   12:*/		return 0x82096050;
	}
	return 0x82096050;
} // Block from 8209601Ch-82096050h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82096050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096050);
		  /* 82096050h */ case    0:  		/* addi R26, R26, 1 */
		/* 82096050h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 82096050h case    0:*/		return 0x82096054;
		  /* 82096054h */ case    1:  		/* addi R31, R31, 1 */
		/* 82096054h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82096054h case    1:*/		return 0x82096058;
		  /* 82096058h */ case    2:  		/* cmpw CR6, R26, R30 */
		/* 82096058h case    2:*/		cpu::op::cmpw<6>(regs,regs.R26,regs.R30);
		/* 82096058h case    2:*/		return 0x8209605C;
		  /* 8209605Ch */ case    3:  		/* bc 12, CR6_LT, -48 */
		/* 8209605Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8209602C;  }
		/* 8209605Ch case    3:*/		return 0x82096060;
		  /* 82096060h */ case    4:  		/* b 868 */
		/* 82096060h case    4:*/		return 0x820963C4;
		/* 82096060h case    4:*/		return 0x82096064;
	}
	return 0x82096064;
} // Block from 82096050h-82096064h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82096064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096064);
		  /* 82096064h */ case    0:  		/* bc 4, CR6_EQ, 12 */
		/* 82096064h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82096070;  }
		/* 82096064h case    0:*/		return 0x82096068;
		  /* 82096068h */ case    1:  		/* lis R11, -32255 */
		/* 82096068h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82096068h case    1:*/		return 0x8209606C;
		  /* 8209606Ch */ case    2:  		/* lwz R27, <#[R11 - 21804]> */
		/* 8209606Ch case    2:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0xFFFFAAD4) );
		/* 8209606Ch case    2:*/		return 0x82096070;
	}
	return 0x82096070;
} // Block from 82096064h-82096070h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82096070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096070);
		  /* 82096070h */ case    0:  		/* li R20, 1 */
		/* 82096070h case    0:*/		cpu::op::li<0>(regs,&regs.R20,0x1);
		/* 82096070h case    0:*/		return 0x82096074;
		  /* 82096074h */ case    1:  		/* mr R11, R27 */
		/* 82096074h case    1:*/		regs.R11 = regs.R27;
		/* 82096074h case    1:*/		return 0x82096078;
		  /* 82096078h */ case    2:  		/* b 24 */
		/* 82096078h case    2:*/		return 0x82096090;
		/* 82096078h case    2:*/		return 0x8209607C;
		  /* 8209607Ch */ case    3:  		/* lhz R10, <#[R11]> */
		/* 8209607Ch case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209607Ch case    3:*/		return 0x82096080;
		  /* 82096080h */ case    4:  		/* addi R30, R30, -1 */
		/* 82096080h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 82096080h case    4:*/		return 0x82096084;
		  /* 82096084h */ case    5:  		/* cmplwi CR0, R10, 0 */
		/* 82096084h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 82096084h case    5:*/		return 0x82096088;
		  /* 82096088h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 82096088h case    6:*/		if ( regs.CR[0].eq ) { return 0x82096098;  }
		/* 82096088h case    6:*/		return 0x8209608C;
		  /* 8209608Ch */ case    7:  		/* addi R11, R11, 2 */
		/* 8209608Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8209608Ch case    7:*/		return 0x82096090;
	}
	return 0x82096090;
} // Block from 82096070h-82096090h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82096090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096090);
		  /* 82096090h */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 82096090h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82096090h case    0:*/		return 0x82096094;
		  /* 82096094h */ case    1:  		/* bc 4, CR6_EQ, -24 */
		/* 82096094h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209607C;  }
		/* 82096094h case    1:*/		return 0x82096098;
	}
	return 0x82096098;
} // Block from 82096090h-82096098h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82096098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096098);
		  /* 82096098h */ case    0:  		/* subf R11, R27, R11 */
		/* 82096098h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R27,regs.R11);
		/* 82096098h case    0:*/		return 0x8209609C;
		  /* 8209609Ch */ case    1:  		/* srawi R26, R11, 1 */
		/* 8209609Ch case    1:*/		cpu::op::srawi<0,1>(regs,&regs.R26,regs.R11);
		/* 8209609Ch case    1:*/		return 0x820960A0;
		  /* 820960A0h */ case    2:  		/* b 804 */
		/* 820960A0h case    2:*/		return 0x820963C4;
		/* 820960A0h case    2:*/		return 0x820960A4;
		  /* 820960A4h */ case    3:  		/* addi R11, R24, 7 */
		/* 820960A4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x7);
		/* 820960A4h case    3:*/		return 0x820960A8;
		  /* 820960A8h */ case    4:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 820960A8h case    4:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 820960A8h case    4:*/		return 0x820960AC;
		  /* 820960ACh */ case    5:  		/* addi R24, R11, 8 */
		/* 820960ACh case    5:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x8);
		/* 820960ACh case    5:*/		return 0x820960B0;
		  /* 820960B0h */ case    6:  		/* lwz R31, <#[R11 + 4]> */
		/* 820960B0h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 820960B0h case    6:*/		return 0x820960B4;
		  /* 820960B4h */ case    7:  		/* bl 19868 */
		/* 820960B4h case    7:*/		regs.LR = 0x820960B8; return 0x8209AE50;
		/* 820960B4h case    7:*/		return 0x820960B8;
		  /* 820960B8h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 820960B8h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820960B8h case    8:*/		return 0x820960BC;
		  /* 820960BCh */ case    9:  		/* bc 12, CR0_EQ, -1276 */
		/* 820960BCh case    9:*/		if ( regs.CR[0].eq ) { return 0x82095BC0;  }
		/* 820960BCh case    9:*/		return 0x820960C0;
		  /* 820960C0h */ case   10:  		/* rlwinm. R11, R25, 0, 26, 26 */
		/* 820960C0h case   10:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R25);
		/* 820960C0h case   10:*/		return 0x820960C4;
		  /* 820960C4h */ case   11:  		/* bc 12, CR0_EQ, 12 */
		/* 820960C4h case   11:*/		if ( regs.CR[0].eq ) { return 0x820960D0;  }
		/* 820960C4h case   11:*/		return 0x820960C8;
		  /* 820960C8h */ case   12:  		/* sth R21, <#[R31]> */
		/* 820960C8h case   12:*/		cpu::mem::store16( regs, regs.R21, (uint32)(regs.R31 + 0x00000000) );
		/* 820960C8h case   12:*/		return 0x820960CC;
		  /* 820960CCh */ case   13:  		/* b 8 */
		/* 820960CCh case   13:*/		return 0x820960D4;
		/* 820960CCh case   13:*/		return 0x820960D0;
	}
	return 0x820960D0;
} // Block from 82096098h-820960D0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820960D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820960D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820960D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820960D0);
		  /* 820960D0h */ case    0:  		/* stw R21, <#[R31]> */
		/* 820960D0h case    0:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R31 + 0x00000000) );
		/* 820960D0h case    0:*/		return 0x820960D4;
	}
	return 0x820960D4;
} // Block from 820960D0h-820960D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820960D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820960D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820960D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820960D4);
		  /* 820960D4h */ case    0:  		/* li R11, 1 */
		/* 820960D4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820960D4h case    0:*/		return 0x820960D8;
		  /* 820960D8h */ case    1:  		/* stw R11, <#[R1 + 100]> */
		/* 820960D8h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 820960D8h case    1:*/		return 0x820960DC;
		  /* 820960DCh */ case    2:  		/* b 1168 */
		/* 820960DCh case    2:*/		return 0x8209656C;
		/* 820960DCh case    2:*/		return 0x820960E0;
		  /* 820960E0h */ case    3:  		/* addi R11, R8, 32 */
		/* 820960E0h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0x20);
		/* 820960E0h case    3:*/		return 0x820960E4;
		  /* 820960E4h */ case    4:  		/* li R18, 1 */
		/* 820960E4h case    4:*/		cpu::op::li<0>(regs,&regs.R18,0x1);
		/* 820960E4h case    4:*/		return 0x820960E8;
	}
	return 0x820960E8;
} // Block from 820960D4h-820960E8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820960E8h
// Function 'write_string'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820960E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820960E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820960E8);
		  /* 820960E8h */ case    0:  		/* rlwinm R29, R11, 0, 16, 31 */
		/* 820960E8h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R29,regs.R11);
		/* 820960E8h case    0:*/		return 0x820960EC;
		  /* 820960ECh */ case    1:  		/* ori R25, R25, 64 */
		/* 820960ECh case    1:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x40);
		/* 820960ECh case    1:*/		return 0x820960F0;
		  /* 820960F0h */ case    2:  		/* addi R27, R1, 128 */
		/* 820960F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R1,0x80);
		/* 820960F0h case    2:*/		return 0x820960F4;
		  /* 820960F4h */ case    3:  		/* li R30, 512 */
		/* 820960F4h case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x200);
		/* 820960F4h case    3:*/		return 0x820960F8;
		  /* 820960F8h */ case    4:  		/* cmpwi CR6, R23, 0 */
		/* 820960F8h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 820960F8h case    4:*/		return 0x820960FC;
		  /* 820960FCh */ case    5:  		/* bc 4, CR6_LT, 12 */
		/* 820960FCh case    5:*/		if ( !regs.CR[6].lt ) { return 0x82096108;  }
		/* 820960FCh case    5:*/		return 0x82096100;
		  /* 82096100h */ case    6:  		/* li R23, 6 */
		/* 82096100h case    6:*/		cpu::op::li<0>(regs,&regs.R23,0x6);
		/* 82096100h case    6:*/		return 0x82096104;
		  /* 82096104h */ case    7:  		/* b 88 */
		/* 82096104h case    7:*/		return 0x8209615C;
		/* 82096104h case    7:*/		return 0x82096108;
	}
	return 0x82096108;
} // Block from 820960E8h-82096108h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82096108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096108);
		  /* 82096108h */ case    0:  		/* bc 4, CR6_EQ, 24 */
		/* 82096108h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82096120;  }
		/* 82096108h case    0:*/		return 0x8209610C;
		  /* 8209610Ch */ case    1:  		/* rlwinm R11, R29, 0, 16, 31 */
		/* 8209610Ch case    1:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R29);
		/* 8209610Ch case    1:*/		return 0x82096110;
		  /* 82096110h */ case    2:  		/* cmplwi CR6, R11, 103 */
		/* 82096110h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000067);
		/* 82096110h case    2:*/		return 0x82096114;
		  /* 82096114h */ case    3:  		/* bc 4, CR6_EQ, 72 */
		/* 82096114h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8209615C;  }
		/* 82096114h case    3:*/		return 0x82096118;
		  /* 82096118h */ case    4:  		/* li R23, 1 */
		/* 82096118h case    4:*/		cpu::op::li<0>(regs,&regs.R23,0x1);
		/* 82096118h case    4:*/		return 0x8209611C;
		  /* 8209611Ch */ case    5:  		/* b 64 */
		/* 8209611Ch case    5:*/		return 0x8209615C;
		/* 8209611Ch case    5:*/		return 0x82096120;
	}
	return 0x82096120;
} // Block from 82096108h-82096120h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82096120h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096120);
		  /* 82096120h */ case    0:  		/* cmpwi CR6, R23, 512 */
		/* 82096120h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000200);
		/* 82096120h case    0:*/		return 0x82096124;
		  /* 82096124h */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 82096124h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8209612C;  }
		/* 82096124h case    1:*/		return 0x82096128;
		  /* 82096128h */ case    2:  		/* li R23, 512 */
		/* 82096128h case    2:*/		cpu::op::li<0>(regs,&regs.R23,0x200);
		/* 82096128h case    2:*/		return 0x8209612C;
	}
	return 0x8209612C;
} // Block from 82096120h-8209612Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209612Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209612C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209612C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209612C);
		  /* 8209612Ch */ case    0:  		/* cmpwi CR6, R23, 163 */
		/* 8209612Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x000000A3);
		/* 8209612Ch case    0:*/		return 0x82096130;
		  /* 82096130h */ case    1:  		/* bc 4, CR6_GT, 44 */
		/* 82096130h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8209615C;  }
		/* 82096130h case    1:*/		return 0x82096134;
		  /* 82096134h */ case    2:  		/* addi R31, R23, 349 */
		/* 82096134h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R23,0x15D);
		/* 82096134h case    2:*/		return 0x82096138;
		  /* 82096138h */ case    3:  		/* mr R3, R31 */
		/* 82096138h case    3:*/		regs.R3 = regs.R31;
		/* 82096138h case    3:*/		return 0x8209613C;
		  /* 8209613Ch */ case    4:  		/* bl -10420 */
		/* 8209613Ch case    4:*/		regs.LR = 0x82096140; return 0x82093888;
		/* 8209613Ch case    4:*/		return 0x82096140;
		  /* 82096140h */ case    5:  		/* stw R3, <#[R1 + 108]> */
		/* 82096140h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x0000006C) );
		/* 82096140h case    5:*/		return 0x82096144;
		  /* 82096144h */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 82096144h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82096144h case    6:*/		return 0x82096148;
		  /* 82096148h */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 82096148h case    7:*/		if ( regs.CR[0].eq ) { return 0x82096158;  }
		/* 82096148h case    7:*/		return 0x8209614C;
		  /* 8209614Ch */ case    8:  		/* mr R27, R3 */
		/* 8209614Ch case    8:*/		regs.R27 = regs.R3;
		/* 8209614Ch case    8:*/		return 0x82096150;
		  /* 82096150h */ case    9:  		/* mr R30, R31 */
		/* 82096150h case    9:*/		regs.R30 = regs.R31;
		/* 82096150h case    9:*/		return 0x82096154;
		  /* 82096154h */ case   10:  		/* b 8 */
		/* 82096154h case   10:*/		return 0x8209615C;
		/* 82096154h case   10:*/		return 0x82096158;
	}
	return 0x82096158;
} // Block from 8209612Ch-82096158h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82096158h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096158);
		  /* 82096158h */ case    0:  		/* li R23, 163 */
		/* 82096158h case    0:*/		cpu::op::li<0>(regs,&regs.R23,0xA3);
		/* 82096158h case    0:*/		return 0x8209615C;
	}
	return 0x8209615C;
} // Block from 82096158h-8209615Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209615Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209615C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209615C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209615C);
		  /* 8209615Ch */ case    0:  		/* addi R11, R24, 7 */
		/* 8209615Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x7);
		/* 8209615Ch case    0:*/		return 0x82096160;
		  /* 82096160h */ case    1:  		/* lwz R10, <#[R19 + 24]> */
		/* 82096160h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R19 + 0x00000018) );
		/* 82096160h case    1:*/		return 0x82096164;
		  /* 82096164h */ case    2:  		/* mr R9, R22 */
		/* 82096164h case    2:*/		regs.R9 = regs.R22;
		/* 82096164h case    2:*/		return 0x82096168;
		  /* 82096168h */ case    3:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82096168h case    3:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82096168h case    3:*/		return 0x8209616C;
		  /* 8209616Ch */ case    4:  		/* mr R8, R18 */
		/* 8209616Ch case    4:*/		regs.R8 = regs.R18;
		/* 8209616Ch case    4:*/		return 0x82096170;
		  /* 82096170h */ case    5:  		/* mr R7, R23 */
		/* 82096170h case    5:*/		regs.R7 = regs.R23;
		/* 82096170h case    5:*/		return 0x82096174;
		  /* 82096174h */ case    6:  		/* mtspr CTR, R10 */
		/* 82096174h case    6:*/		regs.CTR = regs.R10;
		/* 82096174h case    6:*/		return 0x82096178;
		  /* 82096178h */ case    7:  		/* extsb R6, R29 */
		/* 82096178h case    7:*/		cpu::op::extsb<0>(regs,&regs.R6,regs.R29);
		/* 82096178h case    7:*/		return 0x8209617C;
		  /* 8209617Ch */ case    8:  		/* mr R5, R30 */
		/* 8209617Ch case    8:*/		regs.R5 = regs.R30;
		/* 8209617Ch case    8:*/		return 0x82096180;
		  /* 82096180h */ case    9:  		/* ld R10, <#[R11]> */
		/* 82096180h case    9:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82096180h case    9:*/		return 0x82096184;
		  /* 82096184h */ case   10:  		/* mr R4, R27 */
		/* 82096184h case   10:*/		regs.R4 = regs.R27;
		/* 82096184h case   10:*/		return 0x82096188;
		  /* 82096188h */ case   11:  		/* addi R3, R1, 120 */
		/* 82096188h case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x78);
		/* 82096188h case   11:*/		return 0x8209618C;
		  /* 8209618Ch */ case   12:  		/* addi R24, R11, 8 */
		/* 8209618Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x8);
		/* 8209618Ch case   12:*/		return 0x82096190;
		  /* 82096190h */ case   13:  		/* std R10, <#[R1 + 120]> */
		/* 82096190h case   13:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000078) );
		/* 82096190h case   13:*/		return 0x82096194;
		  /* 82096194h */ case   14:  		/* bcctrl 20, CR0_LT */
		/* 82096194h case   14:*/		if ( 1 ) { regs.LR = 0x82096198; return (uint32)regs.CTR; }
		/* 82096194h case   14:*/		return 0x82096198;
		  /* 82096198h */ case   15:  		/* rlwinm. R31, R25, 0, 24, 24 */
		/* 82096198h case   15:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R31,regs.R25);
		/* 82096198h case   15:*/		return 0x8209619C;
		  /* 8209619Ch */ case   16:  		/* bc 12, CR0_EQ, 32 */
		/* 8209619Ch case   16:*/		if ( regs.CR[0].eq ) { return 0x820961BC;  }
		/* 8209619Ch case   16:*/		return 0x820961A0;
		  /* 820961A0h */ case   17:  		/* cmpwi CR6, R23, 0 */
		/* 820961A0h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 820961A0h case   17:*/		return 0x820961A4;
		  /* 820961A4h */ case   18:  		/* bc 4, CR6_EQ, 24 */
		/* 820961A4h case   18:*/		if ( !regs.CR[6].eq ) { return 0x820961BC;  }
		/* 820961A4h case   18:*/		return 0x820961A8;
		  /* 820961A8h */ case   19:  		/* lwz R11, <#[R19 + 36]> */
		/* 820961A8h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000024) );
		/* 820961A8h case   19:*/		return 0x820961AC;
		  /* 820961ACh */ case   20:  		/* mr R4, R22 */
		/* 820961ACh case   20:*/		regs.R4 = regs.R22;
		/* 820961ACh case   20:*/		return 0x820961B0;
		  /* 820961B0h */ case   21:  		/* mr R3, R27 */
		/* 820961B0h case   21:*/		regs.R3 = regs.R27;
		/* 820961B0h case   21:*/		return 0x820961B4;
		  /* 820961B4h */ case   22:  		/* mtspr CTR, R11 */
		/* 820961B4h case   22:*/		regs.CTR = regs.R11;
		/* 820961B4h case   22:*/		return 0x820961B8;
	}
	return 0x820961B8;
} // Block from 8209615Ch-820961B8h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820961B8h
// Function '_output_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820961B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820961B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820961B8);
		  /* 820961B8h */ case    0:  		/* bcctrl 20, CR0_LT */
		/* 820961B8h case    0:*/		if ( 1 ) { regs.LR = 0x820961BC; return (uint32)regs.CTR; }
		/* 820961B8h case    0:*/		return 0x820961BC;
	}
	return 0x820961BC;
} // Block from 820961B8h-820961BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820961BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820961BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820961BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820961BC);
		  /* 820961BCh */ case    0:  		/* rlwinm R11, R29, 0, 16, 31 */
		/* 820961BCh case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R29);
		/* 820961BCh case    0:*/		return 0x820961C0;
		  /* 820961C0h */ case    1:  		/* cmplwi CR6, R11, 103 */
		/* 820961C0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000067);
		/* 820961C0h case    1:*/		return 0x820961C4;
		  /* 820961C4h */ case    2:  		/* bc 4, CR6_EQ, 32 */
		/* 820961C4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820961E4;  }
		/* 820961C4h case    2:*/		return 0x820961C8;
		  /* 820961C8h */ case    3:  		/* cmpwi CR6, R31, 0 */
		/* 820961C8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 820961C8h case    3:*/		return 0x820961CC;
		  /* 820961CCh */ case    4:  		/* bc 4, CR6_EQ, 24 */
		/* 820961CCh case    4:*/		if ( !regs.CR[6].eq ) { return 0x820961E4;  }
		/* 820961CCh case    4:*/		return 0x820961D0;
		  /* 820961D0h */ case    5:  		/* lwz R11, <#[R19 + 32]> */
		/* 820961D0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000020) );
		/* 820961D0h case    5:*/		return 0x820961D4;
		  /* 820961D4h */ case    6:  		/* mr R4, R22 */
		/* 820961D4h case    6:*/		regs.R4 = regs.R22;
		/* 820961D4h case    6:*/		return 0x820961D8;
		  /* 820961D8h */ case    7:  		/* mr R3, R27 */
		/* 820961D8h case    7:*/		regs.R3 = regs.R27;
		/* 820961D8h case    7:*/		return 0x820961DC;
		  /* 820961DCh */ case    8:  		/* mtspr CTR, R11 */
		/* 820961DCh case    8:*/		regs.CTR = regs.R11;
		/* 820961DCh case    8:*/		return 0x820961E0;
		  /* 820961E0h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820961E0h case    9:*/		if ( 1 ) { regs.LR = 0x820961E4; return (uint32)regs.CTR; }
		/* 820961E0h case    9:*/		return 0x820961E4;
	}
	return 0x820961E4;
} // Block from 820961BCh-820961E4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820961E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820961E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820961E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820961E4);
		  /* 820961E4h */ case    0:  		/* lbz R11, <#[R27]> */
		/* 820961E4h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820961E4h case    0:*/		return 0x820961E8;
		  /* 820961E8h */ case    1:  		/* cmplwi CR6, R11, 45 */
		/* 820961E8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002D);
		/* 820961E8h case    1:*/		return 0x820961EC;
		  /* 820961ECh */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 820961ECh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820961F8;  }
		/* 820961ECh case    2:*/		return 0x820961F0;
		  /* 820961F0h */ case    3:  		/* ori R25, R25, 256 */
		/* 820961F0h case    3:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x100);
		/* 820961F0h case    3:*/		return 0x820961F4;
		  /* 820961F4h */ case    4:  		/* addi R27, R27, 1 */
		/* 820961F4h case    4:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 820961F4h case    4:*/		return 0x820961F8;
	}
	return 0x820961F8;
} // Block from 820961E4h-820961F8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820961F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820961F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820961F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820961F8);
		  /* 820961F8h */ case    0:  		/* mr R11, R27 */
		/* 820961F8h case    0:*/		regs.R11 = regs.R27;
		/* 820961F8h case    0:*/		return 0x820961FC;
		  /* 820961FCh */ case    1:  		/* lbz R10, <#[R11]> */
		/* 820961FCh case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820961FCh case    1:*/		return 0x82096200;
		  /* 82096200h */ case    2:  		/* addi R11, R11, 1 */
		/* 82096200h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82096200h case    2:*/		return 0x82096204;
		  /* 82096204h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 82096204h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82096204h case    3:*/		return 0x82096208;
		  /* 82096208h */ case    4:  		/* bc 4, CR6_EQ, -12 */
		/* 82096208h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820961FC;  }
		/* 82096208h case    4:*/		return 0x8209620C;
		  /* 8209620Ch */ case    5:  		/* subf R11, R27, R11 */
		/* 8209620Ch case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R27,regs.R11);
		/* 8209620Ch case    5:*/		return 0x82096210;
		  /* 82096210h */ case    6:  		/* b -592 */
		/* 82096210h case    6:*/		return 0x82095FC0;
		/* 82096210h case    6:*/		return 0x82096214;
		  /* 82096214h */ case    7:  		/* ori R25, R25, 64 */
		/* 82096214h case    7:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x40);
		/* 82096214h case    7:*/		return 0x82096218;
		  /* 82096218h */ case    8:  		/* li R8, 10 */
		/* 82096218h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0xA);
		/* 82096218h case    8:*/		return 0x8209621C;
		  /* 8209621Ch */ case    9:  		/* b 76 */
		/* 8209621Ch case    9:*/		return 0x82096268;
		/* 8209621Ch case    9:*/		return 0x82096220;
		  /* 82096220h */ case   10:  		/* li R23, 8 */
		/* 82096220h case   10:*/		cpu::op::li<0>(regs,&regs.R23,0x8);
		/* 82096220h case   10:*/		return 0x82096224;
		  /* 82096224h */ case   11:  		/* li R11, 7 */
		/* 82096224h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 82096224h case   11:*/		return 0x82096228;
		  /* 82096228h */ case   12:  		/* b 8 */
		/* 82096228h case   12:*/		return 0x82096230;
		/* 82096228h case   12:*/		return 0x8209622C;
		  /* 8209622Ch */ case   13:  		/* li R11, 39 */
		/* 8209622Ch case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x27);
		/* 8209622Ch case   13:*/		return 0x82096230;
	}
	return 0x82096230;
} // Block from 820961F8h-82096230h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82096230h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096230);
		  /* 82096230h */ case    0:  		/* stw R11, <#[R1 + 112]> */
		/* 82096230h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 82096230h case    0:*/		return 0x82096234;
		  /* 82096234h */ case    1:  		/* rlwinm. R10, R25, 0, 24, 24 */
		/* 82096234h case    1:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R10,regs.R25);
		/* 82096234h case    1:*/		return 0x82096238;
		  /* 82096238h */ case    2:  		/* li R8, 16 */
		/* 82096238h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x10);
		/* 82096238h case    2:*/		return 0x8209623C;
		  /* 8209623Ch */ case    3:  		/* bc 12, CR0_EQ, 44 */
		/* 8209623Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x82096268;  }
		/* 8209623Ch case    3:*/		return 0x82096240;
		  /* 82096240h */ case    4:  		/* addi R11, R11, 81 */
		/* 82096240h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x51);
		/* 82096240h case    4:*/		return 0x82096244;
		  /* 82096244h */ case    5:  		/* li R10, 48 */
		/* 82096244h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x30);
		/* 82096244h case    5:*/		return 0x82096248;
		  /* 82096248h */ case    6:  		/* li R15, 2 */
		/* 82096248h case    6:*/		cpu::op::li<0>(regs,&regs.R15,0x2);
		/* 82096248h case    6:*/		return 0x8209624C;
		  /* 8209624Ch */ case    7:  		/* sth R11, <#[R1 + 90]> */
		/* 8209624Ch case    7:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x0000005A) );
		/* 8209624Ch case    7:*/		return 0x82096250;
		  /* 82096250h */ case    8:  		/* sth R10, <#[R1 + 88]> */
		/* 82096250h case    8:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82096250h case    8:*/		return 0x82096254;
		  /* 82096254h */ case    9:  		/* b 20 */
		/* 82096254h case    9:*/		return 0x82096268;
		/* 82096254h case    9:*/		return 0x82096258;
		  /* 82096258h */ case   10:  		/* rlwinm. R11, R25, 0, 24, 24 */
		/* 82096258h case   10:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R11,regs.R25);
		/* 82096258h case   10:*/		return 0x8209625C;
		  /* 8209625Ch */ case   11:  		/* li R8, 8 */
		/* 8209625Ch case   11:*/		cpu::op::li<0>(regs,&regs.R8,0x8);
		/* 8209625Ch case   11:*/		return 0x82096260;
		  /* 82096260h */ case   12:  		/* bc 12, CR0_EQ, 8 */
		/* 82096260h case   12:*/		if ( regs.CR[0].eq ) { return 0x82096268;  }
		/* 82096260h case   12:*/		return 0x82096264;
		  /* 82096264h */ case   13:  		/* ori R25, R25, 512 */
		/* 82096264h case   13:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x200);
		/* 82096264h case   13:*/		return 0x82096268;
	}
	return 0x82096268;
} // Block from 82096230h-82096268h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82096268h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096268);
		  /* 82096268h */ case    0:  		/* rlwinm. R11, R25, 0, 16, 16 */
		/* 82096268h case    0:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R11,regs.R25);
		/* 82096268h case    0:*/		return 0x8209626C;
		  /* 8209626Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 8209626Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x82096278;  }
		/* 8209626Ch case    1:*/		return 0x82096270;
		  /* 82096270h */ case    2:  		/* rlwinm. R11, R25, 0, 19, 19 */
		/* 82096270h case    2:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R11,regs.R25);
		/* 82096270h case    2:*/		return 0x82096274;
		  /* 82096274h */ case    3:  		/* bc 12, CR0_EQ, 24 */
		/* 82096274h case    3:*/		if ( regs.CR[0].eq ) { return 0x8209628C;  }
		/* 82096274h case    3:*/		return 0x82096278;
	}
	return 0x82096278;
} // Block from 82096268h-82096278h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82096278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096278);
		  /* 82096278h */ case    0:  		/* addi R11, R24, 7 */
		/* 82096278h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x7);
		/* 82096278h case    0:*/		return 0x8209627C;
		  /* 8209627Ch */ case    1:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 8209627Ch case    1:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 8209627Ch case    1:*/		return 0x82096280;
		  /* 82096280h */ case    2:  		/* addi R24, R11, 8 */
		/* 82096280h case    2:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x8);
		/* 82096280h case    2:*/		return 0x82096284;
		  /* 82096284h */ case    3:  		/* ld R11, <#[R11]> */
		/* 82096284h case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82096284h case    3:*/		return 0x82096288;
		  /* 82096288h */ case    4:  		/* b 84 */
		/* 82096288h case    4:*/		return 0x820962DC;
		/* 82096288h case    4:*/		return 0x8209628C;
	}
	return 0x8209628C;
} // Block from 82096278h-8209628Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209628Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209628C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209628C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209628C);
		  /* 8209628Ch */ case    0:  		/* rlwinm. R11, R25, 0, 26, 26 */
		/* 8209628Ch case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R25);
		/* 8209628Ch case    0:*/		return 0x82096290;
		  /* 82096290h */ case    1:  		/* bc 12, CR0_EQ, 44 */
		/* 82096290h case    1:*/		if ( regs.CR[0].eq ) { return 0x820962BC;  }
		/* 82096290h case    1:*/		return 0x82096294;
		  /* 82096294h */ case    2:  		/* rlwinm. R11, R25, 0, 25, 25 */
		/* 82096294h case    2:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R25);
		/* 82096294h case    2:*/		return 0x82096298;
		  /* 82096298h */ case    3:  		/* addi R11, R24, 7 */
		/* 82096298h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x7);
		/* 82096298h case    3:*/		return 0x8209629C;
		  /* 8209629Ch */ case    4:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 8209629Ch case    4:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 8209629Ch case    4:*/		return 0x820962A0;
		  /* 820962A0h */ case    5:  		/* addi R24, R11, 8 */
		/* 820962A0h case    5:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x8);
		/* 820962A0h case    5:*/		return 0x820962A4;
		  /* 820962A4h */ case    6:  		/* lwz R11, <#[R11 + 4]> */
		/* 820962A4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820962A4h case    6:*/		return 0x820962A8;
		  /* 820962A8h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 820962A8h case    7:*/		if ( regs.CR[0].eq ) { return 0x820962B4;  }
		/* 820962A8h case    7:*/		return 0x820962AC;
		  /* 820962ACh */ case    8:  		/* extsh R11, R11 */
		/* 820962ACh case    8:*/		cpu::op::extsh<0>(regs,&regs.R11,regs.R11);
		/* 820962ACh case    8:*/		return 0x820962B0;
		  /* 820962B0h */ case    9:  		/* b 44 */
		/* 820962B0h case    9:*/		return 0x820962DC;
		/* 820962B0h case    9:*/		return 0x820962B4;
	}
	return 0x820962B4;
} // Block from 8209628Ch-820962B4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820962B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820962B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820962B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820962B4);
		  /* 820962B4h */ case    0:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 820962B4h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 820962B4h case    0:*/		return 0x820962B8;
		  /* 820962B8h */ case    1:  		/* b 36 */
		/* 820962B8h case    1:*/		return 0x820962DC;
		/* 820962B8h case    1:*/		return 0x820962BC;
	}
	return 0x820962BC;
} // Block from 820962B4h-820962BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820962BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820962BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820962BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820962BC);
		  /* 820962BCh */ case    0:  		/* rlwinm. R11, R25, 0, 25, 25 */
		/* 820962BCh case    0:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R25);
		/* 820962BCh case    0:*/		return 0x820962C0;
		  /* 820962C0h */ case    1:  		/* addi R11, R24, 7 */
		/* 820962C0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x7);
		/* 820962C0h case    1:*/		return 0x820962C4;
		  /* 820962C4h */ case    2:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 820962C4h case    2:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 820962C4h case    2:*/		return 0x820962C8;
		  /* 820962C8h */ case    3:  		/* addi R24, R11, 8 */
		/* 820962C8h case    3:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x8);
		/* 820962C8h case    3:*/		return 0x820962CC;
		  /* 820962CCh */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 820962CCh case    4:*/		if ( regs.CR[0].eq ) { return 0x820962D8;  }
		/* 820962CCh case    4:*/		return 0x820962D0;
		  /* 820962D0h */ case    5:  		/* lwa R11, <#[R11 + 4]> */
		/* 820962D0h case    5:*/		cpu::mem::load32a( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820962D0h case    5:*/		return 0x820962D4;
		  /* 820962D4h */ case    6:  		/* b 8 */
		/* 820962D4h case    6:*/		return 0x820962DC;
		/* 820962D4h case    6:*/		return 0x820962D8;
	}
	return 0x820962D8;
} // Block from 820962BCh-820962D8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820962D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820962D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820962D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820962D8);
		  /* 820962D8h */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 820962D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820962D8h case    0:*/		return 0x820962DC;
	}
	return 0x820962DC;
} // Block from 820962D8h-820962DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820962DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820962DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820962DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820962DC);
		  /* 820962DCh */ case    0:  		/* rlwinm. R10, R25, 0, 25, 25 */
		/* 820962DCh case    0:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R25);
		/* 820962DCh case    0:*/		return 0x820962E0;
		  /* 820962E0h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 820962E0h case    1:*/		if ( regs.CR[0].eq ) { return 0x820962F4;  }
		/* 820962E0h case    1:*/		return 0x820962E4;
		  /* 820962E4h */ case    2:  		/* cmpdi CR6, R11, 0 */
		/* 820962E4h case    2:*/		cpu::op::cmpdi<6>(regs,regs.R11,0x00000000);
		/* 820962E4h case    2:*/		return 0x820962E8;
		  /* 820962E8h */ case    3:  		/* bc 4, CR6_LT, 12 */
		/* 820962E8h case    3:*/		if ( !regs.CR[6].lt ) { return 0x820962F4;  }
		/* 820962E8h case    3:*/		return 0x820962EC;
		  /* 820962ECh */ case    4:  		/* neg R11, R11 */
		/* 820962ECh case    4:*/		cpu::op::neg<0>(regs,&regs.R11,regs.R11);
		/* 820962ECh case    4:*/		return 0x820962F0;
		  /* 820962F0h */ case    5:  		/* ori R25, R25, 256 */
		/* 820962F0h case    5:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x100);
		/* 820962F0h case    5:*/		return 0x820962F4;
	}
	return 0x820962F4;
} // Block from 820962DCh-820962F4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820962F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820962F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820962F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820962F4);
		  /* 820962F4h */ case    0:  		/* rlwinm. R10, R25, 0, 16, 16 */
		/* 820962F4h case    0:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R10,regs.R25);
		/* 820962F4h case    0:*/		return 0x820962F8;
		  /* 820962F8h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 820962F8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82096308;  }
		/* 820962F8h case    1:*/		return 0x820962FC;
		  /* 820962FCh */ case    2:  		/* rlwinm. R10, R25, 0, 19, 19 */
		/* 820962FCh case    2:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R10,regs.R25);
		/* 820962FCh case    2:*/		return 0x82096300;
		  /* 82096300h */ case    3:  		/* bc 4, CR0_EQ, 8 */
		/* 82096300h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82096308;  }
		/* 82096300h case    3:*/		return 0x82096304;
		  /* 82096304h */ case    4:  		/* rldicl R11, R11, 0, 32 */
		/* 82096304h case    4:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R11);
		/* 82096304h case    4:*/		return 0x82096308;
	}
	return 0x82096308;
} // Block from 820962F4h-82096308h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82096308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096308);
		  /* 82096308h */ case    0:  		/* cmpwi CR6, R23, 0 */
		/* 82096308h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 82096308h case    0:*/		return 0x8209630C;
		  /* 8209630Ch */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 8209630Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x82096318;  }
		/* 8209630Ch case    1:*/		return 0x82096310;
		  /* 82096310h */ case    2:  		/* li R23, 1 */
		/* 82096310h case    2:*/		cpu::op::li<0>(regs,&regs.R23,0x1);
		/* 82096310h case    2:*/		return 0x82096314;
		  /* 82096314h */ case    3:  		/* b 20 */
		/* 82096314h case    3:*/		return 0x82096328;
		/* 82096314h case    3:*/		return 0x82096318;
	}
	return 0x82096318;
} // Block from 82096308h-82096318h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82096318h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096318);
		  /* 82096318h */ case    0:  		/* rlwinm R25, R25, 0, 29, 27 */
		/* 82096318h case    0:*/		cpu::op::rlwinm<0,0,29,27>(regs,&regs.R25,regs.R25);
		/* 82096318h case    0:*/		return 0x8209631C;
		  /* 8209631Ch */ case    1:  		/* cmpwi CR6, R23, 512 */
		/* 8209631Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000200);
		/* 8209631Ch case    1:*/		return 0x82096320;
		  /* 82096320h */ case    2:  		/* bc 4, CR6_GT, 8 */
		/* 82096320h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82096328;  }
		/* 82096320h case    2:*/		return 0x82096324;
		  /* 82096324h */ case    3:  		/* li R23, 512 */
		/* 82096324h case    3:*/		cpu::op::li<0>(regs,&regs.R23,0x200);
		/* 82096324h case    3:*/		return 0x82096328;
	}
	return 0x82096328;
} // Block from 82096318h-82096328h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82096328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096328);
		  /* 82096328h */ case    0:  		/* cmpldi CR6, R11, 0 */
		/* 82096328h case    0:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82096328h case    0:*/		return 0x8209632C;
		  /* 8209632Ch */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 8209632Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82096334;  }
		/* 8209632Ch case    1:*/		return 0x82096330;
		  /* 82096330h */ case    2:  		/* li R15, 0 */
		/* 82096330h case    2:*/		cpu::op::li<0>(regs,&regs.R15,0x0);
		/* 82096330h case    2:*/		return 0x82096334;
	}
	return 0x82096334;
} // Block from 82096328h-82096334h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82096334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096334);
		  /* 82096334h */ case    0:  		/* addi R9, R1, 639 */
		/* 82096334h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x27F);
		/* 82096334h case    0:*/		return 0x82096338;
		  /* 82096338h */ case    1:  		/* cmpwi CR6, R23, 0 */
		/* 82096338h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 82096338h case    1:*/		return 0x8209633C;
		  /* 8209633Ch */ case    2:  		/* addi R23, R23, -1 */
		/* 8209633Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0xFFFFFFFF);
		/* 8209633Ch case    2:*/		return 0x82096340;
		  /* 82096340h */ case    3:  		/* bc 12, CR6_GT, 12 */
		/* 82096340h case    3:*/		if ( regs.CR[6].gt ) { return 0x8209634C;  }
		/* 82096340h case    3:*/		return 0x82096344;
		  /* 82096344h */ case    4:  		/* cmpldi CR6, R11, 0 */
		/* 82096344h case    4:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82096344h case    4:*/		return 0x82096348;
		  /* 82096348h */ case    5:  		/* bc 12, CR6_EQ, 72 */
		/* 82096348h case    5:*/		if ( regs.CR[6].eq ) { return 0x82096390;  }
		/* 82096348h case    5:*/		return 0x8209634C;
	}
	return 0x8209634C;
} // Block from 82096334h-8209634Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209634Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209634C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209634C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209634C);
		  /* 8209634Ch */ case    0:  		/* extsw R10, R8 */
		/* 8209634Ch case    0:*/		cpu::op::extsw<0>(regs,&regs.R10,regs.R8);
		/* 8209634Ch case    0:*/		return 0x82096350;
		  /* 82096350h */ case    1:  		/* divdu R7, R11, R10 */
		/* 82096350h case    1:*/		cpu::op::divdu<0>(regs,&regs.R7,regs.R11,regs.R10);
		/* 82096350h case    1:*/		return 0x82096354;
		  /* 82096354h */ case    2:  		/* tdi 6, R10, 0 */
		/* 82096354h case    2:*/		cpu::op::td<6>(regs, 0x82096354, regs.R10, 0x00000000);
		/* 82096354h case    2:*/		return 0x82096358;
		  /* 82096358h */ case    3:  		/* mulld R7, R7, R10 */
		/* 82096358h case    3:*/		cpu::op::mulld<0>(regs,&regs.R7,regs.R7,regs.R10);
		/* 82096358h case    3:*/		return 0x8209635C;
		  /* 8209635Ch */ case    4:  		/* subf R7, R7, R11 */
		/* 8209635Ch case    4:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R7,regs.R11);
		/* 8209635Ch case    4:*/		return 0x82096360;
		  /* 82096360h */ case    5:  		/* divdu R11, R11, R10 */
		/* 82096360h case    5:*/		cpu::op::divdu<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82096360h case    5:*/		return 0x82096364;
		  /* 82096364h */ case    6:  		/* tdi 6, R10, 0 */
		/* 82096364h case    6:*/		cpu::op::td<6>(regs, 0x82096364, regs.R10, 0x00000000);
		/* 82096364h case    6:*/		return 0x82096368;
		  /* 82096368h */ case    7:  		/* rlwinm R10, R7, 0, 0, 31 */
		/* 82096368h case    7:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R7);
		/* 82096368h case    7:*/		return 0x8209636C;
		  /* 8209636Ch */ case    8:  		/* addi R10, R10, 48 */
		/* 8209636Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x30);
		/* 8209636Ch case    8:*/		return 0x82096370;
		  /* 82096370h */ case    9:  		/* cmpwi CR6, R10, 57 */
		/* 82096370h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000039);
		/* 82096370h case    9:*/		return 0x82096374;
		  /* 82096374h */ case   10:  		/* bc 4, CR6_GT, 12 */
		/* 82096374h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82096380;  }
		/* 82096374h case   10:*/		return 0x82096378;
		  /* 82096378h */ case   11:  		/* lwz R7, <#[R1 + 112]> */
		/* 82096378h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000070) );
		/* 82096378h case   11:*/		return 0x8209637C;
		  /* 8209637Ch */ case   12:  		/* add R10, R10, R7 */
		/* 8209637Ch case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 8209637Ch case   12:*/		return 0x82096380;
	}
	return 0x82096380;
} // Block from 8209634Ch-82096380h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82096380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096380);
		  /* 82096380h */ case    0:  		/* extsb R10, R10 */
		/* 82096380h case    0:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 82096380h case    0:*/		return 0x82096384;
		  /* 82096384h */ case    1:  		/* stb R10, <#[R9]> */
		/* 82096384h case    1:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 82096384h case    1:*/		return 0x82096388;
		  /* 82096388h */ case    2:  		/* addi R9, R9, -1 */
		/* 82096388h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82096388h case    2:*/		return 0x8209638C;
		  /* 8209638Ch */ case    3:  		/* b -84 */
		/* 8209638Ch case    3:*/		return 0x82096338;
		/* 8209638Ch case    3:*/		return 0x82096390;
	}
	return 0x82096390;
} // Block from 82096380h-82096390h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82096390h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096390);
		  /* 82096390h */ case    0:  		/* addi R11, R1, 639 */
		/* 82096390h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x27F);
		/* 82096390h case    0:*/		return 0x82096394;
		  /* 82096394h */ case    1:  		/* rlwinm. R10, R25, 0, 22, 22 */
		/* 82096394h case    1:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R10,regs.R25);
		/* 82096394h case    1:*/		return 0x82096398;
		  /* 82096398h */ case    2:  		/* subf R26, R9, R11 */
		/* 82096398h case    2:*/		cpu::op::subf<0>(regs,&regs.R26,regs.R9,regs.R11);
		/* 82096398h case    2:*/		return 0x8209639C;
		  /* 8209639Ch */ case    3:  		/* addi R27, R9, 1 */
		/* 8209639Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R9,0x1);
		/* 8209639Ch case    3:*/		return 0x820963A0;
		  /* 820963A0h */ case    4:  		/* bc 12, CR0_EQ, 36 */
		/* 820963A0h case    4:*/		if ( regs.CR[0].eq ) { return 0x820963C4;  }
		/* 820963A0h case    4:*/		return 0x820963A4;
		  /* 820963A4h */ case    5:  		/* cmpwi CR6, R26, 0 */
		/* 820963A4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 820963A4h case    5:*/		return 0x820963A8;
		  /* 820963A8h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 820963A8h case    6:*/		if ( regs.CR[6].eq ) { return 0x820963B8;  }
		/* 820963A8h case    6:*/		return 0x820963AC;
		  /* 820963ACh */ case    7:  		/* lbz R11, <#[R27]> */
		/* 820963ACh case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820963ACh case    7:*/		return 0x820963B0;
		  /* 820963B0h */ case    8:  		/* cmplwi CR6, R11, 48 */
		/* 820963B0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 820963B0h case    8:*/		return 0x820963B4;
		  /* 820963B4h */ case    9:  		/* bc 12, CR6_EQ, 16 */
		/* 820963B4h case    9:*/		if ( regs.CR[6].eq ) { return 0x820963C4;  }
		/* 820963B4h case    9:*/		return 0x820963B8;
	}
	return 0x820963B8;
} // Block from 82096390h-820963B8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820963B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820963B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820963B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820963B8);
		  /* 820963B8h */ case    0:  		/* li R11, 48 */
		/* 820963B8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x30);
		/* 820963B8h case    0:*/		return 0x820963BC;
		  /* 820963BCh */ case    1:  		/* addi R26, R26, 1 */
		/* 820963BCh case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820963BCh case    1:*/		return 0x820963C0;
		  /* 820963C0h */ case    2:  		/* stbu R11, <#[R27 - 1]> */
		/* 820963C0h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R27 + 0xFFFFFFFF) );
		regs.R27 = (uint32)(regs.R27 + 0xFFFFFFFF);
		/* 820963C0h case    2:*/		return 0x820963C4;
	}
	return 0x820963C4;
} // Block from 820963B8h-820963C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820963C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820963C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820963C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820963C4);
		  /* 820963C4h */ case    0:  		/* lwz R11, <#[R1 + 100]> */
		/* 820963C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 820963C4h case    0:*/		return 0x820963C8;
		  /* 820963C8h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820963C8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820963C8h case    1:*/		return 0x820963CC;
		  /* 820963CCh */ case    2:  		/* bc 4, CR6_EQ, 416 */
		/* 820963CCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x8209656C;  }
		/* 820963CCh case    2:*/		return 0x820963D0;
		  /* 820963D0h */ case    3:  		/* rlwinm. R11, R25, 0, 25, 25 */
		/* 820963D0h case    3:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R25);
		/* 820963D0h case    3:*/		return 0x820963D4;
		  /* 820963D4h */ case    4:  		/* bc 12, CR0_EQ, 56 */
		/* 820963D4h case    4:*/		if ( regs.CR[0].eq ) { return 0x8209640C;  }
		/* 820963D4h case    4:*/		return 0x820963D8;
		  /* 820963D8h */ case    5:  		/* rlwinm. R11, R25, 0, 23, 23 */
		/* 820963D8h case    5:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R25);
		/* 820963D8h case    5:*/		return 0x820963DC;
		  /* 820963DCh */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 820963DCh case    6:*/		if ( regs.CR[0].eq ) { return 0x820963E8;  }
		/* 820963DCh case    6:*/		return 0x820963E0;
		  /* 820963E0h */ case    7:  		/* li R11, 45 */
		/* 820963E0h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x2D);
		/* 820963E0h case    7:*/		return 0x820963E4;
		  /* 820963E4h */ case    8:  		/* b 32 */
		/* 820963E4h case    8:*/		return 0x82096404;
		/* 820963E4h case    8:*/		return 0x820963E8;
	}
	return 0x820963E8;
} // Block from 820963C4h-820963E8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820963E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820963E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820963E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820963E8);
		  /* 820963E8h */ case    0:  		/* rlwinm. R11, R25, 0, 31, 31 */
		/* 820963E8h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R25);
		/* 820963E8h case    0:*/		return 0x820963EC;
		  /* 820963ECh */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 820963ECh case    1:*/		if ( regs.CR[0].eq ) { return 0x820963F8;  }
		/* 820963ECh case    1:*/		return 0x820963F0;
		  /* 820963F0h */ case    2:  		/* li R11, 43 */
		/* 820963F0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x2B);
		/* 820963F0h case    2:*/		return 0x820963F4;
		  /* 820963F4h */ case    3:  		/* b 16 */
		/* 820963F4h case    3:*/		return 0x82096404;
		/* 820963F4h case    3:*/		return 0x820963F8;
	}
	return 0x820963F8;
} // Block from 820963E8h-820963F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820963F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820963F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820963F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820963F8);
		  /* 820963F8h */ case    0:  		/* rlwinm. R11, R25, 0, 30, 30 */
		/* 820963F8h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R25);
		/* 820963F8h case    0:*/		return 0x820963FC;
		  /* 820963FCh */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 820963FCh case    1:*/		if ( regs.CR[0].eq ) { return 0x8209640C;  }
		/* 820963FCh case    1:*/		return 0x82096400;
		  /* 82096400h */ case    2:  		/* li R11, 32 */
		/* 82096400h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x20);
		/* 82096400h case    2:*/		return 0x82096404;
	}
	return 0x82096404;
} // Block from 820963F8h-82096404h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82096404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096404);
		  /* 82096404h */ case    0:  		/* li R15, 1 */
		/* 82096404h case    0:*/		cpu::op::li<0>(regs,&regs.R15,0x1);
		/* 82096404h case    0:*/		return 0x82096408;
		  /* 82096408h */ case    1:  		/* sth R11, <#[R1 + 88]> */
		/* 82096408h case    1:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82096408h case    1:*/		return 0x8209640C;
	}
	return 0x8209640C;
} // Block from 82096404h-8209640Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209640Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209640C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209640C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209640C);
		  /* 8209640Ch */ case    0:  		/* subf R11, R26, R14 */
		/* 8209640Ch case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R26,regs.R14);
		/* 8209640Ch case    0:*/		return 0x82096410;
		  /* 82096410h */ case    1:  		/* rlwinm. R10, R25, 0, 28, 29 */
		/* 82096410h case    1:*/		cpu::op::rlwinm<1,0,28,29>(regs,&regs.R10,regs.R25);
		/* 82096410h case    1:*/		return 0x82096414;
		  /* 82096414h */ case    2:  		/* subf R28, R15, R11 */
		/* 82096414h case    2:*/		cpu::op::subf<0>(regs,&regs.R28,regs.R15,regs.R11);
		/* 82096414h case    2:*/		return 0x82096418;
		  /* 82096418h */ case    3:  		/* bc 4, CR0_EQ, 56 */
		/* 82096418h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82096450;  }
		/* 82096418h case    3:*/		return 0x8209641C;
		  /* 8209641Ch */ case    4:  		/* mr R31, R28 */
		/* 8209641Ch case    4:*/		regs.R31 = regs.R28;
		/* 8209641Ch case    4:*/		return 0x82096420;
		  /* 82096420h */ case    5:  		/* cmpwi CR6, R28, 0 */
		/* 82096420h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 82096420h case    5:*/		return 0x82096424;
		  /* 82096424h */ case    6:  		/* bc 4, CR6_GT, 44 */
		/* 82096424h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82096450;  }
		/* 82096424h case    6:*/		return 0x82096428;
		  /* 82096428h */ case    7:  		/* addi R5, R1, 80 */
		/* 82096428h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82096428h case    7:*/		return 0x8209642C;
		  /* 8209642Ch */ case    8:  		/* mr R4, R16 */
		/* 8209642Ch case    8:*/		regs.R4 = regs.R16;
		/* 8209642Ch case    8:*/		return 0x82096430;
		  /* 82096430h */ case    9:  		/* li R3, 32 */
		/* 82096430h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x20);
		/* 82096430h case    9:*/		return 0x82096434;
		  /* 82096434h */ case   10:  		/* addi R31, R31, -1 */
		/* 82096434h case   10:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82096434h case   10:*/		return 0x82096438;
		  /* 82096438h */ case   11:  		/* bl -2544 */
		/* 82096438h case   11:*/		regs.LR = 0x8209643C; return 0x82095A48;
		/* 82096438h case   11:*/		return 0x8209643C;
		  /* 8209643Ch */ case   12:  		/* lwz R11, <#[R1 + 80]> */
		/* 8209643Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8209643Ch case   12:*/		return 0x82096440;
		  /* 82096440h */ case   13:  		/* cmpwi CR6, R11, -1 */
		/* 82096440h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82096440h case   13:*/		return 0x82096444;
		  /* 82096444h */ case   14:  		/* bc 12, CR6_EQ, 12 */
		/* 82096444h case   14:*/		if ( regs.CR[6].eq ) { return 0x82096450;  }
		/* 82096444h case   14:*/		return 0x82096448;
		  /* 82096448h */ case   15:  		/* cmpwi CR6, R31, 0 */
		/* 82096448h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82096448h case   15:*/		return 0x8209644C;
		  /* 8209644Ch */ case   16:  		/* bc 12, CR6_GT, -36 */
		/* 8209644Ch case   16:*/		if ( regs.CR[6].gt ) { return 0x82096428;  }
		/* 8209644Ch case   16:*/		return 0x82096450;
	}
	return 0x82096450;
} // Block from 8209640Ch-82096450h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82096450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096450);
		  /* 82096450h */ case    0:  		/* addi R6, R1, 80 */
		/* 82096450h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 82096450h case    0:*/		return 0x82096454;
		  /* 82096454h */ case    1:  		/* mr R5, R16 */
		/* 82096454h case    1:*/		regs.R5 = regs.R16;
		/* 82096454h case    1:*/		return 0x82096458;
		  /* 82096458h */ case    2:  		/* mr R4, R15 */
		/* 82096458h case    2:*/		regs.R4 = regs.R15;
		/* 82096458h case    2:*/		return 0x8209645C;
		  /* 8209645Ch */ case    3:  		/* addi R3, R1, 88 */
		/* 8209645Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 8209645Ch case    3:*/		return 0x82096460;
		  /* 82096460h */ case    4:  		/* bl -2480 */
		/* 82096460h case    4:*/		regs.LR = 0x82096464; return 0x82095AB0;
		/* 82096460h case    4:*/		return 0x82096464;
		  /* 82096464h */ case    5:  		/* rlwinm. R11, R25, 0, 28, 28 */
		/* 82096464h case    5:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R25);
		/* 82096464h case    5:*/		return 0x82096468;
		  /* 82096468h */ case    6:  		/* bc 12, CR0_EQ, 64 */
		/* 82096468h case    6:*/		if ( regs.CR[0].eq ) { return 0x820964A8;  }
		/* 82096468h case    6:*/		return 0x8209646C;
		  /* 8209646Ch */ case    7:  		/* rlwinm. R11, R25, 0, 29, 29 */
		/* 8209646Ch case    7:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R25);
		/* 8209646Ch case    7:*/		return 0x82096470;
		  /* 82096470h */ case    8:  		/* bc 4, CR0_EQ, 56 */
		/* 82096470h case    8:*/		if ( !regs.CR[0].eq ) { return 0x820964A8;  }
		/* 82096470h case    8:*/		return 0x82096474;
		  /* 82096474h */ case    9:  		/* mr R31, R28 */
		/* 82096474h case    9:*/		regs.R31 = regs.R28;
		/* 82096474h case    9:*/		return 0x82096478;
		  /* 82096478h */ case   10:  		/* cmpwi CR6, R28, 0 */
		/* 82096478h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 82096478h case   10:*/		return 0x8209647C;
		  /* 8209647Ch */ case   11:  		/* bc 4, CR6_GT, 44 */
		/* 8209647Ch case   11:*/		if ( !regs.CR[6].gt ) { return 0x820964A8;  }
		/* 8209647Ch case   11:*/		return 0x82096480;
		  /* 82096480h */ case   12:  		/* addi R5, R1, 80 */
		/* 82096480h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82096480h case   12:*/		return 0x82096484;
		  /* 82096484h */ case   13:  		/* mr R4, R16 */
		/* 82096484h case   13:*/		regs.R4 = regs.R16;
		/* 82096484h case   13:*/		return 0x82096488;
		  /* 82096488h */ case   14:  		/* li R3, 48 */
		/* 82096488h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x30);
		/* 82096488h case   14:*/		return 0x8209648C;
		  /* 8209648Ch */ case   15:  		/* addi R31, R31, -1 */
		/* 8209648Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 8209648Ch case   15:*/		return 0x82096490;
		  /* 82096490h */ case   16:  		/* bl -2632 */
		/* 82096490h case   16:*/		regs.LR = 0x82096494; return 0x82095A48;
		/* 82096490h case   16:*/		return 0x82096494;
		  /* 82096494h */ case   17:  		/* lwz R11, <#[R1 + 80]> */
		/* 82096494h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82096494h case   17:*/		return 0x82096498;
		  /* 82096498h */ case   18:  		/* cmpwi CR6, R11, -1 */
		/* 82096498h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82096498h case   18:*/		return 0x8209649C;
		  /* 8209649Ch */ case   19:  		/* bc 12, CR6_EQ, 12 */
		/* 8209649Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x820964A8;  }
		/* 8209649Ch case   19:*/		return 0x820964A0;
		  /* 820964A0h */ case   20:  		/* cmpwi CR6, R31, 0 */
		/* 820964A0h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 820964A0h case   20:*/		return 0x820964A4;
		  /* 820964A4h */ case   21:  		/* bc 12, CR6_GT, -36 */
		/* 820964A4h case   21:*/		if ( regs.CR[6].gt ) { return 0x82096480;  }
		/* 820964A4h case   21:*/		return 0x820964A8;
	}
	return 0x820964A8;
} // Block from 82096450h-820964A8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820964A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820964A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820964A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820964A8);
		  /* 820964A8h */ case    0:  		/* cmpwi CR6, R20, 0 */
		/* 820964A8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 820964A8h case    0:*/		return 0x820964AC;
		  /* 820964ACh */ case    1:  		/* bc 4, CR6_EQ, 100 */
		/* 820964ACh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82096510;  }
		/* 820964ACh case    1:*/		return 0x820964B0;
		  /* 820964B0h */ case    2:  		/* cmpwi CR6, R26, 0 */
		/* 820964B0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 820964B0h case    2:*/		return 0x820964B4;
		  /* 820964B4h */ case    3:  		/* bc 4, CR6_GT, 92 */
		/* 820964B4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82096510;  }
		/* 820964B4h case    3:*/		return 0x820964B8;
		  /* 820964B8h */ case    4:  		/* mr R30, R27 */
		/* 820964B8h case    4:*/		regs.R30 = regs.R27;
		/* 820964B8h case    4:*/		return 0x820964BC;
		  /* 820964BCh */ case    5:  		/* mr R31, R26 */
		/* 820964BCh case    5:*/		regs.R31 = regs.R26;
		/* 820964BCh case    5:*/		return 0x820964C0;
		  /* 820964C0h */ case    6:  		/* lwz R11, <#[R22]> */
		/* 820964C0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 820964C0h case    6:*/		return 0x820964C4;
		  /* 820964C4h */ case    7:  		/* mr R6, R22 */
		/* 820964C4h case    7:*/		regs.R6 = regs.R22;
		/* 820964C4h case    7:*/		return 0x820964C8;
		  /* 820964C8h */ case    8:  		/* mr R4, R30 */
		/* 820964C8h case    8:*/		regs.R4 = regs.R30;
		/* 820964C8h case    8:*/		return 0x820964CC;
		  /* 820964CCh */ case    9:  		/* addi R3, R1, 92 */
		/* 820964CCh case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x5C);
		/* 820964CCh case    9:*/		return 0x820964D0;
		  /* 820964D0h */ case   10:  		/* addi R31, R31, -1 */
		/* 820964D0h case   10:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 820964D0h case   10:*/		return 0x820964D4;
		  /* 820964D4h */ case   11:  		/* lwz R5, <#[R11 + 172]> */
		/* 820964D4h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x000000AC) );
		/* 820964D4h case   11:*/		return 0x820964D8;
		  /* 820964D8h */ case   12:  		/* bl 18880 */
		/* 820964D8h case   12:*/		regs.LR = 0x820964DC; return 0x8209AE98;
		/* 820964D8h case   12:*/		return 0x820964DC;
		  /* 820964DCh */ case   13:  		/* or. R29, R3, R3 */
		/* 820964DCh case   13:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820964DCh case   13:*/		return 0x820964E0;
		  /* 820964E0h */ case   14:  		/* bc 4, CR0_GT, 36 */
		/* 820964E0h case   14:*/		if ( !regs.CR[0].gt ) { return 0x82096504;  }
		/* 820964E0h case   14:*/		return 0x820964E4;
		  /* 820964E4h */ case   15:  		/* addi R5, R1, 80 */
		/* 820964E4h case   15:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820964E4h case   15:*/		return 0x820964E8;
		  /* 820964E8h */ case   16:  		/* lhz R3, <#[R1 + 92]> */
		/* 820964E8h case   16:*/		cpu::mem::load16z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000005C) );
		/* 820964E8h case   16:*/		return 0x820964EC;
		  /* 820964ECh */ case   17:  		/* mr R4, R16 */
		/* 820964ECh case   17:*/		regs.R4 = regs.R16;
		/* 820964ECh case   17:*/		return 0x820964F0;
		  /* 820964F0h */ case   18:  		/* bl -2728 */
		/* 820964F0h case   18:*/		regs.LR = 0x820964F4; return 0x82095A48;
		/* 820964F0h case   18:*/		return 0x820964F4;
		  /* 820964F4h */ case   19:  		/* add R30, R29, R30 */
		/* 820964F4h case   19:*/		cpu::op::add<0>(regs,&regs.R30,regs.R29,regs.R30);
		/* 820964F4h case   19:*/		return 0x820964F8;
		  /* 820964F8h */ case   20:  		/* cmpwi CR6, R31, 0 */
		/* 820964F8h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 820964F8h case   20:*/		return 0x820964FC;
		  /* 820964FCh */ case   21:  		/* bc 12, CR6_GT, -60 */
		/* 820964FCh case   21:*/		if ( regs.CR[6].gt ) { return 0x820964C0;  }
		/* 820964FCh case   21:*/		return 0x82096500;
		  /* 82096500h */ case   22:  		/* b 36 */
		/* 82096500h case   22:*/		return 0x82096524;
		/* 82096500h case   22:*/		return 0x82096504;
	}
	return 0x82096504;
} // Block from 820964A8h-82096504h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82096504h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096504( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096504) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096504);
		  /* 82096504h */ case    0:  		/* li R21, -1 */
		/* 82096504h case    0:*/		cpu::op::li<0>(regs,&regs.R21,0xFFFFFFFF);
		/* 82096504h case    0:*/		return 0x82096508;
		  /* 82096508h */ case    1:  		/* stw R21, <#[R1 + 80]> */
		/* 82096508h case    1:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000050) );
		/* 82096508h case    1:*/		return 0x8209650C;
		  /* 8209650Ch */ case    2:  		/* b 28 */
		/* 8209650Ch case    2:*/		return 0x82096528;
		/* 8209650Ch case    2:*/		return 0x82096510;
	}
	return 0x82096510;
} // Block from 82096504h-82096510h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82096510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096510);
		  /* 82096510h */ case    0:  		/* addi R6, R1, 80 */
		/* 82096510h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 82096510h case    0:*/		return 0x82096514;
		  /* 82096514h */ case    1:  		/* mr R5, R16 */
		/* 82096514h case    1:*/		regs.R5 = regs.R16;
		/* 82096514h case    1:*/		return 0x82096518;
		  /* 82096518h */ case    2:  		/* mr R4, R26 */
		/* 82096518h case    2:*/		regs.R4 = regs.R26;
		/* 82096518h case    2:*/		return 0x8209651C;
		  /* 8209651Ch */ case    3:  		/* mr R3, R27 */
		/* 8209651Ch case    3:*/		regs.R3 = regs.R27;
		/* 8209651Ch case    3:*/		return 0x82096520;
		  /* 82096520h */ case    4:  		/* bl -2672 */
		/* 82096520h case    4:*/		regs.LR = 0x82096524; return 0x82095AB0;
		/* 82096520h case    4:*/		return 0x82096524;
	}
	return 0x82096524;
} // Block from 82096510h-82096524h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82096524h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096524( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096524) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096524);
		  /* 82096524h */ case    0:  		/* lwz R21, <#[R1 + 80]> */
		/* 82096524h case    0:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000050) );
		/* 82096524h case    0:*/		return 0x82096528;
	}
	return 0x82096528;
} // Block from 82096524h-82096528h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82096528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096528);
		  /* 82096528h */ case    0:  		/* cmpwi CR6, R21, 0 */
		/* 82096528h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 82096528h case    0:*/		return 0x8209652C;
		  /* 8209652Ch */ case    1:  		/* bc 12, CR6_LT, 64 */
		/* 8209652Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x8209656C;  }
		/* 8209652Ch case    1:*/		return 0x82096530;
		  /* 82096530h */ case    2:  		/* rlwinm. R11, R25, 0, 29, 29 */
		/* 82096530h case    2:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R25);
		/* 82096530h case    2:*/		return 0x82096534;
		  /* 82096534h */ case    3:  		/* bc 12, CR0_EQ, 56 */
		/* 82096534h case    3:*/		if ( regs.CR[0].eq ) { return 0x8209656C;  }
		/* 82096534h case    3:*/		return 0x82096538;
		  /* 82096538h */ case    4:  		/* mr R31, R28 */
		/* 82096538h case    4:*/		regs.R31 = regs.R28;
		/* 82096538h case    4:*/		return 0x8209653C;
		  /* 8209653Ch */ case    5:  		/* cmpwi CR6, R28, 0 */
		/* 8209653Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 8209653Ch case    5:*/		return 0x82096540;
		  /* 82096540h */ case    6:  		/* bc 4, CR6_GT, 44 */
		/* 82096540h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8209656C;  }
		/* 82096540h case    6:*/		return 0x82096544;
		  /* 82096544h */ case    7:  		/* addi R5, R1, 80 */
		/* 82096544h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82096544h case    7:*/		return 0x82096548;
		  /* 82096548h */ case    8:  		/* mr R4, R16 */
		/* 82096548h case    8:*/		regs.R4 = regs.R16;
		/* 82096548h case    8:*/		return 0x8209654C;
		  /* 8209654Ch */ case    9:  		/* li R3, 32 */
		/* 8209654Ch case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x20);
		/* 8209654Ch case    9:*/		return 0x82096550;
		  /* 82096550h */ case   10:  		/* addi R31, R31, -1 */
		/* 82096550h case   10:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82096550h case   10:*/		return 0x82096554;
		  /* 82096554h */ case   11:  		/* bl -2828 */
		/* 82096554h case   11:*/		regs.LR = 0x82096558; return 0x82095A48;
		/* 82096554h case   11:*/		return 0x82096558;
		  /* 82096558h */ case   12:  		/* lwz R21, <#[R1 + 80]> */
		/* 82096558h case   12:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000050) );
		/* 82096558h case   12:*/		return 0x8209655C;
		  /* 8209655Ch */ case   13:  		/* cmpwi CR6, R21, -1 */
		/* 8209655Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R21,0xFFFFFFFF);
		/* 8209655Ch case   13:*/		return 0x82096560;
		  /* 82096560h */ case   14:  		/* bc 12, CR6_EQ, 12 */
		/* 82096560h case   14:*/		if ( regs.CR[6].eq ) { return 0x8209656C;  }
		/* 82096560h case   14:*/		return 0x82096564;
		  /* 82096564h */ case   15:  		/* cmpwi CR6, R31, 0 */
		/* 82096564h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82096564h case   15:*/		return 0x82096568;
		  /* 82096568h */ case   16:  		/* bc 12, CR6_GT, -36 */
		/* 82096568h case   16:*/		if ( regs.CR[6].gt ) { return 0x82096544;  }
		/* 82096568h case   16:*/		return 0x8209656C;
	}
	return 0x8209656C;
} // Block from 82096528h-8209656Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8209656Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209656C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209656C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209656C);
		  /* 8209656Ch */ case    0:  		/* lwz R3, <#[R1 + 108]> */
		/* 8209656Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000006C) );
		/* 8209656Ch case    0:*/		return 0x82096570;
		  /* 82096570h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 82096570h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82096570h case    1:*/		return 0x82096574;
		  /* 82096574h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 82096574h case    2:*/		if ( regs.CR[6].eq ) { return 0x82096584;  }
		/* 82096574h case    2:*/		return 0x82096578;
		  /* 82096578h */ case    3:  		/* bl -11600 */
		/* 82096578h case    3:*/		regs.LR = 0x8209657C; return 0x82093828;
		/* 82096578h case    3:*/		return 0x8209657C;
		  /* 8209657Ch */ case    4:  		/* li R11, 0 */
		/* 8209657Ch case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209657Ch case    4:*/		return 0x82096580;
		  /* 82096580h */ case    5:  		/* stw R11, <#[R1 + 108]> */
		/* 82096580h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 82096580h case    5:*/		return 0x82096584;
	}
	return 0x82096584;
} // Block from 8209656Ch-82096584h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82096584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096584);
		  /* 82096584h */ case    0:  		/* lhz R29, <#[R17]> */
		/* 82096584h case    0:*/		cpu::mem::load16z( regs, &regs.R29, (uint32)(regs.R17 + 0x00000000) );
		/* 82096584h case    0:*/		return 0x82096588;
		  /* 82096588h */ case    1:  		/* or. R8, R29, R29 */
		/* 82096588h case    1:*/		cpu::op::or<1>(regs,&regs.R8,regs.R29,regs.R29);
		/* 82096588h case    1:*/		return 0x8209658C;
		  /* 8209658Ch */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8209658Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8209659C;  }
		/* 8209658Ch case    2:*/		return 0x82096590;
		  /* 82096590h */ case    3:  		/* lwz R10, <#[R1 + 104]> */
		/* 82096590h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000068) );
		/* 82096590h case    3:*/		return 0x82096594;
		  /* 82096594h */ case    4:  		/* li R30, 0 */
		/* 82096594h case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82096594h case    4:*/		return 0x82096598;
		  /* 82096598h */ case    5:  		/* b -2388 */
		/* 82096598h case    5:*/		return 0x82095C44;
		/* 82096598h case    5:*/		return 0x8209659C;
	}
	return 0x8209659C;
} // Block from 82096584h-8209659Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209659Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209659C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209659C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209659C);
		  /* 8209659Ch */ case    0:  		/* lwz R11, <#[R1 + 96]> */
		/* 8209659Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 8209659Ch case    0:*/		return 0x820965A0;
		  /* 820965A0h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820965A0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820965A0h case    1:*/		return 0x820965A4;
		  /* 820965A4h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 820965A4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820965B0;  }
		/* 820965A4h case    2:*/		return 0x820965A8;
		  /* 820965A8h */ case    3:  		/* cmpwi CR6, R11, 7 */
		/* 820965A8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000007);
		/* 820965A8h case    3:*/		return 0x820965AC;
		  /* 820965ACh */ case    4:  		/* bc 4, CR6_EQ, -2540 */
		/* 820965ACh case    4:*/		if ( !regs.CR[6].eq ) { return 0x82095BC0;  }
		/* 820965ACh case    4:*/		return 0x820965B0;
	}
	return 0x820965B0;
} // Block from 8209659Ch-820965B0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820965B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820965B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820965B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820965B0);
		  /* 820965B0h */ case    0:  		/* mr R3, R21 */
		/* 820965B0h case    0:*/		regs.R3 = regs.R21;
		/* 820965B0h case    0:*/		return 0x820965B4;
		  /* 820965B4h */ case    1:  		/* b 56 */
		/* 820965B4h case    1:*/		return 0x820965EC;
		/* 820965B4h case    1:*/		return 0x820965B8;
	}
	return 0x820965B8;
} // Block from 820965B0h-820965B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820965B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820965B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820965B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820965B8);
		  /* 820965B8h */ case    0:  		/* mr R6, R24 */
		/* 820965B8h case    0:*/		regs.R6 = regs.R24;
		/* 820965B8h case    0:*/		return 0x820965BC;
		  /* 820965BCh */ case    1:  		/* mr R5, R17 */
		/* 820965BCh case    1:*/		regs.R5 = regs.R17;
		/* 820965BCh case    1:*/		return 0x820965C0;
		  /* 820965C0h */ case    2:  		/* li R4, 512 */
		/* 820965C0h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x200);
		/* 820965C0h case    2:*/		return 0x820965C4;
		  /* 820965C4h */ case    3:  		/* addi R3, R1, 1152 */
		/* 820965C4h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x480);
		/* 820965C4h case    3:*/		return 0x820965C8;
		  /* 820965C8h */ case    4:  		/* bl 18296 */
		/* 820965C8h case    4:*/		regs.LR = 0x820965CC; return 0x8209AD40;
		/* 820965C8h case    4:*/		return 0x820965CC;
		  /* 820965CCh */ case    5:  		/* mr R31, R3 */
		/* 820965CCh case    5:*/		regs.R31 = regs.R3;
		/* 820965CCh case    5:*/		return 0x820965D0;
		  /* 820965D0h */ case    6:  		/* cmpwi CR6, R3, -1 */
		/* 820965D0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820965D0h case    6:*/		return 0x820965D4;
		  /* 820965D4h */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 820965D4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820965E0;  }
		/* 820965D4h case    7:*/		return 0x820965D8;
		  /* 820965D8h */ case    8:  		/* li R31, 511 */
		/* 820965D8h case    8:*/		cpu::op::li<0>(regs,&regs.R31,0x1FF);
		/* 820965D8h case    8:*/		return 0x820965DC;
		  /* 820965DCh */ case    9:  		/* sth R30, <#[R1 + 2174]> */
		/* 820965DCh case    9:*/		cpu::mem::store16( regs, regs.R30, (uint32)(regs.R1 + 0x0000087E) );
		/* 820965DCh case    9:*/		return 0x820965E0;
	}
	return 0x820965E0;
} // Block from 820965B8h-820965E0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820965E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820965E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820965E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820965E0);
		  /* 820965E0h */ case    0:  		/* addi R3, R1, 1152 */
		/* 820965E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x480);
		/* 820965E0h case    0:*/		return 0x820965E4;
		  /* 820965E4h */ case    1:  		/* bl 1904212 */
		/* 820965E4h case    1:*/		regs.LR = 0x820965E8; return 0x82267438;
		/* 820965E4h case    1:*/		return 0x820965E8;
		  /* 820965E8h */ case    2:  		/* mr R3, R31 */
		/* 820965E8h case    2:*/		regs.R3 = regs.R31;
		/* 820965E8h case    2:*/		return 0x820965EC;
	}
	return 0x820965EC;
} // Block from 820965E0h-820965ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820965ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820965EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820965EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820965EC);
		  /* 820965ECh */ case    0:  		/* addi R1, R1, 2336 */
		/* 820965ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x920);
		/* 820965ECh case    0:*/		return 0x820965F0;
		  /* 820965F0h */ case    1:  		/* b -21376 */
		/* 820965F0h case    1:*/		return 0x82091270;
		/* 820965F0h case    1:*/		return 0x820965F4;
		  /* 820965F4h */ case    2:  		/* nop */
		/* 820965F4h case    2:*/		cpu::op::nop();
		/* 820965F4h case    2:*/		return 0x820965F8;
	}
	return 0x820965F8;
} // Block from 820965ECh-820965F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820965F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820965F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820965F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820965F8);
		  /* 820965F8h */ case    0:  		/* mfspr R12, LR */
		/* 820965F8h case    0:*/		regs.R12 = regs.LR;
		/* 820965F8h case    0:*/		return 0x820965FC;
		  /* 820965FCh */ case    1:  		/* bl -21468 */
		/* 820965FCh case    1:*/		regs.LR = 0x82096600; return 0x82091220;
		/* 820965FCh case    1:*/		return 0x82096600;
		  /* 82096600h */ case    2:  		/* stwu R1, <#[R1 - 1328]> */
		/* 82096600h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFAD0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFAD0);
		/* 82096600h case    2:*/		return 0x82096604;
		  /* 82096604h */ case    3:  		/* li R30, 0 */
		/* 82096604h case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82096604h case    3:*/		return 0x82096608;
		  /* 82096608h */ case    4:  		/* mr R18, R3 */
		/* 82096608h case    4:*/		regs.R18 = regs.R3;
		/* 82096608h case    4:*/		return 0x8209660C;
		  /* 8209660Ch */ case    5:  		/* mr R31, R4 */
		/* 8209660Ch case    5:*/		regs.R31 = regs.R4;
		/* 8209660Ch case    5:*/		return 0x82096610;
		  /* 82096610h */ case    6:  		/* stw R30, <#[R1 + 104]> */
		/* 82096610h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000068) );
		/* 82096610h case    6:*/		return 0x82096614;
		  /* 82096614h */ case    7:  		/* mr R26, R6 */
		/* 82096614h case    7:*/		regs.R26 = regs.R6;
		/* 82096614h case    7:*/		return 0x82096618;
		  /* 82096618h */ case    8:  		/* stw R30, <#[R1 + 96]> */
		/* 82096618h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000060) );
		/* 82096618h case    8:*/		return 0x8209661C;
		  /* 8209661Ch */ case    9:  		/* cmplwi CR6, R3, 0 */
		/* 8209661Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209661Ch case    9:*/		return 0x82096620;
		  /* 82096620h */ case   10:  		/* stw R30, <#[R1 + 92]> */
		/* 82096620h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000005C) );
		/* 82096620h case   10:*/		return 0x82096624;
		  /* 82096624h */ case   11:  		/* mr R27, R30 */
		/* 82096624h case   11:*/		regs.R27 = regs.R30;
		/* 82096624h case   11:*/		return 0x82096628;
		  /* 82096628h */ case   12:  		/* stw R30, <#[R1 + 100]> */
		/* 82096628h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000064) );
		/* 82096628h case   12:*/		return 0x8209662C;
		  /* 8209662Ch */ case   13:  		/* mr R25, R30 */
		/* 8209662Ch case   13:*/		regs.R25 = regs.R30;
		/* 8209662Ch case   13:*/		return 0x82096630;
		  /* 82096630h */ case   14:  		/* mr R16, R30 */
		/* 82096630h case   14:*/		regs.R16 = regs.R30;
		/* 82096630h case   14:*/		return 0x82096634;
		  /* 82096634h */ case   15:  		/* bc 4, CR6_EQ, 28 */
		/* 82096634h case   15:*/		if ( !regs.CR[6].eq ) { return 0x82096650;  }
		/* 82096634h case   15:*/		return 0x82096638;
		  /* 82096638h */ case   16:  		/* bl -5936 */
		/* 82096638h case   16:*/		regs.LR = 0x8209663C; return 0x82094F08;
		/* 82096638h case   16:*/		return 0x8209663C;
		  /* 8209663Ch */ case   17:  		/* li R11, 22 */
		/* 8209663Ch case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 8209663Ch case   17:*/		return 0x82096640;
		  /* 82096640h */ case   18:  		/* stw R11, <#[R3]> */
		/* 82096640h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82096640h case   18:*/		return 0x82096644;
		  /* 82096644h */ case   19:  		/* bl -11492 */
		/* 82096644h case   19:*/		regs.LR = 0x82096648; return 0x82093960;
		/* 82096644h case   19:*/		return 0x82096648;
		  /* 82096648h */ case   20:  		/* li R3, -1 */
		/* 82096648h case   20:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82096648h case   20:*/		return 0x8209664C;
		  /* 8209664Ch */ case   21:  		/* b 2772 */
		/* 8209664Ch case   21:*/		return 0x82097120;
		/* 8209664Ch case   21:*/		return 0x82096650;
	}
	return 0x82096650;
} // Block from 820965F8h-82096650h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82096650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096650);
		  /* 82096650h */ case    0:  		/* lwz R11, <#[R18 + 12]> */
		/* 82096650h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x0000000C) );
		/* 82096650h case    0:*/		return 0x82096654;
		  /* 82096654h */ case    1:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 82096654h case    1:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 82096654h case    1:*/		return 0x82096658;
		  /* 82096658h */ case    2:  		/* bc 4, CR0_EQ, 148 */
		/* 82096658h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820966EC;  }
		/* 82096658h case    2:*/		return 0x8209665C;
		  /* 8209665Ch */ case    3:  		/* mr R3, R18 */
		/* 8209665Ch case    3:*/		regs.R3 = regs.R18;
		/* 8209665Ch case    3:*/		return 0x82096660;
		  /* 82096660h */ case    4:  		/* bl 17184 */
		/* 82096660h case    4:*/		regs.LR = 0x82096664; return 0x8209A980;
		/* 82096660h case    4:*/		return 0x82096664;
		  /* 82096664h */ case    5:  		/* lis R11, -32215 */
		/* 82096664h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82096664h case    5:*/		return 0x82096668;
		  /* 82096668h */ case    6:  		/* lis R10, -32217 */
		/* 82096668h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 82096668h case    6:*/		return 0x8209666C;
		  /* 8209666Ch */ case    7:  		/* cmpwi CR6, R3, -1 */
		/* 8209666Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8209666Ch case    7:*/		return 0x82096670;
		  /* 82096670h */ case    8:  		/* addi R11, R11, -25504 */
		/* 82096670h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF9C60);
		/* 82096670h case    8:*/		return 0x82096674;
		  /* 82096674h */ case    9:  		/* addi R8, R10, 8872 */
		/* 82096674h case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x22A8);
		/* 82096674h case    9:*/		return 0x82096678;
		  /* 82096678h */ case   10:  		/* bc 12, CR6_EQ, 40 */
		/* 82096678h case   10:*/		if ( regs.CR[6].eq ) { return 0x820966A0;  }
		/* 82096678h case   10:*/		return 0x8209667C;
		  /* 8209667Ch */ case   11:  		/* cmpwi CR6, R3, -2 */
		/* 8209667Ch case   11:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFE);
		/* 8209667Ch case   11:*/		return 0x82096680;
		  /* 82096680h */ case   12:  		/* bc 12, CR6_EQ, 32 */
		/* 82096680h case   12:*/		if ( regs.CR[6].eq ) { return 0x820966A0;  }
		/* 82096680h case   12:*/		return 0x82096684;
		  /* 82096684h */ case   13:  		/* srawi R10, R3, 5 */
		/* 82096684h case   13:*/		cpu::op::srawi<0,5>(regs,&regs.R10,regs.R3);
		/* 82096684h case   13:*/		return 0x82096688;
		  /* 82096688h */ case   14:  		/* rlwinm R9, R3, 0, 27, 31 */
		/* 82096688h case   14:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R3);
		/* 82096688h case   14:*/		return 0x8209668C;
		  /* 8209668Ch */ case   15:  		/* rlwinm R7, R10, 2, 0, 29 */
		/* 8209668Ch case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R10);
		/* 8209668Ch case   15:*/		return 0x82096690;
		  /* 82096690h */ case   16:  		/* mulli R10, R9, 72 */
		/* 82096690h case   16:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R9,0x48);
		/* 82096690h case   16:*/		return 0x82096694;
		  /* 82096694h */ case   17:  		/* lwzx R9, <#[R7 + R11]> */
		/* 82096694h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 82096694h case   17:*/		return 0x82096698;
		  /* 82096698h */ case   18:  		/* add R10, R9, R10 */
		/* 82096698h case   18:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82096698h case   18:*/		return 0x8209669C;
		  /* 8209669Ch */ case   19:  		/* b 8 */
		/* 8209669Ch case   19:*/		return 0x820966A4;
		/* 8209669Ch case   19:*/		return 0x820966A0;
	}
	return 0x820966A0;
} // Block from 82096650h-820966A0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820966A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820966A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820966A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820966A0);
		  /* 820966A0h */ case    0:  		/* mr R10, R8 */
		/* 820966A0h case    0:*/		regs.R10 = regs.R8;
		/* 820966A0h case    0:*/		return 0x820966A4;
	}
	return 0x820966A4;
} // Block from 820966A0h-820966A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820966A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820966A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820966A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820966A4);
		  /* 820966A4h */ case    0:  		/* lbz R10, <#[R10 + 40]> */
		/* 820966A4h case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000028) );
		/* 820966A4h case    0:*/		return 0x820966A8;
		  /* 820966A8h */ case    1:  		/* rlwinm. R10, R10, 0, 0, 30 */
		/* 820966A8h case    1:*/		cpu::op::rlwinm<1,0,0,30>(regs,&regs.R10,regs.R10);
		/* 820966A8h case    1:*/		return 0x820966AC;
		  /* 820966ACh */ case    2:  		/* bc 4, CR0_EQ, -116 */
		/* 820966ACh case    2:*/		if ( !regs.CR[0].eq ) { return 0x82096638;  }
		/* 820966ACh case    2:*/		return 0x820966B0;
		  /* 820966B0h */ case    3:  		/* cmpwi CR6, R3, -1 */
		/* 820966B0h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820966B0h case    3:*/		return 0x820966B4;
		  /* 820966B4h */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 820966B4h case    4:*/		if ( regs.CR[6].eq ) { return 0x820966DC;  }
		/* 820966B4h case    4:*/		return 0x820966B8;
		  /* 820966B8h */ case    5:  		/* cmpwi CR6, R3, -2 */
		/* 820966B8h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFE);
		/* 820966B8h case    5:*/		return 0x820966BC;
		  /* 820966BCh */ case    6:  		/* bc 12, CR6_EQ, 32 */
		/* 820966BCh case    6:*/		if ( regs.CR[6].eq ) { return 0x820966DC;  }
		/* 820966BCh case    6:*/		return 0x820966C0;
		  /* 820966C0h */ case    7:  		/* srawi R10, R3, 5 */
		/* 820966C0h case    7:*/		cpu::op::srawi<0,5>(regs,&regs.R10,regs.R3);
		/* 820966C0h case    7:*/		return 0x820966C4;
		  /* 820966C4h */ case    8:  		/* rlwinm R9, R3, 0, 27, 31 */
		/* 820966C4h case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R3);
		/* 820966C4h case    8:*/		return 0x820966C8;
		  /* 820966C8h */ case    9:  		/* rlwinm R8, R10, 2, 0, 29 */
		/* 820966C8h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R10);
		/* 820966C8h case    9:*/		return 0x820966CC;
		  /* 820966CCh */ case   10:  		/* mulli R10, R9, 72 */
		/* 820966CCh case   10:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R9,0x48);
		/* 820966CCh case   10:*/		return 0x820966D0;
		  /* 820966D0h */ case   11:  		/* lwzx R11, <#[R8 + R11]> */
		/* 820966D0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 820966D0h case   11:*/		return 0x820966D4;
		  /* 820966D4h */ case   12:  		/* add R11, R11, R10 */
		/* 820966D4h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820966D4h case   12:*/		return 0x820966D8;
		  /* 820966D8h */ case   13:  		/* b 8 */
		/* 820966D8h case   13:*/		return 0x820966E0;
		/* 820966D8h case   13:*/		return 0x820966DC;
	}
	return 0x820966DC;
} // Block from 820966A4h-820966DCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 820966DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820966DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820966DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820966DC);
		  /* 820966DCh */ case    0:  		/* mr R11, R8 */
		/* 820966DCh case    0:*/		regs.R11 = regs.R8;
		/* 820966DCh case    0:*/		return 0x820966E0;
	}
	return 0x820966E0;
} // Block from 820966DCh-820966E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820966E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820966E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820966E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820966E0);
		  /* 820966E0h */ case    0:  		/* lbz R11, <#[R11 + 40]> */
		/* 820966E0h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 820966E0h case    0:*/		return 0x820966E4;
		  /* 820966E4h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 820966E4h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 820966E4h case    1:*/		return 0x820966E8;
		  /* 820966E8h */ case    2:  		/* bc 4, CR0_EQ, -176 */
		/* 820966E8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82096638;  }
		/* 820966E8h case    2:*/		return 0x820966EC;
	}
	return 0x820966EC;
} // Block from 820966E0h-820966ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820966ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820966EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820966EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820966EC);
		  /* 820966ECh */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820966ECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820966ECh case    0:*/		return 0x820966F0;
		  /* 820966F0h */ case    1:  		/* bc 12, CR6_EQ, -184 */
		/* 820966F0h case    1:*/		if ( regs.CR[6].eq ) { return 0x82096638;  }
		/* 820966F0h case    1:*/		return 0x820966F4;
		  /* 820966F4h */ case    2:  		/* bl 16364 */
		/* 820966F4h case    2:*/		regs.LR = 0x820966F8; return 0x8209A6E0;
		/* 820966F4h case    2:*/		return 0x820966F8;
		  /* 820966F8h */ case    3:  		/* addi R11, R3, 32 */
		/* 820966F8h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x20);
		/* 820966F8h case    3:*/		return 0x820966FC;
		  /* 820966FCh */ case    4:  		/* cmplw CR6, R18, R11 */
		/* 820966FCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R18,regs.R11);
		/* 820966FCh case    4:*/		return 0x82096700;
		  /* 82096700h */ case    5:  		/* bc 12, CR6_EQ, 2540 */
		/* 82096700h case    5:*/		if ( regs.CR[6].eq ) { return 0x820970EC;  }
		/* 82096700h case    5:*/		return 0x82096704;
		  /* 82096704h */ case    6:  		/* bl 16348 */
		/* 82096704h case    6:*/		regs.LR = 0x82096708; return 0x8209A6E0;
		/* 82096704h case    6:*/		return 0x82096708;
		  /* 82096708h */ case    7:  		/* addi R11, R3, 64 */
		/* 82096708h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x40);
		/* 82096708h case    7:*/		return 0x8209670C;
		  /* 8209670Ch */ case    8:  		/* cmplw CR6, R18, R11 */
		/* 8209670Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R18,regs.R11);
		/* 8209670Ch case    8:*/		return 0x82096710;
		  /* 82096710h */ case    9:  		/* bc 12, CR6_EQ, 2524 */
		/* 82096710h case    9:*/		if ( regs.CR[6].eq ) { return 0x820970EC;  }
		/* 82096710h case    9:*/		return 0x82096714;
		  /* 82096714h */ case   10:  		/* lbz R29, <#[R31]> */
		/* 82096714h case   10:*/		cpu::mem::load8z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000000) );
		/* 82096714h case   10:*/		return 0x82096718;
		  /* 82096718h */ case   11:  		/* mr R24, R30 */
		/* 82096718h case   11:*/		regs.R24 = regs.R30;
		/* 82096718h case   11:*/		return 0x8209671C;
		  /* 8209671Ch */ case   12:  		/* mr R6, R30 */
		/* 8209671Ch case   12:*/		regs.R6 = regs.R30;
		/* 8209671Ch case   12:*/		return 0x82096720;
		  /* 82096720h */ case   13:  		/* stw R30, <#[R1 + 80]> */
		/* 82096720h case   13:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 82096720h case   13:*/		return 0x82096724;
		  /* 82096724h */ case   14:  		/* extsb. R8, R29 */
		/* 82096724h case   14:*/		cpu::op::extsb<1>(regs,&regs.R8,regs.R29);
		/* 82096724h case   14:*/		return 0x82096728;
		  /* 82096728h */ case   15:  		/* stw R30, <#[R1 + 84]> */
		/* 82096728h case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 82096728h case   15:*/		return 0x8209672C;
		  /* 8209672Ch */ case   16:  		/* mr R7, R30 */
		/* 8209672Ch case   16:*/		regs.R7 = regs.R30;
		/* 8209672Ch case   16:*/		return 0x82096730;
		  /* 82096730h */ case   17:  		/* mr R14, R30 */
		/* 82096730h case   17:*/		regs.R14 = regs.R30;
		/* 82096730h case   17:*/		return 0x82096734;
		  /* 82096734h */ case   18:  		/* bc 12, CR0_EQ, 2480 */
		/* 82096734h case   18:*/		if ( regs.CR[0].eq ) { return 0x820970E4;  }
		/* 82096734h case   18:*/		return 0x82096738;
		  /* 82096738h */ case   19:  		/* lis R11, -32217 */
		/* 82096738h case   19:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82096738h case   19:*/		return 0x8209673C;
		  /* 8209673Ch */ case   20:  		/* lwz R21, <#[R1 + 112]> */
		/* 8209673Ch case   20:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000070) );
		/* 8209673Ch case   20:*/		return 0x82096740;
		  /* 82096740h */ case   21:  		/* lis R10, -32217 */
		/* 82096740h case   21:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 82096740h case   21:*/		return 0x82096744;
		  /* 82096744h */ case   22:  		/* lwz R28, <#[R1 + 112]> */
		/* 82096744h case   22:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000070) );
		/* 82096744h case   22:*/		return 0x82096748;
		  /* 82096748h */ case   23:  		/* lis R9, -32255 */
		/* 82096748h case   23:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 82096748h case   23:*/		return 0x8209674C;
		  /* 8209674Ch */ case   24:  		/* addi R19, R31, -1 */
		/* 8209674Ch case   24:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R31,0xFFFFFFFF);
		/* 8209674Ch case   24:*/		return 0x82096750;
		  /* 82096750h */ case   25:  		/* lis R15, -32255 */
		/* 82096750h case   25:*/		cpu::op::lis<0>(regs,&regs.R15,0xFFFF8201);
		/* 82096750h case   25:*/		return 0x82096754;
		  /* 82096754h */ case   26:  		/* lis R20, -32255 */
		/* 82096754h case   26:*/		cpu::op::lis<0>(regs,&regs.R20,0xFFFF8201);
		/* 82096754h case   26:*/		return 0x82096758;
		  /* 82096758h */ case   27:  		/* addi R23, R11, 8856 */
		/* 82096758h case   27:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R11,0x2298);
		/* 82096758h case   27:*/		return 0x8209675C;
		  /* 8209675Ch */ case   28:  		/* addi R22, R10, 7288 */
		/* 8209675Ch case   28:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R10,0x1C78);
		/* 8209675Ch case   28:*/		return 0x82096760;
		  /* 82096760h */ case   29:  		/* addi R17, R9, -21800 */
		/* 82096760h case   29:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R9,0xFFFFAAD8);
		/* 82096760h case   29:*/		return 0x82096764;
		  /* 82096764h */ case   30:  		/* addi R19, R19, 1 */
		/* 82096764h case   30:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x1);
		/* 82096764h case   30:*/		return 0x82096768;
		  /* 82096768h */ case   31:  		/* cmpwi CR6, R24, 0 */
		/* 82096768h case   31:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 82096768h case   31:*/		return 0x8209676C;
		  /* 8209676Ch */ case   32:  		/* bc 12, CR6_LT, 2424 */
		/* 8209676Ch case   32:*/		if ( regs.CR[6].lt ) { return 0x820970E4;  }
		/* 8209676Ch case   32:*/		return 0x82096770;
		  /* 82096770h */ case   33:  		/* cmpwi CR6, R8, 32 */
		/* 82096770h case   33:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000020);
		/* 82096770h case   33:*/		return 0x82096774;
		  /* 82096774h */ case   34:  		/* bc 12, CR6_LT, 28 */
		/* 82096774h case   34:*/		if ( regs.CR[6].lt ) { return 0x82096790;  }
		/* 82096774h case   34:*/		return 0x82096778;
		  /* 82096778h */ case   35:  		/* cmpwi CR6, R8, 120 */
		/* 82096778h case   35:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000078);
		/* 82096778h case   35:*/		return 0x8209677C;
		  /* 8209677Ch */ case   36:  		/* bc 12, CR6_GT, 20 */
		/* 8209677Ch case   36:*/		if ( regs.CR[6].gt ) { return 0x82096790;  }
		/* 8209677Ch case   36:*/		return 0x82096780;
		  /* 82096780h */ case   37:  		/* add R11, R8, R17 */
		/* 82096780h case   37:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R17);
		/* 82096780h case   37:*/		return 0x82096784;
		  /* 82096784h */ case   38:  		/* lbz R11, <#[R11 - 32]> */
		/* 82096784h case   38:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFE0) );
		/* 82096784h case   38:*/		return 0x82096788;
		  /* 82096788h */ case   39:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 82096788h case   39:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 82096788h case   39:*/		return 0x8209678C;
		  /* 8209678Ch */ case   40:  		/* b 8 */
		/* 8209678Ch case   40:*/		return 0x82096794;
		/* 8209678Ch case   40:*/		return 0x82096790;
	}
	return 0x82096790;
} // Block from 820966ECh-82096790h (41 instructions)

//////////////////////////////////////////////////////
// Block at 82096790h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096790);
		  /* 82096790h */ case    0:  		/* mr R11, R30 */
		/* 82096790h case    0:*/		regs.R11 = regs.R30;
		/* 82096790h case    0:*/		return 0x82096794;
	}
	return 0x82096794;
} // Block from 82096790h-82096794h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82096794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096794);
		  /* 82096794h */ case    0:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 82096794h case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 82096794h case    0:*/		return 0x82096798;
		  /* 82096798h */ case    1:  		/* add R11, R11, R7 */
		/* 82096798h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 82096798h case    1:*/		return 0x8209679C;
		  /* 8209679Ch */ case    2:  		/* lbzx R11, <#[R11 + R17]> */
		/* 8209679Ch case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R17 + 0x00000000) );
		/* 8209679Ch case    2:*/		return 0x820967A0;
		  /* 820967A0h */ case    3:  		/* extsb R11, R11 */
		/* 820967A0h case    3:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820967A0h case    3:*/		return 0x820967A4;
		  /* 820967A4h */ case    4:  		/* srawi R11, R11, 4 */
		/* 820967A4h case    4:*/		cpu::op::srawi<0,4>(regs,&regs.R11,regs.R11);
		/* 820967A4h case    4:*/		return 0x820967A8;
		  /* 820967A8h */ case    5:  		/* stw R11, <#[R1 + 108]> */
		/* 820967A8h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 820967A8h case    5:*/		return 0x820967AC;
		  /* 820967ACh */ case    6:  		/* cmplwi CR6, R11, 7 */
		/* 820967ACh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000007);
		/* 820967ACh case    6:*/		return 0x820967B0;
		  /* 820967B0h */ case    7:  		/* bc 12, CR6_GT, 2328 */
		/* 820967B0h case    7:*/		if ( regs.CR[6].gt ) { return 0x820970C8;  }
		/* 820967B0h case    7:*/		return 0x820967B4;
		  /* 820967B4h */ case    8:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820967B4h case    8:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820967B4h case    8:*/		return 0x820967B8;
		  /* 820967B8h */ case    9:  		/* mtspr CTR, R11 */
		/* 820967B8h case    9:*/		regs.CTR = regs.R11;
		/* 820967B8h case    9:*/		return 0x820967BC;
		  /* 820967BCh */ case   10:  		/* cmpwi CR6, R11, 0 */
		/* 820967BCh case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820967BCh case   10:*/		return 0x820967C0;
		  /* 820967C0h */ case   11:  		/* bc 12, CR6_EQ, 492 */
		/* 820967C0h case   11:*/		if ( regs.CR[6].eq ) { return 0x820969AC;  }
		/* 820967C0h case   11:*/		return 0x820967C4;
		  /* 820967C4h */ case   12:  		/* bc 18, CR0_LT, 28 */
		/* 820967C4h case   12:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x820967E0;  }
		/* 820967C4h case   12:*/		return 0x820967C8;
		  /* 820967C8h */ case   13:  		/* bc 18, CR0_LT, 56 */
		/* 820967C8h case   13:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x82096800;  }
		/* 820967C8h case   13:*/		return 0x820967CC;
		  /* 820967CCh */ case   14:  		/* bc 18, CR0_LT, 132 */
		/* 820967CCh case   14:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x82096850;  }
		/* 820967CCh case   14:*/		return 0x820967D0;
		  /* 820967D0h */ case   15:  		/* bc 18, CR0_LT, 204 */
		/* 820967D0h case   15:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x8209689C;  }
		/* 820967D0h case   15:*/		return 0x820967D4;
		  /* 820967D4h */ case   16:  		/* bc 18, CR0_LT, 208 */
		/* 820967D4h case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x820968A4;  }
		/* 820967D4h case   16:*/		return 0x820967D8;
		  /* 820967D8h */ case   17:  		/* bc 18, CR0_LT, 260 */
		/* 820967D8h case   17:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x820968DC;  }
		/* 820967D8h case   17:*/		return 0x820967DC;
		  /* 820967DCh */ case   18:  		/* b 540 */
		/* 820967DCh case   18:*/		return 0x820969F8;
		/* 820967DCh case   18:*/		return 0x820967E0;
	}
	return 0x820967E0;
} // Block from 82096794h-820967E0h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820967E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820967E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820967E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820967E0);
		  /* 820967E0h */ case    0:  		/* li R27, 0 */
		/* 820967E0h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820967E0h case    0:*/		return 0x820967E4;
		  /* 820967E4h */ case    1:  		/* li R25, -1 */
		/* 820967E4h case    1:*/		cpu::op::li<0>(regs,&regs.R25,0xFFFFFFFF);
		/* 820967E4h case    1:*/		return 0x820967E8;
		  /* 820967E8h */ case    2:  		/* mr R21, R27 */
		/* 820967E8h case    2:*/		regs.R21 = regs.R27;
		/* 820967E8h case    2:*/		return 0x820967EC;
		  /* 820967ECh */ case    3:  		/* stw R27, <#[R1 + 100]> */
		/* 820967ECh case    3:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000064) );
		/* 820967ECh case    3:*/		return 0x820967F0;
		  /* 820967F0h */ case    4:  		/* stw R27, <#[R1 + 96]> */
		/* 820967F0h case    4:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000060) );
		/* 820967F0h case    4:*/		return 0x820967F4;
		  /* 820967F4h */ case    5:  		/* mr R16, R27 */
		/* 820967F4h case    5:*/		regs.R16 = regs.R27;
		/* 820967F4h case    5:*/		return 0x820967F8;
		  /* 820967F8h */ case    6:  		/* stw R27, <#[R1 + 92]> */
		/* 820967F8h case    6:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x0000005C) );
		/* 820967F8h case    6:*/		return 0x820967FC;
		  /* 820967FCh */ case    7:  		/* b 2252 */
		/* 820967FCh case    7:*/		return 0x820970C8;
		/* 820967FCh case    7:*/		return 0x82096800;
	}
	return 0x82096800;
} // Block from 820967E0h-82096800h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82096800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096800);
		  /* 82096800h */ case    0:  		/* cmpwi CR6, R8, 32 */
		/* 82096800h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000020);
		/* 82096800h case    0:*/		return 0x82096804;
		  /* 82096804h */ case    1:  		/* bc 12, CR6_EQ, 68 */
		/* 82096804h case    1:*/		if ( regs.CR[6].eq ) { return 0x82096848;  }
		/* 82096804h case    1:*/		return 0x82096808;
		  /* 82096808h */ case    2:  		/* cmpwi CR6, R8, 35 */
		/* 82096808h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000023);
		/* 82096808h case    2:*/		return 0x8209680C;
		  /* 8209680Ch */ case    3:  		/* bc 12, CR6_EQ, 52 */
		/* 8209680Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82096840;  }
		/* 8209680Ch case    3:*/		return 0x82096810;
		  /* 82096810h */ case    4:  		/* cmpwi CR6, R8, 43 */
		/* 82096810h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000002B);
		/* 82096810h case    4:*/		return 0x82096814;
		  /* 82096814h */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 82096814h case    5:*/		if ( regs.CR[6].eq ) { return 0x82096838;  }
		/* 82096814h case    5:*/		return 0x82096818;
		  /* 82096818h */ case    6:  		/* cmpwi CR6, R8, 45 */
		/* 82096818h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000002D);
		/* 82096818h case    6:*/		return 0x8209681C;
		  /* 8209681Ch */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 8209681Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x82096830;  }
		/* 8209681Ch case    7:*/		return 0x82096820;
		  /* 82096820h */ case    8:  		/* cmpwi CR6, R8, 48 */
		/* 82096820h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000030);
		/* 82096820h case    8:*/		return 0x82096824;
		  /* 82096824h */ case    9:  		/* bc 4, CR6_EQ, 2212 */
		/* 82096824h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820970C8;  }
		/* 82096824h case    9:*/		return 0x82096828;
		  /* 82096828h */ case   10:  		/* ori R27, R27, 8 */
		/* 82096828h case   10:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x8);
		/* 82096828h case   10:*/		return 0x8209682C;
		  /* 8209682Ch */ case   11:  		/* b 2204 */
		/* 8209682Ch case   11:*/		return 0x820970C8;
		/* 8209682Ch case   11:*/		return 0x82096830;
	}
	return 0x82096830;
} // Block from 82096800h-82096830h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82096830h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096830);
		  /* 82096830h */ case    0:  		/* ori R27, R27, 4 */
		/* 82096830h case    0:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x4);
		/* 82096830h case    0:*/		return 0x82096834;
		  /* 82096834h */ case    1:  		/* b 2196 */
		/* 82096834h case    1:*/		return 0x820970C8;
		/* 82096834h case    1:*/		return 0x82096838;
	}
	return 0x82096838;
} // Block from 82096830h-82096838h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82096838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096838);
		  /* 82096838h */ case    0:  		/* ori R27, R27, 1 */
		/* 82096838h case    0:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82096838h case    0:*/		return 0x8209683C;
		  /* 8209683Ch */ case    1:  		/* b 2188 */
		/* 8209683Ch case    1:*/		return 0x820970C8;
		/* 8209683Ch case    1:*/		return 0x82096840;
	}
	return 0x82096840;
} // Block from 82096838h-82096840h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82096840h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096840);
		  /* 82096840h */ case    0:  		/* ori R27, R27, 128 */
		/* 82096840h case    0:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x80);
		/* 82096840h case    0:*/		return 0x82096844;
		  /* 82096844h */ case    1:  		/* b 2180 */
		/* 82096844h case    1:*/		return 0x820970C8;
		/* 82096844h case    1:*/		return 0x82096848;
	}
	return 0x82096848;
} // Block from 82096840h-82096848h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82096848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096848);
		  /* 82096848h */ case    0:  		/* ori R27, R27, 2 */
		/* 82096848h case    0:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x2);
		/* 82096848h case    0:*/		return 0x8209684C;
		  /* 8209684Ch */ case    1:  		/* b 2172 */
		/* 8209684Ch case    1:*/		return 0x820970C8;
		/* 8209684Ch case    1:*/		return 0x82096850;
	}
	return 0x82096850;
} // Block from 82096848h-82096850h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82096850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096850);
		  /* 82096850h */ case    0:  		/* cmpwi CR6, R8, 42 */
		/* 82096850h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000002A);
		/* 82096850h case    0:*/		return 0x82096854;
		  /* 82096854h */ case    1:  		/* bc 4, CR6_EQ, 48 */
		/* 82096854h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82096884;  }
		/* 82096854h case    1:*/		return 0x82096858;
		  /* 82096858h */ case    2:  		/* addi R11, R26, 7 */
		/* 82096858h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x7);
		/* 82096858h case    2:*/		return 0x8209685C;
		  /* 8209685Ch */ case    3:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 8209685Ch case    3:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 8209685Ch case    3:*/		return 0x82096860;
		  /* 82096860h */ case    4:  		/* addi R26, R11, 8 */
		/* 82096860h case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x8);
		/* 82096860h case    4:*/		return 0x82096864;
		  /* 82096864h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 82096864h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82096864h case    5:*/		return 0x82096868;
		  /* 82096868h */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 82096868h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82096868h case    6:*/		return 0x8209686C;
		  /* 8209686Ch */ case    7:  		/* stw R11, <#[R1 + 96]> */
		/* 8209686Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 8209686Ch case    7:*/		return 0x82096870;
		  /* 82096870h */ case    8:  		/* bc 4, CR6_LT, 2136 */
		/* 82096870h case    8:*/		if ( !regs.CR[6].lt ) { return 0x820970C8;  }
		/* 82096870h case    8:*/		return 0x82096874;
		  /* 82096874h */ case    9:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 82096874h case    9:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 82096874h case    9:*/		return 0x82096878;
		  /* 82096878h */ case   10:  		/* ori R27, R27, 4 */
		/* 82096878h case   10:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x4);
		/* 82096878h case   10:*/		return 0x8209687C;
		  /* 8209687Ch */ case   11:  		/* neg R11, R11 */
		/* 8209687Ch case   11:*/		cpu::op::neg<0>(regs,&regs.R11,regs.R11);
		/* 8209687Ch case   11:*/		return 0x82096880;
		  /* 82096880h */ case   12:  		/* b 20 */
		/* 82096880h case   12:*/		return 0x82096894;
		/* 82096880h case   12:*/		return 0x82096884;
	}
	return 0x82096884;
} // Block from 82096850h-82096884h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82096884h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096884( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096884) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096884);
		  /* 82096884h */ case    0:  		/* lwz R11, <#[R1 + 96]> */
		/* 82096884h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82096884h case    0:*/		return 0x82096888;
		  /* 82096888h */ case    1:  		/* mulli R11, R11, 10 */
		/* 82096888h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xA);
		/* 82096888h case    1:*/		return 0x8209688C;
		  /* 8209688Ch */ case    2:  		/* add R11, R11, R8 */
		/* 8209688Ch case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8209688Ch case    2:*/		return 0x82096890;
		  /* 82096890h */ case    3:  		/* addi R11, R11, -48 */
		/* 82096890h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFD0);
		/* 82096890h case    3:*/		return 0x82096894;
	}
	return 0x82096894;
} // Block from 82096884h-82096894h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82096894h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096894( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096894) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096894);
		  /* 82096894h */ case    0:  		/* stw R11, <#[R1 + 96]> */
		/* 82096894h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82096894h case    0:*/		return 0x82096898;
		  /* 82096898h */ case    1:  		/* b 2096 */
		/* 82096898h case    1:*/		return 0x820970C8;
		/* 82096898h case    1:*/		return 0x8209689C;
	}
	return 0x8209689C;
} // Block from 82096894h-8209689Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209689Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209689C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209689C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209689C);
		  /* 8209689Ch */ case    0:  		/* li R25, 0 */
		/* 8209689Ch case    0:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 8209689Ch case    0:*/		return 0x820968A0;
		  /* 820968A0h */ case    1:  		/* b 2088 */
		/* 820968A0h case    1:*/		return 0x820970C8;
		/* 820968A0h case    1:*/		return 0x820968A4;
	}
	return 0x820968A4;
} // Block from 8209689Ch-820968A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820968A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820968A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820968A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820968A4);
		  /* 820968A4h */ case    0:  		/* cmpwi CR6, R8, 42 */
		/* 820968A4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000002A);
		/* 820968A4h case    0:*/		return 0x820968A8;
		  /* 820968A8h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 820968A8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820968CC;  }
		/* 820968A8h case    1:*/		return 0x820968AC;
		  /* 820968ACh */ case    2:  		/* addi R11, R26, 7 */
		/* 820968ACh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x7);
		/* 820968ACh case    2:*/		return 0x820968B0;
		  /* 820968B0h */ case    3:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 820968B0h case    3:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 820968B0h case    3:*/		return 0x820968B4;
		  /* 820968B4h */ case    4:  		/* addi R26, R11, 8 */
		/* 820968B4h case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x8);
		/* 820968B4h case    4:*/		return 0x820968B8;
		  /* 820968B8h */ case    5:  		/* lwz R25, <#[R11 + 4]> */
		/* 820968B8h case    5:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R11 + 0x00000004) );
		/* 820968B8h case    5:*/		return 0x820968BC;
		  /* 820968BCh */ case    6:  		/* cmpwi CR6, R25, 0 */
		/* 820968BCh case    6:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 820968BCh case    6:*/		return 0x820968C0;
		  /* 820968C0h */ case    7:  		/* bc 4, CR6_LT, 2056 */
		/* 820968C0h case    7:*/		if ( !regs.CR[6].lt ) { return 0x820970C8;  }
		/* 820968C0h case    7:*/		return 0x820968C4;
		  /* 820968C4h */ case    8:  		/* li R25, -1 */
		/* 820968C4h case    8:*/		cpu::op::li<0>(regs,&regs.R25,0xFFFFFFFF);
		/* 820968C4h case    8:*/		return 0x820968C8;
		  /* 820968C8h */ case    9:  		/* b 2048 */
		/* 820968C8h case    9:*/		return 0x820970C8;
		/* 820968C8h case    9:*/		return 0x820968CC;
	}
	return 0x820968CC;
} // Block from 820968A4h-820968CCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 820968CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820968CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820968CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820968CC);
		  /* 820968CCh */ case    0:  		/* mulli R11, R25, 10 */
		/* 820968CCh case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R25,0xA);
		/* 820968CCh case    0:*/		return 0x820968D0;
		  /* 820968D0h */ case    1:  		/* add R11, R11, R8 */
		/* 820968D0h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 820968D0h case    1:*/		return 0x820968D4;
		  /* 820968D4h */ case    2:  		/* addi R25, R11, -48 */
		/* 820968D4h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R11,0xFFFFFFD0);
		/* 820968D4h case    2:*/		return 0x820968D8;
		  /* 820968D8h */ case    3:  		/* b 2032 */
		/* 820968D8h case    3:*/		return 0x820970C8;
		/* 820968D8h case    3:*/		return 0x820968DC;
	}
	return 0x820968DC;
} // Block from 820968CCh-820968DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820968DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820968DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820968DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820968DC);
		  /* 820968DCh */ case    0:  		/* cmpwi CR6, R8, 73 */
		/* 820968DCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000049);
		/* 820968DCh case    0:*/		return 0x820968E0;
		  /* 820968E0h */ case    1:  		/* bc 12, CR6_EQ, 76 */
		/* 820968E0h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209692C;  }
		/* 820968E0h case    1:*/		return 0x820968E4;
		  /* 820968E4h */ case    2:  		/* cmpwi CR6, R8, 104 */
		/* 820968E4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000068);
		/* 820968E4h case    2:*/		return 0x820968E8;
		  /* 820968E8h */ case    3:  		/* bc 12, CR6_EQ, 60 */
		/* 820968E8h case    3:*/		if ( regs.CR[6].eq ) { return 0x82096924;  }
		/* 820968E8h case    3:*/		return 0x820968EC;
		  /* 820968ECh */ case    4:  		/* cmpwi CR6, R8, 108 */
		/* 820968ECh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000006C);
		/* 820968ECh case    4:*/		return 0x820968F0;
		  /* 820968F0h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 820968F0h case    5:*/		if ( regs.CR[6].eq ) { return 0x82096904;  }
		/* 820968F0h case    5:*/		return 0x820968F4;
		  /* 820968F4h */ case    6:  		/* cmpwi CR6, R8, 119 */
		/* 820968F4h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000077);
		/* 820968F4h case    6:*/		return 0x820968F8;
		  /* 820968F8h */ case    7:  		/* bc 4, CR6_EQ, 2000 */
		/* 820968F8h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820970C8;  }
		/* 820968F8h case    7:*/		return 0x820968FC;
		  /* 820968FCh */ case    8:  		/* ori R27, R27, 2048 */
		/* 820968FCh case    8:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x800);
		/* 820968FCh case    8:*/		return 0x82096900;
		  /* 82096900h */ case    9:  		/* b 1992 */
		/* 82096900h case    9:*/		return 0x820970C8;
		/* 82096900h case    9:*/		return 0x82096904;
	}
	return 0x82096904;
} // Block from 820968DCh-82096904h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82096904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096904);
		  /* 82096904h */ case    0:  		/* lbz R11, <#[R19 + 1]> */
		/* 82096904h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000001) );
		/* 82096904h case    0:*/		return 0x82096908;
		  /* 82096908h */ case    1:  		/* cmplwi CR6, R11, 108 */
		/* 82096908h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000006C);
		/* 82096908h case    1:*/		return 0x8209690C;
		  /* 8209690Ch */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 8209690Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x8209691C;  }
		/* 8209690Ch case    2:*/		return 0x82096910;
		  /* 82096910h */ case    3:  		/* addi R19, R19, 1 */
		/* 82096910h case    3:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x1);
		/* 82096910h case    3:*/		return 0x82096914;
		  /* 82096914h */ case    4:  		/* ori R27, R27, 4096 */
		/* 82096914h case    4:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x1000);
		/* 82096914h case    4:*/		return 0x82096918;
		  /* 82096918h */ case    5:  		/* b 1968 */
		/* 82096918h case    5:*/		return 0x820970C8;
		/* 82096918h case    5:*/		return 0x8209691C;
	}
	return 0x8209691C;
} // Block from 82096904h-8209691Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209691Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209691C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209691C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209691C);
		  /* 8209691Ch */ case    0:  		/* ori R27, R27, 16 */
		/* 8209691Ch case    0:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x10);
		/* 8209691Ch case    0:*/		return 0x82096920;
		  /* 82096920h */ case    1:  		/* b 1960 */
		/* 82096920h case    1:*/		return 0x820970C8;
		/* 82096920h case    1:*/		return 0x82096924;
	}
	return 0x82096924;
} // Block from 8209691Ch-82096924h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82096924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096924);
		  /* 82096924h */ case    0:  		/* ori R27, R27, 32 */
		/* 82096924h case    0:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x20);
		/* 82096924h case    0:*/		return 0x82096928;
		  /* 82096928h */ case    1:  		/* b 1952 */
		/* 82096928h case    1:*/		return 0x820970C8;
		/* 82096928h case    1:*/		return 0x8209692C;
	}
	return 0x8209692C;
} // Block from 82096924h-8209692Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209692Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209692C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209692C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209692C);
		  /* 8209692Ch */ case    0:  		/* lbz R11, <#[R19 + 1]> */
		/* 8209692Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000001) );
		/* 8209692Ch case    0:*/		return 0x82096930;
		  /* 82096930h */ case    1:  		/* extsb R11, R11 */
		/* 82096930h case    1:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 82096930h case    1:*/		return 0x82096934;
		  /* 82096934h */ case    2:  		/* cmpwi CR6, R11, 54 */
		/* 82096934h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000036);
		/* 82096934h case    2:*/		return 0x82096938;
		  /* 82096938h */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 82096938h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82096954;  }
		/* 82096938h case    3:*/		return 0x8209693C;
		  /* 8209693Ch */ case    4:  		/* lbz R10, <#[R19 + 2]> */
		/* 8209693Ch case    4:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R19 + 0x00000002) );
		/* 8209693Ch case    4:*/		return 0x82096940;
		  /* 82096940h */ case    5:  		/* cmplwi CR6, R10, 52 */
		/* 82096940h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000034);
		/* 82096940h case    5:*/		return 0x82096944;
		  /* 82096944h */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 82096944h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82096954;  }
		/* 82096944h case    6:*/		return 0x82096948;
		  /* 82096948h */ case    7:  		/* addi R19, R19, 2 */
		/* 82096948h case    7:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x2);
		/* 82096948h case    7:*/		return 0x8209694C;
		  /* 8209694Ch */ case    8:  		/* ori R27, R27, 32768 */
		/* 8209694Ch case    8:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x8000);
		/* 8209694Ch case    8:*/		return 0x82096950;
		  /* 82096950h */ case    9:  		/* b 1912 */
		/* 82096950h case    9:*/		return 0x820970C8;
		/* 82096950h case    9:*/		return 0x82096954;
	}
	return 0x82096954;
} // Block from 8209692Ch-82096954h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82096954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096954);
		  /* 82096954h */ case    0:  		/* cmpwi CR6, R11, 51 */
		/* 82096954h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000033);
		/* 82096954h case    0:*/		return 0x82096958;
		  /* 82096958h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 82096958h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82096974;  }
		/* 82096958h case    1:*/		return 0x8209695C;
		  /* 8209695Ch */ case    2:  		/* lbz R10, <#[R19 + 2]> */
		/* 8209695Ch case    2:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R19 + 0x00000002) );
		/* 8209695Ch case    2:*/		return 0x82096960;
		  /* 82096960h */ case    3:  		/* cmplwi CR6, R10, 50 */
		/* 82096960h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000032);
		/* 82096960h case    3:*/		return 0x82096964;
		  /* 82096964h */ case    4:  		/* bc 4, CR6_EQ, 16 */
		/* 82096964h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82096974;  }
		/* 82096964h case    4:*/		return 0x82096968;
		  /* 82096968h */ case    5:  		/* addi R19, R19, 2 */
		/* 82096968h case    5:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x2);
		/* 82096968h case    5:*/		return 0x8209696C;
		  /* 8209696Ch */ case    6:  		/* rlwinm R27, R27, 0, 17, 15 */
		/* 8209696Ch case    6:*/		cpu::op::rlwinm<0,0,17,15>(regs,&regs.R27,regs.R27);
		/* 8209696Ch case    6:*/		return 0x82096970;
		  /* 82096970h */ case    7:  		/* b 1880 */
		/* 82096970h case    7:*/		return 0x820970C8;
		/* 82096970h case    7:*/		return 0x82096974;
	}
	return 0x82096974;
} // Block from 82096954h-82096974h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82096974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096974);
		  /* 82096974h */ case    0:  		/* cmpwi CR6, R11, 100 */
		/* 82096974h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000064);
		/* 82096974h case    0:*/		return 0x82096978;
		  /* 82096978h */ case    1:  		/* bc 12, CR6_EQ, 1872 */
		/* 82096978h case    1:*/		if ( regs.CR[6].eq ) { return 0x820970C8;  }
		/* 82096978h case    1:*/		return 0x8209697C;
		  /* 8209697Ch */ case    2:  		/* cmpwi CR6, R11, 105 */
		/* 8209697Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000069);
		/* 8209697Ch case    2:*/		return 0x82096980;
		  /* 82096980h */ case    3:  		/* bc 12, CR6_EQ, 1864 */
		/* 82096980h case    3:*/		if ( regs.CR[6].eq ) { return 0x820970C8;  }
		/* 82096980h case    3:*/		return 0x82096984;
		  /* 82096984h */ case    4:  		/* cmpwi CR6, R11, 111 */
		/* 82096984h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000006F);
		/* 82096984h case    4:*/		return 0x82096988;
		  /* 82096988h */ case    5:  		/* bc 12, CR6_EQ, 1856 */
		/* 82096988h case    5:*/		if ( regs.CR[6].eq ) { return 0x820970C8;  }
		/* 82096988h case    5:*/		return 0x8209698C;
		  /* 8209698Ch */ case    6:  		/* cmpwi CR6, R11, 117 */
		/* 8209698Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000075);
		/* 8209698Ch case    6:*/		return 0x82096990;
		  /* 82096990h */ case    7:  		/* bc 12, CR6_EQ, 1848 */
		/* 82096990h case    7:*/		if ( regs.CR[6].eq ) { return 0x820970C8;  }
		/* 82096990h case    7:*/		return 0x82096994;
		  /* 82096994h */ case    8:  		/* cmpwi CR6, R11, 120 */
		/* 82096994h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000078);
		/* 82096994h case    8:*/		return 0x82096998;
		  /* 82096998h */ case    9:  		/* bc 12, CR6_EQ, 1840 */
		/* 82096998h case    9:*/		if ( regs.CR[6].eq ) { return 0x820970C8;  }
		/* 82096998h case    9:*/		return 0x8209699C;
		  /* 8209699Ch */ case   10:  		/* cmpwi CR6, R11, 88 */
		/* 8209699Ch case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000058);
		/* 8209699Ch case   10:*/		return 0x820969A0;
		  /* 820969A0h */ case   11:  		/* bc 12, CR6_EQ, 1832 */
		/* 820969A0h case   11:*/		if ( regs.CR[6].eq ) { return 0x820970C8;  }
		/* 820969A0h case   11:*/		return 0x820969A4;
		  /* 820969A4h */ case   12:  		/* li R11, 0 */
		/* 820969A4h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820969A4h case   12:*/		return 0x820969A8;
		  /* 820969A8h */ case   13:  		/* stw R11, <#[R1 + 108]> */
		/* 820969A8h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 820969A8h case   13:*/		return 0x820969AC;
	}
	return 0x820969AC;
} // Block from 82096974h-820969ACh (14 instructions)

//////////////////////////////////////////////////////
// Block at 820969ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820969AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820969AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820969AC);
		  /* 820969ACh */ case    0:  		/* mr R4, R23 */
		/* 820969ACh case    0:*/		regs.R4 = regs.R23;
		/* 820969ACh case    0:*/		return 0x820969B0;
		  /* 820969B0h */ case    1:  		/* rlwinm R3, R29, 0, 24, 31 */
		/* 820969B0h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R29);
		/* 820969B0h case    1:*/		return 0x820969B4;
		  /* 820969B4h */ case    2:  		/* li R16, 0 */
		/* 820969B4h case    2:*/		cpu::op::li<0>(regs,&regs.R16,0x0);
		/* 820969B4h case    2:*/		return 0x820969B8;
		  /* 820969B8h */ case    3:  		/* bl 17600 */
		/* 820969B8h case    3:*/		regs.LR = 0x820969BC; return 0x8209AE78;
		/* 820969B8h case    3:*/		return 0x820969BC;
		  /* 820969BCh */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820969BCh case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820969BCh case    4:*/		return 0x820969C0;
		  /* 820969C0h */ case    5:  		/* bc 12, CR0_EQ, 32 */
		/* 820969C0h case    5:*/		if ( regs.CR[0].eq ) { return 0x820969E0;  }
		/* 820969C0h case    5:*/		return 0x820969C4;
		  /* 820969C4h */ case    6:  		/* addi R5, R1, 80 */
		/* 820969C4h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820969C4h case    6:*/		return 0x820969C8;
		  /* 820969C8h */ case    7:  		/* mr R4, R18 */
		/* 820969C8h case    7:*/		regs.R4 = regs.R18;
		/* 820969C8h case    7:*/		return 0x820969CC;
		  /* 820969CCh */ case    8:  		/* mr R3, R29 */
		/* 820969CCh case    8:*/		regs.R3 = regs.R29;
		/* 820969CCh case    8:*/		return 0x820969D0;
		  /* 820969D0h */ case    9:  		/* bl 1880 */
		/* 820969D0h case    9:*/		regs.LR = 0x820969D4; return 0x82097128;
		/* 820969D0h case    9:*/		return 0x820969D4;
		  /* 820969D4h */ case   10:  		/* lbzu R29, <#[R19 + 1]> */
		/* 820969D4h case   10:*/		cpu::mem::load8z( regs, &regs.R29, (uint32)(regs.R19 + 0x00000001) );
		regs.R19 = (uint32)(regs.R19 + 0x00000001);
		/* 820969D4h case   10:*/		return 0x820969D8;
		  /* 820969D8h */ case   11:  		/* cmplwi CR0, R29, 0 */
		/* 820969D8h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R29,0x00000000);
		/* 820969D8h case   11:*/		return 0x820969DC;
		  /* 820969DCh */ case   12:  		/* bc 12, CR0_EQ, -932 */
		/* 820969DCh case   12:*/		if ( regs.CR[0].eq ) { return 0x82096638;  }
		/* 820969DCh case   12:*/		return 0x820969E0;
	}
	return 0x820969E0;
} // Block from 820969ACh-820969E0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820969E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820969E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820969E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820969E0);
		  /* 820969E0h */ case    0:  		/* addi R5, R1, 80 */
		/* 820969E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820969E0h case    0:*/		return 0x820969E4;
		  /* 820969E4h */ case    1:  		/* mr R4, R18 */
		/* 820969E4h case    1:*/		regs.R4 = regs.R18;
		/* 820969E4h case    1:*/		return 0x820969E8;
		  /* 820969E8h */ case    2:  		/* mr R3, R29 */
		/* 820969E8h case    2:*/		regs.R3 = regs.R29;
		/* 820969E8h case    2:*/		return 0x820969EC;
		  /* 820969ECh */ case    3:  		/* bl 1852 */
		/* 820969ECh case    3:*/		regs.LR = 0x820969F0; return 0x82097128;
		/* 820969ECh case    3:*/		return 0x820969F0;
		  /* 820969F0h */ case    4:  		/* lwz R24, <#[R1 + 80]> */
		/* 820969F0h case    4:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000050) );
		/* 820969F0h case    4:*/		return 0x820969F4;
		  /* 820969F4h */ case    5:  		/* b 1748 */
		/* 820969F4h case    5:*/		return 0x820970C8;
		/* 820969F4h case    5:*/		return 0x820969F8;
	}
	return 0x820969F8;
} // Block from 820969E0h-820969F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820969F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820969F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820969F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820969F8);
		  /* 820969F8h */ case    0:  		/* addi R11, R8, -65 */
		/* 820969F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0xFFFFFFBF);
		/* 820969F8h case    0:*/		return 0x820969FC;
		  /* 820969FCh */ case    1:  		/* cmplwi CR6, R11, 55 */
		/* 820969FCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000037);
		/* 820969FCh case    1:*/		return 0x82096A00;
		  /* 82096A00h */ case    2:  		/* bc 12, CR6_GT, 1272 */
		/* 82096A00h case    2:*/		if ( regs.CR[6].gt ) { return 0x82096EF8;  }
		/* 82096A00h case    2:*/		return 0x82096A04;
		  /* 82096A04h */ case    3:  		/* lis R12, -32255 */
		/* 82096A04h case    3:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8201);
		/* 82096A04h case    3:*/		return 0x82096A08;
		  /* 82096A08h */ case    4:  		/* rlwinm R0, R11, 1, 0, 30 */
		/* 82096A08h case    4:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R0,regs.R11);
		/* 82096A08h case    4:*/		return 0x82096A0C;
		  /* 82096A0Ch */ case    5:  		/* addi R12, R12, -21704 */
		/* 82096A0Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFAB38);
		/* 82096A0Ch case    5:*/		return 0x82096A10;
		  /* 82096A10h */ case    6:  		/* lhzx R0, <#[R12 + R0]> */
		/* 82096A10h case    6:*/		cpu::mem::load16z( regs, &regs.R0, (uint32)(regs.R12 + regs.R0 + 0x00000000) );
		/* 82096A10h case    6:*/		return 0x82096A14;
		  /* 82096A14h */ case    7:  		/* lis R12, -32247 */
		/* 82096A14h case    7:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8209);
		/* 82096A14h case    7:*/		return 0x82096A18;
		  /* 82096A18h */ case    8:  		/* addi R12, R12, 27180 */
		/* 82096A18h case    8:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x6A2C);
		/* 82096A18h case    8:*/		return 0x82096A1C;
		  /* 82096A1Ch */ case    9:  		/* ori R0, R0, 0 */
		/* 82096A1Ch case    9:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82096A1Ch case    9:*/		return 0x82096A20;
		  /* 82096A20h */ case   10:  		/* add R12, R12, R0 */
		/* 82096A20h case   10:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 82096A20h case   10:*/		return 0x82096A24;
		  /* 82096A24h */ case   11:  		/* mtspr CTR, R12 */
		/* 82096A24h case   11:*/		regs.CTR = regs.R12;
		/* 82096A24h case   11:*/		return 0x82096A28;
		  /* 82096A28h */ case   12:  		/* bcctr 20, CR0_LT */
		/* 82096A28h case   12:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 82096A28h case   12:*/		return 0x82096A2C;
		  /* 82096A2Ch */ case   13:  		/* andi. R11, R27, 2096 */
		/* 82096A2Ch case   13:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R27,0x830);
		/* 82096A2Ch case   13:*/		return 0x82096A30;
		  /* 82096A30h */ case   14:  		/* cmpwi CR0, R11, 0 */
		/* 82096A30h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 82096A30h case   14:*/		return 0x82096A34;
		  /* 82096A34h */ case   15:  		/* bc 4, CR0_EQ, 8 */
		/* 82096A34h case   15:*/		if ( !regs.CR[0].eq ) { return 0x82096A3C;  }
		/* 82096A34h case   15:*/		return 0x82096A38;
		  /* 82096A38h */ case   16:  		/* ori R27, R27, 2048 */
		/* 82096A38h case   16:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x800);
		/* 82096A38h case   16:*/		return 0x82096A3C;
	}
	return 0x82096A3C;
} // Block from 820969F8h-82096A3Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 82096A3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096A3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096A3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096A3C);
		  /* 82096A3Ch */ case    0:  		/* andi. R11, R27, 2064 */
		/* 82096A3Ch case    0:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R27,0x810);
		/* 82096A3Ch case    0:*/		return 0x82096A40;
		  /* 82096A40h */ case    1:  		/* cmpwi CR0, R11, 0 */
		/* 82096A40h case    1:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 82096A40h case    1:*/		return 0x82096A44;
		  /* 82096A44h */ case    2:  		/* addi R11, R26, 7 */
		/* 82096A44h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x7);
		/* 82096A44h case    2:*/		return 0x82096A48;
		  /* 82096A48h */ case    3:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82096A48h case    3:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82096A48h case    3:*/		return 0x82096A4C;
		  /* 82096A4Ch */ case    4:  		/* addi R26, R11, 8 */
		/* 82096A4Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x8);
		/* 82096A4Ch case    4:*/		return 0x82096A50;
		  /* 82096A50h */ case    5:  		/* bc 12, CR0_EQ, 44 */
		/* 82096A50h case    5:*/		if ( regs.CR[0].eq ) { return 0x82096A7C;  }
		/* 82096A50h case    5:*/		return 0x82096A54;
		  /* 82096A54h */ case    6:  		/* li R5, 512 */
		/* 82096A54h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x200);
		/* 82096A54h case    6:*/		return 0x82096A58;
		  /* 82096A58h */ case    7:  		/* lhz R6, <#[R11 + 6]> */
		/* 82096A58h case    7:*/		cpu::mem::load16z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000006) );
		/* 82096A58h case    7:*/		return 0x82096A5C;
		  /* 82096A5Ch */ case    8:  		/* addi R4, R1, 144 */
		/* 82096A5Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x90);
		/* 82096A5Ch case    8:*/		return 0x82096A60;
		  /* 82096A60h */ case    9:  		/* addi R3, R1, 84 */
		/* 82096A60h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x54);
		/* 82096A60h case    9:*/		return 0x82096A64;
		  /* 82096A64h */ case   10:  		/* bl 18028 */
		/* 82096A64h case   10:*/		regs.LR = 0x82096A68; return 0x8209B0D0;
		/* 82096A64h case   10:*/		return 0x82096A68;
		  /* 82096A68h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 82096A68h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82096A68h case   11:*/		return 0x82096A6C;
		  /* 82096A6Ch */ case   12:  		/* bc 12, CR0_EQ, 32 */
		/* 82096A6Ch case   12:*/		if ( regs.CR[0].eq ) { return 0x82096A8C;  }
		/* 82096A6Ch case   12:*/		return 0x82096A70;
		  /* 82096A70h */ case   13:  		/* li R11, 1 */
		/* 82096A70h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82096A70h case   13:*/		return 0x82096A74;
		  /* 82096A74h */ case   14:  		/* stw R11, <#[R1 + 100]> */
		/* 82096A74h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82096A74h case   14:*/		return 0x82096A78;
		  /* 82096A78h */ case   15:  		/* b 20 */
		/* 82096A78h case   15:*/		return 0x82096A8C;
		/* 82096A78h case   15:*/		return 0x82096A7C;
	}
	return 0x82096A7C;
} // Block from 82096A3Ch-82096A7Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 82096A7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096A7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096A7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096A7C);
		  /* 82096A7Ch */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 82096A7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82096A7Ch case    0:*/		return 0x82096A80;
		  /* 82096A80h */ case    1:  		/* li R10, 1 */
		/* 82096A80h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82096A80h case    1:*/		return 0x82096A84;
		  /* 82096A84h */ case    2:  		/* stw R10, <#[R1 + 84]> */
		/* 82096A84h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82096A84h case    2:*/		return 0x82096A88;
		  /* 82096A88h */ case    3:  		/* stb R11, <#[R1 + 144]> */
		/* 82096A88h case    3:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 82096A88h case    3:*/		return 0x82096A8C;
	}
	return 0x82096A8C;
} // Block from 82096A7Ch-82096A8Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82096A8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096A8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096A8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096A8C);
		  /* 82096A8Ch */ case    0:  		/* lwz R6, <#[R1 + 84]> */
		/* 82096A8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 82096A8Ch case    0:*/		return 0x82096A90;
		  /* 82096A90h */ case    1:  		/* addi R28, R1, 144 */
		/* 82096A90h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0x90);
		/* 82096A90h case    1:*/		return 0x82096A94;
		  /* 82096A94h */ case    2:  		/* b 1124 */
		/* 82096A94h case    2:*/		return 0x82096EF8;
		/* 82096A94h case    2:*/		return 0x82096A98;
		  /* 82096A98h */ case    3:  		/* addi R11, R26, 7 */
		/* 82096A98h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x7);
		/* 82096A98h case    3:*/		return 0x82096A9C;
		  /* 82096A9Ch */ case    4:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82096A9Ch case    4:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82096A9Ch case    4:*/		return 0x82096AA0;
		  /* 82096AA0h */ case    5:  		/* addi R26, R11, 8 */
		/* 82096AA0h case    5:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x8);
		/* 82096AA0h case    5:*/		return 0x82096AA4;
		  /* 82096AA4h */ case    6:  		/* lwz R11, <#[R11 + 4]> */
		/* 82096AA4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82096AA4h case    6:*/		return 0x82096AA8;
		  /* 82096AA8h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82096AA8h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82096AA8h case    7:*/		return 0x82096AAC;
		  /* 82096AACh */ case    8:  		/* bc 12, CR6_EQ, 60 */
		/* 82096AACh case    8:*/		if ( regs.CR[6].eq ) { return 0x82096AE8;  }
		/* 82096AACh case    8:*/		return 0x82096AB0;
		  /* 82096AB0h */ case    9:  		/* lwz R10, <#[R11 + 4]> */
		/* 82096AB0h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82096AB0h case    9:*/		return 0x82096AB4;
		  /* 82096AB4h */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 82096AB4h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82096AB4h case   10:*/		return 0x82096AB8;
		  /* 82096AB8h */ case   11:  		/* bc 12, CR6_EQ, 48 */
		/* 82096AB8h case   11:*/		if ( regs.CR[6].eq ) { return 0x82096AE8;  }
		/* 82096AB8h case   11:*/		return 0x82096ABC;
		  /* 82096ABCh */ case   12:  		/* rlwinm. R9, R27, 0, 20, 20 */
		/* 82096ABCh case   12:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R9,regs.R27);
		/* 82096ABCh case   12:*/		return 0x82096AC0;
		  /* 82096AC0h */ case   13:  		/* mr R28, R10 */
		/* 82096AC0h case   13:*/		regs.R28 = regs.R10;
		/* 82096AC0h case   13:*/		return 0x82096AC4;
		  /* 82096AC4h */ case   14:  		/* bc 12, CR0_EQ, 24 */
		/* 82096AC4h case   14:*/		if ( regs.CR[0].eq ) { return 0x82096ADC;  }
		/* 82096AC4h case   14:*/		return 0x82096AC8;
		  /* 82096AC8h */ case   15:  		/* lha R11, <#[R11]> */
		/* 82096AC8h case   15:*/		cpu::mem::load16a( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82096AC8h case   15:*/		return 0x82096ACC;
		  /* 82096ACCh */ case   16:  		/* li R16, 1 */
		/* 82096ACCh case   16:*/		cpu::op::li<0>(regs,&regs.R16,0x1);
		/* 82096ACCh case   16:*/		return 0x82096AD0;
		  /* 82096AD0h */ case   17:  		/* srawi R11, R11, 1 */
		/* 82096AD0h case   17:*/		cpu::op::srawi<0,1>(regs,&regs.R11,regs.R11);
		/* 82096AD0h case   17:*/		return 0x82096AD4;
		  /* 82096AD4h */ case   18:  		/* addze R6, R11 */
		/* 82096AD4h case   18:*/		cpu::op::addze<0>(regs,&regs.R6,regs.R11);
		/* 82096AD4h case   18:*/		return 0x82096AD8;
		  /* 82096AD8h */ case   19:  		/* b 1052 */
		/* 82096AD8h case   19:*/		return 0x82096EF4;
		/* 82096AD8h case   19:*/		return 0x82096ADC;
	}
	return 0x82096ADC;
} // Block from 82096A8Ch-82096ADCh (20 instructions)

//////////////////////////////////////////////////////
// Block at 82096ADCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096ADC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096ADC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096ADC);
		  /* 82096ADCh */ case    0:  		/* lha R6, <#[R11]> */
		/* 82096ADCh case    0:*/		cpu::mem::load16a( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 82096ADCh case    0:*/		return 0x82096AE0;
		  /* 82096AE0h */ case    1:  		/* li R16, 0 */
		/* 82096AE0h case    1:*/		cpu::op::li<0>(regs,&regs.R16,0x0);
		/* 82096AE0h case    1:*/		return 0x82096AE4;
		  /* 82096AE4h */ case    2:  		/* b 1040 */
		/* 82096AE4h case    2:*/		return 0x82096EF4;
		/* 82096AE4h case    2:*/		return 0x82096AE8;
	}
	return 0x82096AE8;
} // Block from 82096ADCh-82096AE8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82096AE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096AE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096AE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096AE8);
		  /* 82096AE8h */ case    0:  		/* lwz R28, <#[R20 - 21808]> */
		/* 82096AE8h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R20 + 0xFFFFAAD0) );
		/* 82096AE8h case    0:*/		return 0x82096AEC;
		  /* 82096AECh */ case    1:  		/* mr R11, R28 */
		/* 82096AECh case    1:*/		regs.R11 = regs.R28;
		/* 82096AECh case    1:*/		return 0x82096AF0;
		  /* 82096AF0h */ case    2:  		/* mr R10, R28 */
		/* 82096AF0h case    2:*/		regs.R10 = regs.R28;
		/* 82096AF0h case    2:*/		return 0x82096AF4;
		  /* 82096AF4h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 82096AF4h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82096AF4h case    3:*/		return 0x82096AF8;
		  /* 82096AF8h */ case    4:  		/* addi R11, R11, 1 */
		/* 82096AF8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82096AF8h case    4:*/		return 0x82096AFC;
		  /* 82096AFCh */ case    5:  		/* cmplwi CR6, R9, 0 */
		/* 82096AFCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82096AFCh case    5:*/		return 0x82096B00;
		  /* 82096B00h */ case    6:  		/* bc 4, CR6_EQ, -12 */
		/* 82096B00h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82096AF4;  }
		/* 82096B00h case    6:*/		return 0x82096B04;
		  /* 82096B04h */ case    7:  		/* subf R11, R10, R11 */
		/* 82096B04h case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82096B04h case    7:*/		return 0x82096B08;
		  /* 82096B08h */ case    8:  		/* addi R11, R11, -1 */
		/* 82096B08h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82096B08h case    8:*/		return 0x82096B0C;
		  /* 82096B0Ch */ case    9:  		/* rlwinm R6, R11, 0, 0, 31 */
		/* 82096B0Ch case    9:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R6,regs.R11);
		/* 82096B0Ch case    9:*/		return 0x82096B10;
		  /* 82096B10h */ case   10:  		/* b 996 */
		/* 82096B10h case   10:*/		return 0x82096EF4;
		/* 82096B10h case   10:*/		return 0x82096B14;
		  /* 82096B14h */ case   11:  		/* andi. R11, R27, 2096 */
		/* 82096B14h case   11:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R27,0x830);
		/* 82096B14h case   11:*/		return 0x82096B18;
		  /* 82096B18h */ case   12:  		/* cmpwi CR0, R11, 0 */
		/* 82096B18h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 82096B18h case   12:*/		return 0x82096B1C;
		  /* 82096B1Ch */ case   13:  		/* bc 4, CR0_EQ, 8 */
		/* 82096B1Ch case   13:*/		if ( !regs.CR[0].eq ) { return 0x82096B24;  }
		/* 82096B1Ch case   13:*/		return 0x82096B20;
		  /* 82096B20h */ case   14:  		/* ori R27, R27, 2048 */
		/* 82096B20h case   14:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x800);
		/* 82096B20h case   14:*/		return 0x82096B24;
	}
	return 0x82096B24;
} // Block from 82096AE8h-82096B24h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82096B24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096B24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096B24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096B24);
		  /* 82096B24h */ case    0:  		/* cmpwi CR6, R25, -1 */
		/* 82096B24h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R25,0xFFFFFFFF);
		/* 82096B24h case    0:*/		return 0x82096B28;
		  /* 82096B28h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 82096B28h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82096B38;  }
		/* 82096B28h case    1:*/		return 0x82096B2C;
		  /* 82096B2Ch */ case    2:  		/* lis R10, 32767 */
		/* 82096B2Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0x7FFF);
		/* 82096B2Ch case    2:*/		return 0x82096B30;
		  /* 82096B30h */ case    3:  		/* ori R10, R10, 65535 */
		/* 82096B30h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0xFFFF);
		/* 82096B30h case    3:*/		return 0x82096B34;
		  /* 82096B34h */ case    4:  		/* b 8 */
		/* 82096B34h case    4:*/		return 0x82096B3C;
		/* 82096B34h case    4:*/		return 0x82096B38;
	}
	return 0x82096B38;
} // Block from 82096B24h-82096B38h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82096B38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096B38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096B38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096B38);
		  /* 82096B38h */ case    0:  		/* mr R10, R25 */
		/* 82096B38h case    0:*/		regs.R10 = regs.R25;
		/* 82096B38h case    0:*/		return 0x82096B3C;
	}
	return 0x82096B3C;
} // Block from 82096B38h-82096B3Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82096B3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096B3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096B3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096B3C);
		  /* 82096B3Ch */ case    0:  		/* addi R11, R26, 7 */
		/* 82096B3Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x7);
		/* 82096B3Ch case    0:*/		return 0x82096B40;
		  /* 82096B40h */ case    1:  		/* andi. R9, R27, 2064 */
		/* 82096B40h case    1:*/		cpu::op::andi<1>(regs,&regs.R9,regs.R27,0x810);
		/* 82096B40h case    1:*/		return 0x82096B44;
		  /* 82096B44h */ case    2:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82096B44h case    2:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82096B44h case    2:*/		return 0x82096B48;
		  /* 82096B48h */ case    3:  		/* cmpwi CR0, R9, 0 */
		/* 82096B48h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 82096B48h case    3:*/		return 0x82096B4C;
		  /* 82096B4Ch */ case    4:  		/* addi R26, R11, 8 */
		/* 82096B4Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x8);
		/* 82096B4Ch case    4:*/		return 0x82096B50;
		  /* 82096B50h */ case    5:  		/* lwz R28, <#[R11 + 4]> */
		/* 82096B50h case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000004) );
		/* 82096B50h case    5:*/		return 0x82096B54;
		  /* 82096B54h */ case    6:  		/* cmplwi CR6, R28, 0 */
		/* 82096B54h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82096B54h case    6:*/		return 0x82096B58;
		  /* 82096B58h */ case    7:  		/* bc 12, CR0_EQ, 64 */
		/* 82096B58h case    7:*/		if ( regs.CR[0].eq ) { return 0x82096B98;  }
		/* 82096B58h case    7:*/		return 0x82096B5C;
		  /* 82096B5Ch */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 82096B5Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x82096B64;  }
		/* 82096B5Ch case    8:*/		return 0x82096B60;
		  /* 82096B60h */ case    9:  		/* lwz R28, <#[R15 - 21804]> */
		/* 82096B60h case    9:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R15 + 0xFFFFAAD4) );
		/* 82096B60h case    9:*/		return 0x82096B64;
	}
	return 0x82096B64;
} // Block from 82096B3Ch-82096B64h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82096B64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096B64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096B64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096B64);
		  /* 82096B64h */ case    0:  		/* li R16, 1 */
		/* 82096B64h case    0:*/		cpu::op::li<0>(regs,&regs.R16,0x1);
		/* 82096B64h case    0:*/		return 0x82096B68;
		  /* 82096B68h */ case    1:  		/* mr R11, R28 */
		/* 82096B68h case    1:*/		regs.R11 = regs.R28;
		/* 82096B68h case    1:*/		return 0x82096B6C;
		  /* 82096B6Ch */ case    2:  		/* b 24 */
		/* 82096B6Ch case    2:*/		return 0x82096B84;
		/* 82096B6Ch case    2:*/		return 0x82096B70;
		  /* 82096B70h */ case    3:  		/* lhz R9, <#[R11]> */
		/* 82096B70h case    3:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82096B70h case    3:*/		return 0x82096B74;
		  /* 82096B74h */ case    4:  		/* addi R10, R10, -1 */
		/* 82096B74h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82096B74h case    4:*/		return 0x82096B78;
		  /* 82096B78h */ case    5:  		/* cmplwi CR0, R9, 0 */
		/* 82096B78h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 82096B78h case    5:*/		return 0x82096B7C;
		  /* 82096B7Ch */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 82096B7Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x82096B8C;  }
		/* 82096B7Ch case    6:*/		return 0x82096B80;
		  /* 82096B80h */ case    7:  		/* addi R11, R11, 2 */
		/* 82096B80h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82096B80h case    7:*/		return 0x82096B84;
	}
	return 0x82096B84;
} // Block from 82096B64h-82096B84h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82096B84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096B84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096B84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096B84);
		  /* 82096B84h */ case    0:  		/* cmpwi CR6, R10, 0 */
		/* 82096B84h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82096B84h case    0:*/		return 0x82096B88;
		  /* 82096B88h */ case    1:  		/* bc 4, CR6_EQ, -24 */
		/* 82096B88h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82096B70;  }
		/* 82096B88h case    1:*/		return 0x82096B8C;
	}
	return 0x82096B8C;
} // Block from 82096B84h-82096B8Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82096B8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096B8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096B8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096B8C);
		  /* 82096B8Ch */ case    0:  		/* subf R11, R28, R11 */
		/* 82096B8Ch case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 82096B8Ch case    0:*/		return 0x82096B90;
		  /* 82096B90h */ case    1:  		/* srawi R6, R11, 1 */
		/* 82096B90h case    1:*/		cpu::op::srawi<0,1>(regs,&regs.R6,regs.R11);
		/* 82096B90h case    1:*/		return 0x82096B94;
		  /* 82096B94h */ case    2:  		/* b 864 */
		/* 82096B94h case    2:*/		return 0x82096EF4;
		/* 82096B94h case    2:*/		return 0x82096B98;
	}
	return 0x82096B98;
} // Block from 82096B8Ch-82096B98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82096B98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096B98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096B98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096B98);
		  /* 82096B98h */ case    0:  		/* bc 4, CR6_EQ, 8 */
		/* 82096B98h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82096BA0;  }
		/* 82096B98h case    0:*/		return 0x82096B9C;
		  /* 82096B9Ch */ case    1:  		/* lwz R28, <#[R20 - 21808]> */
		/* 82096B9Ch case    1:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R20 + 0xFFFFAAD0) );
		/* 82096B9Ch case    1:*/		return 0x82096BA0;
	}
	return 0x82096BA0;
} // Block from 82096B98h-82096BA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82096BA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096BA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096BA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096BA0);
		  /* 82096BA0h */ case    0:  		/* mr R11, R28 */
		/* 82096BA0h case    0:*/		regs.R11 = regs.R28;
		/* 82096BA0h case    0:*/		return 0x82096BA4;
		  /* 82096BA4h */ case    1:  		/* b 24 */
		/* 82096BA4h case    1:*/		return 0x82096BBC;
		/* 82096BA4h case    1:*/		return 0x82096BA8;
		  /* 82096BA8h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 82096BA8h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82096BA8h case    2:*/		return 0x82096BAC;
		  /* 82096BACh */ case    3:  		/* addi R10, R10, -1 */
		/* 82096BACh case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82096BACh case    3:*/		return 0x82096BB0;
		  /* 82096BB0h */ case    4:  		/* cmplwi CR0, R9, 0 */
		/* 82096BB0h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 82096BB0h case    4:*/		return 0x82096BB4;
		  /* 82096BB4h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 82096BB4h case    5:*/		if ( regs.CR[0].eq ) { return 0x82096BC4;  }
		/* 82096BB4h case    5:*/		return 0x82096BB8;
		  /* 82096BB8h */ case    6:  		/* addi R11, R11, 1 */
		/* 82096BB8h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82096BB8h case    6:*/		return 0x82096BBC;
	}
	return 0x82096BBC;
} // Block from 82096BA0h-82096BBCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 82096BBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096BBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096BBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096BBC);
		  /* 82096BBCh */ case    0:  		/* cmpwi CR6, R10, 0 */
		/* 82096BBCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82096BBCh case    0:*/		return 0x82096BC0;
		  /* 82096BC0h */ case    1:  		/* bc 4, CR6_EQ, -24 */
		/* 82096BC0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82096BA8;  }
		/* 82096BC0h case    1:*/		return 0x82096BC4;
	}
	return 0x82096BC4;
} // Block from 82096BBCh-82096BC4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82096BC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096BC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096BC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096BC4);
		  /* 82096BC4h */ case    0:  		/* subf R6, R28, R11 */
		/* 82096BC4h case    0:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R28,regs.R11);
		/* 82096BC4h case    0:*/		return 0x82096BC8;
		  /* 82096BC8h */ case    1:  		/* b 812 */
		/* 82096BC8h case    1:*/		return 0x82096EF4;
		/* 82096BC8h case    1:*/		return 0x82096BCC;
		  /* 82096BCCh */ case    2:  		/* addi R11, R26, 7 */
		/* 82096BCCh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x7);
		/* 82096BCCh case    2:*/		return 0x82096BD0;
		  /* 82096BD0h */ case    3:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82096BD0h case    3:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82096BD0h case    3:*/		return 0x82096BD4;
		  /* 82096BD4h */ case    4:  		/* addi R26, R11, 8 */
		/* 82096BD4h case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x8);
		/* 82096BD4h case    4:*/		return 0x82096BD8;
		  /* 82096BD8h */ case    5:  		/* lwz R31, <#[R11 + 4]> */
		/* 82096BD8h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 82096BD8h case    5:*/		return 0x82096BDC;
		  /* 82096BDCh */ case    6:  		/* bl 17012 */
		/* 82096BDCh case    6:*/		regs.LR = 0x82096BE0; return 0x8209AE50;
		/* 82096BDCh case    6:*/		return 0x82096BE0;
		  /* 82096BE0h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 82096BE0h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82096BE0h case    7:*/		return 0x82096BE4;
		  /* 82096BE4h */ case    8:  		/* bc 12, CR0_EQ, -1452 */
		/* 82096BE4h case    8:*/		if ( regs.CR[0].eq ) { return 0x82096638;  }
		/* 82096BE4h case    8:*/		return 0x82096BE8;
		  /* 82096BE8h */ case    9:  		/* rlwinm. R11, R27, 0, 26, 26 */
		/* 82096BE8h case    9:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R27);
		/* 82096BE8h case    9:*/		return 0x82096BEC;
		  /* 82096BECh */ case   10:  		/* bc 12, CR0_EQ, 12 */
		/* 82096BECh case   10:*/		if ( regs.CR[0].eq ) { return 0x82096BF8;  }
		/* 82096BECh case   10:*/		return 0x82096BF0;
		  /* 82096BF0h */ case   11:  		/* sth R24, <#[R31]> */
		/* 82096BF0h case   11:*/		cpu::mem::store16( regs, regs.R24, (uint32)(regs.R31 + 0x00000000) );
		/* 82096BF0h case   11:*/		return 0x82096BF4;
		  /* 82096BF4h */ case   12:  		/* b 8 */
		/* 82096BF4h case   12:*/		return 0x82096BFC;
		/* 82096BF4h case   12:*/		return 0x82096BF8;
	}
	return 0x82096BF8;
} // Block from 82096BC4h-82096BF8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82096BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096BF8);
		  /* 82096BF8h */ case    0:  		/* stw R24, <#[R31]> */
		/* 82096BF8h case    0:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000000) );
		/* 82096BF8h case    0:*/		return 0x82096BFC;
	}
	return 0x82096BFC;
} // Block from 82096BF8h-82096BFCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82096BFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096BFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096BFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096BFC);
		  /* 82096BFCh */ case    0:  		/* li R11, 1 */
		/* 82096BFCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82096BFCh case    0:*/		return 0x82096C00;
		  /* 82096C00h */ case    1:  		/* stw R11, <#[R1 + 100]> */
		/* 82096C00h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82096C00h case    1:*/		return 0x82096C04;
		  /* 82096C04h */ case    2:  		/* b 1200 */
		/* 82096C04h case    2:*/		return 0x820970B4;
		/* 82096C04h case    2:*/		return 0x82096C08;
		  /* 82096C08h */ case    3:  		/* addi R11, R8, 32 */
		/* 82096C08h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0x20);
		/* 82096C08h case    3:*/		return 0x82096C0C;
		  /* 82096C0Ch */ case    4:  		/* li R21, 1 */
		/* 82096C0Ch case    4:*/		cpu::op::li<0>(regs,&regs.R21,0x1);
		/* 82096C0Ch case    4:*/		return 0x82096C10;
		  /* 82096C10h */ case    5:  		/* extsb R29, R11 */
		/* 82096C10h case    5:*/		cpu::op::extsb<0>(regs,&regs.R29,regs.R11);
		/* 82096C10h case    5:*/		return 0x82096C14;
		  /* 82096C14h */ case    6:  		/* ori R27, R27, 64 */
		/* 82096C14h case    6:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x40);
		/* 82096C14h case    6:*/		return 0x82096C18;
		  /* 82096C18h */ case    7:  		/* addi R28, R1, 144 */
		/* 82096C18h case    7:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0x90);
		/* 82096C18h case    7:*/		return 0x82096C1C;
		  /* 82096C1Ch */ case    8:  		/* li R30, 512 */
		/* 82096C1Ch case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x200);
		/* 82096C1Ch case    8:*/		return 0x82096C20;
		  /* 82096C20h */ case    9:  		/* cmpwi CR6, R25, 0 */
		/* 82096C20h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82096C20h case    9:*/		return 0x82096C24;
		  /* 82096C24h */ case   10:  		/* bc 4, CR6_LT, 12 */
		/* 82096C24h case   10:*/		if ( !regs.CR[6].lt ) { return 0x82096C30;  }
		/* 82096C24h case   10:*/		return 0x82096C28;
		  /* 82096C28h */ case   11:  		/* li R25, 6 */
		/* 82096C28h case   11:*/		cpu::op::li<0>(regs,&regs.R25,0x6);
		/* 82096C28h case   11:*/		return 0x82096C2C;
		  /* 82096C2Ch */ case   12:  		/* b 84 */
		/* 82096C2Ch case   12:*/		return 0x82096C80;
		/* 82096C2Ch case   12:*/		return 0x82096C30;
	}
	return 0x82096C30;
} // Block from 82096BFCh-82096C30h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82096C30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096C30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096C30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096C30);
		  /* 82096C30h */ case    0:  		/* bc 4, CR6_EQ, 24 */
		/* 82096C30h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82096C48;  }
		/* 82096C30h case    0:*/		return 0x82096C34;
		  /* 82096C34h */ case    1:  		/* extsb R11, R29 */
		/* 82096C34h case    1:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R29);
		/* 82096C34h case    1:*/		return 0x82096C38;
		  /* 82096C38h */ case    2:  		/* cmpwi CR6, R11, 103 */
		/* 82096C38h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000067);
		/* 82096C38h case    2:*/		return 0x82096C3C;
		  /* 82096C3Ch */ case    3:  		/* bc 4, CR6_EQ, 68 */
		/* 82096C3Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82096C80;  }
		/* 82096C3Ch case    3:*/		return 0x82096C40;
		  /* 82096C40h */ case    4:  		/* li R25, 1 */
		/* 82096C40h case    4:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 82096C40h case    4:*/		return 0x82096C44;
		  /* 82096C44h */ case    5:  		/* b 60 */
		/* 82096C44h case    5:*/		return 0x82096C80;
		/* 82096C44h case    5:*/		return 0x82096C48;
	}
	return 0x82096C48;
} // Block from 82096C30h-82096C48h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82096C48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096C48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096C48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096C48);
		  /* 82096C48h */ case    0:  		/* cmpwi CR6, R25, 512 */
		/* 82096C48h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000200);
		/* 82096C48h case    0:*/		return 0x82096C4C;
		  /* 82096C4Ch */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 82096C4Ch case    1:*/		if ( !regs.CR[6].gt ) { return 0x82096C54;  }
		/* 82096C4Ch case    1:*/		return 0x82096C50;
		  /* 82096C50h */ case    2:  		/* li R25, 512 */
		/* 82096C50h case    2:*/		cpu::op::li<0>(regs,&regs.R25,0x200);
		/* 82096C50h case    2:*/		return 0x82096C54;
	}
	return 0x82096C54;
} // Block from 82096C48h-82096C54h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82096C54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096C54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096C54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096C54);
		  /* 82096C54h */ case    0:  		/* cmpwi CR6, R25, 163 */
		/* 82096C54h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x000000A3);
		/* 82096C54h case    0:*/		return 0x82096C58;
		  /* 82096C58h */ case    1:  		/* bc 4, CR6_GT, 40 */
		/* 82096C58h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82096C80;  }
		/* 82096C58h case    1:*/		return 0x82096C5C;
		  /* 82096C5Ch */ case    2:  		/* addi R31, R25, 349 */
		/* 82096C5Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R25,0x15D);
		/* 82096C5Ch case    2:*/		return 0x82096C60;
		  /* 82096C60h */ case    3:  		/* mr R3, R31 */
		/* 82096C60h case    3:*/		regs.R3 = regs.R31;
		/* 82096C60h case    3:*/		return 0x82096C64;
		  /* 82096C64h */ case    4:  		/* bl -13276 */
		/* 82096C64h case    4:*/		regs.LR = 0x82096C68; return 0x82093888;
		/* 82096C64h case    4:*/		return 0x82096C68;
		  /* 82096C68h */ case    5:  		/* or. R14, R3, R3 */
		/* 82096C68h case    5:*/		cpu::op::or<1>(regs,&regs.R14,regs.R3,regs.R3);
		/* 82096C68h case    5:*/		return 0x82096C6C;
		  /* 82096C6Ch */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 82096C6Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x82096C7C;  }
		/* 82096C6Ch case    6:*/		return 0x82096C70;
		  /* 82096C70h */ case    7:  		/* mr R28, R14 */
		/* 82096C70h case    7:*/		regs.R28 = regs.R14;
		/* 82096C70h case    7:*/		return 0x82096C74;
		  /* 82096C74h */ case    8:  		/* mr R30, R31 */
		/* 82096C74h case    8:*/		regs.R30 = regs.R31;
		/* 82096C74h case    8:*/		return 0x82096C78;
		  /* 82096C78h */ case    9:  		/* b 8 */
		/* 82096C78h case    9:*/		return 0x82096C80;
		/* 82096C78h case    9:*/		return 0x82096C7C;
	}
	return 0x82096C7C;
} // Block from 82096C54h-82096C7Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 82096C7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096C7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096C7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096C7C);
		  /* 82096C7Ch */ case    0:  		/* li R25, 163 */
		/* 82096C7Ch case    0:*/		cpu::op::li<0>(regs,&regs.R25,0xA3);
		/* 82096C7Ch case    0:*/		return 0x82096C80;
	}
	return 0x82096C80;
} // Block from 82096C7Ch-82096C80h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82096C80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096C80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096C80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096C80);
		  /* 82096C80h */ case    0:  		/* addi R11, R26, 7 */
		/* 82096C80h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x7);
		/* 82096C80h case    0:*/		return 0x82096C84;
		  /* 82096C84h */ case    1:  		/* lwz R10, <#[R22 + 24]> */
		/* 82096C84h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000018) );
		/* 82096C84h case    1:*/		return 0x82096C88;
		  /* 82096C88h */ case    2:  		/* extsb R31, R29 */
		/* 82096C88h case    2:*/		cpu::op::extsb<0>(regs,&regs.R31,regs.R29);
		/* 82096C88h case    2:*/		return 0x82096C8C;
		  /* 82096C8Ch */ case    3:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82096C8Ch case    3:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82096C8Ch case    3:*/		return 0x82096C90;
		  /* 82096C90h */ case    4:  		/* mr R9, R23 */
		/* 82096C90h case    4:*/		regs.R9 = regs.R23;
		/* 82096C90h case    4:*/		return 0x82096C94;
		  /* 82096C94h */ case    5:  		/* mr R8, R21 */
		/* 82096C94h case    5:*/		regs.R8 = regs.R21;
		/* 82096C94h case    5:*/		return 0x82096C98;
		  /* 82096C98h */ case    6:  		/* mtspr CTR, R10 */
		/* 82096C98h case    6:*/		regs.CTR = regs.R10;
		/* 82096C98h case    6:*/		return 0x82096C9C;
		  /* 82096C9Ch */ case    7:  		/* mr R7, R25 */
		/* 82096C9Ch case    7:*/		regs.R7 = regs.R25;
		/* 82096C9Ch case    7:*/		return 0x82096CA0;
		  /* 82096CA0h */ case    8:  		/* mr R6, R31 */
		/* 82096CA0h case    8:*/		regs.R6 = regs.R31;
		/* 82096CA0h case    8:*/		return 0x82096CA4;
		  /* 82096CA4h */ case    9:  		/* ld R10, <#[R11]> */
		/* 82096CA4h case    9:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82096CA4h case    9:*/		return 0x82096CA8;
		  /* 82096CA8h */ case   10:  		/* mr R5, R30 */
		/* 82096CA8h case   10:*/		regs.R5 = regs.R30;
		/* 82096CA8h case   10:*/		return 0x82096CAC;
		  /* 82096CACh */ case   11:  		/* mr R4, R28 */
		/* 82096CACh case   11:*/		regs.R4 = regs.R28;
		/* 82096CACh case   11:*/		return 0x82096CB0;
		  /* 82096CB0h */ case   12:  		/* addi R3, R1, 128 */
		/* 82096CB0h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 82096CB0h case   12:*/		return 0x82096CB4;
		  /* 82096CB4h */ case   13:  		/* addi R26, R11, 8 */
		/* 82096CB4h case   13:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x8);
		/* 82096CB4h case   13:*/		return 0x82096CB8;
		  /* 82096CB8h */ case   14:  		/* std R10, <#[R1 + 128]> */
		/* 82096CB8h case   14:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000080) );
		/* 82096CB8h case   14:*/		return 0x82096CBC;
		  /* 82096CBCh */ case   15:  		/* bcctrl 20, CR0_LT */
		/* 82096CBCh case   15:*/		if ( 1 ) { regs.LR = 0x82096CC0; return (uint32)regs.CTR; }
		/* 82096CBCh case   15:*/		return 0x82096CC0;
		  /* 82096CC0h */ case   16:  		/* rlwinm. R30, R27, 0, 24, 24 */
		/* 82096CC0h case   16:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R30,regs.R27);
		/* 82096CC0h case   16:*/		return 0x82096CC4;
		  /* 82096CC4h */ case   17:  		/* bc 12, CR0_EQ, 32 */
		/* 82096CC4h case   17:*/		if ( regs.CR[0].eq ) { return 0x82096CE4;  }
		/* 82096CC4h case   17:*/		return 0x82096CC8;
		  /* 82096CC8h */ case   18:  		/* cmpwi CR6, R25, 0 */
		/* 82096CC8h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82096CC8h case   18:*/		return 0x82096CCC;
		  /* 82096CCCh */ case   19:  		/* bc 4, CR6_EQ, 24 */
		/* 82096CCCh case   19:*/		if ( !regs.CR[6].eq ) { return 0x82096CE4;  }
		/* 82096CCCh case   19:*/		return 0x82096CD0;
		  /* 82096CD0h */ case   20:  		/* lwz R11, <#[R22 + 36]> */
		/* 82096CD0h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000024) );
		/* 82096CD0h case   20:*/		return 0x82096CD4;
		  /* 82096CD4h */ case   21:  		/* mr R4, R23 */
		/* 82096CD4h case   21:*/		regs.R4 = regs.R23;
		/* 82096CD4h case   21:*/		return 0x82096CD8;
		  /* 82096CD8h */ case   22:  		/* mr R3, R28 */
		/* 82096CD8h case   22:*/		regs.R3 = regs.R28;
		/* 82096CD8h case   22:*/		return 0x82096CDC;
		  /* 82096CDCh */ case   23:  		/* mtspr CTR, R11 */
		/* 82096CDCh case   23:*/		regs.CTR = regs.R11;
		/* 82096CDCh case   23:*/		return 0x82096CE0;
		  /* 82096CE0h */ case   24:  		/* bcctrl 20, CR0_LT */
		/* 82096CE0h case   24:*/		if ( 1 ) { regs.LR = 0x82096CE4; return (uint32)regs.CTR; }
		/* 82096CE0h case   24:*/		return 0x82096CE4;
	}
	return 0x82096CE4;
} // Block from 82096C80h-82096CE4h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82096CE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096CE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096CE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096CE4);
		  /* 82096CE4h */ case    0:  		/* cmpwi CR6, R31, 103 */
		/* 82096CE4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000067);
		/* 82096CE4h case    0:*/		return 0x82096CE8;
	}
	return 0x82096CE8;
} // Block from 82096CE4h-82096CE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82096CE8h
// Function 'write_char'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096CE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096CE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096CE8);
		  /* 82096CE8h */ case    0:  		/* bc 4, CR6_EQ, 32 */
		/* 82096CE8h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82096D08;  }
		/* 82096CE8h case    0:*/		return 0x82096CEC;
		  /* 82096CECh */ case    1:  		/* cmpwi CR6, R30, 0 */
		/* 82096CECh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82096CECh case    1:*/		return 0x82096CF0;
		  /* 82096CF0h */ case    2:  		/* bc 4, CR6_EQ, 24 */
		/* 82096CF0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82096D08;  }
		/* 82096CF0h case    2:*/		return 0x82096CF4;
		  /* 82096CF4h */ case    3:  		/* lwz R11, <#[R22 + 32]> */
		/* 82096CF4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000020) );
		/* 82096CF4h case    3:*/		return 0x82096CF8;
		  /* 82096CF8h */ case    4:  		/* mr R4, R23 */
		/* 82096CF8h case    4:*/		regs.R4 = regs.R23;
		/* 82096CF8h case    4:*/		return 0x82096CFC;
		  /* 82096CFCh */ case    5:  		/* mr R3, R28 */
		/* 82096CFCh case    5:*/		regs.R3 = regs.R28;
		/* 82096CFCh case    5:*/		return 0x82096D00;
		  /* 82096D00h */ case    6:  		/* mtspr CTR, R11 */
		/* 82096D00h case    6:*/		regs.CTR = regs.R11;
		/* 82096D00h case    6:*/		return 0x82096D04;
		  /* 82096D04h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 82096D04h case    7:*/		if ( 1 ) { regs.LR = 0x82096D08; return (uint32)regs.CTR; }
		/* 82096D04h case    7:*/		return 0x82096D08;
	}
	return 0x82096D08;
} // Block from 82096CE8h-82096D08h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82096D08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096D08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096D08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096D08);
		  /* 82096D08h */ case    0:  		/* lbz R11, <#[R28]> */
		/* 82096D08h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82096D08h case    0:*/		return 0x82096D0C;
		  /* 82096D0Ch */ case    1:  		/* cmplwi CR6, R11, 45 */
		/* 82096D0Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002D);
		/* 82096D0Ch case    1:*/		return 0x82096D10;
		  /* 82096D10h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 82096D10h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82096D1C;  }
		/* 82096D10h case    2:*/		return 0x82096D14;
		  /* 82096D14h */ case    3:  		/* ori R27, R27, 256 */
		/* 82096D14h case    3:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x100);
		/* 82096D14h case    3:*/		return 0x82096D18;
		  /* 82096D18h */ case    4:  		/* addi R28, R28, 1 */
		/* 82096D18h case    4:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82096D18h case    4:*/		return 0x82096D1C;
	}
	return 0x82096D1C;
} // Block from 82096D08h-82096D1Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82096D1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096D1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096D1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096D1C);
		  /* 82096D1Ch */ case    0:  		/* mr R11, R28 */
		/* 82096D1Ch case    0:*/		regs.R11 = regs.R28;
		/* 82096D1Ch case    0:*/		return 0x82096D20;
		  /* 82096D20h */ case    1:  		/* lbz R10, <#[R11]> */
		/* 82096D20h case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82096D20h case    1:*/		return 0x82096D24;
		  /* 82096D24h */ case    2:  		/* addi R11, R11, 1 */
		/* 82096D24h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82096D24h case    2:*/		return 0x82096D28;
		  /* 82096D28h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 82096D28h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82096D28h case    3:*/		return 0x82096D2C;
		  /* 82096D2Ch */ case    4:  		/* bc 4, CR6_EQ, -12 */
		/* 82096D2Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x82096D20;  }
		/* 82096D2Ch case    4:*/		return 0x82096D30;
		  /* 82096D30h */ case    5:  		/* subf R11, R28, R11 */
		/* 82096D30h case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 82096D30h case    5:*/		return 0x82096D34;
		  /* 82096D34h */ case    6:  		/* b -556 */
		/* 82096D34h case    6:*/		return 0x82096B08;
		/* 82096D34h case    6:*/		return 0x82096D38;
		  /* 82096D38h */ case    7:  		/* ori R27, R27, 64 */
		/* 82096D38h case    7:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x40);
		/* 82096D38h case    7:*/		return 0x82096D3C;
		  /* 82096D3Ch */ case    8:  		/* li R8, 10 */
		/* 82096D3Ch case    8:*/		cpu::op::li<0>(regs,&regs.R8,0xA);
		/* 82096D3Ch case    8:*/		return 0x82096D40;
		  /* 82096D40h */ case    9:  		/* b 80 */
		/* 82096D40h case    9:*/		return 0x82096D90;
		/* 82096D40h case    9:*/		return 0x82096D44;
		  /* 82096D44h */ case   10:  		/* li R25, 8 */
		/* 82096D44h case   10:*/		cpu::op::li<0>(regs,&regs.R25,0x8);
		/* 82096D44h case   10:*/		return 0x82096D48;
		  /* 82096D48h */ case   11:  		/* li R11, 7 */
		/* 82096D48h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 82096D48h case   11:*/		return 0x82096D4C;
		  /* 82096D4Ch */ case   12:  		/* b 8 */
		/* 82096D4Ch case   12:*/		return 0x82096D54;
		/* 82096D4Ch case   12:*/		return 0x82096D50;
		  /* 82096D50h */ case   13:  		/* li R11, 39 */
		/* 82096D50h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x27);
		/* 82096D50h case   13:*/		return 0x82096D54;
	}
	return 0x82096D54;
} // Block from 82096D1Ch-82096D54h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82096D54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096D54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096D54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096D54);
		  /* 82096D54h */ case    0:  		/* stw R11, <#[R1 + 104]> */
		/* 82096D54h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 82096D54h case    0:*/		return 0x82096D58;
		  /* 82096D58h */ case    1:  		/* rlwinm. R10, R27, 0, 24, 24 */
		/* 82096D58h case    1:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R10,regs.R27);
		/* 82096D58h case    1:*/		return 0x82096D5C;
		  /* 82096D5Ch */ case    2:  		/* li R8, 16 */
		/* 82096D5Ch case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x10);
		/* 82096D5Ch case    2:*/		return 0x82096D60;
		  /* 82096D60h */ case    3:  		/* bc 12, CR0_EQ, 48 */
		/* 82096D60h case    3:*/		if ( regs.CR[0].eq ) { return 0x82096D90;  }
		/* 82096D60h case    3:*/		return 0x82096D64;
		  /* 82096D64h */ case    4:  		/* addi R11, R11, 81 */
		/* 82096D64h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x51);
		/* 82096D64h case    4:*/		return 0x82096D68;
		  /* 82096D68h */ case    5:  		/* li R10, 48 */
		/* 82096D68h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x30);
		/* 82096D68h case    5:*/		return 0x82096D6C;
		  /* 82096D6Ch */ case    6:  		/* li R9, 2 */
		/* 82096D6Ch case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 82096D6Ch case    6:*/		return 0x82096D70;
		  /* 82096D70h */ case    7:  		/* stb R11, <#[R1 + 89]> */
		/* 82096D70h case    7:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000059) );
		/* 82096D70h case    7:*/		return 0x82096D74;
		  /* 82096D74h */ case    8:  		/* stb R10, <#[R1 + 88]> */
		/* 82096D74h case    8:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82096D74h case    8:*/		return 0x82096D78;
		  /* 82096D78h */ case    9:  		/* stw R9, <#[R1 + 92]> */
		/* 82096D78h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000005C) );
		/* 82096D78h case    9:*/		return 0x82096D7C;
		  /* 82096D7Ch */ case   10:  		/* b 20 */
		/* 82096D7Ch case   10:*/		return 0x82096D90;
		/* 82096D7Ch case   10:*/		return 0x82096D80;
	}
	return 0x82096D80;
} // Block from 82096D54h-82096D80h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82096D80h
// Function '_output_s_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096D80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096D80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096D80);
		  /* 82096D80h */ case    0:  		/* rlwinm. R11, R27, 0, 24, 24 */
		/* 82096D80h case    0:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R11,regs.R27);
		/* 82096D80h case    0:*/		return 0x82096D84;
		  /* 82096D84h */ case    1:  		/* li R8, 8 */
		/* 82096D84h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x8);
		/* 82096D84h case    1:*/		return 0x82096D88;
		  /* 82096D88h */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 82096D88h case    2:*/		if ( regs.CR[0].eq ) { return 0x82096D90;  }
		/* 82096D88h case    2:*/		return 0x82096D8C;
		  /* 82096D8Ch */ case    3:  		/* ori R27, R27, 512 */
		/* 82096D8Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x200);
		/* 82096D8Ch case    3:*/		return 0x82096D90;
	}
	return 0x82096D90;
} // Block from 82096D80h-82096D90h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82096D90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096D90);
		  /* 82096D90h */ case    0:  		/* rlwinm. R11, R27, 0, 16, 16 */
		/* 82096D90h case    0:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R11,regs.R27);
		/* 82096D90h case    0:*/		return 0x82096D94;
		  /* 82096D94h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 82096D94h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82096DA0;  }
		/* 82096D94h case    1:*/		return 0x82096D98;
		  /* 82096D98h */ case    2:  		/* rlwinm. R11, R27, 0, 19, 19 */
		/* 82096D98h case    2:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R11,regs.R27);
		/* 82096D98h case    2:*/		return 0x82096D9C;
		  /* 82096D9Ch */ case    3:  		/* bc 12, CR0_EQ, 24 */
		/* 82096D9Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x82096DB4;  }
		/* 82096D9Ch case    3:*/		return 0x82096DA0;
	}
	return 0x82096DA0;
} // Block from 82096D90h-82096DA0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82096DA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096DA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096DA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096DA0);
		  /* 82096DA0h */ case    0:  		/* addi R11, R26, 7 */
		/* 82096DA0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x7);
		/* 82096DA0h case    0:*/		return 0x82096DA4;
		  /* 82096DA4h */ case    1:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82096DA4h case    1:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82096DA4h case    1:*/		return 0x82096DA8;
		  /* 82096DA8h */ case    2:  		/* addi R26, R11, 8 */
		/* 82096DA8h case    2:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x8);
		/* 82096DA8h case    2:*/		return 0x82096DAC;
		  /* 82096DACh */ case    3:  		/* ld R11, <#[R11]> */
		/* 82096DACh case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82096DACh case    3:*/		return 0x82096DB0;
		  /* 82096DB0h */ case    4:  		/* b 84 */
		/* 82096DB0h case    4:*/		return 0x82096E04;
		/* 82096DB0h case    4:*/		return 0x82096DB4;
	}
	return 0x82096DB4;
} // Block from 82096DA0h-82096DB4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82096DB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096DB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096DB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096DB4);
		  /* 82096DB4h */ case    0:  		/* rlwinm. R11, R27, 0, 26, 26 */
		/* 82096DB4h case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R27);
		/* 82096DB4h case    0:*/		return 0x82096DB8;
		  /* 82096DB8h */ case    1:  		/* bc 12, CR0_EQ, 44 */
		/* 82096DB8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82096DE4;  }
		/* 82096DB8h case    1:*/		return 0x82096DBC;
		  /* 82096DBCh */ case    2:  		/* rlwinm. R11, R27, 0, 25, 25 */
		/* 82096DBCh case    2:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R27);
		/* 82096DBCh case    2:*/		return 0x82096DC0;
		  /* 82096DC0h */ case    3:  		/* addi R11, R26, 7 */
		/* 82096DC0h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x7);
		/* 82096DC0h case    3:*/		return 0x82096DC4;
		  /* 82096DC4h */ case    4:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82096DC4h case    4:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82096DC4h case    4:*/		return 0x82096DC8;
		  /* 82096DC8h */ case    5:  		/* addi R26, R11, 8 */
		/* 82096DC8h case    5:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x8);
		/* 82096DC8h case    5:*/		return 0x82096DCC;
		  /* 82096DCCh */ case    6:  		/* lwz R11, <#[R11 + 4]> */
		/* 82096DCCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82096DCCh case    6:*/		return 0x82096DD0;
		  /* 82096DD0h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 82096DD0h case    7:*/		if ( regs.CR[0].eq ) { return 0x82096DDC;  }
		/* 82096DD0h case    7:*/		return 0x82096DD4;
		  /* 82096DD4h */ case    8:  		/* extsh R11, R11 */
		/* 82096DD4h case    8:*/		cpu::op::extsh<0>(regs,&regs.R11,regs.R11);
		/* 82096DD4h case    8:*/		return 0x82096DD8;
		  /* 82096DD8h */ case    9:  		/* b 44 */
		/* 82096DD8h case    9:*/		return 0x82096E04;
		/* 82096DD8h case    9:*/		return 0x82096DDC;
	}
	return 0x82096DDC;
} // Block from 82096DB4h-82096DDCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 82096DDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096DDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096DDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096DDC);
		  /* 82096DDCh */ case    0:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 82096DDCh case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 82096DDCh case    0:*/		return 0x82096DE0;
		  /* 82096DE0h */ case    1:  		/* b 36 */
		/* 82096DE0h case    1:*/		return 0x82096E04;
		/* 82096DE0h case    1:*/		return 0x82096DE4;
	}
	return 0x82096DE4;
} // Block from 82096DDCh-82096DE4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82096DE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096DE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096DE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096DE4);
		  /* 82096DE4h */ case    0:  		/* rlwinm. R11, R27, 0, 25, 25 */
		/* 82096DE4h case    0:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R27);
		/* 82096DE4h case    0:*/		return 0x82096DE8;
		  /* 82096DE8h */ case    1:  		/* addi R11, R26, 7 */
		/* 82096DE8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x7);
		/* 82096DE8h case    1:*/		return 0x82096DEC;
		  /* 82096DECh */ case    2:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82096DECh case    2:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82096DECh case    2:*/		return 0x82096DF0;
		  /* 82096DF0h */ case    3:  		/* addi R26, R11, 8 */
		/* 82096DF0h case    3:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x8);
		/* 82096DF0h case    3:*/		return 0x82096DF4;
		  /* 82096DF4h */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 82096DF4h case    4:*/		if ( regs.CR[0].eq ) { return 0x82096E00;  }
		/* 82096DF4h case    4:*/		return 0x82096DF8;
		  /* 82096DF8h */ case    5:  		/* lwa R11, <#[R11 + 4]> */
		/* 82096DF8h case    5:*/		cpu::mem::load32a( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82096DF8h case    5:*/		return 0x82096DFC;
		  /* 82096DFCh */ case    6:  		/* b 8 */
		/* 82096DFCh case    6:*/		return 0x82096E04;
		/* 82096DFCh case    6:*/		return 0x82096E00;
	}
	return 0x82096E00;
} // Block from 82096DE4h-82096E00h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82096E00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096E00);
		  /* 82096E00h */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 82096E00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82096E00h case    0:*/		return 0x82096E04;
	}
	return 0x82096E04;
} // Block from 82096E00h-82096E04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82096E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096E04);
		  /* 82096E04h */ case    0:  		/* rlwinm. R10, R27, 0, 25, 25 */
		/* 82096E04h case    0:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R27);
		/* 82096E04h case    0:*/		return 0x82096E08;
		  /* 82096E08h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 82096E08h case    1:*/		if ( regs.CR[0].eq ) { return 0x82096E1C;  }
		/* 82096E08h case    1:*/		return 0x82096E0C;
		  /* 82096E0Ch */ case    2:  		/* cmpdi CR6, R11, 0 */
		/* 82096E0Ch case    2:*/		cpu::op::cmpdi<6>(regs,regs.R11,0x00000000);
		/* 82096E0Ch case    2:*/		return 0x82096E10;
		  /* 82096E10h */ case    3:  		/* bc 4, CR6_LT, 12 */
		/* 82096E10h case    3:*/		if ( !regs.CR[6].lt ) { return 0x82096E1C;  }
		/* 82096E10h case    3:*/		return 0x82096E14;
		  /* 82096E14h */ case    4:  		/* neg R11, R11 */
		/* 82096E14h case    4:*/		cpu::op::neg<0>(regs,&regs.R11,regs.R11);
		/* 82096E14h case    4:*/		return 0x82096E18;
		  /* 82096E18h */ case    5:  		/* ori R27, R27, 256 */
		/* 82096E18h case    5:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x100);
		/* 82096E18h case    5:*/		return 0x82096E1C;
	}
	return 0x82096E1C;
} // Block from 82096E04h-82096E1Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82096E1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096E1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096E1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096E1C);
		  /* 82096E1Ch */ case    0:  		/* rlwinm. R10, R27, 0, 16, 16 */
		/* 82096E1Ch case    0:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R10,regs.R27);
		/* 82096E1Ch case    0:*/		return 0x82096E20;
		  /* 82096E20h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 82096E20h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82096E30;  }
		/* 82096E20h case    1:*/		return 0x82096E24;
		  /* 82096E24h */ case    2:  		/* rlwinm. R10, R27, 0, 19, 19 */
		/* 82096E24h case    2:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R10,regs.R27);
		/* 82096E24h case    2:*/		return 0x82096E28;
		  /* 82096E28h */ case    3:  		/* bc 4, CR0_EQ, 8 */
		/* 82096E28h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82096E30;  }
		/* 82096E28h case    3:*/		return 0x82096E2C;
		  /* 82096E2Ch */ case    4:  		/* rldicl R11, R11, 0, 32 */
		/* 82096E2Ch case    4:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R11);
		/* 82096E2Ch case    4:*/		return 0x82096E30;
	}
	return 0x82096E30;
} // Block from 82096E1Ch-82096E30h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82096E30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096E30);
		  /* 82096E30h */ case    0:  		/* cmpwi CR6, R25, 0 */
		/* 82096E30h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82096E30h case    0:*/		return 0x82096E34;
		  /* 82096E34h */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 82096E34h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82096E40;  }
		/* 82096E34h case    1:*/		return 0x82096E38;
		  /* 82096E38h */ case    2:  		/* li R25, 1 */
		/* 82096E38h case    2:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 82096E38h case    2:*/		return 0x82096E3C;
		  /* 82096E3Ch */ case    3:  		/* b 20 */
		/* 82096E3Ch case    3:*/		return 0x82096E50;
		/* 82096E3Ch case    3:*/		return 0x82096E40;
	}
	return 0x82096E40;
} // Block from 82096E30h-82096E40h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82096E40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096E40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096E40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096E40);
		  /* 82096E40h */ case    0:  		/* rlwinm R27, R27, 0, 29, 27 */
		/* 82096E40h case    0:*/		cpu::op::rlwinm<0,0,29,27>(regs,&regs.R27,regs.R27);
		/* 82096E40h case    0:*/		return 0x82096E44;
		  /* 82096E44h */ case    1:  		/* cmpwi CR6, R25, 512 */
		/* 82096E44h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000200);
		/* 82096E44h case    1:*/		return 0x82096E48;
		  /* 82096E48h */ case    2:  		/* bc 4, CR6_GT, 8 */
		/* 82096E48h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82096E50;  }
		/* 82096E48h case    2:*/		return 0x82096E4C;
		  /* 82096E4Ch */ case    3:  		/* li R25, 512 */
		/* 82096E4Ch case    3:*/		cpu::op::li<0>(regs,&regs.R25,0x200);
		/* 82096E4Ch case    3:*/		return 0x82096E50;
	}
	return 0x82096E50;
} // Block from 82096E40h-82096E50h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82096E50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096E50);
		  /* 82096E50h */ case    0:  		/* cmpldi CR6, R11, 0 */
		/* 82096E50h case    0:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82096E50h case    0:*/		return 0x82096E54;
		  /* 82096E54h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82096E54h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82096E60;  }
		/* 82096E54h case    1:*/		return 0x82096E58;
		  /* 82096E58h */ case    2:  		/* li R10, 0 */
		/* 82096E58h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82096E58h case    2:*/		return 0x82096E5C;
		  /* 82096E5Ch */ case    3:  		/* stw R10, <#[R1 + 92]> */
		/* 82096E5Ch case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 82096E5Ch case    3:*/		return 0x82096E60;
	}
	return 0x82096E60;
} // Block from 82096E50h-82096E60h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82096E60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096E60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096E60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096E60);
		  /* 82096E60h */ case    0:  		/* addi R9, R1, 655 */
		/* 82096E60h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x28F);
		/* 82096E60h case    0:*/		return 0x82096E64;
		  /* 82096E64h */ case    1:  		/* cmpwi CR6, R25, 0 */
		/* 82096E64h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82096E64h case    1:*/		return 0x82096E68;
		  /* 82096E68h */ case    2:  		/* addi R25, R25, -1 */
		/* 82096E68h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0xFFFFFFFF);
		/* 82096E68h case    2:*/		return 0x82096E6C;
		  /* 82096E6Ch */ case    3:  		/* bc 12, CR6_GT, 12 */
		/* 82096E6Ch case    3:*/		if ( regs.CR[6].gt ) { return 0x82096E78;  }
		/* 82096E6Ch case    3:*/		return 0x82096E70;
		  /* 82096E70h */ case    4:  		/* cmpldi CR6, R11, 0 */
		/* 82096E70h case    4:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82096E70h case    4:*/		return 0x82096E74;
		  /* 82096E74h */ case    5:  		/* bc 12, CR6_EQ, 72 */
		/* 82096E74h case    5:*/		if ( regs.CR[6].eq ) { return 0x82096EBC;  }
		/* 82096E74h case    5:*/		return 0x82096E78;
	}
	return 0x82096E78;
} // Block from 82096E60h-82096E78h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82096E78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096E78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096E78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096E78);
		  /* 82096E78h */ case    0:  		/* extsw R10, R8 */
		/* 82096E78h case    0:*/		cpu::op::extsw<0>(regs,&regs.R10,regs.R8);
		/* 82096E78h case    0:*/		return 0x82096E7C;
		  /* 82096E7Ch */ case    1:  		/* divdu R7, R11, R10 */
		/* 82096E7Ch case    1:*/		cpu::op::divdu<0>(regs,&regs.R7,regs.R11,regs.R10);
		/* 82096E7Ch case    1:*/		return 0x82096E80;
		  /* 82096E80h */ case    2:  		/* tdi 6, R10, 0 */
		/* 82096E80h case    2:*/		cpu::op::td<6>(regs, 0x82096E80, regs.R10, 0x00000000);
		/* 82096E80h case    2:*/		return 0x82096E84;
		  /* 82096E84h */ case    3:  		/* mulld R7, R7, R10 */
		/* 82096E84h case    3:*/		cpu::op::mulld<0>(regs,&regs.R7,regs.R7,regs.R10);
		/* 82096E84h case    3:*/		return 0x82096E88;
		  /* 82096E88h */ case    4:  		/* subf R7, R7, R11 */
		/* 82096E88h case    4:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R7,regs.R11);
		/* 82096E88h case    4:*/		return 0x82096E8C;
		  /* 82096E8Ch */ case    5:  		/* divdu R11, R11, R10 */
		/* 82096E8Ch case    5:*/		cpu::op::divdu<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82096E8Ch case    5:*/		return 0x82096E90;
		  /* 82096E90h */ case    6:  		/* tdi 6, R10, 0 */
		/* 82096E90h case    6:*/		cpu::op::td<6>(regs, 0x82096E90, regs.R10, 0x00000000);
		/* 82096E90h case    6:*/		return 0x82096E94;
		  /* 82096E94h */ case    7:  		/* rlwinm R10, R7, 0, 0, 31 */
		/* 82096E94h case    7:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R7);
		/* 82096E94h case    7:*/		return 0x82096E98;
		  /* 82096E98h */ case    8:  		/* addi R10, R10, 48 */
		/* 82096E98h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x30);
		/* 82096E98h case    8:*/		return 0x82096E9C;
		  /* 82096E9Ch */ case    9:  		/* cmpwi CR6, R10, 57 */
		/* 82096E9Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000039);
		/* 82096E9Ch case    9:*/		return 0x82096EA0;
		  /* 82096EA0h */ case   10:  		/* bc 4, CR6_GT, 12 */
		/* 82096EA0h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82096EAC;  }
		/* 82096EA0h case   10:*/		return 0x82096EA4;
		  /* 82096EA4h */ case   11:  		/* lwz R7, <#[R1 + 104]> */
		/* 82096EA4h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000068) );
		/* 82096EA4h case   11:*/		return 0x82096EA8;
		  /* 82096EA8h */ case   12:  		/* add R10, R10, R7 */
		/* 82096EA8h case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 82096EA8h case   12:*/		return 0x82096EAC;
	}
	return 0x82096EAC;
} // Block from 82096E78h-82096EACh (13 instructions)

//////////////////////////////////////////////////////
// Block at 82096EACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096EAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096EAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096EAC);
		  /* 82096EACh */ case    0:  		/* extsb R10, R10 */
		/* 82096EACh case    0:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 82096EACh case    0:*/		return 0x82096EB0;
		  /* 82096EB0h */ case    1:  		/* stb R10, <#[R9]> */
		/* 82096EB0h case    1:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 82096EB0h case    1:*/		return 0x82096EB4;
		  /* 82096EB4h */ case    2:  		/* addi R9, R9, -1 */
		/* 82096EB4h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82096EB4h case    2:*/		return 0x82096EB8;
		  /* 82096EB8h */ case    3:  		/* b -84 */
		/* 82096EB8h case    3:*/		return 0x82096E64;
		/* 82096EB8h case    3:*/		return 0x82096EBC;
	}
	return 0x82096EBC;
} // Block from 82096EACh-82096EBCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 82096EBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096EBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096EBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096EBC);
		  /* 82096EBCh */ case    0:  		/* addi R11, R1, 655 */
		/* 82096EBCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x28F);
		/* 82096EBCh case    0:*/		return 0x82096EC0;
		  /* 82096EC0h */ case    1:  		/* rlwinm. R10, R27, 0, 22, 22 */
		/* 82096EC0h case    1:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R10,regs.R27);
		/* 82096EC0h case    1:*/		return 0x82096EC4;
		  /* 82096EC4h */ case    2:  		/* subf R6, R9, R11 */
		/* 82096EC4h case    2:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R9,regs.R11);
		/* 82096EC4h case    2:*/		return 0x82096EC8;
		  /* 82096EC8h */ case    3:  		/* addi R28, R9, 1 */
		/* 82096EC8h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R9,0x1);
		/* 82096EC8h case    3:*/		return 0x82096ECC;
		  /* 82096ECCh */ case    4:  		/* stw R6, <#[R1 + 84]> */
		/* 82096ECCh case    4:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 82096ECCh case    4:*/		return 0x82096ED0;
		  /* 82096ED0h */ case    5:  		/* bc 12, CR0_EQ, 40 */
		/* 82096ED0h case    5:*/		if ( regs.CR[0].eq ) { return 0x82096EF8;  }
		/* 82096ED0h case    5:*/		return 0x82096ED4;
		  /* 82096ED4h */ case    6:  		/* cmpwi CR6, R6, 0 */
		/* 82096ED4h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 82096ED4h case    6:*/		return 0x82096ED8;
		  /* 82096ED8h */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 82096ED8h case    7:*/		if ( regs.CR[6].eq ) { return 0x82096EE8;  }
		/* 82096ED8h case    7:*/		return 0x82096EDC;
		  /* 82096EDCh */ case    8:  		/* lbz R11, <#[R28]> */
		/* 82096EDCh case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82096EDCh case    8:*/		return 0x82096EE0;
		  /* 82096EE0h */ case    9:  		/* cmplwi CR6, R11, 48 */
		/* 82096EE0h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 82096EE0h case    9:*/		return 0x82096EE4;
		  /* 82096EE4h */ case   10:  		/* bc 12, CR6_EQ, 20 */
		/* 82096EE4h case   10:*/		if ( regs.CR[6].eq ) { return 0x82096EF8;  }
		/* 82096EE4h case   10:*/		return 0x82096EE8;
	}
	return 0x82096EE8;
} // Block from 82096EBCh-82096EE8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82096EE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096EE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096EE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096EE8);
		  /* 82096EE8h */ case    0:  		/* li R11, 48 */
		/* 82096EE8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x30);
		/* 82096EE8h case    0:*/		return 0x82096EEC;
		  /* 82096EECh */ case    1:  		/* addi R6, R6, 1 */
		/* 82096EECh case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82096EECh case    1:*/		return 0x82096EF0;
		  /* 82096EF0h */ case    2:  		/* stbu R11, <#[R28 - 1]> */
		/* 82096EF0h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R28 + 0xFFFFFFFF) );
		regs.R28 = (uint32)(regs.R28 + 0xFFFFFFFF);
		/* 82096EF0h case    2:*/		return 0x82096EF4;
	}
	return 0x82096EF4;
} // Block from 82096EE8h-82096EF4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82096EF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096EF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096EF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096EF4);
		  /* 82096EF4h */ case    0:  		/* stw R6, <#[R1 + 84]> */
		/* 82096EF4h case    0:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 82096EF4h case    0:*/		return 0x82096EF8;
	}
	return 0x82096EF8;
} // Block from 82096EF4h-82096EF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82096EF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096EF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096EF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096EF8);
		  /* 82096EF8h */ case    0:  		/* lwz R11, <#[R1 + 100]> */
		/* 82096EF8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82096EF8h case    0:*/		return 0x82096EFC;
		  /* 82096EFCh */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82096EFCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82096EFCh case    1:*/		return 0x82096F00;
		  /* 82096F00h */ case    2:  		/* bc 4, CR6_EQ, 436 */
		/* 82096F00h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820970B4;  }
		/* 82096F00h case    2:*/		return 0x82096F04;
		  /* 82096F04h */ case    3:  		/* rlwinm. R11, R27, 0, 25, 25 */
		/* 82096F04h case    3:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R27);
		/* 82096F04h case    3:*/		return 0x82096F08;
		  /* 82096F08h */ case    4:  		/* bc 12, CR0_EQ, 64 */
		/* 82096F08h case    4:*/		if ( regs.CR[0].eq ) { return 0x82096F48;  }
		/* 82096F08h case    4:*/		return 0x82096F0C;
		  /* 82096F0Ch */ case    5:  		/* rlwinm. R11, R27, 0, 23, 23 */
		/* 82096F0Ch case    5:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R27);
		/* 82096F0Ch case    5:*/		return 0x82096F10;
		  /* 82096F10h */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 82096F10h case    6:*/		if ( regs.CR[0].eq ) { return 0x82096F1C;  }
		/* 82096F10h case    6:*/		return 0x82096F14;
		  /* 82096F14h */ case    7:  		/* li R11, 45 */
		/* 82096F14h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x2D);
		/* 82096F14h case    7:*/		return 0x82096F18;
		  /* 82096F18h */ case    8:  		/* b 16 */
		/* 82096F18h case    8:*/		return 0x82096F28;
		/* 82096F18h case    8:*/		return 0x82096F1C;
	}
	return 0x82096F1C;
} // Block from 82096EF8h-82096F1Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82096F1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096F1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096F1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096F1C);
		  /* 82096F1Ch */ case    0:  		/* rlwinm. R11, R27, 0, 31, 31 */
		/* 82096F1Ch case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R27);
		/* 82096F1Ch case    0:*/		return 0x82096F20;
		  /* 82096F20h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 82096F20h case    1:*/		if ( regs.CR[0].eq ) { return 0x82096F38;  }
		/* 82096F20h case    1:*/		return 0x82096F24;
		  /* 82096F24h */ case    2:  		/* li R11, 43 */
		/* 82096F24h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x2B);
		/* 82096F24h case    2:*/		return 0x82096F28;
	}
	return 0x82096F28;
} // Block from 82096F1Ch-82096F28h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82096F28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096F28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096F28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096F28);
		  /* 82096F28h */ case    0:  		/* li R30, 1 */
		/* 82096F28h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82096F28h case    0:*/		return 0x82096F2C;
		  /* 82096F2Ch */ case    1:  		/* stb R11, <#[R1 + 88]> */
		/* 82096F2Ch case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82096F2Ch case    1:*/		return 0x82096F30;
		  /* 82096F30h */ case    2:  		/* stw R30, <#[R1 + 92]> */
		/* 82096F30h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000005C) );
		/* 82096F30h case    2:*/		return 0x82096F34;
		  /* 82096F34h */ case    3:  		/* b 24 */
		/* 82096F34h case    3:*/		return 0x82096F4C;
		/* 82096F34h case    3:*/		return 0x82096F38;
	}
	return 0x82096F38;
} // Block from 82096F28h-82096F38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82096F38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096F38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096F38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096F38);
		  /* 82096F38h */ case    0:  		/* rlwinm. R11, R27, 0, 30, 30 */
		/* 82096F38h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R27);
		/* 82096F38h case    0:*/		return 0x82096F3C;
		  /* 82096F3Ch */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82096F3Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82096F48;  }
		/* 82096F3Ch case    1:*/		return 0x82096F40;
		  /* 82096F40h */ case    2:  		/* li R11, 32 */
		/* 82096F40h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x20);
		/* 82096F40h case    2:*/		return 0x82096F44;
		  /* 82096F44h */ case    3:  		/* b -28 */
		/* 82096F44h case    3:*/		return 0x82096F28;
		/* 82096F44h case    3:*/		return 0x82096F48;
	}
	return 0x82096F48;
} // Block from 82096F38h-82096F48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82096F48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096F48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096F48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096F48);
		  /* 82096F48h */ case    0:  		/* lwz R30, <#[R1 + 92]> */
		/* 82096F48h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x0000005C) );
		/* 82096F48h case    0:*/		return 0x82096F4C;
	}
	return 0x82096F4C;
} // Block from 82096F48h-82096F4Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82096F4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096F4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096F4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096F4C);
		  /* 82096F4Ch */ case    0:  		/* lwz R11, <#[R1 + 96]> */
		/* 82096F4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82096F4Ch case    0:*/		return 0x82096F50;
		  /* 82096F50h */ case    1:  		/* rlwinm. R10, R27, 0, 28, 29 */
		/* 82096F50h case    1:*/		cpu::op::rlwinm<1,0,28,29>(regs,&regs.R10,regs.R27);
		/* 82096F50h case    1:*/		return 0x82096F54;
		  /* 82096F54h */ case    2:  		/* subf R11, R6, R11 */
		/* 82096F54h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R11);
		/* 82096F54h case    2:*/		return 0x82096F58;
		  /* 82096F58h */ case    3:  		/* subf R29, R30, R11 */
		/* 82096F58h case    3:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R30,regs.R11);
		/* 82096F58h case    3:*/		return 0x82096F5C;
		  /* 82096F5Ch */ case    4:  		/* bc 4, CR0_EQ, 56 */
		/* 82096F5Ch case    4:*/		if ( !regs.CR[0].eq ) { return 0x82096F94;  }
		/* 82096F5Ch case    4:*/		return 0x82096F60;
		  /* 82096F60h */ case    5:  		/* mr R31, R29 */
		/* 82096F60h case    5:*/		regs.R31 = regs.R29;
		/* 82096F60h case    5:*/		return 0x82096F64;
		  /* 82096F64h */ case    6:  		/* cmpwi CR6, R29, 0 */
		/* 82096F64h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82096F64h case    6:*/		return 0x82096F68;
		  /* 82096F68h */ case    7:  		/* bc 4, CR6_GT, 44 */
		/* 82096F68h case    7:*/		if ( !regs.CR[6].gt ) { return 0x82096F94;  }
		/* 82096F68h case    7:*/		return 0x82096F6C;
		  /* 82096F6Ch */ case    8:  		/* addi R5, R1, 80 */
		/* 82096F6Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82096F6Ch case    8:*/		return 0x82096F70;
		  /* 82096F70h */ case    9:  		/* mr R4, R18 */
		/* 82096F70h case    9:*/		regs.R4 = regs.R18;
		/* 82096F70h case    9:*/		return 0x82096F74;
		  /* 82096F74h */ case   10:  		/* li R3, 32 */
		/* 82096F74h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x20);
		/* 82096F74h case   10:*/		return 0x82096F78;
		  /* 82096F78h */ case   11:  		/* addi R31, R31, -1 */
		/* 82096F78h case   11:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82096F78h case   11:*/		return 0x82096F7C;
		  /* 82096F7Ch */ case   12:  		/* bl 428 */
		/* 82096F7Ch case   12:*/		regs.LR = 0x82096F80; return 0x82097128;
		/* 82096F7Ch case   12:*/		return 0x82096F80;
		  /* 82096F80h */ case   13:  		/* lwz R11, <#[R1 + 80]> */
		/* 82096F80h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82096F80h case   13:*/		return 0x82096F84;
		  /* 82096F84h */ case   14:  		/* cmpwi CR6, R11, -1 */
		/* 82096F84h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82096F84h case   14:*/		return 0x82096F88;
		  /* 82096F88h */ case   15:  		/* bc 12, CR6_EQ, 12 */
		/* 82096F88h case   15:*/		if ( regs.CR[6].eq ) { return 0x82096F94;  }
		/* 82096F88h case   15:*/		return 0x82096F8C;
		  /* 82096F8Ch */ case   16:  		/* cmpwi CR6, R31, 0 */
		/* 82096F8Ch case   16:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82096F8Ch case   16:*/		return 0x82096F90;
		  /* 82096F90h */ case   17:  		/* bc 12, CR6_GT, -36 */
		/* 82096F90h case   17:*/		if ( regs.CR[6].gt ) { return 0x82096F6C;  }
		/* 82096F90h case   17:*/		return 0x82096F94;
	}
	return 0x82096F94;
} // Block from 82096F4Ch-82096F94h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82096F94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096F94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096F94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096F94);
		  /* 82096F94h */ case    0:  		/* addi R6, R1, 80 */
		/* 82096F94h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 82096F94h case    0:*/		return 0x82096F98;
		  /* 82096F98h */ case    1:  		/* mr R5, R18 */
		/* 82096F98h case    1:*/		regs.R5 = regs.R18;
		/* 82096F98h case    1:*/		return 0x82096F9C;
		  /* 82096F9Ch */ case    2:  		/* mr R4, R30 */
		/* 82096F9Ch case    2:*/		regs.R4 = regs.R30;
		/* 82096F9Ch case    2:*/		return 0x82096FA0;
		  /* 82096FA0h */ case    3:  		/* addi R3, R1, 88 */
		/* 82096FA0h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 82096FA0h case    3:*/		return 0x82096FA4;
		  /* 82096FA4h */ case    4:  		/* bl 540 */
		/* 82096FA4h case    4:*/		regs.LR = 0x82096FA8; return 0x820971C0;
		/* 82096FA4h case    4:*/		return 0x82096FA8;
		  /* 82096FA8h */ case    5:  		/* rlwinm. R11, R27, 0, 28, 28 */
		/* 82096FA8h case    5:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R27);
		/* 82096FA8h case    5:*/		return 0x82096FAC;
		  /* 82096FACh */ case    6:  		/* bc 12, CR0_EQ, 64 */
		/* 82096FACh case    6:*/		if ( regs.CR[0].eq ) { return 0x82096FEC;  }
		/* 82096FACh case    6:*/		return 0x82096FB0;
		  /* 82096FB0h */ case    7:  		/* rlwinm. R11, R27, 0, 29, 29 */
		/* 82096FB0h case    7:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R27);
		/* 82096FB0h case    7:*/		return 0x82096FB4;
		  /* 82096FB4h */ case    8:  		/* bc 4, CR0_EQ, 56 */
		/* 82096FB4h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82096FEC;  }
		/* 82096FB4h case    8:*/		return 0x82096FB8;
		  /* 82096FB8h */ case    9:  		/* mr R31, R29 */
		/* 82096FB8h case    9:*/		regs.R31 = regs.R29;
		/* 82096FB8h case    9:*/		return 0x82096FBC;
		  /* 82096FBCh */ case   10:  		/* cmpwi CR6, R29, 0 */
		/* 82096FBCh case   10:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82096FBCh case   10:*/		return 0x82096FC0;
		  /* 82096FC0h */ case   11:  		/* bc 4, CR6_GT, 44 */
		/* 82096FC0h case   11:*/		if ( !regs.CR[6].gt ) { return 0x82096FEC;  }
		/* 82096FC0h case   11:*/		return 0x82096FC4;
		  /* 82096FC4h */ case   12:  		/* addi R5, R1, 80 */
		/* 82096FC4h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82096FC4h case   12:*/		return 0x82096FC8;
		  /* 82096FC8h */ case   13:  		/* mr R4, R18 */
		/* 82096FC8h case   13:*/		regs.R4 = regs.R18;
		/* 82096FC8h case   13:*/		return 0x82096FCC;
		  /* 82096FCCh */ case   14:  		/* li R3, 48 */
		/* 82096FCCh case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x30);
		/* 82096FCCh case   14:*/		return 0x82096FD0;
		  /* 82096FD0h */ case   15:  		/* addi R31, R31, -1 */
		/* 82096FD0h case   15:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82096FD0h case   15:*/		return 0x82096FD4;
		  /* 82096FD4h */ case   16:  		/* bl 340 */
		/* 82096FD4h case   16:*/		regs.LR = 0x82096FD8; return 0x82097128;
		/* 82096FD4h case   16:*/		return 0x82096FD8;
		  /* 82096FD8h */ case   17:  		/* lwz R11, <#[R1 + 80]> */
		/* 82096FD8h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82096FD8h case   17:*/		return 0x82096FDC;
		  /* 82096FDCh */ case   18:  		/* cmpwi CR6, R11, -1 */
		/* 82096FDCh case   18:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82096FDCh case   18:*/		return 0x82096FE0;
		  /* 82096FE0h */ case   19:  		/* bc 12, CR6_EQ, 12 */
		/* 82096FE0h case   19:*/		if ( regs.CR[6].eq ) { return 0x82096FEC;  }
		/* 82096FE0h case   19:*/		return 0x82096FE4;
		  /* 82096FE4h */ case   20:  		/* cmpwi CR6, R31, 0 */
		/* 82096FE4h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82096FE4h case   20:*/		return 0x82096FE8;
		  /* 82096FE8h */ case   21:  		/* bc 12, CR6_GT, -36 */
		/* 82096FE8h case   21:*/		if ( regs.CR[6].gt ) { return 0x82096FC4;  }
		/* 82096FE8h case   21:*/		return 0x82096FEC;
	}
	return 0x82096FEC;
} // Block from 82096F94h-82096FECh (22 instructions)

//////////////////////////////////////////////////////
// Block at 82096FECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82096FEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82096FEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82096FEC);
		  /* 82096FECh */ case    0:  		/* lwz R4, <#[R1 + 84]> */
		/* 82096FECh case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 82096FECh case    0:*/		return 0x82096FF0;
		  /* 82096FF0h */ case    1:  		/* cmpwi CR6, R16, 0 */
		/* 82096FF0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R16,0x00000000);
		/* 82096FF0h case    1:*/		return 0x82096FF4;
		  /* 82096FF4h */ case    2:  		/* bc 12, CR6_EQ, 104 */
		/* 82096FF4h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209705C;  }
		/* 82096FF4h case    2:*/		return 0x82096FF8;
		  /* 82096FF8h */ case    3:  		/* cmpwi CR6, R4, 0 */
		/* 82096FF8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 82096FF8h case    3:*/		return 0x82096FFC;
		  /* 82096FFCh */ case    4:  		/* bc 4, CR6_GT, 96 */
		/* 82096FFCh case    4:*/		if ( !regs.CR[6].gt ) { return 0x8209705C;  }
		/* 82096FFCh case    4:*/		return 0x82097000;
		  /* 82097000h */ case    5:  		/* addi R30, R28, -2 */
		/* 82097000h case    5:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R28,0xFFFFFFFE);
		/* 82097000h case    5:*/		return 0x82097004;
		  /* 82097004h */ case    6:  		/* mr R31, R4 */
		/* 82097004h case    6:*/		regs.R31 = regs.R4;
		/* 82097004h case    6:*/		return 0x82097008;
		  /* 82097008h */ case    7:  		/* li R5, 6 */
		/* 82097008h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x6);
		/* 82097008h case    7:*/		return 0x8209700C;
		  /* 8209700Ch */ case    8:  		/* lhzu R6, <#[R30 + 2]> */
		/* 8209700Ch case    8:*/		cpu::mem::load16z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000002) );
		regs.R30 = (uint32)(regs.R30 + 0x00000002);
		/* 8209700Ch case    8:*/		return 0x82097010;
		  /* 82097010h */ case    9:  		/* addi R4, R1, 116 */
		/* 82097010h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x74);
		/* 82097010h case    9:*/		return 0x82097014;
		  /* 82097014h */ case   10:  		/* addi R3, R1, 112 */
		/* 82097014h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 82097014h case   10:*/		return 0x82097018;
		  /* 82097018h */ case   11:  		/* addi R31, R31, -1 */
		/* 82097018h case   11:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82097018h case   11:*/		return 0x8209701C;
		  /* 8209701Ch */ case   12:  		/* bl 16564 */
		/* 8209701Ch case   12:*/		regs.LR = 0x82097020; return 0x8209B0D0;
		/* 8209701Ch case   12:*/		return 0x82097020;
		  /* 82097020h */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 82097020h case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82097020h case   13:*/		return 0x82097024;
		  /* 82097024h */ case   14:  		/* bc 4, CR0_EQ, 44 */
		/* 82097024h case   14:*/		if ( !regs.CR[0].eq ) { return 0x82097050;  }
		/* 82097024h case   14:*/		return 0x82097028;
		  /* 82097028h */ case   15:  		/* lwz R4, <#[R1 + 112]> */
		/* 82097028h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000070) );
		/* 82097028h case   15:*/		return 0x8209702C;
		  /* 8209702Ch */ case   16:  		/* cmpwi CR6, R4, 0 */
		/* 8209702Ch case   16:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 8209702Ch case   16:*/		return 0x82097030;
		  /* 82097030h */ case   17:  		/* bc 12, CR6_EQ, 32 */
		/* 82097030h case   17:*/		if ( regs.CR[6].eq ) { return 0x82097050;  }
		/* 82097030h case   17:*/		return 0x82097034;
		  /* 82097034h */ case   18:  		/* addi R6, R1, 80 */
		/* 82097034h case   18:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 82097034h case   18:*/		return 0x82097038;
		  /* 82097038h */ case   19:  		/* mr R5, R18 */
		/* 82097038h case   19:*/		regs.R5 = regs.R18;
		/* 82097038h case   19:*/		return 0x8209703C;
		  /* 8209703Ch */ case   20:  		/* addi R3, R1, 116 */
		/* 8209703Ch case   20:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x74);
		/* 8209703Ch case   20:*/		return 0x82097040;
		  /* 82097040h */ case   21:  		/* bl 384 */
		/* 82097040h case   21:*/		regs.LR = 0x82097044; return 0x820971C0;
		/* 82097040h case   21:*/		return 0x82097044;
		  /* 82097044h */ case   22:  		/* cmpwi CR6, R31, 0 */
		/* 82097044h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82097044h case   22:*/		return 0x82097048;
		  /* 82097048h */ case   23:  		/* bc 4, CR6_EQ, -64 */
		/* 82097048h case   23:*/		if ( !regs.CR[6].eq ) { return 0x82097008;  }
		/* 82097048h case   23:*/		return 0x8209704C;
		  /* 8209704Ch */ case   24:  		/* b 32 */
		/* 8209704Ch case   24:*/		return 0x8209706C;
		/* 8209704Ch case   24:*/		return 0x82097050;
	}
	return 0x82097050;
} // Block from 82096FECh-82097050h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82097050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097050);
		  /* 82097050h */ case    0:  		/* li R24, -1 */
		/* 82097050h case    0:*/		cpu::op::li<0>(regs,&regs.R24,0xFFFFFFFF);
		/* 82097050h case    0:*/		return 0x82097054;
		  /* 82097054h */ case    1:  		/* stw R24, <#[R1 + 80]> */
		/* 82097054h case    1:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000050) );
		/* 82097054h case    1:*/		return 0x82097058;
		  /* 82097058h */ case    2:  		/* b 24 */
		/* 82097058h case    2:*/		return 0x82097070;
		/* 82097058h case    2:*/		return 0x8209705C;
	}
	return 0x8209705C;
} // Block from 82097050h-8209705Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209705Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209705C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209705C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209705C);
		  /* 8209705Ch */ case    0:  		/* addi R6, R1, 80 */
		/* 8209705Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 8209705Ch case    0:*/		return 0x82097060;
		  /* 82097060h */ case    1:  		/* mr R5, R18 */
		/* 82097060h case    1:*/		regs.R5 = regs.R18;
		/* 82097060h case    1:*/		return 0x82097064;
		  /* 82097064h */ case    2:  		/* mr R3, R28 */
		/* 82097064h case    2:*/		regs.R3 = regs.R28;
		/* 82097064h case    2:*/		return 0x82097068;
		  /* 82097068h */ case    3:  		/* bl 344 */
		/* 82097068h case    3:*/		regs.LR = 0x8209706C; return 0x820971C0;
		/* 82097068h case    3:*/		return 0x8209706C;
	}
	return 0x8209706C;
} // Block from 8209705Ch-8209706Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209706Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209706C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209706C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209706C);
		  /* 8209706Ch */ case    0:  		/* lwz R24, <#[R1 + 80]> */
		/* 8209706Ch case    0:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000050) );
		/* 8209706Ch case    0:*/		return 0x82097070;
	}
	return 0x82097070;
} // Block from 8209706Ch-82097070h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82097070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097070);
		  /* 82097070h */ case    0:  		/* cmpwi CR6, R24, 0 */
		/* 82097070h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 82097070h case    0:*/		return 0x82097074;
		  /* 82097074h */ case    1:  		/* bc 12, CR6_LT, 64 */
		/* 82097074h case    1:*/		if ( regs.CR[6].lt ) { return 0x820970B4;  }
		/* 82097074h case    1:*/		return 0x82097078;
		  /* 82097078h */ case    2:  		/* rlwinm. R11, R27, 0, 29, 29 */
		/* 82097078h case    2:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R27);
		/* 82097078h case    2:*/		return 0x8209707C;
		  /* 8209707Ch */ case    3:  		/* bc 12, CR0_EQ, 56 */
		/* 8209707Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x820970B4;  }
		/* 8209707Ch case    3:*/		return 0x82097080;
		  /* 82097080h */ case    4:  		/* mr R31, R29 */
		/* 82097080h case    4:*/		regs.R31 = regs.R29;
		/* 82097080h case    4:*/		return 0x82097084;
		  /* 82097084h */ case    5:  		/* cmpwi CR6, R29, 0 */
		/* 82097084h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82097084h case    5:*/		return 0x82097088;
		  /* 82097088h */ case    6:  		/* bc 4, CR6_GT, 44 */
		/* 82097088h case    6:*/		if ( !regs.CR[6].gt ) { return 0x820970B4;  }
		/* 82097088h case    6:*/		return 0x8209708C;
		  /* 8209708Ch */ case    7:  		/* addi R5, R1, 80 */
		/* 8209708Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8209708Ch case    7:*/		return 0x82097090;
		  /* 82097090h */ case    8:  		/* mr R4, R18 */
		/* 82097090h case    8:*/		regs.R4 = regs.R18;
		/* 82097090h case    8:*/		return 0x82097094;
		  /* 82097094h */ case    9:  		/* li R3, 32 */
		/* 82097094h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x20);
		/* 82097094h case    9:*/		return 0x82097098;
		  /* 82097098h */ case   10:  		/* addi R31, R31, -1 */
		/* 82097098h case   10:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82097098h case   10:*/		return 0x8209709C;
		  /* 8209709Ch */ case   11:  		/* bl 140 */
		/* 8209709Ch case   11:*/		regs.LR = 0x820970A0; return 0x82097128;
		/* 8209709Ch case   11:*/		return 0x820970A0;
		  /* 820970A0h */ case   12:  		/* lwz R24, <#[R1 + 80]> */
		/* 820970A0h case   12:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000050) );
		/* 820970A0h case   12:*/		return 0x820970A4;
		  /* 820970A4h */ case   13:  		/* cmpwi CR6, R24, -1 */
		/* 820970A4h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R24,0xFFFFFFFF);
		/* 820970A4h case   13:*/		return 0x820970A8;
		  /* 820970A8h */ case   14:  		/* bc 12, CR6_EQ, 12 */
		/* 820970A8h case   14:*/		if ( regs.CR[6].eq ) { return 0x820970B4;  }
		/* 820970A8h case   14:*/		return 0x820970AC;
		  /* 820970ACh */ case   15:  		/* cmpwi CR6, R31, 0 */
		/* 820970ACh case   15:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 820970ACh case   15:*/		return 0x820970B0;
		  /* 820970B0h */ case   16:  		/* bc 12, CR6_GT, -36 */
		/* 820970B0h case   16:*/		if ( regs.CR[6].gt ) { return 0x8209708C;  }
		/* 820970B0h case   16:*/		return 0x820970B4;
	}
	return 0x820970B4;
} // Block from 82097070h-820970B4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820970B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820970B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820970B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820970B4);
		  /* 820970B4h */ case    0:  		/* cmplwi CR6, R14, 0 */
		/* 820970B4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820970B4h case    0:*/		return 0x820970B8;
		  /* 820970B8h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820970B8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820970C8;  }
		/* 820970B8h case    1:*/		return 0x820970BC;
		  /* 820970BCh */ case    2:  		/* mr R3, R14 */
		/* 820970BCh case    2:*/		regs.R3 = regs.R14;
		/* 820970BCh case    2:*/		return 0x820970C0;
		  /* 820970C0h */ case    3:  		/* bl -14488 */
		/* 820970C0h case    3:*/		regs.LR = 0x820970C4; return 0x82093828;
		/* 820970C0h case    3:*/		return 0x820970C4;
		  /* 820970C4h */ case    4:  		/* li R14, 0 */
		/* 820970C4h case    4:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 820970C4h case    4:*/		return 0x820970C8;
	}
	return 0x820970C8;
} // Block from 820970B4h-820970C8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820970C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820970C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820970C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820970C8);
		  /* 820970C8h */ case    0:  		/* lbz R29, <#[R19 + 1]> */
		/* 820970C8h case    0:*/		cpu::mem::load8z( regs, &regs.R29, (uint32)(regs.R19 + 0x00000001) );
		/* 820970C8h case    0:*/		return 0x820970CC;
		  /* 820970CCh */ case    1:  		/* extsb. R8, R29 */
		/* 820970CCh case    1:*/		cpu::op::extsb<1>(regs,&regs.R8,regs.R29);
		/* 820970CCh case    1:*/		return 0x820970D0;
		  /* 820970D0h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 820970D0h case    2:*/		if ( regs.CR[0].eq ) { return 0x820970E4;  }
		/* 820970D0h case    2:*/		return 0x820970D4;
		  /* 820970D4h */ case    3:  		/* lwz R7, <#[R1 + 108]> */
		/* 820970D4h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x0000006C) );
		/* 820970D4h case    3:*/		return 0x820970D8;
		  /* 820970D8h */ case    4:  		/* li R30, 0 */
		/* 820970D8h case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820970D8h case    4:*/		return 0x820970DC;
		  /* 820970DCh */ case    5:  		/* lwz R6, <#[R1 + 84]> */
		/* 820970DCh case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 820970DCh case    5:*/		return 0x820970E0;
		  /* 820970E0h */ case    6:  		/* b -2428 */
		/* 820970E0h case    6:*/		return 0x82096764;
		/* 820970E0h case    6:*/		return 0x820970E4;
	}
	return 0x820970E4;
} // Block from 820970C8h-820970E4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820970E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820970E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820970E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820970E4);
		  /* 820970E4h */ case    0:  		/* mr R3, R24 */
		/* 820970E4h case    0:*/		regs.R3 = regs.R24;
		/* 820970E4h case    0:*/		return 0x820970E8;
		  /* 820970E8h */ case    1:  		/* b 56 */
		/* 820970E8h case    1:*/		return 0x82097120;
		/* 820970E8h case    1:*/		return 0x820970EC;
	}
	return 0x820970EC;
} // Block from 820970E4h-820970ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820970ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820970EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820970EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820970EC);
		  /* 820970ECh */ case    0:  		/* mr R6, R26 */
		/* 820970ECh case    0:*/		regs.R6 = regs.R26;
		/* 820970ECh case    0:*/		return 0x820970F0;
		  /* 820970F0h */ case    1:  		/* mr R5, R31 */
		/* 820970F0h case    1:*/		regs.R5 = regs.R31;
		/* 820970F0h case    1:*/		return 0x820970F4;
		  /* 820970F4h */ case    2:  		/* li R4, 512 */
		/* 820970F4h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x200);
		/* 820970F4h case    2:*/		return 0x820970F8;
		  /* 820970F8h */ case    3:  		/* addi R3, R1, 656 */
		/* 820970F8h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x290);
		/* 820970F8h case    3:*/		return 0x820970FC;
		  /* 820970FCh */ case    4:  		/* bl 16076 */
		/* 820970FCh case    4:*/		regs.LR = 0x82097100; return 0x8209AFC8;
		/* 820970FCh case    4:*/		return 0x82097100;
		  /* 82097100h */ case    5:  		/* mr R31, R3 */
		/* 82097100h case    5:*/		regs.R31 = regs.R3;
		/* 82097100h case    5:*/		return 0x82097104;
		  /* 82097104h */ case    6:  		/* cmpwi CR6, R3, -1 */
		/* 82097104h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82097104h case    6:*/		return 0x82097108;
		  /* 82097108h */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 82097108h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82097114;  }
		/* 82097108h case    7:*/		return 0x8209710C;
		  /* 8209710Ch */ case    8:  		/* li R31, 511 */
		/* 8209710Ch case    8:*/		cpu::op::li<0>(regs,&regs.R31,0x1FF);
		/* 8209710Ch case    8:*/		return 0x82097110;
		  /* 82097110h */ case    9:  		/* stb R30, <#[R1 + 1167]> */
		/* 82097110h case    9:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R1 + 0x0000048F) );
		/* 82097110h case    9:*/		return 0x82097114;
	}
	return 0x82097114;
} // Block from 820970ECh-82097114h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82097114h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097114( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097114) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097114);
		  /* 82097114h */ case    0:  		/* addi R3, R1, 656 */
		/* 82097114h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x290);
		/* 82097114h case    0:*/		return 0x82097118;
		  /* 82097118h */ case    1:  		/* bl -60864 */
		/* 82097118h case    1:*/		regs.LR = 0x8209711C; return 0x82088358;
		/* 82097118h case    1:*/		return 0x8209711C;
		  /* 8209711Ch */ case    2:  		/* mr R3, R31 */
		/* 8209711Ch case    2:*/		regs.R3 = regs.R31;
		/* 8209711Ch case    2:*/		return 0x82097120;
	}
	return 0x82097120;
} // Block from 82097114h-82097120h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82097120h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097120);
		  /* 82097120h */ case    0:  		/* addi R1, R1, 1328 */
		/* 82097120h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x530);
		/* 82097120h case    0:*/		return 0x82097124;
		  /* 82097124h */ case    1:  		/* b -24244 */
		/* 82097124h case    1:*/		return 0x82091270;
		/* 82097124h case    1:*/		return 0x82097128;
	}
	return 0x82097128;
} // Block from 82097120h-82097128h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82097128h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097128);
		  /* 82097128h */ case    0:  		/* mfspr R12, LR */
		/* 82097128h case    0:*/		regs.R12 = regs.LR;
		/* 82097128h case    0:*/		return 0x8209712C;
		  /* 8209712Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209712Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209712Ch case    1:*/		return 0x82097130;
		  /* 82097130h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82097130h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82097130h case    2:*/		return 0x82097134;
		  /* 82097134h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82097134h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82097134h case    3:*/		return 0x82097138;
		  /* 82097138h */ case    4:  		/* lwz R10, <#[R4 + 12]> */
		/* 82097138h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000000C) );
		/* 82097138h case    4:*/		return 0x8209713C;
		  /* 8209713Ch */ case    5:  		/* mr R11, R3 */
		/* 8209713Ch case    5:*/		regs.R11 = regs.R3;
		/* 8209713Ch case    5:*/		return 0x82097140;
		  /* 82097140h */ case    6:  		/* mr R31, R5 */
		/* 82097140h case    6:*/		regs.R31 = regs.R5;
		/* 82097140h case    6:*/		return 0x82097144;
		  /* 82097144h */ case    7:  		/* rlwinm. R10, R10, 0, 25, 25 */
		/* 82097144h case    7:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R10);
		/* 82097144h case    7:*/		return 0x82097148;
		  /* 82097148h */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 82097148h case    8:*/		if ( regs.CR[0].eq ) { return 0x82097158;  }
		/* 82097148h case    8:*/		return 0x8209714C;
		  /* 8209714Ch */ case    9:  		/* lwz R10, <#[R4 + 8]> */
		/* 8209714Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 8209714Ch case    9:*/		return 0x82097150;
		  /* 82097150h */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 82097150h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82097150h case   10:*/		return 0x82097154;
		  /* 82097154h */ case   11:  		/* bc 12, CR6_EQ, 72 */
		/* 82097154h case   11:*/		if ( regs.CR[6].eq ) { return 0x8209719C;  }
		/* 82097154h case   11:*/		return 0x82097158;
	}
	return 0x82097158;
} // Block from 82097128h-82097158h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82097158h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097158);
		  /* 82097158h */ case    0:  		/* lwz R10, <#[R4 + 4]> */
		/* 82097158h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 82097158h case    0:*/		return 0x8209715C;
		  /* 8209715Ch */ case    1:  		/* addic. R10, R10, -1 */
		/* 8209715Ch case    1:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8209715Ch case    1:*/		return 0x82097160;
		  /* 82097160h */ case    2:  		/* stw R10, <#[R4 + 4]> */
		/* 82097160h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 82097160h case    2:*/		return 0x82097164;
		  /* 82097164h */ case    3:  		/* bc 12, CR0_LT, 32 */
		/* 82097164h case    3:*/		if ( regs.CR[0].lt ) { return 0x82097184;  }
		/* 82097164h case    3:*/		return 0x82097168;
		  /* 82097168h */ case    4:  		/* lwz R10, <#[R4]> */
		/* 82097168h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 82097168h case    4:*/		return 0x8209716C;
		  /* 8209716Ch */ case    5:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 8209716Ch case    5:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 8209716Ch case    5:*/		return 0x82097170;
		  /* 82097170h */ case    6:  		/* stb R11, <#[R10]> */
		/* 82097170h case    6:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82097170h case    6:*/		return 0x82097174;
		  /* 82097174h */ case    7:  		/* lwz R11, <#[R4]> */
		/* 82097174h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82097174h case    7:*/		return 0x82097178;
		  /* 82097178h */ case    8:  		/* addi R11, R11, 1 */
		/* 82097178h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82097178h case    8:*/		return 0x8209717C;
		  /* 8209717Ch */ case    9:  		/* stw R11, <#[R4]> */
		/* 8209717Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8209717Ch case    9:*/		return 0x82097180;
		  /* 82097180h */ case   10:  		/* b 12 */
		/* 82097180h case   10:*/		return 0x8209718C;
		/* 82097180h case   10:*/		return 0x82097184;
	}
	return 0x82097184;
} // Block from 82097158h-82097184h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82097184h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097184( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097184) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097184);
		  /* 82097184h */ case    0:  		/* extsb R3, R11 */
		/* 82097184h case    0:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 82097184h case    0:*/		return 0x82097188;
		  /* 82097188h */ case    1:  		/* bl -9416 */
		/* 82097188h case    1:*/		regs.LR = 0x8209718C; return 0x82094CC0;
		/* 82097188h case    1:*/		return 0x8209718C;
	}
	return 0x8209718C;
} // Block from 82097184h-8209718Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209718Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209718C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209718C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209718C);
		  /* 8209718Ch */ case    0:  		/* cmpwi CR6, R3, -1 */
		/* 8209718Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8209718Ch case    0:*/		return 0x82097190;
		  /* 82097190h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82097190h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209719C;  }
		/* 82097190h case    1:*/		return 0x82097194;
		  /* 82097194h */ case    2:  		/* li R11, -1 */
		/* 82097194h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 82097194h case    2:*/		return 0x82097198;
		  /* 82097198h */ case    3:  		/* b 12 */
		/* 82097198h case    3:*/		return 0x820971A4;
		/* 82097198h case    3:*/		return 0x8209719C;
	}
	return 0x8209719C;
} // Block from 8209718Ch-8209719Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209719Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209719C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209719C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209719C);
		  /* 8209719Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8209719Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209719Ch case    0:*/		return 0x820971A0;
		  /* 820971A0h */ case    1:  		/* addi R11, R11, 1 */
		/* 820971A0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820971A0h case    1:*/		return 0x820971A4;
	}
	return 0x820971A4;
} // Block from 8209719Ch-820971A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820971A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820971A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820971A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820971A4);
		  /* 820971A4h */ case    0:  		/* stw R11, <#[R31]> */
		/* 820971A4h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820971A4h case    0:*/		return 0x820971A8;
		  /* 820971A8h */ case    1:  		/* addi R1, R1, 96 */
		/* 820971A8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820971A8h case    1:*/		return 0x820971AC;
		  /* 820971ACh */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820971ACh case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820971ACh case    2:*/		return 0x820971B0;
		  /* 820971B0h */ case    3:  		/* mtspr LR, R12 */
		/* 820971B0h case    3:*/		regs.LR = regs.R12;
		/* 820971B0h case    3:*/		return 0x820971B4;
		  /* 820971B4h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820971B4h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820971B4h case    4:*/		return 0x820971B8;
		  /* 820971B8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820971B8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820971B8h case    5:*/		return 0x820971BC;
	}
	return 0x820971BC;
} // Block from 820971A4h-820971BCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820971BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820971BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820971BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820971BC);
		  /* 820971BCh */ case    0:  		/* nop */
		/* 820971BCh case    0:*/		cpu::op::nop();
		/* 820971BCh case    0:*/		return 0x820971C0;
	}
	return 0x820971C0;
} // Block from 820971BCh-820971C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820971C0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820971C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820971C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820971C0);
		  /* 820971C0h */ case    0:  		/* mfspr R12, LR */
		/* 820971C0h case    0:*/		regs.R12 = regs.LR;
		/* 820971C0h case    0:*/		return 0x820971C4;
		  /* 820971C4h */ case    1:  		/* bl -24432 */
		/* 820971C4h case    1:*/		regs.LR = 0x820971C8; return 0x82091254;
		/* 820971C4h case    1:*/		return 0x820971C8;
		  /* 820971C8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820971C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820971C8h case    2:*/		return 0x820971CC;
		  /* 820971CCh */ case    3:  		/* mr R28, R3 */
		/* 820971CCh case    3:*/		regs.R28 = regs.R3;
		/* 820971CCh case    3:*/		return 0x820971D0;
		  /* 820971D0h */ case    4:  		/* mr R30, R4 */
		/* 820971D0h case    4:*/		regs.R30 = regs.R4;
		/* 820971D0h case    4:*/		return 0x820971D4;
		  /* 820971D4h */ case    5:  		/* mr R29, R5 */
		/* 820971D4h case    5:*/		regs.R29 = regs.R5;
		/* 820971D4h case    5:*/		return 0x820971D8;
		  /* 820971D8h */ case    6:  		/* mr R31, R6 */
		/* 820971D8h case    6:*/		regs.R31 = regs.R6;
		/* 820971D8h case    6:*/		return 0x820971DC;
		  /* 820971DCh */ case    7:  		/* bl -8916 */
		/* 820971DCh case    7:*/		regs.LR = 0x820971E0; return 0x82094F08;
		/* 820971DCh case    7:*/		return 0x820971E0;
		  /* 820971E0h */ case    8:  		/* lwz R11, <#[R29 + 12]> */
		/* 820971E0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 820971E0h case    8:*/		return 0x820971E4;
		  /* 820971E4h */ case    9:  		/* lwz R27, <#[R3]> */
		/* 820971E4h case    9:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 820971E4h case    9:*/		return 0x820971E8;
		  /* 820971E8h */ case   10:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 820971E8h case   10:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 820971E8h case   10:*/		return 0x820971EC;
		  /* 820971ECh */ case   11:  		/* bc 12, CR0_EQ, 32 */
		/* 820971ECh case   11:*/		if ( regs.CR[0].eq ) { return 0x8209720C;  }
		/* 820971ECh case   11:*/		return 0x820971F0;
		  /* 820971F0h */ case   12:  		/* lwz R11, <#[R29 + 8]> */
		/* 820971F0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820971F0h case   12:*/		return 0x820971F4;
		  /* 820971F4h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 820971F4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820971F4h case   13:*/		return 0x820971F8;
		  /* 820971F8h */ case   14:  		/* bc 4, CR6_EQ, 20 */
		/* 820971F8h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8209720C;  }
		/* 820971F8h case   14:*/		return 0x820971FC;
		  /* 820971FCh */ case   15:  		/* lwz R11, <#[R31]> */
		/* 820971FCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820971FCh case   15:*/		return 0x82097200;
		  /* 82097200h */ case   16:  		/* add R11, R11, R30 */
		/* 82097200h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 82097200h case   16:*/		return 0x82097204;
		  /* 82097204h */ case   17:  		/* stw R11, <#[R31]> */
		/* 82097204h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82097204h case   17:*/		return 0x82097208;
		  /* 82097208h */ case   18:  		/* b 124 */
		/* 82097208h case   18:*/		return 0x82097284;
		/* 82097208h case   18:*/		return 0x8209720C;
	}
	return 0x8209720C;
} // Block from 820971C0h-8209720Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8209720Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209720C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209720C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209720C);
		  /* 8209720Ch */ case    0:  		/* bl -8964 */
		/* 8209720Ch case    0:*/		regs.LR = 0x82097210; return 0x82094F08;
		/* 8209720Ch case    0:*/		return 0x82097210;
		  /* 82097210h */ case    1:  		/* li R11, 0 */
		/* 82097210h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82097210h case    1:*/		return 0x82097214;
		  /* 82097214h */ case    2:  		/* cmpwi CR6, R30, 0 */
		/* 82097214h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82097214h case    2:*/		return 0x82097218;
		  /* 82097218h */ case    3:  		/* stw R11, <#[R3]> */
		/* 82097218h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82097218h case    3:*/		return 0x8209721C;
		  /* 8209721Ch */ case    4:  		/* bc 4, CR6_GT, 80 */
		/* 8209721Ch case    4:*/		if ( !regs.CR[6].gt ) { return 0x8209726C;  }
		/* 8209721Ch case    4:*/		return 0x82097220;
		  /* 82097220h */ case    5:  		/* addi R28, R28, -1 */
		/* 82097220h case    5:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0xFFFFFFFF);
		/* 82097220h case    5:*/		return 0x82097224;
		  /* 82097224h */ case    6:  		/* mr R5, R31 */
		/* 82097224h case    6:*/		regs.R5 = regs.R31;
		/* 82097224h case    6:*/		return 0x82097228;
		  /* 82097228h */ case    7:  		/* lbzu R3, <#[R28 + 1]> */
		/* 82097228h case    7:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000001) );
		regs.R28 = (uint32)(regs.R28 + 0x00000001);
		/* 82097228h case    7:*/		return 0x8209722C;
		  /* 8209722Ch */ case    8:  		/* mr R4, R29 */
		/* 8209722Ch case    8:*/		regs.R4 = regs.R29;
		/* 8209722Ch case    8:*/		return 0x82097230;
		  /* 82097230h */ case    9:  		/* addi R30, R30, -1 */
		/* 82097230h case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 82097230h case    9:*/		return 0x82097234;
		  /* 82097234h */ case   10:  		/* bl -268 */
		/* 82097234h case   10:*/		regs.LR = 0x82097238; return 0x82097128;
		/* 82097234h case   10:*/		return 0x82097238;
		  /* 82097238h */ case   11:  		/* lwz R11, <#[R31]> */
		/* 82097238h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82097238h case   11:*/		return 0x8209723C;
		  /* 8209723Ch */ case   12:  		/* cmpwi CR6, R11, -1 */
		/* 8209723Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8209723Ch case   12:*/		return 0x82097240;
		  /* 82097240h */ case   13:  		/* bc 4, CR6_EQ, 36 */
		/* 82097240h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82097264;  }
		/* 82097240h case   13:*/		return 0x82097244;
		  /* 82097244h */ case   14:  		/* bl -9020 */
		/* 82097244h case   14:*/		regs.LR = 0x82097248; return 0x82094F08;
		/* 82097244h case   14:*/		return 0x82097248;
		  /* 82097248h */ case   15:  		/* lwz R11, <#[R3]> */
		/* 82097248h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82097248h case   15:*/		return 0x8209724C;
		  /* 8209724Ch */ case   16:  		/* cmpwi CR6, R11, 42 */
		/* 8209724Ch case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002A);
		/* 8209724Ch case   16:*/		return 0x82097250;
		  /* 82097250h */ case   17:  		/* bc 4, CR6_EQ, 28 */
		/* 82097250h case   17:*/		if ( !regs.CR[6].eq ) { return 0x8209726C;  }
		/* 82097250h case   17:*/		return 0x82097254;
		  /* 82097254h */ case   18:  		/* mr R5, R31 */
		/* 82097254h case   18:*/		regs.R5 = regs.R31;
		/* 82097254h case   18:*/		return 0x82097258;
		  /* 82097258h */ case   19:  		/* mr R4, R29 */
		/* 82097258h case   19:*/		regs.R4 = regs.R29;
		/* 82097258h case   19:*/		return 0x8209725C;
		  /* 8209725Ch */ case   20:  		/* li R3, 63 */
		/* 8209725Ch case   20:*/		cpu::op::li<0>(regs,&regs.R3,0x3F);
		/* 8209725Ch case   20:*/		return 0x82097260;
		  /* 82097260h */ case   21:  		/* bl -312 */
		/* 82097260h case   21:*/		regs.LR = 0x82097264; return 0x82097128;
		/* 82097260h case   21:*/		return 0x82097264;
	}
	return 0x82097264;
} // Block from 8209720Ch-82097264h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82097264h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097264( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097264) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097264);
		  /* 82097264h */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 82097264h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82097264h case    0:*/		return 0x82097268;
		  /* 82097268h */ case    1:  		/* bc 12, CR6_GT, -68 */
		/* 82097268h case    1:*/		if ( regs.CR[6].gt ) { return 0x82097224;  }
		/* 82097268h case    1:*/		return 0x8209726C;
	}
	return 0x8209726C;
} // Block from 82097264h-8209726Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209726Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209726C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209726C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209726C);
		  /* 8209726Ch */ case    0:  		/* bl -9060 */
		/* 8209726Ch case    0:*/		regs.LR = 0x82097270; return 0x82094F08;
		/* 8209726Ch case    0:*/		return 0x82097270;
		  /* 82097270h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 82097270h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82097270h case    1:*/		return 0x82097274;
		  /* 82097274h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 82097274h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82097274h case    2:*/		return 0x82097278;
		  /* 82097278h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 82097278h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82097284;  }
		/* 82097278h case    3:*/		return 0x8209727C;
		  /* 8209727Ch */ case    4:  		/* bl -9076 */
		/* 8209727Ch case    4:*/		regs.LR = 0x82097280; return 0x82094F08;
		/* 8209727Ch case    4:*/		return 0x82097280;
		  /* 82097280h */ case    5:  		/* stw R27, <#[R3]> */
		/* 82097280h case    5:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 82097280h case    5:*/		return 0x82097284;
	}
	return 0x82097284;
} // Block from 8209726Ch-82097284h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82097284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097284);
		  /* 82097284h */ case    0:  		/* addi R1, R1, 128 */
		/* 82097284h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82097284h case    0:*/		return 0x82097288;
		  /* 82097288h */ case    1:  		/* b -24548 */
		/* 82097288h case    1:*/		return 0x820912A4;
		/* 82097288h case    1:*/		return 0x8209728C;
		  /* 8209728Ch */ case    2:  		/* nop */
		/* 8209728Ch case    2:*/		cpu::op::nop();
		/* 8209728Ch case    2:*/		return 0x82097290;
	}
	return 0x82097290;
} // Block from 82097284h-82097290h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82097290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097290);
		  /* 82097290h */ case    0:  		/* mfspr R12, LR */
		/* 82097290h case    0:*/		regs.R12 = regs.LR;
		/* 82097290h case    0:*/		return 0x82097294;
		  /* 82097294h */ case    1:  		/* bl -24692 */
		/* 82097294h case    1:*/		regs.LR = 0x82097298; return 0x82091220;
		/* 82097294h case    1:*/		return 0x82097298;
		  /* 82097298h */ case    2:  		/* stwu R1, <#[R1 - 1328]> */
		/* 82097298h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFAD0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFAD0);
		/* 82097298h case    2:*/		return 0x8209729C;
		  /* 8209729Ch */ case    3:  		/* li R30, 0 */
		/* 8209729Ch case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8209729Ch case    3:*/		return 0x820972A0;
		  /* 820972A0h */ case    4:  		/* mr R18, R3 */
		/* 820972A0h case    4:*/		regs.R18 = regs.R3;
		/* 820972A0h case    4:*/		return 0x820972A4;
		  /* 820972A4h */ case    5:  		/* mr R31, R4 */
		/* 820972A4h case    5:*/		regs.R31 = regs.R4;
		/* 820972A4h case    5:*/		return 0x820972A8;
		  /* 820972A8h */ case    6:  		/* stw R30, <#[R1 + 108]> */
		/* 820972A8h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000006C) );
		/* 820972A8h case    6:*/		return 0x820972AC;
		  /* 820972ACh */ case    7:  		/* mr R26, R6 */
		/* 820972ACh case    7:*/		regs.R26 = regs.R6;
		/* 820972ACh case    7:*/		return 0x820972B0;
		  /* 820972B0h */ case    8:  		/* stw R30, <#[R1 + 96]> */
		/* 820972B0h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000060) );
		/* 820972B0h case    8:*/		return 0x820972B4;
		  /* 820972B4h */ case    9:  		/* cmplwi CR6, R3, 0 */
		/* 820972B4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820972B4h case    9:*/		return 0x820972B8;
		  /* 820972B8h */ case   10:  		/* stw R30, <#[R1 + 92]> */
		/* 820972B8h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000005C) );
		/* 820972B8h case   10:*/		return 0x820972BC;
		  /* 820972BCh */ case   11:  		/* mr R27, R30 */
		/* 820972BCh case   11:*/		regs.R27 = regs.R30;
		/* 820972BCh case   11:*/		return 0x820972C0;
		  /* 820972C0h */ case   12:  		/* stw R30, <#[R1 + 104]> */
		/* 820972C0h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000068) );
		/* 820972C0h case   12:*/		return 0x820972C4;
		  /* 820972C4h */ case   13:  		/* mr R25, R30 */
		/* 820972C4h case   13:*/		regs.R25 = regs.R30;
		/* 820972C4h case   13:*/		return 0x820972C8;
		  /* 820972C8h */ case   14:  		/* mr R16, R30 */
		/* 820972C8h case   14:*/		regs.R16 = regs.R30;
		/* 820972C8h case   14:*/		return 0x820972CC;
		  /* 820972CCh */ case   15:  		/* bc 4, CR6_EQ, 28 */
		/* 820972CCh case   15:*/		if ( !regs.CR[6].eq ) { return 0x820972E8;  }
		/* 820972CCh case   15:*/		return 0x820972D0;
		  /* 820972D0h */ case   16:  		/* bl -9160 */
		/* 820972D0h case   16:*/		regs.LR = 0x820972D4; return 0x82094F08;
		/* 820972D0h case   16:*/		return 0x820972D4;
		  /* 820972D4h */ case   17:  		/* li R11, 22 */
		/* 820972D4h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 820972D4h case   17:*/		return 0x820972D8;
		  /* 820972D8h */ case   18:  		/* stw R11, <#[R3]> */
		/* 820972D8h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820972D8h case   18:*/		return 0x820972DC;
		  /* 820972DCh */ case   19:  		/* bl -14716 */
		/* 820972DCh case   19:*/		regs.LR = 0x820972E0; return 0x82093960;
		/* 820972DCh case   19:*/		return 0x820972E0;
		  /* 820972E0h */ case   20:  		/* li R3, -1 */
		/* 820972E0h case   20:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820972E0h case   20:*/		return 0x820972E4;
		  /* 820972E4h */ case   21:  		/* b 2796 */
		/* 820972E4h case   21:*/		return 0x82097DD0;
		/* 820972E4h case   21:*/		return 0x820972E8;
	}
	return 0x820972E8;
} // Block from 82097290h-820972E8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820972E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820972E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820972E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820972E8);
		  /* 820972E8h */ case    0:  		/* lwz R11, <#[R18 + 12]> */
		/* 820972E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x0000000C) );
		/* 820972E8h case    0:*/		return 0x820972EC;
		  /* 820972ECh */ case    1:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 820972ECh case    1:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 820972ECh case    1:*/		return 0x820972F0;
		  /* 820972F0h */ case    2:  		/* bc 4, CR0_EQ, 148 */
		/* 820972F0h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82097384;  }
		/* 820972F0h case    2:*/		return 0x820972F4;
		  /* 820972F4h */ case    3:  		/* mr R3, R18 */
		/* 820972F4h case    3:*/		regs.R3 = regs.R18;
		/* 820972F4h case    3:*/		return 0x820972F8;
		  /* 820972F8h */ case    4:  		/* bl 13960 */
		/* 820972F8h case    4:*/		regs.LR = 0x820972FC; return 0x8209A980;
		/* 820972F8h case    4:*/		return 0x820972FC;
		  /* 820972FCh */ case    5:  		/* lis R11, -32215 */
		/* 820972FCh case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 820972FCh case    5:*/		return 0x82097300;
		  /* 82097300h */ case    6:  		/* lis R10, -32217 */
		/* 82097300h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 82097300h case    6:*/		return 0x82097304;
		  /* 82097304h */ case    7:  		/* cmpwi CR6, R3, -1 */
		/* 82097304h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82097304h case    7:*/		return 0x82097308;
		  /* 82097308h */ case    8:  		/* addi R11, R11, -25504 */
		/* 82097308h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF9C60);
		/* 82097308h case    8:*/		return 0x8209730C;
		  /* 8209730Ch */ case    9:  		/* addi R8, R10, 8872 */
		/* 8209730Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x22A8);
		/* 8209730Ch case    9:*/		return 0x82097310;
		  /* 82097310h */ case   10:  		/* bc 12, CR6_EQ, 40 */
		/* 82097310h case   10:*/		if ( regs.CR[6].eq ) { return 0x82097338;  }
		/* 82097310h case   10:*/		return 0x82097314;
		  /* 82097314h */ case   11:  		/* cmpwi CR6, R3, -2 */
		/* 82097314h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFE);
		/* 82097314h case   11:*/		return 0x82097318;
		  /* 82097318h */ case   12:  		/* bc 12, CR6_EQ, 32 */
		/* 82097318h case   12:*/		if ( regs.CR[6].eq ) { return 0x82097338;  }
		/* 82097318h case   12:*/		return 0x8209731C;
		  /* 8209731Ch */ case   13:  		/* srawi R10, R3, 5 */
		/* 8209731Ch case   13:*/		cpu::op::srawi<0,5>(regs,&regs.R10,regs.R3);
		/* 8209731Ch case   13:*/		return 0x82097320;
		  /* 82097320h */ case   14:  		/* rlwinm R9, R3, 0, 27, 31 */
		/* 82097320h case   14:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R3);
		/* 82097320h case   14:*/		return 0x82097324;
		  /* 82097324h */ case   15:  		/* rlwinm R7, R10, 2, 0, 29 */
		/* 82097324h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R10);
		/* 82097324h case   15:*/		return 0x82097328;
		  /* 82097328h */ case   16:  		/* mulli R10, R9, 72 */
		/* 82097328h case   16:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R9,0x48);
		/* 82097328h case   16:*/		return 0x8209732C;
		  /* 8209732Ch */ case   17:  		/* lwzx R9, <#[R7 + R11]> */
		/* 8209732Ch case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 8209732Ch case   17:*/		return 0x82097330;
		  /* 82097330h */ case   18:  		/* add R10, R9, R10 */
		/* 82097330h case   18:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82097330h case   18:*/		return 0x82097334;
		  /* 82097334h */ case   19:  		/* b 8 */
		/* 82097334h case   19:*/		return 0x8209733C;
		/* 82097334h case   19:*/		return 0x82097338;
	}
	return 0x82097338;
} // Block from 820972E8h-82097338h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82097338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097338);
		  /* 82097338h */ case    0:  		/* mr R10, R8 */
		/* 82097338h case    0:*/		regs.R10 = regs.R8;
		/* 82097338h case    0:*/		return 0x8209733C;
	}
	return 0x8209733C;
} // Block from 82097338h-8209733Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209733Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209733C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209733C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209733C);
		  /* 8209733Ch */ case    0:  		/* lbz R10, <#[R10 + 40]> */
		/* 8209733Ch case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000028) );
		/* 8209733Ch case    0:*/		return 0x82097340;
		  /* 82097340h */ case    1:  		/* rlwinm. R10, R10, 0, 0, 30 */
		/* 82097340h case    1:*/		cpu::op::rlwinm<1,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82097340h case    1:*/		return 0x82097344;
		  /* 82097344h */ case    2:  		/* bc 4, CR0_EQ, -116 */
		/* 82097344h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820972D0;  }
		/* 82097344h case    2:*/		return 0x82097348;
		  /* 82097348h */ case    3:  		/* cmpwi CR6, R3, -1 */
		/* 82097348h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82097348h case    3:*/		return 0x8209734C;
		  /* 8209734Ch */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 8209734Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x82097374;  }
		/* 8209734Ch case    4:*/		return 0x82097350;
		  /* 82097350h */ case    5:  		/* cmpwi CR6, R3, -2 */
		/* 82097350h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFE);
		/* 82097350h case    5:*/		return 0x82097354;
		  /* 82097354h */ case    6:  		/* bc 12, CR6_EQ, 32 */
		/* 82097354h case    6:*/		if ( regs.CR[6].eq ) { return 0x82097374;  }
		/* 82097354h case    6:*/		return 0x82097358;
		  /* 82097358h */ case    7:  		/* srawi R10, R3, 5 */
		/* 82097358h case    7:*/		cpu::op::srawi<0,5>(regs,&regs.R10,regs.R3);
		/* 82097358h case    7:*/		return 0x8209735C;
		  /* 8209735Ch */ case    8:  		/* rlwinm R9, R3, 0, 27, 31 */
		/* 8209735Ch case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R3);
		/* 8209735Ch case    8:*/		return 0x82097360;
		  /* 82097360h */ case    9:  		/* rlwinm R8, R10, 2, 0, 29 */
		/* 82097360h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R10);
		/* 82097360h case    9:*/		return 0x82097364;
		  /* 82097364h */ case   10:  		/* mulli R10, R9, 72 */
		/* 82097364h case   10:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R9,0x48);
		/* 82097364h case   10:*/		return 0x82097368;
		  /* 82097368h */ case   11:  		/* lwzx R11, <#[R8 + R11]> */
		/* 82097368h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82097368h case   11:*/		return 0x8209736C;
		  /* 8209736Ch */ case   12:  		/* add R11, R11, R10 */
		/* 8209736Ch case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8209736Ch case   12:*/		return 0x82097370;
		  /* 82097370h */ case   13:  		/* b 8 */
		/* 82097370h case   13:*/		return 0x82097378;
		/* 82097370h case   13:*/		return 0x82097374;
	}
	return 0x82097374;
} // Block from 8209733Ch-82097374h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82097374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097374);
		  /* 82097374h */ case    0:  		/* mr R11, R8 */
		/* 82097374h case    0:*/		regs.R11 = regs.R8;
		/* 82097374h case    0:*/		return 0x82097378;
	}
	return 0x82097378;
} // Block from 82097374h-82097378h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82097378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097378);
		  /* 82097378h */ case    0:  		/* lbz R11, <#[R11 + 40]> */
		/* 82097378h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82097378h case    0:*/		return 0x8209737C;
		  /* 8209737Ch */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8209737Ch case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8209737Ch case    1:*/		return 0x82097380;
		  /* 82097380h */ case    2:  		/* bc 4, CR0_EQ, -176 */
		/* 82097380h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820972D0;  }
		/* 82097380h case    2:*/		return 0x82097384;
	}
	return 0x82097384;
} // Block from 82097378h-82097384h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82097384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097384);
		  /* 82097384h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82097384h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82097384h case    0:*/		return 0x82097388;
		  /* 82097388h */ case    1:  		/* bc 12, CR6_EQ, -184 */
		/* 82097388h case    1:*/		if ( regs.CR[6].eq ) { return 0x820972D0;  }
		/* 82097388h case    1:*/		return 0x8209738C;
		  /* 8209738Ch */ case    2:  		/* bl 13140 */
		/* 8209738Ch case    2:*/		regs.LR = 0x82097390; return 0x8209A6E0;
		/* 8209738Ch case    2:*/		return 0x82097390;
		  /* 82097390h */ case    3:  		/* addi R11, R3, 32 */
		/* 82097390h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x20);
		/* 82097390h case    3:*/		return 0x82097394;
		  /* 82097394h */ case    4:  		/* cmplw CR6, R18, R11 */
		/* 82097394h case    4:*/		cpu::op::cmplw<6>(regs,regs.R18,regs.R11);
		/* 82097394h case    4:*/		return 0x82097398;
		  /* 82097398h */ case    5:  		/* bc 12, CR6_EQ, 2564 */
		/* 82097398h case    5:*/		if ( regs.CR[6].eq ) { return 0x82097D9C;  }
		/* 82097398h case    5:*/		return 0x8209739C;
		  /* 8209739Ch */ case    6:  		/* bl 13124 */
		/* 8209739Ch case    6:*/		regs.LR = 0x820973A0; return 0x8209A6E0;
		/* 8209739Ch case    6:*/		return 0x820973A0;
		  /* 820973A0h */ case    7:  		/* addi R11, R3, 64 */
		/* 820973A0h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x40);
		/* 820973A0h case    7:*/		return 0x820973A4;
		  /* 820973A4h */ case    8:  		/* cmplw CR6, R18, R11 */
		/* 820973A4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R18,regs.R11);
		/* 820973A4h case    8:*/		return 0x820973A8;
		  /* 820973A8h */ case    9:  		/* bc 12, CR6_EQ, 2548 */
		/* 820973A8h case    9:*/		if ( regs.CR[6].eq ) { return 0x82097D9C;  }
		/* 820973A8h case    9:*/		return 0x820973AC;
		  /* 820973ACh */ case   10:  		/* lbz R29, <#[R31]> */
		/* 820973ACh case   10:*/		cpu::mem::load8z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000000) );
		/* 820973ACh case   10:*/		return 0x820973B0;
		  /* 820973B0h */ case   11:  		/* mr R24, R30 */
		/* 820973B0h case   11:*/		regs.R24 = regs.R30;
		/* 820973B0h case   11:*/		return 0x820973B4;
		  /* 820973B4h */ case   12:  		/* mr R7, R30 */
		/* 820973B4h case   12:*/		regs.R7 = regs.R30;
		/* 820973B4h case   12:*/		return 0x820973B8;
		  /* 820973B8h */ case   13:  		/* stw R30, <#[R1 + 100]> */
		/* 820973B8h case   13:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000064) );
		/* 820973B8h case   13:*/		return 0x820973BC;
		  /* 820973BCh */ case   14:  		/* extsb. R8, R29 */
		/* 820973BCh case   14:*/		cpu::op::extsb<1>(regs,&regs.R8,regs.R29);
		/* 820973BCh case   14:*/		return 0x820973C0;
		  /* 820973C0h */ case   15:  		/* stw R30, <#[R1 + 80]> */
		/* 820973C0h case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 820973C0h case   15:*/		return 0x820973C4;
		  /* 820973C4h */ case   16:  		/* stw R30, <#[R1 + 84]> */
		/* 820973C4h case   16:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 820973C4h case   16:*/		return 0x820973C8;
		  /* 820973C8h */ case   17:  		/* mr R14, R30 */
		/* 820973C8h case   17:*/		regs.R14 = regs.R30;
		/* 820973C8h case   17:*/		return 0x820973CC;
		  /* 820973CCh */ case   18:  		/* bc 12, CR0_EQ, 2504 */
		/* 820973CCh case   18:*/		if ( regs.CR[0].eq ) { return 0x82097D94;  }
		/* 820973CCh case   18:*/		return 0x820973D0;
		  /* 820973D0h */ case   19:  		/* lis R11, -32217 */
		/* 820973D0h case   19:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 820973D0h case   19:*/		return 0x820973D4;
		  /* 820973D4h */ case   20:  		/* lwz R21, <#[R1 + 112]> */
		/* 820973D4h case   20:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000070) );
		/* 820973D4h case   20:*/		return 0x820973D8;
		  /* 820973D8h */ case   21:  		/* lis R10, -32217 */
		/* 820973D8h case   21:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 820973D8h case   21:*/		return 0x820973DC;
		  /* 820973DCh */ case   22:  		/* lwz R28, <#[R1 + 112]> */
		/* 820973DCh case   22:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000070) );
		/* 820973DCh case   22:*/		return 0x820973E0;
		  /* 820973E0h */ case   23:  		/* lis R9, -32255 */
		/* 820973E0h case   23:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820973E0h case   23:*/		return 0x820973E4;
		  /* 820973E4h */ case   24:  		/* addi R19, R31, -1 */
		/* 820973E4h case   24:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R31,0xFFFFFFFF);
		/* 820973E4h case   24:*/		return 0x820973E8;
		  /* 820973E8h */ case   25:  		/* lis R15, -32255 */
		/* 820973E8h case   25:*/		cpu::op::lis<0>(regs,&regs.R15,0xFFFF8201);
		/* 820973E8h case   25:*/		return 0x820973EC;
		  /* 820973ECh */ case   26:  		/* lis R20, -32255 */
		/* 820973ECh case   26:*/		cpu::op::lis<0>(regs,&regs.R20,0xFFFF8201);
		/* 820973ECh case   26:*/		return 0x820973F0;
		  /* 820973F0h */ case   27:  		/* addi R23, R11, 8856 */
		/* 820973F0h case   27:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R11,0x2298);
		/* 820973F0h case   27:*/		return 0x820973F4;
		  /* 820973F4h */ case   28:  		/* addi R22, R10, 7288 */
		/* 820973F4h case   28:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R10,0x1C78);
		/* 820973F4h case   28:*/		return 0x820973F8;
		  /* 820973F8h */ case   29:  		/* addi R17, R9, -21592 */
		/* 820973F8h case   29:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R9,0xFFFFABA8);
		/* 820973F8h case   29:*/		return 0x820973FC;
		  /* 820973FCh */ case   30:  		/* addi R19, R19, 1 */
		/* 820973FCh case   30:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x1);
		/* 820973FCh case   30:*/		return 0x82097400;
		  /* 82097400h */ case   31:  		/* cmpwi CR6, R24, 0 */
		/* 82097400h case   31:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 82097400h case   31:*/		return 0x82097404;
		  /* 82097404h */ case   32:  		/* bc 12, CR6_LT, 2428 */
		/* 82097404h case   32:*/		if ( regs.CR[6].lt ) { return 0x82097D80;  }
		/* 82097404h case   32:*/		return 0x82097408;
		  /* 82097408h */ case   33:  		/* cmpwi CR6, R8, 32 */
		/* 82097408h case   33:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000020);
		/* 82097408h case   33:*/		return 0x8209740C;
		  /* 8209740Ch */ case   34:  		/* bc 12, CR6_LT, 28 */
		/* 8209740Ch case   34:*/		if ( regs.CR[6].lt ) { return 0x82097428;  }
		/* 8209740Ch case   34:*/		return 0x82097410;
		  /* 82097410h */ case   35:  		/* cmpwi CR6, R8, 120 */
		/* 82097410h case   35:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000078);
		/* 82097410h case   35:*/		return 0x82097414;
		  /* 82097414h */ case   36:  		/* bc 12, CR6_GT, 20 */
		/* 82097414h case   36:*/		if ( regs.CR[6].gt ) { return 0x82097428;  }
		/* 82097414h case   36:*/		return 0x82097418;
		  /* 82097418h */ case   37:  		/* add R11, R8, R17 */
		/* 82097418h case   37:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R17);
		/* 82097418h case   37:*/		return 0x8209741C;
		  /* 8209741Ch */ case   38:  		/* lbz R11, <#[R11 - 32]> */
		/* 8209741Ch case   38:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFE0) );
		/* 8209741Ch case   38:*/		return 0x82097420;
		  /* 82097420h */ case   39:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 82097420h case   39:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 82097420h case   39:*/		return 0x82097424;
		  /* 82097424h */ case   40:  		/* b 8 */
		/* 82097424h case   40:*/		return 0x8209742C;
		/* 82097424h case   40:*/		return 0x82097428;
	}
	return 0x82097428;
} // Block from 82097384h-82097428h (41 instructions)

//////////////////////////////////////////////////////
// Block at 82097428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097428);
		  /* 82097428h */ case    0:  		/* mr R11, R30 */
		/* 82097428h case    0:*/		regs.R11 = regs.R30;
		/* 82097428h case    0:*/		return 0x8209742C;
	}
	return 0x8209742C;
} // Block from 82097428h-8209742Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209742Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209742C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209742C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209742C);
		  /* 8209742Ch */ case    0:  		/* lwz R10, <#[R1 + 100]> */
		/* 8209742Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000064) );
		/* 8209742Ch case    0:*/		return 0x82097430;
		  /* 82097430h */ case    1:  		/* mulli R11, R11, 9 */
		/* 82097430h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x9);
		/* 82097430h case    1:*/		return 0x82097434;
		  /* 82097434h */ case    2:  		/* add R11, R11, R10 */
		/* 82097434h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82097434h case    2:*/		return 0x82097438;
		  /* 82097438h */ case    3:  		/* lbzx R11, <#[R11 + R17]> */
		/* 82097438h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R17 + 0x00000000) );
		/* 82097438h case    3:*/		return 0x8209743C;
		  /* 8209743Ch */ case    4:  		/* rlwinm R11, R11, 28, 4, 31 */
		/* 8209743Ch case    4:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R11,regs.R11);
		/* 8209743Ch case    4:*/		return 0x82097440;
		  /* 82097440h */ case    5:  		/* stw R11, <#[R1 + 100]> */
		/* 82097440h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82097440h case    5:*/		return 0x82097444;
		  /* 82097444h */ case    6:  		/* cmpwi CR6, R11, 8 */
		/* 82097444h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000008);
		/* 82097444h case    6:*/		return 0x82097448;
		  /* 82097448h */ case    7:  		/* bc 12, CR6_EQ, -376 */
		/* 82097448h case    7:*/		if ( regs.CR[6].eq ) { return 0x820972D0;  }
		/* 82097448h case    7:*/		return 0x8209744C;
		  /* 8209744Ch */ case    8:  		/* cmplwi CR6, R11, 7 */
		/* 8209744Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000007);
		/* 8209744Ch case    8:*/		return 0x82097450;
		  /* 82097450h */ case    9:  		/* bc 12, CR6_GT, 2328 */
		/* 82097450h case    9:*/		if ( regs.CR[6].gt ) { return 0x82097D68;  }
		/* 82097450h case    9:*/		return 0x82097454;
		  /* 82097454h */ case   10:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 82097454h case   10:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 82097454h case   10:*/		return 0x82097458;
		  /* 82097458h */ case   11:  		/* mtspr CTR, R11 */
		/* 82097458h case   11:*/		regs.CTR = regs.R11;
		/* 82097458h case   11:*/		return 0x8209745C;
		  /* 8209745Ch */ case   12:  		/* cmpwi CR6, R11, 0 */
		/* 8209745Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8209745Ch case   12:*/		return 0x82097460;
		  /* 82097460h */ case   13:  		/* bc 12, CR6_EQ, 492 */
		/* 82097460h case   13:*/		if ( regs.CR[6].eq ) { return 0x8209764C;  }
		/* 82097460h case   13:*/		return 0x82097464;
		  /* 82097464h */ case   14:  		/* bc 18, CR0_LT, 28 */
		/* 82097464h case   14:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x82097480;  }
		/* 82097464h case   14:*/		return 0x82097468;
		  /* 82097468h */ case   15:  		/* bc 18, CR0_LT, 56 */
		/* 82097468h case   15:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x820974A0;  }
		/* 82097468h case   15:*/		return 0x8209746C;
		  /* 8209746Ch */ case   16:  		/* bc 18, CR0_LT, 132 */
		/* 8209746Ch case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x820974F0;  }
		/* 8209746Ch case   16:*/		return 0x82097470;
		  /* 82097470h */ case   17:  		/* bc 18, CR0_LT, 204 */
		/* 82097470h case   17:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x8209753C;  }
		/* 82097470h case   17:*/		return 0x82097474;
		  /* 82097474h */ case   18:  		/* bc 18, CR0_LT, 208 */
		/* 82097474h case   18:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x82097544;  }
		/* 82097474h case   18:*/		return 0x82097478;
		  /* 82097478h */ case   19:  		/* bc 18, CR0_LT, 260 */
		/* 82097478h case   19:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x8209757C;  }
		/* 82097478h case   19:*/		return 0x8209747C;
		  /* 8209747Ch */ case   20:  		/* b 540 */
		/* 8209747Ch case   20:*/		return 0x82097698;
		/* 8209747Ch case   20:*/		return 0x82097480;
	}
	return 0x82097480;
} // Block from 8209742Ch-82097480h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82097480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097480);
		  /* 82097480h */ case    0:  		/* li R27, 0 */
		/* 82097480h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82097480h case    0:*/		return 0x82097484;
		  /* 82097484h */ case    1:  		/* li R25, -1 */
		/* 82097484h case    1:*/		cpu::op::li<0>(regs,&regs.R25,0xFFFFFFFF);
		/* 82097484h case    1:*/		return 0x82097488;
		  /* 82097488h */ case    2:  		/* mr R21, R27 */
		/* 82097488h case    2:*/		regs.R21 = regs.R27;
		/* 82097488h case    2:*/		return 0x8209748C;
		  /* 8209748Ch */ case    3:  		/* stw R27, <#[R1 + 104]> */
		/* 8209748Ch case    3:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000068) );
		/* 8209748Ch case    3:*/		return 0x82097490;
		  /* 82097490h */ case    4:  		/* stw R27, <#[R1 + 96]> */
		/* 82097490h case    4:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000060) );
		/* 82097490h case    4:*/		return 0x82097494;
		  /* 82097494h */ case    5:  		/* mr R16, R27 */
		/* 82097494h case    5:*/		regs.R16 = regs.R27;
		/* 82097494h case    5:*/		return 0x82097498;
		  /* 82097498h */ case    6:  		/* stw R27, <#[R1 + 92]> */
		/* 82097498h case    6:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x0000005C) );
		/* 82097498h case    6:*/		return 0x8209749C;
		  /* 8209749Ch */ case    7:  		/* b 2252 */
		/* 8209749Ch case    7:*/		return 0x82097D68;
		/* 8209749Ch case    7:*/		return 0x820974A0;
	}
	return 0x820974A0;
} // Block from 82097480h-820974A0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820974A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820974A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820974A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820974A0);
		  /* 820974A0h */ case    0:  		/* cmpwi CR6, R8, 32 */
		/* 820974A0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000020);
		/* 820974A0h case    0:*/		return 0x820974A4;
		  /* 820974A4h */ case    1:  		/* bc 12, CR6_EQ, 68 */
		/* 820974A4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820974E8;  }
		/* 820974A4h case    1:*/		return 0x820974A8;
		  /* 820974A8h */ case    2:  		/* cmpwi CR6, R8, 35 */
		/* 820974A8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000023);
		/* 820974A8h case    2:*/		return 0x820974AC;
		  /* 820974ACh */ case    3:  		/* bc 12, CR6_EQ, 52 */
		/* 820974ACh case    3:*/		if ( regs.CR[6].eq ) { return 0x820974E0;  }
		/* 820974ACh case    3:*/		return 0x820974B0;
		  /* 820974B0h */ case    4:  		/* cmpwi CR6, R8, 43 */
		/* 820974B0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000002B);
		/* 820974B0h case    4:*/		return 0x820974B4;
		  /* 820974B4h */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 820974B4h case    5:*/		if ( regs.CR[6].eq ) { return 0x820974D8;  }
		/* 820974B4h case    5:*/		return 0x820974B8;
		  /* 820974B8h */ case    6:  		/* cmpwi CR6, R8, 45 */
		/* 820974B8h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000002D);
		/* 820974B8h case    6:*/		return 0x820974BC;
		  /* 820974BCh */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 820974BCh case    7:*/		if ( regs.CR[6].eq ) { return 0x820974D0;  }
		/* 820974BCh case    7:*/		return 0x820974C0;
		  /* 820974C0h */ case    8:  		/* cmpwi CR6, R8, 48 */
		/* 820974C0h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000030);
		/* 820974C0h case    8:*/		return 0x820974C4;
		  /* 820974C4h */ case    9:  		/* bc 4, CR6_EQ, 2212 */
		/* 820974C4h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82097D68;  }
		/* 820974C4h case    9:*/		return 0x820974C8;
		  /* 820974C8h */ case   10:  		/* ori R27, R27, 8 */
		/* 820974C8h case   10:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x8);
		/* 820974C8h case   10:*/		return 0x820974CC;
		  /* 820974CCh */ case   11:  		/* b 2204 */
		/* 820974CCh case   11:*/		return 0x82097D68;
		/* 820974CCh case   11:*/		return 0x820974D0;
	}
	return 0x820974D0;
} // Block from 820974A0h-820974D0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820974D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820974D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820974D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820974D0);
		  /* 820974D0h */ case    0:  		/* ori R27, R27, 4 */
		/* 820974D0h case    0:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x4);
		/* 820974D0h case    0:*/		return 0x820974D4;
		  /* 820974D4h */ case    1:  		/* b 2196 */
		/* 820974D4h case    1:*/		return 0x82097D68;
		/* 820974D4h case    1:*/		return 0x820974D8;
	}
	return 0x820974D8;
} // Block from 820974D0h-820974D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820974D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820974D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820974D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820974D8);
		  /* 820974D8h */ case    0:  		/* ori R27, R27, 1 */
		/* 820974D8h case    0:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x1);
		/* 820974D8h case    0:*/		return 0x820974DC;
		  /* 820974DCh */ case    1:  		/* b 2188 */
		/* 820974DCh case    1:*/		return 0x82097D68;
		/* 820974DCh case    1:*/		return 0x820974E0;
	}
	return 0x820974E0;
} // Block from 820974D8h-820974E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820974E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820974E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820974E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820974E0);
		  /* 820974E0h */ case    0:  		/* ori R27, R27, 128 */
		/* 820974E0h case    0:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x80);
		/* 820974E0h case    0:*/		return 0x820974E4;
		  /* 820974E4h */ case    1:  		/* b 2180 */
		/* 820974E4h case    1:*/		return 0x82097D68;
		/* 820974E4h case    1:*/		return 0x820974E8;
	}
	return 0x820974E8;
} // Block from 820974E0h-820974E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820974E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820974E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820974E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820974E8);
		  /* 820974E8h */ case    0:  		/* ori R27, R27, 2 */
		/* 820974E8h case    0:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x2);
		/* 820974E8h case    0:*/		return 0x820974EC;
		  /* 820974ECh */ case    1:  		/* b 2172 */
		/* 820974ECh case    1:*/		return 0x82097D68;
		/* 820974ECh case    1:*/		return 0x820974F0;
	}
	return 0x820974F0;
} // Block from 820974E8h-820974F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820974F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820974F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820974F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820974F0);
		  /* 820974F0h */ case    0:  		/* cmpwi CR6, R8, 42 */
		/* 820974F0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000002A);
		/* 820974F0h case    0:*/		return 0x820974F4;
		  /* 820974F4h */ case    1:  		/* bc 4, CR6_EQ, 48 */
		/* 820974F4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82097524;  }
		/* 820974F4h case    1:*/		return 0x820974F8;
		  /* 820974F8h */ case    2:  		/* addi R11, R26, 7 */
		/* 820974F8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x7);
		/* 820974F8h case    2:*/		return 0x820974FC;
		  /* 820974FCh */ case    3:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 820974FCh case    3:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 820974FCh case    3:*/		return 0x82097500;
		  /* 82097500h */ case    4:  		/* addi R26, R11, 8 */
		/* 82097500h case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x8);
		/* 82097500h case    4:*/		return 0x82097504;
		  /* 82097504h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 82097504h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82097504h case    5:*/		return 0x82097508;
		  /* 82097508h */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 82097508h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82097508h case    6:*/		return 0x8209750C;
		  /* 8209750Ch */ case    7:  		/* stw R11, <#[R1 + 96]> */
		/* 8209750Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 8209750Ch case    7:*/		return 0x82097510;
		  /* 82097510h */ case    8:  		/* bc 4, CR6_LT, 2136 */
		/* 82097510h case    8:*/		if ( !regs.CR[6].lt ) { return 0x82097D68;  }
		/* 82097510h case    8:*/		return 0x82097514;
		  /* 82097514h */ case    9:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 82097514h case    9:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 82097514h case    9:*/		return 0x82097518;
		  /* 82097518h */ case   10:  		/* ori R27, R27, 4 */
		/* 82097518h case   10:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x4);
		/* 82097518h case   10:*/		return 0x8209751C;
		  /* 8209751Ch */ case   11:  		/* neg R11, R11 */
		/* 8209751Ch case   11:*/		cpu::op::neg<0>(regs,&regs.R11,regs.R11);
		/* 8209751Ch case   11:*/		return 0x82097520;
		  /* 82097520h */ case   12:  		/* b 20 */
		/* 82097520h case   12:*/		return 0x82097534;
		/* 82097520h case   12:*/		return 0x82097524;
	}
	return 0x82097524;
} // Block from 820974F0h-82097524h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82097524h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097524( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097524) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097524);
		  /* 82097524h */ case    0:  		/* lwz R11, <#[R1 + 96]> */
		/* 82097524h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82097524h case    0:*/		return 0x82097528;
		  /* 82097528h */ case    1:  		/* mulli R11, R11, 10 */
		/* 82097528h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xA);
		/* 82097528h case    1:*/		return 0x8209752C;
		  /* 8209752Ch */ case    2:  		/* add R11, R11, R8 */
		/* 8209752Ch case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8209752Ch case    2:*/		return 0x82097530;
		  /* 82097530h */ case    3:  		/* addi R11, R11, -48 */
		/* 82097530h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFD0);
		/* 82097530h case    3:*/		return 0x82097534;
	}
	return 0x82097534;
} // Block from 82097524h-82097534h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82097534h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097534( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097534) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097534);
		  /* 82097534h */ case    0:  		/* stw R11, <#[R1 + 96]> */
		/* 82097534h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82097534h case    0:*/		return 0x82097538;
		  /* 82097538h */ case    1:  		/* b 2096 */
		/* 82097538h case    1:*/		return 0x82097D68;
		/* 82097538h case    1:*/		return 0x8209753C;
	}
	return 0x8209753C;
} // Block from 82097534h-8209753Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209753Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209753C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209753C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209753C);
		  /* 8209753Ch */ case    0:  		/* li R25, 0 */
		/* 8209753Ch case    0:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 8209753Ch case    0:*/		return 0x82097540;
		  /* 82097540h */ case    1:  		/* b 2088 */
		/* 82097540h case    1:*/		return 0x82097D68;
		/* 82097540h case    1:*/		return 0x82097544;
	}
	return 0x82097544;
} // Block from 8209753Ch-82097544h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82097544h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097544( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097544) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097544);
		  /* 82097544h */ case    0:  		/* cmpwi CR6, R8, 42 */
		/* 82097544h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000002A);
		/* 82097544h case    0:*/		return 0x82097548;
		  /* 82097548h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 82097548h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209756C;  }
		/* 82097548h case    1:*/		return 0x8209754C;
		  /* 8209754Ch */ case    2:  		/* addi R11, R26, 7 */
		/* 8209754Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x7);
		/* 8209754Ch case    2:*/		return 0x82097550;
		  /* 82097550h */ case    3:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82097550h case    3:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82097550h case    3:*/		return 0x82097554;
		  /* 82097554h */ case    4:  		/* addi R26, R11, 8 */
		/* 82097554h case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x8);
		/* 82097554h case    4:*/		return 0x82097558;
		  /* 82097558h */ case    5:  		/* lwz R25, <#[R11 + 4]> */
		/* 82097558h case    5:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R11 + 0x00000004) );
		/* 82097558h case    5:*/		return 0x8209755C;
		  /* 8209755Ch */ case    6:  		/* cmpwi CR6, R25, 0 */
		/* 8209755Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 8209755Ch case    6:*/		return 0x82097560;
		  /* 82097560h */ case    7:  		/* bc 4, CR6_LT, 2056 */
		/* 82097560h case    7:*/		if ( !regs.CR[6].lt ) { return 0x82097D68;  }
		/* 82097560h case    7:*/		return 0x82097564;
		  /* 82097564h */ case    8:  		/* li R25, -1 */
		/* 82097564h case    8:*/		cpu::op::li<0>(regs,&regs.R25,0xFFFFFFFF);
		/* 82097564h case    8:*/		return 0x82097568;
		  /* 82097568h */ case    9:  		/* b 2048 */
		/* 82097568h case    9:*/		return 0x82097D68;
		/* 82097568h case    9:*/		return 0x8209756C;
	}
	return 0x8209756C;
} // Block from 82097544h-8209756Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209756Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209756C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209756C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209756C);
		  /* 8209756Ch */ case    0:  		/* mulli R11, R25, 10 */
		/* 8209756Ch case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R25,0xA);
		/* 8209756Ch case    0:*/		return 0x82097570;
		  /* 82097570h */ case    1:  		/* add R11, R11, R8 */
		/* 82097570h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 82097570h case    1:*/		return 0x82097574;
		  /* 82097574h */ case    2:  		/* addi R25, R11, -48 */
		/* 82097574h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R11,0xFFFFFFD0);
		/* 82097574h case    2:*/		return 0x82097578;
		  /* 82097578h */ case    3:  		/* b 2032 */
		/* 82097578h case    3:*/		return 0x82097D68;
		/* 82097578h case    3:*/		return 0x8209757C;
	}
	return 0x8209757C;
} // Block from 8209756Ch-8209757Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209757Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209757C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209757C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209757C);
		  /* 8209757Ch */ case    0:  		/* cmpwi CR6, R8, 73 */
		/* 8209757Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000049);
		/* 8209757Ch case    0:*/		return 0x82097580;
		  /* 82097580h */ case    1:  		/* bc 12, CR6_EQ, 76 */
		/* 82097580h case    1:*/		if ( regs.CR[6].eq ) { return 0x820975CC;  }
		/* 82097580h case    1:*/		return 0x82097584;
		  /* 82097584h */ case    2:  		/* cmpwi CR6, R8, 104 */
		/* 82097584h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000068);
		/* 82097584h case    2:*/		return 0x82097588;
		  /* 82097588h */ case    3:  		/* bc 12, CR6_EQ, 60 */
		/* 82097588h case    3:*/		if ( regs.CR[6].eq ) { return 0x820975C4;  }
		/* 82097588h case    3:*/		return 0x8209758C;
		  /* 8209758Ch */ case    4:  		/* cmpwi CR6, R8, 108 */
		/* 8209758Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000006C);
		/* 8209758Ch case    4:*/		return 0x82097590;
		  /* 82097590h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 82097590h case    5:*/		if ( regs.CR[6].eq ) { return 0x820975A4;  }
		/* 82097590h case    5:*/		return 0x82097594;
		  /* 82097594h */ case    6:  		/* cmpwi CR6, R8, 119 */
		/* 82097594h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000077);
		/* 82097594h case    6:*/		return 0x82097598;
		  /* 82097598h */ case    7:  		/* bc 4, CR6_EQ, 2000 */
		/* 82097598h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82097D68;  }
		/* 82097598h case    7:*/		return 0x8209759C;
		  /* 8209759Ch */ case    8:  		/* ori R27, R27, 2048 */
		/* 8209759Ch case    8:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x800);
		/* 8209759Ch case    8:*/		return 0x820975A0;
		  /* 820975A0h */ case    9:  		/* b 1992 */
		/* 820975A0h case    9:*/		return 0x82097D68;
		/* 820975A0h case    9:*/		return 0x820975A4;
	}
	return 0x820975A4;
} // Block from 8209757Ch-820975A4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820975A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820975A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820975A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820975A4);
		  /* 820975A4h */ case    0:  		/* lbz R11, <#[R19 + 1]> */
		/* 820975A4h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000001) );
		/* 820975A4h case    0:*/		return 0x820975A8;
		  /* 820975A8h */ case    1:  		/* cmplwi CR6, R11, 108 */
		/* 820975A8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000006C);
		/* 820975A8h case    1:*/		return 0x820975AC;
		  /* 820975ACh */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820975ACh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820975BC;  }
		/* 820975ACh case    2:*/		return 0x820975B0;
		  /* 820975B0h */ case    3:  		/* addi R19, R19, 1 */
		/* 820975B0h case    3:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x1);
		/* 820975B0h case    3:*/		return 0x820975B4;
		  /* 820975B4h */ case    4:  		/* ori R27, R27, 4096 */
		/* 820975B4h case    4:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x1000);
		/* 820975B4h case    4:*/		return 0x820975B8;
		  /* 820975B8h */ case    5:  		/* b 1968 */
		/* 820975B8h case    5:*/		return 0x82097D68;
		/* 820975B8h case    5:*/		return 0x820975BC;
	}
	return 0x820975BC;
} // Block from 820975A4h-820975BCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820975BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820975BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820975BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820975BC);
		  /* 820975BCh */ case    0:  		/* ori R27, R27, 16 */
		/* 820975BCh case    0:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x10);
		/* 820975BCh case    0:*/		return 0x820975C0;
		  /* 820975C0h */ case    1:  		/* b 1960 */
		/* 820975C0h case    1:*/		return 0x82097D68;
		/* 820975C0h case    1:*/		return 0x820975C4;
	}
	return 0x820975C4;
} // Block from 820975BCh-820975C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820975C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820975C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820975C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820975C4);
		  /* 820975C4h */ case    0:  		/* ori R27, R27, 32 */
		/* 820975C4h case    0:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x20);
		/* 820975C4h case    0:*/		return 0x820975C8;
		  /* 820975C8h */ case    1:  		/* b 1952 */
		/* 820975C8h case    1:*/		return 0x82097D68;
		/* 820975C8h case    1:*/		return 0x820975CC;
	}
	return 0x820975CC;
} // Block from 820975C4h-820975CCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820975CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820975CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820975CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820975CC);
		  /* 820975CCh */ case    0:  		/* lbz R11, <#[R19 + 1]> */
		/* 820975CCh case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000001) );
		/* 820975CCh case    0:*/		return 0x820975D0;
		  /* 820975D0h */ case    1:  		/* extsb R11, R11 */
		/* 820975D0h case    1:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820975D0h case    1:*/		return 0x820975D4;
		  /* 820975D4h */ case    2:  		/* cmpwi CR6, R11, 54 */
		/* 820975D4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000036);
		/* 820975D4h case    2:*/		return 0x820975D8;
		  /* 820975D8h */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 820975D8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820975F4;  }
		/* 820975D8h case    3:*/		return 0x820975DC;
		  /* 820975DCh */ case    4:  		/* lbz R10, <#[R19 + 2]> */
		/* 820975DCh case    4:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R19 + 0x00000002) );
		/* 820975DCh case    4:*/		return 0x820975E0;
		  /* 820975E0h */ case    5:  		/* cmplwi CR6, R10, 52 */
		/* 820975E0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000034);
		/* 820975E0h case    5:*/		return 0x820975E4;
		  /* 820975E4h */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 820975E4h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820975F4;  }
		/* 820975E4h case    6:*/		return 0x820975E8;
		  /* 820975E8h */ case    7:  		/* addi R19, R19, 2 */
		/* 820975E8h case    7:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x2);
		/* 820975E8h case    7:*/		return 0x820975EC;
		  /* 820975ECh */ case    8:  		/* ori R27, R27, 32768 */
		/* 820975ECh case    8:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x8000);
		/* 820975ECh case    8:*/		return 0x820975F0;
		  /* 820975F0h */ case    9:  		/* b 1912 */
		/* 820975F0h case    9:*/		return 0x82097D68;
		/* 820975F0h case    9:*/		return 0x820975F4;
	}
	return 0x820975F4;
} // Block from 820975CCh-820975F4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820975F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820975F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820975F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820975F4);
		  /* 820975F4h */ case    0:  		/* cmpwi CR6, R11, 51 */
		/* 820975F4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000033);
		/* 820975F4h case    0:*/		return 0x820975F8;
		  /* 820975F8h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 820975F8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82097614;  }
		/* 820975F8h case    1:*/		return 0x820975FC;
		  /* 820975FCh */ case    2:  		/* lbz R10, <#[R19 + 2]> */
		/* 820975FCh case    2:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R19 + 0x00000002) );
		/* 820975FCh case    2:*/		return 0x82097600;
		  /* 82097600h */ case    3:  		/* cmplwi CR6, R10, 50 */
		/* 82097600h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000032);
		/* 82097600h case    3:*/		return 0x82097604;
		  /* 82097604h */ case    4:  		/* bc 4, CR6_EQ, 16 */
		/* 82097604h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82097614;  }
		/* 82097604h case    4:*/		return 0x82097608;
		  /* 82097608h */ case    5:  		/* addi R19, R19, 2 */
		/* 82097608h case    5:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x2);
		/* 82097608h case    5:*/		return 0x8209760C;
		  /* 8209760Ch */ case    6:  		/* rlwinm R27, R27, 0, 17, 15 */
		/* 8209760Ch case    6:*/		cpu::op::rlwinm<0,0,17,15>(regs,&regs.R27,regs.R27);
		/* 8209760Ch case    6:*/		return 0x82097610;
		  /* 82097610h */ case    7:  		/* b 1880 */
		/* 82097610h case    7:*/		return 0x82097D68;
		/* 82097610h case    7:*/		return 0x82097614;
	}
	return 0x82097614;
} // Block from 820975F4h-82097614h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82097614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097614);
		  /* 82097614h */ case    0:  		/* cmpwi CR6, R11, 100 */
		/* 82097614h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000064);
		/* 82097614h case    0:*/		return 0x82097618;
		  /* 82097618h */ case    1:  		/* bc 12, CR6_EQ, 1872 */
		/* 82097618h case    1:*/		if ( regs.CR[6].eq ) { return 0x82097D68;  }
		/* 82097618h case    1:*/		return 0x8209761C;
		  /* 8209761Ch */ case    2:  		/* cmpwi CR6, R11, 105 */
		/* 8209761Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000069);
		/* 8209761Ch case    2:*/		return 0x82097620;
		  /* 82097620h */ case    3:  		/* bc 12, CR6_EQ, 1864 */
		/* 82097620h case    3:*/		if ( regs.CR[6].eq ) { return 0x82097D68;  }
		/* 82097620h case    3:*/		return 0x82097624;
		  /* 82097624h */ case    4:  		/* cmpwi CR6, R11, 111 */
		/* 82097624h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000006F);
		/* 82097624h case    4:*/		return 0x82097628;
		  /* 82097628h */ case    5:  		/* bc 12, CR6_EQ, 1856 */
		/* 82097628h case    5:*/		if ( regs.CR[6].eq ) { return 0x82097D68;  }
		/* 82097628h case    5:*/		return 0x8209762C;
		  /* 8209762Ch */ case    6:  		/* cmpwi CR6, R11, 117 */
		/* 8209762Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000075);
		/* 8209762Ch case    6:*/		return 0x82097630;
		  /* 82097630h */ case    7:  		/* bc 12, CR6_EQ, 1848 */
		/* 82097630h case    7:*/		if ( regs.CR[6].eq ) { return 0x82097D68;  }
		/* 82097630h case    7:*/		return 0x82097634;
		  /* 82097634h */ case    8:  		/* cmpwi CR6, R11, 120 */
		/* 82097634h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000078);
		/* 82097634h case    8:*/		return 0x82097638;
		  /* 82097638h */ case    9:  		/* bc 12, CR6_EQ, 1840 */
		/* 82097638h case    9:*/		if ( regs.CR[6].eq ) { return 0x82097D68;  }
		/* 82097638h case    9:*/		return 0x8209763C;
		  /* 8209763Ch */ case   10:  		/* cmpwi CR6, R11, 88 */
		/* 8209763Ch case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000058);
		/* 8209763Ch case   10:*/		return 0x82097640;
		  /* 82097640h */ case   11:  		/* bc 12, CR6_EQ, 1832 */
		/* 82097640h case   11:*/		if ( regs.CR[6].eq ) { return 0x82097D68;  }
		/* 82097640h case   11:*/		return 0x82097644;
		  /* 82097644h */ case   12:  		/* li R11, 0 */
		/* 82097644h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82097644h case   12:*/		return 0x82097648;
		  /* 82097648h */ case   13:  		/* stw R11, <#[R1 + 100]> */
		/* 82097648h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82097648h case   13:*/		return 0x8209764C;
	}
	return 0x8209764C;
} // Block from 82097614h-8209764Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209764Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209764C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209764C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209764C);
		  /* 8209764Ch */ case    0:  		/* mr R4, R23 */
		/* 8209764Ch case    0:*/		regs.R4 = regs.R23;
		/* 8209764Ch case    0:*/		return 0x82097650;
		  /* 82097650h */ case    1:  		/* rlwinm R3, R29, 0, 24, 31 */
		/* 82097650h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R29);
		/* 82097650h case    1:*/		return 0x82097654;
		  /* 82097654h */ case    2:  		/* li R16, 0 */
		/* 82097654h case    2:*/		cpu::op::li<0>(regs,&regs.R16,0x0);
		/* 82097654h case    2:*/		return 0x82097658;
		  /* 82097658h */ case    3:  		/* bl 14368 */
		/* 82097658h case    3:*/		regs.LR = 0x8209765C; return 0x8209AE78;
		/* 82097658h case    3:*/		return 0x8209765C;
		  /* 8209765Ch */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 8209765Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209765Ch case    4:*/		return 0x82097660;
		  /* 82097660h */ case    5:  		/* bc 12, CR0_EQ, 32 */
		/* 82097660h case    5:*/		if ( regs.CR[0].eq ) { return 0x82097680;  }
		/* 82097660h case    5:*/		return 0x82097664;
		  /* 82097664h */ case    6:  		/* addi R5, R1, 80 */
		/* 82097664h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82097664h case    6:*/		return 0x82097668;
		  /* 82097668h */ case    7:  		/* mr R4, R18 */
		/* 82097668h case    7:*/		regs.R4 = regs.R18;
		/* 82097668h case    7:*/		return 0x8209766C;
		  /* 8209766Ch */ case    8:  		/* mr R3, R29 */
		/* 8209766Ch case    8:*/		regs.R3 = regs.R29;
		/* 8209766Ch case    8:*/		return 0x82097670;
		  /* 82097670h */ case    9:  		/* bl -1352 */
		/* 82097670h case    9:*/		regs.LR = 0x82097674; return 0x82097128;
		/* 82097670h case    9:*/		return 0x82097674;
		  /* 82097674h */ case   10:  		/* lbzu R29, <#[R19 + 1]> */
		/* 82097674h case   10:*/		cpu::mem::load8z( regs, &regs.R29, (uint32)(regs.R19 + 0x00000001) );
		regs.R19 = (uint32)(regs.R19 + 0x00000001);
		/* 82097674h case   10:*/		return 0x82097678;
		  /* 82097678h */ case   11:  		/* cmplwi CR0, R29, 0 */
		/* 82097678h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R29,0x00000000);
		/* 82097678h case   11:*/		return 0x8209767C;
		  /* 8209767Ch */ case   12:  		/* bc 12, CR0_EQ, -940 */
		/* 8209767Ch case   12:*/		if ( regs.CR[0].eq ) { return 0x820972D0;  }
		/* 8209767Ch case   12:*/		return 0x82097680;
	}
	return 0x82097680;
} // Block from 8209764Ch-82097680h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82097680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097680);
		  /* 82097680h */ case    0:  		/* addi R5, R1, 80 */
		/* 82097680h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82097680h case    0:*/		return 0x82097684;
		  /* 82097684h */ case    1:  		/* mr R4, R18 */
		/* 82097684h case    1:*/		regs.R4 = regs.R18;
		/* 82097684h case    1:*/		return 0x82097688;
		  /* 82097688h */ case    2:  		/* mr R3, R29 */
		/* 82097688h case    2:*/		regs.R3 = regs.R29;
		/* 82097688h case    2:*/		return 0x8209768C;
		  /* 8209768Ch */ case    3:  		/* bl -1380 */
		/* 8209768Ch case    3:*/		regs.LR = 0x82097690; return 0x82097128;
		/* 8209768Ch case    3:*/		return 0x82097690;
		  /* 82097690h */ case    4:  		/* lwz R24, <#[R1 + 80]> */
		/* 82097690h case    4:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000050) );
		/* 82097690h case    4:*/		return 0x82097694;
		  /* 82097694h */ case    5:  		/* b 1748 */
		/* 82097694h case    5:*/		return 0x82097D68;
		/* 82097694h case    5:*/		return 0x82097698;
	}
	return 0x82097698;
} // Block from 82097680h-82097698h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82097698h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097698);
		  /* 82097698h */ case    0:  		/* addi R11, R8, -65 */
		/* 82097698h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0xFFFFFFBF);
		/* 82097698h case    0:*/		return 0x8209769C;
		  /* 8209769Ch */ case    1:  		/* cmplwi CR6, R11, 55 */
		/* 8209769Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000037);
		/* 8209769Ch case    1:*/		return 0x820976A0;
		  /* 820976A0h */ case    2:  		/* bc 12, CR6_GT, 1272 */
		/* 820976A0h case    2:*/		if ( regs.CR[6].gt ) { return 0x82097B98;  }
		/* 820976A0h case    2:*/		return 0x820976A4;
		  /* 820976A4h */ case    3:  		/* lis R12, -32255 */
		/* 820976A4h case    3:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8201);
		/* 820976A4h case    3:*/		return 0x820976A8;
		  /* 820976A8h */ case    4:  		/* rlwinm R0, R11, 1, 0, 30 */
		/* 820976A8h case    4:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R0,regs.R11);
		/* 820976A8h case    4:*/		return 0x820976AC;
		  /* 820976ACh */ case    5:  		/* addi R12, R12, -21496 */
		/* 820976ACh case    5:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFAC08);
		/* 820976ACh case    5:*/		return 0x820976B0;
		  /* 820976B0h */ case    6:  		/* lhzx R0, <#[R12 + R0]> */
		/* 820976B0h case    6:*/		cpu::mem::load16z( regs, &regs.R0, (uint32)(regs.R12 + regs.R0 + 0x00000000) );
		/* 820976B0h case    6:*/		return 0x820976B4;
		  /* 820976B4h */ case    7:  		/* lis R12, -32247 */
		/* 820976B4h case    7:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8209);
		/* 820976B4h case    7:*/		return 0x820976B8;
		  /* 820976B8h */ case    8:  		/* addi R12, R12, 30412 */
		/* 820976B8h case    8:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x76CC);
		/* 820976B8h case    8:*/		return 0x820976BC;
		  /* 820976BCh */ case    9:  		/* ori R0, R0, 0 */
		/* 820976BCh case    9:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820976BCh case    9:*/		return 0x820976C0;
		  /* 820976C0h */ case   10:  		/* add R12, R12, R0 */
		/* 820976C0h case   10:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 820976C0h case   10:*/		return 0x820976C4;
		  /* 820976C4h */ case   11:  		/* mtspr CTR, R12 */
		/* 820976C4h case   11:*/		regs.CTR = regs.R12;
		/* 820976C4h case   11:*/		return 0x820976C8;
		  /* 820976C8h */ case   12:  		/* bcctr 20, CR0_LT */
		/* 820976C8h case   12:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820976C8h case   12:*/		return 0x820976CC;
		  /* 820976CCh */ case   13:  		/* andi. R11, R27, 2096 */
		/* 820976CCh case   13:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R27,0x830);
		/* 820976CCh case   13:*/		return 0x820976D0;
		  /* 820976D0h */ case   14:  		/* cmpwi CR0, R11, 0 */
		/* 820976D0h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 820976D0h case   14:*/		return 0x820976D4;
		  /* 820976D4h */ case   15:  		/* bc 4, CR0_EQ, 8 */
		/* 820976D4h case   15:*/		if ( !regs.CR[0].eq ) { return 0x820976DC;  }
		/* 820976D4h case   15:*/		return 0x820976D8;
		  /* 820976D8h */ case   16:  		/* ori R27, R27, 2048 */
		/* 820976D8h case   16:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x800);
		/* 820976D8h case   16:*/		return 0x820976DC;
	}
	return 0x820976DC;
} // Block from 82097698h-820976DCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 820976DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820976DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820976DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820976DC);
		  /* 820976DCh */ case    0:  		/* andi. R11, R27, 2064 */
		/* 820976DCh case    0:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R27,0x810);
		/* 820976DCh case    0:*/		return 0x820976E0;
		  /* 820976E0h */ case    1:  		/* cmpwi CR0, R11, 0 */
		/* 820976E0h case    1:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 820976E0h case    1:*/		return 0x820976E4;
		  /* 820976E4h */ case    2:  		/* addi R11, R26, 7 */
		/* 820976E4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x7);
		/* 820976E4h case    2:*/		return 0x820976E8;
		  /* 820976E8h */ case    3:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 820976E8h case    3:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 820976E8h case    3:*/		return 0x820976EC;
		  /* 820976ECh */ case    4:  		/* addi R26, R11, 8 */
		/* 820976ECh case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x8);
		/* 820976ECh case    4:*/		return 0x820976F0;
		  /* 820976F0h */ case    5:  		/* bc 12, CR0_EQ, 44 */
		/* 820976F0h case    5:*/		if ( regs.CR[0].eq ) { return 0x8209771C;  }
		/* 820976F0h case    5:*/		return 0x820976F4;
		  /* 820976F4h */ case    6:  		/* li R5, 512 */
		/* 820976F4h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x200);
		/* 820976F4h case    6:*/		return 0x820976F8;
		  /* 820976F8h */ case    7:  		/* lhz R6, <#[R11 + 6]> */
		/* 820976F8h case    7:*/		cpu::mem::load16z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000006) );
		/* 820976F8h case    7:*/		return 0x820976FC;
		  /* 820976FCh */ case    8:  		/* addi R4, R1, 144 */
		/* 820976FCh case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x90);
		/* 820976FCh case    8:*/		return 0x82097700;
		  /* 82097700h */ case    9:  		/* addi R3, R1, 84 */
		/* 82097700h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x54);
		/* 82097700h case    9:*/		return 0x82097704;
		  /* 82097704h */ case   10:  		/* bl 14796 */
		/* 82097704h case   10:*/		regs.LR = 0x82097708; return 0x8209B0D0;
		/* 82097704h case   10:*/		return 0x82097708;
		  /* 82097708h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 82097708h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82097708h case   11:*/		return 0x8209770C;
		  /* 8209770Ch */ case   12:  		/* bc 12, CR0_EQ, 32 */
		/* 8209770Ch case   12:*/		if ( regs.CR[0].eq ) { return 0x8209772C;  }
		/* 8209770Ch case   12:*/		return 0x82097710;
		  /* 82097710h */ case   13:  		/* li R11, 1 */
		/* 82097710h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82097710h case   13:*/		return 0x82097714;
		  /* 82097714h */ case   14:  		/* stw R11, <#[R1 + 104]> */
		/* 82097714h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 82097714h case   14:*/		return 0x82097718;
		  /* 82097718h */ case   15:  		/* b 20 */
		/* 82097718h case   15:*/		return 0x8209772C;
		/* 82097718h case   15:*/		return 0x8209771C;
	}
	return 0x8209771C;
} // Block from 820976DCh-8209771Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8209771Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209771C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209771C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209771C);
		  /* 8209771Ch */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 8209771Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8209771Ch case    0:*/		return 0x82097720;
		  /* 82097720h */ case    1:  		/* li R10, 1 */
		/* 82097720h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82097720h case    1:*/		return 0x82097724;
		  /* 82097724h */ case    2:  		/* stw R10, <#[R1 + 84]> */
		/* 82097724h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82097724h case    2:*/		return 0x82097728;
		  /* 82097728h */ case    3:  		/* stb R11, <#[R1 + 144]> */
		/* 82097728h case    3:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 82097728h case    3:*/		return 0x8209772C;
	}
	return 0x8209772C;
} // Block from 8209771Ch-8209772Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209772Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209772C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209772C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209772C);
		  /* 8209772Ch */ case    0:  		/* lwz R7, <#[R1 + 84]> */
		/* 8209772Ch case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000054) );
		/* 8209772Ch case    0:*/		return 0x82097730;
		  /* 82097730h */ case    1:  		/* addi R28, R1, 144 */
		/* 82097730h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0x90);
		/* 82097730h case    1:*/		return 0x82097734;
		  /* 82097734h */ case    2:  		/* b 1124 */
		/* 82097734h case    2:*/		return 0x82097B98;
		/* 82097734h case    2:*/		return 0x82097738;
		  /* 82097738h */ case    3:  		/* addi R11, R26, 7 */
		/* 82097738h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x7);
		/* 82097738h case    3:*/		return 0x8209773C;
		  /* 8209773Ch */ case    4:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 8209773Ch case    4:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 8209773Ch case    4:*/		return 0x82097740;
		  /* 82097740h */ case    5:  		/* addi R26, R11, 8 */
		/* 82097740h case    5:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x8);
		/* 82097740h case    5:*/		return 0x82097744;
		  /* 82097744h */ case    6:  		/* lwz R11, <#[R11 + 4]> */
		/* 82097744h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82097744h case    6:*/		return 0x82097748;
		  /* 82097748h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82097748h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82097748h case    7:*/		return 0x8209774C;
		  /* 8209774Ch */ case    8:  		/* bc 12, CR6_EQ, 60 */
		/* 8209774Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x82097788;  }
		/* 8209774Ch case    8:*/		return 0x82097750;
		  /* 82097750h */ case    9:  		/* lwz R10, <#[R11 + 4]> */
		/* 82097750h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82097750h case    9:*/		return 0x82097754;
		  /* 82097754h */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 82097754h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82097754h case   10:*/		return 0x82097758;
		  /* 82097758h */ case   11:  		/* bc 12, CR6_EQ, 48 */
		/* 82097758h case   11:*/		if ( regs.CR[6].eq ) { return 0x82097788;  }
		/* 82097758h case   11:*/		return 0x8209775C;
		  /* 8209775Ch */ case   12:  		/* rlwinm. R9, R27, 0, 20, 20 */
		/* 8209775Ch case   12:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R9,regs.R27);
		/* 8209775Ch case   12:*/		return 0x82097760;
		  /* 82097760h */ case   13:  		/* mr R28, R10 */
		/* 82097760h case   13:*/		regs.R28 = regs.R10;
		/* 82097760h case   13:*/		return 0x82097764;
		  /* 82097764h */ case   14:  		/* bc 12, CR0_EQ, 24 */
		/* 82097764h case   14:*/		if ( regs.CR[0].eq ) { return 0x8209777C;  }
		/* 82097764h case   14:*/		return 0x82097768;
		  /* 82097768h */ case   15:  		/* lha R11, <#[R11]> */
		/* 82097768h case   15:*/		cpu::mem::load16a( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82097768h case   15:*/		return 0x8209776C;
		  /* 8209776Ch */ case   16:  		/* li R16, 1 */
		/* 8209776Ch case   16:*/		cpu::op::li<0>(regs,&regs.R16,0x1);
		/* 8209776Ch case   16:*/		return 0x82097770;
		  /* 82097770h */ case   17:  		/* srawi R11, R11, 1 */
		/* 82097770h case   17:*/		cpu::op::srawi<0,1>(regs,&regs.R11,regs.R11);
		/* 82097770h case   17:*/		return 0x82097774;
		  /* 82097774h */ case   18:  		/* addze R7, R11 */
		/* 82097774h case   18:*/		cpu::op::addze<0>(regs,&regs.R7,regs.R11);
		/* 82097774h case   18:*/		return 0x82097778;
		  /* 82097778h */ case   19:  		/* b 1052 */
		/* 82097778h case   19:*/		return 0x82097B94;
		/* 82097778h case   19:*/		return 0x8209777C;
	}
	return 0x8209777C;
} // Block from 8209772Ch-8209777Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 8209777Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209777C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209777C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209777C);
		  /* 8209777Ch */ case    0:  		/* lha R7, <#[R11]> */
		/* 8209777Ch case    0:*/		cpu::mem::load16a( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8209777Ch case    0:*/		return 0x82097780;
		  /* 82097780h */ case    1:  		/* li R16, 0 */
		/* 82097780h case    1:*/		cpu::op::li<0>(regs,&regs.R16,0x0);
		/* 82097780h case    1:*/		return 0x82097784;
		  /* 82097784h */ case    2:  		/* b 1040 */
		/* 82097784h case    2:*/		return 0x82097B94;
		/* 82097784h case    2:*/		return 0x82097788;
	}
	return 0x82097788;
} // Block from 8209777Ch-82097788h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82097788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097788);
		  /* 82097788h */ case    0:  		/* lwz R28, <#[R20 - 21808]> */
		/* 82097788h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R20 + 0xFFFFAAD0) );
		/* 82097788h case    0:*/		return 0x8209778C;
		  /* 8209778Ch */ case    1:  		/* mr R11, R28 */
		/* 8209778Ch case    1:*/		regs.R11 = regs.R28;
		/* 8209778Ch case    1:*/		return 0x82097790;
		  /* 82097790h */ case    2:  		/* mr R10, R28 */
		/* 82097790h case    2:*/		regs.R10 = regs.R28;
		/* 82097790h case    2:*/		return 0x82097794;
		  /* 82097794h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 82097794h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82097794h case    3:*/		return 0x82097798;
		  /* 82097798h */ case    4:  		/* addi R11, R11, 1 */
		/* 82097798h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82097798h case    4:*/		return 0x8209779C;
		  /* 8209779Ch */ case    5:  		/* cmplwi CR6, R9, 0 */
		/* 8209779Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8209779Ch case    5:*/		return 0x820977A0;
		  /* 820977A0h */ case    6:  		/* bc 4, CR6_EQ, -12 */
		/* 820977A0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82097794;  }
		/* 820977A0h case    6:*/		return 0x820977A4;
		  /* 820977A4h */ case    7:  		/* subf R11, R10, R11 */
		/* 820977A4h case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820977A4h case    7:*/		return 0x820977A8;
		  /* 820977A8h */ case    8:  		/* addi R11, R11, -1 */
		/* 820977A8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820977A8h case    8:*/		return 0x820977AC;
		  /* 820977ACh */ case    9:  		/* rlwinm R7, R11, 0, 0, 31 */
		/* 820977ACh case    9:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R7,regs.R11);
		/* 820977ACh case    9:*/		return 0x820977B0;
		  /* 820977B0h */ case   10:  		/* b 996 */
		/* 820977B0h case   10:*/		return 0x82097B94;
		/* 820977B0h case   10:*/		return 0x820977B4;
		  /* 820977B4h */ case   11:  		/* andi. R11, R27, 2096 */
		/* 820977B4h case   11:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R27,0x830);
		/* 820977B4h case   11:*/		return 0x820977B8;
		  /* 820977B8h */ case   12:  		/* cmpwi CR0, R11, 0 */
		/* 820977B8h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 820977B8h case   12:*/		return 0x820977BC;
		  /* 820977BCh */ case   13:  		/* bc 4, CR0_EQ, 8 */
		/* 820977BCh case   13:*/		if ( !regs.CR[0].eq ) { return 0x820977C4;  }
		/* 820977BCh case   13:*/		return 0x820977C0;
		  /* 820977C0h */ case   14:  		/* ori R27, R27, 2048 */
		/* 820977C0h case   14:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x800);
		/* 820977C0h case   14:*/		return 0x820977C4;
	}
	return 0x820977C4;
} // Block from 82097788h-820977C4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820977C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820977C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820977C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820977C4);
		  /* 820977C4h */ case    0:  		/* cmpwi CR6, R25, -1 */
		/* 820977C4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R25,0xFFFFFFFF);
		/* 820977C4h case    0:*/		return 0x820977C8;
		  /* 820977C8h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820977C8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820977D8;  }
		/* 820977C8h case    1:*/		return 0x820977CC;
		  /* 820977CCh */ case    2:  		/* lis R10, 32767 */
		/* 820977CCh case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0x7FFF);
		/* 820977CCh case    2:*/		return 0x820977D0;
		  /* 820977D0h */ case    3:  		/* ori R10, R10, 65535 */
		/* 820977D0h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0xFFFF);
		/* 820977D0h case    3:*/		return 0x820977D4;
		  /* 820977D4h */ case    4:  		/* b 8 */
		/* 820977D4h case    4:*/		return 0x820977DC;
		/* 820977D4h case    4:*/		return 0x820977D8;
	}
	return 0x820977D8;
} // Block from 820977C4h-820977D8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820977D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820977D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820977D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820977D8);
		  /* 820977D8h */ case    0:  		/* mr R10, R25 */
		/* 820977D8h case    0:*/		regs.R10 = regs.R25;
		/* 820977D8h case    0:*/		return 0x820977DC;
	}
	return 0x820977DC;
} // Block from 820977D8h-820977DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820977DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820977DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820977DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820977DC);
		  /* 820977DCh */ case    0:  		/* addi R11, R26, 7 */
		/* 820977DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x7);
		/* 820977DCh case    0:*/		return 0x820977E0;
		  /* 820977E0h */ case    1:  		/* andi. R9, R27, 2064 */
		/* 820977E0h case    1:*/		cpu::op::andi<1>(regs,&regs.R9,regs.R27,0x810);
		/* 820977E0h case    1:*/		return 0x820977E4;
		  /* 820977E4h */ case    2:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 820977E4h case    2:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 820977E4h case    2:*/		return 0x820977E8;
		  /* 820977E8h */ case    3:  		/* cmpwi CR0, R9, 0 */
		/* 820977E8h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820977E8h case    3:*/		return 0x820977EC;
		  /* 820977ECh */ case    4:  		/* addi R26, R11, 8 */
		/* 820977ECh case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x8);
		/* 820977ECh case    4:*/		return 0x820977F0;
		  /* 820977F0h */ case    5:  		/* lwz R28, <#[R11 + 4]> */
		/* 820977F0h case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000004) );
		/* 820977F0h case    5:*/		return 0x820977F4;
		  /* 820977F4h */ case    6:  		/* cmplwi CR6, R28, 0 */
		/* 820977F4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820977F4h case    6:*/		return 0x820977F8;
		  /* 820977F8h */ case    7:  		/* bc 12, CR0_EQ, 64 */
		/* 820977F8h case    7:*/		if ( regs.CR[0].eq ) { return 0x82097838;  }
		/* 820977F8h case    7:*/		return 0x820977FC;
		  /* 820977FCh */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 820977FCh case    8:*/		if ( !regs.CR[6].eq ) { return 0x82097804;  }
		/* 820977FCh case    8:*/		return 0x82097800;
		  /* 82097800h */ case    9:  		/* lwz R28, <#[R15 - 21804]> */
		/* 82097800h case    9:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R15 + 0xFFFFAAD4) );
		/* 82097800h case    9:*/		return 0x82097804;
	}
	return 0x82097804;
} // Block from 820977DCh-82097804h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82097804h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097804( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097804) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097804);
		  /* 82097804h */ case    0:  		/* li R16, 1 */
		/* 82097804h case    0:*/		cpu::op::li<0>(regs,&regs.R16,0x1);
		/* 82097804h case    0:*/		return 0x82097808;
		  /* 82097808h */ case    1:  		/* mr R11, R28 */
		/* 82097808h case    1:*/		regs.R11 = regs.R28;
		/* 82097808h case    1:*/		return 0x8209780C;
		  /* 8209780Ch */ case    2:  		/* b 24 */
		/* 8209780Ch case    2:*/		return 0x82097824;
		/* 8209780Ch case    2:*/		return 0x82097810;
		  /* 82097810h */ case    3:  		/* lhz R9, <#[R11]> */
		/* 82097810h case    3:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82097810h case    3:*/		return 0x82097814;
		  /* 82097814h */ case    4:  		/* addi R10, R10, -1 */
		/* 82097814h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82097814h case    4:*/		return 0x82097818;
		  /* 82097818h */ case    5:  		/* cmplwi CR0, R9, 0 */
		/* 82097818h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 82097818h case    5:*/		return 0x8209781C;
		  /* 8209781Ch */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 8209781Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x8209782C;  }
		/* 8209781Ch case    6:*/		return 0x82097820;
		  /* 82097820h */ case    7:  		/* addi R11, R11, 2 */
		/* 82097820h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82097820h case    7:*/		return 0x82097824;
	}
	return 0x82097824;
} // Block from 82097804h-82097824h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82097824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097824);
		  /* 82097824h */ case    0:  		/* cmpwi CR6, R10, 0 */
		/* 82097824h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82097824h case    0:*/		return 0x82097828;
		  /* 82097828h */ case    1:  		/* bc 4, CR6_EQ, -24 */
		/* 82097828h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82097810;  }
		/* 82097828h case    1:*/		return 0x8209782C;
	}
	return 0x8209782C;
} // Block from 82097824h-8209782Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209782Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209782C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209782C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209782C);
		  /* 8209782Ch */ case    0:  		/* subf R11, R28, R11 */
		/* 8209782Ch case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 8209782Ch case    0:*/		return 0x82097830;
		  /* 82097830h */ case    1:  		/* srawi R7, R11, 1 */
		/* 82097830h case    1:*/		cpu::op::srawi<0,1>(regs,&regs.R7,regs.R11);
		/* 82097830h case    1:*/		return 0x82097834;
		  /* 82097834h */ case    2:  		/* b 864 */
		/* 82097834h case    2:*/		return 0x82097B94;
		/* 82097834h case    2:*/		return 0x82097838;
	}
	return 0x82097838;
} // Block from 8209782Ch-82097838h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82097838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097838);
		  /* 82097838h */ case    0:  		/* bc 4, CR6_EQ, 8 */
		/* 82097838h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82097840;  }
		/* 82097838h case    0:*/		return 0x8209783C;
		  /* 8209783Ch */ case    1:  		/* lwz R28, <#[R20 - 21808]> */
		/* 8209783Ch case    1:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R20 + 0xFFFFAAD0) );
		/* 8209783Ch case    1:*/		return 0x82097840;
	}
	return 0x82097840;
} // Block from 82097838h-82097840h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82097840h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097840);
		  /* 82097840h */ case    0:  		/* mr R11, R28 */
		/* 82097840h case    0:*/		regs.R11 = regs.R28;
		/* 82097840h case    0:*/		return 0x82097844;
		  /* 82097844h */ case    1:  		/* b 24 */
		/* 82097844h case    1:*/		return 0x8209785C;
		/* 82097844h case    1:*/		return 0x82097848;
		  /* 82097848h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 82097848h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82097848h case    2:*/		return 0x8209784C;
		  /* 8209784Ch */ case    3:  		/* addi R10, R10, -1 */
		/* 8209784Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8209784Ch case    3:*/		return 0x82097850;
		  /* 82097850h */ case    4:  		/* cmplwi CR0, R9, 0 */
		/* 82097850h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 82097850h case    4:*/		return 0x82097854;
		  /* 82097854h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 82097854h case    5:*/		if ( regs.CR[0].eq ) { return 0x82097864;  }
		/* 82097854h case    5:*/		return 0x82097858;
		  /* 82097858h */ case    6:  		/* addi R11, R11, 1 */
		/* 82097858h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82097858h case    6:*/		return 0x8209785C;
	}
	return 0x8209785C;
} // Block from 82097840h-8209785Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209785Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209785C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209785C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209785C);
		  /* 8209785Ch */ case    0:  		/* cmpwi CR6, R10, 0 */
		/* 8209785Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8209785Ch case    0:*/		return 0x82097860;
		  /* 82097860h */ case    1:  		/* bc 4, CR6_EQ, -24 */
		/* 82097860h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82097848;  }
		/* 82097860h case    1:*/		return 0x82097864;
	}
	return 0x82097864;
} // Block from 8209785Ch-82097864h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82097864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097864);
		  /* 82097864h */ case    0:  		/* subf R7, R28, R11 */
		/* 82097864h case    0:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R28,regs.R11);
		/* 82097864h case    0:*/		return 0x82097868;
		  /* 82097868h */ case    1:  		/* b 812 */
		/* 82097868h case    1:*/		return 0x82097B94;
		/* 82097868h case    1:*/		return 0x8209786C;
		  /* 8209786Ch */ case    2:  		/* addi R11, R26, 7 */
		/* 8209786Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x7);
		/* 8209786Ch case    2:*/		return 0x82097870;
		  /* 82097870h */ case    3:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82097870h case    3:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82097870h case    3:*/		return 0x82097874;
		  /* 82097874h */ case    4:  		/* addi R26, R11, 8 */
		/* 82097874h case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x8);
		/* 82097874h case    4:*/		return 0x82097878;
		  /* 82097878h */ case    5:  		/* lwz R31, <#[R11 + 4]> */
		/* 82097878h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 82097878h case    5:*/		return 0x8209787C;
		  /* 8209787Ch */ case    6:  		/* bl 13780 */
		/* 8209787Ch case    6:*/		regs.LR = 0x82097880; return 0x8209AE50;
		/* 8209787Ch case    6:*/		return 0x82097880;
		  /* 82097880h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 82097880h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82097880h case    7:*/		return 0x82097884;
		  /* 82097884h */ case    8:  		/* bc 12, CR0_EQ, -1460 */
		/* 82097884h case    8:*/		if ( regs.CR[0].eq ) { return 0x820972D0;  }
		/* 82097884h case    8:*/		return 0x82097888;
		  /* 82097888h */ case    9:  		/* rlwinm. R11, R27, 0, 26, 26 */
		/* 82097888h case    9:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R27);
		/* 82097888h case    9:*/		return 0x8209788C;
		  /* 8209788Ch */ case   10:  		/* bc 12, CR0_EQ, 12 */
		/* 8209788Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x82097898;  }
		/* 8209788Ch case   10:*/		return 0x82097890;
		  /* 82097890h */ case   11:  		/* sth R24, <#[R31]> */
		/* 82097890h case   11:*/		cpu::mem::store16( regs, regs.R24, (uint32)(regs.R31 + 0x00000000) );
		/* 82097890h case   11:*/		return 0x82097894;
		  /* 82097894h */ case   12:  		/* b 8 */
		/* 82097894h case   12:*/		return 0x8209789C;
		/* 82097894h case   12:*/		return 0x82097898;
	}
	return 0x82097898;
} // Block from 82097864h-82097898h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82097898h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097898);
		  /* 82097898h */ case    0:  		/* stw R24, <#[R31]> */
		/* 82097898h case    0:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000000) );
		/* 82097898h case    0:*/		return 0x8209789C;
	}
	return 0x8209789C;
} // Block from 82097898h-8209789Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209789Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209789C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209789C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209789C);
		  /* 8209789Ch */ case    0:  		/* li R11, 1 */
		/* 8209789Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8209789Ch case    0:*/		return 0x820978A0;
		  /* 820978A0h */ case    1:  		/* stw R11, <#[R1 + 104]> */
		/* 820978A0h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 820978A0h case    1:*/		return 0x820978A4;
		  /* 820978A4h */ case    2:  		/* b 1200 */
		/* 820978A4h case    2:*/		return 0x82097D54;
		/* 820978A4h case    2:*/		return 0x820978A8;
		  /* 820978A8h */ case    3:  		/* addi R11, R8, 32 */
		/* 820978A8h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0x20);
		/* 820978A8h case    3:*/		return 0x820978AC;
		  /* 820978ACh */ case    4:  		/* li R21, 1 */
		/* 820978ACh case    4:*/		cpu::op::li<0>(regs,&regs.R21,0x1);
		/* 820978ACh case    4:*/		return 0x820978B0;
		  /* 820978B0h */ case    5:  		/* extsb R29, R11 */
		/* 820978B0h case    5:*/		cpu::op::extsb<0>(regs,&regs.R29,regs.R11);
		/* 820978B0h case    5:*/		return 0x820978B4;
		  /* 820978B4h */ case    6:  		/* ori R27, R27, 64 */
		/* 820978B4h case    6:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x40);
		/* 820978B4h case    6:*/		return 0x820978B8;
		  /* 820978B8h */ case    7:  		/* addi R28, R1, 144 */
		/* 820978B8h case    7:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0x90);
		/* 820978B8h case    7:*/		return 0x820978BC;
		  /* 820978BCh */ case    8:  		/* li R30, 512 */
		/* 820978BCh case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x200);
		/* 820978BCh case    8:*/		return 0x820978C0;
		  /* 820978C0h */ case    9:  		/* cmpwi CR6, R25, 0 */
		/* 820978C0h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 820978C0h case    9:*/		return 0x820978C4;
		  /* 820978C4h */ case   10:  		/* bc 4, CR6_LT, 12 */
		/* 820978C4h case   10:*/		if ( !regs.CR[6].lt ) { return 0x820978D0;  }
		/* 820978C4h case   10:*/		return 0x820978C8;
	}
	return 0x820978C8;
} // Block from 8209789Ch-820978C8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820978C8h
// Function 'abort'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820978C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820978C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820978C8);
		  /* 820978C8h */ case    0:  		/* li R25, 6 */
		/* 820978C8h case    0:*/		cpu::op::li<0>(regs,&regs.R25,0x6);
		/* 820978C8h case    0:*/		return 0x820978CC;
		  /* 820978CCh */ case    1:  		/* b 84 */
		/* 820978CCh case    1:*/		return 0x82097920;
		/* 820978CCh case    1:*/		return 0x820978D0;
	}
	return 0x820978D0;
} // Block from 820978C8h-820978D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820978D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820978D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820978D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820978D0);
		  /* 820978D0h */ case    0:  		/* bc 4, CR6_EQ, 24 */
		/* 820978D0h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820978E8;  }
		/* 820978D0h case    0:*/		return 0x820978D4;
		  /* 820978D4h */ case    1:  		/* extsb R11, R29 */
		/* 820978D4h case    1:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R29);
		/* 820978D4h case    1:*/		return 0x820978D8;
		  /* 820978D8h */ case    2:  		/* cmpwi CR6, R11, 103 */
		/* 820978D8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000067);
		/* 820978D8h case    2:*/		return 0x820978DC;
		  /* 820978DCh */ case    3:  		/* bc 4, CR6_EQ, 68 */
		/* 820978DCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x82097920;  }
		/* 820978DCh case    3:*/		return 0x820978E0;
		  /* 820978E0h */ case    4:  		/* li R25, 1 */
		/* 820978E0h case    4:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 820978E0h case    4:*/		return 0x820978E4;
		  /* 820978E4h */ case    5:  		/* b 60 */
		/* 820978E4h case    5:*/		return 0x82097920;
		/* 820978E4h case    5:*/		return 0x820978E8;
	}
	return 0x820978E8;
} // Block from 820978D0h-820978E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820978E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820978E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820978E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820978E8);
		  /* 820978E8h */ case    0:  		/* cmpwi CR6, R25, 512 */
		/* 820978E8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000200);
		/* 820978E8h case    0:*/		return 0x820978EC;
		  /* 820978ECh */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 820978ECh case    1:*/		if ( !regs.CR[6].gt ) { return 0x820978F4;  }
		/* 820978ECh case    1:*/		return 0x820978F0;
		  /* 820978F0h */ case    2:  		/* li R25, 512 */
		/* 820978F0h case    2:*/		cpu::op::li<0>(regs,&regs.R25,0x200);
		/* 820978F0h case    2:*/		return 0x820978F4;
	}
	return 0x820978F4;
} // Block from 820978E8h-820978F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820978F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820978F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820978F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820978F4);
		  /* 820978F4h */ case    0:  		/* cmpwi CR6, R25, 163 */
		/* 820978F4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x000000A3);
		/* 820978F4h case    0:*/		return 0x820978F8;
		  /* 820978F8h */ case    1:  		/* bc 4, CR6_GT, 40 */
		/* 820978F8h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82097920;  }
		/* 820978F8h case    1:*/		return 0x820978FC;
		  /* 820978FCh */ case    2:  		/* addi R31, R25, 349 */
		/* 820978FCh case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R25,0x15D);
		/* 820978FCh case    2:*/		return 0x82097900;
		  /* 82097900h */ case    3:  		/* mr R3, R31 */
		/* 82097900h case    3:*/		regs.R3 = regs.R31;
		/* 82097900h case    3:*/		return 0x82097904;
		  /* 82097904h */ case    4:  		/* bl -16508 */
		/* 82097904h case    4:*/		regs.LR = 0x82097908; return 0x82093888;
		/* 82097904h case    4:*/		return 0x82097908;
		  /* 82097908h */ case    5:  		/* or. R14, R3, R3 */
		/* 82097908h case    5:*/		cpu::op::or<1>(regs,&regs.R14,regs.R3,regs.R3);
		/* 82097908h case    5:*/		return 0x8209790C;
		  /* 8209790Ch */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 8209790Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x8209791C;  }
		/* 8209790Ch case    6:*/		return 0x82097910;
		  /* 82097910h */ case    7:  		/* mr R28, R14 */
		/* 82097910h case    7:*/		regs.R28 = regs.R14;
		/* 82097910h case    7:*/		return 0x82097914;
		  /* 82097914h */ case    8:  		/* mr R30, R31 */
		/* 82097914h case    8:*/		regs.R30 = regs.R31;
		/* 82097914h case    8:*/		return 0x82097918;
	}
	return 0x82097918;
} // Block from 820978F4h-82097918h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82097918h
// Function '_set_abort_behavior'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097918);
		  /* 82097918h */ case    0:  		/* b 8 */
		/* 82097918h case    0:*/		return 0x82097920;
		/* 82097918h case    0:*/		return 0x8209791C;
	}
	return 0x8209791C;
} // Block from 82097918h-8209791Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209791Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209791C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209791C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209791C);
		  /* 8209791Ch */ case    0:  		/* li R25, 163 */
		/* 8209791Ch case    0:*/		cpu::op::li<0>(regs,&regs.R25,0xA3);
		/* 8209791Ch case    0:*/		return 0x82097920;
	}
	return 0x82097920;
} // Block from 8209791Ch-82097920h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82097920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097920);
		  /* 82097920h */ case    0:  		/* addi R11, R26, 7 */
		/* 82097920h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x7);
		/* 82097920h case    0:*/		return 0x82097924;
		  /* 82097924h */ case    1:  		/* lwz R10, <#[R22 + 24]> */
		/* 82097924h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000018) );
		/* 82097924h case    1:*/		return 0x82097928;
		  /* 82097928h */ case    2:  		/* extsb R31, R29 */
		/* 82097928h case    2:*/		cpu::op::extsb<0>(regs,&regs.R31,regs.R29);
		/* 82097928h case    2:*/		return 0x8209792C;
		  /* 8209792Ch */ case    3:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 8209792Ch case    3:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 8209792Ch case    3:*/		return 0x82097930;
		  /* 82097930h */ case    4:  		/* mr R9, R23 */
		/* 82097930h case    4:*/		regs.R9 = regs.R23;
		/* 82097930h case    4:*/		return 0x82097934;
		  /* 82097934h */ case    5:  		/* mr R8, R21 */
		/* 82097934h case    5:*/		regs.R8 = regs.R21;
		/* 82097934h case    5:*/		return 0x82097938;
	}
	return 0x82097938;
} // Block from 82097920h-82097938h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82097938h
// Function '_GET_RTERRMSG'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097938);
		  /* 82097938h */ case    0:  		/* mtspr CTR, R10 */
		/* 82097938h case    0:*/		regs.CTR = regs.R10;
		/* 82097938h case    0:*/		return 0x8209793C;
		  /* 8209793Ch */ case    1:  		/* mr R7, R25 */
		/* 8209793Ch case    1:*/		regs.R7 = regs.R25;
		/* 8209793Ch case    1:*/		return 0x82097940;
		  /* 82097940h */ case    2:  		/* mr R6, R31 */
		/* 82097940h case    2:*/		regs.R6 = regs.R31;
		/* 82097940h case    2:*/		return 0x82097944;
		  /* 82097944h */ case    3:  		/* ld R10, <#[R11]> */
		/* 82097944h case    3:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82097944h case    3:*/		return 0x82097948;
		  /* 82097948h */ case    4:  		/* mr R5, R30 */
		/* 82097948h case    4:*/		regs.R5 = regs.R30;
		/* 82097948h case    4:*/		return 0x8209794C;
		  /* 8209794Ch */ case    5:  		/* mr R4, R28 */
		/* 8209794Ch case    5:*/		regs.R4 = regs.R28;
		/* 8209794Ch case    5:*/		return 0x82097950;
		  /* 82097950h */ case    6:  		/* addi R3, R1, 128 */
		/* 82097950h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 82097950h case    6:*/		return 0x82097954;
		  /* 82097954h */ case    7:  		/* addi R26, R11, 8 */
		/* 82097954h case    7:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x8);
		/* 82097954h case    7:*/		return 0x82097958;
		  /* 82097958h */ case    8:  		/* std R10, <#[R1 + 128]> */
		/* 82097958h case    8:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000080) );
		/* 82097958h case    8:*/		return 0x8209795C;
		  /* 8209795Ch */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 8209795Ch case    9:*/		if ( 1 ) { regs.LR = 0x82097960; return (uint32)regs.CTR; }
		/* 8209795Ch case    9:*/		return 0x82097960;
		  /* 82097960h */ case   10:  		/* rlwinm. R30, R27, 0, 24, 24 */
		/* 82097960h case   10:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R30,regs.R27);
		/* 82097960h case   10:*/		return 0x82097964;
		  /* 82097964h */ case   11:  		/* bc 12, CR0_EQ, 32 */
		/* 82097964h case   11:*/		if ( regs.CR[0].eq ) { return 0x82097984;  }
		/* 82097964h case   11:*/		return 0x82097968;
		  /* 82097968h */ case   12:  		/* cmpwi CR6, R25, 0 */
		/* 82097968h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82097968h case   12:*/		return 0x8209796C;
		  /* 8209796Ch */ case   13:  		/* bc 4, CR6_EQ, 24 */
		/* 8209796Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x82097984;  }
		/* 8209796Ch case   13:*/		return 0x82097970;
		  /* 82097970h */ case   14:  		/* lwz R11, <#[R22 + 36]> */
		/* 82097970h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000024) );
		/* 82097970h case   14:*/		return 0x82097974;
		  /* 82097974h */ case   15:  		/* mr R4, R23 */
		/* 82097974h case   15:*/		regs.R4 = regs.R23;
		/* 82097974h case   15:*/		return 0x82097978;
		  /* 82097978h */ case   16:  		/* mr R3, R28 */
		/* 82097978h case   16:*/		regs.R3 = regs.R28;
		/* 82097978h case   16:*/		return 0x8209797C;
		  /* 8209797Ch */ case   17:  		/* mtspr CTR, R11 */
		/* 8209797Ch case   17:*/		regs.CTR = regs.R11;
		/* 8209797Ch case   17:*/		return 0x82097980;
	}
	return 0x82097980;
} // Block from 82097938h-82097980h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82097980h
// Function '_NMSG_WRITE'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097980);
		  /* 82097980h */ case    0:  		/* bcctrl 20, CR0_LT */
		/* 82097980h case    0:*/		if ( 1 ) { regs.LR = 0x82097984; return (uint32)regs.CTR; }
		/* 82097980h case    0:*/		return 0x82097984;
	}
	return 0x82097984;
} // Block from 82097980h-82097984h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82097984h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097984( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097984) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097984);
		  /* 82097984h */ case    0:  		/* cmpwi CR6, R31, 103 */
		/* 82097984h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000067);
		/* 82097984h case    0:*/		return 0x82097988;
		  /* 82097988h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 82097988h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820979A8;  }
		/* 82097988h case    1:*/		return 0x8209798C;
		  /* 8209798Ch */ case    2:  		/* cmpwi CR6, R30, 0 */
		/* 8209798Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 8209798Ch case    2:*/		return 0x82097990;
		  /* 82097990h */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 82097990h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820979A8;  }
		/* 82097990h case    3:*/		return 0x82097994;
		  /* 82097994h */ case    4:  		/* lwz R11, <#[R22 + 32]> */
		/* 82097994h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000020) );
		/* 82097994h case    4:*/		return 0x82097998;
		  /* 82097998h */ case    5:  		/* mr R4, R23 */
		/* 82097998h case    5:*/		regs.R4 = regs.R23;
		/* 82097998h case    5:*/		return 0x8209799C;
		  /* 8209799Ch */ case    6:  		/* mr R3, R28 */
		/* 8209799Ch case    6:*/		regs.R3 = regs.R28;
		/* 8209799Ch case    6:*/		return 0x820979A0;
		  /* 820979A0h */ case    7:  		/* mtspr CTR, R11 */
		/* 820979A0h case    7:*/		regs.CTR = regs.R11;
		/* 820979A0h case    7:*/		return 0x820979A4;
		  /* 820979A4h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 820979A4h case    8:*/		if ( 1 ) { regs.LR = 0x820979A8; return (uint32)regs.CTR; }
		/* 820979A4h case    8:*/		return 0x820979A8;
	}
	return 0x820979A8;
} // Block from 82097984h-820979A8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820979A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820979A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820979A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820979A8);
		  /* 820979A8h */ case    0:  		/* lbz R11, <#[R28]> */
		/* 820979A8h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820979A8h case    0:*/		return 0x820979AC;
		  /* 820979ACh */ case    1:  		/* cmplwi CR6, R11, 45 */
		/* 820979ACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002D);
		/* 820979ACh case    1:*/		return 0x820979B0;
	}
	return 0x820979B0;
} // Block from 820979A8h-820979B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820979B0h
// Function '_FF_MSGBANNER'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820979B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820979B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820979B0);
		  /* 820979B0h */ case    0:  		/* bc 4, CR6_EQ, 12 */
		/* 820979B0h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820979BC;  }
		/* 820979B0h case    0:*/		return 0x820979B4;
		  /* 820979B4h */ case    1:  		/* ori R27, R27, 256 */
		/* 820979B4h case    1:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x100);
		/* 820979B4h case    1:*/		return 0x820979B8;
		  /* 820979B8h */ case    2:  		/* addi R28, R28, 1 */
		/* 820979B8h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820979B8h case    2:*/		return 0x820979BC;
	}
	return 0x820979BC;
} // Block from 820979B0h-820979BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820979BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820979BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820979BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820979BC);
		  /* 820979BCh */ case    0:  		/* mr R11, R28 */
		/* 820979BCh case    0:*/		regs.R11 = regs.R28;
		/* 820979BCh case    0:*/		return 0x820979C0;
		  /* 820979C0h */ case    1:  		/* lbz R10, <#[R11]> */
		/* 820979C0h case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820979C0h case    1:*/		return 0x820979C4;
		  /* 820979C4h */ case    2:  		/* addi R11, R11, 1 */
		/* 820979C4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820979C4h case    2:*/		return 0x820979C8;
		  /* 820979C8h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 820979C8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820979C8h case    3:*/		return 0x820979CC;
		  /* 820979CCh */ case    4:  		/* bc 4, CR6_EQ, -12 */
		/* 820979CCh case    4:*/		if ( !regs.CR[6].eq ) { return 0x820979C0;  }
		/* 820979CCh case    4:*/		return 0x820979D0;
		  /* 820979D0h */ case    5:  		/* subf R11, R28, R11 */
		/* 820979D0h case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 820979D0h case    5:*/		return 0x820979D4;
		  /* 820979D4h */ case    6:  		/* b -556 */
		/* 820979D4h case    6:*/		return 0x820977A8;
		/* 820979D4h case    6:*/		return 0x820979D8;
		  /* 820979D8h */ case    7:  		/* ori R27, R27, 64 */
		/* 820979D8h case    7:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x40);
		/* 820979D8h case    7:*/		return 0x820979DC;
		  /* 820979DCh */ case    8:  		/* li R8, 10 */
		/* 820979DCh case    8:*/		cpu::op::li<0>(regs,&regs.R8,0xA);
		/* 820979DCh case    8:*/		return 0x820979E0;
		  /* 820979E0h */ case    9:  		/* b 80 */
		/* 820979E0h case    9:*/		return 0x82097A30;
		/* 820979E0h case    9:*/		return 0x820979E4;
		  /* 820979E4h */ case   10:  		/* li R25, 8 */
		/* 820979E4h case   10:*/		cpu::op::li<0>(regs,&regs.R25,0x8);
		/* 820979E4h case   10:*/		return 0x820979E8;
		  /* 820979E8h */ case   11:  		/* li R11, 7 */
		/* 820979E8h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 820979E8h case   11:*/		return 0x820979EC;
		  /* 820979ECh */ case   12:  		/* b 8 */
		/* 820979ECh case   12:*/		return 0x820979F4;
		/* 820979ECh case   12:*/		return 0x820979F0;
		  /* 820979F0h */ case   13:  		/* li R11, 39 */
		/* 820979F0h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x27);
		/* 820979F0h case   13:*/		return 0x820979F4;
	}
	return 0x820979F4;
} // Block from 820979BCh-820979F4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820979F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820979F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820979F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820979F4);
		  /* 820979F4h */ case    0:  		/* stw R11, <#[R1 + 108]> */
		/* 820979F4h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 820979F4h case    0:*/		return 0x820979F8;
	}
	return 0x820979F8;
} // Block from 820979F4h-820979F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820979F8h
// Function '_initp_misc_purevirt'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820979F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820979F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820979F8);
		  /* 820979F8h */ case    0:  		/* rlwinm. R10, R27, 0, 24, 24 */
		/* 820979F8h case    0:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R10,regs.R27);
		/* 820979F8h case    0:*/		return 0x820979FC;
		  /* 820979FCh */ case    1:  		/* li R8, 16 */
		/* 820979FCh case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x10);
		/* 820979FCh case    1:*/		return 0x82097A00;
		  /* 82097A00h */ case    2:  		/* bc 12, CR0_EQ, 48 */
		/* 82097A00h case    2:*/		if ( regs.CR[0].eq ) { return 0x82097A30;  }
		/* 82097A00h case    2:*/		return 0x82097A04;
		  /* 82097A04h */ case    3:  		/* addi R11, R11, 81 */
		/* 82097A04h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x51);
		/* 82097A04h case    3:*/		return 0x82097A08;
	}
	return 0x82097A08;
} // Block from 820979F8h-82097A08h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82097A08h
// Function 'log'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097A08);
		  /* 82097A08h */ case    0:  		/* li R10, 48 */
		/* 82097A08h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x30);
		/* 82097A08h case    0:*/		return 0x82097A0C;
		  /* 82097A0Ch */ case    1:  		/* li R9, 2 */
		/* 82097A0Ch case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 82097A0Ch case    1:*/		return 0x82097A10;
		  /* 82097A10h */ case    2:  		/* stb R11, <#[R1 + 89]> */
		/* 82097A10h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000059) );
		/* 82097A10h case    2:*/		return 0x82097A14;
		  /* 82097A14h */ case    3:  		/* stb R10, <#[R1 + 88]> */
		/* 82097A14h case    3:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82097A14h case    3:*/		return 0x82097A18;
		  /* 82097A18h */ case    4:  		/* stw R9, <#[R1 + 92]> */
		/* 82097A18h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000005C) );
		/* 82097A18h case    4:*/		return 0x82097A1C;
		  /* 82097A1Ch */ case    5:  		/* b 20 */
		/* 82097A1Ch case    5:*/		return 0x82097A30;
		/* 82097A1Ch case    5:*/		return 0x82097A20;
		  /* 82097A20h */ case    6:  		/* rlwinm. R11, R27, 0, 24, 24 */
		/* 82097A20h case    6:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R11,regs.R27);
		/* 82097A20h case    6:*/		return 0x82097A24;
		  /* 82097A24h */ case    7:  		/* li R8, 8 */
		/* 82097A24h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x8);
		/* 82097A24h case    7:*/		return 0x82097A28;
		  /* 82097A28h */ case    8:  		/* bc 12, CR0_EQ, 8 */
		/* 82097A28h case    8:*/		if ( regs.CR[0].eq ) { return 0x82097A30;  }
		/* 82097A28h case    8:*/		return 0x82097A2C;
		  /* 82097A2Ch */ case    9:  		/* ori R27, R27, 512 */
		/* 82097A2Ch case    9:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x200);
		/* 82097A2Ch case    9:*/		return 0x82097A30;
	}
	return 0x82097A30;
} // Block from 82097A08h-82097A30h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82097A30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097A30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097A30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097A30);
		  /* 82097A30h */ case    0:  		/* rlwinm. R11, R27, 0, 16, 16 */
		/* 82097A30h case    0:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R11,regs.R27);
		/* 82097A30h case    0:*/		return 0x82097A34;
		  /* 82097A34h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 82097A34h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82097A40;  }
		/* 82097A34h case    1:*/		return 0x82097A38;
		  /* 82097A38h */ case    2:  		/* rlwinm. R11, R27, 0, 19, 19 */
		/* 82097A38h case    2:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R11,regs.R27);
		/* 82097A38h case    2:*/		return 0x82097A3C;
		  /* 82097A3Ch */ case    3:  		/* bc 12, CR0_EQ, 24 */
		/* 82097A3Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x82097A54;  }
		/* 82097A3Ch case    3:*/		return 0x82097A40;
	}
	return 0x82097A40;
} // Block from 82097A30h-82097A40h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82097A40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097A40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097A40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097A40);
		  /* 82097A40h */ case    0:  		/* addi R11, R26, 7 */
		/* 82097A40h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x7);
		/* 82097A40h case    0:*/		return 0x82097A44;
		  /* 82097A44h */ case    1:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82097A44h case    1:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82097A44h case    1:*/		return 0x82097A48;
		  /* 82097A48h */ case    2:  		/* addi R26, R11, 8 */
		/* 82097A48h case    2:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x8);
		/* 82097A48h case    2:*/		return 0x82097A4C;
		  /* 82097A4Ch */ case    3:  		/* ld R11, <#[R11]> */
		/* 82097A4Ch case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82097A4Ch case    3:*/		return 0x82097A50;
		  /* 82097A50h */ case    4:  		/* b 84 */
		/* 82097A50h case    4:*/		return 0x82097AA4;
		/* 82097A50h case    4:*/		return 0x82097A54;
	}
	return 0x82097A54;
} // Block from 82097A40h-82097A54h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82097A54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097A54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097A54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097A54);
		  /* 82097A54h */ case    0:  		/* rlwinm. R11, R27, 0, 26, 26 */
		/* 82097A54h case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R27);
		/* 82097A54h case    0:*/		return 0x82097A58;
		  /* 82097A58h */ case    1:  		/* bc 12, CR0_EQ, 44 */
		/* 82097A58h case    1:*/		if ( regs.CR[0].eq ) { return 0x82097A84;  }
		/* 82097A58h case    1:*/		return 0x82097A5C;
		  /* 82097A5Ch */ case    2:  		/* rlwinm. R11, R27, 0, 25, 25 */
		/* 82097A5Ch case    2:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R27);
		/* 82097A5Ch case    2:*/		return 0x82097A60;
		  /* 82097A60h */ case    3:  		/* addi R11, R26, 7 */
		/* 82097A60h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x7);
		/* 82097A60h case    3:*/		return 0x82097A64;
		  /* 82097A64h */ case    4:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82097A64h case    4:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82097A64h case    4:*/		return 0x82097A68;
		  /* 82097A68h */ case    5:  		/* addi R26, R11, 8 */
		/* 82097A68h case    5:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x8);
		/* 82097A68h case    5:*/		return 0x82097A6C;
		  /* 82097A6Ch */ case    6:  		/* lwz R11, <#[R11 + 4]> */
		/* 82097A6Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82097A6Ch case    6:*/		return 0x82097A70;
		  /* 82097A70h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 82097A70h case    7:*/		if ( regs.CR[0].eq ) { return 0x82097A7C;  }
		/* 82097A70h case    7:*/		return 0x82097A74;
		  /* 82097A74h */ case    8:  		/* extsh R11, R11 */
		/* 82097A74h case    8:*/		cpu::op::extsh<0>(regs,&regs.R11,regs.R11);
		/* 82097A74h case    8:*/		return 0x82097A78;
		  /* 82097A78h */ case    9:  		/* b 44 */
		/* 82097A78h case    9:*/		return 0x82097AA4;
		/* 82097A78h case    9:*/		return 0x82097A7C;
	}
	return 0x82097A7C;
} // Block from 82097A54h-82097A7Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 82097A7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097A7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097A7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097A7C);
		  /* 82097A7Ch */ case    0:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 82097A7Ch case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 82097A7Ch case    0:*/		return 0x82097A80;
		  /* 82097A80h */ case    1:  		/* b 36 */
		/* 82097A80h case    1:*/		return 0x82097AA4;
		/* 82097A80h case    1:*/		return 0x82097A84;
	}
	return 0x82097A84;
} // Block from 82097A7Ch-82097A84h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82097A84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097A84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097A84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097A84);
		  /* 82097A84h */ case    0:  		/* rlwinm. R11, R27, 0, 25, 25 */
		/* 82097A84h case    0:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R27);
		/* 82097A84h case    0:*/		return 0x82097A88;
		  /* 82097A88h */ case    1:  		/* addi R11, R26, 7 */
		/* 82097A88h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x7);
		/* 82097A88h case    1:*/		return 0x82097A8C;
		  /* 82097A8Ch */ case    2:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 82097A8Ch case    2:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 82097A8Ch case    2:*/		return 0x82097A90;
		  /* 82097A90h */ case    3:  		/* addi R26, R11, 8 */
		/* 82097A90h case    3:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x8);
		/* 82097A90h case    3:*/		return 0x82097A94;
		  /* 82097A94h */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 82097A94h case    4:*/		if ( regs.CR[0].eq ) { return 0x82097AA0;  }
		/* 82097A94h case    4:*/		return 0x82097A98;
		  /* 82097A98h */ case    5:  		/* lwa R11, <#[R11 + 4]> */
		/* 82097A98h case    5:*/		cpu::mem::load32a( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82097A98h case    5:*/		return 0x82097A9C;
		  /* 82097A9Ch */ case    6:  		/* b 8 */
		/* 82097A9Ch case    6:*/		return 0x82097AA4;
		/* 82097A9Ch case    6:*/		return 0x82097AA0;
	}
	return 0x82097AA0;
} // Block from 82097A84h-82097AA0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82097AA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097AA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097AA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097AA0);
		  /* 82097AA0h */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 82097AA0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82097AA0h case    0:*/		return 0x82097AA4;
	}
	return 0x82097AA4;
} // Block from 82097AA0h-82097AA4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82097AA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097AA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097AA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097AA4);
		  /* 82097AA4h */ case    0:  		/* rlwinm. R10, R27, 0, 25, 25 */
		/* 82097AA4h case    0:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R27);
		/* 82097AA4h case    0:*/		return 0x82097AA8;
		  /* 82097AA8h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 82097AA8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82097ABC;  }
		/* 82097AA8h case    1:*/		return 0x82097AAC;
		  /* 82097AACh */ case    2:  		/* cmpdi CR6, R11, 0 */
		/* 82097AACh case    2:*/		cpu::op::cmpdi<6>(regs,regs.R11,0x00000000);
		/* 82097AACh case    2:*/		return 0x82097AB0;
		  /* 82097AB0h */ case    3:  		/* bc 4, CR6_LT, 12 */
		/* 82097AB0h case    3:*/		if ( !regs.CR[6].lt ) { return 0x82097ABC;  }
		/* 82097AB0h case    3:*/		return 0x82097AB4;
		  /* 82097AB4h */ case    4:  		/* neg R11, R11 */
		/* 82097AB4h case    4:*/		cpu::op::neg<0>(regs,&regs.R11,regs.R11);
		/* 82097AB4h case    4:*/		return 0x82097AB8;
		  /* 82097AB8h */ case    5:  		/* ori R27, R27, 256 */
		/* 82097AB8h case    5:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x100);
		/* 82097AB8h case    5:*/		return 0x82097ABC;
	}
	return 0x82097ABC;
} // Block from 82097AA4h-82097ABCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 82097ABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097ABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097ABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097ABC);
		  /* 82097ABCh */ case    0:  		/* rlwinm. R10, R27, 0, 16, 16 */
		/* 82097ABCh case    0:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R10,regs.R27);
		/* 82097ABCh case    0:*/		return 0x82097AC0;
		  /* 82097AC0h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 82097AC0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82097AD0;  }
		/* 82097AC0h case    1:*/		return 0x82097AC4;
		  /* 82097AC4h */ case    2:  		/* rlwinm. R10, R27, 0, 19, 19 */
		/* 82097AC4h case    2:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R10,regs.R27);
		/* 82097AC4h case    2:*/		return 0x82097AC8;
		  /* 82097AC8h */ case    3:  		/* bc 4, CR0_EQ, 8 */
		/* 82097AC8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82097AD0;  }
		/* 82097AC8h case    3:*/		return 0x82097ACC;
		  /* 82097ACCh */ case    4:  		/* rldicl R11, R11, 0, 32 */
		/* 82097ACCh case    4:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R11);
		/* 82097ACCh case    4:*/		return 0x82097AD0;
	}
	return 0x82097AD0;
} // Block from 82097ABCh-82097AD0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82097AD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097AD0);
		  /* 82097AD0h */ case    0:  		/* cmpwi CR6, R25, 0 */
		/* 82097AD0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82097AD0h case    0:*/		return 0x82097AD4;
		  /* 82097AD4h */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 82097AD4h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82097AE0;  }
		/* 82097AD4h case    1:*/		return 0x82097AD8;
		  /* 82097AD8h */ case    2:  		/* li R25, 1 */
		/* 82097AD8h case    2:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 82097AD8h case    2:*/		return 0x82097ADC;
		  /* 82097ADCh */ case    3:  		/* b 20 */
		/* 82097ADCh case    3:*/		return 0x82097AF0;
		/* 82097ADCh case    3:*/		return 0x82097AE0;
	}
	return 0x82097AE0;
} // Block from 82097AD0h-82097AE0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82097AE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097AE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097AE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097AE0);
		  /* 82097AE0h */ case    0:  		/* rlwinm R27, R27, 0, 29, 27 */
		/* 82097AE0h case    0:*/		cpu::op::rlwinm<0,0,29,27>(regs,&regs.R27,regs.R27);
		/* 82097AE0h case    0:*/		return 0x82097AE4;
		  /* 82097AE4h */ case    1:  		/* cmpwi CR6, R25, 512 */
		/* 82097AE4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000200);
		/* 82097AE4h case    1:*/		return 0x82097AE8;
		  /* 82097AE8h */ case    2:  		/* bc 4, CR6_GT, 8 */
		/* 82097AE8h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82097AF0;  }
		/* 82097AE8h case    2:*/		return 0x82097AEC;
		  /* 82097AECh */ case    3:  		/* li R25, 512 */
		/* 82097AECh case    3:*/		cpu::op::li<0>(regs,&regs.R25,0x200);
		/* 82097AECh case    3:*/		return 0x82097AF0;
	}
	return 0x82097AF0;
} // Block from 82097AE0h-82097AF0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82097AF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097AF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097AF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097AF0);
		  /* 82097AF0h */ case    0:  		/* cmpldi CR6, R11, 0 */
		/* 82097AF0h case    0:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82097AF0h case    0:*/		return 0x82097AF4;
		  /* 82097AF4h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82097AF4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82097B00;  }
		/* 82097AF4h case    1:*/		return 0x82097AF8;
		  /* 82097AF8h */ case    2:  		/* li R10, 0 */
		/* 82097AF8h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82097AF8h case    2:*/		return 0x82097AFC;
		  /* 82097AFCh */ case    3:  		/* stw R10, <#[R1 + 92]> */
		/* 82097AFCh case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 82097AFCh case    3:*/		return 0x82097B00;
	}
	return 0x82097B00;
} // Block from 82097AF0h-82097B00h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82097B00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097B00);
		  /* 82097B00h */ case    0:  		/* addi R9, R1, 655 */
		/* 82097B00h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x28F);
		/* 82097B00h case    0:*/		return 0x82097B04;
		  /* 82097B04h */ case    1:  		/* cmpwi CR6, R25, 0 */
		/* 82097B04h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82097B04h case    1:*/		return 0x82097B08;
		  /* 82097B08h */ case    2:  		/* addi R25, R25, -1 */
		/* 82097B08h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0xFFFFFFFF);
		/* 82097B08h case    2:*/		return 0x82097B0C;
		  /* 82097B0Ch */ case    3:  		/* bc 12, CR6_GT, 12 */
		/* 82097B0Ch case    3:*/		if ( regs.CR[6].gt ) { return 0x82097B18;  }
		/* 82097B0Ch case    3:*/		return 0x82097B10;
		  /* 82097B10h */ case    4:  		/* cmpldi CR6, R11, 0 */
		/* 82097B10h case    4:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82097B10h case    4:*/		return 0x82097B14;
		  /* 82097B14h */ case    5:  		/* bc 12, CR6_EQ, 72 */
		/* 82097B14h case    5:*/		if ( regs.CR[6].eq ) { return 0x82097B5C;  }
		/* 82097B14h case    5:*/		return 0x82097B18;
	}
	return 0x82097B18;
} // Block from 82097B00h-82097B18h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82097B18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097B18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097B18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097B18);
		  /* 82097B18h */ case    0:  		/* extsw R10, R8 */
		/* 82097B18h case    0:*/		cpu::op::extsw<0>(regs,&regs.R10,regs.R8);
		/* 82097B18h case    0:*/		return 0x82097B1C;
		  /* 82097B1Ch */ case    1:  		/* divdu R7, R11, R10 */
		/* 82097B1Ch case    1:*/		cpu::op::divdu<0>(regs,&regs.R7,regs.R11,regs.R10);
		/* 82097B1Ch case    1:*/		return 0x82097B20;
		  /* 82097B20h */ case    2:  		/* tdi 6, R10, 0 */
		/* 82097B20h case    2:*/		cpu::op::td<6>(regs, 0x82097B20, regs.R10, 0x00000000);
		/* 82097B20h case    2:*/		return 0x82097B24;
		  /* 82097B24h */ case    3:  		/* mulld R7, R7, R10 */
		/* 82097B24h case    3:*/		cpu::op::mulld<0>(regs,&regs.R7,regs.R7,regs.R10);
		/* 82097B24h case    3:*/		return 0x82097B28;
		  /* 82097B28h */ case    4:  		/* subf R7, R7, R11 */
		/* 82097B28h case    4:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R7,regs.R11);
		/* 82097B28h case    4:*/		return 0x82097B2C;
		  /* 82097B2Ch */ case    5:  		/* divdu R11, R11, R10 */
		/* 82097B2Ch case    5:*/		cpu::op::divdu<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82097B2Ch case    5:*/		return 0x82097B30;
		  /* 82097B30h */ case    6:  		/* tdi 6, R10, 0 */
		/* 82097B30h case    6:*/		cpu::op::td<6>(regs, 0x82097B30, regs.R10, 0x00000000);
		/* 82097B30h case    6:*/		return 0x82097B34;
		  /* 82097B34h */ case    7:  		/* rlwinm R10, R7, 0, 0, 31 */
		/* 82097B34h case    7:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R7);
		/* 82097B34h case    7:*/		return 0x82097B38;
		  /* 82097B38h */ case    8:  		/* addi R10, R10, 48 */
		/* 82097B38h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x30);
		/* 82097B38h case    8:*/		return 0x82097B3C;
		  /* 82097B3Ch */ case    9:  		/* cmpwi CR6, R10, 57 */
		/* 82097B3Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000039);
		/* 82097B3Ch case    9:*/		return 0x82097B40;
		  /* 82097B40h */ case   10:  		/* bc 4, CR6_GT, 12 */
		/* 82097B40h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82097B4C;  }
		/* 82097B40h case   10:*/		return 0x82097B44;
		  /* 82097B44h */ case   11:  		/* lwz R7, <#[R1 + 108]> */
		/* 82097B44h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x0000006C) );
		/* 82097B44h case   11:*/		return 0x82097B48;
		  /* 82097B48h */ case   12:  		/* add R10, R10, R7 */
		/* 82097B48h case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 82097B48h case   12:*/		return 0x82097B4C;
	}
	return 0x82097B4C;
} // Block from 82097B18h-82097B4Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 82097B4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097B4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097B4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097B4C);
		  /* 82097B4Ch */ case    0:  		/* extsb R10, R10 */
		/* 82097B4Ch case    0:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 82097B4Ch case    0:*/		return 0x82097B50;
		  /* 82097B50h */ case    1:  		/* stb R10, <#[R9]> */
		/* 82097B50h case    1:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 82097B50h case    1:*/		return 0x82097B54;
		  /* 82097B54h */ case    2:  		/* addi R9, R9, -1 */
		/* 82097B54h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82097B54h case    2:*/		return 0x82097B58;
		  /* 82097B58h */ case    3:  		/* b -84 */
		/* 82097B58h case    3:*/		return 0x82097B04;
		/* 82097B58h case    3:*/		return 0x82097B5C;
	}
	return 0x82097B5C;
} // Block from 82097B4Ch-82097B5Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82097B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097B5C);
		  /* 82097B5Ch */ case    0:  		/* addi R11, R1, 655 */
		/* 82097B5Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x28F);
		/* 82097B5Ch case    0:*/		return 0x82097B60;
		  /* 82097B60h */ case    1:  		/* rlwinm. R10, R27, 0, 22, 22 */
		/* 82097B60h case    1:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R10,regs.R27);
		/* 82097B60h case    1:*/		return 0x82097B64;
		  /* 82097B64h */ case    2:  		/* subf R7, R9, R11 */
		/* 82097B64h case    2:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R9,regs.R11);
		/* 82097B64h case    2:*/		return 0x82097B68;
		  /* 82097B68h */ case    3:  		/* addi R28, R9, 1 */
		/* 82097B68h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R9,0x1);
		/* 82097B68h case    3:*/		return 0x82097B6C;
		  /* 82097B6Ch */ case    4:  		/* stw R7, <#[R1 + 84]> */
		/* 82097B6Ch case    4:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000054) );
		/* 82097B6Ch case    4:*/		return 0x82097B70;
		  /* 82097B70h */ case    5:  		/* bc 12, CR0_EQ, 40 */
		/* 82097B70h case    5:*/		if ( regs.CR[0].eq ) { return 0x82097B98;  }
		/* 82097B70h case    5:*/		return 0x82097B74;
		  /* 82097B74h */ case    6:  		/* cmpwi CR6, R7, 0 */
		/* 82097B74h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 82097B74h case    6:*/		return 0x82097B78;
		  /* 82097B78h */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 82097B78h case    7:*/		if ( regs.CR[6].eq ) { return 0x82097B88;  }
		/* 82097B78h case    7:*/		return 0x82097B7C;
		  /* 82097B7Ch */ case    8:  		/* lbz R11, <#[R28]> */
		/* 82097B7Ch case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82097B7Ch case    8:*/		return 0x82097B80;
		  /* 82097B80h */ case    9:  		/* cmplwi CR6, R11, 48 */
		/* 82097B80h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 82097B80h case    9:*/		return 0x82097B84;
		  /* 82097B84h */ case   10:  		/* bc 12, CR6_EQ, 20 */
		/* 82097B84h case   10:*/		if ( regs.CR[6].eq ) { return 0x82097B98;  }
		/* 82097B84h case   10:*/		return 0x82097B88;
	}
	return 0x82097B88;
} // Block from 82097B5Ch-82097B88h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82097B88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097B88);
		  /* 82097B88h */ case    0:  		/* li R11, 48 */
		/* 82097B88h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x30);
		/* 82097B88h case    0:*/		return 0x82097B8C;
		  /* 82097B8Ch */ case    1:  		/* addi R7, R7, 1 */
		/* 82097B8Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82097B8Ch case    1:*/		return 0x82097B90;
		  /* 82097B90h */ case    2:  		/* stbu R11, <#[R28 - 1]> */
		/* 82097B90h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R28 + 0xFFFFFFFF) );
		regs.R28 = (uint32)(regs.R28 + 0xFFFFFFFF);
		/* 82097B90h case    2:*/		return 0x82097B94;
	}
	return 0x82097B94;
} // Block from 82097B88h-82097B94h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82097B94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097B94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097B94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097B94);
		  /* 82097B94h */ case    0:  		/* stw R7, <#[R1 + 84]> */
		/* 82097B94h case    0:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000054) );
		/* 82097B94h case    0:*/		return 0x82097B98;
	}
	return 0x82097B98;
} // Block from 82097B94h-82097B98h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82097B98h
// Function '_copysign'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097B98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097B98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097B98);
		  /* 82097B98h */ case    0:  		/* lwz R11, <#[R1 + 104]> */
		/* 82097B98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 82097B98h case    0:*/		return 0x82097B9C;
		  /* 82097B9Ch */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82097B9Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82097B9Ch case    1:*/		return 0x82097BA0;
		  /* 82097BA0h */ case    2:  		/* bc 4, CR6_EQ, 436 */
		/* 82097BA0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82097D54;  }
		/* 82097BA0h case    2:*/		return 0x82097BA4;
		  /* 82097BA4h */ case    3:  		/* rlwinm. R11, R27, 0, 25, 25 */
		/* 82097BA4h case    3:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R27);
		/* 82097BA4h case    3:*/		return 0x82097BA8;
		  /* 82097BA8h */ case    4:  		/* bc 12, CR0_EQ, 64 */
		/* 82097BA8h case    4:*/		if ( regs.CR[0].eq ) { return 0x82097BE8;  }
		/* 82097BA8h case    4:*/		return 0x82097BAC;
		  /* 82097BACh */ case    5:  		/* rlwinm. R11, R27, 0, 23, 23 */
		/* 82097BACh case    5:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R27);
		/* 82097BACh case    5:*/		return 0x82097BB0;
		  /* 82097BB0h */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 82097BB0h case    6:*/		if ( regs.CR[0].eq ) { return 0x82097BBC;  }
		/* 82097BB0h case    6:*/		return 0x82097BB4;
		  /* 82097BB4h */ case    7:  		/* li R11, 45 */
		/* 82097BB4h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x2D);
		/* 82097BB4h case    7:*/		return 0x82097BB8;
		  /* 82097BB8h */ case    8:  		/* b 16 */
		/* 82097BB8h case    8:*/		return 0x82097BC8;
		/* 82097BB8h case    8:*/		return 0x82097BBC;
	}
	return 0x82097BBC;
} // Block from 82097B98h-82097BBCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 82097BBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097BBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097BBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097BBC);
		  /* 82097BBCh */ case    0:  		/* rlwinm. R11, R27, 0, 31, 31 */
		/* 82097BBCh case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R27);
		/* 82097BBCh case    0:*/		return 0x82097BC0;
		  /* 82097BC0h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 82097BC0h case    1:*/		if ( regs.CR[0].eq ) { return 0x82097BD8;  }
		/* 82097BC0h case    1:*/		return 0x82097BC4;
		  /* 82097BC4h */ case    2:  		/* li R11, 43 */
		/* 82097BC4h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x2B);
		/* 82097BC4h case    2:*/		return 0x82097BC8;
	}
	return 0x82097BC8;
} // Block from 82097BBCh-82097BC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82097BC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097BC8);
		  /* 82097BC8h */ case    0:  		/* li R30, 1 */
		/* 82097BC8h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82097BC8h case    0:*/		return 0x82097BCC;
		  /* 82097BCCh */ case    1:  		/* stb R11, <#[R1 + 88]> */
		/* 82097BCCh case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82097BCCh case    1:*/		return 0x82097BD0;
	}
	return 0x82097BD0;
} // Block from 82097BC8h-82097BD0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82097BD0h
// Function '_chgsign'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097BD0);
		  /* 82097BD0h */ case    0:  		/* stw R30, <#[R1 + 92]> */
		/* 82097BD0h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000005C) );
		/* 82097BD0h case    0:*/		return 0x82097BD4;
		  /* 82097BD4h */ case    1:  		/* b 24 */
		/* 82097BD4h case    1:*/		return 0x82097BEC;
		/* 82097BD4h case    1:*/		return 0x82097BD8;
	}
	return 0x82097BD8;
} // Block from 82097BD0h-82097BD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82097BD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097BD8);
		  /* 82097BD8h */ case    0:  		/* rlwinm. R11, R27, 0, 30, 30 */
		/* 82097BD8h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R27);
		/* 82097BD8h case    0:*/		return 0x82097BDC;
		  /* 82097BDCh */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82097BDCh case    1:*/		if ( regs.CR[0].eq ) { return 0x82097BE8;  }
		/* 82097BDCh case    1:*/		return 0x82097BE0;
		  /* 82097BE0h */ case    2:  		/* li R11, 32 */
		/* 82097BE0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x20);
		/* 82097BE0h case    2:*/		return 0x82097BE4;
		  /* 82097BE4h */ case    3:  		/* b -28 */
		/* 82097BE4h case    3:*/		return 0x82097BC8;
		/* 82097BE4h case    3:*/		return 0x82097BE8;
	}
	return 0x82097BE8;
} // Block from 82097BD8h-82097BE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82097BE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097BE8);
		  /* 82097BE8h */ case    0:  		/* lwz R30, <#[R1 + 92]> */
		/* 82097BE8h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x0000005C) );
		/* 82097BE8h case    0:*/		return 0x82097BEC;
	}
	return 0x82097BEC;
} // Block from 82097BE8h-82097BECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82097BECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097BEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097BEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097BEC);
		  /* 82097BECh */ case    0:  		/* lwz R11, <#[R1 + 96]> */
		/* 82097BECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82097BECh case    0:*/		return 0x82097BF0;
		  /* 82097BF0h */ case    1:  		/* rlwinm. R10, R27, 0, 28, 29 */
		/* 82097BF0h case    1:*/		cpu::op::rlwinm<1,0,28,29>(regs,&regs.R10,regs.R27);
		/* 82097BF0h case    1:*/		return 0x82097BF4;
		  /* 82097BF4h */ case    2:  		/* subf R11, R7, R11 */
		/* 82097BF4h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 82097BF4h case    2:*/		return 0x82097BF8;
		  /* 82097BF8h */ case    3:  		/* subf R29, R30, R11 */
		/* 82097BF8h case    3:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R30,regs.R11);
		/* 82097BF8h case    3:*/		return 0x82097BFC;
		  /* 82097BFCh */ case    4:  		/* bc 4, CR0_EQ, 56 */
		/* 82097BFCh case    4:*/		if ( !regs.CR[0].eq ) { return 0x82097C34;  }
		/* 82097BFCh case    4:*/		return 0x82097C00;
	}
	return 0x82097C00;
} // Block from 82097BECh-82097C00h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82097C00h
// Function '_finite'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097C00);
		  /* 82097C00h */ case    0:  		/* mr R31, R29 */
		/* 82097C00h case    0:*/		regs.R31 = regs.R29;
		/* 82097C00h case    0:*/		return 0x82097C04;
		  /* 82097C04h */ case    1:  		/* cmpwi CR6, R29, 0 */
		/* 82097C04h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82097C04h case    1:*/		return 0x82097C08;
		  /* 82097C08h */ case    2:  		/* bc 4, CR6_GT, 44 */
		/* 82097C08h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82097C34;  }
		/* 82097C08h case    2:*/		return 0x82097C0C;
		  /* 82097C0Ch */ case    3:  		/* addi R5, R1, 80 */
		/* 82097C0Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82097C0Ch case    3:*/		return 0x82097C10;
		  /* 82097C10h */ case    4:  		/* mr R4, R18 */
		/* 82097C10h case    4:*/		regs.R4 = regs.R18;
		/* 82097C10h case    4:*/		return 0x82097C14;
		  /* 82097C14h */ case    5:  		/* li R3, 32 */
		/* 82097C14h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x20);
		/* 82097C14h case    5:*/		return 0x82097C18;
		  /* 82097C18h */ case    6:  		/* addi R31, R31, -1 */
		/* 82097C18h case    6:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82097C18h case    6:*/		return 0x82097C1C;
		  /* 82097C1Ch */ case    7:  		/* bl -2804 */
		/* 82097C1Ch case    7:*/		regs.LR = 0x82097C20; return 0x82097128;
		/* 82097C1Ch case    7:*/		return 0x82097C20;
	}
	return 0x82097C20;
} // Block from 82097C00h-82097C20h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82097C20h
// Function '_isnan'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097C20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097C20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097C20);
		  /* 82097C20h */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 82097C20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82097C20h case    0:*/		return 0x82097C24;
		  /* 82097C24h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 82097C24h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82097C24h case    1:*/		return 0x82097C28;
		  /* 82097C28h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 82097C28h case    2:*/		if ( regs.CR[6].eq ) { return 0x82097C34;  }
		/* 82097C28h case    2:*/		return 0x82097C2C;
		  /* 82097C2Ch */ case    3:  		/* cmpwi CR6, R31, 0 */
		/* 82097C2Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82097C2Ch case    3:*/		return 0x82097C30;
		  /* 82097C30h */ case    4:  		/* bc 12, CR6_GT, -36 */
		/* 82097C30h case    4:*/		if ( regs.CR[6].gt ) { return 0x82097C0C;  }
		/* 82097C30h case    4:*/		return 0x82097C34;
	}
	return 0x82097C34;
} // Block from 82097C20h-82097C34h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82097C34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097C34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097C34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097C34);
		  /* 82097C34h */ case    0:  		/* addi R6, R1, 80 */
		/* 82097C34h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 82097C34h case    0:*/		return 0x82097C38;
		  /* 82097C38h */ case    1:  		/* mr R5, R18 */
		/* 82097C38h case    1:*/		regs.R5 = regs.R18;
		/* 82097C38h case    1:*/		return 0x82097C3C;
		  /* 82097C3Ch */ case    2:  		/* mr R4, R30 */
		/* 82097C3Ch case    2:*/		regs.R4 = regs.R30;
		/* 82097C3Ch case    2:*/		return 0x82097C40;
		  /* 82097C40h */ case    3:  		/* addi R3, R1, 88 */
		/* 82097C40h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 82097C40h case    3:*/		return 0x82097C44;
		  /* 82097C44h */ case    4:  		/* bl -2692 */
		/* 82097C44h case    4:*/		regs.LR = 0x82097C48; return 0x820971C0;
		/* 82097C44h case    4:*/		return 0x82097C48;
		  /* 82097C48h */ case    5:  		/* rlwinm. R11, R27, 0, 28, 28 */
		/* 82097C48h case    5:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R27);
		/* 82097C48h case    5:*/		return 0x82097C4C;
		  /* 82097C4Ch */ case    6:  		/* bc 12, CR0_EQ, 64 */
		/* 82097C4Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x82097C8C;  }
		/* 82097C4Ch case    6:*/		return 0x82097C50;
		  /* 82097C50h */ case    7:  		/* rlwinm. R11, R27, 0, 29, 29 */
		/* 82097C50h case    7:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R27);
		/* 82097C50h case    7:*/		return 0x82097C54;
		  /* 82097C54h */ case    8:  		/* bc 4, CR0_EQ, 56 */
		/* 82097C54h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82097C8C;  }
		/* 82097C54h case    8:*/		return 0x82097C58;
		  /* 82097C58h */ case    9:  		/* mr R31, R29 */
		/* 82097C58h case    9:*/		regs.R31 = regs.R29;
		/* 82097C58h case    9:*/		return 0x82097C5C;
		  /* 82097C5Ch */ case   10:  		/* cmpwi CR6, R29, 0 */
		/* 82097C5Ch case   10:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82097C5Ch case   10:*/		return 0x82097C60;
		  /* 82097C60h */ case   11:  		/* bc 4, CR6_GT, 44 */
		/* 82097C60h case   11:*/		if ( !regs.CR[6].gt ) { return 0x82097C8C;  }
		/* 82097C60h case   11:*/		return 0x82097C64;
		  /* 82097C64h */ case   12:  		/* addi R5, R1, 80 */
		/* 82097C64h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82097C64h case   12:*/		return 0x82097C68;
	}
	return 0x82097C68;
} // Block from 82097C34h-82097C68h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82097C68h
// Function '_fpclass'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097C68);
		  /* 82097C68h */ case    0:  		/* mr R4, R18 */
		/* 82097C68h case    0:*/		regs.R4 = regs.R18;
		/* 82097C68h case    0:*/		return 0x82097C6C;
		  /* 82097C6Ch */ case    1:  		/* li R3, 48 */
		/* 82097C6Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x30);
		/* 82097C6Ch case    1:*/		return 0x82097C70;
		  /* 82097C70h */ case    2:  		/* addi R31, R31, -1 */
		/* 82097C70h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82097C70h case    2:*/		return 0x82097C74;
		  /* 82097C74h */ case    3:  		/* bl -2892 */
		/* 82097C74h case    3:*/		regs.LR = 0x82097C78; return 0x82097128;
		/* 82097C74h case    3:*/		return 0x82097C78;
		  /* 82097C78h */ case    4:  		/* lwz R11, <#[R1 + 80]> */
		/* 82097C78h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82097C78h case    4:*/		return 0x82097C7C;
		  /* 82097C7Ch */ case    5:  		/* cmpwi CR6, R11, -1 */
		/* 82097C7Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82097C7Ch case    5:*/		return 0x82097C80;
		  /* 82097C80h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 82097C80h case    6:*/		if ( regs.CR[6].eq ) { return 0x82097C8C;  }
		/* 82097C80h case    6:*/		return 0x82097C84;
		  /* 82097C84h */ case    7:  		/* cmpwi CR6, R31, 0 */
		/* 82097C84h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82097C84h case    7:*/		return 0x82097C88;
		  /* 82097C88h */ case    8:  		/* bc 12, CR6_GT, -36 */
		/* 82097C88h case    8:*/		if ( regs.CR[6].gt ) { return 0x82097C64;  }
		/* 82097C88h case    8:*/		return 0x82097C8C;
	}
	return 0x82097C8C;
} // Block from 82097C68h-82097C8Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82097C8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097C8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097C8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097C8C);
		  /* 82097C8Ch */ case    0:  		/* lwz R4, <#[R1 + 84]> */
		/* 82097C8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 82097C8Ch case    0:*/		return 0x82097C90;
		  /* 82097C90h */ case    1:  		/* cmpwi CR6, R16, 0 */
		/* 82097C90h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R16,0x00000000);
		/* 82097C90h case    1:*/		return 0x82097C94;
		  /* 82097C94h */ case    2:  		/* bc 12, CR6_EQ, 104 */
		/* 82097C94h case    2:*/		if ( regs.CR[6].eq ) { return 0x82097CFC;  }
		/* 82097C94h case    2:*/		return 0x82097C98;
		  /* 82097C98h */ case    3:  		/* cmpwi CR6, R4, 0 */
		/* 82097C98h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 82097C98h case    3:*/		return 0x82097C9C;
		  /* 82097C9Ch */ case    4:  		/* bc 4, CR6_GT, 96 */
		/* 82097C9Ch case    4:*/		if ( !regs.CR[6].gt ) { return 0x82097CFC;  }
		/* 82097C9Ch case    4:*/		return 0x82097CA0;
		  /* 82097CA0h */ case    5:  		/* addi R30, R28, -2 */
		/* 82097CA0h case    5:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R28,0xFFFFFFFE);
		/* 82097CA0h case    5:*/		return 0x82097CA4;
		  /* 82097CA4h */ case    6:  		/* mr R31, R4 */
		/* 82097CA4h case    6:*/		regs.R31 = regs.R4;
		/* 82097CA4h case    6:*/		return 0x82097CA8;
		  /* 82097CA8h */ case    7:  		/* li R5, 6 */
		/* 82097CA8h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x6);
		/* 82097CA8h case    7:*/		return 0x82097CAC;
		  /* 82097CACh */ case    8:  		/* lhzu R6, <#[R30 + 2]> */
		/* 82097CACh case    8:*/		cpu::mem::load16z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000002) );
		regs.R30 = (uint32)(regs.R30 + 0x00000002);
		/* 82097CACh case    8:*/		return 0x82097CB0;
		  /* 82097CB0h */ case    9:  		/* addi R4, R1, 116 */
		/* 82097CB0h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x74);
		/* 82097CB0h case    9:*/		return 0x82097CB4;
		  /* 82097CB4h */ case   10:  		/* addi R3, R1, 112 */
		/* 82097CB4h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 82097CB4h case   10:*/		return 0x82097CB8;
		  /* 82097CB8h */ case   11:  		/* addi R31, R31, -1 */
		/* 82097CB8h case   11:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82097CB8h case   11:*/		return 0x82097CBC;
		  /* 82097CBCh */ case   12:  		/* bl 13332 */
		/* 82097CBCh case   12:*/		regs.LR = 0x82097CC0; return 0x8209B0D0;
		/* 82097CBCh case   12:*/		return 0x82097CC0;
		  /* 82097CC0h */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 82097CC0h case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82097CC0h case   13:*/		return 0x82097CC4;
		  /* 82097CC4h */ case   14:  		/* bc 4, CR0_EQ, 44 */
		/* 82097CC4h case   14:*/		if ( !regs.CR[0].eq ) { return 0x82097CF0;  }
		/* 82097CC4h case   14:*/		return 0x82097CC8;
		  /* 82097CC8h */ case   15:  		/* lwz R4, <#[R1 + 112]> */
		/* 82097CC8h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000070) );
		/* 82097CC8h case   15:*/		return 0x82097CCC;
		  /* 82097CCCh */ case   16:  		/* cmpwi CR6, R4, 0 */
		/* 82097CCCh case   16:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 82097CCCh case   16:*/		return 0x82097CD0;
		  /* 82097CD0h */ case   17:  		/* bc 12, CR6_EQ, 32 */
		/* 82097CD0h case   17:*/		if ( regs.CR[6].eq ) { return 0x82097CF0;  }
		/* 82097CD0h case   17:*/		return 0x82097CD4;
		  /* 82097CD4h */ case   18:  		/* addi R6, R1, 80 */
		/* 82097CD4h case   18:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 82097CD4h case   18:*/		return 0x82097CD8;
		  /* 82097CD8h */ case   19:  		/* mr R5, R18 */
		/* 82097CD8h case   19:*/		regs.R5 = regs.R18;
		/* 82097CD8h case   19:*/		return 0x82097CDC;
		  /* 82097CDCh */ case   20:  		/* addi R3, R1, 116 */
		/* 82097CDCh case   20:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x74);
		/* 82097CDCh case   20:*/		return 0x82097CE0;
		  /* 82097CE0h */ case   21:  		/* bl -2848 */
		/* 82097CE0h case   21:*/		regs.LR = 0x82097CE4; return 0x820971C0;
		/* 82097CE0h case   21:*/		return 0x82097CE4;
		  /* 82097CE4h */ case   22:  		/* cmpwi CR6, R31, 0 */
		/* 82097CE4h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82097CE4h case   22:*/		return 0x82097CE8;
		  /* 82097CE8h */ case   23:  		/* bc 4, CR6_EQ, -64 */
		/* 82097CE8h case   23:*/		if ( !regs.CR[6].eq ) { return 0x82097CA8;  }
		/* 82097CE8h case   23:*/		return 0x82097CEC;
		  /* 82097CECh */ case   24:  		/* b 32 */
		/* 82097CECh case   24:*/		return 0x82097D0C;
		/* 82097CECh case   24:*/		return 0x82097CF0;
	}
	return 0x82097CF0;
} // Block from 82097C8Ch-82097CF0h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82097CF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097CF0);
		  /* 82097CF0h */ case    0:  		/* li R24, -1 */
		/* 82097CF0h case    0:*/		cpu::op::li<0>(regs,&regs.R24,0xFFFFFFFF);
		/* 82097CF0h case    0:*/		return 0x82097CF4;
		  /* 82097CF4h */ case    1:  		/* stw R24, <#[R1 + 80]> */
		/* 82097CF4h case    1:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000050) );
		/* 82097CF4h case    1:*/		return 0x82097CF8;
		  /* 82097CF8h */ case    2:  		/* b 24 */
		/* 82097CF8h case    2:*/		return 0x82097D10;
		/* 82097CF8h case    2:*/		return 0x82097CFC;
	}
	return 0x82097CFC;
} // Block from 82097CF0h-82097CFCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82097CFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097CFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097CFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097CFC);
		  /* 82097CFCh */ case    0:  		/* addi R6, R1, 80 */
		/* 82097CFCh case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 82097CFCh case    0:*/		return 0x82097D00;
		  /* 82097D00h */ case    1:  		/* mr R5, R18 */
		/* 82097D00h case    1:*/		regs.R5 = regs.R18;
		/* 82097D00h case    1:*/		return 0x82097D04;
		  /* 82097D04h */ case    2:  		/* mr R3, R28 */
		/* 82097D04h case    2:*/		regs.R3 = regs.R28;
		/* 82097D04h case    2:*/		return 0x82097D08;
		  /* 82097D08h */ case    3:  		/* bl -2888 */
		/* 82097D08h case    3:*/		regs.LR = 0x82097D0C; return 0x820971C0;
		/* 82097D08h case    3:*/		return 0x82097D0C;
	}
	return 0x82097D0C;
} // Block from 82097CFCh-82097D0Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82097D0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097D0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097D0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097D0C);
		  /* 82097D0Ch */ case    0:  		/* lwz R24, <#[R1 + 80]> */
		/* 82097D0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000050) );
		/* 82097D0Ch case    0:*/		return 0x82097D10;
	}
	return 0x82097D10;
} // Block from 82097D0Ch-82097D10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82097D10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097D10);
		  /* 82097D10h */ case    0:  		/* cmpwi CR6, R24, 0 */
		/* 82097D10h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 82097D10h case    0:*/		return 0x82097D14;
		  /* 82097D14h */ case    1:  		/* bc 12, CR6_LT, 64 */
		/* 82097D14h case    1:*/		if ( regs.CR[6].lt ) { return 0x82097D54;  }
		/* 82097D14h case    1:*/		return 0x82097D18;
		  /* 82097D18h */ case    2:  		/* rlwinm. R11, R27, 0, 29, 29 */
		/* 82097D18h case    2:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R27);
		/* 82097D18h case    2:*/		return 0x82097D1C;
		  /* 82097D1Ch */ case    3:  		/* bc 12, CR0_EQ, 56 */
		/* 82097D1Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x82097D54;  }
		/* 82097D1Ch case    3:*/		return 0x82097D20;
		  /* 82097D20h */ case    4:  		/* mr R31, R29 */
		/* 82097D20h case    4:*/		regs.R31 = regs.R29;
		/* 82097D20h case    4:*/		return 0x82097D24;
		  /* 82097D24h */ case    5:  		/* cmpwi CR6, R29, 0 */
		/* 82097D24h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82097D24h case    5:*/		return 0x82097D28;
		  /* 82097D28h */ case    6:  		/* bc 4, CR6_GT, 44 */
		/* 82097D28h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82097D54;  }
		/* 82097D28h case    6:*/		return 0x82097D2C;
		  /* 82097D2Ch */ case    7:  		/* addi R5, R1, 80 */
		/* 82097D2Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82097D2Ch case    7:*/		return 0x82097D30;
		  /* 82097D30h */ case    8:  		/* mr R4, R18 */
		/* 82097D30h case    8:*/		regs.R4 = regs.R18;
		/* 82097D30h case    8:*/		return 0x82097D34;
		  /* 82097D34h */ case    9:  		/* li R3, 32 */
		/* 82097D34h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x20);
		/* 82097D34h case    9:*/		return 0x82097D38;
		  /* 82097D38h */ case   10:  		/* addi R31, R31, -1 */
		/* 82097D38h case   10:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82097D38h case   10:*/		return 0x82097D3C;
		  /* 82097D3Ch */ case   11:  		/* bl -3092 */
		/* 82097D3Ch case   11:*/		regs.LR = 0x82097D40; return 0x82097128;
		/* 82097D3Ch case   11:*/		return 0x82097D40;
	}
	return 0x82097D40;
} // Block from 82097D10h-82097D40h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82097D40h
// Function '__savefpr'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097D40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097D40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097D40);
		  /* 82097D40h */ case    0:  		/* lwz R24, <#[R1 + 80]> */
		/* 82097D40h case    0:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000050) );
		/* 82097D40h case    0:*/		return 0x82097D44;
		  /* 82097D44h */ case    1:  		/* cmpwi CR6, R24, -1 */
		/* 82097D44h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R24,0xFFFFFFFF);
		/* 82097D44h case    1:*/		return 0x82097D48;
		  /* 82097D48h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 82097D48h case    2:*/		if ( regs.CR[6].eq ) { return 0x82097D54;  }
		/* 82097D48h case    2:*/		return 0x82097D4C;
		  /* 82097D4Ch */ case    3:  		/* cmpwi CR6, R31, 0 */
		/* 82097D4Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82097D4Ch case    3:*/		return 0x82097D50;
		  /* 82097D50h */ case    4:  		/* bc 12, CR6_GT, -36 */
		/* 82097D50h case    4:*/		if ( regs.CR[6].gt ) { return 0x82097D2C;  }
		/* 82097D50h case    4:*/		return 0x82097D54;
	}
	return 0x82097D54;
} // Block from 82097D40h-82097D54h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82097D54h
// Function '__savefpr_19'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097D54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097D54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097D54);
		  /* 82097D54h */ case    0:  		/* cmplwi CR6, R14, 0 */
		/* 82097D54h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 82097D54h case    0:*/		return 0x82097D58;
		  /* 82097D58h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 82097D58h case    1:*/		if ( regs.CR[6].eq ) { return 0x82097D68;  }
		/* 82097D58h case    1:*/		return 0x82097D5C;
	}
	return 0x82097D5C;
} // Block from 82097D54h-82097D5Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82097D5Ch
// Function '__savefpr_21'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097D5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097D5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097D5C);
		  /* 82097D5Ch */ case    0:  		/* mr R3, R14 */
		/* 82097D5Ch case    0:*/		regs.R3 = regs.R14;
		/* 82097D5Ch case    0:*/		return 0x82097D60;
		  /* 82097D60h */ case    1:  		/* bl -17720 */
		/* 82097D60h case    1:*/		regs.LR = 0x82097D64; return 0x82093828;
		/* 82097D60h case    1:*/		return 0x82097D64;
		  /* 82097D64h */ case    2:  		/* li R14, 0 */
		/* 82097D64h case    2:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 82097D64h case    2:*/		return 0x82097D68;
	}
	return 0x82097D68;
} // Block from 82097D5Ch-82097D68h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82097D68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097D68);
		  /* 82097D68h */ case    0:  		/* lbz R29, <#[R19 + 1]> */
		/* 82097D68h case    0:*/		cpu::mem::load8z( regs, &regs.R29, (uint32)(regs.R19 + 0x00000001) );
		/* 82097D68h case    0:*/		return 0x82097D6C;
	}
	return 0x82097D6C;
} // Block from 82097D68h-82097D6Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82097D6Ch
// Function '__savefpr_25'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097D6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097D6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097D6C);
		  /* 82097D6Ch */ case    0:  		/* extsb. R8, R29 */
		/* 82097D6Ch case    0:*/		cpu::op::extsb<1>(regs,&regs.R8,regs.R29);
		/* 82097D6Ch case    0:*/		return 0x82097D70;
	}
	return 0x82097D70;
} // Block from 82097D6Ch-82097D70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82097D70h
// Function '__savefpr_26'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097D70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097D70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097D70);
		  /* 82097D70h */ case    0:  		/* bc 12, CR0_EQ, 16 */
		/* 82097D70h case    0:*/		if ( regs.CR[0].eq ) { return 0x82097D80;  }
		/* 82097D70h case    0:*/		return 0x82097D74;
	}
	return 0x82097D74;
} // Block from 82097D70h-82097D74h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82097D74h
// Function '__savefpr_27'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097D74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097D74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097D74);
		  /* 82097D74h */ case    0:  		/* lwz R7, <#[R1 + 84]> */
		/* 82097D74h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000054) );
		/* 82097D74h case    0:*/		return 0x82097D78;
	}
	return 0x82097D78;
} // Block from 82097D74h-82097D78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82097D78h
// Function '__savefpr_28'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097D78);
		  /* 82097D78h */ case    0:  		/* li R30, 0 */
		/* 82097D78h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82097D78h case    0:*/		return 0x82097D7C;
		  /* 82097D7Ch */ case    1:  		/* b -2432 */
		/* 82097D7Ch case    1:*/		return 0x820973FC;
		/* 82097D7Ch case    1:*/		return 0x82097D80;
	}
	return 0x82097D80;
} // Block from 82097D78h-82097D80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82097D80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097D80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097D80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097D80);
		  /* 82097D80h */ case    0:  		/* lwz R11, <#[R1 + 100]> */
		/* 82097D80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82097D80h case    0:*/		return 0x82097D84;
		  /* 82097D84h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82097D84h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82097D84h case    1:*/		return 0x82097D88;
		  /* 82097D88h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 82097D88h case    2:*/		if ( regs.CR[6].eq ) { return 0x82097D94;  }
		/* 82097D88h case    2:*/		return 0x82097D8C;
	}
	return 0x82097D8C;
} // Block from 82097D80h-82097D8Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82097D8Ch
// Function '__restfpr_14'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097D8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097D8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097D8C);
		  /* 82097D8Ch */ case    0:  		/* cmpwi CR6, R11, 7 */
		/* 82097D8Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000007);
		/* 82097D8Ch case    0:*/		return 0x82097D90;
		  /* 82097D90h */ case    1:  		/* bc 4, CR6_EQ, -2752 */
		/* 82097D90h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820972D0;  }
		/* 82097D90h case    1:*/		return 0x82097D94;
	}
	return 0x82097D94;
} // Block from 82097D8Ch-82097D94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82097D94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097D94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097D94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097D94);
		  /* 82097D94h */ case    0:  		/* mr R3, R24 */
		/* 82097D94h case    0:*/		regs.R3 = regs.R24;
		/* 82097D94h case    0:*/		return 0x82097D98;
		  /* 82097D98h */ case    1:  		/* b 56 */
		/* 82097D98h case    1:*/		return 0x82097DD0;
		/* 82097D98h case    1:*/		return 0x82097D9C;
	}
	return 0x82097D9C;
} // Block from 82097D94h-82097D9Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82097D9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097D9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097D9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097D9C);
		  /* 82097D9Ch */ case    0:  		/* mr R6, R26 */
		/* 82097D9Ch case    0:*/		regs.R6 = regs.R26;
		/* 82097D9Ch case    0:*/		return 0x82097DA0;
	}
	return 0x82097DA0;
} // Block from 82097D9Ch-82097DA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82097DA0h
// Function '__restfpr_19'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097DA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097DA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097DA0);
		  /* 82097DA0h */ case    0:  		/* mr R5, R31 */
		/* 82097DA0h case    0:*/		regs.R5 = regs.R31;
		/* 82097DA0h case    0:*/		return 0x82097DA4;
		  /* 82097DA4h */ case    1:  		/* li R4, 512 */
		/* 82097DA4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x200);
		/* 82097DA4h case    1:*/		return 0x82097DA8;
	}
	return 0x82097DA8;
} // Block from 82097DA0h-82097DA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82097DA8h
// Function '__restfpr_21'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097DA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097DA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097DA8);
		  /* 82097DA8h */ case    0:  		/* addi R3, R1, 656 */
		/* 82097DA8h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x290);
		/* 82097DA8h case    0:*/		return 0x82097DAC;
		  /* 82097DACh */ case    1:  		/* bl 12828 */
		/* 82097DACh case    1:*/		regs.LR = 0x82097DB0; return 0x8209AFC8;
		/* 82097DACh case    1:*/		return 0x82097DB0;
		  /* 82097DB0h */ case    2:  		/* mr R31, R3 */
		/* 82097DB0h case    2:*/		regs.R31 = regs.R3;
		/* 82097DB0h case    2:*/		return 0x82097DB4;
		  /* 82097DB4h */ case    3:  		/* cmpwi CR6, R3, -1 */
		/* 82097DB4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82097DB4h case    3:*/		return 0x82097DB8;
	}
	return 0x82097DB8;
} // Block from 82097DA8h-82097DB8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82097DB8h
// Function '__restfpr_25'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097DB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097DB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097DB8);
		  /* 82097DB8h */ case    0:  		/* bc 4, CR6_EQ, 12 */
		/* 82097DB8h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82097DC4;  }
		/* 82097DB8h case    0:*/		return 0x82097DBC;
	}
	return 0x82097DBC;
} // Block from 82097DB8h-82097DBCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82097DBCh
// Function '__restfpr_26'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097DBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097DBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097DBC);
		  /* 82097DBCh */ case    0:  		/* li R31, 511 */
		/* 82097DBCh case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x1FF);
		/* 82097DBCh case    0:*/		return 0x82097DC0;
	}
	return 0x82097DC0;
} // Block from 82097DBCh-82097DC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82097DC0h
// Function '__restfpr_27'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097DC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097DC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097DC0);
		  /* 82097DC0h */ case    0:  		/* stb R30, <#[R1 + 1167]> */
		/* 82097DC0h case    0:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R1 + 0x0000048F) );
		/* 82097DC0h case    0:*/		return 0x82097DC4;
	}
	return 0x82097DC4;
} // Block from 82097DC0h-82097DC4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82097DC4h
// Function '__restfpr_28'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097DC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097DC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097DC4);
		  /* 82097DC4h */ case    0:  		/* addi R3, R1, 656 */
		/* 82097DC4h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x290);
		/* 82097DC4h case    0:*/		return 0x82097DC8;
		  /* 82097DC8h */ case    1:  		/* bl -64112 */
		/* 82097DC8h case    1:*/		regs.LR = 0x82097DCC; return 0x82088358;
		/* 82097DC8h case    1:*/		return 0x82097DCC;
		  /* 82097DCCh */ case    2:  		/* mr R3, R31 */
		/* 82097DCCh case    2:*/		regs.R3 = regs.R31;
		/* 82097DCCh case    2:*/		return 0x82097DD0;
	}
	return 0x82097DD0;
} // Block from 82097DC4h-82097DD0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82097DD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097DD0);
		  /* 82097DD0h */ case    0:  		/* addi R1, R1, 1328 */
		/* 82097DD0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x530);
		/* 82097DD0h case    0:*/		return 0x82097DD4;
		  /* 82097DD4h */ case    1:  		/* b -27492 */
		/* 82097DD4h case    1:*/		return 0x82091270;
		/* 82097DD4h case    1:*/		return 0x82097DD8;
	}
	return 0x82097DD8;
} // Block from 82097DD0h-82097DD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82097DD8h
// Function '_raise_exc_ex'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097DD8);
		  /* 82097DD8h */ case    0:  		/* lis R11, -32256 */
		/* 82097DD8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82097DD8h case    0:*/		return 0x82097DDC;
		  /* 82097DDCh */ case    1:  		/* stfd FR1, <#[R1 + 16]> */
		/* 82097DDCh case    1:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000010) );
		/* 82097DDCh case    1:*/		return 0x82097DE0;
		  /* 82097DE0h */ case    2:  		/* lfd FR6, <#[R11 + 1848]> */
		/* 82097DE0h case    2:*/		cpu::mem::load64f( regs, &regs.FR6, (uint32)(regs.R11 + 0x00000738) );
		/* 82097DE0h case    2:*/		return 0x82097DE4;
		  /* 82097DE4h */ case    3:  		/* fcmpu CR6, FR1, FR6 */
		/* 82097DE4h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR6);
		/* 82097DE4h case    3:*/		return 0x82097DE8;
		  /* 82097DE8h */ case    4:  		/* bc 4, CR6_EQ, 16 */
		/* 82097DE8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82097DF8;  }
		/* 82097DE8h case    4:*/		return 0x82097DEC;
		  /* 82097DECh */ case    5:  		/* lis R11, -32256 */
		/* 82097DECh case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82097DECh case    5:*/		return 0x82097DF0;
		  /* 82097DF0h */ case    6:  		/* lfd FR1, <#[R11 + 1808]> */
		/* 82097DF0h case    6:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000710) );
		/* 82097DF0h case    6:*/		return 0x82097DF4;
		  /* 82097DF4h */ case    7:  		/* bclr 20, CR0_LT */
		/* 82097DF4h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82097DF4h case    7:*/		return 0x82097DF8;
	}
	return 0x82097DF8;
} // Block from 82097DD8h-82097DF8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82097DF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097DF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097DF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097DF8);
		  /* 82097DF8h */ case    0:  		/* lhz R10, <#[R1 + 16]> */
		/* 82097DF8h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000010) );
		/* 82097DF8h case    0:*/		return 0x82097DFC;
		  /* 82097DFCh */ case    1:  		/* rlwinm R11, R10, 0, 17, 27 */
		/* 82097DFCh case    1:*/		cpu::op::rlwinm<0,0,17,27>(regs,&regs.R11,regs.R10);
		/* 82097DFCh case    1:*/		return 0x82097E00;
		  /* 82097E00h */ case    2:  		/* mr R9, R10 */
		/* 82097E00h case    2:*/		regs.R9 = regs.R10;
		/* 82097E00h case    2:*/		return 0x82097E04;
		  /* 82097E04h */ case    3:  		/* cmplwi CR6, R11, 32752 */
		/* 82097E04h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00007FF0);
		/* 82097E04h case    3:*/		return 0x82097E08;
		  /* 82097E08h */ case    4:  		/* bc 4, CR6_EQ, 36 */
		/* 82097E08h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82097E2C;  }
		/* 82097E08h case    4:*/		return 0x82097E0C;
		  /* 82097E0Ch */ case    5:  		/* lis R11, -32255 */
		/* 82097E0Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82097E0Ch case    5:*/		return 0x82097E10;
		  /* 82097E10h */ case    6:  		/* lfd FR0, <#[R11 - 21136]> */
		/* 82097E10h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFAD70) );
		/* 82097E10h case    6:*/		return 0x82097E14;
		  /* 82097E14h */ case    7:  		/* fcmpu CR6, FR1, FR0 */
		/* 82097E14h case    7:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82097E14h case    7:*/		return 0x82097E18;
		  /* 82097E18h */ case    8:  		/* bclr 12, CR6_GT */
		/* 82097E18h case    8:*/		if ( regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 82097E18h case    8:*/		return 0x82097E1C;
	}
	return 0x82097E1C;
} // Block from 82097DF8h-82097E1Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82097E1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097E1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097E1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097E1C);
		  /* 82097E1Ch */ case    0:  		/* lis R11, -32217 */
		/* 82097E1Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82097E1Ch case    0:*/		return 0x82097E20;
		  /* 82097E20h */ case    1:  		/* lfd FR0, <#[R11 + 7336]> */
		/* 82097E20h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001CA8) );
		/* 82097E20h case    1:*/		return 0x82097E24;
		  /* 82097E24h */ case    2:  		/* fneg FR1, FR0 */
		/* 82097E24h case    2:*/		cpu::op::fneg<0>(regs,&regs.FR1,regs.FR0);
		/* 82097E24h case    2:*/		return 0x82097E28;
		  /* 82097E28h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82097E28h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82097E28h case    3:*/		return 0x82097E2C;
	}
	return 0x82097E2C;
} // Block from 82097E1Ch-82097E2Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82097E2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097E2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097E2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097E2C);
		  /* 82097E2Ch */ case    0:  		/* lis R10, -32256 */
		/* 82097E2Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82097E2Ch case    0:*/		return 0x82097E30;
		  /* 82097E30h */ case    1:  		/* lfd FR0, <#[R10 + 1808]> */
		/* 82097E30h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000710) );
		/* 82097E30h case    1:*/		return 0x82097E34;
		  /* 82097E34h */ case    2:  		/* fcmpu CR6, FR1, FR0 */
		/* 82097E34h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82097E34h case    2:*/		return 0x82097E38;
		  /* 82097E38h */ case    3:  		/* bc 12, CR6_GT, 24 */
		/* 82097E38h case    3:*/		if ( regs.CR[6].gt ) { return 0x82097E50;  }
		/* 82097E38h case    3:*/		return 0x82097E3C;
		  /* 82097E3Ch */ case    4:  		/* fcmpu CR6, FR1, FR0 */
		/* 82097E3Ch case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82097E3Ch case    4:*/		return 0x82097E40;
		  /* 82097E40h */ case    5:  		/* bc 4, CR6_EQ, -36 */
		/* 82097E40h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82097E1C;  }
		/* 82097E40h case    5:*/		return 0x82097E44;
		  /* 82097E44h */ case    6:  		/* lis R11, -32217 */
		/* 82097E44h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82097E44h case    6:*/		return 0x82097E48;
		  /* 82097E48h */ case    7:  		/* lfd FR0, <#[R11 + 7328]> */
		/* 82097E48h case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001CA0) );
		/* 82097E48h case    7:*/		return 0x82097E4C;
		  /* 82097E4Ch */ case    8:  		/* b -40 */
		/* 82097E4Ch case    8:*/		return 0x82097E24;
		/* 82097E4Ch case    8:*/		return 0x82097E50;
	}
	return 0x82097E50;
} // Block from 82097E2Ch-82097E50h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82097E50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097E50);
		  /* 82097E50h */ case    0:  		/* lis R10, -32255 */
		/* 82097E50h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 82097E50h case    0:*/		return 0x82097E54;
		  /* 82097E54h */ case    1:  		/* lfd FR0, <#[R10 - 21144]> */
		/* 82097E54h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0xFFFFAD68) );
		/* 82097E54h case    1:*/		return 0x82097E58;
		  /* 82097E58h */ case    2:  		/* fcmpu CR6, FR1, FR0 */
		/* 82097E58h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82097E58h case    2:*/		return 0x82097E5C;
		  /* 82097E5Ch */ case    3:  		/* bc 4, CR6_LT, 44 */
		/* 82097E5Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x82097E88;  }
		/* 82097E5Ch case    3:*/		return 0x82097E60;
		  /* 82097E60h */ case    4:  		/* lis R11, -32255 */
		/* 82097E60h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82097E60h case    4:*/		return 0x82097E64;
		  /* 82097E64h */ case    5:  		/* lfd FR0, <#[R11 - 21152]> */
		/* 82097E64h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFAD60) );
		/* 82097E64h case    5:*/		return 0x82097E68;
		  /* 82097E68h */ case    6:  		/* fmul FR1, FR1, FR0 */
		/* 82097E68h case    6:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR1,regs.FR0);
		/* 82097E68h case    6:*/		return 0x82097E6C;
		  /* 82097E6Ch */ case    7:  		/* stfd FR1, <#[R1 + 16]> */
		/* 82097E6Ch case    7:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000010) );
		/* 82097E6Ch case    7:*/		return 0x82097E70;
		  /* 82097E70h */ case    8:  		/* lhz R11, <#[R1 + 16]> */
		/* 82097E70h case    8:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000010) );
		/* 82097E70h case    8:*/		return 0x82097E74;
		  /* 82097E74h */ case    9:  		/* rlwinm R10, R11, 28, 21, 31 */
		/* 82097E74h case    9:*/		cpu::op::rlwinm<0,28,21,31>(regs,&regs.R10,regs.R11);
		/* 82097E74h case    9:*/		return 0x82097E78;
		  /* 82097E78h */ case   10:  		/* mr R9, R11 */
		/* 82097E78h case   10:*/		regs.R9 = regs.R11;
		/* 82097E78h case   10:*/		return 0x82097E7C;
		  /* 82097E7Ch */ case   11:  		/* mr R11, R10 */
		/* 82097E7Ch case   11:*/		regs.R11 = regs.R10;
		/* 82097E7Ch case   11:*/		return 0x82097E80;
		  /* 82097E80h */ case   12:  		/* addi R10, R10, -1075 */
		/* 82097E80h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFBCD);
		/* 82097E80h case   12:*/		return 0x82097E84;
		  /* 82097E84h */ case   13:  		/* b 12 */
		/* 82097E84h case   13:*/		return 0x82097E90;
		/* 82097E84h case   13:*/		return 0x82097E88;
	}
	return 0x82097E88;
} // Block from 82097E50h-82097E88h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82097E88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097E88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097E88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097E88);
		  /* 82097E88h */ case    0:  		/* rlwinm R11, R11, 28, 20, 31 */
		/* 82097E88h case    0:*/		cpu::op::rlwinm<0,28,20,31>(regs,&regs.R11,regs.R11);
		/* 82097E88h case    0:*/		return 0x82097E8C;
		  /* 82097E8Ch */ case    1:  		/* addi R10, R11, -1022 */
		/* 82097E8Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFC02);
		/* 82097E8Ch case    1:*/		return 0x82097E90;
	}
	return 0x82097E90;
} // Block from 82097E88h-82097E90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82097E90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097E90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097E90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097E90);
		  /* 82097E90h */ case    0:  		/* lis R11, -32255 */
		/* 82097E90h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82097E90h case    0:*/		return 0x82097E94;
		  /* 82097E94h */ case    1:  		/* stfd FR1, <#[R1 - 16]> */
		/* 82097E94h case    1:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82097E94h case    1:*/		return 0x82097E98;
		  /* 82097E98h */ case    2:  		/* andi. R9, R9, 32783 */
		/* 82097E98h case    2:*/		cpu::op::andi<1>(regs,&regs.R9,regs.R9,0x800F);
		/* 82097E98h case    2:*/		return 0x82097E9C;
		  /* 82097E9Ch */ case    3:  		/* addi R11, R11, -21272 */
		/* 82097E9Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFACE8);
		/* 82097E9Ch case    3:*/		return 0x82097EA0;
		  /* 82097EA0h */ case    4:  		/* ori R9, R9, 16352 */
		/* 82097EA0h case    4:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x3FE0);
		/* 82097EA0h case    4:*/		return 0x82097EA4;
		  /* 82097EA4h */ case    5:  		/* sth R9, <#[R1 - 16]> */
		/* 82097EA4h case    5:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82097EA4h case    5:*/		return 0x82097EA8;
		  /* 82097EA8h */ case    6:  		/* lfd FR13, <#[R1 - 16]> */
		/* 82097EA8h case    6:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82097EA8h case    6:*/		return 0x82097EAC;
		  /* 82097EACh */ case    7:  		/* lis R9, -32256 */
		/* 82097EACh case    7:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 82097EACh case    7:*/		return 0x82097EB0;
		  /* 82097EB0h */ case    8:  		/* lfd FR0, <#[R11]> */
		/* 82097EB0h case    8:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000000) );
		/* 82097EB0h case    8:*/		return 0x82097EB4;
		  /* 82097EB4h */ case    9:  		/* fcmpu CR6, FR13, FR0 */
		/* 82097EB4h case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 82097EB4h case    9:*/		return 0x82097EB8;
		  /* 82097EB8h */ case   10:  		/* bc 4, CR6_GT, 28 */
		/* 82097EB8h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82097ED4;  }
		/* 82097EB8h case   10:*/		return 0x82097EBC;
		  /* 82097EBCh */ case   11:  		/* lfd FR0, <#[R9 + 4736]> */
		/* 82097EBCh case   11:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00001280) );
		/* 82097EBCh case   11:*/		return 0x82097EC0;
		  /* 82097EC0h */ case   12:  		/* fadd FR12, FR13, FR6 */
		/* 82097EC0h case   12:*/		cpu::op::fadd<0>(regs,&regs.FR12,regs.FR13,regs.FR6);
		/* 82097EC0h case   12:*/		return 0x82097EC4;
		  /* 82097EC4h */ case   13:  		/* fsub FR11, FR13, FR0 */
		/* 82097EC4h case   13:*/		cpu::op::fsub<0>(regs,&regs.FR11,regs.FR13,regs.FR0);
		/* 82097EC4h case   13:*/		return 0x82097EC8;
		  /* 82097EC8h */ case   14:  		/* fmul FR13, FR12, FR0 */
		/* 82097EC8h case   14:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR12,regs.FR0);
		/* 82097EC8h case   14:*/		return 0x82097ECC;
		  /* 82097ECCh */ case   15:  		/* fsub FR0, FR11, FR0 */
		/* 82097ECCh case   15:*/		cpu::op::fsub<0>(regs,&regs.FR0,regs.FR11,regs.FR0);
		/* 82097ECCh case   15:*/		return 0x82097ED0;
		  /* 82097ED0h */ case   16:  		/* b 24 */
		/* 82097ED0h case   16:*/		return 0x82097EE8;
		/* 82097ED0h case   16:*/		return 0x82097ED4;
	}
	return 0x82097ED4;
} // Block from 82097E90h-82097ED4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82097ED4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097ED4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097ED4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097ED4);
		  /* 82097ED4h */ case    0:  		/* lfd FR12, <#[R9 + 4736]> */
		/* 82097ED4h case    0:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R9 + 0x00001280) );
		/* 82097ED4h case    0:*/		return 0x82097ED8;
		  /* 82097ED8h */ case    1:  		/* addi R10, R10, -1 */
		/* 82097ED8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82097ED8h case    1:*/		return 0x82097EDC;
		  /* 82097EDCh */ case    2:  		/* fsub FR0, FR13, FR12 */
		/* 82097EDCh case    2:*/		cpu::op::fsub<0>(regs,&regs.FR0,regs.FR13,regs.FR12);
		/* 82097EDCh case    2:*/		return 0x82097EE0;
		  /* 82097EE0h */ case    3:  		/* fadd FR13, FR0, FR6 */
		/* 82097EE0h case    3:*/		cpu::op::fadd<0>(regs,&regs.FR13,regs.FR0,regs.FR6);
		/* 82097EE0h case    3:*/		return 0x82097EE4;
		  /* 82097EE4h */ case    4:  		/* fmul FR13, FR13, FR12 */
		/* 82097EE4h case    4:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR13,regs.FR12);
		/* 82097EE4h case    4:*/		return 0x82097EE8;
	}
	return 0x82097EE8;
} // Block from 82097ED4h-82097EE8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82097EE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097EE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097EE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097EE8);
		  /* 82097EE8h */ case    0:  		/* fdiv FR5, FR0, FR13 */
		/* 82097EE8h case    0:*/		cpu::op::fdiv<0>(regs,&regs.FR5,regs.FR0,regs.FR13);
		/* 82097EE8h case    0:*/		return 0x82097EEC;
		  /* 82097EECh */ case    1:  		/* lis R9, -32255 */
		/* 82097EECh case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 82097EECh case    1:*/		return 0x82097EF0;
		  /* 82097EF0h */ case    2:  		/* lis R8, -32255 */
		/* 82097EF0h case    2:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8201);
		/* 82097EF0h case    2:*/		return 0x82097EF4;
		  /* 82097EF4h */ case    3:  		/* lfd FR12, <#[R11 + 40]> */
		/* 82097EF4h case    3:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000028) );
		/* 82097EF4h case    3:*/		return 0x82097EF8;
		  /* 82097EF8h */ case    4:  		/* lis R7, -32255 */
		/* 82097EF8h case    4:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8201);
		/* 82097EF8h case    4:*/		return 0x82097EFC;
		  /* 82097EFCh */ case    5:  		/* lfd FR9, <#[R11 + 64]> */
		/* 82097EFCh case    5:*/		cpu::mem::load64f( regs, &regs.FR9, (uint32)(regs.R11 + 0x00000040) );
		/* 82097EFCh case    5:*/		return 0x82097F00;
		  /* 82097F00h */ case    6:  		/* lis R6, -32255 */
		/* 82097F00h case    6:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8201);
		/* 82097F00h case    6:*/		return 0x82097F04;
		  /* 82097F04h */ case    7:  		/* lfd FR7, <#[R11 + 8]> */
		/* 82097F04h case    7:*/		cpu::mem::load64f( regs, &regs.FR7, (uint32)(regs.R11 + 0x00000008) );
		/* 82097F04h case    7:*/		return 0x82097F08;
		  /* 82097F08h */ case    8:  		/* extsw R11, R10 */
		/* 82097F08h case    8:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R10);
		/* 82097F08h case    8:*/		return 0x82097F0C;
		  /* 82097F0Ch */ case    9:  		/* lfd FR13, <#[R9 - 21160]> */
		/* 82097F0Ch case    9:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R9 + 0xFFFFAD58) );
		/* 82097F0Ch case    9:*/		return 0x82097F10;
		  /* 82097F10h */ case   10:  		/* lis R10, -32255 */
		/* 82097F10h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 82097F10h case   10:*/		return 0x82097F14;
		  /* 82097F14h */ case   11:  		/* lfd FR11, <#[R8 - 21168]> */
		/* 82097F14h case   11:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R8 + 0xFFFFAD50) );
		/* 82097F14h case   11:*/		return 0x82097F18;
		  /* 82097F18h */ case   12:  		/* std R11, <#[R1 - 16]> */
		/* 82097F18h case   12:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82097F18h case   12:*/		return 0x82097F1C;
		  /* 82097F1Ch */ case   13:  		/* lfd FR10, <#[R7 - 21176]> */
		/* 82097F1Ch case   13:*/		cpu::mem::load64f( regs, &regs.FR10, (uint32)(regs.R7 + 0xFFFFAD48) );
		/* 82097F1Ch case   13:*/		return 0x82097F20;
		  /* 82097F20h */ case   14:  		/* lfd FR8, <#[R6 - 21184]> */
		/* 82097F20h case   14:*/		cpu::mem::load64f( regs, &regs.FR8, (uint32)(regs.R6 + 0xFFFFAD40) );
		/* 82097F20h case   14:*/		return 0x82097F24;
		  /* 82097F24h */ case   15:  		/* lfd FR0, <#[R1 - 16]> */
		/* 82097F24h case   15:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82097F24h case   15:*/		return 0x82097F28;
		  /* 82097F28h */ case   16:  		/* fcfid FR4, FR0 */
		/* 82097F28h case   16:*/		cpu::op::fcfid<0>(regs,&regs.FR4,regs.FR0);
		/* 82097F28h case   16:*/		return 0x82097F2C;
		  /* 82097F2Ch */ case   17:  		/* fmul FR3, FR5, FR5 */
		/* 82097F2Ch case   17:*/		cpu::op::fmul<0>(regs,&regs.FR3,regs.FR5,regs.FR5);
		/* 82097F2Ch case   17:*/		return 0x82097F30;
		  /* 82097F30h */ case   18:  		/* lfd FR0, <#[R10 - 21192]> */
		/* 82097F30h case   18:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0xFFFFAD38) );
		/* 82097F30h case   18:*/		return 0x82097F34;
		  /* 82097F34h */ case   19:  		/* fmul FR0, FR4, FR0 */
		/* 82097F34h case   19:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR4,regs.FR0);
		/* 82097F34h case   19:*/		return 0x82097F38;
		  /* 82097F38h */ case   20:  		/* fnmsub FR13, FR3, FR13, FR12 */
		/* 82097F38h case   20:*/		cpu::op::fnmsub<0>(regs,&regs.FR13,regs.FR3,regs.FR13,regs.FR12);
		/* 82097F38h case   20:*/		return 0x82097F3C;
		  /* 82097F3Ch */ case   21:  		/* fsub FR12, FR3, FR11 */
		/* 82097F3Ch case   21:*/		cpu::op::fsub<0>(regs,&regs.FR12,regs.FR3,regs.FR11);
		/* 82097F3Ch case   21:*/		return 0x82097F40;
		  /* 82097F40h */ case   22:  		/* fmsub FR13, FR13, FR3, FR10 */
		/* 82097F40h case   22:*/		cpu::op::fmsub<0>(regs,&regs.FR13,regs.FR13,regs.FR3,regs.FR10);
		/* 82097F40h case   22:*/		return 0x82097F44;
		  /* 82097F44h */ case   23:  		/* fmadd FR12, FR12, FR3, FR9 */
		/* 82097F44h case   23:*/		cpu::op::fmadd<0>(regs,&regs.FR12,regs.FR12,regs.FR3,regs.FR9);
		/* 82097F44h case   23:*/		return 0x82097F48;
		  /* 82097F48h */ case   24:  		/* fmul FR13, FR13, FR3 */
		/* 82097F48h case   24:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR13,regs.FR3);
		/* 82097F48h case   24:*/		return 0x82097F4C;
		  /* 82097F4Ch */ case   25:  		/* fmsub FR12, FR12, FR3, FR8 */
		/* 82097F4Ch case   25:*/		cpu::op::fmsub<0>(regs,&regs.FR12,regs.FR12,regs.FR3,regs.FR8);
		/* 82097F4Ch case   25:*/		return 0x82097F50;
		  /* 82097F50h */ case   26:  		/* fdiv FR13, FR13, FR12 */
		/* 82097F50h case   26:*/		cpu::op::fdiv<0>(regs,&regs.FR13,regs.FR13,regs.FR12);
		/* 82097F50h case   26:*/		return 0x82097F54;
		  /* 82097F54h */ case   27:  		/* fadd FR13, FR13, FR6 */
		/* 82097F54h case   27:*/		cpu::op::fadd<0>(regs,&regs.FR13,regs.FR13,regs.FR6);
		/* 82097F54h case   27:*/		return 0x82097F58;
		  /* 82097F58h */ case   28:  		/* fmsub FR0, FR13, FR5, FR0 */
		/* 82097F58h case   28:*/		cpu::op::fmsub<0>(regs,&regs.FR0,regs.FR13,regs.FR5,regs.FR0);
		/* 82097F58h case   28:*/		return 0x82097F5C;
		  /* 82097F5Ch */ case   29:  		/* fmadd FR1, FR4, FR7, FR0 */
		/* 82097F5Ch case   29:*/		cpu::op::fmadd<0>(regs,&regs.FR1,regs.FR4,regs.FR7,regs.FR0);
		/* 82097F5Ch case   29:*/		return 0x82097F60;
		  /* 82097F60h */ case   30:  		/* bclr 20, CR0_LT */
		/* 82097F60h case   30:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82097F60h case   30:*/		return 0x82097F64;
	}
	return 0x82097F64;
} // Block from 82097EE8h-82097F64h (31 instructions)

//////////////////////////////////////////////////////
// Block at 82097F64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097F64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097F64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097F64);
		  /* 82097F64h */ case    0:  		/* nop */
		/* 82097F64h case    0:*/		cpu::op::nop();
		/* 82097F64h case    0:*/		return 0x82097F68;
	}
	return 0x82097F68;
} // Block from 82097F64h-82097F68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82097F68h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097F68);
		  /* 82097F68h */ case    0:  		/* stfd FR2, <#[R1 + 24]> */
		/* 82097F68h case    0:*/		cpu::mem::store64f( regs, regs.FR2, (uint32)(regs.R1 + 0x00000018) );
		/* 82097F68h case    0:*/		return 0x82097F6C;
		  /* 82097F6Ch */ case    1:  		/* lwz R11, <#[R1 + 24]> */
		/* 82097F6Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000018) );
		/* 82097F6Ch case    1:*/		return 0x82097F70;
		  /* 82097F70h */ case    2:  		/* lis R10, -32256 */
		/* 82097F70h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82097F70h case    2:*/		return 0x82097F74;
		  /* 82097F74h */ case    3:  		/* stfd FR1, <#[R1 + 16]> */
		/* 82097F74h case    3:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000010) );
		/* 82097F74h case    3:*/		return 0x82097F78;
		  /* 82097F78h */ case    4:  		/* lwz R9, <#[R1 + 16]> */
		/* 82097F78h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000010) );
		/* 82097F78h case    4:*/		return 0x82097F7C;
		  /* 82097F7Ch */ case    5:  		/* lwz R8, <#[R1 + 20]> */
		/* 82097F7Ch case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000014) );
		/* 82097F7Ch case    5:*/		return 0x82097F80;
		  /* 82097F80h */ case    6:  		/* lfd FR0, <#[R10 + 1808]> */
		/* 82097F80h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000710) );
		/* 82097F80h case    6:*/		return 0x82097F84;
		  /* 82097F84h */ case    7:  		/* stfd FR0, <#[R1 - 16]> */
		/* 82097F84h case    7:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82097F84h case    7:*/		return 0x82097F88;
		  /* 82097F88h */ case    8:  		/* stw R8, <#[R1 - 12]> */
		/* 82097F88h case    8:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 82097F88h case    8:*/		return 0x82097F8C;
		  /* 82097F8Ch */ case    9:  		/* rlwimi R11, R9, 0, 1, 31 */
		/* 82097F8Ch case    9:*/		cpu::op::rlwimi<0,0,1,31>(regs,&regs.R11,regs.R9);
		/* 82097F8Ch case    9:*/		return 0x82097F90;
		  /* 82097F90h */ case   10:  		/* stw R11, <#[R1 - 16]> */
		/* 82097F90h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82097F90h case   10:*/		return 0x82097F94;
		  /* 82097F94h */ case   11:  		/* lfd FR1, <#[R1 - 16]> */
		/* 82097F94h case   11:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82097F94h case   11:*/		return 0x82097F98;
		  /* 82097F98h */ case   12:  		/* bclr 20, CR0_LT */
		/* 82097F98h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82097F98h case   12:*/		return 0x82097F9C;
	}
	return 0x82097F9C;
} // Block from 82097F68h-82097F9Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 82097F9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097F9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097F9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097F9C);
		  /* 82097F9Ch */ case    0:  		/* nop */
		/* 82097F9Ch case    0:*/		cpu::op::nop();
		/* 82097F9Ch case    0:*/		return 0x82097FA0;
		  /* 82097FA0h */ case    1:  		/* lis R10, -32256 */
		/* 82097FA0h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82097FA0h case    1:*/		return 0x82097FA4;
		  /* 82097FA4h */ case    2:  		/* stfd FR1, <#[R1 + 16]> */
		/* 82097FA4h case    2:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000010) );
		/* 82097FA4h case    2:*/		return 0x82097FA8;
		  /* 82097FA8h */ case    3:  		/* lwz R11, <#[R1 + 16]> */
		/* 82097FA8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000010) );
		/* 82097FA8h case    3:*/		return 0x82097FAC;
		  /* 82097FACh */ case    4:  		/* nor R8, R11, R11 */
		/* 82097FACh case    4:*/		cpu::op::nor<0>(regs,&regs.R8,regs.R11,regs.R11);
		/* 82097FACh case    4:*/		return 0x82097FB0;
		  /* 82097FB0h */ case    5:  		/* lwz R9, <#[R1 + 20]> */
		/* 82097FB0h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000014) );
		/* 82097FB0h case    5:*/		return 0x82097FB4;
		  /* 82097FB4h */ case    6:  		/* lfd FR0, <#[R10 + 1808]> */
		/* 82097FB4h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000710) );
		/* 82097FB4h case    6:*/		return 0x82097FB8;
		  /* 82097FB8h */ case    7:  		/* stfd FR0, <#[R1 - 16]> */
		/* 82097FB8h case    7:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82097FB8h case    7:*/		return 0x82097FBC;
		  /* 82097FBCh */ case    8:  		/* stw R9, <#[R1 - 12]> */
		/* 82097FBCh case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 82097FBCh case    8:*/		return 0x82097FC0;
		  /* 82097FC0h */ case    9:  		/* rlwimi R8, R11, 0, 1, 31 */
		/* 82097FC0h case    9:*/		cpu::op::rlwimi<0,0,1,31>(regs,&regs.R8,regs.R11);
		/* 82097FC0h case    9:*/		return 0x82097FC4;
		  /* 82097FC4h */ case   10:  		/* stw R8, <#[R1 - 16]> */
		/* 82097FC4h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82097FC4h case   10:*/		return 0x82097FC8;
		  /* 82097FC8h */ case   11:  		/* lfd FR1, <#[R1 - 16]> */
		/* 82097FC8h case   11:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82097FC8h case   11:*/		return 0x82097FCC;
		  /* 82097FCCh */ case   12:  		/* bclr 20, CR0_LT */
		/* 82097FCCh case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82097FCCh case   12:*/		return 0x82097FD0;
	}
	return 0x82097FD0;
} // Block from 82097F9Ch-82097FD0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82097FD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097FD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097FD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097FD0);
		  /* 82097FD0h */ case    0:  		/* stfd FR1, <#[R1 + 16]> */
		/* 82097FD0h case    0:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000010) );
		/* 82097FD0h case    0:*/		return 0x82097FD4;
		  /* 82097FD4h */ case    1:  		/* lhz R11, <#[R1 + 16]> */
		/* 82097FD4h case    1:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000010) );
		/* 82097FD4h case    1:*/		return 0x82097FD8;
		  /* 82097FD8h */ case    2:  		/* rlwinm R11, R11, 0, 17, 27 */
		/* 82097FD8h case    2:*/		cpu::op::rlwinm<0,0,17,27>(regs,&regs.R11,regs.R11);
		/* 82097FD8h case    2:*/		return 0x82097FDC;
		  /* 82097FDCh */ case    3:  		/* addi R11, R11, -32752 */
		/* 82097FDCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF8010);
		/* 82097FDCh case    3:*/		return 0x82097FE0;
		  /* 82097FE0h */ case    4:  		/* addic R10, R11, -1 */
		/* 82097FE0h case    4:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 82097FE0h case    4:*/		return 0x82097FE4;
		  /* 82097FE4h */ case    5:  		/* subfe R3, R10, R11 */
		/* 82097FE4h case    5:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82097FE4h case    5:*/		return 0x82097FE8;
		  /* 82097FE8h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82097FE8h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82097FE8h case    6:*/		return 0x82097FEC;
	}
	return 0x82097FEC;
} // Block from 82097FD0h-82097FECh (7 instructions)

//////////////////////////////////////////////////////
// Block at 82097FECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82097FEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82097FEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82097FEC);
		  /* 82097FECh */ case    0:  		/* nop */
		/* 82097FECh case    0:*/		cpu::op::nop();
		/* 82097FECh case    0:*/		return 0x82097FF0;
		  /* 82097FF0h */ case    1:  		/* stfd FR1, <#[R1 + 16]> */
		/* 82097FF0h case    1:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000010) );
		/* 82097FF0h case    1:*/		return 0x82097FF4;
		  /* 82097FF4h */ case    2:  		/* lhz R11, <#[R1 + 16]> */
		/* 82097FF4h case    2:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000010) );
		/* 82097FF4h case    2:*/		return 0x82097FF8;
		  /* 82097FF8h */ case    3:  		/* rlwinm R11, R11, 0, 17, 28 */
		/* 82097FF8h case    3:*/		cpu::op::rlwinm<0,0,17,28>(regs,&regs.R11,regs.R11);
		/* 82097FF8h case    3:*/		return 0x82097FFC;
		  /* 82097FFCh */ case    4:  		/* cmplwi CR6, R11, 32752 */
		/* 82097FFCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00007FF0);
		/* 82097FFCh case    4:*/		return 0x82098000;
		  /* 82098000h */ case    5:  		/* bc 4, CR6_EQ, 28 */
		/* 82098000h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8209801C;  }
		/* 82098000h case    5:*/		return 0x82098004;
		  /* 82098004h */ case    6:  		/* lwz R10, <#[R1 + 16]> */
		/* 82098004h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000010) );
		/* 82098004h case    6:*/		return 0x82098008;
		  /* 82098008h */ case    7:  		/* rlwinm. R10, R10, 0, 13, 31 */
		/* 82098008h case    7:*/		cpu::op::rlwinm<1,0,13,31>(regs,&regs.R10,regs.R10);
		/* 82098008h case    7:*/		return 0x8209800C;
		  /* 8209800Ch */ case    8:  		/* bc 4, CR0_EQ, 24 */
		/* 8209800Ch case    8:*/		if ( !regs.CR[0].eq ) { return 0x82098024;  }
		/* 8209800Ch case    8:*/		return 0x82098010;
		  /* 82098010h */ case    9:  		/* lwz R10, <#[R1 + 20]> */
		/* 82098010h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000014) );
		/* 82098010h case    9:*/		return 0x82098014;
		  /* 82098014h */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 82098014h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82098014h case   10:*/		return 0x82098018;
		  /* 82098018h */ case   11:  		/* bc 4, CR6_EQ, 12 */
		/* 82098018h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82098024;  }
		/* 82098018h case   11:*/		return 0x8209801C;
	}
	return 0x8209801C;
} // Block from 82097FECh-8209801Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8209801Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209801C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209801C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209801C);
		  /* 8209801Ch */ case    0:  		/* cmplwi CR6, R11, 32760 */
		/* 8209801Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00007FF8);
		/* 8209801Ch case    0:*/		return 0x82098020;
		  /* 82098020h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82098020h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209802C;  }
		/* 82098020h case    1:*/		return 0x82098024;
	}
	return 0x82098024;
} // Block from 8209801Ch-82098024h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82098024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098024);
		  /* 82098024h */ case    0:  		/* li R3, 1 */
		/* 82098024h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82098024h case    0:*/		return 0x82098028;
		  /* 82098028h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82098028h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82098028h case    1:*/		return 0x8209802C;
	}
	return 0x8209802C;
} // Block from 82098024h-8209802Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209802Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209802C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209802C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209802C);
		  /* 8209802Ch */ case    0:  		/* li R3, 0 */
		/* 8209802Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209802Ch case    0:*/		return 0x82098030;
		  /* 82098030h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82098030h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82098030h case    1:*/		return 0x82098034;
	}
	return 0x82098034;
} // Block from 8209802Ch-82098034h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82098034h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098034( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098034) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098034);
		  /* 82098034h */ case    0:  		/* nop */
		/* 82098034h case    0:*/		cpu::op::nop();
		/* 82098034h case    0:*/		return 0x82098038;
	}
	return 0x82098038;
} // Block from 82098034h-82098038h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82098038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098038);
		  /* 82098038h */ case    0:  		/* mfspr R12, LR */
		/* 82098038h case    0:*/		regs.R12 = regs.LR;
		/* 82098038h case    0:*/		return 0x8209803C;
		  /* 8209803Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209803Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209803Ch case    1:*/		return 0x82098040;
		  /* 82098040h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82098040h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82098040h case    2:*/		return 0x82098044;
		  /* 82098044h */ case    3:  		/* stfd FR1, <#[R1 + 112]> */
		/* 82098044h case    3:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000070) );
		/* 82098044h case    3:*/		return 0x82098048;
		  /* 82098048h */ case    4:  		/* lhz R11, <#[R1 + 112]> */
		/* 82098048h case    4:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 82098048h case    4:*/		return 0x8209804C;
		  /* 8209804Ch */ case    5:  		/* rlwinm R10, R11, 0, 17, 27 */
		/* 8209804Ch case    5:*/		cpu::op::rlwinm<0,0,17,27>(regs,&regs.R10,regs.R11);
		/* 8209804Ch case    5:*/		return 0x82098050;
		  /* 82098050h */ case    6:  		/* cmplwi CR6, R10, 32752 */
		/* 82098050h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00007FF0);
		/* 82098050h case    6:*/		return 0x82098054;
		  /* 82098054h */ case    7:  		/* bc 4, CR6_EQ, 60 */
		/* 82098054h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82098090;  }
		/* 82098054h case    7:*/		return 0x82098058;
		  /* 82098058h */ case    8:  		/* bl -13912 */
		/* 82098058h case    8:*/		regs.LR = 0x8209805C; return 0x82094A00;
		/* 82098058h case    8:*/		return 0x8209805C;
		  /* 8209805Ch */ case    9:  		/* cmpwi CR6, R3, 1 */
		/* 8209805Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8209805Ch case    9:*/		return 0x82098060;
		  /* 82098060h */ case   10:  		/* bc 12, CR6_EQ, 40 */
		/* 82098060h case   10:*/		if ( regs.CR[6].eq ) { return 0x82098088;  }
		/* 82098060h case   10:*/		return 0x82098064;
		  /* 82098064h */ case   11:  		/* cmpwi CR6, R3, 2 */
		/* 82098064h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 82098064h case   11:*/		return 0x82098068;
		  /* 82098068h */ case   12:  		/* bc 12, CR6_EQ, 24 */
		/* 82098068h case   12:*/		if ( regs.CR[6].eq ) { return 0x82098080;  }
		/* 82098068h case   12:*/		return 0x8209806C;
		  /* 8209806Ch */ case   13:  		/* addi R11, R3, -3 */
		/* 8209806Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0xFFFFFFFD);
		/* 8209806Ch case   13:*/		return 0x82098070;
		  /* 82098070h */ case   14:  		/* cntlzw R11, R11 */
		/* 82098070h case   14:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82098070h case   14:*/		return 0x82098074;
		  /* 82098074h */ case   15:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 82098074h case   15:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82098074h case   15:*/		return 0x82098078;
		  /* 82098078h */ case   16:  		/* addi R3, R11, 1 */
		/* 82098078h case   16:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1);
		/* 82098078h case   16:*/		return 0x8209807C;
		  /* 8209807Ch */ case   17:  		/* b 128 */
		/* 8209807Ch case   17:*/		return 0x820980FC;
		/* 8209807Ch case   17:*/		return 0x82098080;
	}
	return 0x82098080;
} // Block from 82098038h-82098080h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82098080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098080);
		  /* 82098080h */ case    0:  		/* li R3, 4 */
		/* 82098080h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x4);
		/* 82098080h case    0:*/		return 0x82098084;
		  /* 82098084h */ case    1:  		/* b 120 */
		/* 82098084h case    1:*/		return 0x820980FC;
		/* 82098084h case    1:*/		return 0x82098088;
	}
	return 0x82098088;
} // Block from 82098080h-82098088h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82098088h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098088);
		  /* 82098088h */ case    0:  		/* li R3, 512 */
		/* 82098088h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x200);
		/* 82098088h case    0:*/		return 0x8209808C;
		  /* 8209808Ch */ case    1:  		/* b 112 */
		/* 8209808Ch case    1:*/		return 0x820980FC;
		/* 8209808Ch case    1:*/		return 0x82098090;
	}
	return 0x82098090;
} // Block from 82098088h-82098090h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82098090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098090);
		  /* 82098090h */ case    0:  		/* rlwinm R11, R11, 0, 16, 16 */
		/* 82098090h case    0:*/		cpu::op::rlwinm<0,0,16,16>(regs,&regs.R11,regs.R11);
		/* 82098090h case    0:*/		return 0x82098094;
		  /* 82098094h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 82098094h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82098094h case    1:*/		return 0x82098098;
		  /* 82098098h */ case    2:  		/* bc 4, CR6_EQ, 52 */
		/* 82098098h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820980CC;  }
		/* 82098098h case    2:*/		return 0x8209809C;
		  /* 8209809Ch */ case    3:  		/* lwz R10, <#[R1 + 112]> */
		/* 8209809Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000070) );
		/* 8209809Ch case    3:*/		return 0x820980A0;
		  /* 820980A0h */ case    4:  		/* rlwinm. R10, R10, 0, 12, 31 */
		/* 820980A0h case    4:*/		cpu::op::rlwinm<1,0,12,31>(regs,&regs.R10,regs.R10);
		/* 820980A0h case    4:*/		return 0x820980A4;
		  /* 820980A4h */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 820980A4h case    5:*/		if ( !regs.CR[0].eq ) { return 0x820980B4;  }
		/* 820980A4h case    5:*/		return 0x820980A8;
		  /* 820980A8h */ case    6:  		/* lwz R10, <#[R1 + 116]> */
		/* 820980A8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000074) );
		/* 820980A8h case    6:*/		return 0x820980AC;
		  /* 820980ACh */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 820980ACh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820980ACh case    7:*/		return 0x820980B0;
		  /* 820980B0h */ case    8:  		/* bc 12, CR6_EQ, 28 */
		/* 820980B0h case    8:*/		if ( regs.CR[6].eq ) { return 0x820980CC;  }
		/* 820980B0h case    8:*/		return 0x820980B4;
	}
	return 0x820980B4;
} // Block from 82098090h-820980B4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820980B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820980B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820980B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820980B4);
		  /* 820980B4h */ case    0:  		/* subfic R11, R11, 0 */
		/* 820980B4h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 820980B4h case    0:*/		return 0x820980B8;
		  /* 820980B8h */ case    1:  		/* subfe R11, R11, R11 */
		/* 820980B8h case    1:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820980B8h case    1:*/		return 0x820980BC;
		  /* 820980BCh */ case    2:  		/* rlwinm R11, R11, 0, 0, 27 */
		/* 820980BCh case    2:*/		cpu::op::rlwinm<0,0,0,27>(regs,&regs.R11,regs.R11);
		/* 820980BCh case    2:*/		return 0x820980C0;
		  /* 820980C0h */ case    3:  		/* rlwinm R11, R11, 0, 27, 24 */
		/* 820980C0h case    3:*/		cpu::op::rlwinm<0,0,27,24>(regs,&regs.R11,regs.R11);
		/* 820980C0h case    3:*/		return 0x820980C4;
		  /* 820980C4h */ case    4:  		/* addi R3, R11, 128 */
		/* 820980C4h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x80);
		/* 820980C4h case    4:*/		return 0x820980C8;
		  /* 820980C8h */ case    5:  		/* b 52 */
		/* 820980C8h case    5:*/		return 0x820980FC;
		/* 820980C8h case    5:*/		return 0x820980CC;
	}
	return 0x820980CC;
} // Block from 820980B4h-820980CCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820980CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820980CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820980CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820980CC);
		  /* 820980CCh */ case    0:  		/* lis R10, -32256 */
		/* 820980CCh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 820980CCh case    0:*/		return 0x820980D0;
		  /* 820980D0h */ case    1:  		/* subfic R11, R11, 0 */
		/* 820980D0h case    1:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 820980D0h case    1:*/		return 0x820980D4;
		  /* 820980D4h */ case    2:  		/* subfe R11, R11, R11 */
		/* 820980D4h case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820980D4h case    2:*/		return 0x820980D8;
		  /* 820980D8h */ case    3:  		/* lfd FR0, <#[R10 + 1808]> */
		/* 820980D8h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000710) );
		/* 820980D8h case    3:*/		return 0x820980DC;
		  /* 820980DCh */ case    4:  		/* fcmpu CR6, FR1, FR0 */
		/* 820980DCh case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 820980DCh case    4:*/		return 0x820980E0;
		  /* 820980E0h */ case    5:  		/* bc 4, CR6_EQ, 16 */
		/* 820980E0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820980F0;  }
		/* 820980E0h case    5:*/		return 0x820980E4;
		  /* 820980E4h */ case    6:  		/* rlwinm R11, R11, 0, 0, 26 */
		/* 820980E4h case    6:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R11,regs.R11);
		/* 820980E4h case    6:*/		return 0x820980E8;
		  /* 820980E8h */ case    7:  		/* addi R3, R11, 64 */
		/* 820980E8h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x40);
		/* 820980E8h case    7:*/		return 0x820980EC;
		  /* 820980ECh */ case    8:  		/* b 16 */
		/* 820980ECh case    8:*/		return 0x820980FC;
		/* 820980ECh case    8:*/		return 0x820980F0;
	}
	return 0x820980F0;
} // Block from 820980CCh-820980F0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820980F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820980F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820980F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820980F0);
		  /* 820980F0h */ case    0:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 820980F0h case    0:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 820980F0h case    0:*/		return 0x820980F4;
		  /* 820980F4h */ case    1:  		/* rlwinm R11, R11, 0, 28, 23 */
		/* 820980F4h case    1:*/		cpu::op::rlwinm<0,0,28,23>(regs,&regs.R11,regs.R11);
		/* 820980F4h case    1:*/		return 0x820980F8;
		  /* 820980F8h */ case    2:  		/* addi R3, R11, 256 */
		/* 820980F8h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x100);
		/* 820980F8h case    2:*/		return 0x820980FC;
	}
	return 0x820980FC;
} // Block from 820980F0h-820980FCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820980FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820980FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820980FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820980FC);
		  /* 820980FCh */ case    0:  		/* addi R1, R1, 96 */
		/* 820980FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820980FCh case    0:*/		return 0x82098100;
		  /* 82098100h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82098100h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82098100h case    1:*/		return 0x82098104;
		  /* 82098104h */ case    2:  		/* mtspr LR, R12 */
		/* 82098104h case    2:*/		regs.LR = regs.R12;
		/* 82098104h case    2:*/		return 0x82098108;
		  /* 82098108h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82098108h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82098108h case    3:*/		return 0x8209810C;
	}
	return 0x8209810C;
} // Block from 820980FCh-8209810Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209810Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209810C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209810C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209810C);
		  /* 8209810Ch */ case    0:  		/* nop */
		/* 8209810Ch case    0:*/		cpu::op::nop();
		/* 8209810Ch case    0:*/		return 0x82098110;
	}
	return 0x82098110;
} // Block from 8209810Ch-82098110h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82098110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098110);
		  /* 82098110h */ case    0:  		/* mfspr R12, LR */
		/* 82098110h case    0:*/		regs.R12 = regs.LR;
		/* 82098110h case    0:*/		return 0x82098114;
		  /* 82098114h */ case    1:  		/* bl -28368 */
		/* 82098114h case    1:*/		regs.LR = 0x82098118; return 0x82091244;
		/* 82098114h case    1:*/		return 0x82098118;
		  /* 82098118h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82098118h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82098118h case    2:*/		return 0x8209811C;
		  /* 8209811Ch */ case    3:  		/* mr R25, R3 */
		/* 8209811Ch case    3:*/		regs.R25 = regs.R3;
		/* 8209811Ch case    3:*/		return 0x82098120;
		  /* 82098120h */ case    4:  		/* mr R23, R4 */
		/* 82098120h case    4:*/		regs.R23 = regs.R4;
		/* 82098120h case    4:*/		return 0x82098124;
		  /* 82098124h */ case    5:  		/* mr R28, R5 */
		/* 82098124h case    5:*/		regs.R28 = regs.R5;
		/* 82098124h case    5:*/		return 0x82098128;
		  /* 82098128h */ case    6:  		/* mr R24, R6 */
		/* 82098128h case    6:*/		regs.R24 = regs.R6;
		/* 82098128h case    6:*/		return 0x8209812C;
		  /* 8209812Ch */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 8209812Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8209812Ch case    7:*/		return 0x82098130;
		  /* 82098130h */ case    8:  		/* bc 12, CR6_EQ, 8 */
		/* 82098130h case    8:*/		if ( regs.CR[6].eq ) { return 0x82098138;  }
		/* 82098130h case    8:*/		return 0x82098134;
		  /* 82098134h */ case    9:  		/* stw R3, <#[R4]> */
		/* 82098134h case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R4 + 0x00000000) );
		/* 82098134h case    9:*/		return 0x82098138;
	}
	return 0x82098138;
} // Block from 82098110h-82098138h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82098138h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098138);
		  /* 82098138h */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 82098138h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82098138h case    0:*/		return 0x8209813C;
		  /* 8209813Ch */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 8209813Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82098154;  }
		/* 8209813Ch case    1:*/		return 0x82098140;
		  /* 82098140h */ case    2:  		/* bl -12856 */
		/* 82098140h case    2:*/		regs.LR = 0x82098144; return 0x82094F08;
		/* 82098140h case    2:*/		return 0x82098144;
		  /* 82098144h */ case    3:  		/* li R11, 22 */
		/* 82098144h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 82098144h case    3:*/		return 0x82098148;
		  /* 82098148h */ case    4:  		/* stw R11, <#[R3]> */
		/* 82098148h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82098148h case    4:*/		return 0x8209814C;
		  /* 8209814Ch */ case    5:  		/* bl -18412 */
		/* 8209814Ch case    5:*/		regs.LR = 0x82098150; return 0x82093960;
		/* 8209814Ch case    5:*/		return 0x82098150;
		  /* 82098150h */ case    6:  		/* b 652 */
		/* 82098150h case    6:*/		return 0x820983DC;
		/* 82098150h case    6:*/		return 0x82098154;
	}
	return 0x82098154;
} // Block from 82098138h-82098154h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82098154h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098154( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098154) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098154);
		  /* 82098154h */ case    0:  		/* cmpwi CR6, R28, 0 */
		/* 82098154h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 82098154h case    0:*/		return 0x82098158;
		  /* 82098158h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 82098158h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209816C;  }
		/* 82098158h case    1:*/		return 0x8209815C;
		  /* 8209815Ch */ case    2:  		/* cmpwi CR6, R28, 2 */
		/* 8209815Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000002);
		/* 8209815Ch case    2:*/		return 0x82098160;
		  /* 82098160h */ case    3:  		/* bc 12, CR6_LT, -32 */
		/* 82098160h case    3:*/		if ( regs.CR[6].lt ) { return 0x82098140;  }
		/* 82098160h case    3:*/		return 0x82098164;
		  /* 82098164h */ case    4:  		/* cmpwi CR6, R28, 36 */
		/* 82098164h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000024);
		/* 82098164h case    4:*/		return 0x82098168;
		  /* 82098168h */ case    5:  		/* bc 12, CR6_GT, -40 */
		/* 82098168h case    5:*/		if ( regs.CR[6].gt ) { return 0x82098140;  }
		/* 82098168h case    5:*/		return 0x8209816C;
	}
	return 0x8209816C;
} // Block from 82098154h-8209816Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209816Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209816C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209816C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209816C);
		  /* 8209816Ch */ case    0:  		/* lis R11, -32217 */
		/* 8209816Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 8209816Ch case    0:*/		return 0x82098170;
		  /* 82098170h */ case    1:  		/* lbz R31, <#[R25]> */
		/* 82098170h case    1:*/		cpu::mem::load8z( regs, &regs.R31, (uint32)(regs.R25 + 0x00000000) );
		/* 82098170h case    1:*/		return 0x82098174;
		  /* 82098174h */ case    2:  		/* li R26, 0 */
		/* 82098174h case    2:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82098174h case    2:*/		return 0x82098178;
		  /* 82098178h */ case    3:  		/* addi R29, R25, 1 */
		/* 82098178h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R25,0x1);
		/* 82098178h case    3:*/		return 0x8209817C;
		  /* 8209817Ch */ case    4:  		/* addi R30, R11, 8856 */
		/* 8209817Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x2298);
		/* 8209817Ch case    4:*/		return 0x82098180;
		  /* 82098180h */ case    5:  		/* lwz R10, <#[R11 + 8856]> */
		/* 82098180h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00002298) );
		/* 82098180h case    5:*/		return 0x82098184;
		  /* 82098184h */ case    6:  		/* lwz R11, <#[R10 + 172]> */
		/* 82098184h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000000AC) );
		/* 82098184h case    6:*/		return 0x82098188;
		  /* 82098188h */ case    7:  		/* cmpwi CR6, R11, 1 */
		/* 82098188h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 82098188h case    7:*/		return 0x8209818C;
		  /* 8209818Ch */ case    8:  		/* bc 4, CR6_GT, 28 */
		/* 8209818Ch case    8:*/		if ( !regs.CR[6].gt ) { return 0x820981A8;  }
		/* 8209818Ch case    8:*/		return 0x82098190;
		  /* 82098190h */ case    9:  		/* mr R5, R30 */
		/* 82098190h case    9:*/		regs.R5 = regs.R30;
		/* 82098190h case    9:*/		return 0x82098194;
		  /* 82098194h */ case   10:  		/* li R4, 8 */
		/* 82098194h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 82098194h case   10:*/		return 0x82098198;
		  /* 82098198h */ case   11:  		/* rlwinm R3, R31, 0, 24, 31 */
		/* 82098198h case   11:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R31);
		/* 82098198h case   11:*/		return 0x8209819C;
		  /* 8209819Ch */ case   12:  		/* bl 12092 */
		/* 8209819Ch case   12:*/		regs.LR = 0x820981A0; return 0x8209B0D8;
		/* 8209819Ch case   12:*/		return 0x820981A0;
		  /* 820981A0h */ case   13:  		/* lwz R10, <#[R30]> */
		/* 820981A0h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820981A0h case   13:*/		return 0x820981A4;
		  /* 820981A4h */ case   14:  		/* b 20 */
		/* 820981A4h case   14:*/		return 0x820981B8;
		/* 820981A4h case   14:*/		return 0x820981A8;
	}
	return 0x820981A8;
} // Block from 8209816Ch-820981A8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820981A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820981A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820981A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820981A8);
		  /* 820981A8h */ case    0:  		/* lwz R11, <#[R10 + 200]> */
		/* 820981A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000000C8) );
		/* 820981A8h case    0:*/		return 0x820981AC;
		  /* 820981ACh */ case    1:  		/* rlwinm R9, R31, 1, 23, 30 */
		/* 820981ACh case    1:*/		cpu::op::rlwinm<0,1,23,30>(regs,&regs.R9,regs.R31);
		/* 820981ACh case    1:*/		return 0x820981B0;
		  /* 820981B0h */ case    2:  		/* lhzx R11, <#[R9 + R11]> */
		/* 820981B0h case    2:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820981B0h case    2:*/		return 0x820981B4;
		  /* 820981B4h */ case    3:  		/* rlwinm R3, R11, 0, 28, 28 */
		/* 820981B4h case    3:*/		cpu::op::rlwinm<0,0,28,28>(regs,&regs.R3,regs.R11);
		/* 820981B4h case    3:*/		return 0x820981B8;
	}
	return 0x820981B8;
} // Block from 820981A8h-820981B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820981B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820981B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820981B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820981B8);
		  /* 820981B8h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820981B8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820981B8h case    0:*/		return 0x820981BC;
		  /* 820981BCh */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820981BCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820981CC;  }
		/* 820981BCh case    1:*/		return 0x820981C0;
		  /* 820981C0h */ case    2:  		/* lbz R31, <#[R29]> */
		/* 820981C0h case    2:*/		cpu::mem::load8z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000000) );
		/* 820981C0h case    2:*/		return 0x820981C4;
		  /* 820981C4h */ case    3:  		/* addi R29, R29, 1 */
		/* 820981C4h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820981C4h case    3:*/		return 0x820981C8;
		  /* 820981C8h */ case    4:  		/* b -68 */
		/* 820981C8h case    4:*/		return 0x82098184;
		/* 820981C8h case    4:*/		return 0x820981CC;
	}
	return 0x820981CC;
} // Block from 820981B8h-820981CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820981CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820981CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820981CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820981CC);
		  /* 820981CCh */ case    0:  		/* extsb R11, R31 */
		/* 820981CCh case    0:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R31);
		/* 820981CCh case    0:*/		return 0x820981D0;
		  /* 820981D0h */ case    1:  		/* cmpwi CR6, R11, 45 */
		/* 820981D0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002D);
		/* 820981D0h case    1:*/		return 0x820981D4;
		  /* 820981D4h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 820981D4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820981E0;  }
		/* 820981D4h case    2:*/		return 0x820981D8;
		  /* 820981D8h */ case    3:  		/* ori R24, R24, 2 */
		/* 820981D8h case    3:*/		cpu::op::ori<0>(regs,&regs.R24,regs.R24,0x2);
		/* 820981D8h case    3:*/		return 0x820981DC;
		  /* 820981DCh */ case    4:  		/* b 12 */
		/* 820981DCh case    4:*/		return 0x820981E8;
		/* 820981DCh case    4:*/		return 0x820981E0;
	}
	return 0x820981E0;
} // Block from 820981CCh-820981E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820981E0h
// Function '_handle_exc'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820981E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820981E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820981E0);
		  /* 820981E0h */ case    0:  		/* cmpwi CR6, R11, 43 */
		/* 820981E0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002B);
		/* 820981E0h case    0:*/		return 0x820981E4;
		  /* 820981E4h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820981E4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820981F0;  }
		/* 820981E4h case    1:*/		return 0x820981E8;
	}
	return 0x820981E8;
} // Block from 820981E0h-820981E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820981E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820981E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820981E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820981E8);
		  /* 820981E8h */ case    0:  		/* lbz R31, <#[R29]> */
		/* 820981E8h case    0:*/		cpu::mem::load8z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000000) );
		/* 820981E8h case    0:*/		return 0x820981EC;
		  /* 820981ECh */ case    1:  		/* addi R29, R29, 1 */
		/* 820981ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820981ECh case    1:*/		return 0x820981F0;
	}
	return 0x820981F0;
} // Block from 820981E8h-820981F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820981F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820981F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820981F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820981F0);
		  /* 820981F0h */ case    0:  		/* cmpwi CR6, R28, 0 */
		/* 820981F0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 820981F0h case    0:*/		return 0x820981F4;
		  /* 820981F4h */ case    1:  		/* bc 12, CR6_LT, 476 */
		/* 820981F4h case    1:*/		if ( regs.CR[6].lt ) { return 0x820983D0;  }
		/* 820981F4h case    1:*/		return 0x820981F8;
		  /* 820981F8h */ case    2:  		/* cmpwi CR6, R28, 1 */
		/* 820981F8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000001);
		/* 820981F8h case    2:*/		return 0x820981FC;
		  /* 820981FCh */ case    3:  		/* bc 12, CR6_EQ, 468 */
		/* 820981FCh case    3:*/		if ( regs.CR[6].eq ) { return 0x820983D0;  }
		/* 820981FCh case    3:*/		return 0x82098200;
		  /* 82098200h */ case    4:  		/* cmpwi CR6, R28, 36 */
		/* 82098200h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000024);
		/* 82098200h case    4:*/		return 0x82098204;
		  /* 82098204h */ case    5:  		/* bc 12, CR6_GT, 460 */
		/* 82098204h case    5:*/		if ( regs.CR[6].gt ) { return 0x820983D0;  }
		/* 82098204h case    5:*/		return 0x82098208;
		  /* 82098208h */ case    6:  		/* cmpwi CR6, R28, 0 */
		/* 82098208h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 82098208h case    6:*/		return 0x8209820C;
		  /* 8209820Ch */ case    7:  		/* bc 4, CR6_EQ, 64 */
		/* 8209820Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x8209824C;  }
		/* 8209820Ch case    7:*/		return 0x82098210;
		  /* 82098210h */ case    8:  		/* extsb R11, R31 */
		/* 82098210h case    8:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R31);
		/* 82098210h case    8:*/		return 0x82098214;
		  /* 82098214h */ case    9:  		/* cmpwi CR6, R11, 48 */
		/* 82098214h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000030);
		/* 82098214h case    9:*/		return 0x82098218;
		  /* 82098218h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 82098218h case   10:*/		if ( regs.CR[6].eq ) { return 0x82098224;  }
		/* 82098218h case   10:*/		return 0x8209821C;
		  /* 8209821Ch */ case   11:  		/* li R28, 10 */
		/* 8209821Ch case   11:*/		cpu::op::li<0>(regs,&regs.R28,0xA);
		/* 8209821Ch case   11:*/		return 0x82098220;
		  /* 82098220h */ case   12:  		/* b 96 */
		/* 82098220h case   12:*/		return 0x82098280;
		/* 82098220h case   12:*/		return 0x82098224;
	}
	return 0x82098224;
} // Block from 820981F0h-82098224h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82098224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098224);
		  /* 82098224h */ case    0:  		/* lbz R11, <#[R29]> */
		/* 82098224h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82098224h case    0:*/		return 0x82098228;
		  /* 82098228h */ case    1:  		/* extsb R11, R11 */
		/* 82098228h case    1:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 82098228h case    1:*/		return 0x8209822C;
		  /* 8209822Ch */ case    2:  		/* cmpwi CR6, R11, 120 */
		/* 8209822Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000078);
		/* 8209822Ch case    2:*/		return 0x82098230;
		  /* 82098230h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 82098230h case    3:*/		if ( regs.CR[6].eq ) { return 0x82098244;  }
		/* 82098230h case    3:*/		return 0x82098234;
		  /* 82098234h */ case    4:  		/* cmpwi CR6, R11, 88 */
		/* 82098234h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000058);
		/* 82098234h case    4:*/		return 0x82098238;
		  /* 82098238h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 82098238h case    5:*/		if ( regs.CR[6].eq ) { return 0x82098244;  }
		/* 82098238h case    5:*/		return 0x8209823C;
		  /* 8209823Ch */ case    6:  		/* li R28, 8 */
		/* 8209823Ch case    6:*/		cpu::op::li<0>(regs,&regs.R28,0x8);
		/* 8209823Ch case    6:*/		return 0x82098240;
		  /* 82098240h */ case    7:  		/* b 64 */
		/* 82098240h case    7:*/		return 0x82098280;
		/* 82098240h case    7:*/		return 0x82098244;
	}
	return 0x82098244;
} // Block from 82098224h-82098244h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82098244h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098244( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098244) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098244);
		  /* 82098244h */ case    0:  		/* li R28, 16 */
		/* 82098244h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x10);
		/* 82098244h case    0:*/		return 0x82098248;
		  /* 82098248h */ case    1:  		/* b 12 */
		/* 82098248h case    1:*/		return 0x82098254;
		/* 82098248h case    1:*/		return 0x8209824C;
	}
	return 0x8209824C;
} // Block from 82098244h-8209824Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209824Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209824C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209824C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209824C);
		  /* 8209824Ch */ case    0:  		/* cmpwi CR6, R28, 16 */
		/* 8209824Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000010);
		/* 8209824Ch case    0:*/		return 0x82098250;
		  /* 82098250h */ case    1:  		/* bc 4, CR6_EQ, 48 */
		/* 82098250h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82098280;  }
		/* 82098250h case    1:*/		return 0x82098254;
	}
	return 0x82098254;
} // Block from 8209824Ch-82098254h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82098254h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098254);
		  /* 82098254h */ case    0:  		/* extsb R11, R31 */
		/* 82098254h case    0:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R31);
		/* 82098254h case    0:*/		return 0x82098258;
		  /* 82098258h */ case    1:  		/* cmpwi CR6, R11, 48 */
		/* 82098258h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000030);
		/* 82098258h case    1:*/		return 0x8209825C;
		  /* 8209825Ch */ case    2:  		/* bc 4, CR6_EQ, 36 */
		/* 8209825Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82098280;  }
		/* 8209825Ch case    2:*/		return 0x82098260;
		  /* 82098260h */ case    3:  		/* lbz R11, <#[R29]> */
		/* 82098260h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82098260h case    3:*/		return 0x82098264;
		  /* 82098264h */ case    4:  		/* extsb R11, R11 */
		/* 82098264h case    4:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 82098264h case    4:*/		return 0x82098268;
		  /* 82098268h */ case    5:  		/* cmpwi CR6, R11, 120 */
		/* 82098268h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000078);
		/* 82098268h case    5:*/		return 0x8209826C;
		  /* 8209826Ch */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 8209826Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x82098278;  }
		/* 8209826Ch case    6:*/		return 0x82098270;
		  /* 82098270h */ case    7:  		/* cmpwi CR6, R11, 88 */
		/* 82098270h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000058);
		/* 82098270h case    7:*/		return 0x82098274;
		  /* 82098274h */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 82098274h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82098280;  }
		/* 82098274h case    8:*/		return 0x82098278;
	}
	return 0x82098278;
} // Block from 82098254h-82098278h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82098278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098278);
		  /* 82098278h */ case    0:  		/* lbzu R31, <#[R29 + 1]> */
		/* 82098278h case    0:*/		cpu::mem::load8z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000001) );
		regs.R29 = (uint32)(regs.R29 + 0x00000001);
		/* 82098278h case    0:*/		return 0x8209827C;
		  /* 8209827Ch */ case    1:  		/* addi R29, R29, 1 */
		/* 8209827Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8209827Ch case    1:*/		return 0x82098280;
	}
	return 0x82098280;
} // Block from 82098278h-82098280h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82098280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098280);
		  /* 82098280h */ case    0:  		/* li R27, -1 */
		/* 82098280h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0xFFFFFFFF);
		/* 82098280h case    0:*/		return 0x82098284;
		  /* 82098284h */ case    1:  		/* lwz R8, <#[R10 + 200]> */
		/* 82098284h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x000000C8) );
		/* 82098284h case    1:*/		return 0x82098288;
		  /* 82098288h */ case    2:  		/* twi 6, R28, 0 */
		/* 82098288h case    2:*/		cpu::op::tw<6>(regs, 0x82098288, regs.R28, 0x00000000);
		/* 82098288h case    2:*/		return 0x8209828C;
		  /* 8209828Ch */ case    3:  		/* divwu R9, R27, R28 */
		/* 8209828Ch case    3:*/		cpu::op::divwu<0>(regs,&regs.R9,regs.R27,regs.R28);
		/* 8209828Ch case    3:*/		return 0x82098290;
		  /* 82098290h */ case    4:  		/* rlwinm R11, R31, 1, 23, 30 */
		/* 82098290h case    4:*/		cpu::op::rlwinm<0,1,23,30>(regs,&regs.R11,regs.R31);
		/* 82098290h case    4:*/		return 0x82098294;
		  /* 82098294h */ case    5:  		/* lhzx R11, <#[R11 + R8]> */
		/* 82098294h case    5:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82098294h case    5:*/		return 0x82098298;
		  /* 82098298h */ case    6:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 82098298h case    6:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 82098298h case    6:*/		return 0x8209829C;
		  /* 8209829Ch */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 8209829Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820982AC;  }
		/* 8209829Ch case    7:*/		return 0x820982A0;
		  /* 820982A0h */ case    8:  		/* extsb R11, R31 */
		/* 820982A0h case    8:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R31);
		/* 820982A0h case    8:*/		return 0x820982A4;
		  /* 820982A4h */ case    9:  		/* addi R11, R11, -48 */
		/* 820982A4h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFD0);
		/* 820982A4h case    9:*/		return 0x820982A8;
		  /* 820982A8h */ case   10:  		/* b 44 */
		/* 820982A8h case   10:*/		return 0x820982D4;
		/* 820982A8h case   10:*/		return 0x820982AC;
	}
	return 0x820982AC;
} // Block from 82098280h-820982ACh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820982ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820982AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820982AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820982AC);
		  /* 820982ACh */ case    0:  		/* andi. R11, R11, 259 */
		/* 820982ACh case    0:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x103);
		/* 820982ACh case    0:*/		return 0x820982B0;
		  /* 820982B0h */ case    1:  		/* cmpwi CR0, R11, 0 */
		/* 820982B0h case    1:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 820982B0h case    1:*/		return 0x820982B4;
		  /* 820982B4h */ case    2:  		/* bc 12, CR0_EQ, 96 */
		/* 820982B4h case    2:*/		if ( regs.CR[0].eq ) { return 0x82098314;  }
		/* 820982B4h case    2:*/		return 0x820982B8;
		  /* 820982B8h */ case    3:  		/* extsb R11, R31 */
		/* 820982B8h case    3:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R31);
		/* 820982B8h case    3:*/		return 0x820982BC;
		  /* 820982BCh */ case    4:  		/* cmpwi CR6, R11, 97 */
		/* 820982BCh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000061);
		/* 820982BCh case    4:*/		return 0x820982C0;
		  /* 820982C0h */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 820982C0h case    5:*/		if ( regs.CR[6].lt ) { return 0x820982D0;  }
		/* 820982C0h case    5:*/		return 0x820982C4;
		  /* 820982C4h */ case    6:  		/* cmpwi CR6, R11, 122 */
		/* 820982C4h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000007A);
		/* 820982C4h case    6:*/		return 0x820982C8;
		  /* 820982C8h */ case    7:  		/* bc 12, CR6_GT, 8 */
		/* 820982C8h case    7:*/		if ( regs.CR[6].gt ) { return 0x820982D0;  }
		/* 820982C8h case    7:*/		return 0x820982CC;
		  /* 820982CCh */ case    8:  		/* addi R11, R11, -32 */
		/* 820982CCh case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFE0);
		/* 820982CCh case    8:*/		return 0x820982D0;
	}
	return 0x820982D0;
} // Block from 820982ACh-820982D0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820982D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820982D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820982D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820982D0);
		  /* 820982D0h */ case    0:  		/* addi R11, R11, -55 */
		/* 820982D0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFC9);
		/* 820982D0h case    0:*/		return 0x820982D4;
	}
	return 0x820982D4;
} // Block from 820982D0h-820982D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820982D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820982D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820982D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820982D4);
		  /* 820982D4h */ case    0:  		/* cmplw CR6, R11, R28 */
		/* 820982D4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 820982D4h case    0:*/		return 0x820982D8;
		  /* 820982D8h */ case    1:  		/* bc 4, CR6_LT, 60 */
		/* 820982D8h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82098314;  }
		/* 820982D8h case    1:*/		return 0x820982DC;
		  /* 820982DCh */ case    2:  		/* ori R24, R24, 8 */
		/* 820982DCh case    2:*/		cpu::op::ori<0>(regs,&regs.R24,regs.R24,0x8);
		/* 820982DCh case    2:*/		return 0x820982E0;
		  /* 820982E0h */ case    3:  		/* cmplw CR6, R26, R9 */
		/* 820982E0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R9);
		/* 820982E0h case    3:*/		return 0x820982E4;
		  /* 820982E4h */ case    4:  		/* bc 12, CR6_LT, 80 */
		/* 820982E4h case    4:*/		if ( regs.CR[6].lt ) { return 0x82098334;  }
		/* 820982E4h case    4:*/		return 0x820982E8;
		  /* 820982E8h */ case    5:  		/* bc 4, CR6_EQ, 32 */
		/* 820982E8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82098308;  }
		/* 820982E8h case    5:*/		return 0x820982EC;
		  /* 820982ECh */ case    6:  		/* divwu R7, R27, R28 */
		/* 820982ECh case    6:*/		cpu::op::divwu<0>(regs,&regs.R7,regs.R27,regs.R28);
		/* 820982ECh case    6:*/		return 0x820982F0;
		  /* 820982F0h */ case    7:  		/* mr R10, R27 */
		/* 820982F0h case    7:*/		regs.R10 = regs.R27;
		/* 820982F0h case    7:*/		return 0x820982F4;
		  /* 820982F4h */ case    8:  		/* mullw R7, R7, R28 */
		/* 820982F4h case    8:*/		cpu::op::mullw<0>(regs,&regs.R7,regs.R7,regs.R28);
		/* 820982F4h case    8:*/		return 0x820982F8;
		  /* 820982F8h */ case    9:  		/* subf R10, R7, R10 */
		/* 820982F8h case    9:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R7,regs.R10);
		/* 820982F8h case    9:*/		return 0x820982FC;
		  /* 820982FCh */ case   10:  		/* twi 6, R28, 0 */
		/* 820982FCh case   10:*/		cpu::op::tw<6>(regs, 0x820982FC, regs.R28, 0x00000000);
		/* 820982FCh case   10:*/		return 0x82098300;
		  /* 82098300h */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 82098300h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82098300h case   11:*/		return 0x82098304;
		  /* 82098304h */ case   12:  		/* bc 4, CR6_GT, 48 */
		/* 82098304h case   12:*/		if ( !regs.CR[6].gt ) { return 0x82098334;  }
		/* 82098304h case   12:*/		return 0x82098308;
	}
	return 0x82098308;
} // Block from 820982D4h-82098308h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82098308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098308);
		  /* 82098308h */ case    0:  		/* ori R24, R24, 4 */
		/* 82098308h case    0:*/		cpu::op::ori<0>(regs,&regs.R24,regs.R24,0x4);
		/* 82098308h case    0:*/		return 0x8209830C;
		  /* 8209830Ch */ case    1:  		/* cmplwi CR6, R23, 0 */
		/* 8209830Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 8209830Ch case    1:*/		return 0x82098310;
		  /* 82098310h */ case    2:  		/* bc 4, CR6_EQ, 44 */
		/* 82098310h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8209833C;  }
		/* 82098310h case    2:*/		return 0x82098314;
	}
	return 0x82098314;
} // Block from 82098308h-82098314h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82098314h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098314( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098314) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098314);
		  /* 82098314h */ case    0:  		/* rlwinm. R11, R24, 0, 28, 28 */
		/* 82098314h case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R24);
		/* 82098314h case    0:*/		return 0x82098318;
		  /* 82098318h */ case    1:  		/* addi R30, R29, -1 */
		/* 82098318h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R29,0xFFFFFFFF);
		/* 82098318h case    1:*/		return 0x8209831C;
		  /* 8209831Ch */ case    2:  		/* bc 4, CR0_EQ, 44 */
		/* 8209831Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x82098348;  }
		/* 8209831Ch case    2:*/		return 0x82098320;
		  /* 82098320h */ case    3:  		/* cmplwi CR6, R23, 0 */
		/* 82098320h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 82098320h case    3:*/		return 0x82098324;
		  /* 82098324h */ case    4:  		/* bc 12, CR6_EQ, 8 */
		/* 82098324h case    4:*/		if ( regs.CR[6].eq ) { return 0x8209832C;  }
		/* 82098324h case    4:*/		return 0x82098328;
		  /* 82098328h */ case    5:  		/* mr R30, R25 */
		/* 82098328h case    5:*/		regs.R30 = regs.R25;
		/* 82098328h case    5:*/		return 0x8209832C;
	}
	return 0x8209832C;
} // Block from 82098314h-8209832Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209832Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209832C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209832C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209832C);
		  /* 8209832Ch */ case    0:  		/* li R26, 0 */
		/* 8209832Ch case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8209832Ch case    0:*/		return 0x82098330;
		  /* 82098330h */ case    1:  		/* b 128 */
		/* 82098330h case    1:*/		return 0x820983B0;
		/* 82098330h case    1:*/		return 0x82098334;
	}
	return 0x82098334;
} // Block from 8209832Ch-82098334h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82098334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098334);
		  /* 82098334h */ case    0:  		/* mullw R10, R26, R28 */
		/* 82098334h case    0:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R26,regs.R28);
		/* 82098334h case    0:*/		return 0x82098338;
		  /* 82098338h */ case    1:  		/* add R26, R10, R11 */
		/* 82098338h case    1:*/		cpu::op::add<0>(regs,&regs.R26,regs.R10,regs.R11);
		/* 82098338h case    1:*/		return 0x8209833C;
	}
	return 0x8209833C;
} // Block from 82098334h-8209833Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209833Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209833C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209833C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209833C);
		  /* 8209833Ch */ case    0:  		/* lbz R31, <#[R29]> */
		/* 8209833Ch case    0:*/		cpu::mem::load8z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000000) );
		/* 8209833Ch case    0:*/		return 0x82098340;
		  /* 82098340h */ case    1:  		/* addi R29, R29, 1 */
		/* 82098340h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82098340h case    1:*/		return 0x82098344;
		  /* 82098344h */ case    2:  		/* b -180 */
		/* 82098344h case    2:*/		return 0x82098290;
		/* 82098344h case    2:*/		return 0x82098348;
	}
	return 0x82098348;
} // Block from 8209833Ch-82098348h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82098348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098348);
		  /* 82098348h */ case    0:  		/* lis R10, 32767 */
		/* 82098348h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x7FFF);
		/* 82098348h case    0:*/		return 0x8209834C;
		  /* 8209834Ch */ case    1:  		/* rlwinm. R11, R24, 0, 29, 29 */
		/* 8209834Ch case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R24);
		/* 8209834Ch case    1:*/		return 0x82098350;
		  /* 82098350h */ case    2:  		/* ori R31, R10, 65535 */
		/* 82098350h case    2:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R10,0xFFFF);
		/* 82098350h case    2:*/		return 0x82098354;
		  /* 82098354h */ case    3:  		/* bc 4, CR0_EQ, 48 */
		/* 82098354h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82098384;  }
		/* 82098354h case    3:*/		return 0x82098358;
		  /* 82098358h */ case    4:  		/* rlwinm. R11, R24, 0, 31, 31 */
		/* 82098358h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R24);
		/* 82098358h case    4:*/		return 0x8209835C;
		  /* 8209835Ch */ case    5:  		/* bc 4, CR0_EQ, 84 */
		/* 8209835Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x820983B0;  }
		/* 8209835Ch case    5:*/		return 0x82098360;
		  /* 82098360h */ case    6:  		/* rlwinm. R11, R24, 0, 30, 30 */
		/* 82098360h case    6:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R24);
		/* 82098360h case    6:*/		return 0x82098364;
		  /* 82098364h */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 82098364h case    7:*/		if ( regs.CR[0].eq ) { return 0x82098374;  }
		/* 82098364h case    7:*/		return 0x82098368;
		  /* 82098368h */ case    8:  		/* lis R10, -32768 */
		/* 82098368h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8000);
		/* 82098368h case    8:*/		return 0x8209836C;
		  /* 8209836Ch */ case    9:  		/* cmplw CR6, R26, R10 */
		/* 8209836Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R10);
		/* 8209836Ch case    9:*/		return 0x82098370;
		  /* 82098370h */ case   10:  		/* bc 12, CR6_GT, 20 */
		/* 82098370h case   10:*/		if ( regs.CR[6].gt ) { return 0x82098384;  }
		/* 82098370h case   10:*/		return 0x82098374;
	}
	return 0x82098374;
} // Block from 82098348h-82098374h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82098374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098374);
		  /* 82098374h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 82098374h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82098374h case    0:*/		return 0x82098378;
		  /* 82098378h */ case    1:  		/* bc 4, CR6_EQ, 56 */
		/* 82098378h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820983B0;  }
		/* 82098378h case    1:*/		return 0x8209837C;
		  /* 8209837Ch */ case    2:  		/* cmplw CR6, R26, R31 */
		/* 8209837Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R31);
		/* 8209837Ch case    2:*/		return 0x82098380;
		  /* 82098380h */ case    3:  		/* bc 4, CR6_GT, 48 */
		/* 82098380h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820983B0;  }
		/* 82098380h case    3:*/		return 0x82098384;
	}
	return 0x82098384;
} // Block from 82098374h-82098384h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82098384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098384);
		  /* 82098384h */ case    0:  		/* bl -13436 */
		/* 82098384h case    0:*/		regs.LR = 0x82098388; return 0x82094F08;
		/* 82098384h case    0:*/		return 0x82098388;
		  /* 82098388h */ case    1:  		/* li R11, 34 */
		/* 82098388h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x22);
		/* 82098388h case    1:*/		return 0x8209838C;
		  /* 8209838Ch */ case    2:  		/* rlwinm. R10, R24, 0, 31, 31 */
		/* 8209838Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R24);
		/* 8209838Ch case    2:*/		return 0x82098390;
		  /* 82098390h */ case    3:  		/* stw R11, <#[R3]> */
		/* 82098390h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82098390h case    3:*/		return 0x82098394;
		  /* 82098394h */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 82098394h case    4:*/		if ( regs.CR[0].eq ) { return 0x820983A0;  }
		/* 82098394h case    4:*/		return 0x82098398;
		  /* 82098398h */ case    5:  		/* mr R26, R27 */
		/* 82098398h case    5:*/		regs.R26 = regs.R27;
		/* 82098398h case    5:*/		return 0x8209839C;
		  /* 8209839Ch */ case    6:  		/* b 20 */
		/* 8209839Ch case    6:*/		return 0x820983B0;
		/* 8209839Ch case    6:*/		return 0x820983A0;
	}
	return 0x820983A0;
} // Block from 82098384h-820983A0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820983A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820983A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820983A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820983A0);
		  /* 820983A0h */ case    0:  		/* rlwinm. R11, R24, 0, 30, 30 */
		/* 820983A0h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R24);
		/* 820983A0h case    0:*/		return 0x820983A4;
		  /* 820983A4h */ case    1:  		/* lis R26, -32768 */
		/* 820983A4h case    1:*/		cpu::op::lis<0>(regs,&regs.R26,0xFFFF8000);
		/* 820983A4h case    1:*/		return 0x820983A8;
		  /* 820983A8h */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 820983A8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820983B0;  }
		/* 820983A8h case    2:*/		return 0x820983AC;
		  /* 820983ACh */ case    3:  		/* mr R26, R31 */
		/* 820983ACh case    3:*/		regs.R26 = regs.R31;
		/* 820983ACh case    3:*/		return 0x820983B0;
	}
	return 0x820983B0;
} // Block from 820983A0h-820983B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820983B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820983B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820983B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820983B0);
		  /* 820983B0h */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 820983B0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 820983B0h case    0:*/		return 0x820983B4;
		  /* 820983B4h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 820983B4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820983BC;  }
		/* 820983B4h case    1:*/		return 0x820983B8;
		  /* 820983B8h */ case    2:  		/* stw R30, <#[R23]> */
		/* 820983B8h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R23 + 0x00000000) );
		/* 820983B8h case    2:*/		return 0x820983BC;
	}
	return 0x820983BC;
} // Block from 820983B0h-820983BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820983BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820983BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820983BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820983BC);
		  /* 820983BCh */ case    0:  		/* rlwinm. R11, R24, 0, 30, 30 */
		/* 820983BCh case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R24);
		/* 820983BCh case    0:*/		return 0x820983C0;
		  /* 820983C0h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 820983C0h case    1:*/		if ( regs.CR[0].eq ) { return 0x820983C8;  }
		/* 820983C0h case    1:*/		return 0x820983C4;
		  /* 820983C4h */ case    2:  		/* neg R26, R26 */
		/* 820983C4h case    2:*/		cpu::op::neg<0>(regs,&regs.R26,regs.R26);
		/* 820983C4h case    2:*/		return 0x820983C8;
	}
	return 0x820983C8;
} // Block from 820983BCh-820983C8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820983C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820983C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820983C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820983C8);
		  /* 820983C8h */ case    0:  		/* mr R3, R26 */
		/* 820983C8h case    0:*/		regs.R3 = regs.R26;
		/* 820983C8h case    0:*/		return 0x820983CC;
		  /* 820983CCh */ case    1:  		/* b 20 */
		/* 820983CCh case    1:*/		return 0x820983E0;
		/* 820983CCh case    1:*/		return 0x820983D0;
	}
	return 0x820983D0;
} // Block from 820983C8h-820983D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820983D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820983D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820983D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820983D0);
		  /* 820983D0h */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 820983D0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 820983D0h case    0:*/		return 0x820983D4;
		  /* 820983D4h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 820983D4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820983DC;  }
		/* 820983D4h case    1:*/		return 0x820983D8;
		  /* 820983D8h */ case    2:  		/* stw R25, <#[R23]> */
		/* 820983D8h case    2:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R23 + 0x00000000) );
		/* 820983D8h case    2:*/		return 0x820983DC;
	}
	return 0x820983DC;
} // Block from 820983D0h-820983DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820983DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820983DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820983DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820983DC);
		  /* 820983DCh */ case    0:  		/* li R3, 0 */
		/* 820983DCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820983DCh case    0:*/		return 0x820983E0;
	}
	return 0x820983E0;
} // Block from 820983DCh-820983E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820983E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820983E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820983E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820983E0);
		  /* 820983E0h */ case    0:  		/* addi R1, R1, 160 */
		/* 820983E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820983E0h case    0:*/		return 0x820983E4;
		  /* 820983E4h */ case    1:  		/* b -29008 */
		/* 820983E4h case    1:*/		return 0x82091294;
		/* 820983E4h case    1:*/		return 0x820983E8;
	}
	return 0x820983E8;
} // Block from 820983E0h-820983E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820983E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820983E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820983E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820983E8);
		  /* 820983E8h */ case    0:  		/* li R6, 0 */
		/* 820983E8h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820983E8h case    0:*/		return 0x820983EC;
		  /* 820983ECh */ case    1:  		/* b -732 */
		/* 820983ECh case    1:*/		return 0x82098110;
		/* 820983ECh case    1:*/		return 0x820983F0;
		  /* 820983F0h */ case    2:  		/* li R6, 1 */
		/* 820983F0h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820983F0h case    2:*/		return 0x820983F4;
		  /* 820983F4h */ case    3:  		/* b -740 */
		/* 820983F4h case    3:*/		return 0x82098110;
		/* 820983F4h case    3:*/		return 0x820983F8;
	}
	return 0x820983F8;
} // Block from 820983E8h-820983F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820983F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820983F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820983F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820983F8);
		  /* 820983F8h */ case    0:  		/* mfspr R12, LR */
		/* 820983F8h case    0:*/		regs.R12 = regs.LR;
		/* 820983F8h case    0:*/		return 0x820983FC;
		  /* 820983FCh */ case    1:  		/* bl -29104 */
		/* 820983FCh case    1:*/		regs.LR = 0x82098400; return 0x8209124C;
		/* 820983FCh case    1:*/		return 0x82098400;
		  /* 82098400h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82098400h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82098400h case    2:*/		return 0x82098404;
		  /* 82098404h */ case    3:  		/* li R11, 0 */
		/* 82098404h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82098404h case    3:*/		return 0x82098408;
		  /* 82098408h */ case    4:  		/* stw R3, <#[R1 + 180]> */
		/* 82098408h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x000000B4) );
		/* 82098408h case    4:*/		return 0x8209840C;
		  /* 8209840Ch */ case    5:  		/* mr R31, R4 */
		/* 8209840Ch case    5:*/		regs.R31 = regs.R4;
		/* 8209840Ch case    5:*/		return 0x82098410;
		  /* 82098410h */ case    6:  		/* stw R11, <#[R3 + 4]> */
		/* 82098410h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82098410h case    6:*/		return 0x82098414;
		  /* 82098414h */ case    7:  		/* rlwinm. R4, R5, 0, 27, 27 */
		/* 82098414h case    7:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R4,regs.R5);
		/* 82098414h case    7:*/		return 0x82098418;
		  /* 82098418h */ case    8:  		/* mr R28, R6 */
		/* 82098418h case    8:*/		regs.R28 = regs.R6;
		/* 82098418h case    8:*/		return 0x8209841C;
		  /* 8209841Ch */ case    9:  		/* mr R29, R7 */
		/* 8209841Ch case    9:*/		regs.R29 = regs.R7;
		/* 8209841Ch case    9:*/		return 0x82098420;
		  /* 82098420h */ case   10:  		/* mr R26, R8 */
		/* 82098420h case   10:*/		regs.R26 = regs.R8;
		/* 82098420h case   10:*/		return 0x82098424;
		  /* 82098424h */ case   11:  		/* mr R25, R9 */
		/* 82098424h case   11:*/		regs.R25 = regs.R9;
		/* 82098424h case   11:*/		return 0x82098428;
		  /* 82098428h */ case   12:  		/* lwz R10, <#[R1 + 180]> */
		/* 82098428h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000B4) );
		/* 82098428h case   12:*/		return 0x8209842C;
		  /* 8209842Ch */ case   13:  		/* stw R11, <#[R10 + 8]> */
		/* 8209842Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8209842Ch case   13:*/		return 0x82098430;
		  /* 82098430h */ case   14:  		/* lwz R10, <#[R1 + 180]> */
		/* 82098430h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000B4) );
		/* 82098430h case   14:*/		return 0x82098434;
		  /* 82098434h */ case   15:  		/* stw R11, <#[R10 + 12]> */
		/* 82098434h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 82098434h case   15:*/		return 0x82098438;
	}
	return 0x82098438;
} // Block from 820983F8h-82098438h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82098438h
// Function '_set_errno_from_matherr'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098438);
		  /* 82098438h */ case    0:  		/* bc 12, CR0_EQ, 32 */
		/* 82098438h case    0:*/		if ( regs.CR[0].eq ) { return 0x82098458;  }
		/* 82098438h case    0:*/		return 0x8209843C;
		  /* 8209843Ch */ case    1:  		/* lwz R11, <#[R1 + 180]> */
		/* 8209843Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 8209843Ch case    1:*/		return 0x82098440;
		  /* 82098440h */ case    2:  		/* lis R27, -16384 */
		/* 82098440h case    2:*/		cpu::op::lis<0>(regs,&regs.R27,0xFFFFC000);
		/* 82098440h case    2:*/		return 0x82098444;
		  /* 82098444h */ case    3:  		/* ori R27, R27, 143 */
		/* 82098444h case    3:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x8F);
		/* 82098444h case    3:*/		return 0x82098448;
		  /* 82098448h */ case    4:  		/* lwz R10, <#[R11 + 4]> */
		/* 82098448h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82098448h case    4:*/		return 0x8209844C;
		  /* 8209844Ch */ case    5:  		/* oris R10, R10, 32768 */
		/* 8209844Ch case    5:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x8000);
		/* 8209844Ch case    5:*/		return 0x82098450;
		  /* 82098450h */ case    6:  		/* stw R10, <#[R11 + 4]> */
		/* 82098450h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82098450h case    6:*/		return 0x82098454;
		  /* 82098454h */ case    7:  		/* b 8 */
		/* 82098454h case    7:*/		return 0x8209845C;
		/* 82098454h case    7:*/		return 0x82098458;
	}
	return 0x82098458;
} // Block from 82098438h-82098458h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82098458h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098458);
		  /* 82098458h */ case    0:  		/* lwz R27, <#[R1 + 80]> */
		/* 82098458h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000050) );
		/* 82098458h case    0:*/		return 0x8209845C;
	}
	return 0x8209845C;
} // Block from 82098458h-8209845Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209845Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209845C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209845C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209845C);
		  /* 8209845Ch */ case    0:  		/* rlwinm. R11, R5, 0, 30, 30 */
		/* 8209845Ch case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R5);
		/* 8209845Ch case    0:*/		return 0x82098460;
		  /* 82098460h */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 82098460h case    1:*/		if ( regs.CR[0].eq ) { return 0x8209847C;  }
		/* 82098460h case    1:*/		return 0x82098464;
		  /* 82098464h */ case    2:  		/* lwz R11, <#[R1 + 180]> */
		/* 82098464h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 82098464h case    2:*/		return 0x82098468;
		  /* 82098468h */ case    3:  		/* lis R27, -16384 */
		/* 82098468h case    3:*/		cpu::op::lis<0>(regs,&regs.R27,0xFFFFC000);
		/* 82098468h case    3:*/		return 0x8209846C;
		  /* 8209846Ch */ case    4:  		/* ori R27, R27, 147 */
		/* 8209846Ch case    4:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x93);
		/* 8209846Ch case    4:*/		return 0x82098470;
		  /* 82098470h */ case    5:  		/* lwz R10, <#[R11 + 4]> */
		/* 82098470h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82098470h case    5:*/		return 0x82098474;
		  /* 82098474h */ case    6:  		/* oris R10, R10, 16384 */
		/* 82098474h case    6:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x4000);
		/* 82098474h case    6:*/		return 0x82098478;
		  /* 82098478h */ case    7:  		/* stw R10, <#[R11 + 4]> */
		/* 82098478h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82098478h case    7:*/		return 0x8209847C;
	}
	return 0x8209847C;
} // Block from 8209845Ch-8209847Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209847Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209847C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209847C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209847C);
		  /* 8209847Ch */ case    0:  		/* rlwinm. R11, R5, 0, 31, 31 */
		/* 8209847Ch case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R5);
		/* 8209847Ch case    0:*/		return 0x82098480;
	}
	return 0x82098480;
} // Block from 8209847Ch-82098480h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82098480h
// Function '_errcode'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098480);
		  /* 82098480h */ case    0:  		/* bc 12, CR0_EQ, 28 */
		/* 82098480h case    0:*/		if ( regs.CR[0].eq ) { return 0x8209849C;  }
		/* 82098480h case    0:*/		return 0x82098484;
		  /* 82098484h */ case    1:  		/* lwz R11, <#[R1 + 180]> */
		/* 82098484h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 82098484h case    1:*/		return 0x82098488;
		  /* 82098488h */ case    2:  		/* lis R27, -16384 */
		/* 82098488h case    2:*/		cpu::op::lis<0>(regs,&regs.R27,0xFFFFC000);
		/* 82098488h case    2:*/		return 0x8209848C;
		  /* 8209848Ch */ case    3:  		/* ori R27, R27, 145 */
		/* 8209848Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x91);
		/* 8209848Ch case    3:*/		return 0x82098490;
		  /* 82098490h */ case    4:  		/* lwz R10, <#[R11 + 4]> */
		/* 82098490h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82098490h case    4:*/		return 0x82098494;
		  /* 82098494h */ case    5:  		/* oris R10, R10, 8192 */
		/* 82098494h case    5:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x2000);
		/* 82098494h case    5:*/		return 0x82098498;
		  /* 82098498h */ case    6:  		/* stw R10, <#[R11 + 4]> */
		/* 82098498h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82098498h case    6:*/		return 0x8209849C;
	}
	return 0x8209849C;
} // Block from 82098480h-8209849Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209849Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209849C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209849C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209849C);
		  /* 8209849Ch */ case    0:  		/* rlwinm. R11, R5, 0, 29, 29 */
		/* 8209849Ch case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R5);
		/* 8209849Ch case    0:*/		return 0x820984A0;
		  /* 820984A0h */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 820984A0h case    1:*/		if ( regs.CR[0].eq ) { return 0x820984BC;  }
		/* 820984A0h case    1:*/		return 0x820984A4;
		  /* 820984A4h */ case    2:  		/* lwz R11, <#[R1 + 180]> */
		/* 820984A4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 820984A4h case    2:*/		return 0x820984A8;
		  /* 820984A8h */ case    3:  		/* lis R27, -16384 */
		/* 820984A8h case    3:*/		cpu::op::lis<0>(regs,&regs.R27,0xFFFFC000);
		/* 820984A8h case    3:*/		return 0x820984AC;
		  /* 820984ACh */ case    4:  		/* ori R27, R27, 142 */
		/* 820984ACh case    4:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x8E);
		/* 820984ACh case    4:*/		return 0x820984B0;
		  /* 820984B0h */ case    5:  		/* lwz R10, <#[R11 + 4]> */
		/* 820984B0h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820984B0h case    5:*/		return 0x820984B4;
		  /* 820984B4h */ case    6:  		/* oris R10, R10, 4096 */
		/* 820984B4h case    6:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x1000);
		/* 820984B4h case    6:*/		return 0x820984B8;
		  /* 820984B8h */ case    7:  		/* stw R10, <#[R11 + 4]> */
		/* 820984B8h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820984B8h case    7:*/		return 0x820984BC;
	}
	return 0x820984BC;
} // Block from 8209849Ch-820984BCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 820984BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820984BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820984BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820984BC);
		  /* 820984BCh */ case    0:  		/* rlwinm. R11, R5, 0, 28, 28 */
		/* 820984BCh case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R5);
		/* 820984BCh case    0:*/		return 0x820984C0;
		  /* 820984C0h */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 820984C0h case    1:*/		if ( regs.CR[0].eq ) { return 0x820984DC;  }
		/* 820984C0h case    1:*/		return 0x820984C4;
		  /* 820984C4h */ case    2:  		/* lwz R11, <#[R1 + 180]> */
		/* 820984C4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 820984C4h case    2:*/		return 0x820984C8;
	}
	return 0x820984C8;
} // Block from 820984BCh-820984C8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820984C8h
// Function '_umatherr'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820984C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820984C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820984C8);
		  /* 820984C8h */ case    0:  		/* lis R27, -16384 */
		/* 820984C8h case    0:*/		cpu::op::lis<0>(regs,&regs.R27,0xFFFFC000);
		/* 820984C8h case    0:*/		return 0x820984CC;
		  /* 820984CCh */ case    1:  		/* ori R27, R27, 144 */
		/* 820984CCh case    1:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x90);
		/* 820984CCh case    1:*/		return 0x820984D0;
		  /* 820984D0h */ case    2:  		/* lwz R10, <#[R11 + 4]> */
		/* 820984D0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820984D0h case    2:*/		return 0x820984D4;
		  /* 820984D4h */ case    3:  		/* oris R10, R10, 2048 */
		/* 820984D4h case    3:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x800);
		/* 820984D4h case    3:*/		return 0x820984D8;
		  /* 820984D8h */ case    4:  		/* stw R10, <#[R11 + 4]> */
		/* 820984D8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820984D8h case    4:*/		return 0x820984DC;
	}
	return 0x820984DC;
} // Block from 820984C8h-820984DCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820984DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820984DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820984DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820984DC);
		  /* 820984DCh */ case    0:  		/* lwz R11, <#[R1 + 180]> */
		/* 820984DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 820984DCh case    0:*/		return 0x820984E0;
		  /* 820984E0h */ case    1:  		/* lwz R10, <#[R31]> */
		/* 820984E0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820984E0h case    1:*/		return 0x820984E4;
		  /* 820984E4h */ case    2:  		/* nor R10, R10, R10 */
		/* 820984E4h case    2:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 820984E4h case    2:*/		return 0x820984E8;
		  /* 820984E8h */ case    3:  		/* lwz R9, <#[R11 + 8]> */
		/* 820984E8h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 820984E8h case    3:*/		return 0x820984EC;
		  /* 820984ECh */ case    4:  		/* rlwimi R9, R10, 20, 4, 4 */
		/* 820984ECh case    4:*/		cpu::op::rlwimi<0,20,4,4>(regs,&regs.R9,regs.R10);
		/* 820984ECh case    4:*/		return 0x820984F0;
		  /* 820984F0h */ case    5:  		/* stw R9, <#[R11 + 8]> */
		/* 820984F0h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 820984F0h case    5:*/		return 0x820984F4;
		  /* 820984F4h */ case    6:  		/* lwz R11, <#[R1 + 180]> */
		/* 820984F4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 820984F4h case    6:*/		return 0x820984F8;
		  /* 820984F8h */ case    7:  		/* lwz R10, <#[R31]> */
		/* 820984F8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820984F8h case    7:*/		return 0x820984FC;
		  /* 820984FCh */ case    8:  		/* nor R10, R10, R10 */
		/* 820984FCh case    8:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 820984FCh case    8:*/		return 0x82098500;
		  /* 82098500h */ case    9:  		/* lwz R9, <#[R11 + 8]> */
		/* 82098500h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82098500h case    9:*/		return 0x82098504;
		  /* 82098504h */ case   10:  		/* rlwimi R9, R10, 24, 3, 3 */
		/* 82098504h case   10:*/		cpu::op::rlwimi<0,24,3,3>(regs,&regs.R9,regs.R10);
		/* 82098504h case   10:*/		return 0x82098508;
		  /* 82098508h */ case   11:  		/* stw R9, <#[R11 + 8]> */
		/* 82098508h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82098508h case   11:*/		return 0x8209850C;
		  /* 8209850Ch */ case   12:  		/* lwz R11, <#[R1 + 180]> */
		/* 8209850Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 8209850Ch case   12:*/		return 0x82098510;
		  /* 82098510h */ case   13:  		/* lwz R10, <#[R31]> */
		/* 82098510h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82098510h case   13:*/		return 0x82098514;
		  /* 82098514h */ case   14:  		/* nor R10, R10, R10 */
		/* 82098514h case   14:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82098514h case   14:*/		return 0x82098518;
		  /* 82098518h */ case   15:  		/* lwz R9, <#[R11 + 8]> */
		/* 82098518h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82098518h case   15:*/		return 0x8209851C;
		  /* 8209851Ch */ case   16:  		/* rlwimi R9, R10, 23, 2, 2 */
		/* 8209851Ch case   16:*/		cpu::op::rlwimi<0,23,2,2>(regs,&regs.R9,regs.R10);
		/* 8209851Ch case   16:*/		return 0x82098520;
		  /* 82098520h */ case   17:  		/* stw R9, <#[R11 + 8]> */
		/* 82098520h case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82098520h case   17:*/		return 0x82098524;
		  /* 82098524h */ case   18:  		/* lwz R11, <#[R1 + 180]> */
		/* 82098524h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 82098524h case   18:*/		return 0x82098528;
		  /* 82098528h */ case   19:  		/* lwz R10, <#[R31]> */
		/* 82098528h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82098528h case   19:*/		return 0x8209852C;
		  /* 8209852Ch */ case   20:  		/* nor R10, R10, R10 */
		/* 8209852Ch case   20:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8209852Ch case   20:*/		return 0x82098530;
		  /* 82098530h */ case   21:  		/* lwz R9, <#[R11 + 8]> */
		/* 82098530h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82098530h case   21:*/		return 0x82098534;
		  /* 82098534h */ case   22:  		/* rlwimi R9, R10, 25, 1, 1 */
		/* 82098534h case   22:*/		cpu::op::rlwimi<0,25,1,1>(regs,&regs.R9,regs.R10);
		/* 82098534h case   22:*/		return 0x82098538;
		  /* 82098538h */ case   23:  		/* stw R9, <#[R11 + 8]> */
		/* 82098538h case   23:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82098538h case   23:*/		return 0x8209853C;
		  /* 8209853Ch */ case   24:  		/* lwz R11, <#[R1 + 180]> */
		/* 8209853Ch case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 8209853Ch case   24:*/		return 0x82098540;
		  /* 82098540h */ case   25:  		/* lwz R10, <#[R31]> */
		/* 82098540h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82098540h case   25:*/		return 0x82098544;
		  /* 82098544h */ case   26:  		/* nor R10, R10, R10 */
		/* 82098544h case   26:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82098544h case   26:*/		return 0x82098548;
		  /* 82098548h */ case   27:  		/* lwz R9, <#[R11 + 8]> */
		/* 82098548h case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82098548h case   27:*/		return 0x8209854C;
		  /* 8209854Ch */ case   28:  		/* rlwimi R9, R10, 28, 0, 0 */
		/* 8209854Ch case   28:*/		cpu::op::rlwimi<0,28,0,0>(regs,&regs.R9,regs.R10);
		/* 8209854Ch case   28:*/		return 0x82098550;
		  /* 82098550h */ case   29:  		/* stw R9, <#[R11 + 8]> */
		/* 82098550h case   29:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82098550h case   29:*/		return 0x82098554;
		  /* 82098554h */ case   30:  		/* bl 2460 */
		/* 82098554h case   30:*/		regs.LR = 0x82098558; return 0x82098EF0;
		/* 82098554h case   30:*/		return 0x82098558;
		  /* 82098558h */ case   31:  		/* rlwinm. R11, R3, 0, 2, 2 */
		/* 82098558h case   31:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R11,regs.R3);
		/* 82098558h case   31:*/		return 0x8209855C;
		  /* 8209855Ch */ case   32:  		/* bc 12, CR0_EQ, 20 */
		/* 8209855Ch case   32:*/		if ( regs.CR[0].eq ) { return 0x82098570;  }
		/* 8209855Ch case   32:*/		return 0x82098560;
		  /* 82098560h */ case   33:  		/* lwz R11, <#[R1 + 180]> */
		/* 82098560h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 82098560h case   33:*/		return 0x82098564;
		  /* 82098564h */ case   34:  		/* lwz R10, <#[R11 + 12]> */
		/* 82098564h case   34:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82098564h case   34:*/		return 0x82098568;
		  /* 82098568h */ case   35:  		/* oris R10, R10, 2048 */
		/* 82098568h case   35:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x800);
		/* 82098568h case   35:*/		return 0x8209856C;
		  /* 8209856Ch */ case   36:  		/* stw R10, <#[R11 + 12]> */
		/* 8209856Ch case   36:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8209856Ch case   36:*/		return 0x82098570;
	}
	return 0x82098570;
} // Block from 820984DCh-82098570h (37 instructions)

//////////////////////////////////////////////////////
// Block at 82098570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098570);
		  /* 82098570h */ case    0:  		/* rlwinm. R11, R3, 0, 5, 5 */
		/* 82098570h case    0:*/		cpu::op::rlwinm<1,0,5,5>(regs,&regs.R11,regs.R3);
		/* 82098570h case    0:*/		return 0x82098574;
		  /* 82098574h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 82098574h case    1:*/		if ( regs.CR[0].eq ) { return 0x82098588;  }
		/* 82098574h case    1:*/		return 0x82098578;
		  /* 82098578h */ case    2:  		/* lwz R11, <#[R1 + 180]> */
		/* 82098578h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 82098578h case    2:*/		return 0x8209857C;
		  /* 8209857Ch */ case    3:  		/* lwz R10, <#[R11 + 12]> */
		/* 8209857Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8209857Ch case    3:*/		return 0x82098580;
		  /* 82098580h */ case    4:  		/* oris R10, R10, 4096 */
		/* 82098580h case    4:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x1000);
		/* 82098580h case    4:*/		return 0x82098584;
		  /* 82098584h */ case    5:  		/* stw R10, <#[R11 + 12]> */
		/* 82098584h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82098584h case    5:*/		return 0x82098588;
	}
	return 0x82098588;
} // Block from 82098570h-82098588h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82098588h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098588( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098588) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098588);
		  /* 82098588h */ case    0:  		/* rlwinm. R11, R3, 0, 3, 3 */
		/* 82098588h case    0:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R11,regs.R3);
		/* 82098588h case    0:*/		return 0x8209858C;
		  /* 8209858Ch */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 8209858Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820985A0;  }
		/* 8209858Ch case    1:*/		return 0x82098590;
		  /* 82098590h */ case    2:  		/* lwz R11, <#[R1 + 180]> */
		/* 82098590h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 82098590h case    2:*/		return 0x82098594;
		  /* 82098594h */ case    3:  		/* lwz R10, <#[R11 + 12]> */
		/* 82098594h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82098594h case    3:*/		return 0x82098598;
		  /* 82098598h */ case    4:  		/* oris R10, R10, 8192 */
		/* 82098598h case    4:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x2000);
		/* 82098598h case    4:*/		return 0x8209859C;
		  /* 8209859Ch */ case    5:  		/* stw R10, <#[R11 + 12]> */
		/* 8209859Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8209859Ch case    5:*/		return 0x820985A0;
	}
	return 0x820985A0;
} // Block from 82098588h-820985A0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820985A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820985A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820985A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820985A0);
		  /* 820985A0h */ case    0:  		/* rlwinm. R11, R3, 0, 4, 4 */
		/* 820985A0h case    0:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R11,regs.R3);
		/* 820985A0h case    0:*/		return 0x820985A4;
		  /* 820985A4h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 820985A4h case    1:*/		if ( regs.CR[0].eq ) { return 0x820985B8;  }
		/* 820985A4h case    1:*/		return 0x820985A8;
		  /* 820985A8h */ case    2:  		/* lwz R11, <#[R1 + 180]> */
		/* 820985A8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 820985A8h case    2:*/		return 0x820985AC;
		  /* 820985ACh */ case    3:  		/* lwz R10, <#[R11 + 12]> */
		/* 820985ACh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820985ACh case    3:*/		return 0x820985B0;
		  /* 820985B0h */ case    4:  		/* oris R10, R10, 16384 */
		/* 820985B0h case    4:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x4000);
		/* 820985B0h case    4:*/		return 0x820985B4;
		  /* 820985B4h */ case    5:  		/* stw R10, <#[R11 + 12]> */
		/* 820985B4h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820985B4h case    5:*/		return 0x820985B8;
	}
	return 0x820985B8;
} // Block from 820985A0h-820985B8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820985B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820985B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820985B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820985B8);
		  /* 820985B8h */ case    0:  		/* rlwinm. R11, R3, 0, 6, 6 */
		/* 820985B8h case    0:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R11,regs.R3);
		/* 820985B8h case    0:*/		return 0x820985BC;
		  /* 820985BCh */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 820985BCh case    1:*/		if ( regs.CR[0].eq ) { return 0x820985D0;  }
		/* 820985BCh case    1:*/		return 0x820985C0;
		  /* 820985C0h */ case    2:  		/* lwz R11, <#[R1 + 180]> */
		/* 820985C0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 820985C0h case    2:*/		return 0x820985C4;
		  /* 820985C4h */ case    3:  		/* lwz R10, <#[R11 + 12]> */
		/* 820985C4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820985C4h case    3:*/		return 0x820985C8;
		  /* 820985C8h */ case    4:  		/* oris R10, R10, 32768 */
		/* 820985C8h case    4:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x8000);
		/* 820985C8h case    4:*/		return 0x820985CC;
		  /* 820985CCh */ case    5:  		/* stw R10, <#[R11 + 12]> */
		/* 820985CCh case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820985CCh case    5:*/		return 0x820985D0;
	}
	return 0x820985D0;
} // Block from 820985B8h-820985D0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820985D0h
// Function '_handle_qnan1'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820985D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820985D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820985D0);
		  /* 820985D0h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820985D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820985D0h case    0:*/		return 0x820985D4;
		  /* 820985D4h */ case    1:  		/* li R30, 1 */
		/* 820985D4h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820985D4h case    1:*/		return 0x820985D8;
		  /* 820985D8h */ case    2:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 820985D8h case    2:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 820985D8h case    2:*/		return 0x820985DC;
		  /* 820985DCh */ case    3:  		/* cmplwi CR6, R11, 1 */
		/* 820985DCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820985DCh case    3:*/		return 0x820985E0;
		  /* 820985E0h */ case    4:  		/* bc 12, CR6_LT, 68 */
		/* 820985E0h case    4:*/		if ( regs.CR[6].lt ) { return 0x82098624;  }
		/* 820985E0h case    4:*/		return 0x820985E4;
		  /* 820985E4h */ case    5:  		/* bc 12, CR6_EQ, 48 */
		/* 820985E4h case    5:*/		if ( regs.CR[6].eq ) { return 0x82098614;  }
		/* 820985E4h case    5:*/		return 0x820985E8;
		  /* 820985E8h */ case    6:  		/* cmplwi CR6, R11, 3 */
		/* 820985E8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820985E8h case    6:*/		return 0x820985EC;
		  /* 820985ECh */ case    7:  		/* bc 12, CR6_LT, 24 */
		/* 820985ECh case    7:*/		if ( regs.CR[6].lt ) { return 0x82098604;  }
		/* 820985ECh case    7:*/		return 0x820985F0;
		  /* 820985F0h */ case    8:  		/* bc 4, CR6_EQ, 68 */
		/* 820985F0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82098634;  }
		/* 820985F0h case    8:*/		return 0x820985F4;
		  /* 820985F4h */ case    9:  		/* lwz R11, <#[R1 + 180]> */
		/* 820985F4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 820985F4h case    9:*/		return 0x820985F8;
		  /* 820985F8h */ case   10:  		/* lwz R10, <#[R11]> */
		/* 820985F8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820985F8h case   10:*/		return 0x820985FC;
		  /* 820985FCh */ case   11:  		/* rlwimi R10, R30, 30, 0, 1 */
		/* 820985FCh case   11:*/		cpu::op::rlwimi<0,30,0,1>(regs,&regs.R10,regs.R30);
		/* 820985FCh case   11:*/		return 0x82098600;
		  /* 82098600h */ case   12:  		/* b 48 */
		/* 82098600h case   12:*/		return 0x82098630;
		/* 82098600h case   12:*/		return 0x82098604;
	}
	return 0x82098604;
} // Block from 820985D0h-82098604h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82098604h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098604( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098604) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098604);
		  /* 82098604h */ case    0:  		/* lwz R11, <#[R1 + 180]> */
		/* 82098604h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 82098604h case    0:*/		return 0x82098608;
		  /* 82098608h */ case    1:  		/* lwz R10, <#[R11]> */
		/* 82098608h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82098608h case    1:*/		return 0x8209860C;
		  /* 8209860Ch */ case    2:  		/* rlwimi R10, R30, 31, 0, 1 */
		/* 8209860Ch case    2:*/		cpu::op::rlwimi<0,31,0,1>(regs,&regs.R10,regs.R30);
		/* 8209860Ch case    2:*/		return 0x82098610;
		  /* 82098610h */ case    3:  		/* b 32 */
		/* 82098610h case    3:*/		return 0x82098630;
		/* 82098610h case    3:*/		return 0x82098614;
	}
	return 0x82098614;
} // Block from 82098604h-82098614h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82098614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098614);
		  /* 82098614h */ case    0:  		/* lwz R11, <#[R1 + 180]> */
		/* 82098614h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 82098614h case    0:*/		return 0x82098618;
		  /* 82098618h */ case    1:  		/* lwz R10, <#[R11]> */
		/* 82098618h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82098618h case    1:*/		return 0x8209861C;
		  /* 8209861Ch */ case    2:  		/* oris R10, R10, 49152 */
		/* 8209861Ch case    2:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0xC000);
		/* 8209861Ch case    2:*/		return 0x82098620;
		  /* 82098620h */ case    3:  		/* b 16 */
		/* 82098620h case    3:*/		return 0x82098630;
		/* 82098620h case    3:*/		return 0x82098624;
	}
	return 0x82098624;
} // Block from 82098614h-82098624h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82098624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098624);
		  /* 82098624h */ case    0:  		/* lwz R11, <#[R1 + 180]> */
		/* 82098624h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 82098624h case    0:*/		return 0x82098628;
		  /* 82098628h */ case    1:  		/* lwz R10, <#[R11]> */
		/* 82098628h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82098628h case    1:*/		return 0x8209862C;
		  /* 8209862Ch */ case    2:  		/* rlwinm R10, R10, 0, 2, 31 */
		/* 8209862Ch case    2:*/		cpu::op::rlwinm<0,0,2,31>(regs,&regs.R10,regs.R10);
		/* 8209862Ch case    2:*/		return 0x82098630;
	}
	return 0x82098630;
} // Block from 82098624h-82098630h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82098630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098630);
		  /* 82098630h */ case    0:  		/* stw R10, <#[R11]> */
		/* 82098630h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82098630h case    0:*/		return 0x82098634;
	}
	return 0x82098634;
} // Block from 82098630h-82098634h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82098634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098634);
		  /* 82098634h */ case    0:  		/* lwz R11, <#[R1 + 180]> */
		/* 82098634h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 82098634h case    0:*/		return 0x82098638;
		  /* 82098638h */ case    1:  		/* cmpwi CR6, R25, 0 */
		/* 82098638h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82098638h case    1:*/		return 0x8209863C;
		  /* 8209863Ch */ case    2:  		/* lwz R10, <#[R11]> */
		/* 8209863Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209863Ch case    2:*/		return 0x82098640;
		  /* 82098640h */ case    3:  		/* rlwimi R10, R30, 27, 2, 4 */
		/* 82098640h case    3:*/		cpu::op::rlwimi<0,27,2,4>(regs,&regs.R10,regs.R30);
		/* 82098640h case    3:*/		return 0x82098644;
		  /* 82098644h */ case    4:  		/* stw R10, <#[R11]> */
		/* 82098644h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82098644h case    4:*/		return 0x82098648;
		  /* 82098648h */ case    5:  		/* lwz R11, <#[R1 + 180]> */
		/* 82098648h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 82098648h case    5:*/		return 0x8209864C;
		  /* 8209864Ch */ case    6:  		/* lwz R10, <#[R11]> */
		/* 8209864Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209864Ch case    6:*/		return 0x82098650;
		  /* 82098650h */ case    7:  		/* rlwimi R10, R28, 15, 5, 16 */
		/* 82098650h case    7:*/		cpu::op::rlwimi<0,15,5,16>(regs,&regs.R10,regs.R28);
		/* 82098650h case    7:*/		return 0x82098654;
		  /* 82098654h */ case    8:  		/* stw R10, <#[R11]> */
		/* 82098654h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82098654h case    8:*/		return 0x82098658;
	}
	return 0x82098658;
} // Block from 82098634h-82098658h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82098658h
// Function '_handle_qnan2'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098658);
		  /* 82098658h */ case    0:  		/* lwz R11, <#[R1 + 180]> */
		/* 82098658h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 82098658h case    0:*/		return 0x8209865C;
		  /* 8209865Ch */ case    1:  		/* lwz R10, <#[R11 + 32]> */
		/* 8209865Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000020) );
		/* 8209865Ch case    1:*/		return 0x82098660;
		  /* 82098660h */ case    2:  		/* oris R10, R10, 32768 */
		/* 82098660h case    2:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x8000);
		/* 82098660h case    2:*/		return 0x82098664;
		  /* 82098664h */ case    3:  		/* stw R10, <#[R11 + 32]> */
		/* 82098664h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000020) );
		/* 82098664h case    3:*/		return 0x82098668;
		  /* 82098668h */ case    4:  		/* lwz R11, <#[R1 + 180]> */
		/* 82098668h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 82098668h case    4:*/		return 0x8209866C;
		  /* 8209866Ch */ case    5:  		/* lwz R10, <#[R11 + 32]> */
		/* 8209866Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000020) );
		/* 8209866Ch case    5:*/		return 0x82098670;
		  /* 82098670h */ case    6:  		/* bc 12, CR6_EQ, 72 */
		/* 82098670h case    6:*/		if ( regs.CR[6].eq ) { return 0x820986B8;  }
		/* 82098670h case    6:*/		return 0x82098674;
		  /* 82098674h */ case    7:  		/* rlwinm R10, R10, 0, 5, 0 */
		/* 82098674h case    7:*/		cpu::op::rlwinm<0,0,5,0>(regs,&regs.R10,regs.R10);
		/* 82098674h case    7:*/		return 0x82098678;
		  /* 82098678h */ case    8:  		/* stw R10, <#[R11 + 32]> */
		/* 82098678h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000020) );
		/* 82098678h case    8:*/		return 0x8209867C;
		  /* 8209867Ch */ case    9:  		/* lfs FR0, <#[R29]> */
		/* 8209867Ch case    9:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R29 + 0x00000000) );
		/* 8209867Ch case    9:*/		return 0x82098680;
		  /* 82098680h */ case   10:  		/* lwz R11, <#[R1 + 180]> */
		/* 82098680h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 82098680h case   10:*/		return 0x82098684;
		  /* 82098684h */ case   11:  		/* stfs FR0, <#[R11 + 16]> */
		/* 82098684h case   11:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000010) );
		/* 82098684h case   11:*/		return 0x82098688;
		  /* 82098688h */ case   12:  		/* lwz R11, <#[R1 + 180]> */
		/* 82098688h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 82098688h case   12:*/		return 0x8209868C;
		  /* 8209868Ch */ case   13:  		/* lwz R10, <#[R11 + 96]> */
		/* 8209868Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000060) );
		/* 8209868Ch case   13:*/		return 0x82098690;
		  /* 82098690h */ case   14:  		/* oris R10, R10, 32768 */
		/* 82098690h case   14:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x8000);
		/* 82098690h case   14:*/		return 0x82098694;
		  /* 82098694h */ case   15:  		/* stw R10, <#[R11 + 96]> */
		/* 82098694h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000060) );
		/* 82098694h case   15:*/		return 0x82098698;
		  /* 82098698h */ case   16:  		/* lwz R11, <#[R1 + 180]> */
		/* 82098698h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 82098698h case   16:*/		return 0x8209869C;
		  /* 8209869Ch */ case   17:  		/* lwz R10, <#[R11 + 96]> */
		/* 8209869Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000060) );
		/* 8209869Ch case   17:*/		return 0x820986A0;
		  /* 820986A0h */ case   18:  		/* rlwinm R10, R10, 0, 5, 0 */
		/* 820986A0h case   18:*/		cpu::op::rlwinm<0,0,5,0>(regs,&regs.R10,regs.R10);
		/* 820986A0h case   18:*/		return 0x820986A4;
		  /* 820986A4h */ case   19:  		/* stw R10, <#[R11 + 96]> */
		/* 820986A4h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000060) );
		/* 820986A4h case   19:*/		return 0x820986A8;
		  /* 820986A8h */ case   20:  		/* lwz R11, <#[R1 + 180]> */
		/* 820986A8h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 820986A8h case   20:*/		return 0x820986AC;
		  /* 820986ACh */ case   21:  		/* lfs FR0, <#[R26]> */
		/* 820986ACh case   21:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R26 + 0x00000000) );
		/* 820986ACh case   21:*/		return 0x820986B0;
		  /* 820986B0h */ case   22:  		/* stfs FR0, <#[R11 + 80]> */
		/* 820986B0h case   22:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000050) );
		/* 820986B0h case   22:*/		return 0x820986B4;
		  /* 820986B4h */ case   23:  		/* b 68 */
		/* 820986B4h case   23:*/		return 0x820986F8;
		/* 820986B4h case   23:*/		return 0x820986B8;
	}
	return 0x820986B8;
} // Block from 82098658h-820986B8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820986B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820986B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820986B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820986B8);
		  /* 820986B8h */ case    0:  		/* rlwimi R10, R30, 27, 1, 4 */
		/* 820986B8h case    0:*/		cpu::op::rlwimi<0,27,1,4>(regs,&regs.R10,regs.R30);
		/* 820986B8h case    0:*/		return 0x820986BC;
		  /* 820986BCh */ case    1:  		/* stw R10, <#[R11 + 32]> */
		/* 820986BCh case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000020) );
		/* 820986BCh case    1:*/		return 0x820986C0;
		  /* 820986C0h */ case    2:  		/* lwz R11, <#[R1 + 180]> */
		/* 820986C0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 820986C0h case    2:*/		return 0x820986C4;
		  /* 820986C4h */ case    3:  		/* lfd FR0, <#[R29]> */
		/* 820986C4h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R29 + 0x00000000) );
		/* 820986C4h case    3:*/		return 0x820986C8;
		  /* 820986C8h */ case    4:  		/* stfd FR0, <#[R11 + 16]> */
		/* 820986C8h case    4:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000010) );
		/* 820986C8h case    4:*/		return 0x820986CC;
		  /* 820986CCh */ case    5:  		/* lwz R11, <#[R1 + 180]> */
		/* 820986CCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 820986CCh case    5:*/		return 0x820986D0;
		  /* 820986D0h */ case    6:  		/* lwz R10, <#[R11 + 96]> */
		/* 820986D0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000060) );
		/* 820986D0h case    6:*/		return 0x820986D4;
		  /* 820986D4h */ case    7:  		/* oris R10, R10, 32768 */
		/* 820986D4h case    7:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x8000);
		/* 820986D4h case    7:*/		return 0x820986D8;
	}
	return 0x820986D8;
} // Block from 820986B8h-820986D8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820986D8h
// Function '_except1'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820986D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820986D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820986D8);
		  /* 820986D8h */ case    0:  		/* stw R10, <#[R11 + 96]> */
		/* 820986D8h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000060) );
		/* 820986D8h case    0:*/		return 0x820986DC;
		  /* 820986DCh */ case    1:  		/* lwz R11, <#[R1 + 180]> */
		/* 820986DCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 820986DCh case    1:*/		return 0x820986E0;
		  /* 820986E0h */ case    2:  		/* lwz R10, <#[R11 + 96]> */
		/* 820986E0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000060) );
		/* 820986E0h case    2:*/		return 0x820986E4;
		  /* 820986E4h */ case    3:  		/* rlwimi R10, R30, 27, 1, 4 */
		/* 820986E4h case    3:*/		cpu::op::rlwimi<0,27,1,4>(regs,&regs.R10,regs.R30);
		/* 820986E4h case    3:*/		return 0x820986E8;
		  /* 820986E8h */ case    4:  		/* stw R10, <#[R11 + 96]> */
		/* 820986E8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000060) );
		/* 820986E8h case    4:*/		return 0x820986EC;
		  /* 820986ECh */ case    5:  		/* lwz R11, <#[R1 + 180]> */
		/* 820986ECh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 820986ECh case    5:*/		return 0x820986F0;
		  /* 820986F0h */ case    6:  		/* lfd FR0, <#[R26]> */
		/* 820986F0h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R26 + 0x00000000) );
		/* 820986F0h case    6:*/		return 0x820986F4;
		  /* 820986F4h */ case    7:  		/* stfd FR0, <#[R11 + 80]> */
		/* 820986F4h case    7:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000050) );
		/* 820986F4h case    7:*/		return 0x820986F8;
	}
	return 0x820986F8;
} // Block from 820986D8h-820986F8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820986F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820986F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820986F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820986F8);
		  /* 820986F8h */ case    0:  		/* bl 11264 */
		/* 820986F8h case    0:*/		regs.LR = 0x820986FC; return 0x8209B2F8;
		/* 820986F8h case    0:*/		return 0x820986FC;
		  /* 820986FCh */ case    1:  		/* addi R6, R1, 180 */
		/* 820986FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0xB4);
		/* 820986FCh case    1:*/		return 0x82098700;
		  /* 82098700h */ case    2:  		/* li R5, 1 */
		/* 82098700h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82098700h case    2:*/		return 0x82098704;
		  /* 82098704h */ case    3:  		/* li R4, 0 */
		/* 82098704h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82098704h case    3:*/		return 0x82098708;
		  /* 82098708h */ case    4:  		/* mr R3, R27 */
		/* 82098708h case    4:*/		regs.R3 = regs.R27;
		/* 82098708h case    4:*/		return 0x8209870C;
		  /* 8209870Ch */ case    5:  		/* bl 1895364 */
		/* 8209870Ch case    5:*/		regs.LR = 0x82098710; return 0x822672D0;
		/* 8209870Ch case    5:*/		return 0x82098710;
		  /* 82098710h */ case    6:  		/* lwz R10, <#[R1 + 180]> */
		/* 82098710h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000B4) );
		/* 82098710h case    6:*/		return 0x82098714;
		  /* 82098714h */ case    7:  		/* lwz R11, <#[R10 + 8]> */
		/* 82098714h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82098714h case    7:*/		return 0x82098718;
		  /* 82098718h */ case    8:  		/* rlwinm. R11, R11, 0, 4, 4 */
		/* 82098718h case    8:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R11,regs.R11);
		/* 82098718h case    8:*/		return 0x8209871C;
		  /* 8209871Ch */ case    9:  		/* bc 12, CR0_EQ, 16 */
		/* 8209871Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x8209872C;  }
		/* 8209871Ch case    9:*/		return 0x82098720;
		  /* 82098720h */ case   10:  		/* lwz R11, <#[R31]> */
		/* 82098720h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82098720h case   10:*/		return 0x82098724;
		  /* 82098724h */ case   11:  		/* rlwinm R11, R11, 0, 25, 23 */
		/* 82098724h case   11:*/		cpu::op::rlwinm<0,0,25,23>(regs,&regs.R11,regs.R11);
		/* 82098724h case   11:*/		return 0x82098728;
		  /* 82098728h */ case   12:  		/* stw R11, <#[R31]> */
		/* 82098728h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82098728h case   12:*/		return 0x8209872C;
	}
	return 0x8209872C;
} // Block from 820986F8h-8209872Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209872Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209872C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209872C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209872C);
		  /* 8209872Ch */ case    0:  		/* lwz R11, <#[R10 + 8]> */
		/* 8209872Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8209872Ch case    0:*/		return 0x82098730;
		  /* 82098730h */ case    1:  		/* rlwinm. R11, R11, 0, 3, 3 */
		/* 82098730h case    1:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R11,regs.R11);
		/* 82098730h case    1:*/		return 0x82098734;
		  /* 82098734h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 82098734h case    2:*/		if ( regs.CR[0].eq ) { return 0x82098744;  }
		/* 82098734h case    2:*/		return 0x82098738;
		  /* 82098738h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 82098738h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82098738h case    3:*/		return 0x8209873C;
		  /* 8209873Ch */ case    4:  		/* rlwinm R11, R11, 0, 28, 26 */
		/* 8209873Ch case    4:*/		cpu::op::rlwinm<0,0,28,26>(regs,&regs.R11,regs.R11);
		/* 8209873Ch case    4:*/		return 0x82098740;
		  /* 82098740h */ case    5:  		/* stw R11, <#[R31]> */
		/* 82098740h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82098740h case    5:*/		return 0x82098744;
	}
	return 0x82098744;
} // Block from 8209872Ch-82098744h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82098744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098744);
		  /* 82098744h */ case    0:  		/* lwz R11, <#[R10 + 8]> */
		/* 82098744h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82098744h case    0:*/		return 0x82098748;
		  /* 82098748h */ case    1:  		/* rlwinm. R11, R11, 0, 2, 2 */
		/* 82098748h case    1:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R11,regs.R11);
		/* 82098748h case    1:*/		return 0x8209874C;
		  /* 8209874Ch */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8209874Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8209875C;  }
		/* 8209874Ch case    2:*/		return 0x82098750;
		  /* 82098750h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 82098750h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82098750h case    3:*/		return 0x82098754;
		  /* 82098754h */ case    4:  		/* rlwinm R11, R11, 0, 26, 24 */
		/* 82098754h case    4:*/		cpu::op::rlwinm<0,0,26,24>(regs,&regs.R11,regs.R11);
		/* 82098754h case    4:*/		return 0x82098758;
		  /* 82098758h */ case    5:  		/* stw R11, <#[R31]> */
		/* 82098758h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82098758h case    5:*/		return 0x8209875C;
	}
	return 0x8209875C;
} // Block from 82098744h-8209875Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209875Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209875C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209875C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209875C);
		  /* 8209875Ch */ case    0:  		/* lwz R11, <#[R10 + 8]> */
		/* 8209875Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8209875Ch case    0:*/		return 0x82098760;
		  /* 82098760h */ case    1:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 82098760h case    1:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 82098760h case    1:*/		return 0x82098764;
		  /* 82098764h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 82098764h case    2:*/		if ( regs.CR[0].eq ) { return 0x82098774;  }
		/* 82098764h case    2:*/		return 0x82098768;
		  /* 82098768h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 82098768h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82098768h case    3:*/		return 0x8209876C;
		  /* 8209876Ch */ case    4:  		/* rlwinm R11, R11, 0, 27, 25 */
		/* 8209876Ch case    4:*/		cpu::op::rlwinm<0,0,27,25>(regs,&regs.R11,regs.R11);
		/* 8209876Ch case    4:*/		return 0x82098770;
		  /* 82098770h */ case    5:  		/* stw R11, <#[R31]> */
		/* 82098770h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82098770h case    5:*/		return 0x82098774;
	}
	return 0x82098774;
} // Block from 8209875Ch-82098774h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82098774h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098774( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098774) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098774);
		  /* 82098774h */ case    0:  		/* lwz R11, <#[R10 + 8]> */
		/* 82098774h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82098774h case    0:*/		return 0x82098778;
		  /* 82098778h */ case    1:  		/* rlwinm. R11, R11, 0, 0, 0 */
		/* 82098778h case    1:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R11);
		/* 82098778h case    1:*/		return 0x8209877C;
		  /* 8209877Ch */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8209877Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8209878C;  }
		/* 8209877Ch case    2:*/		return 0x82098780;
		  /* 82098780h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 82098780h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82098780h case    3:*/		return 0x82098784;
		  /* 82098784h */ case    4:  		/* rlwinm R11, R11, 0, 29, 27 */
		/* 82098784h case    4:*/		cpu::op::rlwinm<0,0,29,27>(regs,&regs.R11,regs.R11);
		/* 82098784h case    4:*/		return 0x82098788;
		  /* 82098788h */ case    5:  		/* stw R11, <#[R31]> */
		/* 82098788h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82098788h case    5:*/		return 0x8209878C;
	}
	return 0x8209878C;
} // Block from 82098774h-8209878Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209878Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209878C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209878C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209878C);
		  /* 8209878Ch */ case    0:  		/* lwz R11, <#[R10]> */
		/* 8209878Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8209878Ch case    0:*/		return 0x82098790;
		  /* 82098790h */ case    1:  		/* rlwinm R11, R11, 2, 30, 31 */
		/* 82098790h case    1:*/		cpu::op::rlwinm<0,2,30,31>(regs,&regs.R11,regs.R11);
		/* 82098790h case    1:*/		return 0x82098794;
		  /* 82098794h */ case    2:  		/* cmplwi CR6, R11, 1 */
		/* 82098794h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82098794h case    2:*/		return 0x82098798;
		  /* 82098798h */ case    3:  		/* bc 12, CR6_LT, 56 */
		/* 82098798h case    3:*/		if ( regs.CR[6].lt ) { return 0x820987D0;  }
		/* 82098798h case    3:*/		return 0x8209879C;
		  /* 8209879Ch */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 8209879Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820987C4;  }
		/* 8209879Ch case    4:*/		return 0x820987A0;
		  /* 820987A0h */ case    5:  		/* cmplwi CR6, R11, 3 */
		/* 820987A0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820987A0h case    5:*/		return 0x820987A4;
		  /* 820987A4h */ case    6:  		/* bc 12, CR6_LT, 20 */
		/* 820987A4h case    6:*/		if ( regs.CR[6].lt ) { return 0x820987B8;  }
		/* 820987A4h case    6:*/		return 0x820987A8;
		  /* 820987A8h */ case    7:  		/* bc 4, CR6_EQ, 52 */
		/* 820987A8h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820987DC;  }
		/* 820987A8h case    7:*/		return 0x820987AC;
		  /* 820987ACh */ case    8:  		/* lwz R11, <#[R31]> */
		/* 820987ACh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820987ACh case    8:*/		return 0x820987B0;
	}
	return 0x820987B0;
} // Block from 8209878Ch-820987B0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820987B0h
// Function '_except2'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820987B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820987B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820987B0);
		  /* 820987B0h */ case    0:  		/* rlwimi R11, R30, 0, 30, 31 */
		/* 820987B0h case    0:*/		cpu::op::rlwimi<0,0,30,31>(regs,&regs.R11,regs.R30);
		/* 820987B0h case    0:*/		return 0x820987B4;
		  /* 820987B4h */ case    1:  		/* b 36 */
		/* 820987B4h case    1:*/		return 0x820987D8;
		/* 820987B4h case    1:*/		return 0x820987B8;
	}
	return 0x820987B8;
} // Block from 820987B0h-820987B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820987B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820987B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820987B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820987B8);
		  /* 820987B8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820987B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820987B8h case    0:*/		return 0x820987BC;
		  /* 820987BCh */ case    1:  		/* rlwimi R11, R30, 1, 30, 31 */
		/* 820987BCh case    1:*/		cpu::op::rlwimi<0,1,30,31>(regs,&regs.R11,regs.R30);
		/* 820987BCh case    1:*/		return 0x820987C0;
		  /* 820987C0h */ case    2:  		/* b 24 */
		/* 820987C0h case    2:*/		return 0x820987D8;
		/* 820987C0h case    2:*/		return 0x820987C4;
	}
	return 0x820987C4;
} // Block from 820987B8h-820987C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820987C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820987C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820987C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820987C4);
		  /* 820987C4h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820987C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820987C4h case    0:*/		return 0x820987C8;
		  /* 820987C8h */ case    1:  		/* ori R11, R11, 3 */
		/* 820987C8h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x3);
		/* 820987C8h case    1:*/		return 0x820987CC;
		  /* 820987CCh */ case    2:  		/* b 12 */
		/* 820987CCh case    2:*/		return 0x820987D8;
		/* 820987CCh case    2:*/		return 0x820987D0;
	}
	return 0x820987D0;
} // Block from 820987C4h-820987D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820987D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820987D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820987D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820987D0);
		  /* 820987D0h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820987D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820987D0h case    0:*/		return 0x820987D4;
		  /* 820987D4h */ case    1:  		/* rlwinm R11, R11, 0, 0, 29 */
		/* 820987D4h case    1:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R11);
		/* 820987D4h case    1:*/		return 0x820987D8;
	}
	return 0x820987D8;
} // Block from 820987D0h-820987D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820987D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820987D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820987D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820987D8);
		  /* 820987D8h */ case    0:  		/* stw R11, <#[R31]> */
		/* 820987D8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820987D8h case    0:*/		return 0x820987DC;
	}
	return 0x820987DC;
} // Block from 820987D8h-820987DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820987DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820987DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820987DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820987DC);
		  /* 820987DCh */ case    0:  		/* cmpwi CR6, R25, 0 */
		/* 820987DCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 820987DCh case    0:*/		return 0x820987E0;
		  /* 820987E0h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820987E0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820987F0;  }
		/* 820987E0h case    1:*/		return 0x820987E4;
		  /* 820987E4h */ case    2:  		/* lfs FR0, <#[R10 + 80]> */
		/* 820987E4h case    2:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000050) );
		/* 820987E4h case    2:*/		return 0x820987E8;
		  /* 820987E8h */ case    3:  		/* stfs FR0, <#[R26]> */
		/* 820987E8h case    3:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R26 + 0x00000000) );
		/* 820987E8h case    3:*/		return 0x820987EC;
		  /* 820987ECh */ case    4:  		/* b 12 */
		/* 820987ECh case    4:*/		return 0x820987F8;
		/* 820987ECh case    4:*/		return 0x820987F0;
	}
	return 0x820987F0;
} // Block from 820987DCh-820987F0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820987F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820987F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820987F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820987F0);
		  /* 820987F0h */ case    0:  		/* lfd FR0, <#[R10 + 80]> */
		/* 820987F0h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000050) );
		/* 820987F0h case    0:*/		return 0x820987F4;
		  /* 820987F4h */ case    1:  		/* stfd FR0, <#[R26]> */
		/* 820987F4h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R26 + 0x00000000) );
		/* 820987F4h case    1:*/		return 0x820987F8;
	}
	return 0x820987F8;
} // Block from 820987F0h-820987F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820987F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820987F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820987F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820987F8);
		  /* 820987F8h */ case    0:  		/* addi R1, R1, 160 */
		/* 820987F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820987F8h case    0:*/		return 0x820987FC;
		  /* 820987FCh */ case    1:  		/* b -30048 */
		/* 820987FCh case    1:*/		return 0x8209129C;
		/* 820987FCh case    1:*/		return 0x82098800;
	}
	return 0x82098800;
} // Block from 820987F8h-82098800h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82098800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098800);
		  /* 82098800h */ case    0:  		/* mfspr R12, LR */
		/* 82098800h case    0:*/		regs.R12 = regs.LR;
		/* 82098800h case    0:*/		return 0x82098804;
		  /* 82098804h */ case    1:  		/* bl -30128 */
		/* 82098804h case    1:*/		regs.LR = 0x82098808; return 0x82091254;
		/* 82098804h case    1:*/		return 0x82098808;
		  /* 82098808h */ case    2:  		/* stfd FR31, <#[R1 - 56]> */
		/* 82098808h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFC8) );
		/* 82098808h case    2:*/		return 0x8209880C;
		  /* 8209880Ch */ case    3:  		/* stwu R1, <#[R1 - 144]> */
		/* 8209880Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8209880Ch case    3:*/		return 0x82098810;
		  /* 82098810h */ case    4:  		/* mr R29, R3 */
		/* 82098810h case    4:*/		regs.R29 = regs.R3;
		/* 82098810h case    4:*/		return 0x82098814;
		  /* 82098814h */ case    5:  		/* mr R30, R4 */
		/* 82098814h case    5:*/		regs.R30 = regs.R4;
		/* 82098814h case    5:*/		return 0x82098818;
		  /* 82098818h */ case    6:  		/* mr R27, R5 */
		/* 82098818h case    6:*/		regs.R27 = regs.R5;
		/* 82098818h case    6:*/		return 0x8209881C;
		  /* 8209881Ch */ case    7:  		/* rlwinm. R11, R3, 0, 28, 28 */
		/* 8209881Ch case    7:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R3);
		/* 8209881Ch case    7:*/		return 0x82098820;
		  /* 82098820h */ case    8:  		/* rlwinm R28, R3, 0, 27, 31 */
		/* 82098820h case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R28,regs.R3);
		/* 82098820h case    8:*/		return 0x82098824;
		  /* 82098824h */ case    9:  		/* bc 12, CR0_EQ, 28 */
		/* 82098824h case    9:*/		if ( regs.CR[0].eq ) { return 0x82098840;  }
		/* 82098824h case    9:*/		return 0x82098828;
		  /* 82098828h */ case   10:  		/* rlwinm. R11, R5, 0, 24, 24 */
		/* 82098828h case   10:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R11,regs.R5);
		/* 82098828h case   10:*/		return 0x8209882C;
		  /* 8209882Ch */ case   11:  		/* bc 12, CR0_EQ, 20 */
		/* 8209882Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x82098840;  }
		/* 8209882Ch case   11:*/		return 0x82098830;
		  /* 82098830h */ case   12:  		/* lis R3, 8192 */
		/* 82098830h case   12:*/		cpu::op::lis<0>(regs,&regs.R3,0x2000);
		/* 82098830h case   12:*/		return 0x82098834;
		  /* 82098834h */ case   13:  		/* bl 1776 */
		/* 82098834h case   13:*/		regs.LR = 0x82098838; return 0x82098F24;
		/* 82098834h case   13:*/		return 0x82098838;
		  /* 82098838h */ case   14:  		/* rlwinm R28, R28, 0, 29, 27 */
		/* 82098838h case   14:*/		cpu::op::rlwinm<0,0,29,27>(regs,&regs.R28,regs.R28);
		/* 82098838h case   14:*/		return 0x8209883C;
		  /* 8209883Ch */ case   15:  		/* b 488 */
		/* 8209883Ch case   15:*/		return 0x82098A24;
		/* 8209883Ch case   15:*/		return 0x82098840;
	}
	return 0x82098840;
} // Block from 82098800h-82098840h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82098840h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098840);
		  /* 82098840h */ case    0:  		/* rlwinm. R11, R29, 0, 29, 29 */
		/* 82098840h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R29);
		/* 82098840h case    0:*/		return 0x82098844;
		  /* 82098844h */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 82098844h case    1:*/		if ( regs.CR[0].eq ) { return 0x82098860;  }
		/* 82098844h case    1:*/		return 0x82098848;
		  /* 82098848h */ case    2:  		/* rlwinm. R11, R27, 0, 27, 27 */
		/* 82098848h case    2:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R27);
		/* 82098848h case    2:*/		return 0x8209884C;
		  /* 8209884Ch */ case    3:  		/* bc 12, CR0_EQ, 20 */
		/* 8209884Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x82098860;  }
		/* 8209884Ch case    3:*/		return 0x82098850;
		  /* 82098850h */ case    4:  		/* lis R3, 1024 */
		/* 82098850h case    4:*/		cpu::op::lis<0>(regs,&regs.R3,0x400);
		/* 82098850h case    4:*/		return 0x82098854;
		  /* 82098854h */ case    5:  		/* bl 1744 */
		/* 82098854h case    5:*/		regs.LR = 0x82098858; return 0x82098F24;
		/* 82098854h case    5:*/		return 0x82098858;
		  /* 82098858h */ case    6:  		/* rlwinm R28, R28, 0, 30, 28 */
		/* 82098858h case    6:*/		cpu::op::rlwinm<0,0,30,28>(regs,&regs.R28,regs.R28);
		/* 82098858h case    6:*/		return 0x8209885C;
		  /* 8209885Ch */ case    7:  		/* b 456 */
		/* 8209885Ch case    7:*/		return 0x82098A24;
		/* 8209885Ch case    7:*/		return 0x82098860;
	}
	return 0x82098860;
} // Block from 82098840h-82098860h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82098860h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098860);
		  /* 82098860h */ case    0:  		/* rlwinm. R11, R29, 0, 31, 31 */
		/* 82098860h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R29);
		/* 82098860h case    0:*/		return 0x82098864;
		  /* 82098864h */ case    1:  		/* bc 12, CR0_EQ, 200 */
		/* 82098864h case    1:*/		if ( regs.CR[0].eq ) { return 0x8209892C;  }
		/* 82098864h case    1:*/		return 0x82098868;
		  /* 82098868h */ case    2:  		/* rlwinm. R11, R27, 0, 25, 25 */
		/* 82098868h case    2:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R27);
		/* 82098868h case    2:*/		return 0x8209886C;
		  /* 8209886Ch */ case    3:  		/* bc 12, CR0_EQ, 192 */
		/* 8209886Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x8209892C;  }
		/* 8209886Ch case    3:*/		return 0x82098870;
		  /* 82098870h */ case    4:  		/* lis R3, 4096 */
		/* 82098870h case    4:*/		cpu::op::lis<0>(regs,&regs.R3,0x1000);
		/* 82098870h case    4:*/		return 0x82098874;
		  /* 82098874h */ case    5:  		/* bl 1712 */
		/* 82098874h case    5:*/		regs.LR = 0x82098878; return 0x82098F24;
		/* 82098874h case    5:*/		return 0x82098878;
		  /* 82098878h */ case    6:  		/* rlwinm R11, R27, 0, 30, 31 */
		/* 82098878h case    6:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R27);
		/* 82098878h case    6:*/		return 0x8209887C;
		  /* 8209887Ch */ case    7:  		/* cmplwi CR6, R11, 1 */
		/* 8209887Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8209887Ch case    7:*/		return 0x82098880;
		  /* 82098880h */ case    8:  		/* bc 12, CR6_LT, 116 */
		/* 82098880h case    8:*/		if ( regs.CR[6].lt ) { return 0x820988F4;  }
		/* 82098880h case    8:*/		return 0x82098884;
		  /* 82098884h */ case    9:  		/* bc 12, CR6_EQ, 80 */
		/* 82098884h case    9:*/		if ( regs.CR[6].eq ) { return 0x820988D4;  }
		/* 82098884h case    9:*/		return 0x82098888;
		  /* 82098888h */ case   10:  		/* cmplwi CR6, R11, 3 */
		/* 82098888h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82098888h case   10:*/		return 0x8209888C;
		  /* 8209888Ch */ case   11:  		/* bc 12, CR6_LT, 40 */
		/* 8209888Ch case   11:*/		if ( regs.CR[6].lt ) { return 0x820988B4;  }
		/* 8209888Ch case   11:*/		return 0x82098890;
		  /* 82098890h */ case   12:  		/* bc 4, CR6_EQ, 148 */
		/* 82098890h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82098924;  }
		/* 82098890h case   12:*/		return 0x82098894;
		  /* 82098894h */ case   13:  		/* lis R11, -32256 */
		/* 82098894h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82098894h case   13:*/		return 0x82098898;
		  /* 82098898h */ case   14:  		/* lfd FR13, <#[R30]> */
		/* 82098898h case   14:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R30 + 0x00000000) );
		/* 82098898h case   14:*/		return 0x8209889C;
		  /* 8209889Ch */ case   15:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 8209889Ch case   15:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 8209889Ch case   15:*/		return 0x820988A0;
	}
	return 0x820988A0;
} // Block from 82098860h-820988A0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820988A0h
// Function '_ctrlfp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820988A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820988A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820988A0);
		  /* 820988A0h */ case    0:  		/* fcmpu CR6, FR13, FR0 */
		/* 820988A0h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820988A0h case    0:*/		return 0x820988A4;
		  /* 820988A4h */ case    1:  		/* bc 4, CR6_GT, 112 */
		/* 820988A4h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82098914;  }
		/* 820988A4h case    1:*/		return 0x820988A8;
		  /* 820988A8h */ case    2:  		/* lis R11, -32217 */
		/* 820988A8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 820988A8h case    2:*/		return 0x820988AC;
		  /* 820988ACh */ case    3:  		/* lfd FR0, <#[R11 + 7344]> */
		/* 820988ACh case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001CB0) );
		/* 820988ACh case    3:*/		return 0x820988B0;
		  /* 820988B0h */ case    4:  		/* b 112 */
		/* 820988B0h case    4:*/		return 0x82098920;
		/* 820988B0h case    4:*/		return 0x820988B4;
	}
	return 0x820988B4;
} // Block from 820988A0h-820988B4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820988B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820988B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820988B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820988B4);
		  /* 820988B4h */ case    0:  		/* lis R11, -32256 */
		/* 820988B4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820988B4h case    0:*/		return 0x820988B8;
		  /* 820988B8h */ case    1:  		/* lfd FR13, <#[R30]> */
		/* 820988B8h case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R30 + 0x00000000) );
		/* 820988B8h case    1:*/		return 0x820988BC;
		  /* 820988BCh */ case    2:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 820988BCh case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 820988BCh case    2:*/		return 0x820988C0;
		  /* 820988C0h */ case    3:  		/* fcmpu CR6, FR13, FR0 */
		/* 820988C0h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820988C0h case    3:*/		return 0x820988C4;
		  /* 820988C4h */ case    4:  		/* bc 12, CR6_GT, 68 */
		/* 820988C4h case    4:*/		if ( regs.CR[6].gt ) { return 0x82098908;  }
		/* 820988C4h case    4:*/		return 0x820988C8;
		  /* 820988C8h */ case    5:  		/* lis R11, -32217 */
		/* 820988C8h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 820988C8h case    5:*/		return 0x820988CC;
		  /* 820988CCh */ case    6:  		/* lfd FR0, <#[R11 + 7344]> */
		/* 820988CCh case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001CB0) );
		/* 820988CCh case    6:*/		return 0x820988D0;
	}
	return 0x820988D0;
} // Block from 820988B4h-820988D0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820988D0h
// Function '_statfp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820988D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820988D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820988D0);
		  /* 820988D0h */ case    0:  		/* b 76 */
		/* 820988D0h case    0:*/		return 0x8209891C;
		/* 820988D0h case    0:*/		return 0x820988D4;
	}
	return 0x820988D4;
} // Block from 820988D0h-820988D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820988D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820988D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820988D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820988D4);
		  /* 820988D4h */ case    0:  		/* lis R11, -32256 */
		/* 820988D4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820988D4h case    0:*/		return 0x820988D8;
		  /* 820988D8h */ case    1:  		/* lfd FR13, <#[R30]> */
		/* 820988D8h case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R30 + 0x00000000) );
		/* 820988D8h case    1:*/		return 0x820988DC;
		  /* 820988DCh */ case    2:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 820988DCh case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 820988DCh case    2:*/		return 0x820988E0;
	}
	return 0x820988E0;
} // Block from 820988D4h-820988E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820988E0h
// Function '_FPreset'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820988E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820988E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820988E0);
		  /* 820988E0h */ case    0:  		/* lis R11, -32217 */
		/* 820988E0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 820988E0h case    0:*/		return 0x820988E4;
		  /* 820988E4h */ case    1:  		/* fcmpu CR6, FR13, FR0 */
		/* 820988E4h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820988E4h case    1:*/		return 0x820988E8;
		  /* 820988E8h */ case    2:  		/* lfd FR0, <#[R11 + 7344]> */
		/* 820988E8h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001CB0) );
		/* 820988E8h case    2:*/		return 0x820988EC;
		  /* 820988ECh */ case    3:  		/* bc 12, CR6_GT, 52 */
		/* 820988ECh case    3:*/		if ( regs.CR[6].gt ) { return 0x82098920;  }
		/* 820988ECh case    3:*/		return 0x820988F0;
		  /* 820988F0h */ case    4:  		/* b 44 */
		/* 820988F0h case    4:*/		return 0x8209891C;
		/* 820988F0h case    4:*/		return 0x820988F4;
	}
	return 0x820988F4;
} // Block from 820988E0h-820988F4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820988F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820988F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820988F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820988F4);
		  /* 820988F4h */ case    0:  		/* lis R11, -32256 */
		/* 820988F4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820988F4h case    0:*/		return 0x820988F8;
		  /* 820988F8h */ case    1:  		/* lfd FR13, <#[R30]> */
		/* 820988F8h case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R30 + 0x00000000) );
		/* 820988F8h case    1:*/		return 0x820988FC;
		  /* 820988FCh */ case    2:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 820988FCh case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 820988FCh case    2:*/		return 0x82098900;
		  /* 82098900h */ case    3:  		/* fcmpu CR6, FR13, FR0 */
		/* 82098900h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 82098900h case    3:*/		return 0x82098904;
	}
	return 0x82098904;
} // Block from 820988F4h-82098904h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82098904h
// Function '_set_statfp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098904);
		  /* 82098904h */ case    0:  		/* bc 4, CR6_GT, 16 */
		/* 82098904h case    0:*/		if ( !regs.CR[6].gt ) { return 0x82098914;  }
		/* 82098904h case    0:*/		return 0x82098908;
	}
	return 0x82098908;
} // Block from 82098904h-82098908h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82098908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098908);
		  /* 82098908h */ case    0:  		/* lis R11, -32217 */
		/* 82098908h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82098908h case    0:*/		return 0x8209890C;
		  /* 8209890Ch */ case    1:  		/* lfd FR0, <#[R11 + 7328]> */
		/* 8209890Ch case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001CA0) );
		/* 8209890Ch case    1:*/		return 0x82098910;
		  /* 82098910h */ case    2:  		/* b 16 */
		/* 82098910h case    2:*/		return 0x82098920;
		/* 82098910h case    2:*/		return 0x82098914;
	}
	return 0x82098914;
} // Block from 82098908h-82098914h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82098914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098914);
		  /* 82098914h */ case    0:  		/* lis R11, -32217 */
		/* 82098914h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82098914h case    0:*/		return 0x82098918;
		  /* 82098918h */ case    1:  		/* lfd FR0, <#[R11 + 7328]> */
		/* 82098918h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001CA0) );
		/* 82098918h case    1:*/		return 0x8209891C;
	}
	return 0x8209891C;
} // Block from 82098914h-8209891Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209891Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209891C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209891C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209891C);
		  /* 8209891Ch */ case    0:  		/* fneg FR0, FR0 */
		/* 8209891Ch case    0:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR0);
		/* 8209891Ch case    0:*/		return 0x82098920;
	}
	return 0x82098920;
} // Block from 8209891Ch-82098920h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82098920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098920);
		  /* 82098920h */ case    0:  		/* stfd FR0, <#[R30]> */
		/* 82098920h case    0:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R30 + 0x00000000) );
		/* 82098920h case    0:*/		return 0x82098924;
	}
	return 0x82098924;
} // Block from 82098920h-82098924h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82098924h
// Function '_set_fsr'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098924);
		  /* 82098924h */ case    0:  		/* rlwinm R28, R28, 0, 0, 30 */
		/* 82098924h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R28,regs.R28);
		/* 82098924h case    0:*/		return 0x82098928;
		  /* 82098928h */ case    1:  		/* b 252 */
		/* 82098928h case    1:*/		return 0x82098A24;
		/* 82098928h case    1:*/		return 0x8209892C;
	}
	return 0x8209892C;
} // Block from 82098924h-8209892Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209892Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209892C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209892C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209892C);
		  /* 8209892Ch */ case    0:  		/* rlwinm. R11, R29, 0, 30, 30 */
		/* 8209892Ch case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R29);
		/* 8209892Ch case    0:*/		return 0x82098930;
		  /* 82098930h */ case    1:  		/* bc 12, CR0_EQ, 244 */
		/* 82098930h case    1:*/		if ( regs.CR[0].eq ) { return 0x82098A24;  }
		/* 82098930h case    1:*/		return 0x82098934;
	}
	return 0x82098934;
} // Block from 8209892Ch-82098934h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82098934h
// Function '_get_fsr'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098934);
		  /* 82098934h */ case    0:  		/* rlwinm. R11, R27, 0, 26, 26 */
		/* 82098934h case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R27);
		/* 82098934h case    0:*/		return 0x82098938;
		  /* 82098938h */ case    1:  		/* bc 12, CR0_EQ, 236 */
		/* 82098938h case    1:*/		if ( regs.CR[0].eq ) { return 0x82098A24;  }
		/* 82098938h case    1:*/		return 0x8209893C;
		  /* 8209893Ch */ case    2:  		/* rlwinm. R11, R29, 0, 27, 27 */
		/* 8209893Ch case    2:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R29);
		/* 8209893Ch case    2:*/		return 0x82098940;
		  /* 82098940h */ case    3:  		/* li R31, 0 */
		/* 82098940h case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82098940h case    3:*/		return 0x82098944;
		  /* 82098944h */ case    4:  		/* bc 12, CR0_EQ, 8 */
		/* 82098944h case    4:*/		if ( regs.CR[0].eq ) { return 0x8209894C;  }
		/* 82098944h case    4:*/		return 0x82098948;
	}
	return 0x82098948;
} // Block from 82098934h-82098948h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82098948h
// Function '?strtoxl@@YAKPAUlocaleinfo_struct@@PBDPAPBDHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098948( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098948) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098948);
		  /* 82098948h */ case    0:  		/* li R31, 1 */
		/* 82098948h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 82098948h case    0:*/		return 0x8209894C;
	}
	return 0x8209894C;
} // Block from 82098948h-8209894Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209894Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209894C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209894C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209894C);
		  /* 8209894Ch */ case    0:  		/* lis R11, -32256 */
		/* 8209894Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8209894Ch case    0:*/		return 0x82098950;
		  /* 82098950h */ case    1:  		/* lfd FR1, <#[R30]> */
		/* 82098950h case    1:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R30 + 0x00000000) );
		/* 82098950h case    1:*/		return 0x82098954;
		  /* 82098954h */ case    2:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 82098954h case    2:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 82098954h case    2:*/		return 0x82098958;
		  /* 82098958h */ case    3:  		/* fcmpu CR6, FR1, FR31 */
		/* 82098958h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR31);
		/* 82098958h case    3:*/		return 0x8209895C;
		  /* 8209895Ch */ case    4:  		/* bc 12, CR6_EQ, 176 */
		/* 8209895Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x82098A0C;  }
		/* 8209895Ch case    4:*/		return 0x82098960;
		  /* 82098960h */ case    5:  		/* addi R4, R1, 80 */
		/* 82098960h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82098960h case    5:*/		return 0x82098964;
		  /* 82098964h */ case    6:  		/* bl -16092 */
		/* 82098964h case    6:*/		regs.LR = 0x82098968; return 0x82094A88;
		/* 82098964h case    6:*/		return 0x82098968;
		  /* 82098968h */ case    7:  		/* lwz R11, <#[R1 + 80]> */
		/* 82098968h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82098968h case    7:*/		return 0x8209896C;
		  /* 8209896Ch */ case    8:  		/* stfd FR1, <#[R1 + 80]> */
		/* 8209896Ch case    8:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000050) );
		/* 8209896Ch case    8:*/		return 0x82098970;
		  /* 82098970h */ case    9:  		/* addi R11, R11, -1536 */
		/* 82098970h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFA00);
		/* 82098970h case    9:*/		return 0x82098974;
		  /* 82098974h */ case   10:  		/* cmpwi CR6, R11, -1074 */
		/* 82098974h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFBCE);
		/* 82098974h case   10:*/		return 0x82098978;
		  /* 82098978h */ case   11:  		/* bc 4, CR6_LT, 16 */
		/* 82098978h case   11:*/		if ( !regs.CR[6].lt ) { return 0x82098988;  }
		/* 82098978h case   11:*/		return 0x8209897C;
		  /* 8209897Ch */ case   12:  		/* fmul FR0, FR1, FR31 */
		/* 8209897Ch case   12:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR1,regs.FR31);
		/* 8209897Ch case   12:*/		return 0x82098980;
		  /* 82098980h */ case   13:  		/* li R31, 1 */
		/* 82098980h case   13:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 82098980h case   13:*/		return 0x82098984;
		  /* 82098984h */ case   14:  		/* b 128 */
		/* 82098984h case   14:*/		return 0x82098A04;
		/* 82098984h case   14:*/		return 0x82098988;
	}
	return 0x82098988;
} // Block from 8209894Ch-82098988h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82098988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098988);
		  /* 82098988h */ case    0:  		/* fcmpu CR6, FR1, FR31 */
		/* 82098988h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR31);
		/* 82098988h case    0:*/		return 0x8209898C;
		  /* 8209898Ch */ case    1:  		/* li R9, 1 */
		/* 8209898Ch case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8209898Ch case    1:*/		return 0x82098990;
		  /* 82098990h */ case    2:  		/* bc 12, CR6_LT, 8 */
		/* 82098990h case    2:*/		if ( regs.CR[6].lt ) { return 0x82098998;  }
		/* 82098990h case    2:*/		return 0x82098994;
		  /* 82098994h */ case    3:  		/* li R9, 0 */
		/* 82098994h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82098994h case    3:*/		return 0x82098998;
	}
	return 0x82098998;
} // Block from 82098988h-82098998h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82098998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098998);
		  /* 82098998h */ case    0:  		/* lhz R10, <#[R1 + 80]> */
		/* 82098998h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82098998h case    0:*/		return 0x8209899C;
		  /* 8209899Ch */ case    1:  		/* cmpwi CR6, R11, -1021 */
		/* 8209899Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFC03);
		/* 8209899Ch case    1:*/		return 0x820989A0;
		  /* 820989A0h */ case    2:  		/* rlwinm R10, R10, 0, 28, 31 */
		/* 820989A0h case    2:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R10,regs.R10);
		/* 820989A0h case    2:*/		return 0x820989A4;
		  /* 820989A4h */ case    3:  		/* ori R10, R10, 16 */
		/* 820989A4h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x10);
		/* 820989A4h case    3:*/		return 0x820989A8;
		  /* 820989A8h */ case    4:  		/* sth R10, <#[R1 + 80]> */
		/* 820989A8h case    4:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820989A8h case    4:*/		return 0x820989AC;
		  /* 820989ACh */ case    5:  		/* bc 4, CR6_LT, 72 */
		/* 820989ACh case    5:*/		if ( !regs.CR[6].lt ) { return 0x820989F4;  }
		/* 820989ACh case    5:*/		return 0x820989B0;
		  /* 820989B0h */ case    6:  		/* subfic R11, R11, -1021 */
		/* 820989B0h case    6:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0xFFFFFC03);
		/* 820989B0h case    6:*/		return 0x820989B4;
		  /* 820989B4h */ case    7:  		/* lwz R10, <#[R1 + 80]> */
		/* 820989B4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820989B4h case    7:*/		return 0x820989B8;
		  /* 820989B8h */ case    8:  		/* mtspr CTR, R11 */
		/* 820989B8h case    8:*/		regs.CTR = regs.R11;
		/* 820989B8h case    8:*/		return 0x820989BC;
		  /* 820989BCh */ case    9:  		/* lwz R11, <#[R1 + 84]> */
		/* 820989BCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820989BCh case    9:*/		return 0x820989C0;
		  /* 820989C0h */ case   10:  		/* rlwinm. R8, R11, 0, 31, 31 */
		/* 820989C0h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R8,regs.R11);
		/* 820989C0h case   10:*/		return 0x820989C4;
		  /* 820989C4h */ case   11:  		/* bc 12, CR0_EQ, 16 */
		/* 820989C4h case   11:*/		if ( regs.CR[0].eq ) { return 0x820989D4;  }
		/* 820989C4h case   11:*/		return 0x820989C8;
		  /* 820989C8h */ case   12:  		/* cmpwi CR6, R31, 0 */
		/* 820989C8h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 820989C8h case   12:*/		return 0x820989CC;
		  /* 820989CCh */ case   13:  		/* bc 4, CR6_EQ, 8 */
		/* 820989CCh case   13:*/		if ( !regs.CR[6].eq ) { return 0x820989D4;  }
		/* 820989CCh case   13:*/		return 0x820989D0;
		  /* 820989D0h */ case   14:  		/* li R31, 1 */
		/* 820989D0h case   14:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 820989D0h case   14:*/		return 0x820989D4;
	}
	return 0x820989D4;
} // Block from 82098998h-820989D4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820989D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820989D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820989D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820989D4);
		  /* 820989D4h */ case    0:  		/* rlwinm. R8, R10, 0, 31, 31 */
		/* 820989D4h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R8,regs.R10);
		/* 820989D4h case    0:*/		return 0x820989D8;
		  /* 820989D8h */ case    1:  		/* rlwinm R11, R11, 31, 1, 31 */
		/* 820989D8h case    1:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R11,regs.R11);
		/* 820989D8h case    1:*/		return 0x820989DC;
		  /* 820989DCh */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 820989DCh case    2:*/		if ( regs.CR[0].eq ) { return 0x820989E4;  }
		/* 820989DCh case    2:*/		return 0x820989E0;
		  /* 820989E0h */ case    3:  		/* oris R11, R11, 32768 */
		/* 820989E0h case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 820989E0h case    3:*/		return 0x820989E4;
	}
	return 0x820989E4;
} // Block from 820989D4h-820989E4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820989E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820989E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820989E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820989E4);
		  /* 820989E4h */ case    0:  		/* rlwinm R10, R10, 31, 1, 31 */
		/* 820989E4h case    0:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R10,regs.R10);
		/* 820989E4h case    0:*/		return 0x820989E8;
		  /* 820989E8h */ case    1:  		/* bc 16, CR0_LT, -40 */
		/* 820989E8h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820989C0;  }
		/* 820989E8h case    1:*/		return 0x820989EC;
		  /* 820989ECh */ case    2:  		/* stw R10, <#[R1 + 80]> */
		/* 820989ECh case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820989ECh case    2:*/		return 0x820989F0;
		  /* 820989F0h */ case    3:  		/* stw R11, <#[R1 + 84]> */
		/* 820989F0h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820989F0h case    3:*/		return 0x820989F4;
	}
	return 0x820989F4;
} // Block from 820989E4h-820989F4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820989F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820989F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820989F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820989F4);
		  /* 820989F4h */ case    0:  		/* lfd FR0, <#[R1 + 80]> */
		/* 820989F4h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820989F4h case    0:*/		return 0x820989F8;
		  /* 820989F8h */ case    1:  		/* cmpwi CR6, R9, 0 */
		/* 820989F8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820989F8h case    1:*/		return 0x820989FC;
		  /* 820989FCh */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 820989FCh case    2:*/		if ( regs.CR[6].eq ) { return 0x82098A04;  }
		/* 820989FCh case    2:*/		return 0x82098A00;
		  /* 82098A00h */ case    3:  		/* fneg FR0, FR0 */
		/* 82098A00h case    3:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR0);
		/* 82098A00h case    3:*/		return 0x82098A04;
	}
	return 0x82098A04;
} // Block from 820989F4h-82098A04h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82098A04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098A04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098A04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098A04);
		  /* 82098A04h */ case    0:  		/* stfd FR0, <#[R30]> */
		/* 82098A04h case    0:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R30 + 0x00000000) );
		/* 82098A04h case    0:*/		return 0x82098A08;
		  /* 82098A08h */ case    1:  		/* b 8 */
		/* 82098A08h case    1:*/		return 0x82098A10;
		/* 82098A08h case    1:*/		return 0x82098A0C;
	}
	return 0x82098A0C;
} // Block from 82098A04h-82098A0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82098A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098A0C);
		  /* 82098A0Ch */ case    0:  		/* li R31, 1 */
		/* 82098A0Ch case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 82098A0Ch case    0:*/		return 0x82098A10;
	}
	return 0x82098A10;
} // Block from 82098A0Ch-82098A10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82098A10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098A10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098A10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098A10);
		  /* 82098A10h */ case    0:  		/* cmpwi CR6, R31, 0 */
		/* 82098A10h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82098A10h case    0:*/		return 0x82098A14;
		  /* 82098A14h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82098A14h case    1:*/		if ( regs.CR[6].eq ) { return 0x82098A20;  }
		/* 82098A14h case    1:*/		return 0x82098A18;
		  /* 82098A18h */ case    2:  		/* lis R3, 2048 */
		/* 82098A18h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0x800);
		/* 82098A18h case    2:*/		return 0x82098A1C;
		  /* 82098A1Ch */ case    3:  		/* bl 1288 */
		/* 82098A1Ch case    3:*/		regs.LR = 0x82098A20; return 0x82098F24;
		/* 82098A1Ch case    3:*/		return 0x82098A20;
	}
	return 0x82098A20;
} // Block from 82098A10h-82098A20h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82098A20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098A20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098A20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098A20);
		  /* 82098A20h */ case    0:  		/* rlwinm R28, R28, 0, 31, 29 */
		/* 82098A20h case    0:*/		cpu::op::rlwinm<0,0,31,29>(regs,&regs.R28,regs.R28);
		/* 82098A20h case    0:*/		return 0x82098A24;
	}
	return 0x82098A24;
} // Block from 82098A20h-82098A24h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82098A24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098A24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098A24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098A24);
		  /* 82098A24h */ case    0:  		/* rlwinm. R11, R29, 0, 27, 27 */
		/* 82098A24h case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R29);
		/* 82098A24h case    0:*/		return 0x82098A28;
		  /* 82098A28h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 82098A28h case    1:*/		if ( regs.CR[0].eq ) { return 0x82098A40;  }
		/* 82098A28h case    1:*/		return 0x82098A2C;
		  /* 82098A2Ch */ case    2:  		/* rlwinm. R11, R27, 0, 28, 28 */
		/* 82098A2Ch case    2:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R27);
		/* 82098A2Ch case    2:*/		return 0x82098A30;
		  /* 82098A30h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 82098A30h case    3:*/		if ( regs.CR[0].eq ) { return 0x82098A40;  }
		/* 82098A30h case    3:*/		return 0x82098A34;
		  /* 82098A34h */ case    4:  		/* lis R3, 512 */
		/* 82098A34h case    4:*/		cpu::op::lis<0>(regs,&regs.R3,0x200);
		/* 82098A34h case    4:*/		return 0x82098A38;
		  /* 82098A38h */ case    5:  		/* bl 1260 */
		/* 82098A38h case    5:*/		regs.LR = 0x82098A3C; return 0x82098F24;
		/* 82098A38h case    5:*/		return 0x82098A3C;
		  /* 82098A3Ch */ case    6:  		/* rlwinm R28, R28, 0, 28, 26 */
		/* 82098A3Ch case    6:*/		cpu::op::rlwinm<0,0,28,26>(regs,&regs.R28,regs.R28);
		/* 82098A3Ch case    6:*/		return 0x82098A40;
	}
	return 0x82098A40;
} // Block from 82098A24h-82098A40h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82098A40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098A40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098A40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098A40);
		  /* 82098A40h */ case    0:  		/* cntlzw R11, R28 */
		/* 82098A40h case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R28);
		/* 82098A40h case    0:*/		return 0x82098A44;
		  /* 82098A44h */ case    1:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 82098A44h case    1:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 82098A44h case    1:*/		return 0x82098A48;
		  /* 82098A48h */ case    2:  		/* addi R1, R1, 144 */
		/* 82098A48h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82098A48h case    2:*/		return 0x82098A4C;
		  /* 82098A4Ch */ case    3:  		/* lfd FR31, <#[R1 - 56]> */
		/* 82098A4Ch case    3:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFC8) );
		/* 82098A4Ch case    3:*/		return 0x82098A50;
		  /* 82098A50h */ case    4:  		/* b -30636 */
		/* 82098A50h case    4:*/		return 0x820912A4;
		/* 82098A50h case    4:*/		return 0x82098A54;
		  /* 82098A54h */ case    5:  		/* nop */
		/* 82098A54h case    5:*/		cpu::op::nop();
		/* 82098A54h case    5:*/		return 0x82098A58;
	}
	return 0x82098A58;
} // Block from 82098A40h-82098A58h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82098A58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098A58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098A58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098A58);
		  /* 82098A58h */ case    0:  		/* mfspr R12, LR */
		/* 82098A58h case    0:*/		regs.R12 = regs.LR;
		/* 82098A58h case    0:*/		return 0x82098A5C;
		  /* 82098A5Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82098A5Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82098A5Ch case    1:*/		return 0x82098A60;
		  /* 82098A60h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82098A60h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82098A60h case    2:*/		return 0x82098A64;
		  /* 82098A64h */ case    3:  		/* cmpwi CR6, R3, 1 */
		/* 82098A64h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82098A64h case    3:*/		return 0x82098A68;
		  /* 82098A68h */ case    4:  		/* bc 12, CR6_EQ, 28 */
		/* 82098A68h case    4:*/		if ( regs.CR[6].eq ) { return 0x82098A84;  }
		/* 82098A68h case    4:*/		return 0x82098A6C;
		  /* 82098A6Ch */ case    5:  		/* bc 4, CR6_GT, 36 */
		/* 82098A6Ch case    5:*/		if ( !regs.CR[6].gt ) { return 0x82098A90;  }
		/* 82098A6Ch case    5:*/		return 0x82098A70;
		  /* 82098A70h */ case    6:  		/* cmpwi CR6, R3, 3 */
		/* 82098A70h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000003);
		/* 82098A70h case    6:*/		return 0x82098A74;
		  /* 82098A74h */ case    7:  		/* bc 12, CR6_GT, 28 */
		/* 82098A74h case    7:*/		if ( regs.CR[6].gt ) { return 0x82098A90;  }
		/* 82098A74h case    7:*/		return 0x82098A78;
		  /* 82098A78h */ case    8:  		/* bl -15216 */
		/* 82098A78h case    8:*/		regs.LR = 0x82098A7C; return 0x82094F08;
		/* 82098A78h case    8:*/		return 0x82098A7C;
		  /* 82098A7Ch */ case    9:  		/* li R11, 34 */
		/* 82098A7Ch case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x22);
		/* 82098A7Ch case    9:*/		return 0x82098A80;
		  /* 82098A80h */ case   10:  		/* b 12 */
		/* 82098A80h case   10:*/		return 0x82098A8C;
		/* 82098A80h case   10:*/		return 0x82098A84;
	}
	return 0x82098A84;
} // Block from 82098A58h-82098A84h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82098A84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098A84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098A84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098A84);
		  /* 82098A84h */ case    0:  		/* bl -15228 */
		/* 82098A84h case    0:*/		regs.LR = 0x82098A88; return 0x82094F08;
		/* 82098A84h case    0:*/		return 0x82098A88;
		  /* 82098A88h */ case    1:  		/* li R11, 33 */
		/* 82098A88h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x21);
		/* 82098A88h case    1:*/		return 0x82098A8C;
	}
	return 0x82098A8C;
} // Block from 82098A84h-82098A8Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82098A8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098A8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098A8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098A8C);
		  /* 82098A8Ch */ case    0:  		/* stw R11, <#[R3]> */
		/* 82098A8Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82098A8Ch case    0:*/		return 0x82098A90;
	}
	return 0x82098A90;
} // Block from 82098A8Ch-82098A90h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82098A90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098A90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098A90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098A90);
		  /* 82098A90h */ case    0:  		/* addi R1, R1, 96 */
		/* 82098A90h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82098A90h case    0:*/		return 0x82098A94;
		  /* 82098A94h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82098A94h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82098A94h case    1:*/		return 0x82098A98;
		  /* 82098A98h */ case    2:  		/* mtspr LR, R12 */
		/* 82098A98h case    2:*/		regs.LR = regs.R12;
		/* 82098A98h case    2:*/		return 0x82098A9C;
		  /* 82098A9Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 82098A9Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82098A9Ch case    3:*/		return 0x82098AA0;
	}
	return 0x82098AA0;
} // Block from 82098A90h-82098AA0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82098AA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098AA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098AA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098AA0);
		  /* 82098AA0h */ case    0:  		/* rlwinm. R11, R3, 0, 26, 26 */
		/* 82098AA0h case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R3);
		/* 82098AA0h case    0:*/		return 0x82098AA4;
		  /* 82098AA4h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82098AA4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82098AB0;  }
		/* 82098AA4h case    1:*/		return 0x82098AA8;
		  /* 82098AA8h */ case    2:  		/* li R3, 5 */
		/* 82098AA8h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x5);
		/* 82098AA8h case    2:*/		return 0x82098AAC;
		  /* 82098AACh */ case    3:  		/* bclr 20, CR0_LT */
		/* 82098AACh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82098AACh case    3:*/		return 0x82098AB0;
	}
	return 0x82098AB0;
} // Block from 82098AA0h-82098AB0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82098AB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098AB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098AB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098AB0);
		  /* 82098AB0h */ case    0:  		/* rlwinm. R11, R3, 0, 28, 28 */
		/* 82098AB0h case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R3);
		/* 82098AB0h case    0:*/		return 0x82098AB4;
		  /* 82098AB4h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82098AB4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82098AC0;  }
		/* 82098AB4h case    1:*/		return 0x82098AB8;
		  /* 82098AB8h */ case    2:  		/* li R3, 1 */
		/* 82098AB8h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82098AB8h case    2:*/		return 0x82098ABC;
		  /* 82098ABCh */ case    3:  		/* bclr 20, CR0_LT */
		/* 82098ABCh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82098ABCh case    3:*/		return 0x82098AC0;
	}
	return 0x82098AC0;
} // Block from 82098AB0h-82098AC0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82098AC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098AC0);
		  /* 82098AC0h */ case    0:  		/* rlwinm. R11, R3, 0, 29, 29 */
		/* 82098AC0h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R3);
		/* 82098AC0h case    0:*/		return 0x82098AC4;
		  /* 82098AC4h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82098AC4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82098AD0;  }
		/* 82098AC4h case    1:*/		return 0x82098AC8;
		  /* 82098AC8h */ case    2:  		/* li R3, 2 */
		/* 82098AC8h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 82098AC8h case    2:*/		return 0x82098ACC;
		  /* 82098ACCh */ case    3:  		/* bclr 20, CR0_LT */
		/* 82098ACCh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82098ACCh case    3:*/		return 0x82098AD0;
	}
	return 0x82098AD0;
} // Block from 82098AC0h-82098AD0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82098AD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098AD0);
		  /* 82098AD0h */ case    0:  		/* rlwinm. R11, R3, 0, 31, 31 */
		/* 82098AD0h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R3);
		/* 82098AD0h case    0:*/		return 0x82098AD4;
		  /* 82098AD4h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82098AD4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82098AE0;  }
		/* 82098AD4h case    1:*/		return 0x82098AD8;
		  /* 82098AD8h */ case    2:  		/* li R3, 3 */
		/* 82098AD8h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 82098AD8h case    2:*/		return 0x82098ADC;
		  /* 82098ADCh */ case    3:  		/* bclr 20, CR0_LT */
		/* 82098ADCh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82098ADCh case    3:*/		return 0x82098AE0;
	}
	return 0x82098AE0;
} // Block from 82098AD0h-82098AE0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82098AE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098AE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098AE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098AE0);
		  /* 82098AE0h */ case    0:  		/* rlwinm R3, R3, 1, 29, 29 */
		/* 82098AE0h case    0:*/		cpu::op::rlwinm<0,1,29,29>(regs,&regs.R3,regs.R3);
		/* 82098AE0h case    0:*/		return 0x82098AE4;
		  /* 82098AE4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82098AE4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82098AE4h case    1:*/		return 0x82098AE8;
	}
	return 0x82098AE8;
} // Block from 82098AE0h-82098AE8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82098AE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098AE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098AE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098AE8);
		  /* 82098AE8h */ case    0:  		/* mfspr R12, LR */
		/* 82098AE8h case    0:*/		regs.R12 = regs.LR;
		/* 82098AE8h case    0:*/		return 0x82098AEC;
		  /* 82098AECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82098AECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82098AECh case    1:*/		return 0x82098AF0;
		  /* 82098AF0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82098AF0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82098AF0h case    2:*/		return 0x82098AF4;
		  /* 82098AF4h */ case    3:  		/* stfd FR31, <#[R1 - 24]> */
		/* 82098AF4h case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82098AF4h case    3:*/		return 0x82098AF8;
		  /* 82098AF8h */ case    4:  		/* stwu R1, <#[R1 - 144]> */
		/* 82098AF8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82098AF8h case    4:*/		return 0x82098AFC;
		  /* 82098AFCh */ case    5:  		/* lis R11, -32217 */
		/* 82098AFCh case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82098AFCh case    5:*/		return 0x82098B00;
		  /* 82098B00h */ case    6:  		/* stfd FR1, <#[R1 + 176]> */
		/* 82098B00h case    6:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x000000B0) );
		/* 82098B00h case    6:*/		return 0x82098B04;
		  /* 82098B04h */ case    7:  		/* mr R31, R3 */
		/* 82098B04h case    7:*/		regs.R31 = regs.R3;
		/* 82098B04h case    7:*/		return 0x82098B08;
		  /* 82098B08h */ case    8:  		/* stfd FR2, <#[R1 + 184]> */
		/* 82098B08h case    8:*/		cpu::mem::store64f( regs, regs.FR2, (uint32)(regs.R1 + 0x000000B8) );
		/* 82098B08h case    8:*/		return 0x82098B0C;
		  /* 82098B0Ch */ case    9:  		/* addi R11, R11, 7744 */
		/* 82098B0Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1E40);
		/* 82098B0Ch case    9:*/		return 0x82098B10;
		  /* 82098B10h */ case   10:  		/* stfd FR3, <#[R1 + 192]> */
		/* 82098B10h case   10:*/		cpu::mem::store64f( regs, regs.FR3, (uint32)(regs.R1 + 0x000000C0) );
		/* 82098B10h case   10:*/		return 0x82098B14;
		  /* 82098B14h */ case   11:  		/* fmr FR31, FR3 */
		/* 82098B14h case   11:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR3);
		/* 82098B14h case   11:*/		return 0x82098B18;
		  /* 82098B18h */ case   12:  		/* mr R3, R8 */
		/* 82098B18h case   12:*/		regs.R3 = regs.R8;
		/* 82098B18h case   12:*/		return 0x82098B1C;
		  /* 82098B1Ch */ case   13:  		/* li R9, 0 */
		/* 82098B1Ch case   13:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82098B1Ch case   13:*/		return 0x82098B20;
		  /* 82098B20h */ case   14:  		/* mr R10, R11 */
		/* 82098B20h case   14:*/		regs.R10 = regs.R11;
		/* 82098B20h case   14:*/		return 0x82098B24;
		  /* 82098B24h */ case   15:  		/* lwz R8, <#[R10]> */
		/* 82098B24h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82098B24h case   15:*/		return 0x82098B28;
		  /* 82098B28h */ case   16:  		/* cmplw CR6, R8, R4 */
		/* 82098B28h case   16:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R4);
		/* 82098B28h case   16:*/		return 0x82098B2C;
		  /* 82098B2Ch */ case   17:  		/* bc 12, CR6_EQ, 136 */
		/* 82098B2Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x82098BB4;  }
		/* 82098B2Ch case   17:*/		return 0x82098B30;
		  /* 82098B30h */ case   18:  		/* addi R10, R10, 8 */
		/* 82098B30h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x8);
		/* 82098B30h case   18:*/		return 0x82098B34;
		  /* 82098B34h */ case   19:  		/* addi R8, R11, 232 */
		/* 82098B34h case   19:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xE8);
		/* 82098B34h case   19:*/		return 0x82098B38;
		  /* 82098B38h */ case   20:  		/* addi R9, R9, 1 */
		/* 82098B38h case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82098B38h case   20:*/		return 0x82098B3C;
		  /* 82098B3Ch */ case   21:  		/* cmpw CR6, R10, R8 */
		/* 82098B3Ch case   21:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R8);
		/* 82098B3Ch case   21:*/		return 0x82098B40;
		  /* 82098B40h */ case   22:  		/* bc 12, CR6_LT, -28 */
		/* 82098B40h case   22:*/		if ( regs.CR[6].lt ) { return 0x82098B24;  }
		/* 82098B40h case   22:*/		return 0x82098B44;
		  /* 82098B44h */ case   23:  		/* li R11, 0 */
		/* 82098B44h case   23:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82098B44h case   23:*/		return 0x82098B48;
		  /* 82098B48h */ case   24:  		/* lis R4, -16377 */
		/* 82098B48h case   24:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFC007);
		/* 82098B48h case   24:*/		return 0x82098B4C;
		  /* 82098B4Ch */ case   25:  		/* stw R11, <#[R1 + 84]> */
		/* 82098B4Ch case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82098B4Ch case   25:*/		return 0x82098B50;
		  /* 82098B50h */ case   26:  		/* cmplwi CR6, R11, 0 */
		/* 82098B50h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82098B50h case   26:*/		return 0x82098B54;
		  /* 82098B54h */ case   27:  		/* ori R4, R4, 65279 */
		/* 82098B54h case   27:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0xFEFF);
		/* 82098B54h case   27:*/		return 0x82098B58;
		  /* 82098B58h */ case   28:  		/* bc 12, CR6_EQ, 108 */
		/* 82098B58h case   28:*/		if ( regs.CR[6].eq ) { return 0x82098BC4;  }
		/* 82098B58h case   28:*/		return 0x82098B5C;
		  /* 82098B5Ch */ case   29:  		/* lwz R11, <#[R1 + 176]> */
		/* 82098B5Ch case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B0) );
		/* 82098B5Ch case   29:*/		return 0x82098B60;
		  /* 82098B60h */ case   30:  		/* lwz R10, <#[R1 + 180]> */
		/* 82098B60h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000B4) );
		/* 82098B60h case   30:*/		return 0x82098B64;
		  /* 82098B64h */ case   31:  		/* lwz R9, <#[R1 + 184]> */
		/* 82098B64h case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000B8) );
		/* 82098B64h case   31:*/		return 0x82098B68;
		  /* 82098B68h */ case   32:  		/* lwz R8, <#[R1 + 188]> */
		/* 82098B68h case   32:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x000000BC) );
		/* 82098B68h case   32:*/		return 0x82098B6C;
		  /* 82098B6Ch */ case   33:  		/* lwz R7, <#[R1 + 192]> */
		/* 82098B6Ch case   33:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x000000C0) );
		/* 82098B6Ch case   33:*/		return 0x82098B70;
		  /* 82098B70h */ case   34:  		/* lwz R6, <#[R1 + 196]> */
		/* 82098B70h case   34:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x000000C4) );
		/* 82098B70h case   34:*/		return 0x82098B74;
		  /* 82098B74h */ case   35:  		/* stw R31, <#[R1 + 80]> */
		/* 82098B74h case   35:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 82098B74h case   35:*/		return 0x82098B78;
		  /* 82098B78h */ case   36:  		/* stw R11, <#[R1 + 88]> */
		/* 82098B78h case   36:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82098B78h case   36:*/		return 0x82098B7C;
		  /* 82098B7Ch */ case   37:  		/* stw R10, <#[R1 + 92]> */
		/* 82098B7Ch case   37:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 82098B7Ch case   37:*/		return 0x82098B80;
		  /* 82098B80h */ case   38:  		/* stw R9, <#[R1 + 96]> */
		/* 82098B80h case   38:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000060) );
		/* 82098B80h case   38:*/		return 0x82098B84;
		  /* 82098B84h */ case   39:  		/* stw R8, <#[R1 + 100]> */
		/* 82098B84h case   39:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000064) );
		/* 82098B84h case   39:*/		return 0x82098B88;
		  /* 82098B88h */ case   40:  		/* stw R7, <#[R1 + 104]> */
		/* 82098B88h case   40:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000068) );
		/* 82098B88h case   40:*/		return 0x82098B8C;
		  /* 82098B8Ch */ case   41:  		/* stw R6, <#[R1 + 108]> */
		/* 82098B8Ch case   41:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x0000006C) );
		/* 82098B8Ch case   41:*/		return 0x82098B90;
		  /* 82098B90h */ case   42:  		/* bl 816 */
		/* 82098B90h case   42:*/		regs.LR = 0x82098B94; return 0x82098EC0;
		/* 82098B90h case   42:*/		return 0x82098B94;
		  /* 82098B94h */ case   43:  		/* addi R3, R1, 80 */
		/* 82098B94h case   43:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82098B94h case   43:*/		return 0x82098B98;
		  /* 82098B98h */ case   44:  		/* bl 1839464 */
		/* 82098B98h case   44:*/		regs.LR = 0x82098B9C; return 0x82259D00;
		/* 82098B98h case   44:*/		return 0x82098B9C;
		  /* 82098B9Ch */ case   45:  		/* cmpwi CR0, R3, 0 */
		/* 82098B9Ch case   45:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82098B9Ch case   45:*/		return 0x82098BA0;
		  /* 82098BA0h */ case   46:  		/* bc 4, CR0_EQ, 12 */
		/* 82098BA0h case   46:*/		if ( !regs.CR[0].eq ) { return 0x82098BAC;  }
		/* 82098BA0h case   46:*/		return 0x82098BA4;
		  /* 82098BA4h */ case   47:  		/* mr R3, R31 */
		/* 82098BA4h case   47:*/		regs.R3 = regs.R31;
		/* 82098BA4h case   47:*/		return 0x82098BA8;
		  /* 82098BA8h */ case   48:  		/* bl -336 */
		/* 82098BA8h case   48:*/		regs.LR = 0x82098BAC; return 0x82098A58;
		/* 82098BA8h case   48:*/		return 0x82098BAC;
	}
	return 0x82098BAC;
} // Block from 82098AE8h-82098BACh (49 instructions)

//////////////////////////////////////////////////////
// Block at 82098BACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098BAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098BAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098BAC);
		  /* 82098BACh */ case    0:  		/* lfd FR1, <#[R1 + 104]> */
		/* 82098BACh case    0:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0x00000068) );
		/* 82098BACh case    0:*/		return 0x82098BB0;
		  /* 82098BB0h */ case    1:  		/* b 36 */
		/* 82098BB0h case    1:*/		return 0x82098BD4;
		/* 82098BB0h case    1:*/		return 0x82098BB4;
	}
	return 0x82098BB4;
} // Block from 82098BACh-82098BB4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82098BB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098BB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098BB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098BB4);
		  /* 82098BB4h */ case    0:  		/* rlwinm R10, R9, 3, 0, 28 */
		/* 82098BB4h case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R9);
		/* 82098BB4h case    0:*/		return 0x82098BB8;
		  /* 82098BB8h */ case    1:  		/* addi R11, R11, 4 */
		/* 82098BB8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82098BB8h case    1:*/		return 0x82098BBC;
		  /* 82098BBCh */ case    2:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82098BBCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82098BBCh case    2:*/		return 0x82098BC0;
		  /* 82098BC0h */ case    3:  		/* b -120 */
		/* 82098BC0h case    3:*/		return 0x82098B48;
		/* 82098BC0h case    3:*/		return 0x82098BC4;
	}
	return 0x82098BC4;
} // Block from 82098BB4h-82098BC4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82098BC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098BC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098BC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098BC4);
		  /* 82098BC4h */ case    0:  		/* bl 764 */
		/* 82098BC4h case    0:*/		regs.LR = 0x82098BC8; return 0x82098EC0;
		/* 82098BC4h case    0:*/		return 0x82098BC8;
		  /* 82098BC8h */ case    1:  		/* mr R3, R31 */
		/* 82098BC8h case    1:*/		regs.R3 = regs.R31;
		/* 82098BC8h case    1:*/		return 0x82098BCC;
		  /* 82098BCCh */ case    2:  		/* bl -372 */
		/* 82098BCCh case    2:*/		regs.LR = 0x82098BD0; return 0x82098A58;
		/* 82098BCCh case    2:*/		return 0x82098BD0;
		  /* 82098BD0h */ case    3:  		/* fmr FR1, FR31 */
		/* 82098BD0h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82098BD0h case    3:*/		return 0x82098BD4;
	}
	return 0x82098BD4;
} // Block from 82098BC4h-82098BD4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82098BD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098BD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098BD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098BD4);
		  /* 82098BD4h */ case    0:  		/* addi R1, R1, 144 */
		/* 82098BD4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82098BD4h case    0:*/		return 0x82098BD8;
		  /* 82098BD8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82098BD8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82098BD8h case    1:*/		return 0x82098BDC;
		  /* 82098BDCh */ case    2:  		/* mtspr LR, R12 */
		/* 82098BDCh case    2:*/		regs.LR = regs.R12;
		/* 82098BDCh case    2:*/		return 0x82098BE0;
		  /* 82098BE0h */ case    3:  		/* lfd FR31, <#[R1 - 24]> */
		/* 82098BE0h case    3:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82098BE0h case    3:*/		return 0x82098BE4;
		  /* 82098BE4h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82098BE4h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82098BE4h case    4:*/		return 0x82098BE8;
		  /* 82098BE8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82098BE8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82098BE8h case    5:*/		return 0x82098BEC;
	}
	return 0x82098BEC;
} // Block from 82098BD4h-82098BECh (6 instructions)

//////////////////////////////////////////////////////
// Block at 82098BECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098BEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098BEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098BEC);
		  /* 82098BECh */ case    0:  		/* nop */
		/* 82098BECh case    0:*/		cpu::op::nop();
		/* 82098BECh case    0:*/		return 0x82098BF0;
	}
	return 0x82098BF0;
} // Block from 82098BECh-82098BF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82098BF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098BF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098BF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098BF0);
		  /* 82098BF0h */ case    0:  		/* mfspr R12, LR */
		/* 82098BF0h case    0:*/		regs.R12 = regs.LR;
		/* 82098BF0h case    0:*/		return 0x82098BF4;
		  /* 82098BF4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82098BF4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82098BF4h case    1:*/		return 0x82098BF8;
		  /* 82098BF8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82098BF8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82098BF8h case    2:*/		return 0x82098BFC;
		  /* 82098BFCh */ case    3:  		/* stfd FR31, <#[R1 - 24]> */
		/* 82098BFCh case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82098BFCh case    3:*/		return 0x82098C00;
		  /* 82098C00h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82098C00h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82098C00h case    4:*/		return 0x82098C04;
		  /* 82098C04h */ case    5:  		/* lis R11, -32217 */
		/* 82098C04h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82098C04h case    5:*/		return 0x82098C08;
		  /* 82098C08h */ case    6:  		/* fmr FR31, FR1 */
		/* 82098C08h case    6:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 82098C08h case    6:*/		return 0x82098C0C;
		  /* 82098C0Ch */ case    7:  		/* mr R4, R3 */
		/* 82098C0Ch case    7:*/		regs.R4 = regs.R3;
		/* 82098C0Ch case    7:*/		return 0x82098C10;
		  /* 82098C10h */ case    8:  		/* mr R31, R5 */
		/* 82098C10h case    8:*/		regs.R31 = regs.R5;
		/* 82098C10h case    8:*/		return 0x82098C14;
		  /* 82098C14h */ case    9:  		/* lwz R11, <#[R11 + 9584]> */
		/* 82098C14h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00002570) );
		/* 82098C14h case    9:*/		return 0x82098C18;
		  /* 82098C18h */ case   10:  		/* cmpwi CR6, R11, 0 */
		/* 82098C18h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82098C18h case   10:*/		return 0x82098C1C;
		  /* 82098C1Ch */ case   11:  		/* bc 4, CR6_EQ, 32 */
		/* 82098C1Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x82098C3C;  }
		/* 82098C1Ch case   11:*/		return 0x82098C20;
	}
	return 0x82098C20;
} // Block from 82098BF0h-82098C20h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82098C20h
// Function 'strtol'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098C20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098C20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098C20);
		  /* 82098C20h */ case    0:  		/* lis R11, -32256 */
		/* 82098C20h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82098C20h case    0:*/		return 0x82098C24;
		  /* 82098C24h */ case    1:  		/* fmr FR3, FR1 */
		/* 82098C24h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR1);
		/* 82098C24h case    1:*/		return 0x82098C28;
	}
	return 0x82098C28;
} // Block from 82098C20h-82098C28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82098C28h
// Function 'strtoul'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098C28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098C28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098C28);
		  /* 82098C28h */ case    0:  		/* mr R8, R5 */
		/* 82098C28h case    0:*/		regs.R8 = regs.R5;
		/* 82098C28h case    0:*/		return 0x82098C2C;
		  /* 82098C2Ch */ case    1:  		/* li R3, 1 */
		/* 82098C2Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82098C2Ch case    1:*/		return 0x82098C30;
	}
	return 0x82098C30;
} // Block from 82098C28h-82098C30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82098C30h
// Function '_mtdeletelocks'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098C30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098C30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098C30);
		  /* 82098C30h */ case    0:  		/* lfd FR2, <#[R11 + 1808]> */
		/* 82098C30h case    0:*/		cpu::mem::load64f( regs, &regs.FR2, (uint32)(regs.R11 + 0x00000710) );
		/* 82098C30h case    0:*/		return 0x82098C34;
		  /* 82098C34h */ case    1:  		/* bl -332 */
		/* 82098C34h case    1:*/		regs.LR = 0x82098C38; return 0x82098AE8;
		/* 82098C34h case    1:*/		return 0x82098C38;
		  /* 82098C38h */ case    2:  		/* b 40 */
		/* 82098C38h case    2:*/		return 0x82098C60;
		/* 82098C38h case    2:*/		return 0x82098C3C;
	}
	return 0x82098C3C;
} // Block from 82098C30h-82098C3Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82098C3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098C3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098C3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098C3C);
		  /* 82098C3Ch */ case    0:  		/* bl -15668 */
		/* 82098C3Ch case    0:*/		regs.LR = 0x82098C40; return 0x82094F08;
		/* 82098C3Ch case    0:*/		return 0x82098C40;
		  /* 82098C40h */ case    1:  		/* mr R11, R3 */
		/* 82098C40h case    1:*/		regs.R11 = regs.R3;
		/* 82098C40h case    1:*/		return 0x82098C44;
		  /* 82098C44h */ case    2:  		/* li R10, 33 */
		/* 82098C44h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x21);
		/* 82098C44h case    2:*/		return 0x82098C48;
		  /* 82098C48h */ case    3:  		/* lis R4, -16377 */
		/* 82098C48h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFC007);
		/* 82098C48h case    3:*/		return 0x82098C4C;
		  /* 82098C4Ch */ case    4:  		/* mr R3, R31 */
		/* 82098C4Ch case    4:*/		regs.R3 = regs.R31;
		/* 82098C4Ch case    4:*/		return 0x82098C50;
		  /* 82098C50h */ case    5:  		/* ori R4, R4, 65279 */
		/* 82098C50h case    5:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0xFEFF);
		/* 82098C50h case    5:*/		return 0x82098C54;
		  /* 82098C54h */ case    6:  		/* stw R10, <#[R11]> */
		/* 82098C54h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82098C54h case    6:*/		return 0x82098C58;
		  /* 82098C58h */ case    7:  		/* bl 616 */
		/* 82098C58h case    7:*/		regs.LR = 0x82098C5C; return 0x82098EC0;
		/* 82098C58h case    7:*/		return 0x82098C5C;
		  /* 82098C5Ch */ case    8:  		/* fmr FR1, FR31 */
		/* 82098C5Ch case    8:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82098C5Ch case    8:*/		return 0x82098C60;
	}
	return 0x82098C60;
} // Block from 82098C3Ch-82098C60h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82098C60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098C60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098C60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098C60);
		  /* 82098C60h */ case    0:  		/* addi R1, R1, 112 */
		/* 82098C60h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82098C60h case    0:*/		return 0x82098C64;
		  /* 82098C64h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82098C64h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82098C64h case    1:*/		return 0x82098C68;
		  /* 82098C68h */ case    2:  		/* mtspr LR, R12 */
		/* 82098C68h case    2:*/		regs.LR = regs.R12;
		/* 82098C68h case    2:*/		return 0x82098C6C;
		  /* 82098C6Ch */ case    3:  		/* lfd FR31, <#[R1 - 24]> */
		/* 82098C6Ch case    3:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82098C6Ch case    3:*/		return 0x82098C70;
		  /* 82098C70h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82098C70h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82098C70h case    4:*/		return 0x82098C74;
		  /* 82098C74h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82098C74h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82098C74h case    5:*/		return 0x82098C78;
	}
	return 0x82098C78;
} // Block from 82098C60h-82098C78h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82098C78h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098C78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098C78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098C78);
		  /* 82098C78h */ case    0:  		/* mfspr R12, LR */
		/* 82098C78h case    0:*/		regs.R12 = regs.LR;
		/* 82098C78h case    0:*/		return 0x82098C7C;
		  /* 82098C7Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82098C7Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82098C7Ch case    1:*/		return 0x82098C80;
		  /* 82098C80h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82098C80h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82098C80h case    2:*/		return 0x82098C84;
		  /* 82098C84h */ case    3:  		/* stfd FR31, <#[R1 - 24]> */
		/* 82098C84h case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82098C84h case    3:*/		return 0x82098C88;
		  /* 82098C88h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82098C88h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82098C88h case    4:*/		return 0x82098C8C;
		  /* 82098C8Ch */ case    5:  		/* lis R11, -32217 */
		/* 82098C8Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82098C8Ch case    5:*/		return 0x82098C90;
		  /* 82098C90h */ case    6:  		/* fadd FR31, FR1, FR2 */
		/* 82098C90h case    6:*/		cpu::op::fadd<0>(regs,&regs.FR31,regs.FR1,regs.FR2);
		/* 82098C90h case    6:*/		return 0x82098C94;
		  /* 82098C94h */ case    7:  		/* mr R4, R3 */
		/* 82098C94h case    7:*/		regs.R4 = regs.R3;
		/* 82098C94h case    7:*/		return 0x82098C98;
		  /* 82098C98h */ case    8:  		/* mr R31, R6 */
		/* 82098C98h case    8:*/		regs.R31 = regs.R6;
		/* 82098C98h case    8:*/		return 0x82098C9C;
		  /* 82098C9Ch */ case    9:  		/* lwz R11, <#[R11 + 9584]> */
		/* 82098C9Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00002570) );
		/* 82098C9Ch case    9:*/		return 0x82098CA0;
	}
	return 0x82098CA0;
} // Block from 82098C78h-82098CA0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82098CA0h
// Function '_unlock'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098CA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098CA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098CA0);
		  /* 82098CA0h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 82098CA0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82098CA0h case    0:*/		return 0x82098CA4;
		  /* 82098CA4h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 82098CA4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82098CBC;  }
		/* 82098CA4h case    1:*/		return 0x82098CA8;
		  /* 82098CA8h */ case    2:  		/* mr R8, R6 */
		/* 82098CA8h case    2:*/		regs.R8 = regs.R6;
		/* 82098CA8h case    2:*/		return 0x82098CAC;
		  /* 82098CACh */ case    3:  		/* fmr FR3, FR31 */
		/* 82098CACh case    3:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR31);
		/* 82098CACh case    3:*/		return 0x82098CB0;
		  /* 82098CB0h */ case    4:  		/* li R3, 1 */
		/* 82098CB0h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82098CB0h case    4:*/		return 0x82098CB4;
		  /* 82098CB4h */ case    5:  		/* bl -460 */
		/* 82098CB4h case    5:*/		regs.LR = 0x82098CB8; return 0x82098AE8;
		/* 82098CB4h case    5:*/		return 0x82098CB8;
		  /* 82098CB8h */ case    6:  		/* b 40 */
		/* 82098CB8h case    6:*/		return 0x82098CE0;
		/* 82098CB8h case    6:*/		return 0x82098CBC;
	}
	return 0x82098CBC;
} // Block from 82098CA0h-82098CBCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 82098CBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098CBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098CBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098CBC);
		  /* 82098CBCh */ case    0:  		/* bl -15796 */
		/* 82098CBCh case    0:*/		regs.LR = 0x82098CC0; return 0x82094F08;
		/* 82098CBCh case    0:*/		return 0x82098CC0;
	}
	return 0x82098CC0;
} // Block from 82098CBCh-82098CC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82098CC0h
// Function '__crtInitCritSecAndSpinCount'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098CC0);
		  /* 82098CC0h */ case    0:  		/* mr R11, R3 */
		/* 82098CC0h case    0:*/		regs.R11 = regs.R3;
		/* 82098CC0h case    0:*/		return 0x82098CC4;
		  /* 82098CC4h */ case    1:  		/* li R10, 33 */
		/* 82098CC4h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x21);
		/* 82098CC4h case    1:*/		return 0x82098CC8;
		  /* 82098CC8h */ case    2:  		/* lis R4, -16377 */
		/* 82098CC8h case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFC007);
		/* 82098CC8h case    2:*/		return 0x82098CCC;
		  /* 82098CCCh */ case    3:  		/* mr R3, R31 */
		/* 82098CCCh case    3:*/		regs.R3 = regs.R31;
		/* 82098CCCh case    3:*/		return 0x82098CD0;
		  /* 82098CD0h */ case    4:  		/* ori R4, R4, 65279 */
		/* 82098CD0h case    4:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0xFEFF);
		/* 82098CD0h case    4:*/		return 0x82098CD4;
		  /* 82098CD4h */ case    5:  		/* stw R10, <#[R11]> */
		/* 82098CD4h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82098CD4h case    5:*/		return 0x82098CD8;
		  /* 82098CD8h */ case    6:  		/* bl 488 */
		/* 82098CD8h case    6:*/		regs.LR = 0x82098CDC; return 0x82098EC0;
		/* 82098CD8h case    6:*/		return 0x82098CDC;
		  /* 82098CDCh */ case    7:  		/* fmr FR1, FR31 */
		/* 82098CDCh case    7:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82098CDCh case    7:*/		return 0x82098CE0;
	}
	return 0x82098CE0;
} // Block from 82098CC0h-82098CE0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82098CE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098CE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098CE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098CE0);
		  /* 82098CE0h */ case    0:  		/* addi R1, R1, 112 */
		/* 82098CE0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82098CE0h case    0:*/		return 0x82098CE4;
		  /* 82098CE4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82098CE4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82098CE4h case    1:*/		return 0x82098CE8;
		  /* 82098CE8h */ case    2:  		/* mtspr LR, R12 */
		/* 82098CE8h case    2:*/		regs.LR = regs.R12;
		/* 82098CE8h case    2:*/		return 0x82098CEC;
		  /* 82098CECh */ case    3:  		/* lfd FR31, <#[R1 - 24]> */
		/* 82098CECh case    3:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82098CECh case    3:*/		return 0x82098CF0;
		  /* 82098CF0h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82098CF0h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82098CF0h case    4:*/		return 0x82098CF4;
		  /* 82098CF4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82098CF4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82098CF4h case    5:*/		return 0x82098CF8;
	}
	return 0x82098CF8;
} // Block from 82098CE0h-82098CF8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82098CF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098CF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098CF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098CF8);
		  /* 82098CF8h */ case    0:  		/* mfspr R12, LR */
		/* 82098CF8h case    0:*/		regs.R12 = regs.LR;
		/* 82098CF8h case    0:*/		return 0x82098CFC;
		  /* 82098CFCh */ case    1:  		/* bl -31392 */
		/* 82098CFCh case    1:*/		regs.LR = 0x82098D00; return 0x8209125C;
		/* 82098CFCh case    1:*/		return 0x82098D00;
		  /* 82098D00h */ case    2:  		/* stfd FR31, <#[R1 - 40]> */
		/* 82098D00h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFD8) );
		/* 82098D00h case    2:*/		return 0x82098D04;
		  /* 82098D04h */ case    3:  		/* stwu R1, <#[R1 - 240]> */
		/* 82098D04h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 82098D04h case    3:*/		return 0x82098D08;
		  /* 82098D08h */ case    4:  		/* stfd FR2, <#[R1 + 280]> */
		/* 82098D08h case    4:*/		cpu::mem::store64f( regs, regs.FR2, (uint32)(regs.R1 + 0x00000118) );
		/* 82098D08h case    4:*/		return 0x82098D0C;
		  /* 82098D0Ch */ case    5:  		/* mr R29, R4 */
		/* 82098D0Ch case    5:*/		regs.R29 = regs.R4;
		/* 82098D0Ch case    5:*/		return 0x82098D10;
		  /* 82098D10h */ case    6:  		/* addi R4, R1, 280 */
		/* 82098D10h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x118);
		/* 82098D10h case    6:*/		return 0x82098D14;
		  /* 82098D14h */ case    7:  		/* stfd FR1, <#[R1 + 272]> */
		/* 82098D14h case    7:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000110) );
		/* 82098D14h case    7:*/		return 0x82098D18;
		  /* 82098D18h */ case    8:  		/* mr R5, R7 */
		/* 82098D18h case    8:*/		regs.R5 = regs.R7;
		/* 82098D18h case    8:*/		return 0x82098D1C;
		  /* 82098D1Ch */ case    9:  		/* fmr FR31, FR1 */
		/* 82098D1Ch case    9:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 82098D1Ch case    9:*/		return 0x82098D20;
		  /* 82098D20h */ case   10:  		/* mr R31, R3 */
		/* 82098D20h case   10:*/		regs.R31 = regs.R3;
		/* 82098D20h case   10:*/		return 0x82098D24;
		  /* 82098D24h */ case   11:  		/* stw R7, <#[R1 + 292]> */
		/* 82098D24h case   11:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000124) );
		/* 82098D24h case   11:*/		return 0x82098D28;
		  /* 82098D28h */ case   12:  		/* mr R30, R7 */
		/* 82098D28h case   12:*/		regs.R30 = regs.R7;
		/* 82098D28h case   12:*/		return 0x82098D2C;
		  /* 82098D2Ch */ case   13:  		/* bl -1324 */
		/* 82098D2Ch case   13:*/		regs.LR = 0x82098D30; return 0x82098800;
		/* 82098D2Ch case   13:*/		return 0x82098D30;
		  /* 82098D30h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 82098D30h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82098D30h case   14:*/		return 0x82098D34;
		  /* 82098D34h */ case   15:  		/* bc 4, CR0_EQ, 52 */
		/* 82098D34h case   15:*/		if ( !regs.CR[0].eq ) { return 0x82098D68;  }
		/* 82098D34h case   15:*/		return 0x82098D38;
		  /* 82098D38h */ case   16:  		/* lwz R11, <#[R1 + 144]> */
		/* 82098D38h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 82098D38h case   16:*/		return 0x82098D3C;
		  /* 82098D3Ch */ case   17:  		/* li R9, 0 */
		/* 82098D3Ch case   17:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82098D3Ch case   17:*/		return 0x82098D40;
		  /* 82098D40h */ case   18:  		/* addi R8, R1, 280 */
		/* 82098D40h case   18:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x118);
		/* 82098D40h case   18:*/		return 0x82098D44;
		  /* 82098D44h */ case   19:  		/* rlwinm R11, R11, 0, 1, 31 */
		/* 82098D44h case   19:*/		cpu::op::rlwinm<0,0,1,31>(regs,&regs.R11,regs.R11);
		/* 82098D44h case   19:*/		return 0x82098D48;
		  /* 82098D48h */ case   20:  		/* addi R7, R1, 272 */
		/* 82098D48h case   20:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x110);
		/* 82098D48h case   20:*/		return 0x82098D4C;
		  /* 82098D4Ch */ case   21:  		/* stw R11, <#[R1 + 144]> */
		/* 82098D4Ch case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 82098D4Ch case   21:*/		return 0x82098D50;
		  /* 82098D50h */ case   22:  		/* mr R6, R29 */
		/* 82098D50h case   22:*/		regs.R6 = regs.R29;
		/* 82098D50h case   22:*/		return 0x82098D54;
		  /* 82098D54h */ case   23:  		/* mr R5, R31 */
		/* 82098D54h case   23:*/		regs.R5 = regs.R31;
		/* 82098D54h case   23:*/		return 0x82098D58;
	}
	return 0x82098D58;
} // Block from 82098CF8h-82098D58h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82098D58h
// Function '_mtinitlocks'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098D58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098D58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098D58);
		  /* 82098D58h */ case    0:  		/* addi R4, R1, 292 */
		/* 82098D58h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x124);
		/* 82098D58h case    0:*/		return 0x82098D5C;
		  /* 82098D5Ch */ case    1:  		/* addi R3, R1, 80 */
		/* 82098D5Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82098D5Ch case    1:*/		return 0x82098D60;
		  /* 82098D60h */ case    2:  		/* bl -2408 */
		/* 82098D60h case    2:*/		regs.LR = 0x82098D64; return 0x820983F8;
		/* 82098D60h case    2:*/		return 0x82098D64;
		  /* 82098D64h */ case    3:  		/* lwz R30, <#[R1 + 292]> */
		/* 82098D64h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000124) );
		/* 82098D64h case    3:*/		return 0x82098D68;
	}
	return 0x82098D68;
} // Block from 82098D58h-82098D68h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82098D68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098D68);
		  /* 82098D68h */ case    0:  		/* mr R3, R31 */
		/* 82098D68h case    0:*/		regs.R3 = regs.R31;
		/* 82098D68h case    0:*/		return 0x82098D6C;
		  /* 82098D6Ch */ case    1:  		/* bl -716 */
		/* 82098D6Ch case    1:*/		regs.LR = 0x82098D70; return 0x82098AA0;
		/* 82098D6Ch case    1:*/		return 0x82098D70;
		  /* 82098D70h */ case    2:  		/* lis R11, -32217 */
		/* 82098D70h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82098D70h case    2:*/		return 0x82098D74;
		  /* 82098D74h */ case    3:  		/* lwz R11, <#[R11 + 9584]> */
		/* 82098D74h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00002570) );
		/* 82098D74h case    3:*/		return 0x82098D78;
		  /* 82098D78h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 82098D78h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82098D78h case    4:*/		return 0x82098D7C;
		  /* 82098D7Ch */ case    5:  		/* bc 4, CR6_EQ, 44 */
		/* 82098D7Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x82098DA8;  }
		/* 82098D7Ch case    5:*/		return 0x82098D80;
		  /* 82098D80h */ case    6:  		/* cmpwi CR6, R3, 0 */
		/* 82098D80h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 82098D80h case    6:*/		return 0x82098D84;
		  /* 82098D84h */ case    7:  		/* bc 12, CR6_EQ, 36 */
		/* 82098D84h case    7:*/		if ( regs.CR[6].eq ) { return 0x82098DA8;  }
		/* 82098D84h case    7:*/		return 0x82098D88;
		  /* 82098D88h */ case    8:  		/* lis R11, -32256 */
		/* 82098D88h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82098D88h case    8:*/		return 0x82098D8C;
		  /* 82098D8Ch */ case    9:  		/* lfd FR3, <#[R1 + 280]> */
		/* 82098D8Ch case    9:*/		cpu::mem::load64f( regs, &regs.FR3, (uint32)(regs.R1 + 0x00000118) );
		/* 82098D8Ch case    9:*/		return 0x82098D90;
		  /* 82098D90h */ case   10:  		/* mr R8, R30 */
		/* 82098D90h case   10:*/		regs.R8 = regs.R30;
		/* 82098D90h case   10:*/		return 0x82098D94;
		  /* 82098D94h */ case   11:  		/* fmr FR1, FR31 */
		/* 82098D94h case   11:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82098D94h case   11:*/		return 0x82098D98;
		  /* 82098D98h */ case   12:  		/* mr R4, R29 */
		/* 82098D98h case   12:*/		regs.R4 = regs.R29;
		/* 82098D98h case   12:*/		return 0x82098D9C;
		  /* 82098D9Ch */ case   13:  		/* lfd FR2, <#[R11 + 1808]> */
		/* 82098D9Ch case   13:*/		cpu::mem::load64f( regs, &regs.FR2, (uint32)(regs.R11 + 0x00000710) );
		/* 82098D9Ch case   13:*/		return 0x82098DA0;
		  /* 82098DA0h */ case   14:  		/* bl -696 */
		/* 82098DA0h case   14:*/		regs.LR = 0x82098DA4; return 0x82098AE8;
		/* 82098DA0h case   14:*/		return 0x82098DA4;
		  /* 82098DA4h */ case   15:  		/* b 28 */
		/* 82098DA4h case   15:*/		return 0x82098DC0;
		/* 82098DA4h case   15:*/		return 0x82098DA8;
	}
	return 0x82098DA8;
} // Block from 82098D68h-82098DA8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82098DA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098DA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098DA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098DA8);
		  /* 82098DA8h */ case    0:  		/* bl -848 */
		/* 82098DA8h case    0:*/		regs.LR = 0x82098DAC; return 0x82098A58;
		/* 82098DA8h case    0:*/		return 0x82098DAC;
		  /* 82098DACh */ case    1:  		/* lis R4, -16377 */
		/* 82098DACh case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFC007);
		/* 82098DACh case    1:*/		return 0x82098DB0;
		  /* 82098DB0h */ case    2:  		/* mr R3, R30 */
		/* 82098DB0h case    2:*/		regs.R3 = regs.R30;
		/* 82098DB0h case    2:*/		return 0x82098DB4;
		  /* 82098DB4h */ case    3:  		/* ori R4, R4, 65279 */
		/* 82098DB4h case    3:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0xFEFF);
		/* 82098DB4h case    3:*/		return 0x82098DB8;
		  /* 82098DB8h */ case    4:  		/* bl 264 */
		/* 82098DB8h case    4:*/		regs.LR = 0x82098DBC; return 0x82098EC0;
		/* 82098DB8h case    4:*/		return 0x82098DBC;
		  /* 82098DBCh */ case    5:  		/* lfd FR1, <#[R1 + 280]> */
		/* 82098DBCh case    5:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0x00000118) );
		/* 82098DBCh case    5:*/		return 0x82098DC0;
	}
	return 0x82098DC0;
} // Block from 82098DA8h-82098DC0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82098DC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098DC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098DC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098DC0);
		  /* 82098DC0h */ case    0:  		/* addi R1, R1, 240 */
		/* 82098DC0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 82098DC0h case    0:*/		return 0x82098DC4;
		  /* 82098DC4h */ case    1:  		/* lfd FR31, <#[R1 - 40]> */
		/* 82098DC4h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFD8) );
		/* 82098DC4h case    1:*/		return 0x82098DC8;
		  /* 82098DC8h */ case    2:  		/* b -31516 */
		/* 82098DC8h case    2:*/		return 0x820912AC;
		/* 82098DC8h case    2:*/		return 0x82098DCC;
		  /* 82098DCCh */ case    3:  		/* nop */
		/* 82098DCCh case    3:*/		cpu::op::nop();
		/* 82098DCCh case    3:*/		return 0x82098DD0;
	}
	return 0x82098DD0;
} // Block from 82098DC0h-82098DD0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82098DD0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098DD0);
		  /* 82098DD0h */ case    0:  		/* mfspr R12, LR */
		/* 82098DD0h case    0:*/		regs.R12 = regs.LR;
		/* 82098DD0h case    0:*/		return 0x82098DD4;
		  /* 82098DD4h */ case    1:  		/* bl -31608 */
		/* 82098DD4h case    1:*/		regs.LR = 0x82098DD8; return 0x8209125C;
		/* 82098DD4h case    1:*/		return 0x82098DD8;
		  /* 82098DD8h */ case    2:  		/* stfd FR30, <#[R1 - 48]> */
		/* 82098DD8h case    2:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFFD0) );
		/* 82098DD8h case    2:*/		return 0x82098DDC;
		  /* 82098DDCh */ case    3:  		/* stfd FR31, <#[R1 - 40]> */
		/* 82098DDCh case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFD8) );
		/* 82098DDCh case    3:*/		return 0x82098DE0;
	}
	return 0x82098DE0;
} // Block from 82098DD0h-82098DE0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82098DE0h
// Function '_mtinitlocknum'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098DE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098DE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098DE0);
		  /* 82098DE0h */ case    0:  		/* stwu R1, <#[R1 - 240]> */
		/* 82098DE0h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 82098DE0h case    0:*/		return 0x82098DE4;
		  /* 82098DE4h */ case    1:  		/* stfd FR3, <#[R1 + 288]> */
		/* 82098DE4h case    1:*/		cpu::mem::store64f( regs, regs.FR3, (uint32)(regs.R1 + 0x00000120) );
		/* 82098DE4h case    1:*/		return 0x82098DE8;
		  /* 82098DE8h */ case    2:  		/* mr R29, R4 */
		/* 82098DE8h case    2:*/		regs.R29 = regs.R4;
		/* 82098DE8h case    2:*/		return 0x82098DEC;
		  /* 82098DECh */ case    3:  		/* addi R4, R1, 288 */
		/* 82098DECh case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x120);
		/* 82098DECh case    3:*/		return 0x82098DF0;
		  /* 82098DF0h */ case    4:  		/* stfd FR1, <#[R1 + 272]> */
		/* 82098DF0h case    4:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000110) );
		/* 82098DF0h case    4:*/		return 0x82098DF4;
		  /* 82098DF4h */ case    5:  		/* mr R5, R8 */
		/* 82098DF4h case    5:*/		regs.R5 = regs.R8;
		/* 82098DF4h case    5:*/		return 0x82098DF8;
		  /* 82098DF8h */ case    6:  		/* fmr FR30, FR1 */
		/* 82098DF8h case    6:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR1);
		/* 82098DF8h case    6:*/		return 0x82098DFC;
		  /* 82098DFCh */ case    7:  		/* mr R31, R3 */
		/* 82098DFCh case    7:*/		regs.R31 = regs.R3;
		/* 82098DFCh case    7:*/		return 0x82098E00;
		  /* 82098E00h */ case    8:  		/* stw R8, <#[R1 + 300]> */
		/* 82098E00h case    8:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x0000012C) );
		/* 82098E00h case    8:*/		return 0x82098E04;
		  /* 82098E04h */ case    9:  		/* mr R30, R8 */
		/* 82098E04h case    9:*/		regs.R30 = regs.R8;
		/* 82098E04h case    9:*/		return 0x82098E08;
		  /* 82098E08h */ case   10:  		/* fmr FR31, FR2 */
		/* 82098E08h case   10:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR2);
		/* 82098E08h case   10:*/		return 0x82098E0C;
		  /* 82098E0Ch */ case   11:  		/* bl -1548 */
		/* 82098E0Ch case   11:*/		regs.LR = 0x82098E10; return 0x82098800;
		/* 82098E0Ch case   11:*/		return 0x82098E10;
		  /* 82098E10h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 82098E10h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82098E10h case   12:*/		return 0x82098E14;
		  /* 82098E14h */ case   13:  		/* bc 4, CR0_EQ, 60 */
		/* 82098E14h case   13:*/		if ( !regs.CR[0].eq ) { return 0x82098E50;  }
		/* 82098E14h case   13:*/		return 0x82098E18;
		  /* 82098E18h */ case   14:  		/* lwz R11, <#[R1 + 144]> */
		/* 82098E18h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 82098E18h case   14:*/		return 0x82098E1C;
		  /* 82098E1Ch */ case   15:  		/* stfd FR31, <#[R1 + 128]> */
		/* 82098E1Ch case   15:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0x00000080) );
		/* 82098E1Ch case   15:*/		return 0x82098E20;
		  /* 82098E20h */ case   16:  		/* li R9, 0 */
		/* 82098E20h case   16:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82098E20h case   16:*/		return 0x82098E24;
		  /* 82098E24h */ case   17:  		/* rlwinm R11, R11, 0, 5, 31 */
		/* 82098E24h case   17:*/		cpu::op::rlwinm<0,0,5,31>(regs,&regs.R11,regs.R11);
		/* 82098E24h case   17:*/		return 0x82098E28;
		  /* 82098E28h */ case   18:  		/* addi R8, R1, 288 */
		/* 82098E28h case   18:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x120);
		/* 82098E28h case   18:*/		return 0x82098E2C;
		  /* 82098E2Ch */ case   19:  		/* oris R11, R11, 34816 */
		/* 82098E2Ch case   19:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8800);
		/* 82098E2Ch case   19:*/		return 0x82098E30;
		  /* 82098E30h */ case   20:  		/* addi R7, R1, 272 */
		/* 82098E30h case   20:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x110);
		/* 82098E30h case   20:*/		return 0x82098E34;
		  /* 82098E34h */ case   21:  		/* stw R11, <#[R1 + 144]> */
		/* 82098E34h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 82098E34h case   21:*/		return 0x82098E38;
		  /* 82098E38h */ case   22:  		/* mr R6, R29 */
		/* 82098E38h case   22:*/		regs.R6 = regs.R29;
		/* 82098E38h case   22:*/		return 0x82098E3C;
		  /* 82098E3Ch */ case   23:  		/* mr R5, R31 */
		/* 82098E3Ch case   23:*/		regs.R5 = regs.R31;
		/* 82098E3Ch case   23:*/		return 0x82098E40;
		  /* 82098E40h */ case   24:  		/* addi R4, R1, 300 */
		/* 82098E40h case   24:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x12C);
		/* 82098E40h case   24:*/		return 0x82098E44;
		  /* 82098E44h */ case   25:  		/* addi R3, R1, 80 */
		/* 82098E44h case   25:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82098E44h case   25:*/		return 0x82098E48;
		  /* 82098E48h */ case   26:  		/* bl -2640 */
		/* 82098E48h case   26:*/		regs.LR = 0x82098E4C; return 0x820983F8;
		/* 82098E48h case   26:*/		return 0x82098E4C;
		  /* 82098E4Ch */ case   27:  		/* lwz R30, <#[R1 + 300]> */
		/* 82098E4Ch case   27:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x0000012C) );
		/* 82098E4Ch case   27:*/		return 0x82098E50;
	}
	return 0x82098E50;
} // Block from 82098DE0h-82098E50h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82098E50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098E50);
		  /* 82098E50h */ case    0:  		/* mr R3, R31 */
		/* 82098E50h case    0:*/		regs.R3 = regs.R31;
		/* 82098E50h case    0:*/		return 0x82098E54;
		  /* 82098E54h */ case    1:  		/* bl -948 */
		/* 82098E54h case    1:*/		regs.LR = 0x82098E58; return 0x82098AA0;
		/* 82098E54h case    1:*/		return 0x82098E58;
		  /* 82098E58h */ case    2:  		/* lis R11, -32217 */
		/* 82098E58h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82098E58h case    2:*/		return 0x82098E5C;
		  /* 82098E5Ch */ case    3:  		/* lwz R11, <#[R11 + 9584]> */
		/* 82098E5Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00002570) );
		/* 82098E5Ch case    3:*/		return 0x82098E60;
		  /* 82098E60h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 82098E60h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82098E60h case    4:*/		return 0x82098E64;
		  /* 82098E64h */ case    5:  		/* bc 4, CR6_EQ, 40 */
		/* 82098E64h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82098E8C;  }
		/* 82098E64h case    5:*/		return 0x82098E68;
		  /* 82098E68h */ case    6:  		/* cmpwi CR6, R3, 0 */
		/* 82098E68h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 82098E68h case    6:*/		return 0x82098E6C;
		  /* 82098E6Ch */ case    7:  		/* bc 12, CR6_EQ, 32 */
		/* 82098E6Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x82098E8C;  }
		/* 82098E6Ch case    7:*/		return 0x82098E70;
		  /* 82098E70h */ case    8:  		/* mr R8, R30 */
		/* 82098E70h case    8:*/		regs.R8 = regs.R30;
		/* 82098E70h case    8:*/		return 0x82098E74;
		  /* 82098E74h */ case    9:  		/* lfd FR3, <#[R1 + 288]> */
		/* 82098E74h case    9:*/		cpu::mem::load64f( regs, &regs.FR3, (uint32)(regs.R1 + 0x00000120) );
		/* 82098E74h case    9:*/		return 0x82098E78;
		  /* 82098E78h */ case   10:  		/* mr R4, R29 */
		/* 82098E78h case   10:*/		regs.R4 = regs.R29;
		/* 82098E78h case   10:*/		return 0x82098E7C;
		  /* 82098E7Ch */ case   11:  		/* fmr FR2, FR31 */
		/* 82098E7Ch case   11:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 82098E7Ch case   11:*/		return 0x82098E80;
		  /* 82098E80h */ case   12:  		/* fmr FR1, FR30 */
		/* 82098E80h case   12:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 82098E80h case   12:*/		return 0x82098E84;
		  /* 82098E84h */ case   13:  		/* bl -924 */
		/* 82098E84h case   13:*/		regs.LR = 0x82098E88; return 0x82098AE8;
		/* 82098E84h case   13:*/		return 0x82098E88;
		  /* 82098E88h */ case   14:  		/* b 28 */
		/* 82098E88h case   14:*/		return 0x82098EA4;
		/* 82098E88h case   14:*/		return 0x82098E8C;
	}
	return 0x82098E8C;
} // Block from 82098E50h-82098E8Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 82098E8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098E8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098E8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098E8C);
		  /* 82098E8Ch */ case    0:  		/* bl -1076 */
		/* 82098E8Ch case    0:*/		regs.LR = 0x82098E90; return 0x82098A58;
		/* 82098E8Ch case    0:*/		return 0x82098E90;
		  /* 82098E90h */ case    1:  		/* lis R4, -16377 */
		/* 82098E90h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFC007);
		/* 82098E90h case    1:*/		return 0x82098E94;
		  /* 82098E94h */ case    2:  		/* mr R3, R30 */
		/* 82098E94h case    2:*/		regs.R3 = regs.R30;
		/* 82098E94h case    2:*/		return 0x82098E98;
		  /* 82098E98h */ case    3:  		/* ori R4, R4, 65279 */
		/* 82098E98h case    3:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0xFEFF);
		/* 82098E98h case    3:*/		return 0x82098E9C;
		  /* 82098E9Ch */ case    4:  		/* bl 36 */
		/* 82098E9Ch case    4:*/		regs.LR = 0x82098EA0; return 0x82098EC0;
		/* 82098E9Ch case    4:*/		return 0x82098EA0;
		  /* 82098EA0h */ case    5:  		/* lfd FR1, <#[R1 + 288]> */
		/* 82098EA0h case    5:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0x00000120) );
		/* 82098EA0h case    5:*/		return 0x82098EA4;
	}
	return 0x82098EA4;
} // Block from 82098E8Ch-82098EA4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82098EA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098EA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098EA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098EA4);
		  /* 82098EA4h */ case    0:  		/* addi R1, R1, 240 */
		/* 82098EA4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 82098EA4h case    0:*/		return 0x82098EA8;
		  /* 82098EA8h */ case    1:  		/* lfd FR30, <#[R1 - 48]> */
		/* 82098EA8h case    1:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFFD0) );
		/* 82098EA8h case    1:*/		return 0x82098EAC;
		  /* 82098EACh */ case    2:  		/* lfd FR31, <#[R1 - 40]> */
		/* 82098EACh case    2:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFD8) );
		/* 82098EACh case    2:*/		return 0x82098EB0;
		  /* 82098EB0h */ case    3:  		/* b -31748 */
		/* 82098EB0h case    3:*/		return 0x820912AC;
		/* 82098EB0h case    3:*/		return 0x82098EB4;
		  /* 82098EB4h */ case    4:  		/* nop */
		/* 82098EB4h case    4:*/		cpu::op::nop();
		/* 82098EB4h case    4:*/		return 0x82098EB8;
		  /* 82098EB8h */ case    5:  		/* nop */
		/* 82098EB8h case    5:*/		cpu::op::nop();
		/* 82098EB8h case    5:*/		return 0x82098EBC;
		  /* 82098EBCh */ case    6:  		/* nop */
		/* 82098EBCh case    6:*/		cpu::op::nop();
		/* 82098EBCh case    6:*/		return 0x82098EC0;
	}
	return 0x82098EC0;
} // Block from 82098EA4h-82098EC0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82098EC0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098EC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098EC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098EC0);
		  /* 82098EC0h */ case    0:  		/* mffs FR0 */
		/* 82098EC0h case    0:*/		cpu::op::mffs<0>(regs,&regs.FR0);
		/* 82098EC0h case    0:*/		return 0x82098EC4;
		  /* 82098EC4h */ case    1:  		/* stfd FR0, <#[R1 - 8]> */
		/* 82098EC4h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82098EC4h case    1:*/		return 0x82098EC8;
		  /* 82098EC8h */ case    2:  		/* xori R5, R3, 248 */
		/* 82098EC8h case    2:*/		cpu::op::xori<0>(regs,&regs.R5,regs.R3,0xF8);
		/* 82098EC8h case    2:*/		return 0x82098ECC;
		  /* 82098ECCh */ case    3:  		/* lwz R3, <#[R1 - 4]> */
		/* 82098ECCh case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFFC) );
		/* 82098ECCh case    3:*/		return 0x82098ED0;
		  /* 82098ED0h */ case    4:  		/* and R5, R5, R4 */
		/* 82098ED0h case    4:*/		cpu::op::and<0>(regs,&regs.R5,regs.R5,regs.R4);
		/* 82098ED0h case    4:*/		return 0x82098ED4;
		  /* 82098ED4h */ case    5:  		/* andc R6, R3, R4 */
		/* 82098ED4h case    5:*/		cpu::op::andc<0>(regs,&regs.R6,regs.R3,regs.R4);
		/* 82098ED4h case    5:*/		return 0x82098ED8;
		  /* 82098ED8h */ case    6:  		/* or R6, R5, R6 */
		/* 82098ED8h case    6:*/		cpu::op::or<0>(regs,&regs.R6,regs.R5,regs.R6);
		/* 82098ED8h case    6:*/		return 0x82098EDC;
		  /* 82098EDCh */ case    7:  		/* stw R6, <#[R1 - 4]> */
		/* 82098EDCh case    7:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0xFFFFFFFC) );
		/* 82098EDCh case    7:*/		return 0x82098EE0;
		  /* 82098EE0h */ case    8:  		/* lfd FR0, <#[R1 - 8]> */
		/* 82098EE0h case    8:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82098EE0h case    8:*/		return 0x82098EE4;
		  /* 82098EE4h */ case    9:  		/* xori R3, R3, 248 */
		/* 82098EE4h case    9:*/		cpu::op::xori<0>(regs,&regs.R3,regs.R3,0xF8);
		/* 82098EE4h case    9:*/		return 0x82098EE8;
		  /* 82098EE8h */ case   10:  		/* mtfsf 127, FR0 */
		/* 82098EE8h case   10:*/		cpu::op::mtfsf<0>(regs,0x7F,regs.FR0);
		/* 82098EE8h case   10:*/		return 0x82098EEC;
		  /* 82098EECh */ case   11:  		/* bclr 20, CR0_LT */
		/* 82098EECh case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82098EECh case   11:*/		return 0x82098EF0;
	}
	return 0x82098EF0;
} // Block from 82098EC0h-82098EF0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82098EF0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098EF0);
		  /* 82098EF0h */ case    0:  		/* mffs FR0 */
		/* 82098EF0h case    0:*/		cpu::op::mffs<0>(regs,&regs.FR0);
		/* 82098EF0h case    0:*/		return 0x82098EF4;
		  /* 82098EF4h */ case    1:  		/* stfd FR0, <#[R1 - 8]> */
		/* 82098EF4h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82098EF4h case    1:*/		return 0x82098EF8;
		  /* 82098EF8h */ case    2:  		/* lwz R3, <#[R1 - 4]> */
		/* 82098EF8h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFFC) );
		/* 82098EF8h case    2:*/		return 0x82098EFC;
		  /* 82098EFCh */ case    3:  		/* bclr 20, CR0_LT */
		/* 82098EFCh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82098EFCh case    3:*/		return 0x82098F00;
	}
	return 0x82098F00;
} // Block from 82098EF0h-82098F00h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82098F00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098F00);
		  /* 82098F00h */ case    0:  		/* mffs FR0 */
		/* 82098F00h case    0:*/		cpu::op::mffs<0>(regs,&regs.FR0);
		/* 82098F00h case    0:*/		return 0x82098F04;
		  /* 82098F04h */ case    1:  		/* li R3, 4 */
		/* 82098F04h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x4);
		/* 82098F04h case    1:*/		return 0x82098F08;
		  /* 82098F08h */ case    2:  		/* stfd FR0, <#[R1 - 8]> */
		/* 82098F08h case    2:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82098F08h case    2:*/		return 0x82098F0C;
		  /* 82098F0Ch */ case    3:  		/* lwz R5, <#[R1 - 4]> */
		/* 82098F0Ch case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0xFFFFFFFC) );
		/* 82098F0Ch case    3:*/		return 0x82098F10;
		  /* 82098F10h */ case    4:  		/* and R5, R3, R5 */
		/* 82098F10h case    4:*/		cpu::op::and<0>(regs,&regs.R5,regs.R3,regs.R5);
		/* 82098F10h case    4:*/		return 0x82098F14;
		  /* 82098F14h */ case    5:  		/* stw R5, <#[R1 - 4]> */
		/* 82098F14h case    5:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0xFFFFFFFC) );
		/* 82098F14h case    5:*/		return 0x82098F18;
		  /* 82098F18h */ case    6:  		/* lfd FR1, <#[R1 - 8]> */
		/* 82098F18h case    6:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82098F18h case    6:*/		return 0x82098F1C;
		  /* 82098F1Ch */ case    7:  		/* mtfsf 127, FR0 */
		/* 82098F1Ch case    7:*/		cpu::op::mtfsf<0>(regs,0x7F,regs.FR0);
		/* 82098F1Ch case    7:*/		return 0x82098F20;
	}
	return 0x82098F20;
} // Block from 82098F00h-82098F20h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82098F20h
// Function '_lock'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098F20);
		  /* 82098F20h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82098F20h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82098F20h case    0:*/		return 0x82098F24;
	}
	return 0x82098F24;
} // Block from 82098F20h-82098F24h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82098F24h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098F24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098F24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098F24);
		  /* 82098F24h */ case    0:  		/* mffs FR0 */
		/* 82098F24h case    0:*/		cpu::op::mffs<0>(regs,&regs.FR0);
		/* 82098F24h case    0:*/		return 0x82098F28;
		  /* 82098F28h */ case    1:  		/* stfd FR0, <#[R1 - 8]> */
		/* 82098F28h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82098F28h case    1:*/		return 0x82098F2C;
		  /* 82098F2Ch */ case    2:  		/* lwz R5, <#[R1 - 4]> */
		/* 82098F2Ch case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0xFFFFFFFC) );
		/* 82098F2Ch case    2:*/		return 0x82098F30;
		  /* 82098F30h */ case    3:  		/* or R5, R3, R5 */
		/* 82098F30h case    3:*/		cpu::op::or<0>(regs,&regs.R5,regs.R3,regs.R5);
		/* 82098F30h case    3:*/		return 0x82098F34;
		  /* 82098F34h */ case    4:  		/* stw R5, <#[R1 - 4]> */
		/* 82098F34h case    4:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0xFFFFFFFC) );
		/* 82098F34h case    4:*/		return 0x82098F38;
		  /* 82098F38h */ case    5:  		/* lfd FR1, <#[R1 - 8]> */
		/* 82098F38h case    5:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82098F38h case    5:*/		return 0x82098F3C;
		  /* 82098F3Ch */ case    6:  		/* mtfsf 127, FR0 */
		/* 82098F3Ch case    6:*/		cpu::op::mtfsf<0>(regs,0x7F,regs.FR0);
		/* 82098F3Ch case    6:*/		return 0x82098F40;
		  /* 82098F40h */ case    7:  		/* bclr 20, CR0_LT */
		/* 82098F40h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82098F40h case    7:*/		return 0x82098F44;
	}
	return 0x82098F44;
} // Block from 82098F24h-82098F44h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82098F44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098F44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098F44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098F44);
		  /* 82098F44h */ case    0:  		/* stw R3, <#[R1 - 4]> */
		/* 82098F44h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0xFFFFFFFC) );
		/* 82098F44h case    0:*/		return 0x82098F48;
		  /* 82098F48h */ case    1:  		/* lfd FR1, <#[R1 - 8]> */
		/* 82098F48h case    1:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82098F48h case    1:*/		return 0x82098F4C;
		  /* 82098F4Ch */ case    2:  		/* mtfsf 127, FR0 */
		/* 82098F4Ch case    2:*/		cpu::op::mtfsf<0>(regs,0x7F,regs.FR0);
		/* 82098F4Ch case    2:*/		return 0x82098F50;
		  /* 82098F50h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82098F50h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82098F50h case    3:*/		return 0x82098F54;
	}
	return 0x82098F54;
} // Block from 82098F44h-82098F54h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82098F54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098F54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098F54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098F54);
		  /* 82098F54h */ case    0:  		/* mffs FR0 */
		/* 82098F54h case    0:*/		cpu::op::mffs<0>(regs,&regs.FR0);
		/* 82098F54h case    0:*/		return 0x82098F58;
		  /* 82098F58h */ case    1:  		/* stfd FR0, <#[R1 - 8]> */
		/* 82098F58h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82098F58h case    1:*/		return 0x82098F5C;
		  /* 82098F5Ch */ case    2:  		/* lwz R3, <#[R1 - 4]> */
		/* 82098F5Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFFC) );
		/* 82098F5Ch case    2:*/		return 0x82098F60;
		  /* 82098F60h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82098F60h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82098F60h case    3:*/		return 0x82098F64;
	}
	return 0x82098F64;
} // Block from 82098F54h-82098F64h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82098F64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098F64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098F64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098F64);
		  /* 82098F64h */ case    0:  		/* nop */
		/* 82098F64h case    0:*/		cpu::op::nop();
		/* 82098F64h case    0:*/		return 0x82098F68;
	}
	return 0x82098F68;
} // Block from 82098F64h-82098F68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82098F68h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098F68);
		  /* 82098F68h */ case    0:  		/* mfspr R12, LR */
		/* 82098F68h case    0:*/		regs.R12 = regs.LR;
		/* 82098F68h case    0:*/		return 0x82098F6C;
		  /* 82098F6Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82098F6Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82098F6Ch case    1:*/		return 0x82098F70;
		  /* 82098F70h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82098F70h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82098F70h case    2:*/		return 0x82098F74;
		  /* 82098F74h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82098F74h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82098F74h case    3:*/		return 0x82098F78;
		  /* 82098F78h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82098F78h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82098F78h case    4:*/		return 0x82098F7C;
		  /* 82098F7Ch */ case    5:  		/* lis R11, -32217 */
		/* 82098F7Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82098F7Ch case    5:*/		return 0x82098F80;
		  /* 82098F80h */ case    6:  		/* addi R30, R11, 7984 */
		/* 82098F80h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x1F30);
		/* 82098F80h case    6:*/		return 0x82098F84;
		  /* 82098F84h */ case    7:  		/* mr R31, R30 */
		/* 82098F84h case    7:*/		regs.R31 = regs.R30;
		/* 82098F84h case    7:*/		return 0x82098F88;
	}
	return 0x82098F88;
} // Block from 82098F68h-82098F88h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82098F88h
// Function '?terminate@@YAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098F88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098F88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098F88);
		  /* 82098F88h */ case    0:  		/* lwz R3, <#[R31]> */
		/* 82098F88h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 82098F88h case    0:*/		return 0x82098F8C;
		  /* 82098F8Ch */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 82098F8Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82098F8Ch case    1:*/		return 0x82098F90;
		  /* 82098F90h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 82098F90h case    2:*/		if ( regs.CR[6].eq ) { return 0x82098FAC;  }
		/* 82098F90h case    2:*/		return 0x82098F94;
		  /* 82098F94h */ case    3:  		/* lwz R11, <#[R31 + 4]> */
		/* 82098F94h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82098F94h case    3:*/		return 0x82098F98;
		  /* 82098F98h */ case    4:  		/* cmpwi CR6, R11, 1 */
		/* 82098F98h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 82098F98h case    4:*/		return 0x82098F9C;
		  /* 82098F9Ch */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 82098F9Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82098FAC;  }
		/* 82098F9Ch case    5:*/		return 0x82098FA0;
		  /* 82098FA0h */ case    6:  		/* bl -22392 */
		/* 82098FA0h case    6:*/		regs.LR = 0x82098FA4; return 0x82093828;
		/* 82098FA0h case    6:*/		return 0x82098FA4;
		  /* 82098FA4h */ case    7:  		/* li R11, 0 */
		/* 82098FA4h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82098FA4h case    7:*/		return 0x82098FA8;
		  /* 82098FA8h */ case    8:  		/* stw R11, <#[R31]> */
		/* 82098FA8h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82098FA8h case    8:*/		return 0x82098FAC;
	}
	return 0x82098FAC;
} // Block from 82098F88h-82098FACh (9 instructions)

//////////////////////////////////////////////////////
// Block at 82098FACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098FAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098FAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098FAC);
		  /* 82098FACh */ case    0:  		/* addi R31, R31, 8 */
		/* 82098FACh case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x8);
		/* 82098FACh case    0:*/		return 0x82098FB0;
		  /* 82098FB0h */ case    1:  		/* addi R11, R30, 288 */
		/* 82098FB0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x120);
		/* 82098FB0h case    1:*/		return 0x82098FB4;
		  /* 82098FB4h */ case    2:  		/* cmpw CR6, R31, R11 */
		/* 82098FB4h case    2:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R11);
		/* 82098FB4h case    2:*/		return 0x82098FB8;
		  /* 82098FB8h */ case    3:  		/* bc 12, CR6_LT, -48 */
		/* 82098FB8h case    3:*/		if ( regs.CR[6].lt ) { return 0x82098F88;  }
		/* 82098FB8h case    3:*/		return 0x82098FBC;
		  /* 82098FBCh */ case    4:  		/* addi R1, R1, 112 */
		/* 82098FBCh case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82098FBCh case    4:*/		return 0x82098FC0;
		  /* 82098FC0h */ case    5:  		/* lwz R12, <#[R1 - 8]> */
		/* 82098FC0h case    5:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82098FC0h case    5:*/		return 0x82098FC4;
		  /* 82098FC4h */ case    6:  		/* mtspr LR, R12 */
		/* 82098FC4h case    6:*/		regs.LR = regs.R12;
		/* 82098FC4h case    6:*/		return 0x82098FC8;
		  /* 82098FC8h */ case    7:  		/* ld R30, <#[R1 - 24]> */
		/* 82098FC8h case    7:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82098FC8h case    7:*/		return 0x82098FCC;
		  /* 82098FCCh */ case    8:  		/* ld R31, <#[R1 - 16]> */
		/* 82098FCCh case    8:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82098FCCh case    8:*/		return 0x82098FD0;
		  /* 82098FD0h */ case    9:  		/* bclr 20, CR0_LT */
		/* 82098FD0h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82098FD0h case    9:*/		return 0x82098FD4;
	}
	return 0x82098FD4;
} // Block from 82098FACh-82098FD4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82098FD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098FD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098FD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098FD4);
		  /* 82098FD4h */ case    0:  		/* nop */
		/* 82098FD4h case    0:*/		cpu::op::nop();
		/* 82098FD4h case    0:*/		return 0x82098FD8;
	}
	return 0x82098FD8;
} // Block from 82098FD4h-82098FD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82098FD8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098FD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098FD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098FD8);
		  /* 82098FD8h */ case    0:  		/* lis R11, -32217 */
		/* 82098FD8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82098FD8h case    0:*/		return 0x82098FDC;
		  /* 82098FDCh */ case    1:  		/* rlwinm R10, R3, 3, 0, 28 */
		/* 82098FDCh case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R3);
		/* 82098FDCh case    1:*/		return 0x82098FE0;
	}
	return 0x82098FE0;
} // Block from 82098FD8h-82098FE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82098FE0h
// Function '_initp_eh_hooks'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098FE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098FE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098FE0);
		  /* 82098FE0h */ case    0:  		/* addi R11, R11, 7984 */
		/* 82098FE0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1F30);
		/* 82098FE0h case    0:*/		return 0x82098FE4;
		  /* 82098FE4h */ case    1:  		/* lwzx R3, <#[R10 + R11]> */
		/* 82098FE4h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82098FE4h case    1:*/		return 0x82098FE8;
		  /* 82098FE8h */ case    2:  		/* b 1916992 */
		/* 82098FE8h case    2:*/		return 0x8226D028;
		/* 82098FE8h case    2:*/		return 0x82098FEC;
		  /* 82098FECh */ case    3:  		/* nop */
		/* 82098FECh case    3:*/		cpu::op::nop();
		/* 82098FECh case    3:*/		return 0x82098FF0;
		  /* 82098FF0h */ case    4:  		/* lwz R17, <#[R6 - 11576]> */
		/* 82098FF0h case    4:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 82098FF0h case    4:*/		return 0x82098FF4;
		  /* 82098FF4h */ case    5:  		/* lwz R16, <#[R4 - 15400]> */
		/* 82098FF4h case    5:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC3D8) );
		/* 82098FF4h case    5:*/		return 0x82098FF8;
	}
	return 0x82098FF8;
} // Block from 82098FE0h-82098FF8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82098FF8h
// Function '_initp_heap_handler'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82098FF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82098FF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82098FF8);
		  /* 82098FF8h */ case    0:  		/* mfspr R12, LR */
		/* 82098FF8h case    0:*/		regs.R12 = regs.LR;
		/* 82098FF8h case    0:*/		return 0x82098FFC;
		  /* 82098FFCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82098FFCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82098FFCh case    1:*/		return 0x82099000;
		  /* 82099000h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82099000h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82099000h case    2:*/		return 0x82099004;
		  /* 82099004h */ case    3:  		/* addi R31, R1, -112 */
		/* 82099004h case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFF90);
		/* 82099004h case    3:*/		return 0x82099008;
	}
	return 0x82099008;
} // Block from 82098FF8h-82099008h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82099008h
// Function '_callnewh'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099008);
		  /* 82099008h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 82099008h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82099008h case    0:*/		return 0x8209900C;
		  /* 8209900Ch */ case    1:  		/* ori R0, R0, 0 */
		/* 8209900Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 8209900Ch case    1:*/		return 0x82099010;
		  /* 82099010h */ case    2:  		/* nop */
		/* 82099010h case    2:*/		cpu::op::nop();
		/* 82099010h case    2:*/		return 0x82099014;
		  /* 82099014h */ case    3:  		/* nop */
		/* 82099014h case    3:*/		cpu::op::nop();
		/* 82099014h case    3:*/		return 0x82099018;
	}
	return 0x82099018;
} // Block from 82099008h-82099018h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82099018h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099018);
		  /* 82099018h */ case    0:  		/* bl 1918208 */
		/* 82099018h case    0:*/		regs.LR = 0x8209901C; return 0x8226D518;
		/* 82099018h case    0:*/		return 0x8209901C;
		  /* 8209901Ch */ case    1:  		/* li R3, 1 */
		/* 8209901Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8209901Ch case    1:*/		return 0x82099020;
		  /* 82099020h */ case    2:  		/* stw R3, <#[R31 + 80]> */
		/* 82099020h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 82099020h case    2:*/		return 0x82099024;
	}
	return 0x82099024;
} // Block from 82099018h-82099024h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82099024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099024);
		  /* 82099024h */ case    0:  		/* nop */
		/* 82099024h case    0:*/		cpu::op::nop();
		/* 82099024h case    0:*/		return 0x82099028;
		  /* 82099028h */ case    1:  		/* nop */
		/* 82099028h case    1:*/		cpu::op::nop();
		/* 82099028h case    1:*/		return 0x8209902C;
		  /* 8209902Ch */ case    2:  		/* nop */
		/* 8209902Ch case    2:*/		cpu::op::nop();
		/* 8209902Ch case    2:*/		return 0x82099030;
		  /* 82099030h */ case    3:  		/* b 36 */
		/* 82099030h case    3:*/		return 0x82099054;
		/* 82099030h case    3:*/		return 0x82099034;
	}
	return 0x82099034;
} // Block from 82099024h-82099034h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82099034h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099034( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099034) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099034);
		  /* 82099034h */ case    0:  		/* lis R11, -16384 */
		/* 82099034h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC000);
		/* 82099034h case    0:*/		return 0x82099038;
		  /* 82099038h */ case    1:  		/* ori R11, R11, 23 */
		/* 82099038h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x17);
		/* 82099038h case    1:*/		return 0x8209903C;
		  /* 8209903Ch */ case    2:  		/* cmplw CR6, R3, R11 */
		/* 8209903Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8209903Ch case    2:*/		return 0x82099040;
		  /* 82099040h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 82099040h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8209904C;  }
		/* 82099040h case    3:*/		return 0x82099044;
		  /* 82099044h */ case    4:  		/* li R3, 8 */
		/* 82099044h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x8);
		/* 82099044h case    4:*/		return 0x82099048;
		  /* 82099048h */ case    5:  		/* bl -59728 */
		/* 82099048h case    5:*/		regs.LR = 0x8209904C; return 0x8208A6F8;
		/* 82099048h case    5:*/		return 0x8209904C;
	}
	return 0x8209904C;
} // Block from 82099034h-8209904Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209904Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209904C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209904C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209904C);
		  /* 8209904Ch */ case    0:  		/* li R3, 0 */
		/* 8209904Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209904Ch case    0:*/		return 0x82099050;
	}
	return 0x82099050;
} // Block from 8209904Ch-82099050h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82099050h
// Function 'calloc'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099050);
		  /* 82099050h */ case    0:  		/* stw R3, <#[R31 + 80]> */
		/* 82099050h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 82099050h case    0:*/		return 0x82099054;
	}
	return 0x82099054;
} // Block from 82099050h-82099054h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82099054h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099054( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099054) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099054);
		  /* 82099054h */ case    0:  		/* addi R1, R31, 112 */
		/* 82099054h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0x70);
		/* 82099054h case    0:*/		return 0x82099058;
		  /* 82099058h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82099058h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82099058h case    1:*/		return 0x8209905C;
		  /* 8209905Ch */ case    2:  		/* mtspr LR, R12 */
		/* 8209905Ch case    2:*/		regs.LR = regs.R12;
		/* 8209905Ch case    2:*/		return 0x82099060;
		  /* 82099060h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82099060h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82099060h case    3:*/		return 0x82099064;
		  /* 82099064h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82099064h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82099064h case    4:*/		return 0x82099068;
	}
	return 0x82099068;
} // Block from 82099054h-82099068h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82099068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099068);
		  /* 82099068h */ case    0:  		/* lis R11, -16384 */
		/* 82099068h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC000);
		/* 82099068h case    0:*/		return 0x8209906C;
		  /* 8209906Ch */ case    1:  		/* ori R11, R11, 23 */
		/* 8209906Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x17);
		/* 8209906Ch case    1:*/		return 0x82099070;
		  /* 82099070h */ case    2:  		/* lwz R10, <#[R3]> */
		/* 82099070h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82099070h case    2:*/		return 0x82099074;
		  /* 82099074h */ case    3:  		/* lwz R10, <#[R10]> */
		/* 82099074h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 82099074h case    3:*/		return 0x82099078;
		  /* 82099078h */ case    4:  		/* subf R11, R10, R11 */
		/* 82099078h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82099078h case    4:*/		return 0x8209907C;
		  /* 8209907Ch */ case    5:  		/* cntlzw R11, R11 */
		/* 8209907Ch case    5:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8209907Ch case    5:*/		return 0x82099080;
		  /* 82099080h */ case    6:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 82099080h case    6:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 82099080h case    6:*/		return 0x82099084;
		  /* 82099084h */ case    7:  		/* nop */
		/* 82099084h case    7:*/		cpu::op::nop();
		/* 82099084h case    7:*/		return 0x82099088;
		  /* 82099088h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82099088h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82099088h case    8:*/		return 0x8209908C;
	}
	return 0x8209908C;
} // Block from 82099068h-8209908Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209908Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209908C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209908C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209908C);
		  /* 8209908Ch */ case    0:  		/* nop */
		/* 8209908Ch case    0:*/		cpu::op::nop();
		/* 8209908Ch case    0:*/		return 0x82099090;
	}
	return 0x82099090;
} // Block from 8209908Ch-82099090h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82099090h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099090);
		  /* 82099090h */ case    0:  		/* mfspr R12, LR */
		/* 82099090h case    0:*/		regs.R12 = regs.LR;
		/* 82099090h case    0:*/		return 0x82099094;
		  /* 82099094h */ case    1:  		/* bl -32316 */
		/* 82099094h case    1:*/		regs.LR = 0x82099098; return 0x82091258;
		/* 82099094h case    1:*/		return 0x82099098;
		  /* 82099098h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82099098h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82099098h case    2:*/		return 0x8209909C;
		  /* 8209909Ch */ case    3:  		/* lis R10, -32217 */
		/* 8209909Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 8209909Ch case    3:*/		return 0x820990A0;
		  /* 820990A0h */ case    4:  		/* lis R11, -32215 */
		/* 820990A0h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 820990A0h case    4:*/		return 0x820990A4;
		  /* 820990A4h */ case    5:  		/* addi R30, R10, 7984 */
		/* 820990A4h case    5:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R10,0x1F30);
		/* 820990A4h case    5:*/		return 0x820990A8;
		  /* 820990A8h */ case    6:  		/* addi R28, R11, -30680 */
		/* 820990A8h case    6:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0xFFFF8828);
		/* 820990A8h case    6:*/		return 0x820990AC;
		  /* 820990ACh */ case    7:  		/* mr R31, R30 */
		/* 820990ACh case    7:*/		regs.R31 = regs.R30;
		/* 820990ACh case    7:*/		return 0x820990B0;
		  /* 820990B0h */ case    8:  		/* li R29, 0 */
		/* 820990B0h case    8:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820990B0h case    8:*/		return 0x820990B4;
		  /* 820990B4h */ case    9:  		/* lwz R11, <#[R31 + 4]> */
		/* 820990B4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820990B4h case    9:*/		return 0x820990B8;
	}
	return 0x820990B8;
} // Block from 82099090h-820990B8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820990B8h
// Function '_mtxthreadnotification'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820990B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820990B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820990B8);
		  /* 820990B8h */ case    0:  		/* cmpwi CR6, R11, 1 */
		/* 820990B8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820990B8h case    0:*/		return 0x820990BC;
		  /* 820990BCh */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 820990BCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820990DC;  }
		/* 820990BCh case    1:*/		return 0x820990C0;
		  /* 820990C0h */ case    2:  		/* stw R28, <#[R31]> */
		/* 820990C0h case    2:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 820990C0h case    2:*/		return 0x820990C4;
		  /* 820990C4h */ case    3:  		/* rlwinm R3, R28, 0, 0, 31 */
		/* 820990C4h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R28);
		/* 820990C4h case    3:*/		return 0x820990C8;
	}
	return 0x820990C8;
} // Block from 820990B8h-820990C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820990C8h
// Function '_forcdecpt_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820990C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820990C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820990C8);
		  /* 820990C8h */ case    0:  		/* li R4, 4000 */
		/* 820990C8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xFA0);
		/* 820990C8h case    0:*/		return 0x820990CC;
		  /* 820990CCh */ case    1:  		/* addi R28, R28, 28 */
		/* 820990CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1C);
		/* 820990CCh case    1:*/		return 0x820990D0;
		  /* 820990D0h */ case    2:  		/* bl -216 */
		/* 820990D0h case    2:*/		regs.LR = 0x820990D4; return 0x82098FF8;
		/* 820990D0h case    2:*/		return 0x820990D4;
		  /* 820990D4h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820990D4h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820990D4h case    3:*/		return 0x820990D8;
		  /* 820990D8h */ case    4:  		/* bc 12, CR0_EQ, 36 */
		/* 820990D8h case    4:*/		if ( regs.CR[0].eq ) { return 0x820990FC;  }
		/* 820990D8h case    4:*/		return 0x820990DC;
	}
	return 0x820990DC;
} // Block from 820990C8h-820990DCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820990DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820990DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820990DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820990DC);
		  /* 820990DCh */ case    0:  		/* addi R31, R31, 8 */
		/* 820990DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x8);
		/* 820990DCh case    0:*/		return 0x820990E0;
		  /* 820990E0h */ case    1:  		/* addi R11, R30, 288 */
		/* 820990E0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x120);
		/* 820990E0h case    1:*/		return 0x820990E4;
		  /* 820990E4h */ case    2:  		/* addi R29, R29, 1 */
		/* 820990E4h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820990E4h case    2:*/		return 0x820990E8;
		  /* 820990E8h */ case    3:  		/* cmpw CR6, R31, R11 */
		/* 820990E8h case    3:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R11);
		/* 820990E8h case    3:*/		return 0x820990EC;
		  /* 820990ECh */ case    4:  		/* bc 12, CR6_LT, -56 */
		/* 820990ECh case    4:*/		if ( regs.CR[6].lt ) { return 0x820990B4;  }
		/* 820990ECh case    4:*/		return 0x820990F0;
		  /* 820990F0h */ case    5:  		/* li R3, 1 */
		/* 820990F0h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820990F0h case    5:*/		return 0x820990F4;
		  /* 820990F4h */ case    6:  		/* addi R1, R1, 128 */
		/* 820990F4h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820990F4h case    6:*/		return 0x820990F8;
		  /* 820990F8h */ case    7:  		/* b -32336 */
		/* 820990F8h case    7:*/		return 0x820912A8;
		/* 820990F8h case    7:*/		return 0x820990FC;
	}
	return 0x820990FC;
} // Block from 820990DCh-820990FCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 820990FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820990FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820990FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820990FC);
		  /* 820990FCh */ case    0:  		/* rlwinm R11, R29, 3, 0, 28 */
		/* 820990FCh case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R29);
		/* 820990FCh case    0:*/		return 0x82099100;
		  /* 82099100h */ case    1:  		/* li R10, 0 */
		/* 82099100h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82099100h case    1:*/		return 0x82099104;
		  /* 82099104h */ case    2:  		/* li R3, 0 */
		/* 82099104h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82099104h case    2:*/		return 0x82099108;
		  /* 82099108h */ case    3:  		/* stwx R10, <#[R11 + R30]> */
		/* 82099108h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82099108h case    3:*/		return 0x8209910C;
		  /* 8209910Ch */ case    4:  		/* b -24 */
		/* 8209910Ch case    4:*/		return 0x820990F4;
		/* 8209910Ch case    4:*/		return 0x82099110;
		  /* 82099110h */ case    5:  		/* lwz R17, <#[R6 - 11576]> */
		/* 82099110h case    5:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 82099110h case    5:*/		return 0x82099114;
		  /* 82099114h */ case    6:  		/* lwz R16, <#[R4 - 15376]> */
		/* 82099114h case    6:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC3F0) );
		/* 82099114h case    6:*/		return 0x82099118;
	}
	return 0x82099118;
} // Block from 820990FCh-82099118h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82099118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099118);
		  /* 82099118h */ case    0:  		/* mfspr R12, LR */
		/* 82099118h case    0:*/		regs.R12 = regs.LR;
		/* 82099118h case    0:*/		return 0x8209911C;
		  /* 8209911Ch */ case    1:  		/* bl -32452 */
		/* 8209911Ch case    1:*/		regs.LR = 0x82099120; return 0x82091258;
		/* 8209911Ch case    1:*/		return 0x82099120;
		  /* 82099120h */ case    2:  		/* addi R31, R1, -128 */
		/* 82099120h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFF80);
		/* 82099120h case    2:*/		return 0x82099124;
		  /* 82099124h */ case    3:  		/* stwu R1, <#[R1 - 128]> */
		/* 82099124h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82099124h case    3:*/		return 0x82099128;
		  /* 82099128h */ case    4:  		/* mr R30, R3 */
		/* 82099128h case    4:*/		regs.R30 = regs.R3;
		/* 82099128h case    4:*/		return 0x8209912C;
		  /* 8209912Ch */ case    5:  		/* li R11, 1 */
		/* 8209912Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8209912Ch case    5:*/		return 0x82099130;
		  /* 82099130h */ case    6:  		/* stw R11, <#[R31 + 80]> */
		/* 82099130h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 82099130h case    6:*/		return 0x82099134;
		  /* 82099134h */ case    7:  		/* bl -46084 */
		/* 82099134h case    7:*/		regs.LR = 0x82099138; return 0x8208DD30;
		/* 82099134h case    7:*/		return 0x82099138;
		  /* 82099138h */ case    8:  		/* cmplwi CR0, R3, 0 */
		/* 82099138h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82099138h case    8:*/		return 0x8209913C;
		  /* 8209913Ch */ case    9:  		/* bc 4, CR0_EQ, 24 */
		/* 8209913Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x82099154;  }
		/* 8209913Ch case    9:*/		return 0x82099140;
		  /* 82099140h */ case   10:  		/* bl -17624 */
		/* 82099140h case   10:*/		regs.LR = 0x82099144; return 0x82094C68;
		/* 82099140h case   10:*/		return 0x82099144;
		  /* 82099144h */ case   11:  		/* li R3, 30 */
		/* 82099144h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x1E);
		/* 82099144h case   11:*/		return 0x82099148;
		  /* 82099148h */ case   12:  		/* bl -17680 */
		/* 82099148h case   12:*/		regs.LR = 0x8209914C; return 0x82094C38;
		/* 82099148h case   12:*/		return 0x8209914C;
		  /* 8209914Ch */ case   13:  		/* li R3, 255 */
		/* 8209914Ch case   13:*/		cpu::op::li<0>(regs,&regs.R3,0xFF);
		/* 8209914Ch case   13:*/		return 0x82099150;
		  /* 82099150h */ case   14:  		/* bl -25600 */
		/* 82099150h case   14:*/		regs.LR = 0x82099154; return 0x82092D50;
		/* 82099150h case   14:*/		return 0x82099154;
	}
	return 0x82099154;
} // Block from 82099118h-82099154h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82099154h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099154( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099154) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099154);
		  /* 82099154h */ case    0:  		/* lis R11, -32217 */
		/* 82099154h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82099154h case    0:*/		return 0x82099158;
		  /* 82099158h */ case    1:  		/* rlwinm R29, R30, 3, 0, 28 */
		/* 82099158h case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R29,regs.R30);
		/* 82099158h case    1:*/		return 0x8209915C;
		  /* 8209915Ch */ case    2:  		/* addi R30, R11, 7984 */
		/* 8209915Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x1F30);
		/* 8209915Ch case    2:*/		return 0x82099160;
		  /* 82099160h */ case    3:  		/* lwzx R11, <#[R29 + R30]> */
		/* 82099160h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R30 + 0x00000000) );
		/* 82099160h case    3:*/		return 0x82099164;
		  /* 82099164h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82099164h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82099164h case    4:*/		return 0x82099168;
	}
	return 0x82099168;
} // Block from 82099154h-82099168h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82099168h
// Function '_cropzeros_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099168);
		  /* 82099168h */ case    0:  		/* bc 12, CR6_EQ, 12 */
		/* 82099168h case    0:*/		if ( regs.CR[6].eq ) { return 0x82099174;  }
		/* 82099168h case    0:*/		return 0x8209916C;
		  /* 8209916Ch */ case    1:  		/* li R3, 1 */
		/* 8209916Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8209916Ch case    1:*/		return 0x82099170;
		  /* 82099170h */ case    2:  		/* b 148 */
		/* 82099170h case    2:*/		return 0x82099204;
		/* 82099170h case    2:*/		return 0x82099174;
	}
	return 0x82099174;
} // Block from 82099168h-82099174h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82099174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099174);
		  /* 82099174h */ case    0:  		/* li R3, 28 */
		/* 82099174h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1C);
		/* 82099174h case    0:*/		return 0x82099178;
		  /* 82099178h */ case    1:  		/* bl -22768 */
		/* 82099178h case    1:*/		regs.LR = 0x8209917C; return 0x82093888;
		/* 82099178h case    1:*/		return 0x8209917C;
		  /* 8209917Ch */ case    2:  		/* or. R28, R3, R3 */
		/* 8209917Ch case    2:*/		cpu::op::or<1>(regs,&regs.R28,regs.R3,regs.R3);
		/* 8209917Ch case    2:*/		return 0x82099180;
		  /* 82099180h */ case    3:  		/* bc 4, CR0_EQ, 28 */
		/* 82099180h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8209919C;  }
		/* 82099180h case    3:*/		return 0x82099184;
		  /* 82099184h */ case    4:  		/* bl -17020 */
		/* 82099184h case    4:*/		regs.LR = 0x82099188; return 0x82094F08;
		/* 82099184h case    4:*/		return 0x82099188;
		  /* 82099188h */ case    5:  		/* mr R11, R3 */
		/* 82099188h case    5:*/		regs.R11 = regs.R3;
		/* 82099188h case    5:*/		return 0x8209918C;
		  /* 8209918Ch */ case    6:  		/* li R10, 12 */
		/* 8209918Ch case    6:*/		cpu::op::li<0>(regs,&regs.R10,0xC);
		/* 8209918Ch case    6:*/		return 0x82099190;
		  /* 82099190h */ case    7:  		/* li R3, 0 */
		/* 82099190h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82099190h case    7:*/		return 0x82099194;
		  /* 82099194h */ case    8:  		/* stw R10, <#[R11]> */
		/* 82099194h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82099194h case    8:*/		return 0x82099198;
		  /* 82099198h */ case    9:  		/* b 108 */
		/* 82099198h case    9:*/		return 0x82099204;
		/* 82099198h case    9:*/		return 0x8209919C;
	}
	return 0x8209919C;
} // Block from 82099174h-8209919Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209919Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209919C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209919C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209919C);
		  /* 8209919Ch */ case    0:  		/* li R3, 10 */
		/* 8209919Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xA);
		/* 8209919Ch case    0:*/		return 0x820991A0;
		  /* 820991A0h */ case    1:  		/* bl 184 */
		/* 820991A0h case    1:*/		regs.LR = 0x820991A4; return 0x82099258;
		/* 820991A0h case    1:*/		return 0x820991A4;
		  /* 820991A4h */ case    2:  		/* nop */
		/* 820991A4h case    2:*/		cpu::op::nop();
		/* 820991A4h case    2:*/		return 0x820991A8;
	}
	return 0x820991A8;
} // Block from 8209919Ch-820991A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820991A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820991A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820991A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820991A8);
		  /* 820991A8h */ case    0:  		/* lwzx R11, <#[R29 + R30]> */
		/* 820991A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R30 + 0x00000000) );
		/* 820991A8h case    0:*/		return 0x820991AC;
		  /* 820991ACh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820991ACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820991ACh case    1:*/		return 0x820991B0;
		  /* 820991B0h */ case    2:  		/* mr R3, R28 */
		/* 820991B0h case    2:*/		regs.R3 = regs.R28;
		/* 820991B0h case    2:*/		return 0x820991B4;
		  /* 820991B4h */ case    3:  		/* bc 4, CR6_EQ, 60 */
		/* 820991B4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820991F0;  }
		/* 820991B4h case    3:*/		return 0x820991B8;
		  /* 820991B8h */ case    4:  		/* li R4, 4000 */
		/* 820991B8h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0xFA0);
		/* 820991B8h case    4:*/		return 0x820991BC;
		  /* 820991BCh */ case    5:  		/* bl -452 */
		/* 820991BCh case    5:*/		regs.LR = 0x820991C0; return 0x82098FF8;
		/* 820991BCh case    5:*/		return 0x820991C0;
		  /* 820991C0h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820991C0h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820991C0h case    6:*/		return 0x820991C4;
		  /* 820991C4h */ case    7:  		/* bc 4, CR0_EQ, 36 */
		/* 820991C4h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820991E8;  }
		/* 820991C4h case    7:*/		return 0x820991C8;
		  /* 820991C8h */ case    8:  		/* mr R3, R28 */
		/* 820991C8h case    8:*/		regs.R3 = regs.R28;
		/* 820991C8h case    8:*/		return 0x820991CC;
		  /* 820991CCh */ case    9:  		/* bl -22948 */
		/* 820991CCh case    9:*/		regs.LR = 0x820991D0; return 0x82093828;
		/* 820991CCh case    9:*/		return 0x820991D0;
		  /* 820991D0h */ case   10:  		/* bl -17096 */
		/* 820991D0h case   10:*/		regs.LR = 0x820991D4; return 0x82094F08;
		/* 820991D0h case   10:*/		return 0x820991D4;
		  /* 820991D4h */ case   11:  		/* li R11, 12 */
		/* 820991D4h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0xC);
		/* 820991D4h case   11:*/		return 0x820991D8;
		  /* 820991D8h */ case   12:  		/* li R10, 0 */
		/* 820991D8h case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820991D8h case   12:*/		return 0x820991DC;
		  /* 820991DCh */ case   13:  		/* stw R11, <#[R3]> */
		/* 820991DCh case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820991DCh case   13:*/		return 0x820991E0;
		  /* 820991E0h */ case   14:  		/* stw R10, <#[R31 + 80]> */
		/* 820991E0h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 820991E0h case   14:*/		return 0x820991E4;
		  /* 820991E4h */ case   15:  		/* b 16 */
		/* 820991E4h case   15:*/		return 0x820991F4;
		/* 820991E4h case   15:*/		return 0x820991E8;
	}
	return 0x820991E8;
} // Block from 820991A8h-820991E8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820991E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820991E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820991E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820991E8);
		  /* 820991E8h */ case    0:  		/* stwx R28, <#[R29 + R30]> */
		/* 820991E8h case    0:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R29 + regs.R30 + 0x00000000) );
		/* 820991E8h case    0:*/		return 0x820991EC;
		  /* 820991ECh */ case    1:  		/* b 8 */
		/* 820991ECh case    1:*/		return 0x820991F4;
		/* 820991ECh case    1:*/		return 0x820991F0;
	}
	return 0x820991F0;
} // Block from 820991E8h-820991F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820991F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820991F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820991F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820991F0);
		  /* 820991F0h */ case    0:  		/* bl -22984 */
		/* 820991F0h case    0:*/		regs.LR = 0x820991F4; return 0x82093828;
		/* 820991F0h case    0:*/		return 0x820991F4;
	}
	return 0x820991F4;
} // Block from 820991F0h-820991F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820991F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820991F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820991F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820991F4);
		  /* 820991F4h */ case    0:  		/* nop */
		/* 820991F4h case    0:*/		cpu::op::nop();
		/* 820991F4h case    0:*/		return 0x820991F8;
		  /* 820991F8h */ case    1:  		/* addi R12, R31, 128 */
		/* 820991F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R31,0x80);
		/* 820991F8h case    1:*/		return 0x820991FC;
		  /* 820991FCh */ case    2:  		/* bl 44 */
		/* 820991FCh case    2:*/		regs.LR = 0x82099200; return 0x82099228;
		/* 820991FCh case    2:*/		return 0x82099200;
		  /* 82099200h */ case    3:  		/* lwz R3, <#[R31 + 80]> */
		/* 82099200h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 82099200h case    3:*/		return 0x82099204;
	}
	return 0x82099204;
} // Block from 820991F4h-82099204h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82099204h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099204( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099204) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099204);
		  /* 82099204h */ case    0:  		/* addi R1, R31, 128 */
		/* 82099204h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0x80);
		/* 82099204h case    0:*/		return 0x82099208;
		  /* 82099208h */ case    1:  		/* b -32608 */
		/* 82099208h case    1:*/		return 0x820912A8;
		/* 82099208h case    1:*/		return 0x8209920C;
	}
	return 0x8209920C;
} // Block from 82099204h-8209920Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209920Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209920C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209920C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209920C);
		  /* 8209920Ch */ case    0:  		/* std R30, <#[R1 - 8]> */
		/* 8209920Ch case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209920Ch case    0:*/		return 0x82099210;
		  /* 82099210h */ case    1:  		/* mfspr R12, LR */
		/* 82099210h case    1:*/		regs.R12 = regs.LR;
		/* 82099210h case    1:*/		return 0x82099214;
		  /* 82099214h */ case    2:  		/* stw R12, <#[R1 - 16]> */
		/* 82099214h case    2:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82099214h case    2:*/		return 0x82099218;
	}
	return 0x82099218;
} // Block from 8209920Ch-82099218h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82099218h
// Function '_positive'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099218);
		  /* 82099218h */ case    0:  		/* stwu R1, <#[R1 - 96]> */
		/* 82099218h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82099218h case    0:*/		return 0x8209921C;
		  /* 8209921Ch */ case    1:  		/* lis R11, -32217 */
		/* 8209921Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 8209921Ch case    1:*/		return 0x82099220;
		  /* 82099220h */ case    2:  		/* addi R30, R11, 7984 */
		/* 82099220h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x1F30);
		/* 82099220h case    2:*/		return 0x82099224;
		  /* 82099224h */ case    3:  		/* b 20 */
		/* 82099224h case    3:*/		return 0x82099238;
		/* 82099224h case    3:*/		return 0x82099228;
	}
	return 0x82099228;
} // Block from 82099218h-82099228h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82099228h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099228);
		  /* 82099228h */ case    0:  		/* std R30, <#[R1 - 8]> */
		/* 82099228h case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82099228h case    0:*/		return 0x8209922C;
		  /* 8209922Ch */ case    1:  		/* mfspr R12, LR */
		/* 8209922Ch case    1:*/		regs.R12 = regs.LR;
		/* 8209922Ch case    1:*/		return 0x82099230;
		  /* 82099230h */ case    2:  		/* stw R12, <#[R1 - 16]> */
		/* 82099230h case    2:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82099230h case    2:*/		return 0x82099234;
		  /* 82099234h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82099234h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82099234h case    3:*/		return 0x82099238;
	}
	return 0x82099238;
} // Block from 82099228h-82099238h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82099238h
// Function '_fassign_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099238);
		  /* 82099238h */ case    0:  		/* lwz R3, <#[R30 + 80]> */
		/* 82099238h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000050) );
		/* 82099238h case    0:*/		return 0x8209923C;
		  /* 8209923Ch */ case    1:  		/* bl 1916396 */
		/* 8209923Ch case    1:*/		regs.LR = 0x82099240; return 0x8226D028;
		/* 8209923Ch case    1:*/		return 0x82099240;
		  /* 82099240h */ case    2:  		/* lwz R1, <#[R1]> */
		/* 82099240h case    2:*/		cpu::mem::load32z( regs, &regs.R1, (uint32)(regs.R1 + 0x00000000) );
		/* 82099240h case    2:*/		return 0x82099244;
		  /* 82099244h */ case    3:  		/* ld R30, <#[R1 - 8]> */
		/* 82099244h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82099244h case    3:*/		return 0x82099248;
		  /* 82099248h */ case    4:  		/* lwz R12, <#[R1 - 16]> */
		/* 82099248h case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82099248h case    4:*/		return 0x8209924C;
		  /* 8209924Ch */ case    5:  		/* mtspr LR, R12 */
		/* 8209924Ch case    5:*/		regs.LR = regs.R12;
		/* 8209924Ch case    5:*/		return 0x82099250;
		  /* 82099250h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82099250h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82099250h case    6:*/		return 0x82099254;
	}
	return 0x82099254;
} // Block from 82099238h-82099254h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82099254h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099254);
		  /* 82099254h */ case    0:  		/* nop */
		/* 82099254h case    0:*/		cpu::op::nop();
		/* 82099254h case    0:*/		return 0x82099258;
	}
	return 0x82099258;
} // Block from 82099254h-82099258h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82099258h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099258);
		  /* 82099258h */ case    0:  		/* mfspr R12, LR */
		/* 82099258h case    0:*/		regs.R12 = regs.LR;
		/* 82099258h case    0:*/		return 0x8209925C;
		  /* 8209925Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209925Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209925Ch case    1:*/		return 0x82099260;
		  /* 82099260h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82099260h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82099260h case    2:*/		return 0x82099264;
		  /* 82099264h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82099264h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82099264h case    3:*/		return 0x82099268;
		  /* 82099268h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82099268h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82099268h case    4:*/		return 0x8209926C;
		  /* 8209926Ch */ case    5:  		/* lis R11, -32217 */
		/* 8209926Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 8209926Ch case    5:*/		return 0x82099270;
		  /* 82099270h */ case    6:  		/* rlwinm R31, R3, 3, 0, 28 */
		/* 82099270h case    6:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R31,regs.R3);
		/* 82099270h case    6:*/		return 0x82099274;
		  /* 82099274h */ case    7:  		/* addi R30, R11, 7984 */
		/* 82099274h case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x1F30);
		/* 82099274h case    7:*/		return 0x82099278;
		  /* 82099278h */ case    8:  		/* lwzx R11, <#[R31 + R30]> */
		/* 82099278h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R30 + 0x00000000) );
		/* 82099278h case    8:*/		return 0x8209927C;
		  /* 8209927Ch */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 8209927Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209927Ch case    9:*/		return 0x82099280;
		  /* 82099280h */ case   10:  		/* bc 4, CR6_EQ, 24 */
		/* 82099280h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82099298;  }
		/* 82099280h case   10:*/		return 0x82099284;
		  /* 82099284h */ case   11:  		/* bl -364 */
		/* 82099284h case   11:*/		regs.LR = 0x82099288; return 0x82099118;
		/* 82099284h case   11:*/		return 0x82099288;
		  /* 82099288h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 82099288h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82099288h case   12:*/		return 0x8209928C;
		  /* 8209928Ch */ case   13:  		/* bc 4, CR0_EQ, 12 */
		/* 8209928Ch case   13:*/		if ( !regs.CR[0].eq ) { return 0x82099298;  }
		/* 8209928Ch case   13:*/		return 0x82099290;
		  /* 82099290h */ case   14:  		/* li R3, 17 */
		/* 82099290h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x11);
		/* 82099290h case   14:*/		return 0x82099294;
		  /* 82099294h */ case   15:  		/* bl -25236 */
		/* 82099294h case   15:*/		regs.LR = 0x82099298; return 0x82093000;
		/* 82099294h case   15:*/		return 0x82099298;
	}
	return 0x82099298;
} // Block from 82099258h-82099298h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82099298h
// Function '_fassign'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099298);
		  /* 82099298h */ case    0:  		/* lwzx R3, <#[R31 + R30]> */
		/* 82099298h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + regs.R30 + 0x00000000) );
		/* 82099298h case    0:*/		return 0x8209929C;
		  /* 8209929Ch */ case    1:  		/* bl 1916316 */
		/* 8209929Ch case    1:*/		regs.LR = 0x820992A0; return 0x8226D038;
		/* 8209929Ch case    1:*/		return 0x820992A0;
	}
	return 0x820992A0;
} // Block from 82099298h-820992A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820992A0h
// Function '_forcdecpt'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820992A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820992A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820992A0);
		  /* 820992A0h */ case    0:  		/* addi R1, R1, 112 */
		/* 820992A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820992A0h case    0:*/		return 0x820992A4;
		  /* 820992A4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820992A4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820992A4h case    1:*/		return 0x820992A8;
	}
	return 0x820992A8;
} // Block from 820992A0h-820992A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820992A8h
// Function '_cropzeros'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820992A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820992A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820992A8);
		  /* 820992A8h */ case    0:  		/* mtspr LR, R12 */
		/* 820992A8h case    0:*/		regs.LR = regs.R12;
		/* 820992A8h case    0:*/		return 0x820992AC;
		  /* 820992ACh */ case    1:  		/* ld R30, <#[R1 - 24]> */
		/* 820992ACh case    1:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820992ACh case    1:*/		return 0x820992B0;
	}
	return 0x820992B0;
} // Block from 820992A8h-820992B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820992B0h
// Function '_cftoe2_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820992B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820992B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820992B0);
		  /* 820992B0h */ case    0:  		/* ld R31, <#[R1 - 16]> */
		/* 820992B0h case    0:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820992B0h case    0:*/		return 0x820992B4;
		  /* 820992B4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820992B4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820992B4h case    1:*/		return 0x820992B8;
	}
	return 0x820992B8;
} // Block from 820992B0h-820992B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820992B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820992B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820992B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820992B8);
		  /* 820992B8h */ case    0:  		/* lwz R17, <#[R6 - 11576]> */
		/* 820992B8h case    0:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 820992B8h case    0:*/		return 0x820992BC;
		  /* 820992BCh */ case    1:  		/* lwz R16, <#[R4 - 15352]> */
		/* 820992BCh case    1:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC408) );
		/* 820992BCh case    1:*/		return 0x820992C0;
	}
	return 0x820992C0;
} // Block from 820992B8h-820992C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820992C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820992C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820992C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820992C0);
		  /* 820992C0h */ case    0:  		/* mfspr R12, LR */
		/* 820992C0h case    0:*/		regs.R12 = regs.LR;
		/* 820992C0h case    0:*/		return 0x820992C4;
		  /* 820992C4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820992C4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820992C4h case    1:*/		return 0x820992C8;
		  /* 820992C8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820992C8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820992C8h case    2:*/		return 0x820992CC;
		  /* 820992CCh */ case    3:  		/* addi R31, R1, -96 */
		/* 820992CCh case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFFA0);
		/* 820992CCh case    3:*/		return 0x820992D0;
		  /* 820992D0h */ case    4:  		/* stwu R1, <#[R1 - 96]> */
		/* 820992D0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820992D0h case    4:*/		return 0x820992D4;
		  /* 820992D4h */ case    5:  		/* bl -24964 */
		/* 820992D4h case    5:*/		regs.LR = 0x820992D8; return 0x82093150;
		/* 820992D4h case    5:*/		return 0x820992D8;
		  /* 820992D8h */ case    6:  		/* lwz R11, <#[R3 + 108]> */
		/* 820992D8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000006C) );
		/* 820992D8h case    6:*/		return 0x820992DC;
		  /* 820992DCh */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 820992DCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820992DCh case    7:*/		return 0x820992E0;
		  /* 820992E0h */ case    8:  		/* bc 12, CR6_EQ, 32 */
		/* 820992E0h case    8:*/		if ( regs.CR[6].eq ) { return 0x82099300;  }
		/* 820992E0h case    8:*/		return 0x820992E4;
		  /* 820992E4h */ case    9:  		/* nop */
		/* 820992E4h case    9:*/		cpu::op::nop();
		/* 820992E4h case    9:*/		return 0x820992E8;
		  /* 820992E8h */ case   10:  		/* nop */
		/* 820992E8h case   10:*/		cpu::op::nop();
		/* 820992E8h case   10:*/		return 0x820992EC;
	}
	return 0x820992EC;
} // Block from 820992C0h-820992ECh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820992ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820992EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820992EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820992EC);
		  /* 820992ECh */ case    0:  		/* mtspr CTR, R11 */
		/* 820992ECh case    0:*/		regs.CTR = regs.R11;
		/* 820992ECh case    0:*/		return 0x820992F0;
		  /* 820992F0h */ case    1:  		/* bcctrl 20, CR0_LT */
		/* 820992F0h case    1:*/		if ( 1 ) { regs.LR = 0x820992F4; return (uint32)regs.CTR; }
		/* 820992F0h case    1:*/		return 0x820992F4;
	}
	return 0x820992F4;
} // Block from 820992ECh-820992F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820992F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820992F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820992F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820992F4);
		  /* 820992F4h */ case    0:  		/* nop */
		/* 820992F4h case    0:*/		cpu::op::nop();
		/* 820992F4h case    0:*/		return 0x820992F8;
		  /* 820992F8h */ case    1:  		/* nop */
		/* 820992F8h case    1:*/		cpu::op::nop();
		/* 820992F8h case    1:*/		return 0x820992FC;
		  /* 820992FCh */ case    2:  		/* nop */
		/* 820992FCh case    2:*/		cpu::op::nop();
		/* 820992FCh case    2:*/		return 0x82099300;
	}
	return 0x82099300;
} // Block from 820992F4h-82099300h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82099300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099300);
		  /* 82099300h */ case    0:  		/* lis R3, -16384 */
		/* 82099300h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFFC000);
		/* 82099300h case    0:*/		return 0x82099304;
		  /* 82099304h */ case    1:  		/* ori R3, R3, 324 */
		/* 82099304h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x144);
		/* 82099304h case    1:*/		return 0x82099308;
		  /* 82099308h */ case    2:  		/* bl 1916672 */
		/* 82099308h case    2:*/		regs.LR = 0x8209930C; return 0x8226D208;
		/* 82099308h case    2:*/		return 0x8209930C;
	}
	return 0x8209930C;
} // Block from 82099300h-8209930Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209930Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209930C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209930C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209930C);
		  /* 8209930Ch */ case    0:  		/* li R3, 1 */
		/* 8209930Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8209930Ch case    0:*/		return 0x82099310;
		  /* 82099310h */ case    1:  		/* nop */
		/* 82099310h case    1:*/		cpu::op::nop();
		/* 82099310h case    1:*/		return 0x82099314;
		  /* 82099314h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82099314h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82099314h case    2:*/		return 0x82099318;
	}
	return 0x82099318;
} // Block from 8209930Ch-82099318h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82099318h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099318);
		  /* 82099318h */ case    0:  		/* lis R11, -32246 */
		/* 82099318h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820A);
		/* 82099318h case    0:*/		return 0x8209931C;
		  /* 8209931Ch */ case    1:  		/* lis R10, -32215 */
		/* 8209931Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 8209931Ch case    1:*/		return 0x82099320;
		  /* 82099320h */ case    2:  		/* addi R11, R11, -27968 */
		/* 82099320h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF92C0);
		/* 82099320h case    2:*/		return 0x82099324;
		  /* 82099324h */ case    3:  		/* stw R11, <#[R10 - 30288]> */
		/* 82099324h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0xFFFF89B0) );
		/* 82099324h case    3:*/		return 0x82099328;
		  /* 82099328h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82099328h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82099328h case    4:*/		return 0x8209932C;
	}
	return 0x8209932C;
} // Block from 82099318h-8209932Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209932Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209932C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209932C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209932C);
		  /* 8209932Ch */ case    0:  		/* nop */
		/* 8209932Ch case    0:*/		cpu::op::nop();
		/* 8209932Ch case    0:*/		return 0x82099330;
	}
	return 0x82099330;
} // Block from 8209932Ch-82099330h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82099330h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099330);
		  /* 82099330h */ case    0:  		/* lis R11, -32215 */
		/* 82099330h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82099330h case    0:*/		return 0x82099334;
		  /* 82099334h */ case    1:  		/* stw R3, <#[R11 - 30284]> */
		/* 82099334h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0xFFFF89B4) );
		/* 82099334h case    1:*/		return 0x82099338;
		  /* 82099338h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82099338h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82099338h case    2:*/		return 0x8209933C;
	}
	return 0x8209933C;
} // Block from 82099330h-8209933Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209933Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209933C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209933C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209933C);
		  /* 8209933Ch */ case    0:  		/* nop */
		/* 8209933Ch case    0:*/		cpu::op::nop();
		/* 8209933Ch case    0:*/		return 0x82099340;
	}
	return 0x82099340;
} // Block from 8209933Ch-82099340h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82099340h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099340);
		  /* 82099340h */ case    0:  		/* mfspr R12, LR */
		/* 82099340h case    0:*/		regs.R12 = regs.LR;
		/* 82099340h case    0:*/		return 0x82099344;
		  /* 82099344h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82099344h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82099344h case    1:*/		return 0x82099348;
		  /* 82099348h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82099348h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82099348h case    2:*/		return 0x8209934C;
		  /* 8209934Ch */ case    3:  		/* lis R11, -32215 */
		/* 8209934Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8209934Ch case    3:*/		return 0x82099350;
		  /* 82099350h */ case    4:  		/* lwz R11, <#[R11 - 30284]> */
		/* 82099350h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFF89B4) );
		/* 82099350h case    4:*/		return 0x82099354;
		  /* 82099354h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 82099354h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82099354h case    5:*/		return 0x82099358;
		  /* 82099358h */ case    6:  		/* bc 12, CR0_EQ, 24 */
		/* 82099358h case    6:*/		if ( regs.CR[0].eq ) { return 0x82099370;  }
		/* 82099358h case    6:*/		return 0x8209935C;
		  /* 8209935Ch */ case    7:  		/* mtspr CTR, R11 */
		/* 8209935Ch case    7:*/		regs.CTR = regs.R11;
		/* 8209935Ch case    7:*/		return 0x82099360;
		  /* 82099360h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 82099360h case    8:*/		if ( 1 ) { regs.LR = 0x82099364; return (uint32)regs.CTR; }
		/* 82099360h case    8:*/		return 0x82099364;
		  /* 82099364h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 82099364h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82099364h case    9:*/		return 0x82099368;
		  /* 82099368h */ case   10:  		/* li R3, 1 */
		/* 82099368h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82099368h case   10:*/		return 0x8209936C;
		  /* 8209936Ch */ case   11:  		/* bc 4, CR0_EQ, 8 */
		/* 8209936Ch case   11:*/		if ( !regs.CR[0].eq ) { return 0x82099374;  }
		/* 8209936Ch case   11:*/		return 0x82099370;
	}
	return 0x82099370;
} // Block from 82099340h-82099370h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82099370h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099370);
		  /* 82099370h */ case    0:  		/* li R3, 0 */
		/* 82099370h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82099370h case    0:*/		return 0x82099374;
	}
	return 0x82099374;
} // Block from 82099370h-82099374h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82099374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099374);
		  /* 82099374h */ case    0:  		/* addi R1, R1, 96 */
		/* 82099374h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82099374h case    0:*/		return 0x82099378;
		  /* 82099378h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82099378h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82099378h case    1:*/		return 0x8209937C;
		  /* 8209937Ch */ case    2:  		/* mtspr LR, R12 */
		/* 8209937Ch case    2:*/		regs.LR = regs.R12;
		/* 8209937Ch case    2:*/		return 0x82099380;
		  /* 82099380h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82099380h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82099380h case    3:*/		return 0x82099384;
	}
	return 0x82099384;
} // Block from 82099374h-82099384h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82099384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099384);
		  /* 82099384h */ case    0:  		/* nop */
		/* 82099384h case    0:*/		cpu::op::nop();
		/* 82099384h case    0:*/		return 0x82099388;
	}
	return 0x82099388;
} // Block from 82099384h-82099388h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82099388h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099388);
		  /* 82099388h */ case    0:  		/* mfspr R12, LR */
		/* 82099388h case    0:*/		regs.R12 = regs.LR;
		/* 82099388h case    0:*/		return 0x8209938C;
		  /* 8209938Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209938Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209938Ch case    1:*/		return 0x82099390;
		  /* 82099390h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82099390h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82099390h case    2:*/		return 0x82099394;
		  /* 82099394h */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 82099394h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82099394h case    3:*/		return 0x82099398;
		  /* 82099398h */ case    4:  		/* li R11, 0 */
		/* 82099398h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82099398h case    4:*/		return 0x8209939C;
		  /* 8209939Ch */ case    5:  		/* addi R5, R1, 80 */
		/* 8209939Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8209939Ch case    5:*/		return 0x820993A0;
		  /* 820993A0h */ case    6:  		/* stw R11, <#[R1 + 80]> */
		/* 820993A0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820993A0h case    6:*/		return 0x820993A4;
		  /* 820993A4h */ case    7:  		/* bl 8068 */
		/* 820993A4h case    7:*/		regs.LR = 0x820993A8; return 0x8209B328;
		/* 820993A4h case    7:*/		return 0x820993A8;
		  /* 820993A8h */ case    8:  		/* or. R31, R3, R3 */
		/* 820993A8h case    8:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820993A8h case    8:*/		return 0x820993AC;
		  /* 820993ACh */ case    9:  		/* bc 4, CR0_EQ, 40 */
		/* 820993ACh case    9:*/		if ( !regs.CR[0].eq ) { return 0x820993D4;  }
		/* 820993ACh case    9:*/		return 0x820993B0;
		  /* 820993B0h */ case   10:  		/* lwz R11, <#[R1 + 80]> */
		/* 820993B0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820993B0h case   10:*/		return 0x820993B4;
		  /* 820993B4h */ case   11:  		/* cmpwi CR6, R11, 0 */
		/* 820993B4h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820993B4h case   11:*/		return 0x820993B8;
		  /* 820993B8h */ case   12:  		/* bc 12, CR6_EQ, 28 */
		/* 820993B8h case   12:*/		if ( regs.CR[6].eq ) { return 0x820993D4;  }
		/* 820993B8h case   12:*/		return 0x820993BC;
		  /* 820993BCh */ case   13:  		/* bl -17588 */
		/* 820993BCh case   13:*/		regs.LR = 0x820993C0; return 0x82094F08;
		/* 820993BCh case   13:*/		return 0x820993C0;
		  /* 820993C0h */ case   14:  		/* cmplwi CR0, R3, 0 */
		/* 820993C0h case   14:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820993C0h case   14:*/		return 0x820993C4;
		  /* 820993C4h */ case   15:  		/* bc 12, CR0_EQ, 16 */
		/* 820993C4h case   15:*/		if ( regs.CR[0].eq ) { return 0x820993D4;  }
		/* 820993C4h case   15:*/		return 0x820993C8;
		  /* 820993C8h */ case   16:  		/* bl -17600 */
		/* 820993C8h case   16:*/		regs.LR = 0x820993CC; return 0x82094F08;
		/* 820993C8h case   16:*/		return 0x820993CC;
		  /* 820993CCh */ case   17:  		/* lwz R11, <#[R1 + 80]> */
		/* 820993CCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820993CCh case   17:*/		return 0x820993D0;
		  /* 820993D0h */ case   18:  		/* stw R11, <#[R3]> */
		/* 820993D0h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820993D0h case   18:*/		return 0x820993D4;
	}
	return 0x820993D4;
} // Block from 82099388h-820993D4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820993D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820993D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820993D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820993D4);
		  /* 820993D4h */ case    0:  		/* mr R3, R31 */
		/* 820993D4h case    0:*/		regs.R3 = regs.R31;
		/* 820993D4h case    0:*/		return 0x820993D8;
		  /* 820993D8h */ case    1:  		/* addi R1, R1, 112 */
		/* 820993D8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820993D8h case    1:*/		return 0x820993DC;
		  /* 820993DCh */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820993DCh case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820993DCh case    2:*/		return 0x820993E0;
		  /* 820993E0h */ case    3:  		/* mtspr LR, R12 */
		/* 820993E0h case    3:*/		regs.LR = regs.R12;
		/* 820993E0h case    3:*/		return 0x820993E4;
		  /* 820993E4h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820993E4h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820993E4h case    4:*/		return 0x820993E8;
		  /* 820993E8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820993E8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820993E8h case    5:*/		return 0x820993EC;
	}
	return 0x820993EC;
} // Block from 820993D4h-820993ECh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820993ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820993EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820993EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820993EC);
		  /* 820993ECh */ case    0:  		/* nop */
		/* 820993ECh case    0:*/		cpu::op::nop();
		/* 820993ECh case    0:*/		return 0x820993F0;
		  /* 820993F0h */ case    1:  		/* cmpwi CR6, R3, 0 */
		/* 820993F0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820993F0h case    1:*/		return 0x820993F4;
		  /* 820993F4h */ case    2:  		/* bclr 4, CR6_EQ */
		/* 820993F4h case    2:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820993F4h case    2:*/		return 0x820993F8;
	}
	return 0x820993F8;
} // Block from 820993ECh-820993F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820993F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820993F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820993F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820993F8);
		  /* 820993F8h */ case    0:  		/* b -25000 */
		/* 820993F8h case    0:*/		return 0x82093250;
		/* 820993F8h case    0:*/		return 0x820993FC;
		  /* 820993FCh */ case    1:  		/* bclr 20, CR0_LT */
		/* 820993FCh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820993FCh case    1:*/		return 0x82099400;
	}
	return 0x82099400;
} // Block from 820993F8h-82099400h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82099400h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099400);
		  /* 82099400h */ case    0:  		/* mfspr R12, LR */
		/* 82099400h case    0:*/		regs.R12 = regs.LR;
		/* 82099400h case    0:*/		return 0x82099404;
		  /* 82099404h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82099404h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82099404h case    1:*/		return 0x82099408;
		  /* 82099408h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82099408h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82099408h case    2:*/		return 0x8209940C;
		  /* 8209940Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209940Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209940Ch case    3:*/		return 0x82099410;
		  /* 82099410h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 82099410h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82099410h case    4:*/		return 0x82099414;
		  /* 82099414h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 82099414h case    5:*/		if ( regs.CR[6].eq ) { return 0x82099420;  }
		/* 82099414h case    5:*/		return 0x82099418;
		  /* 82099418h */ case    6:  		/* cmplwi CR6, R4, 0 */
		/* 82099418h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82099418h case    6:*/		return 0x8209941C;
		  /* 8209941Ch */ case    7:  		/* bc 4, CR6_EQ, 28 */
		/* 8209941Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x82099438;  }
		/* 8209941Ch case    7:*/		return 0x82099420;
	}
	return 0x82099420;
} // Block from 82099400h-82099420h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82099420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099420);
		  /* 82099420h */ case    0:  		/* bl -17688 */
		/* 82099420h case    0:*/		regs.LR = 0x82099424; return 0x82094F08;
		/* 82099420h case    0:*/		return 0x82099424;
		  /* 82099424h */ case    1:  		/* li R11, 22 */
		/* 82099424h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 82099424h case    1:*/		return 0x82099428;
		  /* 82099428h */ case    2:  		/* stw R11, <#[R3]> */
		/* 82099428h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82099428h case    2:*/		return 0x8209942C;
		  /* 8209942Ch */ case    3:  		/* bl -23244 */
		/* 8209942Ch case    3:*/		regs.LR = 0x82099430; return 0x82093960;
		/* 8209942Ch case    3:*/		return 0x82099430;
		  /* 82099430h */ case    4:  		/* li R3, 22 */
		/* 82099430h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x16);
		/* 82099430h case    4:*/		return 0x82099434;
		  /* 82099434h */ case    5:  		/* b 108 */
		/* 82099434h case    5:*/		return 0x820994A0;
		/* 82099434h case    5:*/		return 0x82099438;
	}
	return 0x82099438;
} // Block from 82099420h-82099438h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82099438h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099438);
		  /* 82099438h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 82099438h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82099438h case    0:*/		return 0x8209943C;
		  /* 8209943Ch */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 8209943Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82099460;  }
		/* 8209943Ch case    1:*/		return 0x82099440;
		  /* 82099440h */ case    2:  		/* li R11, 0 */
		/* 82099440h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82099440h case    2:*/		return 0x82099444;
		  /* 82099444h */ case    3:  		/* stb R11, <#[R3]> */
		/* 82099444h case    3:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82099444h case    3:*/		return 0x82099448;
		  /* 82099448h */ case    4:  		/* bl -17728 */
		/* 82099448h case    4:*/		regs.LR = 0x8209944C; return 0x82094F08;
		/* 82099448h case    4:*/		return 0x8209944C;
		  /* 8209944Ch */ case    5:  		/* li R31, 22 */
		/* 8209944Ch case    5:*/		cpu::op::li<0>(regs,&regs.R31,0x16);
		/* 8209944Ch case    5:*/		return 0x82099450;
		  /* 82099450h */ case    6:  		/* stw R31, <#[R3]> */
		/* 82099450h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82099450h case    6:*/		return 0x82099454;
		  /* 82099454h */ case    7:  		/* bl -23284 */
		/* 82099454h case    7:*/		regs.LR = 0x82099458; return 0x82093960;
		/* 82099454h case    7:*/		return 0x82099458;
		  /* 82099458h */ case    8:  		/* mr R3, R31 */
		/* 82099458h case    8:*/		regs.R3 = regs.R31;
		/* 82099458h case    8:*/		return 0x8209945C;
		  /* 8209945Ch */ case    9:  		/* b 68 */
		/* 8209945Ch case    9:*/		return 0x820994A0;
		/* 8209945Ch case    9:*/		return 0x82099460;
	}
	return 0x82099460;
} // Block from 82099438h-82099460h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82099460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099460);
		  /* 82099460h */ case    0:  		/* subf R11, R5, R3 */
		/* 82099460h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R5,regs.R3);
		/* 82099460h case    0:*/		return 0x82099464;
		  /* 82099464h */ case    1:  		/* lbz R10, <#[R5]> */
		/* 82099464h case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 82099464h case    1:*/		return 0x82099468;
		  /* 82099468h */ case    2:  		/* cmplwi CR0, R10, 0 */
		/* 82099468h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 82099468h case    2:*/		return 0x8209946C;
		  /* 8209946Ch */ case    3:  		/* stbx R10, <#[R11 + R5]> */
		/* 8209946Ch case    3:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 8209946Ch case    3:*/		return 0x82099470;
		  /* 82099470h */ case    4:  		/* addi R5, R5, 1 */
		/* 82099470h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 82099470h case    4:*/		return 0x82099474;
		  /* 82099474h */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 82099474h case    5:*/		if ( regs.CR[0].eq ) { return 0x82099480;  }
		/* 82099474h case    5:*/		return 0x82099478;
		  /* 82099478h */ case    6:  		/* addic. R4, R4, -1 */
		/* 82099478h case    6:*/		cpu::op::addic<1>(regs,&regs.R4,regs.R4,0xFFFFFFFF);
		/* 82099478h case    6:*/		return 0x8209947C;
		  /* 8209947Ch */ case    7:  		/* bc 4, CR0_EQ, -24 */
		/* 8209947Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x82099464;  }
		/* 8209947Ch case    7:*/		return 0x82099480;
	}
	return 0x82099480;
} // Block from 82099460h-82099480h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82099480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099480);
		  /* 82099480h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 82099480h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82099480h case    0:*/		return 0x82099484;
		  /* 82099484h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 82099484h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209949C;  }
		/* 82099484h case    1:*/		return 0x82099488;
		  /* 82099488h */ case    2:  		/* li R11, 0 */
		/* 82099488h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82099488h case    2:*/		return 0x8209948C;
		  /* 8209948Ch */ case    3:  		/* stb R11, <#[R3]> */
		/* 8209948Ch case    3:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209948Ch case    3:*/		return 0x82099490;
		  /* 82099490h */ case    4:  		/* bl -17800 */
		/* 82099490h case    4:*/		regs.LR = 0x82099494; return 0x82094F08;
		/* 82099490h case    4:*/		return 0x82099494;
		  /* 82099494h */ case    5:  		/* li R31, 34 */
		/* 82099494h case    5:*/		cpu::op::li<0>(regs,&regs.R31,0x22);
		/* 82099494h case    5:*/		return 0x82099498;
		  /* 82099498h */ case    6:  		/* b -72 */
		/* 82099498h case    6:*/		return 0x82099450;
		/* 82099498h case    6:*/		return 0x8209949C;
	}
	return 0x8209949C;
} // Block from 82099480h-8209949Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209949Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209949C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209949C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209949C);
		  /* 8209949Ch */ case    0:  		/* li R3, 0 */
		/* 8209949Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209949Ch case    0:*/		return 0x820994A0;
	}
	return 0x820994A0;
} // Block from 8209949Ch-820994A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820994A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820994A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820994A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820994A0);
		  /* 820994A0h */ case    0:  		/* addi R1, R1, 96 */
		/* 820994A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820994A0h case    0:*/		return 0x820994A4;
		  /* 820994A4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820994A4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820994A4h case    1:*/		return 0x820994A8;
		  /* 820994A8h */ case    2:  		/* mtspr LR, R12 */
		/* 820994A8h case    2:*/		regs.LR = regs.R12;
		/* 820994A8h case    2:*/		return 0x820994AC;
		  /* 820994ACh */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820994ACh case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820994ACh case    3:*/		return 0x820994B0;
		  /* 820994B0h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820994B0h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820994B0h case    4:*/		return 0x820994B4;
	}
	return 0x820994B4;
} // Block from 820994A0h-820994B4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820994B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820994B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820994B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820994B4);
		  /* 820994B4h */ case    0:  		/* nop */
		/* 820994B4h case    0:*/		cpu::op::nop();
		/* 820994B4h case    0:*/		return 0x820994B8;
	}
	return 0x820994B8;
} // Block from 820994B4h-820994B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820994B8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820994B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820994B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820994B8);
		  /* 820994B8h */ case    0:  		/* mfspr R12, LR */
		/* 820994B8h case    0:*/		regs.R12 = regs.LR;
		/* 820994B8h case    0:*/		return 0x820994BC;
		  /* 820994BCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820994BCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820994BCh case    1:*/		return 0x820994C0;
		  /* 820994C0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820994C0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820994C0h case    2:*/		return 0x820994C4;
		  /* 820994C4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820994C4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820994C4h case    3:*/		return 0x820994C8;
		  /* 820994C8h */ case    4:  		/* stwu R1, <#[R1 - 144]> */
		/* 820994C8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820994C8h case    4:*/		return 0x820994CC;
		  /* 820994CCh */ case    5:  		/* lis R11, -32255 */
		/* 820994CCh case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820994CCh case    5:*/		return 0x820994D0;
		  /* 820994D0h */ case    6:  		/* mr R30, R3 */
		/* 820994D0h case    6:*/		regs.R30 = regs.R3;
		/* 820994D0h case    6:*/		return 0x820994D4;
		  /* 820994D4h */ case    7:  		/* mr R31, R4 */
		/* 820994D4h case    7:*/		regs.R31 = regs.R4;
		/* 820994D4h case    7:*/		return 0x820994D8;
		  /* 820994D8h */ case    8:  		/* addi R3, R1, 80 */
		/* 820994D8h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820994D8h case    8:*/		return 0x820994DC;
		  /* 820994DCh */ case    9:  		/* addi R4, R11, -20768 */
		/* 820994DCh case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFAEE0);
		/* 820994DCh case    9:*/		return 0x820994E0;
		  /* 820994E0h */ case   10:  		/* li R5, 32 */
		/* 820994E0h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 820994E0h case   10:*/		return 0x820994E4;
		  /* 820994E4h */ case   11:  		/* bl -31540 */
		/* 820994E4h case   11:*/		regs.LR = 0x820994E8; return 0x820919B0;
		/* 820994E4h case   11:*/		return 0x820994E8;
		  /* 820994E8h */ case   12:  		/* stw R30, <#[R1 + 104]> */
		/* 820994E8h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000068) );
		/* 820994E8h case   12:*/		return 0x820994EC;
		  /* 820994ECh */ case   13:  		/* stw R31, <#[R1 + 108]> */
		/* 820994ECh case   13:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x0000006C) );
		/* 820994ECh case   13:*/		return 0x820994F0;
		  /* 820994F0h */ case   14:  		/* cmplwi CR6, R31, 0 */
		/* 820994F0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820994F0h case   14:*/		return 0x820994F4;
		  /* 820994F4h */ case   15:  		/* bc 12, CR6_EQ, 28 */
		/* 820994F4h case   15:*/		if ( regs.CR[6].eq ) { return 0x82099510;  }
		/* 820994F4h case   15:*/		return 0x820994F8;
		  /* 820994F8h */ case   16:  		/* lwz R11, <#[R31]> */
		/* 820994F8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820994F8h case   16:*/		return 0x820994FC;
		  /* 820994FCh */ case   17:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 820994FCh case   17:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 820994FCh case   17:*/		return 0x82099500;
	}
	return 0x82099500;
} // Block from 820994B8h-82099500h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82099500h
// Function '_cftoe_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099500);
		  /* 82099500h */ case    0:  		/* bc 12, CR0_EQ, 16 */
		/* 82099500h case    0:*/		if ( regs.CR[0].eq ) { return 0x82099510;  }
		/* 82099500h case    0:*/		return 0x82099504;
		  /* 82099504h */ case    1:  		/* lis R11, 409 */
		/* 82099504h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0x199);
		/* 82099504h case    1:*/		return 0x82099508;
		  /* 82099508h */ case    2:  		/* ori R11, R11, 16384 */
		/* 82099508h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 82099508h case    2:*/		return 0x8209950C;
		  /* 8209950Ch */ case    3:  		/* stw R11, <#[R1 + 100]> */
		/* 8209950Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 8209950Ch case    3:*/		return 0x82099510;
	}
	return 0x82099510;
} // Block from 82099500h-82099510h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82099510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099510);
		  /* 82099510h */ case    0:  		/* addi R6, R1, 100 */
		/* 82099510h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x64);
		/* 82099510h case    0:*/		return 0x82099514;
		  /* 82099514h */ case    1:  		/* lwz R5, <#[R1 + 96]> */
		/* 82099514h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000060) );
		/* 82099514h case    1:*/		return 0x82099518;
		  /* 82099518h */ case    2:  		/* lwz R4, <#[R1 + 84]> */
		/* 82099518h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 82099518h case    2:*/		return 0x8209951C;
		  /* 8209951Ch */ case    3:  		/* lwz R3, <#[R1 + 80]> */
		/* 8209951Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 8209951Ch case    3:*/		return 0x82099520;
		  /* 82099520h */ case    4:  		/* bl 1891760 */
		/* 82099520h case    4:*/		regs.LR = 0x82099524; return 0x822672D0;
		/* 82099520h case    4:*/		return 0x82099524;
		  /* 82099524h */ case    5:  		/* addi R1, R1, 144 */
		/* 82099524h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82099524h case    5:*/		return 0x82099528;
		  /* 82099528h */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 82099528h case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82099528h case    6:*/		return 0x8209952C;
		  /* 8209952Ch */ case    7:  		/* mtspr LR, R12 */
		/* 8209952Ch case    7:*/		regs.LR = regs.R12;
		/* 8209952Ch case    7:*/		return 0x82099530;
		  /* 82099530h */ case    8:  		/* ld R30, <#[R1 - 24]> */
		/* 82099530h case    8:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82099530h case    8:*/		return 0x82099534;
		  /* 82099534h */ case    9:  		/* ld R31, <#[R1 - 16]> */
		/* 82099534h case    9:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82099534h case    9:*/		return 0x82099538;
		  /* 82099538h */ case   10:  		/* bclr 20, CR0_LT */
		/* 82099538h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82099538h case   10:*/		return 0x8209953C;
	}
	return 0x8209953C;
} // Block from 82099510h-8209953Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209953Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209953C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209953C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209953C);
		  /* 8209953Ch */ case    0:  		/* nop */
		/* 8209953Ch case    0:*/		cpu::op::nop();
		/* 8209953Ch case    0:*/		return 0x82099540;
	}
	return 0x82099540;
} // Block from 8209953Ch-82099540h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82099540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099540);
		  /* 82099540h */ case    0:  		/* mfspr R12, LR */
		/* 82099540h case    0:*/		regs.R12 = regs.LR;
		/* 82099540h case    0:*/		return 0x82099544;
		  /* 82099544h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82099544h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82099544h case    1:*/		return 0x82099548;
		  /* 82099548h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82099548h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82099548h case    2:*/		return 0x8209954C;
		  /* 8209954Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8209954Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209954Ch case    3:*/		return 0x82099550;
		  /* 82099550h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82099550h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82099550h case    4:*/		return 0x82099554;
		  /* 82099554h */ case    5:  		/* lis R11, -32255 */
		/* 82099554h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82099554h case    5:*/		return 0x82099558;
		  /* 82099558h */ case    6:  		/* mr R31, R3 */
		/* 82099558h case    6:*/		regs.R31 = regs.R3;
		/* 82099558h case    6:*/		return 0x8209955C;
		  /* 8209955Ch */ case    7:  		/* addi R11, R11, -20736 */
		/* 8209955Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFAF00);
		/* 8209955Ch case    7:*/		return 0x82099560;
		  /* 82099560h */ case    8:  		/* mr R30, R4 */
		/* 82099560h case    8:*/		regs.R30 = regs.R4;
		/* 82099560h case    8:*/		return 0x82099564;
		  /* 82099564h */ case    9:  		/* stw R11, <#[R3]> */
		/* 82099564h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82099564h case    9:*/		return 0x82099568;
		  /* 82099568h */ case   10:  		/* bl 7824 */
		/* 82099568h case   10:*/		regs.LR = 0x8209956C; return 0x8209B3F8;
		/* 82099568h case   10:*/		return 0x8209956C;
		  /* 8209956Ch */ case   11:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 8209956Ch case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 8209956Ch case   11:*/		return 0x82099570;
		  /* 82099570h */ case   12:  		/* bc 12, CR0_EQ, 12 */
		/* 82099570h case   12:*/		if ( regs.CR[0].eq ) { return 0x8209957C;  }
		/* 82099570h case   12:*/		return 0x82099574;
		  /* 82099574h */ case   13:  		/* mr R3, R31 */
		/* 82099574h case   13:*/		regs.R3 = regs.R31;
		/* 82099574h case   13:*/		return 0x82099578;
		  /* 82099578h */ case   14:  		/* bl -29200 */
		/* 82099578h case   14:*/		regs.LR = 0x8209957C; return 0x82092368;
		/* 82099578h case   14:*/		return 0x8209957C;
	}
	return 0x8209957C;
} // Block from 82099540h-8209957Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8209957Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209957C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209957C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209957C);
		  /* 8209957Ch */ case    0:  		/* mr R3, R31 */
		/* 8209957Ch case    0:*/		regs.R3 = regs.R31;
		/* 8209957Ch case    0:*/		return 0x82099580;
		  /* 82099580h */ case    1:  		/* addi R1, R1, 112 */
		/* 82099580h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82099580h case    1:*/		return 0x82099584;
		  /* 82099584h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82099584h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82099584h case    2:*/		return 0x82099588;
		  /* 82099588h */ case    3:  		/* mtspr LR, R12 */
		/* 82099588h case    3:*/		regs.LR = regs.R12;
		/* 82099588h case    3:*/		return 0x8209958C;
		  /* 8209958Ch */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 8209958Ch case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209958Ch case    4:*/		return 0x82099590;
		  /* 82099590h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 82099590h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82099590h case    5:*/		return 0x82099594;
		  /* 82099594h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82099594h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82099594h case    6:*/		return 0x82099598;
	}
	return 0x82099598;
} // Block from 8209957Ch-82099598h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82099598h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099598);
		  /* 82099598h */ case    0:  		/* lis R10, -32215 */
		/* 82099598h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 82099598h case    0:*/		return 0x8209959C;
		  /* 8209959Ch */ case    1:  		/* li R11, 0 */
		/* 8209959Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209959Ch case    1:*/		return 0x820995A0;
		  /* 820995A0h */ case    2:  		/* stw R11, <#[R10 - 25248]> */
		/* 820995A0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0xFFFF9D60) );
		/* 820995A0h case    2:*/		return 0x820995A4;
		  /* 820995A4h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820995A4h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820995A4h case    3:*/		return 0x820995A8;
	}
	return 0x820995A8;
} // Block from 82099598h-820995A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820995A8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820995A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820995A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820995A8);
		  /* 820995A8h */ case    0:  		/* mfspr R12, LR */
		/* 820995A8h case    0:*/		regs.R12 = regs.LR;
		/* 820995A8h case    0:*/		return 0x820995AC;
		  /* 820995ACh */ case    1:  		/* bl -33624 */
		/* 820995ACh case    1:*/		regs.LR = 0x820995B0; return 0x82091254;
		/* 820995ACh case    1:*/		return 0x820995B0;
		  /* 820995B0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820995B0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820995B0h case    2:*/		return 0x820995B4;
		  /* 820995B4h */ case    3:  		/* mr R28, R3 */
		/* 820995B4h case    3:*/		regs.R28 = regs.R3;
		/* 820995B4h case    3:*/		return 0x820995B8;
		  /* 820995B8h */ case    4:  		/* mr R31, R4 */
		/* 820995B8h case    4:*/		regs.R31 = regs.R4;
		/* 820995B8h case    4:*/		return 0x820995BC;
		  /* 820995BCh */ case    5:  		/* cmplwi CR6, R3, 0 */
		/* 820995BCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820995BCh case    5:*/		return 0x820995C0;
		  /* 820995C0h */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 820995C0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820995D0;  }
		/* 820995C0h case    6:*/		return 0x820995C4;
		  /* 820995C4h */ case    7:  		/* mr R3, R4 */
		/* 820995C4h case    7:*/		regs.R3 = regs.R4;
		/* 820995C4h case    7:*/		return 0x820995C8;
		  /* 820995C8h */ case    8:  		/* bl -23872 */
		/* 820995C8h case    8:*/		regs.LR = 0x820995CC; return 0x82093888;
		/* 820995C8h case    8:*/		return 0x820995CC;
		  /* 820995CCh */ case    9:  		/* b 144 */
		/* 820995CCh case    9:*/		return 0x8209965C;
		/* 820995CCh case    9:*/		return 0x820995D0;
	}
	return 0x820995D0;
} // Block from 820995A8h-820995D0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820995D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820995D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820995D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820995D0);
		  /* 820995D0h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820995D0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820995D0h case    0:*/		return 0x820995D4;
		  /* 820995D4h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820995D4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820995E4;  }
		/* 820995D4h case    1:*/		return 0x820995D8;
		  /* 820995D8h */ case    2:  		/* mr R3, R28 */
		/* 820995D8h case    2:*/		regs.R3 = regs.R28;
		/* 820995D8h case    2:*/		return 0x820995DC;
		  /* 820995DCh */ case    3:  		/* bl -23988 */
		/* 820995DCh case    3:*/		regs.LR = 0x820995E0; return 0x82093828;
		/* 820995DCh case    3:*/		return 0x820995E0;
		  /* 820995E0h */ case    4:  		/* b 120 */
		/* 820995E0h case    4:*/		return 0x82099658;
		/* 820995E0h case    4:*/		return 0x820995E4;
	}
	return 0x820995E4;
} // Block from 820995D0h-820995E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820995E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820995E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820995E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820995E4);
		  /* 820995E4h */ case    0:  		/* li R29, -4096 */
		/* 820995E4h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0xFFFFF000);
		/* 820995E4h case    0:*/		return 0x820995E8;
		  /* 820995E8h */ case    1:  		/* cmplw CR6, R31, R29 */
		/* 820995E8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 820995E8h case    1:*/		return 0x820995EC;
		  /* 820995ECh */ case    2:  		/* bc 12, CR6_GT, 84 */
		/* 820995ECh case    2:*/		if ( regs.CR[6].gt ) { return 0x82099640;  }
		/* 820995ECh case    2:*/		return 0x820995F0;
	}
	return 0x820995F0;
} // Block from 820995E4h-820995F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820995F0h
// Function '_cftoa_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820995F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820995F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820995F0);
		  /* 820995F0h */ case    0:  		/* lis R27, -32215 */
		/* 820995F0h case    0:*/		cpu::op::lis<0>(regs,&regs.R27,0xFFFF8229);
		/* 820995F0h case    0:*/		return 0x820995F4;
		  /* 820995F4h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 820995F4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820995F4h case    1:*/		return 0x820995F8;
		  /* 820995F8h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820995F8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82099600;  }
		/* 820995F8h case    2:*/		return 0x820995FC;
		  /* 820995FCh */ case    3:  		/* li R31, 1 */
		/* 820995FCh case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 820995FCh case    3:*/		return 0x82099600;
	}
	return 0x82099600;
} // Block from 820995F0h-82099600h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82099600h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099600);
		  /* 82099600h */ case    0:  		/* bl -47312 */
		/* 82099600h case    0:*/		regs.LR = 0x82099604; return 0x8208DD30;
		/* 82099600h case    0:*/		return 0x82099604;
		  /* 82099604h */ case    1:  		/* li R4, 0 */
		/* 82099604h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82099604h case    1:*/		return 0x82099608;
		  /* 82099608h */ case    2:  		/* mr R5, R28 */
		/* 82099608h case    2:*/		regs.R5 = regs.R28;
		/* 82099608h case    2:*/		return 0x8209960C;
		  /* 8209960Ch */ case    3:  		/* mr R6, R31 */
		/* 8209960Ch case    3:*/		regs.R6 = regs.R31;
		/* 8209960Ch case    3:*/		return 0x82099610;
		  /* 82099610h */ case    4:  		/* bl -49928 */
		/* 82099610h case    4:*/		regs.LR = 0x82099614; return 0x8208D308;
		/* 82099610h case    4:*/		return 0x82099614;
		  /* 82099614h */ case    5:  		/* or. R30, R3, R3 */
		/* 82099614h case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 82099614h case    5:*/		return 0x82099618;
		  /* 82099618h */ case    6:  		/* bc 4, CR0_EQ, 120 */
		/* 82099618h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82099690;  }
		/* 82099618h case    6:*/		return 0x8209961C;
		  /* 8209961Ch */ case    7:  		/* lwz R11, <#[R27 - 30280]> */
		/* 8209961Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFF89B8) );
		/* 8209961Ch case    7:*/		return 0x82099620;
		  /* 82099620h */ case    8:  		/* cmpwi CR6, R11, 0 */
		/* 82099620h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82099620h case    8:*/		return 0x82099624;
		  /* 82099624h */ case    9:  		/* bc 12, CR6_EQ, 88 */
		/* 82099624h case    9:*/		if ( regs.CR[6].eq ) { return 0x8209967C;  }
		/* 82099624h case    9:*/		return 0x82099628;
		  /* 82099628h */ case   10:  		/* mr R3, R31 */
		/* 82099628h case   10:*/		regs.R3 = regs.R31;
		/* 82099628h case   10:*/		return 0x8209962C;
		  /* 8209962Ch */ case   11:  		/* bl -748 */
		/* 8209962Ch case   11:*/		regs.LR = 0x82099630; return 0x82099340;
		/* 8209962Ch case   11:*/		return 0x82099630;
		  /* 82099630h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 82099630h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82099630h case   12:*/		return 0x82099634;
		  /* 82099634h */ case   13:  		/* bc 12, CR0_EQ, 48 */
		/* 82099634h case   13:*/		if ( regs.CR[0].eq ) { return 0x82099664;  }
		/* 82099634h case   13:*/		return 0x82099638;
		  /* 82099638h */ case   14:  		/* cmplw CR6, R31, R29 */
		/* 82099638h case   14:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 82099638h case   14:*/		return 0x8209963C;
		  /* 8209963Ch */ case   15:  		/* bc 4, CR6_GT, -72 */
		/* 8209963Ch case   15:*/		if ( !regs.CR[6].gt ) { return 0x820995F4;  }
		/* 8209963Ch case   15:*/		return 0x82099640;
	}
	return 0x82099640;
} // Block from 82099600h-82099640h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82099640h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099640);
		  /* 82099640h */ case    0:  		/* mr R3, R31 */
		/* 82099640h case    0:*/		regs.R3 = regs.R31;
		/* 82099640h case    0:*/		return 0x82099644;
		  /* 82099644h */ case    1:  		/* bl -772 */
		/* 82099644h case    1:*/		regs.LR = 0x82099648; return 0x82099340;
		/* 82099644h case    1:*/		return 0x82099648;
		  /* 82099648h */ case    2:  		/* bl -18240 */
		/* 82099648h case    2:*/		regs.LR = 0x8209964C; return 0x82094F08;
		/* 82099648h case    2:*/		return 0x8209964C;
		  /* 8209964Ch */ case    3:  		/* li R10, 12 */
		/* 8209964Ch case    3:*/		cpu::op::li<0>(regs,&regs.R10,0xC);
		/* 8209964Ch case    3:*/		return 0x82099650;
		  /* 82099650h */ case    4:  		/* mr R11, R3 */
		/* 82099650h case    4:*/		regs.R11 = regs.R3;
		/* 82099650h case    4:*/		return 0x82099654;
		  /* 82099654h */ case    5:  		/* stw R10, <#[R3]> */
		/* 82099654h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82099654h case    5:*/		return 0x82099658;
	}
	return 0x82099658;
} // Block from 82099640h-82099658h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82099658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099658);
		  /* 82099658h */ case    0:  		/* li R3, 0 */
		/* 82099658h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82099658h case    0:*/		return 0x8209965C;
	}
	return 0x8209965C;
} // Block from 82099658h-8209965Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209965Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209965C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209965C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209965C);
		  /* 8209965Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 8209965Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8209965Ch case    0:*/		return 0x82099660;
		  /* 82099660h */ case    1:  		/* b -33724 */
		/* 82099660h case    1:*/		return 0x820912A4;
		/* 82099660h case    1:*/		return 0x82099664;
	}
	return 0x82099664;
} // Block from 8209965Ch-82099664h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82099664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099664);
		  /* 82099664h */ case    0:  		/* bl -18268 */
		/* 82099664h case    0:*/		regs.LR = 0x82099668; return 0x82094F08;
		/* 82099664h case    0:*/		return 0x82099668;
		  /* 82099668h */ case    1:  		/* mr R31, R3 */
		/* 82099668h case    1:*/		regs.R31 = regs.R3;
		/* 82099668h case    1:*/		return 0x8209966C;
		  /* 8209966Ch */ case    2:  		/* bl -61292 */
		/* 8209966Ch case    2:*/		regs.LR = 0x82099670; return 0x8208A700;
		/* 8209966Ch case    2:*/		return 0x82099670;
		  /* 82099670h */ case    3:  		/* bl -18392 */
		/* 82099670h case    3:*/		regs.LR = 0x82099674; return 0x82094E98;
		/* 82099670h case    3:*/		return 0x82099674;
		  /* 82099674h */ case    4:  		/* stw R3, <#[R31]> */
		/* 82099674h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 82099674h case    4:*/		return 0x82099678;
		  /* 82099678h */ case    5:  		/* b -32 */
		/* 82099678h case    5:*/		return 0x82099658;
		/* 82099678h case    5:*/		return 0x8209967C;
	}
	return 0x8209967C;
} // Block from 82099664h-8209967Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209967Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209967C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209967C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209967C);
		  /* 8209967Ch */ case    0:  		/* bl -18292 */
		/* 8209967Ch case    0:*/		regs.LR = 0x82099680; return 0x82094F08;
		/* 8209967Ch case    0:*/		return 0x82099680;
		  /* 82099680h */ case    1:  		/* mr R31, R3 */
		/* 82099680h case    1:*/		regs.R31 = regs.R3;
		/* 82099680h case    1:*/		return 0x82099684;
		  /* 82099684h */ case    2:  		/* bl -61316 */
		/* 82099684h case    2:*/		regs.LR = 0x82099688; return 0x8208A700;
		/* 82099684h case    2:*/		return 0x82099688;
		  /* 82099688h */ case    3:  		/* bl -18416 */
		/* 82099688h case    3:*/		regs.LR = 0x8209968C; return 0x82094E98;
		/* 82099688h case    3:*/		return 0x8209968C;
		  /* 8209968Ch */ case    4:  		/* stw R3, <#[R31]> */
		/* 8209968Ch case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8209968Ch case    4:*/		return 0x82099690;
	}
	return 0x82099690;
} // Block from 8209967Ch-82099690h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82099690h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099690);
		  /* 82099690h */ case    0:  		/* mr R3, R30 */
		/* 82099690h case    0:*/		regs.R3 = regs.R30;
		/* 82099690h case    0:*/		return 0x82099694;
		  /* 82099694h */ case    1:  		/* b -56 */
		/* 82099694h case    1:*/		return 0x8209965C;
		/* 82099694h case    1:*/		return 0x82099698;
	}
	return 0x82099698;
} // Block from 82099690h-82099698h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82099698h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099698);
		  /* 82099698h */ case    0:  		/* mfspr R12, LR */
		/* 82099698h case    0:*/		regs.R12 = regs.LR;
		/* 82099698h case    0:*/		return 0x8209969C;
		  /* 8209969Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209969Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209969Ch case    1:*/		return 0x820996A0;
		  /* 820996A0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820996A0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820996A0h case    2:*/		return 0x820996A4;
		  /* 820996A4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820996A4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820996A4h case    3:*/		return 0x820996A8;
		  /* 820996A8h */ case    4:  		/* mr R31, R3 */
		/* 820996A8h case    4:*/		regs.R31 = regs.R3;
		/* 820996A8h case    4:*/		return 0x820996AC;
		  /* 820996ACh */ case    5:  		/* cmplwi CR6, R3, 0 */
		/* 820996ACh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820996ACh case    5:*/		return 0x820996B0;
		  /* 820996B0h */ case    6:  		/* bc 4, CR6_EQ, 28 */
		/* 820996B0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820996CC;  }
		/* 820996B0h case    6:*/		return 0x820996B4;
		  /* 820996B4h */ case    7:  		/* bl -18348 */
		/* 820996B4h case    7:*/		regs.LR = 0x820996B8; return 0x82094F08;
		/* 820996B4h case    7:*/		return 0x820996B8;
		  /* 820996B8h */ case    8:  		/* li R11, 22 */
		/* 820996B8h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 820996B8h case    8:*/		return 0x820996BC;
		  /* 820996BCh */ case    9:  		/* stw R11, <#[R3]> */
		/* 820996BCh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820996BCh case    9:*/		return 0x820996C0;
		  /* 820996C0h */ case   10:  		/* bl -23904 */
		/* 820996C0h case   10:*/		regs.LR = 0x820996C4; return 0x82093960;
		/* 820996C0h case   10:*/		return 0x820996C4;
		  /* 820996C4h */ case   11:  		/* li R3, -1 */
		/* 820996C4h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820996C4h case   11:*/		return 0x820996C8;
		  /* 820996C8h */ case   12:  		/* b 20 */
		/* 820996C8h case   12:*/		return 0x820996DC;
		/* 820996C8h case   12:*/		return 0x820996CC;
	}
	return 0x820996CC;
} // Block from 82099698h-820996CCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820996CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820996CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820996CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820996CC);
		  /* 820996CCh */ case    0:  		/* bl -47516 */
		/* 820996CCh case    0:*/		regs.LR = 0x820996D0; return 0x8208DD30;
		/* 820996CCh case    0:*/		return 0x820996D0;
		  /* 820996D0h */ case    1:  		/* li R4, 0 */
		/* 820996D0h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820996D0h case    1:*/		return 0x820996D4;
		  /* 820996D4h */ case    2:  		/* mr R5, R31 */
		/* 820996D4h case    2:*/		regs.R5 = regs.R31;
		/* 820996D4h case    2:*/		return 0x820996D8;
		  /* 820996D8h */ case    3:  		/* bl -56648 */
		/* 820996D8h case    3:*/		regs.LR = 0x820996DC; return 0x8208B990;
		/* 820996D8h case    3:*/		return 0x820996DC;
	}
	return 0x820996DC;
} // Block from 820996CCh-820996DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820996DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820996DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820996DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820996DC);
		  /* 820996DCh */ case    0:  		/* addi R1, R1, 96 */
		/* 820996DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820996DCh case    0:*/		return 0x820996E0;
		  /* 820996E0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820996E0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820996E0h case    1:*/		return 0x820996E4;
		  /* 820996E4h */ case    2:  		/* mtspr LR, R12 */
		/* 820996E4h case    2:*/		regs.LR = regs.R12;
		/* 820996E4h case    2:*/		return 0x820996E8;
		  /* 820996E8h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820996E8h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820996E8h case    3:*/		return 0x820996EC;
		  /* 820996ECh */ case    4:  		/* bclr 20, CR0_LT */
		/* 820996ECh case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820996ECh case    4:*/		return 0x820996F0;
	}
	return 0x820996F0;
} // Block from 820996DCh-820996F0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820996F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820996F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820996F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820996F0);
		  /* 820996F0h */ case    0:  		/* lis R11, -32217 */
		/* 820996F0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 820996F0h case    0:*/		return 0x820996F4;
		  /* 820996F4h */ case    1:  		/* rlwinm R10, R3, 1, 0, 30 */
		/* 820996F4h case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R3);
		/* 820996F4h case    1:*/		return 0x820996F8;
		  /* 820996F8h */ case    2:  		/* addi R11, R11, 8640 */
		/* 820996F8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x21C0);
		/* 820996F8h case    2:*/		return 0x820996FC;
		  /* 820996FCh */ case    3:  		/* lwz R11, <#[R11 + 200]> */
		/* 820996FCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000C8) );
		/* 820996FCh case    3:*/		return 0x82099700;
		  /* 82099700h */ case    4:  		/* lhzx R11, <#[R10 + R11]> */
		/* 82099700h case    4:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82099700h case    4:*/		return 0x82099704;
		  /* 82099704h */ case    5:  		/* andi. R3, R11, 259 */
		/* 82099704h case    5:*/		cpu::op::andi<1>(regs,&regs.R3,regs.R11,0x103);
		/* 82099704h case    5:*/		return 0x82099708;
		  /* 82099708h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82099708h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82099708h case    6:*/		return 0x8209970C;
	}
	return 0x8209970C;
} // Block from 820996F0h-8209970Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209970Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209970C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209970C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209970C);
		  /* 8209970Ch */ case    0:  		/* nop */
		/* 8209970Ch case    0:*/		cpu::op::nop();
		/* 8209970Ch case    0:*/		return 0x82099710;
	}
	return 0x82099710;
} // Block from 8209970Ch-82099710h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82099710h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099710);
		  /* 82099710h */ case    0:  		/* lis R11, -32217 */
		/* 82099710h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82099710h case    0:*/		return 0x82099714;
		  /* 82099714h */ case    1:  		/* rlwinm R10, R3, 1, 0, 30 */
		/* 82099714h case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R3);
		/* 82099714h case    1:*/		return 0x82099718;
		  /* 82099718h */ case    2:  		/* addi R11, R11, 8640 */
		/* 82099718h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x21C0);
		/* 82099718h case    2:*/		return 0x8209971C;
		  /* 8209971Ch */ case    3:  		/* lwz R11, <#[R11 + 200]> */
		/* 8209971Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000C8) );
		/* 8209971Ch case    3:*/		return 0x82099720;
		  /* 82099720h */ case    4:  		/* lhzx R11, <#[R10 + R11]> */
		/* 82099720h case    4:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82099720h case    4:*/		return 0x82099724;
		  /* 82099724h */ case    5:  		/* rlwinm R3, R11, 0, 29, 29 */
		/* 82099724h case    5:*/		cpu::op::rlwinm<0,0,29,29>(regs,&regs.R3,regs.R11);
		/* 82099724h case    5:*/		return 0x82099728;
		  /* 82099728h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82099728h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82099728h case    6:*/		return 0x8209972C;
	}
	return 0x8209972C;
} // Block from 82099710h-8209972Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209972Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209972C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209972C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209972C);
		  /* 8209972Ch */ case    0:  		/* nop */
		/* 8209972Ch case    0:*/		cpu::op::nop();
		/* 8209972Ch case    0:*/		return 0x82099730;
		  /* 82099730h */ case    1:  		/* lis R11, -32217 */
		/* 82099730h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82099730h case    1:*/		return 0x82099734;
		  /* 82099734h */ case    2:  		/* rlwinm R10, R3, 1, 0, 30 */
		/* 82099734h case    2:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R3);
		/* 82099734h case    2:*/		return 0x82099738;
		  /* 82099738h */ case    3:  		/* addi R11, R11, 8640 */
		/* 82099738h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x21C0);
		/* 82099738h case    3:*/		return 0x8209973C;
		  /* 8209973Ch */ case    4:  		/* lwz R11, <#[R11 + 200]> */
		/* 8209973Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000C8) );
		/* 8209973Ch case    4:*/		return 0x82099740;
		  /* 82099740h */ case    5:  		/* lhzx R11, <#[R10 + R11]> */
		/* 82099740h case    5:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82099740h case    5:*/		return 0x82099744;
		  /* 82099744h */ case    6:  		/* rlwinm R3, R11, 0, 24, 24 */
		/* 82099744h case    6:*/		cpu::op::rlwinm<0,0,24,24>(regs,&regs.R3,regs.R11);
		/* 82099744h case    6:*/		return 0x82099748;
		  /* 82099748h */ case    7:  		/* bclr 20, CR0_LT */
		/* 82099748h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82099748h case    7:*/		return 0x8209974C;
	}
	return 0x8209974C;
} // Block from 8209972Ch-8209974Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209974Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209974C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209974C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209974C);
		  /* 8209974Ch */ case    0:  		/* nop */
		/* 8209974Ch case    0:*/		cpu::op::nop();
		/* 8209974Ch case    0:*/		return 0x82099750;
		  /* 82099750h */ case    1:  		/* lis R11, -32217 */
		/* 82099750h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82099750h case    1:*/		return 0x82099754;
		  /* 82099754h */ case    2:  		/* rlwinm R10, R3, 1, 0, 30 */
		/* 82099754h case    2:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R3);
		/* 82099754h case    2:*/		return 0x82099758;
		  /* 82099758h */ case    3:  		/* addi R11, R11, 8640 */
		/* 82099758h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x21C0);
		/* 82099758h case    3:*/		return 0x8209975C;
		  /* 8209975Ch */ case    4:  		/* lwz R11, <#[R11 + 200]> */
		/* 8209975Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000C8) );
		/* 8209975Ch case    4:*/		return 0x82099760;
		  /* 82099760h */ case    5:  		/* lhzx R11, <#[R10 + R11]> */
		/* 82099760h case    5:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82099760h case    5:*/		return 0x82099764;
		  /* 82099764h */ case    6:  		/* rlwinm R3, R11, 0, 28, 28 */
		/* 82099764h case    6:*/		cpu::op::rlwinm<0,0,28,28>(regs,&regs.R3,regs.R11);
		/* 82099764h case    6:*/		return 0x82099768;
		  /* 82099768h */ case    7:  		/* bclr 20, CR0_LT */
		/* 82099768h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82099768h case    7:*/		return 0x8209976C;
	}
	return 0x8209976C;
} // Block from 8209974Ch-8209976Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209976Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209976C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209976C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209976C);
		  /* 8209976Ch */ case    0:  		/* nop */
		/* 8209976Ch case    0:*/		cpu::op::nop();
		/* 8209976Ch case    0:*/		return 0x82099770;
		  /* 82099770h */ case    1:  		/* lis R11, -32217 */
		/* 82099770h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82099770h case    1:*/		return 0x82099774;
		  /* 82099774h */ case    2:  		/* rlwinm R10, R3, 1, 0, 30 */
		/* 82099774h case    2:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R3);
		/* 82099774h case    2:*/		return 0x82099778;
		  /* 82099778h */ case    3:  		/* addi R11, R11, 8640 */
		/* 82099778h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x21C0);
		/* 82099778h case    3:*/		return 0x8209977C;
		  /* 8209977Ch */ case    4:  		/* lwz R11, <#[R11 + 200]> */
		/* 8209977Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000C8) );
		/* 8209977Ch case    4:*/		return 0x82099780;
		  /* 82099780h */ case    5:  		/* lhzx R11, <#[R10 + R11]> */
		/* 82099780h case    5:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82099780h case    5:*/		return 0x82099784;
		  /* 82099784h */ case    6:  		/* andi. R3, R11, 263 */
		/* 82099784h case    6:*/		cpu::op::andi<1>(regs,&regs.R3,regs.R11,0x107);
		/* 82099784h case    6:*/		return 0x82099788;
		  /* 82099788h */ case    7:  		/* bclr 20, CR0_LT */
		/* 82099788h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82099788h case    7:*/		return 0x8209978C;
	}
	return 0x8209978C;
} // Block from 8209976Ch-8209978Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209978Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209978C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209978C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209978C);
		  /* 8209978Ch */ case    0:  		/* nop */
		/* 8209978Ch case    0:*/		cpu::op::nop();
		/* 8209978Ch case    0:*/		return 0x82099790;
	}
	return 0x82099790;
} // Block from 8209978Ch-82099790h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82099790h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099790);
		  /* 82099790h */ case    0:  		/* cmpwi CR6, R3, 65 */
		/* 82099790h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000041);
		/* 82099790h case    0:*/		return 0x82099794;
		  /* 82099794h */ case    1:  		/* bclr 12, CR6_LT */
		/* 82099794h case    1:*/		if ( regs.CR[6].lt ) { return (uint32)regs.LR; }
		/* 82099794h case    1:*/		return 0x82099798;
	}
	return 0x82099798;
} // Block from 82099790h-82099798h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82099798h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099798);
		  /* 82099798h */ case    0:  		/* cmpwi CR6, R3, 90 */
		/* 82099798h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x0000005A);
		/* 82099798h case    0:*/		return 0x8209979C;
		  /* 8209979Ch */ case    1:  		/* bclr 12, CR6_GT */
		/* 8209979Ch case    1:*/		if ( regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 8209979Ch case    1:*/		return 0x820997A0;
	}
	return 0x820997A0;
} // Block from 82099798h-820997A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820997A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820997A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820997A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820997A0);
		  /* 820997A0h */ case    0:  		/* addi R3, R3, 32 */
		/* 820997A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x20);
		/* 820997A0h case    0:*/		return 0x820997A4;
		  /* 820997A4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820997A4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820997A4h case    1:*/		return 0x820997A8;
	}
	return 0x820997A8;
} // Block from 820997A0h-820997A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820997A8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820997A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820997A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820997A8);
		  /* 820997A8h */ case    0:  		/* mfspr R12, LR */
		/* 820997A8h case    0:*/		regs.R12 = regs.LR;
		/* 820997A8h case    0:*/		return 0x820997AC;
		  /* 820997ACh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820997ACh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820997ACh case    1:*/		return 0x820997B0;
		  /* 820997B0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820997B0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820997B0h case    2:*/		return 0x820997B4;
		  /* 820997B4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820997B4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820997B4h case    3:*/		return 0x820997B8;
		  /* 820997B8h */ case    4:  		/* stwu R1, <#[R1 - 128]> */
		/* 820997B8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820997B8h case    4:*/		return 0x820997BC;
		  /* 820997BCh */ case    5:  		/* lis R11, -32217 */
		/* 820997BCh case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 820997BCh case    5:*/		return 0x820997C0;
		  /* 820997C0h */ case    6:  		/* mr R30, R3 */
		/* 820997C0h case    6:*/		regs.R30 = regs.R3;
		/* 820997C0h case    6:*/		return 0x820997C4;
		  /* 820997C4h */ case    7:  		/* mr R5, R4 */
		/* 820997C4h case    7:*/		regs.R5 = regs.R4;
		/* 820997C4h case    7:*/		return 0x820997C8;
		  /* 820997C8h */ case    8:  		/* addi R10, R11, 8856 */
		/* 820997C8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x2298);
		/* 820997C8h case    8:*/		return 0x820997CC;
		  /* 820997CCh */ case    9:  		/* li R9, 0 */
		/* 820997CCh case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820997CCh case    9:*/		return 0x820997D0;
		  /* 820997D0h */ case   10:  		/* li R8, 0 */
		/* 820997D0h case   10:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820997D0h case   10:*/		return 0x820997D4;
		  /* 820997D4h */ case   11:  		/* li R7, 0 */
		/* 820997D4h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820997D4h case   11:*/		return 0x820997D8;
		  /* 820997D8h */ case   12:  		/* li R6, 0 */
		/* 820997D8h case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820997D8h case   12:*/		return 0x820997DC;
		  /* 820997DCh */ case   13:  		/* addi R4, R1, 80 */
		/* 820997DCh case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820997DCh case   13:*/		return 0x820997E0;
		  /* 820997E0h */ case   14:  		/* addi R3, R1, 88 */
		/* 820997E0h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 820997E0h case   14:*/		return 0x820997E4;
		  /* 820997E4h */ case   15:  		/* bl 11076 */
		/* 820997E4h case   15:*/		regs.LR = 0x820997E8; return 0x8209C328;
		/* 820997E4h case   15:*/		return 0x820997E8;
		  /* 820997E8h */ case   16:  		/* mr R31, R3 */
		/* 820997E8h case   16:*/		regs.R31 = regs.R3;
		/* 820997E8h case   16:*/		return 0x820997EC;
		  /* 820997ECh */ case   17:  		/* mr R4, R30 */
		/* 820997ECh case   17:*/		regs.R4 = regs.R30;
		/* 820997ECh case   17:*/		return 0x820997F0;
		  /* 820997F0h */ case   18:  		/* addi R3, R1, 88 */
		/* 820997F0h case   18:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 820997F0h case   18:*/		return 0x820997F4;
		  /* 820997F4h */ case   19:  		/* bl 7428 */
		/* 820997F4h case   19:*/		regs.LR = 0x820997F8; return 0x8209B4F8;
		/* 820997F4h case   19:*/		return 0x820997F8;
		  /* 820997F8h */ case   20:  		/* rlwinm. R11, R31, 0, 30, 31 */
		/* 820997F8h case   20:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R11,regs.R31);
		/* 820997F8h case   20:*/		return 0x820997FC;
		  /* 820997FCh */ case   21:  		/* bc 4, CR0_EQ, 36 */
		/* 820997FCh case   21:*/		if ( !regs.CR[0].eq ) { return 0x82099820;  }
		/* 820997FCh case   21:*/		return 0x82099800;
		  /* 82099800h */ case   22:  		/* cmpwi CR6, R3, 1 */
		/* 82099800h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82099800h case   22:*/		return 0x82099804;
		  /* 82099804h */ case   23:  		/* bc 4, CR6_EQ, 12 */
		/* 82099804h case   23:*/		if ( !regs.CR[6].eq ) { return 0x82099810;  }
		/* 82099804h case   23:*/		return 0x82099808;
		  /* 82099808h */ case   24:  		/* li R3, 3 */
		/* 82099808h case   24:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 82099808h case   24:*/		return 0x8209980C;
		  /* 8209980Ch */ case   25:  		/* b 44 */
		/* 8209980Ch case   25:*/		return 0x82099838;
		/* 8209980Ch case   25:*/		return 0x82099810;
	}
	return 0x82099810;
} // Block from 820997A8h-82099810h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82099810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099810);
		  /* 82099810h */ case    0:  		/* cmpwi CR6, R3, 2 */
		/* 82099810h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 82099810h case    0:*/		return 0x82099814;
		  /* 82099814h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 82099814h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82099834;  }
		/* 82099814h case    1:*/		return 0x82099818;
		  /* 82099818h */ case    2:  		/* li R3, 4 */
		/* 82099818h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x4);
		/* 82099818h case    2:*/		return 0x8209981C;
		  /* 8209981Ch */ case    3:  		/* b 28 */
		/* 8209981Ch case    3:*/		return 0x82099838;
		/* 8209981Ch case    3:*/		return 0x82099820;
	}
	return 0x82099820;
} // Block from 82099810h-82099820h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82099820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099820);
		  /* 82099820h */ case    0:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 82099820h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 82099820h case    0:*/		return 0x82099824;
		  /* 82099824h */ case    1:  		/* bc 4, CR0_EQ, -12 */
		/* 82099824h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82099818;  }
		/* 82099824h case    1:*/		return 0x82099828;
		  /* 82099828h */ case    2:  		/* rlwinm. R11, R31, 0, 30, 30 */
		/* 82099828h case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R31);
		/* 82099828h case    2:*/		return 0x8209982C;
		  /* 8209982Ch */ case    3:  		/* li R3, 3 */
		/* 8209982Ch case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 8209982Ch case    3:*/		return 0x82099830;
		  /* 82099830h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 82099830h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82099838;  }
		/* 82099830h case    4:*/		return 0x82099834;
	}
	return 0x82099834;
} // Block from 82099820h-82099834h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82099834h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099834( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099834) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099834);
		  /* 82099834h */ case    0:  		/* li R3, 0 */
		/* 82099834h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82099834h case    0:*/		return 0x82099838;
	}
	return 0x82099838;
} // Block from 82099834h-82099838h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82099838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099838);
		  /* 82099838h */ case    0:  		/* addi R1, R1, 128 */
		/* 82099838h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82099838h case    0:*/		return 0x8209983C;
		  /* 8209983Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209983Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209983Ch case    1:*/		return 0x82099840;
		  /* 82099840h */ case    2:  		/* mtspr LR, R12 */
		/* 82099840h case    2:*/		regs.LR = regs.R12;
		/* 82099840h case    2:*/		return 0x82099844;
		  /* 82099844h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82099844h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82099844h case    3:*/		return 0x82099848;
		  /* 82099848h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82099848h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82099848h case    4:*/		return 0x8209984C;
		  /* 8209984Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 8209984Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209984Ch case    5:*/		return 0x82099850;
	}
	return 0x82099850;
} // Block from 82099838h-82099850h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82099850h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099850);
		  /* 82099850h */ case    0:  		/* mfspr R12, LR */
		/* 82099850h case    0:*/		regs.R12 = regs.LR;
		/* 82099850h case    0:*/		return 0x82099854;
		  /* 82099854h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82099854h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82099854h case    1:*/		return 0x82099858;
		  /* 82099858h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82099858h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82099858h case    2:*/		return 0x8209985C;
		  /* 8209985Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8209985Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209985Ch case    3:*/		return 0x82099860;
		  /* 82099860h */ case    4:  		/* stwu R1, <#[R1 - 128]> */
		/* 82099860h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82099860h case    4:*/		return 0x82099864;
		  /* 82099864h */ case    5:  		/* lis R11, -32217 */
		/* 82099864h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82099864h case    5:*/		return 0x82099868;
		  /* 82099868h */ case    6:  		/* mr R30, R3 */
		/* 82099868h case    6:*/		regs.R30 = regs.R3;
		/* 82099868h case    6:*/		return 0x8209986C;
		  /* 8209986Ch */ case    7:  		/* mr R5, R4 */
		/* 8209986Ch case    7:*/		regs.R5 = regs.R4;
		/* 8209986Ch case    7:*/		return 0x82099870;
		  /* 82099870h */ case    8:  		/* addi R10, R11, 8856 */
		/* 82099870h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x2298);
		/* 82099870h case    8:*/		return 0x82099874;
		  /* 82099874h */ case    9:  		/* li R9, 0 */
		/* 82099874h case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82099874h case    9:*/		return 0x82099878;
		  /* 82099878h */ case   10:  		/* li R8, 0 */
		/* 82099878h case   10:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82099878h case   10:*/		return 0x8209987C;
		  /* 8209987Ch */ case   11:  		/* li R7, 0 */
		/* 8209987Ch case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8209987Ch case   11:*/		return 0x82099880;
		  /* 82099880h */ case   12:  		/* li R6, 0 */
		/* 82099880h case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82099880h case   12:*/		return 0x82099884;
		  /* 82099884h */ case   13:  		/* addi R4, R1, 80 */
		/* 82099884h case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82099884h case   13:*/		return 0x82099888;
		  /* 82099888h */ case   14:  		/* addi R3, R1, 88 */
		/* 82099888h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 82099888h case   14:*/		return 0x8209988C;
		  /* 8209988Ch */ case   15:  		/* bl 10908 */
		/* 8209988Ch case   15:*/		regs.LR = 0x82099890; return 0x8209C328;
		/* 8209988Ch case   15:*/		return 0x82099890;
		  /* 82099890h */ case   16:  		/* mr R31, R3 */
		/* 82099890h case   16:*/		regs.R31 = regs.R3;
		/* 82099890h case   16:*/		return 0x82099894;
		  /* 82099894h */ case   17:  		/* mr R4, R30 */
		/* 82099894h case   17:*/		regs.R4 = regs.R30;
		/* 82099894h case   17:*/		return 0x82099898;
		  /* 82099898h */ case   18:  		/* addi R3, R1, 88 */
		/* 82099898h case   18:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 82099898h case   18:*/		return 0x8209989C;
		  /* 8209989Ch */ case   19:  		/* bl 9076 */
		/* 8209989Ch case   19:*/		regs.LR = 0x820998A0; return 0x8209BC10;
		/* 8209989Ch case   19:*/		return 0x820998A0;
		  /* 820998A0h */ case   20:  		/* rlwinm. R11, R31, 0, 30, 31 */
		/* 820998A0h case   20:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R11,regs.R31);
		/* 820998A0h case   20:*/		return 0x820998A4;
		  /* 820998A4h */ case   21:  		/* bc 4, CR0_EQ, 36 */
		/* 820998A4h case   21:*/		if ( !regs.CR[0].eq ) { return 0x820998C8;  }
		/* 820998A4h case   21:*/		return 0x820998A8;
		  /* 820998A8h */ case   22:  		/* cmpwi CR6, R3, 1 */
		/* 820998A8h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 820998A8h case   22:*/		return 0x820998AC;
		  /* 820998ACh */ case   23:  		/* bc 4, CR6_EQ, 12 */
		/* 820998ACh case   23:*/		if ( !regs.CR[6].eq ) { return 0x820998B8;  }
		/* 820998ACh case   23:*/		return 0x820998B0;
		  /* 820998B0h */ case   24:  		/* li R3, 3 */
		/* 820998B0h case   24:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 820998B0h case   24:*/		return 0x820998B4;
		  /* 820998B4h */ case   25:  		/* b 44 */
		/* 820998B4h case   25:*/		return 0x820998E0;
		/* 820998B4h case   25:*/		return 0x820998B8;
	}
	return 0x820998B8;
} // Block from 82099850h-820998B8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820998B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820998B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820998B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820998B8);
		  /* 820998B8h */ case    0:  		/* cmpwi CR6, R3, 2 */
		/* 820998B8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 820998B8h case    0:*/		return 0x820998BC;
		  /* 820998BCh */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 820998BCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820998DC;  }
		/* 820998BCh case    1:*/		return 0x820998C0;
		  /* 820998C0h */ case    2:  		/* li R3, 4 */
		/* 820998C0h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x4);
		/* 820998C0h case    2:*/		return 0x820998C4;
		  /* 820998C4h */ case    3:  		/* b 28 */
		/* 820998C4h case    3:*/		return 0x820998E0;
		/* 820998C4h case    3:*/		return 0x820998C8;
	}
	return 0x820998C8;
} // Block from 820998B8h-820998C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820998C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820998C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820998C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820998C8);
		  /* 820998C8h */ case    0:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 820998C8h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 820998C8h case    0:*/		return 0x820998CC;
		  /* 820998CCh */ case    1:  		/* bc 4, CR0_EQ, -12 */
		/* 820998CCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x820998C0;  }
		/* 820998CCh case    1:*/		return 0x820998D0;
		  /* 820998D0h */ case    2:  		/* rlwinm. R11, R31, 0, 30, 30 */
		/* 820998D0h case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R31);
		/* 820998D0h case    2:*/		return 0x820998D4;
		  /* 820998D4h */ case    3:  		/* li R3, 3 */
		/* 820998D4h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 820998D4h case    3:*/		return 0x820998D8;
		  /* 820998D8h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 820998D8h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820998E0;  }
		/* 820998D8h case    4:*/		return 0x820998DC;
	}
	return 0x820998DC;
} // Block from 820998C8h-820998DCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820998DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820998DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820998DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820998DC);
		  /* 820998DCh */ case    0:  		/* li R3, 0 */
		/* 820998DCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820998DCh case    0:*/		return 0x820998E0;
	}
	return 0x820998E0;
} // Block from 820998DCh-820998E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820998E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820998E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820998E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820998E0);
		  /* 820998E0h */ case    0:  		/* addi R1, R1, 128 */
		/* 820998E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820998E0h case    0:*/		return 0x820998E4;
		  /* 820998E4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820998E4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820998E4h case    1:*/		return 0x820998E8;
		  /* 820998E8h */ case    2:  		/* mtspr LR, R12 */
		/* 820998E8h case    2:*/		regs.LR = regs.R12;
		/* 820998E8h case    2:*/		return 0x820998EC;
		  /* 820998ECh */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820998ECh case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820998ECh case    3:*/		return 0x820998F0;
		  /* 820998F0h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820998F0h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820998F0h case    4:*/		return 0x820998F4;
		  /* 820998F4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820998F4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820998F4h case    5:*/		return 0x820998F8;
	}
	return 0x820998F8;
} // Block from 820998E0h-820998F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820998F8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820998F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820998F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820998F8);
		  /* 820998F8h */ case    0:  		/* mfspr R12, LR */
		/* 820998F8h case    0:*/		regs.R12 = regs.LR;
		/* 820998F8h case    0:*/		return 0x820998FC;
		  /* 820998FCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820998FCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820998FCh case    1:*/		return 0x82099900;
		  /* 82099900h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82099900h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82099900h case    2:*/		return 0x82099904;
		  /* 82099904h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82099904h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82099904h case    3:*/		return 0x82099908;
		  /* 82099908h */ case    4:  		/* lwz R9, <#[R6 + 12]> */
		/* 82099908h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x0000000C) );
		/* 82099908h case    4:*/		return 0x8209990C;
		  /* 8209990Ch */ case    5:  		/* cmplwi CR6, R3, 0 */
		/* 8209990Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209990Ch case    5:*/		return 0x82099910;
		  /* 82099910h */ case    6:  		/* bc 4, CR6_EQ, 28 */
		/* 82099910h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8209992C;  }
		/* 82099910h case    6:*/		return 0x82099914;
		  /* 82099914h */ case    7:  		/* bl -18956 */
		/* 82099914h case    7:*/		regs.LR = 0x82099918; return 0x82094F08;
		/* 82099914h case    7:*/		return 0x82099918;
		  /* 82099918h */ case    8:  		/* li R11, 22 */
		/* 82099918h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 82099918h case    8:*/		return 0x8209991C;
		  /* 8209991Ch */ case    9:  		/* stw R11, <#[R3]> */
		/* 8209991Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209991Ch case    9:*/		return 0x82099920;
		  /* 82099920h */ case   10:  		/* bl -24512 */
		/* 82099920h case   10:*/		regs.LR = 0x82099924; return 0x82093960;
		/* 82099920h case   10:*/		return 0x82099924;
		  /* 82099924h */ case   11:  		/* li R3, 22 */
		/* 82099924h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x16);
		/* 82099924h case   11:*/		return 0x82099928;
		  /* 82099928h */ case   12:  		/* b 284 */
		/* 82099928h case   12:*/		return 0x82099A44;
		/* 82099928h case   12:*/		return 0x8209992C;
	}
	return 0x8209992C;
} // Block from 820998F8h-8209992Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209992Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209992C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209992C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209992C);
		  /* 8209992Ch */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 8209992Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8209992Ch case    0:*/		return 0x82099930;
		  /* 82099930h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 82099930h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209994C;  }
		/* 82099930h case    1:*/		return 0x82099934;
		  /* 82099934h */ case    2:  		/* bl -18988 */
		/* 82099934h case    2:*/		regs.LR = 0x82099938; return 0x82094F08;
		/* 82099934h case    2:*/		return 0x82099938;
		  /* 82099938h */ case    3:  		/* li R31, 22 */
		/* 82099938h case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x16);
		/* 82099938h case    3:*/		return 0x8209993C;
		  /* 8209993Ch */ case    4:  		/* stw R31, <#[R3]> */
		/* 8209993Ch case    4:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 8209993Ch case    4:*/		return 0x82099940;
		  /* 82099940h */ case    5:  		/* bl -24544 */
		/* 82099940h case    5:*/		regs.LR = 0x82099944; return 0x82093960;
		/* 82099940h case    5:*/		return 0x82099944;
		  /* 82099944h */ case    6:  		/* mr R3, R31 */
		/* 82099944h case    6:*/		regs.R3 = regs.R31;
		/* 82099944h case    6:*/		return 0x82099948;
		  /* 82099948h */ case    7:  		/* b 252 */
		/* 82099948h case    7:*/		return 0x82099A44;
		/* 82099948h case    7:*/		return 0x8209994C;
	}
	return 0x8209994C;
} // Block from 8209992Ch-8209994Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209994Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209994C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209994C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209994C);
		  /* 8209994Ch */ case    0:  		/* subfic R11, R5, 0 */
		/* 8209994Ch case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R5,0x0);
		/* 8209994Ch case    0:*/		return 0x82099950;
		  /* 82099950h */ case    1:  		/* rlwinm R11, R5, 1, 31, 31 */
		/* 82099950h case    1:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R5);
		/* 82099950h case    1:*/		return 0x82099954;
		  /* 82099954h */ case    2:  		/* li R8, 0 */
		/* 82099954h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82099954h case    2:*/		return 0x82099958;
		  /* 82099958h */ case    3:  		/* addme R11, R11 */
		/* 82099958h case    3:*/		cpu::op::addme<0>(regs,&regs.R11,regs.R11);
		/* 82099958h case    3:*/		return 0x8209995C;
		  /* 8209995Ch */ case    4:  		/* stb R8, <#[R3]> */
		/* 8209995Ch case    4:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 8209995Ch case    4:*/		return 0x82099960;
		  /* 82099960h */ case    5:  		/* and R11, R11, R5 */
		/* 82099960h case    5:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 82099960h case    5:*/		return 0x82099964;
		  /* 82099964h */ case    6:  		/* addi R11, R11, 1 */
		/* 82099964h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82099964h case    6:*/		return 0x82099968;
		  /* 82099968h */ case    7:  		/* cmplw CR6, R4, R11 */
		/* 82099968h case    7:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 82099968h case    7:*/		return 0x8209996C;
		  /* 8209996Ch */ case    8:  		/* bc 12, CR6_GT, 16 */
		/* 8209996Ch case    8:*/		if ( regs.CR[6].gt ) { return 0x8209997C;  }
		/* 8209996Ch case    8:*/		return 0x82099970;
		  /* 82099970h */ case    9:  		/* bl -19048 */
		/* 82099970h case    9:*/		regs.LR = 0x82099974; return 0x82094F08;
		/* 82099970h case    9:*/		return 0x82099974;
		  /* 82099974h */ case   10:  		/* li R31, 34 */
		/* 82099974h case   10:*/		cpu::op::li<0>(regs,&regs.R31,0x22);
		/* 82099974h case   10:*/		return 0x82099978;
		  /* 82099978h */ case   11:  		/* b -60 */
		/* 82099978h case   11:*/		return 0x8209993C;
		/* 82099978h case   11:*/		return 0x8209997C;
	}
	return 0x8209997C;
} // Block from 8209994Ch-8209997Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8209997Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209997C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209997C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209997C);
		  /* 8209997Ch */ case    0:  		/* li R7, 48 */
		/* 8209997Ch case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x30);
		/* 8209997Ch case    0:*/		return 0x82099980;
		  /* 82099980h */ case    1:  		/* addi R4, R3, 1 */
		/* 82099980h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0x1);
		/* 82099980h case    1:*/		return 0x82099984;
		  /* 82099984h */ case    2:  		/* stb R7, <#[R3]> */
		/* 82099984h case    2:*/		cpu::mem::store8( regs, regs.R7, (uint32)(regs.R3 + 0x00000000) );
		/* 82099984h case    2:*/		return 0x82099988;
		  /* 82099988h */ case    3:  		/* cmpwi CR6, R5, 0 */
		/* 82099988h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 82099988h case    3:*/		return 0x8209998C;
		  /* 8209998Ch */ case    4:  		/* mr R11, R4 */
		/* 8209998Ch case    4:*/		regs.R11 = regs.R4;
		/* 8209998Ch case    4:*/		return 0x82099990;
		  /* 82099990h */ case    5:  		/* bc 4, CR6_GT, 48 */
		/* 82099990h case    5:*/		if ( !regs.CR[6].gt ) { return 0x820999C0;  }
		/* 82099990h case    5:*/		return 0x82099994;
		  /* 82099994h */ case    6:  		/* mtspr CTR, R5 */
		/* 82099994h case    6:*/		regs.CTR = regs.R5;
		/* 82099994h case    6:*/		return 0x82099998;
		  /* 82099998h */ case    7:  		/* mr R5, R8 */
		/* 82099998h case    7:*/		regs.R5 = regs.R8;
		/* 82099998h case    7:*/		return 0x8209999C;
		  /* 8209999Ch */ case    8:  		/* lbz R10, <#[R9]> */
		/* 8209999Ch case    8:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8209999Ch case    8:*/		return 0x820999A0;
		  /* 820999A0h */ case    9:  		/* cmplwi CR0, R10, 0 */
		/* 820999A0h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 820999A0h case    9:*/		return 0x820999A4;
		  /* 820999A4h */ case   10:  		/* bc 12, CR0_EQ, 12 */
		/* 820999A4h case   10:*/		if ( regs.CR[0].eq ) { return 0x820999B0;  }
		/* 820999A4h case   10:*/		return 0x820999A8;
		  /* 820999A8h */ case   11:  		/* addi R9, R9, 1 */
		/* 820999A8h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820999A8h case   11:*/		return 0x820999AC;
		  /* 820999ACh */ case   12:  		/* b 8 */
		/* 820999ACh case   12:*/		return 0x820999B4;
		/* 820999ACh case   12:*/		return 0x820999B0;
	}
	return 0x820999B0;
} // Block from 8209997Ch-820999B0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820999B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820999B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820999B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820999B0);
		  /* 820999B0h */ case    0:  		/* mr R10, R7 */
		/* 820999B0h case    0:*/		regs.R10 = regs.R7;
		/* 820999B0h case    0:*/		return 0x820999B4;
	}
	return 0x820999B4;
} // Block from 820999B0h-820999B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820999B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820999B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820999B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820999B4);
		  /* 820999B4h */ case    0:  		/* stb R10, <#[R11]> */
		/* 820999B4h case    0:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820999B4h case    0:*/		return 0x820999B8;
		  /* 820999B8h */ case    1:  		/* addi R11, R11, 1 */
		/* 820999B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820999B8h case    1:*/		return 0x820999BC;
		  /* 820999BCh */ case    2:  		/* bc 16, CR0_LT, -32 */
		/* 820999BCh case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209999C;  }
		/* 820999BCh case    2:*/		return 0x820999C0;
	}
	return 0x820999C0;
} // Block from 820999B4h-820999C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820999C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820999C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820999C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820999C0);
		  /* 820999C0h */ case    0:  		/* cmpwi CR6, R5, 0 */
		/* 820999C0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 820999C0h case    0:*/		return 0x820999C4;
		  /* 820999C4h */ case    1:  		/* stb R8, <#[R11]> */
		/* 820999C4h case    1:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820999C4h case    1:*/		return 0x820999C8;
		  /* 820999C8h */ case    2:  		/* bc 12, CR6_LT, 52 */
		/* 820999C8h case    2:*/		if ( regs.CR[6].lt ) { return 0x820999FC;  }
		/* 820999C8h case    2:*/		return 0x820999CC;
		  /* 820999CCh */ case    3:  		/* lbz R10, <#[R9]> */
		/* 820999CCh case    3:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 820999CCh case    3:*/		return 0x820999D0;
		  /* 820999D0h */ case    4:  		/* extsb R10, R10 */
		/* 820999D0h case    4:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 820999D0h case    4:*/		return 0x820999D4;
		  /* 820999D4h */ case    5:  		/* cmpwi CR6, R10, 53 */
		/* 820999D4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000035);
		/* 820999D4h case    5:*/		return 0x820999D8;
		  /* 820999D8h */ case    6:  		/* bc 12, CR6_LT, 36 */
		/* 820999D8h case    6:*/		if ( regs.CR[6].lt ) { return 0x820999FC;  }
		/* 820999D8h case    6:*/		return 0x820999DC;
		  /* 820999DCh */ case    7:  		/* b 8 */
		/* 820999DCh case    7:*/		return 0x820999E4;
		/* 820999DCh case    7:*/		return 0x820999E0;
		  /* 820999E0h */ case    8:  		/* stb R7, <#[R11]> */
		/* 820999E0h case    8:*/		cpu::mem::store8( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 820999E0h case    8:*/		return 0x820999E4;
	}
	return 0x820999E4;
} // Block from 820999C0h-820999E4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820999E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820999E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820999E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820999E4);
		  /* 820999E4h */ case    0:  		/* lbzu R10, <#[R11 - 1]> */
		/* 820999E4h case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0xFFFFFFFF) );
		regs.R11 = (uint32)(regs.R11 + 0xFFFFFFFF);
		/* 820999E4h case    0:*/		return 0x820999E8;
		  /* 820999E8h */ case    1:  		/* cmplwi CR6, R10, 57 */
		/* 820999E8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000039);
		/* 820999E8h case    1:*/		return 0x820999EC;
		  /* 820999ECh */ case    2:  		/* bc 12, CR6_EQ, -12 */
		/* 820999ECh case    2:*/		if ( regs.CR[6].eq ) { return 0x820999E0;  }
		/* 820999ECh case    2:*/		return 0x820999F0;
		  /* 820999F0h */ case    3:  		/* lbz R10, <#[R11]> */
		/* 820999F0h case    3:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820999F0h case    3:*/		return 0x820999F4;
		  /* 820999F4h */ case    4:  		/* addi R10, R10, 1 */
		/* 820999F4h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820999F4h case    4:*/		return 0x820999F8;
		  /* 820999F8h */ case    5:  		/* stb R10, <#[R11]> */
		/* 820999F8h case    5:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820999F8h case    5:*/		return 0x820999FC;
	}
	return 0x820999FC;
} // Block from 820999E4h-820999FCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820999FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820999FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820999FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820999FC);
		  /* 820999FCh */ case    0:  		/* lbz R11, <#[R3]> */
		/* 820999FCh case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820999FCh case    0:*/		return 0x82099A00;
	}
	return 0x82099A00;
} // Block from 820999FCh-82099A00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82099A00h
// Function '_cftof2_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099A00);
		  /* 82099A00h */ case    0:  		/* cmplwi CR6, R11, 49 */
		/* 82099A00h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000031);
		/* 82099A00h case    0:*/		return 0x82099A04;
		  /* 82099A04h */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 82099A04h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82099A18;  }
		/* 82099A04h case    1:*/		return 0x82099A08;
		  /* 82099A08h */ case    2:  		/* lwz R11, <#[R6 + 4]> */
		/* 82099A08h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000004) );
		/* 82099A08h case    2:*/		return 0x82099A0C;
		  /* 82099A0Ch */ case    3:  		/* addi R11, R11, 1 */
		/* 82099A0Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82099A0Ch case    3:*/		return 0x82099A10;
		  /* 82099A10h */ case    4:  		/* stw R11, <#[R6 + 4]> */
		/* 82099A10h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000004) );
		/* 82099A10h case    4:*/		return 0x82099A14;
		  /* 82099A14h */ case    5:  		/* b 44 */
		/* 82099A14h case    5:*/		return 0x82099A40;
		/* 82099A14h case    5:*/		return 0x82099A18;
	}
	return 0x82099A18;
} // Block from 82099A00h-82099A18h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82099A18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099A18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099A18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099A18);
		  /* 82099A18h */ case    0:  		/* mr R11, R4 */
		/* 82099A18h case    0:*/		regs.R11 = regs.R4;
		/* 82099A18h case    0:*/		return 0x82099A1C;
		  /* 82099A1Ch */ case    1:  		/* lbz R10, <#[R11]> */
		/* 82099A1Ch case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82099A1Ch case    1:*/		return 0x82099A20;
		  /* 82099A20h */ case    2:  		/* addi R11, R11, 1 */
		/* 82099A20h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82099A20h case    2:*/		return 0x82099A24;
		  /* 82099A24h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 82099A24h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82099A24h case    3:*/		return 0x82099A28;
		  /* 82099A28h */ case    4:  		/* bc 4, CR6_EQ, -12 */
		/* 82099A28h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82099A1C;  }
		/* 82099A28h case    4:*/		return 0x82099A2C;
		  /* 82099A2Ch */ case    5:  		/* subf R11, R4, R11 */
		/* 82099A2Ch case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R4,regs.R11);
		/* 82099A2Ch case    5:*/		return 0x82099A30;
		  /* 82099A30h */ case    6:  		/* addi R11, R11, -1 */
		/* 82099A30h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82099A30h case    6:*/		return 0x82099A34;
		  /* 82099A34h */ case    7:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 82099A34h case    7:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 82099A34h case    7:*/		return 0x82099A38;
		  /* 82099A38h */ case    8:  		/* addi R5, R11, 1 */
		/* 82099A38h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x1);
		/* 82099A38h case    8:*/		return 0x82099A3C;
		  /* 82099A3Ch */ case    9:  		/* bl -31516 */
		/* 82099A3Ch case    9:*/		regs.LR = 0x82099A40; return 0x82091F20;
		/* 82099A3Ch case    9:*/		return 0x82099A40;
	}
	return 0x82099A40;
} // Block from 82099A18h-82099A40h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82099A40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099A40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099A40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099A40);
		  /* 82099A40h */ case    0:  		/* li R3, 0 */
		/* 82099A40h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82099A40h case    0:*/		return 0x82099A44;
	}
	return 0x82099A44;
} // Block from 82099A40h-82099A44h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82099A44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099A44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099A44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099A44);
		  /* 82099A44h */ case    0:  		/* addi R1, R1, 96 */
		/* 82099A44h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82099A44h case    0:*/		return 0x82099A48;
		  /* 82099A48h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82099A48h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82099A48h case    1:*/		return 0x82099A4C;
		  /* 82099A4Ch */ case    2:  		/* mtspr LR, R12 */
		/* 82099A4Ch case    2:*/		regs.LR = regs.R12;
		/* 82099A4Ch case    2:*/		return 0x82099A50;
		  /* 82099A50h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82099A50h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82099A50h case    3:*/		return 0x82099A54;
		  /* 82099A54h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82099A54h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82099A54h case    4:*/		return 0x82099A58;
	}
	return 0x82099A58;
} // Block from 82099A44h-82099A58h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82099A58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099A58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099A58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099A58);
		  /* 82099A58h */ case    0:  		/* lhz R8, <#[R4]> */
		/* 82099A58h case    0:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000000) );
		/* 82099A58h case    0:*/		return 0x82099A5C;
		  /* 82099A5Ch */ case    1:  		/* lis R10, -32768 */
		/* 82099A5Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8000);
		/* 82099A5Ch case    1:*/		return 0x82099A60;
		  /* 82099A60h */ case    2:  		/* lwz R7, <#[R4]> */
		/* 82099A60h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000000) );
		/* 82099A60h case    2:*/		return 0x82099A64;
		  /* 82099A64h */ case    3:  		/* rlwinm. R11, R8, 28, 21, 31 */
		/* 82099A64h case    3:*/		cpu::op::rlwinm<1,28,21,31>(regs,&regs.R11,regs.R8);
		/* 82099A64h case    3:*/		return 0x82099A68;
		  /* 82099A68h */ case    4:  		/* lwz R9, <#[R4 + 4]> */
		/* 82099A68h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000004) );
		/* 82099A68h case    4:*/		return 0x82099A6C;
		  /* 82099A6Ch */ case    5:  		/* rlwinm R6, R8, 0, 0, 16 */
		/* 82099A6Ch case    5:*/		cpu::op::rlwinm<0,0,0,16>(regs,&regs.R6,regs.R8);
		/* 82099A6Ch case    5:*/		return 0x82099A70;
		  /* 82099A70h */ case    6:  		/* rlwinm R7, R7, 0, 12, 31 */
		/* 82099A70h case    6:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R7,regs.R7);
		/* 82099A70h case    6:*/		return 0x82099A74;
		  /* 82099A74h */ case    7:  		/* mr R8, R11 */
		/* 82099A74h case    7:*/		regs.R8 = regs.R11;
		/* 82099A74h case    7:*/		return 0x82099A78;
		  /* 82099A78h */ case    8:  		/* bc 12, CR0_EQ, 28 */
		/* 82099A78h case    8:*/		if ( regs.CR[0].eq ) { return 0x82099A94;  }
		/* 82099A78h case    8:*/		return 0x82099A7C;
		  /* 82099A7Ch */ case    9:  		/* cmpwi CR6, R11, 2047 */
		/* 82099A7Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x000007FF);
		/* 82099A7Ch case    9:*/		return 0x82099A80;
		  /* 82099A80h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 82099A80h case   10:*/		if ( regs.CR[6].eq ) { return 0x82099A8C;  }
		/* 82099A80h case   10:*/		return 0x82099A84;
		  /* 82099A84h */ case   11:  		/* addi R11, R11, 15360 */
		/* 82099A84h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3C00);
		/* 82099A84h case   11:*/		return 0x82099A88;
		  /* 82099A88h */ case   12:  		/* b 56 */
		/* 82099A88h case   12:*/		return 0x82099AC0;
		/* 82099A88h case   12:*/		return 0x82099A8C;
	}
	return 0x82099A8C;
} // Block from 82099A58h-82099A8Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 82099A8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099A8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099A8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099A8C);
		  /* 82099A8Ch */ case    0:  		/* li R11, 32767 */
		/* 82099A8Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x7FFF);
		/* 82099A8Ch case    0:*/		return 0x82099A90;
		  /* 82099A90h */ case    1:  		/* b 52 */
		/* 82099A90h case    1:*/		return 0x82099AC4;
		/* 82099A90h case    1:*/		return 0x82099A94;
	}
	return 0x82099A94;
} // Block from 82099A8Ch-82099A94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82099A94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099A94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099A94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099A94);
		  /* 82099A94h */ case    0:  		/* cmplwi CR6, R7, 0 */
		/* 82099A94h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82099A94h case    0:*/		return 0x82099A98;
		  /* 82099A98h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 82099A98h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82099AB8;  }
		/* 82099A98h case    1:*/		return 0x82099A9C;
		  /* 82099A9Ch */ case    2:  		/* cmplwi CR6, R9, 0 */
		/* 82099A9Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82099A9Ch case    2:*/		return 0x82099AA0;
		  /* 82099AA0h */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 82099AA0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82099AB8;  }
		/* 82099AA0h case    3:*/		return 0x82099AA4;
		  /* 82099AA4h */ case    4:  		/* li R11, 0 */
		/* 82099AA4h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82099AA4h case    4:*/		return 0x82099AA8;
		  /* 82099AA8h */ case    5:  		/* sth R6, <#[R3]> */
		/* 82099AA8h case    5:*/		cpu::mem::store16( regs, regs.R6, (uint32)(regs.R3 + 0x00000000) );
		/* 82099AA8h case    5:*/		return 0x82099AAC;
		  /* 82099AACh */ case    6:  		/* stw R11, <#[R3 + 2]> */
		/* 82099AACh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000002) );
		/* 82099AACh case    6:*/		return 0x82099AB0;
		  /* 82099AB0h */ case    7:  		/* stw R11, <#[R3 + 6]> */
		/* 82099AB0h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000006) );
		/* 82099AB0h case    7:*/		return 0x82099AB4;
		  /* 82099AB4h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82099AB4h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82099AB4h case    8:*/		return 0x82099AB8;
	}
	return 0x82099AB8;
} // Block from 82099A94h-82099AB8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82099AB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099AB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099AB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099AB8);
		  /* 82099AB8h */ case    0:  		/* addi R11, R11, 15361 */
		/* 82099AB8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3C01);
		/* 82099AB8h case    0:*/		return 0x82099ABC;
		  /* 82099ABCh */ case    1:  		/* li R10, 0 */
		/* 82099ABCh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82099ABCh case    1:*/		return 0x82099AC0;
	}
	return 0x82099AC0;
} // Block from 82099AB8h-82099AC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82099AC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099AC0);
		  /* 82099AC0h */ case    0:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 82099AC0h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 82099AC0h case    0:*/		return 0x82099AC4;
	}
	return 0x82099AC4;
} // Block from 82099AC0h-82099AC4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82099AC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099AC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099AC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099AC4);
		  /* 82099AC4h */ case    0:  		/* rlwinm R8, R9, 11, 21, 31 */
		/* 82099AC4h case    0:*/		cpu::op::rlwinm<0,11,21,31>(regs,&regs.R8,regs.R9);
		/* 82099AC4h case    0:*/		return 0x82099AC8;
		  /* 82099AC8h */ case    1:  		/* rlwinm R7, R7, 11, 0, 20 */
		/* 82099AC8h case    1:*/		cpu::op::rlwinm<0,11,0,20>(regs,&regs.R7,regs.R7);
		/* 82099AC8h case    1:*/		return 0x82099ACC;
		  /* 82099ACCh */ case    2:  		/* rlwinm R9, R9, 11, 0, 20 */
		/* 82099ACCh case    2:*/		cpu::op::rlwinm<0,11,0,20>(regs,&regs.R9,regs.R9);
		/* 82099ACCh case    2:*/		return 0x82099AD0;
		  /* 82099AD0h */ case    3:  		/* or R8, R8, R7 */
		/* 82099AD0h case    3:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 82099AD0h case    3:*/		return 0x82099AD4;
		  /* 82099AD4h */ case    4:  		/* stw R9, <#[R3 + 6]> */
		/* 82099AD4h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000006) );
		/* 82099AD4h case    4:*/		return 0x82099AD8;
		  /* 82099AD8h */ case    5:  		/* or R10, R8, R10 */
		/* 82099AD8h case    5:*/		cpu::op::or<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 82099AD8h case    5:*/		return 0x82099ADC;
		  /* 82099ADCh */ case    6:  		/* rlwinm. R9, R10, 0, 0, 0 */
		/* 82099ADCh case    6:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R9,regs.R10);
		/* 82099ADCh case    6:*/		return 0x82099AE0;
		  /* 82099AE0h */ case    7:  		/* stw R10, <#[R3 + 2]> */
		/* 82099AE0h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000002) );
		/* 82099AE0h case    7:*/		return 0x82099AE4;
		  /* 82099AE4h */ case    8:  		/* bc 4, CR0_EQ, 64 */
		/* 82099AE4h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82099B24;  }
		/* 82099AE4h case    8:*/		return 0x82099AE8;
		  /* 82099AE8h */ case    9:  		/* lwz R10, <#[R3 + 6]> */
		/* 82099AE8h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000006) );
		/* 82099AE8h case    9:*/		return 0x82099AEC;
		  /* 82099AECh */ case   10:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 82099AECh case   10:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 82099AECh case   10:*/		return 0x82099AF0;
		  /* 82099AF0h */ case   11:  		/* lwz R9, <#[R3 + 2]> */
		/* 82099AF0h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000002) );
		/* 82099AF0h case   11:*/		return 0x82099AF4;
		  /* 82099AF4h */ case   12:  		/* rlwinm R8, R10, 1, 31, 31 */
		/* 82099AF4h case   12:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R8,regs.R10);
		/* 82099AF4h case   12:*/		return 0x82099AF8;
		  /* 82099AF8h */ case   13:  		/* rlwinm R9, R9, 1, 0, 30 */
		/* 82099AF8h case   13:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R9);
		/* 82099AF8h case   13:*/		return 0x82099AFC;
		  /* 82099AFCh */ case   14:  		/* rlwinm R10, R10, 1, 0, 30 */
		/* 82099AFCh case   14:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R10);
		/* 82099AFCh case   14:*/		return 0x82099B00;
		  /* 82099B00h */ case   15:  		/* or R9, R8, R9 */
		/* 82099B00h case   15:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82099B00h case   15:*/		return 0x82099B04;
		  /* 82099B04h */ case   16:  		/* addis R11, R11, 1 */
		/* 82099B04h case   16:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82099B04h case   16:*/		return 0x82099B08;
		  /* 82099B08h */ case   17:  		/* stw R10, <#[R3 + 6]> */
		/* 82099B08h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000006) );
		/* 82099B08h case   17:*/		return 0x82099B0C;
		  /* 82099B0Ch */ case   18:  		/* rlwinm R10, R9, 0, 0, 31 */
		/* 82099B0Ch case   18:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R9);
		/* 82099B0Ch case   18:*/		return 0x82099B10;
		  /* 82099B10h */ case   19:  		/* stw R9, <#[R3 + 2]> */
		/* 82099B10h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000002) );
		/* 82099B10h case   19:*/		return 0x82099B14;
		  /* 82099B14h */ case   20:  		/* addi R11, R11, -1 */
		/* 82099B14h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82099B14h case   20:*/		return 0x82099B18;
		  /* 82099B18h */ case   21:  		/* rlwinm. R10, R10, 0, 0, 0 */
		/* 82099B18h case   21:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R10,regs.R10);
		/* 82099B18h case   21:*/		return 0x82099B1C;
		  /* 82099B1Ch */ case   22:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 82099B1Ch case   22:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 82099B1Ch case   22:*/		return 0x82099B20;
		  /* 82099B20h */ case   23:  		/* bc 12, CR0_EQ, -56 */
		/* 82099B20h case   23:*/		if ( regs.CR[0].eq ) { return 0x82099AE8;  }
		/* 82099B20h case   23:*/		return 0x82099B24;
	}
	return 0x82099B24;
} // Block from 82099AC4h-82099B24h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82099B24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099B24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099B24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099B24);
		  /* 82099B24h */ case    0:  		/* rlwinm R10, R6, 0, 16, 31 */
		/* 82099B24h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R6);
		/* 82099B24h case    0:*/		return 0x82099B28;
		  /* 82099B28h */ case    1:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 82099B28h case    1:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 82099B28h case    1:*/		return 0x82099B2C;
		  /* 82099B2Ch */ case    2:  		/* or R11, R10, R11 */
		/* 82099B2Ch case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82099B2Ch case    2:*/		return 0x82099B30;
		  /* 82099B30h */ case    3:  		/* sth R11, <#[R3]> */
		/* 82099B30h case    3:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82099B30h case    3:*/		return 0x82099B34;
		  /* 82099B34h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82099B34h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82099B34h case    4:*/		return 0x82099B38;
	}
	return 0x82099B38;
} // Block from 82099B24h-82099B38h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82099B38h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099B38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099B38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099B38);
		  /* 82099B38h */ case    0:  		/* mfspr R12, LR */
		/* 82099B38h case    0:*/		regs.R12 = regs.LR;
		/* 82099B38h case    0:*/		return 0x82099B3C;
		  /* 82099B3Ch */ case    1:  		/* bl -35040 */
		/* 82099B3Ch case    1:*/		regs.LR = 0x82099B40; return 0x8209125C;
		/* 82099B3Ch case    1:*/		return 0x82099B40;
		  /* 82099B40h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82099B40h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82099B40h case    2:*/		return 0x82099B44;
		  /* 82099B44h */ case    3:  		/* std R3, <#[R1 + 176]> */
		/* 82099B44h case    3:*/		cpu::mem::store64( regs, regs.R3, (uint32)(regs.R1 + 0x000000B0) );
		/* 82099B44h case    3:*/		return 0x82099B48;
		  /* 82099B48h */ case    4:  		/* mr R31, R4 */
		/* 82099B48h case    4:*/		regs.R31 = regs.R4;
		/* 82099B48h case    4:*/		return 0x82099B4C;
		  /* 82099B4Ch */ case    5:  		/* addi R4, R1, 176 */
		/* 82099B4Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xB0);
		/* 82099B4Ch case    5:*/		return 0x82099B50;
		  /* 82099B50h */ case    6:  		/* addi R3, R1, 80 */
		/* 82099B50h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82099B50h case    6:*/		return 0x82099B54;
		  /* 82099B54h */ case    7:  		/* mr R30, R5 */
		/* 82099B54h case    7:*/		regs.R30 = regs.R5;
		/* 82099B54h case    7:*/		return 0x82099B58;
		  /* 82099B58h */ case    8:  		/* mr R29, R6 */
		/* 82099B58h case    8:*/		regs.R29 = regs.R6;
		/* 82099B58h case    8:*/		return 0x82099B5C;
		  /* 82099B5Ch */ case    9:  		/* bl -260 */
		/* 82099B5Ch case    9:*/		regs.LR = 0x82099B60; return 0x82099A58;
		/* 82099B5Ch case    9:*/		return 0x82099B60;
		  /* 82099B60h */ case   10:  		/* lhz R11, <#[R1 + 88]> */
		/* 82099B60h case   10:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82099B60h case   10:*/		return 0x82099B64;
		  /* 82099B64h */ case   11:  		/* addi R7, R1, 96 */
		/* 82099B64h case   11:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 82099B64h case   11:*/		return 0x82099B68;
		  /* 82099B68h */ case   12:  		/* li R6, 0 */
		/* 82099B68h case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82099B68h case   12:*/		return 0x82099B6C;
		  /* 82099B6Ch */ case   13:  		/* li R5, 17 */
		/* 82099B6Ch case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x11);
		/* 82099B6Ch case   13:*/		return 0x82099B70;
		  /* 82099B70h */ case   14:  		/* rldicr R4, R11, 48, 63 */
		/* 82099B70h case   14:*/		cpu::op::rldicr<0,48,63>(regs,&regs.R4,regs.R11);
		/* 82099B70h case   14:*/		return 0x82099B74;
		  /* 82099B74h */ case   15:  		/* ld R3, <#[R1 + 80]> */
		/* 82099B74h case   15:*/		cpu::mem::load64( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 82099B74h case   15:*/		return 0x82099B78;
		  /* 82099B78h */ case   16:  		/* bl 12560 */
		/* 82099B78h case   16:*/		regs.LR = 0x82099B7C; return 0x8209CC88;
		/* 82099B78h case   16:*/		return 0x82099B7C;
		  /* 82099B7Ch */ case   17:  		/* lbz R11, <#[R1 + 98]> */
		/* 82099B7Ch case   17:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000062) );
		/* 82099B7Ch case   17:*/		return 0x82099B80;
		  /* 82099B80h */ case   18:  		/* addi R5, R1, 100 */
		/* 82099B80h case   18:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x64);
		/* 82099B80h case   18:*/		return 0x82099B84;
		  /* 82099B84h */ case   19:  		/* lha R10, <#[R1 + 96]> */
		/* 82099B84h case   19:*/		cpu::mem::load16a( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 82099B84h case   19:*/		return 0x82099B88;
		  /* 82099B88h */ case   20:  		/* mr R4, R29 */
		/* 82099B88h case   20:*/		regs.R4 = regs.R29;
		/* 82099B88h case   20:*/		return 0x82099B8C;
		  /* 82099B8Ch */ case   21:  		/* extsb R11, R11 */
		/* 82099B8Ch case   21:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 82099B8Ch case   21:*/		return 0x82099B90;
		  /* 82099B90h */ case   22:  		/* stw R3, <#[R31 + 8]> */
		/* 82099B90h case   22:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 82099B90h case   22:*/		return 0x82099B94;
		  /* 82099B94h */ case   23:  		/* stw R10, <#[R31 + 4]> */
		/* 82099B94h case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82099B94h case   23:*/		return 0x82099B98;
		  /* 82099B98h */ case   24:  		/* mr R3, R30 */
		/* 82099B98h case   24:*/		regs.R3 = regs.R30;
		/* 82099B98h case   24:*/		return 0x82099B9C;
		  /* 82099B9Ch */ case   25:  		/* stw R11, <#[R31]> */
		/* 82099B9Ch case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82099B9Ch case   25:*/		return 0x82099BA0;
		  /* 82099BA0h */ case   26:  		/* bl -1952 */
		/* 82099BA0h case   26:*/		regs.LR = 0x82099BA4; return 0x82099400;
		/* 82099BA0h case   26:*/		return 0x82099BA4;
		  /* 82099BA4h */ case   27:  		/* cmpwi CR0, R3, 0 */
		/* 82099BA4h case   27:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82099BA4h case   27:*/		return 0x82099BA8;
		  /* 82099BA8h */ case   28:  		/* bc 4, CR0_EQ, 20 */
		/* 82099BA8h case   28:*/		if ( !regs.CR[0].eq ) { return 0x82099BBC;  }
		/* 82099BA8h case   28:*/		return 0x82099BAC;
		  /* 82099BACh */ case   29:  		/* stw R30, <#[R31 + 12]> */
		/* 82099BACh case   29:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 82099BACh case   29:*/		return 0x82099BB0;
		  /* 82099BB0h */ case   30:  		/* mr R3, R31 */
		/* 82099BB0h case   30:*/		regs.R3 = regs.R31;
		/* 82099BB0h case   30:*/		return 0x82099BB4;
		  /* 82099BB4h */ case   31:  		/* addi R1, R1, 160 */
		/* 82099BB4h case   31:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82099BB4h case   31:*/		return 0x82099BB8;
	}
	return 0x82099BB8;
} // Block from 82099B38h-82099BB8h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82099BB8h
// Function '_cftof_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099BB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099BB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099BB8);
		  /* 82099BB8h */ case    0:  		/* b -35084 */
		/* 82099BB8h case    0:*/		return 0x820912AC;
		/* 82099BB8h case    0:*/		return 0x82099BBC;
	}
	return 0x82099BBC;
} // Block from 82099BB8h-82099BBCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82099BBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099BBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099BBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099BBC);
		  /* 82099BBCh */ case    0:  		/* li R7, 0 */
		/* 82099BBCh case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82099BBCh case    0:*/		return 0x82099BC0;
		  /* 82099BC0h */ case    1:  		/* li R6, 0 */
		/* 82099BC0h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82099BC0h case    1:*/		return 0x82099BC4;
		  /* 82099BC4h */ case    2:  		/* li R5, 0 */
		/* 82099BC4h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82099BC4h case    2:*/		return 0x82099BC8;
		  /* 82099BC8h */ case    3:  		/* li R4, 0 */
		/* 82099BC8h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82099BC8h case    3:*/		return 0x82099BCC;
		  /* 82099BCCh */ case    4:  		/* li R3, 0 */
		/* 82099BCCh case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82099BCCh case    4:*/		return 0x82099BD0;
		  /* 82099BD0h */ case    5:  		/* bl -24984 */
		/* 82099BD0h case    5:*/		regs.LR = 0x82099BD4; return 0x82093A38;
		/* 82099BD0h case    5:*/		return 0x82099BD4;
		  /* 82099BD4h */ case    6:  		/* nop */
		/* 82099BD4h case    6:*/		cpu::op::nop();
		/* 82099BD4h case    6:*/		return 0x82099BD8;
	}
	return 0x82099BD8;
} // Block from 82099BBCh-82099BD8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82099BD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099BD8);
		  /* 82099BD8h */ case    0:  		/* li R3, 2 */
		/* 82099BD8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 82099BD8h case    0:*/		return 0x82099BDC;
		  /* 82099BDCh */ case    1:  		/* b -27612 */
		/* 82099BDCh case    1:*/		return 0x82093000;
		/* 82099BDCh case    1:*/		return 0x82099BE0;
	}
	return 0x82099BE0;
} // Block from 82099BD8h-82099BE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82099BE0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099BE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099BE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099BE0);
		  /* 82099BE0h */ case    0:  		/* lis R11, -32215 */
		/* 82099BE0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82099BE0h case    0:*/		return 0x82099BE4;
		  /* 82099BE4h */ case    1:  		/* lwz R3, <#[R11 - 30264]> */
		/* 82099BE4h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFF89C8) );
		/* 82099BE4h case    1:*/		return 0x82099BE8;
		  /* 82099BE8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82099BE8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82099BE8h case    2:*/		return 0x82099BEC;
	}
	return 0x82099BEC;
} // Block from 82099BE0h-82099BECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82099BECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099BEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099BEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099BEC);
		  /* 82099BECh */ case    0:  		/* nop */
		/* 82099BECh case    0:*/		cpu::op::nop();
		/* 82099BECh case    0:*/		return 0x82099BF0;
		  /* 82099BF0h */ case    1:  		/* lwz R17, <#[R6 - 11576]> */
		/* 82099BF0h case    1:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 82099BF0h case    1:*/		return 0x82099BF4;
		  /* 82099BF4h */ case    2:  		/* lwz R16, <#[R4 - 15328]> */
		/* 82099BF4h case    2:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC420) );
		/* 82099BF4h case    2:*/		return 0x82099BF8;
	}
	return 0x82099BF8;
} // Block from 82099BECh-82099BF8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82099BF8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099BF8);
		  /* 82099BF8h */ case    0:  		/* mfspr R12, LR */
		/* 82099BF8h case    0:*/		regs.R12 = regs.LR;
		/* 82099BF8h case    0:*/		return 0x82099BFC;
		  /* 82099BFCh */ case    1:  		/* bl -35244 */
		/* 82099BFCh case    1:*/		regs.LR = 0x82099C00; return 0x82091250;
		/* 82099BFCh case    1:*/		return 0x82099C00;
		  /* 82099C00h */ case    2:  		/* addi R31, R1, -160 */
		/* 82099C00h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFF60);
		/* 82099C00h case    2:*/		return 0x82099C04;
		  /* 82099C04h */ case    3:  		/* stwu R1, <#[R1 - 160]> */
		/* 82099C04h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82099C04h case    3:*/		return 0x82099C08;
		  /* 82099C08h */ case    4:  		/* mr R29, R3 */
		/* 82099C08h case    4:*/		regs.R29 = regs.R3;
		/* 82099C08h case    4:*/		return 0x82099C0C;
		  /* 82099C0Ch */ case    5:  		/* stw R3, <#[R31 + 180]> */
		/* 82099C0Ch case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000000B4) );
		/* 82099C0Ch case    5:*/		return 0x82099C10;
		  /* 82099C10h */ case    6:  		/* li R26, 0 */
		/* 82099C10h case    6:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82099C10h case    6:*/		return 0x82099C14;
		  /* 82099C14h */ case    7:  		/* cmpwi CR6, R3, 11 */
		/* 82099C14h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x0000000B);
		/* 82099C14h case    7:*/		return 0x82099C18;
		  /* 82099C18h */ case    8:  		/* mr R28, R26 */
		/* 82099C18h case    8:*/		regs.R28 = regs.R26;
		/* 82099C18h case    8:*/		return 0x82099C1C;
		  /* 82099C1Ch */ case    9:  		/* mr R27, R26 */
		/* 82099C1Ch case    9:*/		regs.R27 = regs.R26;
		/* 82099C1Ch case    9:*/		return 0x82099C20;
		  /* 82099C20h */ case   10:  		/* stw R26, <#[R31 + 84]> */
		/* 82099C20h case   10:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000054) );
		/* 82099C20h case   10:*/		return 0x82099C24;
		  /* 82099C24h */ case   11:  		/* stw R26, <#[R31 + 88]> */
		/* 82099C24h case   11:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000058) );
		/* 82099C24h case   11:*/		return 0x82099C28;
		  /* 82099C28h */ case   12:  		/* bc 12, CR6_GT, 172 */
		/* 82099C28h case   12:*/		if ( regs.CR[6].gt ) { return 0x82099CD4;  }
		/* 82099C28h case   12:*/		return 0x82099C2C;
		  /* 82099C2Ch */ case   13:  		/* bc 12, CR6_EQ, 36 */
		/* 82099C2Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x82099C50;  }
		/* 82099C2Ch case   13:*/		return 0x82099C30;
		  /* 82099C30h */ case   14:  		/* cmpwi CR6, R3, 2 */
		/* 82099C30h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 82099C30h case   14:*/		return 0x82099C34;
		  /* 82099C34h */ case   15:  		/* bc 12, CR6_EQ, 52 */
		/* 82099C34h case   15:*/		if ( regs.CR[6].eq ) { return 0x82099C68;  }
		/* 82099C34h case   15:*/		return 0x82099C38;
		  /* 82099C38h */ case   16:  		/* cmpwi CR6, R3, 4 */
		/* 82099C38h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000004);
		/* 82099C38h case   16:*/		return 0x82099C3C;
		  /* 82099C3Ch */ case   17:  		/* bc 12, CR6_EQ, 20 */
		/* 82099C3Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x82099C50;  }
		/* 82099C3Ch case   17:*/		return 0x82099C40;
		  /* 82099C40h */ case   18:  		/* cmpwi CR6, R3, 6 */
		/* 82099C40h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000006);
		/* 82099C40h case   18:*/		return 0x82099C44;
		  /* 82099C44h */ case   19:  		/* bc 12, CR6_EQ, 188 */
		/* 82099C44h case   19:*/		if ( regs.CR[6].eq ) { return 0x82099D00;  }
		/* 82099C44h case   19:*/		return 0x82099C48;
		  /* 82099C48h */ case   20:  		/* cmpwi CR6, R3, 8 */
		/* 82099C48h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000008);
		/* 82099C48h case   20:*/		return 0x82099C4C;
		  /* 82099C4Ch */ case   21:  		/* bc 4, CR6_EQ, 160 */
		/* 82099C4Ch case   21:*/		if ( !regs.CR[6].eq ) { return 0x82099CEC;  }
		/* 82099C4Ch case   21:*/		return 0x82099C50;
	}
	return 0x82099C50;
} // Block from 82099BF8h-82099C50h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82099C50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099C50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099C50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099C50);
		  /* 82099C50h */ case    0:  		/* bl -27608 */
		/* 82099C50h case    0:*/		regs.LR = 0x82099C54; return 0x82093078;
		/* 82099C50h case    0:*/		return 0x82099C54;
		  /* 82099C54h */ case    1:  		/* or. R27, R3, R3 */
		/* 82099C54h case    1:*/		cpu::op::or<1>(regs,&regs.R27,regs.R3,regs.R3);
		/* 82099C54h case    1:*/		return 0x82099C58;
		  /* 82099C58h */ case    2:  		/* stw R27, <#[R31 + 88]> */
		/* 82099C58h case    2:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000058) );
		/* 82099C58h case    2:*/		return 0x82099C5C;
		  /* 82099C5Ch */ case    3:  		/* bc 4, CR0_EQ, 28 */
		/* 82099C5Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x82099C78;  }
		/* 82099C5Ch case    3:*/		return 0x82099C60;
		  /* 82099C60h */ case    4:  		/* li R3, -1 */
		/* 82099C60h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82099C60h case    4:*/		return 0x82099C64;
		  /* 82099C64h */ case    5:  		/* b 532 */
		/* 82099C64h case    5:*/		return 0x82099E78;
		/* 82099C64h case    5:*/		return 0x82099C68;
	}
	return 0x82099C68;
} // Block from 82099C50h-82099C68h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82099C68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099C68);
		  /* 82099C68h */ case    0:  		/* lis R11, -32215 */
		/* 82099C68h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82099C68h case    0:*/		return 0x82099C6C;
		  /* 82099C6Ch */ case    1:  		/* addi R30, R11, -30272 */
		/* 82099C6Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFF89C0);
		/* 82099C6Ch case    1:*/		return 0x82099C70;
		  /* 82099C70h */ case    2:  		/* lwz R11, <#[R11 - 30272]> */
		/* 82099C70h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFF89C0) );
		/* 82099C70h case    2:*/		return 0x82099C74;
		  /* 82099C74h */ case    3:  		/* b 196 */
		/* 82099C74h case    3:*/		return 0x82099D38;
		/* 82099C74h case    3:*/		return 0x82099C78;
	}
	return 0x82099C78;
} // Block from 82099C68h-82099C78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82099C78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099C78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099C78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099C78);
		  /* 82099C78h */ case    0:  		/* lwz R10, <#[R27 + 92]> */
		/* 82099C78h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x0000005C) );
		/* 82099C78h case    0:*/		return 0x82099C7C;
		  /* 82099C7Ch */ case    1:  		/* mr R11, R10 */
		/* 82099C7Ch case    1:*/		regs.R11 = regs.R10;
		/* 82099C7Ch case    1:*/		return 0x82099C80;
		  /* 82099C80h */ case    2:  		/* lis R9, -32255 */
		/* 82099C80h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 82099C80h case    2:*/		return 0x82099C84;
		  /* 82099C84h */ case    3:  		/* lwz R8, <#[R9 - 20772]> */
		/* 82099C84h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0xFFFFAEDC) );
		/* 82099C84h case    3:*/		return 0x82099C88;
	}
	return 0x82099C88;
} // Block from 82099C78h-82099C88h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82099C88h
// Function '_cftog_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099C88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099C88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099C88);
		  /* 82099C88h */ case    0:  		/* lwz R9, <#[R11 + 4]> */
		/* 82099C88h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82099C88h case    0:*/		return 0x82099C8C;
		  /* 82099C8Ch */ case    1:  		/* cmpw CR6, R9, R29 */
		/* 82099C8Ch case    1:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R29);
		/* 82099C8Ch case    1:*/		return 0x82099C90;
		  /* 82099C90h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 82099C90h case    2:*/		if ( regs.CR[6].eq ) { return 0x82099CA8;  }
		/* 82099C90h case    2:*/		return 0x82099C94;
		  /* 82099C94h */ case    3:  		/* mulli R9, R8, 12 */
		/* 82099C94h case    3:*/		cpu::op::mulli<0>(regs,&regs.R9,regs.R8,0xC);
		/* 82099C94h case    3:*/		return 0x82099C98;
		  /* 82099C98h */ case    4:  		/* addi R11, R11, 12 */
		/* 82099C98h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xC);
		/* 82099C98h case    4:*/		return 0x82099C9C;
		  /* 82099C9Ch */ case    5:  		/* add R9, R9, R10 */
		/* 82099C9Ch case    5:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 82099C9Ch case    5:*/		return 0x82099CA0;
		  /* 82099CA0h */ case    6:  		/* cmplw CR6, R11, R9 */
		/* 82099CA0h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82099CA0h case    6:*/		return 0x82099CA4;
		  /* 82099CA4h */ case    7:  		/* bc 12, CR6_LT, -28 */
		/* 82099CA4h case    7:*/		if ( regs.CR[6].lt ) { return 0x82099C88;  }
		/* 82099CA4h case    7:*/		return 0x82099CA8;
	}
	return 0x82099CA8;
} // Block from 82099C88h-82099CA8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82099CA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099CA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099CA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099CA8);
		  /* 82099CA8h */ case    0:  		/* mulli R9, R8, 12 */
		/* 82099CA8h case    0:*/		cpu::op::mulli<0>(regs,&regs.R9,regs.R8,0xC);
		/* 82099CA8h case    0:*/		return 0x82099CAC;
		  /* 82099CACh */ case    1:  		/* add R10, R9, R10 */
		/* 82099CACh case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82099CACh case    1:*/		return 0x82099CB0;
		  /* 82099CB0h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 82099CB0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82099CB0h case    2:*/		return 0x82099CB4;
		  /* 82099CB4h */ case    3:  		/* bc 4, CR6_LT, 16 */
		/* 82099CB4h case    3:*/		if ( !regs.CR[6].lt ) { return 0x82099CC4;  }
		/* 82099CB4h case    3:*/		return 0x82099CB8;
		  /* 82099CB8h */ case    4:  		/* lwz R10, <#[R11 + 4]> */
		/* 82099CB8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82099CB8h case    4:*/		return 0x82099CBC;
		  /* 82099CBCh */ case    5:  		/* cmpw CR6, R10, R29 */
		/* 82099CBCh case    5:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R29);
		/* 82099CBCh case    5:*/		return 0x82099CC0;
		  /* 82099CC0h */ case    6:  		/* bc 12, CR6_EQ, 8 */
		/* 82099CC0h case    6:*/		if ( regs.CR[6].eq ) { return 0x82099CC8;  }
		/* 82099CC0h case    6:*/		return 0x82099CC4;
	}
	return 0x82099CC4;
} // Block from 82099CA8h-82099CC4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82099CC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099CC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099CC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099CC4);
		  /* 82099CC4h */ case    0:  		/* mr R11, R26 */
		/* 82099CC4h case    0:*/		regs.R11 = regs.R26;
		/* 82099CC4h case    0:*/		return 0x82099CC8;
	}
	return 0x82099CC8;
} // Block from 82099CC4h-82099CC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82099CC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099CC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099CC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099CC8);
		  /* 82099CC8h */ case    0:  		/* addi R30, R11, 8 */
		/* 82099CC8h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x8);
		/* 82099CC8h case    0:*/		return 0x82099CCC;
		  /* 82099CCCh */ case    1:  		/* lwz R11, <#[R11 + 8]> */
		/* 82099CCCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82099CCCh case    1:*/		return 0x82099CD0;
		  /* 82099CD0h */ case    2:  		/* b 112 */
		/* 82099CD0h case    2:*/		return 0x82099D40;
		/* 82099CD0h case    2:*/		return 0x82099CD4;
	}
	return 0x82099CD4;
} // Block from 82099CC8h-82099CD4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82099CD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099CD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099CD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099CD4);
		  /* 82099CD4h */ case    0:  		/* cmpwi CR6, R29, 15 */
		/* 82099CD4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x0000000F);
		/* 82099CD4h case    0:*/		return 0x82099CD8;
		  /* 82099CD8h */ case    1:  		/* bc 12, CR6_EQ, 80 */
		/* 82099CD8h case    1:*/		if ( regs.CR[6].eq ) { return 0x82099D28;  }
		/* 82099CD8h case    1:*/		return 0x82099CDC;
		  /* 82099CDCh */ case    2:  		/* cmpwi CR6, R29, 21 */
		/* 82099CDCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000015);
		/* 82099CDCh case    2:*/		return 0x82099CE0;
		  /* 82099CE0h */ case    3:  		/* bc 12, CR6_EQ, 52 */
		/* 82099CE0h case    3:*/		if ( regs.CR[6].eq ) { return 0x82099D14;  }
		/* 82099CE0h case    3:*/		return 0x82099CE4;
		  /* 82099CE4h */ case    4:  		/* cmpwi CR6, R29, 22 */
		/* 82099CE4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000016);
		/* 82099CE4h case    4:*/		return 0x82099CE8;
		  /* 82099CE8h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 82099CE8h case    5:*/		if ( regs.CR[6].eq ) { return 0x82099D00;  }
		/* 82099CE8h case    5:*/		return 0x82099CEC;
	}
	return 0x82099CEC;
} // Block from 82099CD4h-82099CECh (6 instructions)

//////////////////////////////////////////////////////
// Block at 82099CECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099CEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099CEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099CEC);
		  /* 82099CECh */ case    0:  		/* bl -19940 */
		/* 82099CECh case    0:*/		regs.LR = 0x82099CF0; return 0x82094F08;
		/* 82099CECh case    0:*/		return 0x82099CF0;
		  /* 82099CF0h */ case    1:  		/* li R11, 22 */
		/* 82099CF0h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 82099CF0h case    1:*/		return 0x82099CF4;
		  /* 82099CF4h */ case    2:  		/* stw R11, <#[R3]> */
		/* 82099CF4h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82099CF4h case    2:*/		return 0x82099CF8;
		  /* 82099CF8h */ case    3:  		/* bl -25496 */
		/* 82099CF8h case    3:*/		regs.LR = 0x82099CFC; return 0x82093960;
		/* 82099CF8h case    3:*/		return 0x82099CFC;
		  /* 82099CFCh */ case    4:  		/* b -156 */
		/* 82099CFCh case    4:*/		return 0x82099C60;
		/* 82099CFCh case    4:*/		return 0x82099D00;
	}
	return 0x82099D00;
} // Block from 82099CECh-82099D00h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82099D00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099D00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099D00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099D00);
		  /* 82099D00h */ case    0:  		/* lis R11, -32215 */
		/* 82099D00h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82099D00h case    0:*/		return 0x82099D04;
		  /* 82099D04h */ case    1:  		/* addi R11, R11, -30272 */
		/* 82099D04h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF89C0);
		/* 82099D04h case    1:*/		return 0x82099D08;
		  /* 82099D08h */ case    2:  		/* addi R30, R11, 8 */
		/* 82099D08h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x8);
		/* 82099D08h case    2:*/		return 0x82099D0C;
		  /* 82099D0Ch */ case    3:  		/* lwz R11, <#[R11 + 8]> */
		/* 82099D0Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82099D0Ch case    3:*/		return 0x82099D10;
		  /* 82099D10h */ case    4:  		/* b 40 */
		/* 82099D10h case    4:*/		return 0x82099D38;
		/* 82099D10h case    4:*/		return 0x82099D14;
	}
	return 0x82099D14;
} // Block from 82099D00h-82099D14h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82099D14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099D14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099D14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099D14);
		  /* 82099D14h */ case    0:  		/* lis R11, -32215 */
		/* 82099D14h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82099D14h case    0:*/		return 0x82099D18;
		  /* 82099D18h */ case    1:  		/* addi R11, R11, -30272 */
		/* 82099D18h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF89C0);
		/* 82099D18h case    1:*/		return 0x82099D1C;
		  /* 82099D1Ch */ case    2:  		/* addi R30, R11, 4 */
		/* 82099D1Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x4);
		/* 82099D1Ch case    2:*/		return 0x82099D20;
		  /* 82099D20h */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 82099D20h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82099D20h case    3:*/		return 0x82099D24;
		  /* 82099D24h */ case    4:  		/* b 20 */
		/* 82099D24h case    4:*/		return 0x82099D38;
		/* 82099D24h case    4:*/		return 0x82099D28;
	}
	return 0x82099D28;
} // Block from 82099D14h-82099D28h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82099D28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099D28);
		  /* 82099D28h */ case    0:  		/* lis R11, -32215 */
		/* 82099D28h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82099D28h case    0:*/		return 0x82099D2C;
		  /* 82099D2Ch */ case    1:  		/* addi R11, R11, -30272 */
		/* 82099D2Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF89C0);
		/* 82099D2Ch case    1:*/		return 0x82099D30;
		  /* 82099D30h */ case    2:  		/* addi R30, R11, 12 */
		/* 82099D30h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xC);
		/* 82099D30h case    2:*/		return 0x82099D34;
		  /* 82099D34h */ case    3:  		/* lwz R11, <#[R11 + 12]> */
		/* 82099D34h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 82099D34h case    3:*/		return 0x82099D38;
	}
	return 0x82099D38;
} // Block from 82099D28h-82099D38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82099D38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099D38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099D38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099D38);
		  /* 82099D38h */ case    0:  		/* li R28, 1 */
		/* 82099D38h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 82099D38h case    0:*/		return 0x82099D3C;
		  /* 82099D3Ch */ case    1:  		/* stw R28, <#[R31 + 84]> */
		/* 82099D3Ch case    1:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000054) );
		/* 82099D3Ch case    1:*/		return 0x82099D40;
	}
	return 0x82099D40;
} // Block from 82099D38h-82099D40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82099D40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099D40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099D40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099D40);
		  /* 82099D40h */ case    0:  		/* stw R11, <#[R31 + 80]> */
		/* 82099D40h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 82099D40h case    0:*/		return 0x82099D44;
		  /* 82099D44h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 82099D44h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82099D44h case    1:*/		return 0x82099D48;
		  /* 82099D48h */ case    2:  		/* bc 12, CR6_EQ, 300 */
		/* 82099D48h case    2:*/		if ( regs.CR[6].eq ) { return 0x82099E74;  }
		/* 82099D48h case    2:*/		return 0x82099D4C;
		  /* 82099D4Ch */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82099D4Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82099D4Ch case    3:*/		return 0x82099D50;
		  /* 82099D50h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 82099D50h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82099D5C;  }
		/* 82099D50h case    4:*/		return 0x82099D54;
		  /* 82099D54h */ case    5:  		/* li R3, 3 */
		/* 82099D54h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 82099D54h case    5:*/		return 0x82099D58;
		  /* 82099D58h */ case    6:  		/* bl -28024 */
		/* 82099D58h case    6:*/		regs.LR = 0x82099D5C; return 0x82092FE0;
		/* 82099D58h case    6:*/		return 0x82099D5C;
	}
	return 0x82099D5C;
} // Block from 82099D40h-82099D5Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82099D5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099D5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099D5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099D5C);
		  /* 82099D5Ch */ case    0:  		/* cmpwi CR6, R28, 0 */
		/* 82099D5Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 82099D5Ch case    0:*/		return 0x82099D60;
		  /* 82099D60h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82099D60h case    1:*/		if ( regs.CR[6].eq ) { return 0x82099D6C;  }
		/* 82099D60h case    1:*/		return 0x82099D64;
		  /* 82099D64h */ case    2:  		/* li R3, 0 */
		/* 82099D64h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82099D64h case    2:*/		return 0x82099D68;
		  /* 82099D68h */ case    3:  		/* bl -2832 */
		/* 82099D68h case    3:*/		regs.LR = 0x82099D6C; return 0x82099258;
		/* 82099D68h case    3:*/		return 0x82099D6C;
	}
	return 0x82099D6C;
} // Block from 82099D5Ch-82099D6Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82099D6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099D6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099D6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099D6C);
		  /* 82099D6Ch */ case    0:  		/* ori R0, R0, 0 */
		/* 82099D6Ch case    0:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82099D6Ch case    0:*/		return 0x82099D70;
		  /* 82099D70h */ case    1:  		/* nop */
		/* 82099D70h case    1:*/		cpu::op::nop();
		/* 82099D70h case    1:*/		return 0x82099D74;
	}
	return 0x82099D74;
} // Block from 82099D6Ch-82099D74h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82099D74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099D74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099D74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099D74);
		  /* 82099D74h */ case    0:  		/* cmpwi CR6, R29, 8 */
		/* 82099D74h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000008);
		/* 82099D74h case    0:*/		return 0x82099D78;
		  /* 82099D78h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 82099D78h case    1:*/		if ( regs.CR[6].eq ) { return 0x82099D8C;  }
		/* 82099D78h case    1:*/		return 0x82099D7C;
		  /* 82099D7Ch */ case    2:  		/* cmpwi CR6, R29, 11 */
		/* 82099D7Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x0000000B);
		/* 82099D7Ch case    2:*/		return 0x82099D80;
		  /* 82099D80h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82099D80h case    3:*/		if ( regs.CR[6].eq ) { return 0x82099D8C;  }
		/* 82099D80h case    3:*/		return 0x82099D84;
		  /* 82099D84h */ case    4:  		/* cmpwi CR6, R29, 4 */
		/* 82099D84h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000004);
		/* 82099D84h case    4:*/		return 0x82099D88;
		  /* 82099D88h */ case    5:  		/* bc 4, CR6_EQ, 40 */
		/* 82099D88h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82099DB0;  }
		/* 82099D88h case    5:*/		return 0x82099D8C;
	}
	return 0x82099D8C;
} // Block from 82099D74h-82099D8Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82099D8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099D8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099D8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099D8C);
		  /* 82099D8Ch */ case    0:  		/* lwz R11, <#[R27 + 96]> */
		/* 82099D8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000060) );
		/* 82099D8Ch case    0:*/		return 0x82099D90;
		  /* 82099D90h */ case    1:  		/* cmpwi CR6, R29, 8 */
		/* 82099D90h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000008);
		/* 82099D90h case    1:*/		return 0x82099D94;
		  /* 82099D94h */ case    2:  		/* stw R11, <#[R31 + 96]> */
		/* 82099D94h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 82099D94h case    2:*/		return 0x82099D98;
		  /* 82099D98h */ case    3:  		/* stw R26, <#[R27 + 96]> */
		/* 82099D98h case    3:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R27 + 0x00000060) );
		/* 82099D98h case    3:*/		return 0x82099D9C;
		  /* 82099D9Ch */ case    4:  		/* bc 4, CR6_EQ, 100 */
		/* 82099D9Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x82099E00;  }
		/* 82099D9Ch case    4:*/		return 0x82099DA0;
		  /* 82099DA0h */ case    5:  		/* lwz R11, <#[R27 + 100]> */
		/* 82099DA0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000064) );
		/* 82099DA0h case    5:*/		return 0x82099DA4;
		  /* 82099DA4h */ case    6:  		/* li R10, 140 */
		/* 82099DA4h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x8C);
		/* 82099DA4h case    6:*/		return 0x82099DA8;
		  /* 82099DA8h */ case    7:  		/* stw R11, <#[R31 + 100]> */
		/* 82099DA8h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000064) );
		/* 82099DA8h case    7:*/		return 0x82099DAC;
		  /* 82099DACh */ case    8:  		/* stw R10, <#[R27 + 100]> */
		/* 82099DACh case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R27 + 0x00000064) );
		/* 82099DACh case    8:*/		return 0x82099DB0;
	}
	return 0x82099DB0;
} // Block from 82099D8Ch-82099DB0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82099DB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099DB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099DB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099DB0);
		  /* 82099DB0h */ case    0:  		/* cmpwi CR6, R29, 8 */
		/* 82099DB0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000008);
		/* 82099DB0h case    0:*/		return 0x82099DB4;
		  /* 82099DB4h */ case    1:  		/* bc 4, CR6_EQ, 76 */
		/* 82099DB4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82099E00;  }
		/* 82099DB4h case    1:*/		return 0x82099DB8;
	}
	return 0x82099DB8;
} // Block from 82099DB0h-82099DB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82099DB8h
// Function '_cfltcvt_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099DB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099DB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099DB8);
		  /* 82099DB8h */ case    0:  		/* lis R8, -32255 */
		/* 82099DB8h case    0:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8201);
		/* 82099DB8h case    0:*/		return 0x82099DBC;
		  /* 82099DBCh */ case    1:  		/* lis R7, -32255 */
		/* 82099DBCh case    1:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8201);
		/* 82099DBCh case    1:*/		return 0x82099DC0;
		  /* 82099DC0h */ case    2:  		/* lwz R10, <#[R8 - 20784]> */
		/* 82099DC0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0xFFFFAED0) );
		/* 82099DC0h case    2:*/		return 0x82099DC4;
		  /* 82099DC4h */ case    3:  		/* mr R11, R10 */
		/* 82099DC4h case    3:*/		regs.R11 = regs.R10;
		/* 82099DC4h case    3:*/		return 0x82099DC8;
		  /* 82099DC8h */ case    4:  		/* stw R10, <#[R31 + 92]> */
		/* 82099DC8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000005C) );
		/* 82099DC8h case    4:*/		return 0x82099DCC;
		  /* 82099DCCh */ case    5:  		/* lwz R9, <#[R7 - 20780]> */
		/* 82099DCCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0xFFFFAED4) );
		/* 82099DCCh case    5:*/		return 0x82099DD0;
		  /* 82099DD0h */ case    6:  		/* add R10, R9, R10 */
		/* 82099DD0h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82099DD0h case    6:*/		return 0x82099DD4;
		  /* 82099DD4h */ case    7:  		/* cmpw CR6, R11, R10 */
		/* 82099DD4h case    7:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82099DD4h case    7:*/		return 0x82099DD8;
		  /* 82099DD8h */ case    8:  		/* bc 4, CR6_LT, 44 */
		/* 82099DD8h case    8:*/		if ( !regs.CR[6].lt ) { return 0x82099E04;  }
		/* 82099DD8h case    8:*/		return 0x82099DDC;
		  /* 82099DDCh */ case    9:  		/* lwz R9, <#[R27 + 92]> */
		/* 82099DDCh case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x0000005C) );
		/* 82099DDCh case    9:*/		return 0x82099DE0;
		  /* 82099DE0h */ case   10:  		/* mulli R10, R11, 12 */
		/* 82099DE0h case   10:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R11,0xC);
		/* 82099DE0h case   10:*/		return 0x82099DE4;
		  /* 82099DE4h */ case   11:  		/* add R10, R10, R9 */
		/* 82099DE4h case   11:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82099DE4h case   11:*/		return 0x82099DE8;
		  /* 82099DE8h */ case   12:  		/* stw R26, <#[R10 + 8]> */
		/* 82099DE8h case   12:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R10 + 0x00000008) );
		/* 82099DE8h case   12:*/		return 0x82099DEC;
		  /* 82099DECh */ case   13:  		/* nop */
		/* 82099DECh case   13:*/		cpu::op::nop();
		/* 82099DECh case   13:*/		return 0x82099DF0;
		  /* 82099DF0h */ case   14:  		/* addi R11, R11, 1 */
		/* 82099DF0h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82099DF0h case   14:*/		return 0x82099DF4;
		  /* 82099DF4h */ case   15:  		/* stw R11, <#[R31 + 92]> */
		/* 82099DF4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 82099DF4h case   15:*/		return 0x82099DF8;
		  /* 82099DF8h */ case   16:  		/* lwz R10, <#[R8 - 20784]> */
		/* 82099DF8h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0xFFFFAED0) );
		/* 82099DF8h case   16:*/		return 0x82099DFC;
		  /* 82099DFCh */ case   17:  		/* b -48 */
		/* 82099DFCh case   17:*/		return 0x82099DCC;
		/* 82099DFCh case   17:*/		return 0x82099E00;
	}
	return 0x82099E00;
} // Block from 82099DB8h-82099E00h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82099E00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099E00);
		  /* 82099E00h */ case    0:  		/* stw R26, <#[R30]> */
		/* 82099E00h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000000) );
		/* 82099E00h case    0:*/		return 0x82099E04;
	}
	return 0x82099E04;
} // Block from 82099E00h-82099E04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82099E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099E04);
		  /* 82099E04h */ case    0:  		/* nop */
		/* 82099E04h case    0:*/		cpu::op::nop();
		/* 82099E04h case    0:*/		return 0x82099E08;
	}
	return 0x82099E08;
} // Block from 82099E04h-82099E08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82099E08h
// Function '_cfltcvt'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099E08);
		  /* 82099E08h */ case    0:  		/* addi R12, R31, 160 */
		/* 82099E08h case    0:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R31,0xA0);
		/* 82099E08h case    0:*/		return 0x82099E0C;
		  /* 82099E0Ch */ case    1:  		/* bl 148 */
		/* 82099E0Ch case    1:*/		regs.LR = 0x82099E10; return 0x82099EA0;
		/* 82099E0Ch case    1:*/		return 0x82099E10;
		  /* 82099E10h */ case    2:  		/* lwz R30, <#[R31 + 180]> */
		/* 82099E10h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x000000B4) );
		/* 82099E10h case    2:*/		return 0x82099E14;
		  /* 82099E14h */ case    3:  		/* cmpwi CR6, R30, 8 */
		/* 82099E14h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000008);
		/* 82099E14h case    3:*/		return 0x82099E18;
		  /* 82099E18h */ case    4:  		/* lwz R11, <#[R31 + 80]> */
		/* 82099E18h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 82099E18h case    4:*/		return 0x82099E1C;
		  /* 82099E1Ch */ case    5:  		/* mtspr CTR, R11 */
		/* 82099E1Ch case    5:*/		regs.CTR = regs.R11;
		/* 82099E1Ch case    5:*/		return 0x82099E20;
		  /* 82099E20h */ case    6:  		/* bc 4, CR6_EQ, 24 */
		/* 82099E20h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82099E38;  }
		/* 82099E20h case    6:*/		return 0x82099E24;
		  /* 82099E24h */ case    7:  		/* li R3, 8 */
		/* 82099E24h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x8);
		/* 82099E24h case    7:*/		return 0x82099E28;
		  /* 82099E28h */ case    8:  		/* lwz R29, <#[R31 + 88]> */
		/* 82099E28h case    8:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000058) );
		/* 82099E28h case    8:*/		return 0x82099E2C;
		  /* 82099E2Ch */ case    9:  		/* lwz R4, <#[R29 + 100]> */
		/* 82099E2Ch case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000064) );
		/* 82099E2Ch case    9:*/		return 0x82099E30;
		  /* 82099E30h */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 82099E30h case   10:*/		if ( 1 ) { regs.LR = 0x82099E34; return (uint32)regs.CTR; }
		/* 82099E30h case   10:*/		return 0x82099E34;
		  /* 82099E34h */ case   11:  		/* b 16 */
		/* 82099E34h case   11:*/		return 0x82099E44;
		/* 82099E34h case   11:*/		return 0x82099E38;
	}
	return 0x82099E38;
} // Block from 82099E08h-82099E38h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82099E38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099E38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099E38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099E38);
		  /* 82099E38h */ case    0:  		/* mr R3, R30 */
		/* 82099E38h case    0:*/		regs.R3 = regs.R30;
		/* 82099E38h case    0:*/		return 0x82099E3C;
		  /* 82099E3Ch */ case    1:  		/* bcctrl 20, CR0_LT */
		/* 82099E3Ch case    1:*/		if ( 1 ) { regs.LR = 0x82099E40; return (uint32)regs.CTR; }
		/* 82099E3Ch case    1:*/		return 0x82099E40;
		  /* 82099E40h */ case    2:  		/* lwz R29, <#[R31 + 88]> */
		/* 82099E40h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000058) );
		/* 82099E40h case    2:*/		return 0x82099E44;
	}
	return 0x82099E44;
} // Block from 82099E38h-82099E44h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82099E44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099E44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099E44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099E44);
		  /* 82099E44h */ case    0:  		/* cmpwi CR6, R30, 8 */
		/* 82099E44h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000008);
		/* 82099E44h case    0:*/		return 0x82099E48;
		  /* 82099E48h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 82099E48h case    1:*/		if ( regs.CR[6].eq ) { return 0x82099E5C;  }
		/* 82099E48h case    1:*/		return 0x82099E4C;
		  /* 82099E4Ch */ case    2:  		/* cmpwi CR6, R30, 11 */
		/* 82099E4Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x0000000B);
		/* 82099E4Ch case    2:*/		return 0x82099E50;
		  /* 82099E50h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82099E50h case    3:*/		if ( regs.CR[6].eq ) { return 0x82099E5C;  }
		/* 82099E50h case    3:*/		return 0x82099E54;
		  /* 82099E54h */ case    4:  		/* cmpwi CR6, R30, 4 */
		/* 82099E54h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 82099E54h case    4:*/		return 0x82099E58;
		  /* 82099E58h */ case    5:  		/* bc 4, CR6_EQ, 28 */
		/* 82099E58h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82099E74;  }
		/* 82099E58h case    5:*/		return 0x82099E5C;
	}
	return 0x82099E5C;
} // Block from 82099E44h-82099E5Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82099E5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099E5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099E5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099E5C);
		  /* 82099E5Ch */ case    0:  		/* lwz R11, <#[R31 + 96]> */
		/* 82099E5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 82099E5Ch case    0:*/		return 0x82099E60;
	}
	return 0x82099E60;
} // Block from 82099E5Ch-82099E60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82099E60h
// Function 'strcpy_s'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099E60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099E60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099E60);
		  /* 82099E60h */ case    0:  		/* cmpwi CR6, R30, 8 */
		/* 82099E60h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000008);
		/* 82099E60h case    0:*/		return 0x82099E64;
		  /* 82099E64h */ case    1:  		/* stw R11, <#[R29 + 96]> */
		/* 82099E64h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000060) );
		/* 82099E64h case    1:*/		return 0x82099E68;
		  /* 82099E68h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 82099E68h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82099E74;  }
		/* 82099E68h case    2:*/		return 0x82099E6C;
		  /* 82099E6Ch */ case    3:  		/* lwz R11, <#[R31 + 100]> */
		/* 82099E6Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000064) );
		/* 82099E6Ch case    3:*/		return 0x82099E70;
		  /* 82099E70h */ case    4:  		/* stw R11, <#[R29 + 100]> */
		/* 82099E70h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000064) );
		/* 82099E70h case    4:*/		return 0x82099E74;
	}
	return 0x82099E74;
} // Block from 82099E60h-82099E74h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82099E74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099E74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099E74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099E74);
		  /* 82099E74h */ case    0:  		/* li R3, 0 */
		/* 82099E74h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82099E74h case    0:*/		return 0x82099E78;
	}
	return 0x82099E78;
} // Block from 82099E74h-82099E78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82099E78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099E78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099E78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099E78);
		  /* 82099E78h */ case    0:  		/* addi R1, R31, 160 */
		/* 82099E78h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0xA0);
		/* 82099E78h case    0:*/		return 0x82099E7C;
		  /* 82099E7Ch */ case    1:  		/* b -35804 */
		/* 82099E7Ch case    1:*/		return 0x820912A0;
		/* 82099E7Ch case    1:*/		return 0x82099E80;
	}
	return 0x82099E80;
} // Block from 82099E78h-82099E80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82099E80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099E80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099E80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099E80);
		  /* 82099E80h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 82099E80h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82099E80h case    0:*/		return 0x82099E84;
		  /* 82099E84h */ case    1:  		/* addi R31, R12, -160 */
		/* 82099E84h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFF60);
		/* 82099E84h case    1:*/		return 0x82099E88;
		  /* 82099E88h */ case    2:  		/* std R28, <#[R1 - 16]> */
		/* 82099E88h case    2:*/		cpu::mem::store64( regs, regs.R28, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82099E88h case    2:*/		return 0x82099E8C;
		  /* 82099E8Ch */ case    3:  		/* mfspr R12, LR */
		/* 82099E8Ch case    3:*/		regs.R12 = regs.LR;
		/* 82099E8Ch case    3:*/		return 0x82099E90;
		  /* 82099E90h */ case    4:  		/* stw R12, <#[R1 - 24]> */
		/* 82099E90h case    4:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82099E90h case    4:*/		return 0x82099E94;
		  /* 82099E94h */ case    5:  		/* stwu R1, <#[R1 - 112]> */
		/* 82099E94h case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82099E94h case    5:*/		return 0x82099E98;
		  /* 82099E98h */ case    6:  		/* lwz R28, <#[R31 + 84]> */
		/* 82099E98h case    6:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000054) );
		/* 82099E98h case    6:*/		return 0x82099E9C;
		  /* 82099E9Ch */ case    7:  		/* b 28 */
		/* 82099E9Ch case    7:*/		return 0x82099EB8;
		/* 82099E9Ch case    7:*/		return 0x82099EA0;
	}
	return 0x82099EA0;
} // Block from 82099E80h-82099EA0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82099EA0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099EA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099EA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099EA0);
		  /* 82099EA0h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 82099EA0h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82099EA0h case    0:*/		return 0x82099EA4;
		  /* 82099EA4h */ case    1:  		/* addi R31, R12, -160 */
		/* 82099EA4h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFF60);
		/* 82099EA4h case    1:*/		return 0x82099EA8;
		  /* 82099EA8h */ case    2:  		/* std R28, <#[R1 - 16]> */
		/* 82099EA8h case    2:*/		cpu::mem::store64( regs, regs.R28, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82099EA8h case    2:*/		return 0x82099EAC;
		  /* 82099EACh */ case    3:  		/* mfspr R12, LR */
		/* 82099EACh case    3:*/		regs.R12 = regs.LR;
		/* 82099EACh case    3:*/		return 0x82099EB0;
		  /* 82099EB0h */ case    4:  		/* stw R12, <#[R1 - 24]> */
		/* 82099EB0h case    4:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82099EB0h case    4:*/		return 0x82099EB4;
		  /* 82099EB4h */ case    5:  		/* stwu R1, <#[R1 - 112]> */
		/* 82099EB4h case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82099EB4h case    5:*/		return 0x82099EB8;
	}
	return 0x82099EB8;
} // Block from 82099EA0h-82099EB8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82099EB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099EB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099EB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099EB8);
		  /* 82099EB8h */ case    0:  		/* cmpwi CR6, R28, 0 */
		/* 82099EB8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 82099EB8h case    0:*/		return 0x82099EBC;
		  /* 82099EBCh */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82099EBCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82099EC8;  }
		/* 82099EBCh case    1:*/		return 0x82099EC0;
		  /* 82099EC0h */ case    2:  		/* li R3, 0 */
		/* 82099EC0h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82099EC0h case    2:*/		return 0x82099EC4;
		  /* 82099EC4h */ case    3:  		/* bl -3820 */
		/* 82099EC4h case    3:*/		regs.LR = 0x82099EC8; return 0x82098FD8;
		/* 82099EC4h case    3:*/		return 0x82099EC8;
	}
	return 0x82099EC8;
} // Block from 82099EB8h-82099EC8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82099EC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099EC8);
		  /* 82099EC8h */ case    0:  		/* lwz R1, <#[R1]> */
		/* 82099EC8h case    0:*/		cpu::mem::load32z( regs, &regs.R1, (uint32)(regs.R1 + 0x00000000) );
		/* 82099EC8h case    0:*/		return 0x82099ECC;
		  /* 82099ECCh */ case    1:  		/* ld R31, <#[R1 - 8]> */
		/* 82099ECCh case    1:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82099ECCh case    1:*/		return 0x82099ED0;
		  /* 82099ED0h */ case    2:  		/* ld R28, <#[R1 - 16]> */
		/* 82099ED0h case    2:*/		cpu::mem::load64( regs, &regs.R28, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82099ED0h case    2:*/		return 0x82099ED4;
		  /* 82099ED4h */ case    3:  		/* lwz R12, <#[R1 - 24]> */
		/* 82099ED4h case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82099ED4h case    3:*/		return 0x82099ED8;
		  /* 82099ED8h */ case    4:  		/* mtspr LR, R12 */
		/* 82099ED8h case    4:*/		regs.LR = regs.R12;
		/* 82099ED8h case    4:*/		return 0x82099EDC;
		  /* 82099EDCh */ case    5:  		/* bclr 20, CR0_LT */
		/* 82099EDCh case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82099EDCh case    5:*/		return 0x82099EE0;
	}
	return 0x82099EE0;
} // Block from 82099EC8h-82099EE0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82099EE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099EE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099EE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099EE0);
		  /* 82099EE0h */ case    0:  		/* mfspr R12, LR */
		/* 82099EE0h case    0:*/		regs.R12 = regs.LR;
		/* 82099EE0h case    0:*/		return 0x82099EE4;
		  /* 82099EE4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82099EE4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82099EE4h case    1:*/		return 0x82099EE8;
		  /* 82099EE8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82099EE8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82099EE8h case    2:*/		return 0x82099EEC;
		  /* 82099EECh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82099EECh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82099EECh case    3:*/		return 0x82099EF0;
		  /* 82099EF0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82099EF0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82099EF0h case    4:*/		return 0x82099EF4;
		  /* 82099EF4h */ case    5:  		/* std R4, <#[R1 + 80]> */
		/* 82099EF4h case    5:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 82099EF4h case    5:*/		return 0x82099EF8;
		  /* 82099EF8h */ case    6:  		/* mr R31, R3 */
		/* 82099EF8h case    6:*/		regs.R31 = regs.R3;
		/* 82099EF8h case    6:*/		return 0x82099EFC;
		  /* 82099EFCh */ case    7:  		/* mr R30, R5 */
		/* 82099EFCh case    7:*/		regs.R30 = regs.R5;
		/* 82099EFCh case    7:*/		return 0x82099F00;
		  /* 82099F00h */ case    8:  		/* bl 14888 */
		/* 82099F00h case    8:*/		regs.LR = 0x82099F04; return 0x8209D928;
		/* 82099F00h case    8:*/		return 0x82099F04;
		  /* 82099F04h */ case    9:  		/* cmpwi CR6, R3, -1 */
		/* 82099F04h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82099F04h case    9:*/		return 0x82099F08;
		  /* 82099F08h */ case   10:  		/* bc 4, CR6_EQ, 28 */
		/* 82099F08h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82099F24;  }
		/* 82099F08h case   10:*/		return 0x82099F0C;
		  /* 82099F0Ch */ case   11:  		/* bl -20484 */
		/* 82099F0Ch case   11:*/		regs.LR = 0x82099F10; return 0x82094F08;
		/* 82099F0Ch case   11:*/		return 0x82099F10;
		  /* 82099F10h */ case   12:  		/* mr R11, R3 */
		/* 82099F10h case   12:*/		regs.R11 = regs.R3;
		/* 82099F10h case   12:*/		return 0x82099F14;
		  /* 82099F14h */ case   13:  		/* li R10, 9 */
		/* 82099F14h case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x9);
		/* 82099F14h case   13:*/		return 0x82099F18;
	}
	return 0x82099F18;
} // Block from 82099EE0h-82099F18h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82099F18h
// Function '_CxxThrowException'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099F18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099F18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099F18);
		  /* 82099F18h */ case    0:  		/* li R3, -1 */
		/* 82099F18h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82099F18h case    0:*/		return 0x82099F1C;
		  /* 82099F1Ch */ case    1:  		/* stw R10, <#[R11]> */
		/* 82099F1Ch case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82099F1Ch case    1:*/		return 0x82099F20;
		  /* 82099F20h */ case    2:  		/* b 112 */
		/* 82099F20h case    2:*/		return 0x82099F90;
		/* 82099F20h case    2:*/		return 0x82099F24;
	}
	return 0x82099F24;
} // Block from 82099F18h-82099F24h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82099F24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099F24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099F24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099F24);
		  /* 82099F24h */ case    0:  		/* mr R6, R30 */
		/* 82099F24h case    0:*/		regs.R6 = regs.R30;
		/* 82099F24h case    0:*/		return 0x82099F28;
		  /* 82099F28h */ case    1:  		/* lwz R4, <#[R1 + 84]> */
		/* 82099F28h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 82099F28h case    1:*/		return 0x82099F2C;
		  /* 82099F2Ch */ case    2:  		/* addi R5, R1, 80 */
		/* 82099F2Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82099F2Ch case    2:*/		return 0x82099F30;
		  /* 82099F30h */ case    3:  		/* bl -71224 */
		/* 82099F30h case    3:*/		regs.LR = 0x82099F34; return 0x820888F8;
		/* 82099F30h case    3:*/		return 0x82099F34;
		  /* 82099F34h */ case    4:  		/* stw R3, <#[R1 + 84]> */
		/* 82099F34h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 82099F34h case    4:*/		return 0x82099F38;
		  /* 82099F38h */ case    5:  		/* cmpwi CR6, R3, -1 */
		/* 82099F38h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82099F38h case    5:*/		return 0x82099F3C;
		  /* 82099F3Ch */ case    6:  		/* bc 4, CR6_EQ, 28 */
		/* 82099F3Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x82099F58;  }
		/* 82099F3Ch case    6:*/		return 0x82099F40;
		  /* 82099F40h */ case    7:  		/* bl -63552 */
		/* 82099F40h case    7:*/		regs.LR = 0x82099F44; return 0x8208A700;
		/* 82099F40h case    7:*/		return 0x82099F44;
		  /* 82099F44h */ case    8:  		/* cmplwi CR0, R3, 0 */
		/* 82099F44h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82099F44h case    8:*/		return 0x82099F48;
		  /* 82099F48h */ case    9:  		/* bc 12, CR0_EQ, 16 */
		/* 82099F48h case    9:*/		if ( regs.CR[0].eq ) { return 0x82099F58;  }
		/* 82099F48h case    9:*/		return 0x82099F4C;
		  /* 82099F4Ch */ case   10:  		/* bl -20436 */
		/* 82099F4Ch case   10:*/		regs.LR = 0x82099F50; return 0x82094F78;
		/* 82099F4Ch case   10:*/		return 0x82099F50;
		  /* 82099F50h */ case   11:  		/* li R3, -1 */
		/* 82099F50h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82099F50h case   11:*/		return 0x82099F54;
		  /* 82099F54h */ case   12:  		/* b 60 */
		/* 82099F54h case   12:*/		return 0x82099F90;
		/* 82099F54h case   12:*/		return 0x82099F58;
	}
	return 0x82099F58;
} // Block from 82099F24h-82099F58h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82099F58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099F58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099F58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099F58);
		  /* 82099F58h */ case    0:  		/* srawi R11, R31, 5 */
		/* 82099F58h case    0:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R31);
		/* 82099F58h case    0:*/		return 0x82099F5C;
		  /* 82099F5Ch */ case    1:  		/* lis R10, -32215 */
		/* 82099F5Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 82099F5Ch case    1:*/		return 0x82099F60;
		  /* 82099F60h */ case    2:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 82099F60h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 82099F60h case    2:*/		return 0x82099F64;
		  /* 82099F64h */ case    3:  		/* addi R10, R10, -25504 */
		/* 82099F64h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFF9C60);
		/* 82099F64h case    3:*/		return 0x82099F68;
		  /* 82099F68h */ case    4:  		/* rlwinm R11, R31, 0, 27, 31 */
		/* 82099F68h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R31);
		/* 82099F68h case    4:*/		return 0x82099F6C;
		  /* 82099F6Ch */ case    5:  		/* mulli R11, R11, 72 */
		/* 82099F6Ch case    5:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x48);
		/* 82099F6Ch case    5:*/		return 0x82099F70;
		  /* 82099F70h */ case    6:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82099F70h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82099F70h case    6:*/		return 0x82099F74;
		  /* 82099F74h */ case    7:  		/* add R11, R10, R11 */
		/* 82099F74h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82099F74h case    7:*/		return 0x82099F78;
		  /* 82099F78h */ case    8:  		/* addi R10, R11, 4 */
		/* 82099F78h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82099F78h case    8:*/		return 0x82099F7C;
		  /* 82099F7Ch */ case    9:  		/* lbz R10, <#[R11 + 4]> */
		/* 82099F7Ch case    9:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82099F7Ch case    9:*/		return 0x82099F80;
		  /* 82099F80h */ case   10:  		/* extsb R10, R10 */
		/* 82099F80h case   10:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 82099F80h case   10:*/		return 0x82099F84;
		  /* 82099F84h */ case   11:  		/* rlwinm R10, R10, 0, 31, 29 */
		/* 82099F84h case   11:*/		cpu::op::rlwinm<0,0,31,29>(regs,&regs.R10,regs.R10);
		/* 82099F84h case   11:*/		return 0x82099F88;
		  /* 82099F88h */ case   12:  		/* stb R10, <#[R11 + 4]> */
		/* 82099F88h case   12:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82099F88h case   12:*/		return 0x82099F8C;
		  /* 82099F8Ch */ case   13:  		/* ld R3, <#[R1 + 80]> */
		/* 82099F8Ch case   13:*/		cpu::mem::load64( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 82099F8Ch case   13:*/		return 0x82099F90;
	}
	return 0x82099F90;
} // Block from 82099F58h-82099F90h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82099F90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099F90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099F90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099F90);
		  /* 82099F90h */ case    0:  		/* addi R1, R1, 112 */
		/* 82099F90h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82099F90h case    0:*/		return 0x82099F94;
		  /* 82099F94h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82099F94h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82099F94h case    1:*/		return 0x82099F98;
		  /* 82099F98h */ case    2:  		/* mtspr LR, R12 */
		/* 82099F98h case    2:*/		regs.LR = regs.R12;
		/* 82099F98h case    2:*/		return 0x82099F9C;
		  /* 82099F9Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82099F9Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82099F9Ch case    3:*/		return 0x82099FA0;
	}
	return 0x82099FA0;
} // Block from 82099F90h-82099FA0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82099FA0h
// Function '??_Etype_info@@UAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099FA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099FA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099FA0);
		  /* 82099FA0h */ case    0:  		/* ld R31, <#[R1 - 16]> */
		/* 82099FA0h case    0:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82099FA0h case    0:*/		return 0x82099FA4;
		  /* 82099FA4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82099FA4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82099FA4h case    1:*/		return 0x82099FA8;
	}
	return 0x82099FA8;
} // Block from 82099FA0h-82099FA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82099FA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099FA8);
		  /* 82099FA8h */ case    0:  		/* lwz R17, <#[R6 - 11576]> */
		/* 82099FA8h case    0:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 82099FA8h case    0:*/		return 0x82099FAC;
		  /* 82099FACh */ case    1:  		/* lwz R16, <#[R4 - 15304]> */
		/* 82099FACh case    1:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC438) );
		/* 82099FACh case    1:*/		return 0x82099FB0;
	}
	return 0x82099FB0;
} // Block from 82099FA8h-82099FB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82099FB0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099FB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099FB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099FB0);
		  /* 82099FB0h */ case    0:  		/* mfspr R12, LR */
		/* 82099FB0h case    0:*/		regs.R12 = regs.LR;
		/* 82099FB0h case    0:*/		return 0x82099FB4;
		  /* 82099FB4h */ case    1:  		/* bl -36204 */
		/* 82099FB4h case    1:*/		regs.LR = 0x82099FB8; return 0x82091248;
		/* 82099FB4h case    1:*/		return 0x82099FB8;
		  /* 82099FB8h */ case    2:  		/* addi R31, R1, -160 */
		/* 82099FB8h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFF60);
		/* 82099FB8h case    2:*/		return 0x82099FBC;
		  /* 82099FBCh */ case    3:  		/* stwu R1, <#[R1 - 160]> */
		/* 82099FBCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82099FBCh case    3:*/		return 0x82099FC0;
		  /* 82099FC0h */ case    4:  		/* mr R30, R3 */
		/* 82099FC0h case    4:*/		regs.R30 = regs.R3;
		/* 82099FC0h case    4:*/		return 0x82099FC4;
		  /* 82099FC4h */ case    5:  		/* stw R3, <#[R31 + 180]> */
		/* 82099FC4h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000000B4) );
		/* 82099FC4h case    5:*/		return 0x82099FC8;
		  /* 82099FC8h */ case    6:  		/* li R24, -1 */
		/* 82099FC8h case    6:*/		cpu::op::li<0>(regs,&regs.R24,0xFFFFFFFF);
		/* 82099FC8h case    6:*/		return 0x82099FCC;
		  /* 82099FCCh */ case    7:  		/* mr R26, R4 */
		/* 82099FCCh case    7:*/		regs.R26 = regs.R4;
		/* 82099FCCh case    7:*/		return 0x82099FD0;
		  /* 82099FD0h */ case    8:  		/* mr R25, R5 */
		/* 82099FD0h case    8:*/		regs.R25 = regs.R5;
		/* 82099FD0h case    8:*/		return 0x82099FD4;
		  /* 82099FD4h */ case    9:  		/* std R24, <#[R31 + 80]> */
		/* 82099FD4h case    9:*/		cpu::mem::store64( regs, regs.R24, (uint32)(regs.R31 + 0x00000050) );
		/* 82099FD4h case    9:*/		return 0x82099FD8;
		  /* 82099FD8h */ case   10:  		/* cmpwi CR6, R3, -2 */
		/* 82099FD8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFE);
		/* 82099FD8h case   10:*/		return 0x82099FDC;
		  /* 82099FDCh */ case   11:  		/* bc 4, CR6_EQ, 40 */
		/* 82099FDCh case   11:*/		if ( !regs.CR[6].eq ) { return 0x8209A004;  }
		/* 82099FDCh case   11:*/		return 0x82099FE0;
		  /* 82099FE0h */ case   12:  		/* bl -20640 */
		/* 82099FE0h case   12:*/		regs.LR = 0x82099FE4; return 0x82094F40;
		/* 82099FE0h case   12:*/		return 0x82099FE4;
		  /* 82099FE4h */ case   13:  		/* li R11, 0 */
		/* 82099FE4h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82099FE4h case   13:*/		return 0x82099FE8;
		  /* 82099FE8h */ case   14:  		/* stw R11, <#[R3]> */
		/* 82099FE8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82099FE8h case   14:*/		return 0x82099FEC;
		  /* 82099FECh */ case   15:  		/* bl -20708 */
		/* 82099FECh case   15:*/		regs.LR = 0x82099FF0; return 0x82094F08;
		/* 82099FECh case   15:*/		return 0x82099FF0;
		  /* 82099FF0h */ case   16:  		/* mr R11, R3 */
		/* 82099FF0h case   16:*/		regs.R11 = regs.R3;
		/* 82099FF0h case   16:*/		return 0x82099FF4;
		  /* 82099FF4h */ case   17:  		/* li R10, 9 */
		/* 82099FF4h case   17:*/		cpu::op::li<0>(regs,&regs.R10,0x9);
		/* 82099FF4h case   17:*/		return 0x82099FF8;
	}
	return 0x82099FF8;
} // Block from 82099FB0h-82099FF8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82099FF8h
// Function '__crt_debugger_hook'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82099FF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82099FF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82099FF8);
		  /* 82099FF8h */ case    0:  		/* li R3, -1 */
		/* 82099FF8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82099FF8h case    0:*/		return 0x82099FFC;
		  /* 82099FFCh */ case    1:  		/* stw R10, <#[R11]> */
		/* 82099FFCh case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82099FFCh case    1:*/		return 0x8209A000;
		  /* 8209A000h */ case    2:  		/* b 208 */
		/* 8209A000h case    2:*/		return 0x8209A0D0;
		/* 8209A000h case    2:*/		return 0x8209A004;
	}
	return 0x8209A004;
} // Block from 82099FF8h-8209A004h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209A004h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A004( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A004) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A004);
		  /* 8209A004h */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 8209A004h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 8209A004h case    0:*/		return 0x8209A008;
	}
	return 0x8209A008;
} // Block from 8209A004h-8209A008h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209A008h
// Function 'realloc'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A008);
		  /* 8209A008h */ case    0:  		/* bc 12, CR6_LT, 20 */
		/* 8209A008h case    0:*/		if ( regs.CR[6].lt ) { return 0x8209A01C;  }
		/* 8209A008h case    0:*/		return 0x8209A00C;
		  /* 8209A00Ch */ case    1:  		/* lis R11, -32215 */
		/* 8209A00Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8209A00Ch case    1:*/		return 0x8209A010;
		  /* 8209A010h */ case    2:  		/* lwz R11, <#[R11 - 25512]> */
		/* 8209A010h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFF9C58) );
		/* 8209A010h case    2:*/		return 0x8209A014;
		  /* 8209A014h */ case    3:  		/* cmplw CR6, R30, R11 */
		/* 8209A014h case    3:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8209A014h case    3:*/		return 0x8209A018;
		  /* 8209A018h */ case    4:  		/* bc 12, CR6_LT, 40 */
		/* 8209A018h case    4:*/		if ( regs.CR[6].lt ) { return 0x8209A040;  }
		/* 8209A018h case    4:*/		return 0x8209A01C;
	}
	return 0x8209A01C;
} // Block from 8209A008h-8209A01Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209A01Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A01C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A01C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A01C);
		  /* 8209A01Ch */ case    0:  		/* bl -20700 */
		/* 8209A01Ch case    0:*/		regs.LR = 0x8209A020; return 0x82094F40;
		/* 8209A01Ch case    0:*/		return 0x8209A020;
		  /* 8209A020h */ case    1:  		/* li R11, 0 */
		/* 8209A020h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209A020h case    1:*/		return 0x8209A024;
		  /* 8209A024h */ case    2:  		/* stw R11, <#[R3]> */
		/* 8209A024h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209A024h case    2:*/		return 0x8209A028;
		  /* 8209A028h */ case    3:  		/* bl -20768 */
		/* 8209A028h case    3:*/		regs.LR = 0x8209A02C; return 0x82094F08;
		/* 8209A028h case    3:*/		return 0x8209A02C;
		  /* 8209A02Ch */ case    4:  		/* li R11, 9 */
		/* 8209A02Ch case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 8209A02Ch case    4:*/		return 0x8209A030;
		  /* 8209A030h */ case    5:  		/* stw R11, <#[R3]> */
		/* 8209A030h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209A030h case    5:*/		return 0x8209A034;
		  /* 8209A034h */ case    6:  		/* bl -26324 */
		/* 8209A034h case    6:*/		regs.LR = 0x8209A038; return 0x82093960;
		/* 8209A034h case    6:*/		return 0x8209A038;
		  /* 8209A038h */ case    7:  		/* li R3, -1 */
		/* 8209A038h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209A038h case    7:*/		return 0x8209A03C;
		  /* 8209A03Ch */ case    8:  		/* b 148 */
		/* 8209A03Ch case    8:*/		return 0x8209A0D0;
		/* 8209A03Ch case    8:*/		return 0x8209A040;
	}
	return 0x8209A040;
} // Block from 8209A01Ch-8209A040h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209A040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A040);
		  /* 8209A040h */ case    0:  		/* srawi R11, R30, 5 */
		/* 8209A040h case    0:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R30);
		/* 8209A040h case    0:*/		return 0x8209A044;
		  /* 8209A044h */ case    1:  		/* lis R10, -32215 */
		/* 8209A044h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 8209A044h case    1:*/		return 0x8209A048;
		  /* 8209A048h */ case    2:  		/* rlwinm R27, R11, 2, 0, 29 */
		/* 8209A048h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R11);
		/* 8209A048h case    2:*/		return 0x8209A04C;
		  /* 8209A04Ch */ case    3:  		/* addi R28, R10, -25504 */
		/* 8209A04Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R10,0xFFFF9C60);
		/* 8209A04Ch case    3:*/		return 0x8209A050;
		  /* 8209A050h */ case    4:  		/* rlwinm R11, R30, 0, 27, 31 */
		/* 8209A050h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R30);
		/* 8209A050h case    4:*/		return 0x8209A054;
		  /* 8209A054h */ case    5:  		/* mulli R29, R11, 72 */
		/* 8209A054h case    5:*/		cpu::op::mulli<0>(regs,&regs.R29,regs.R11,0x48);
		/* 8209A054h case    5:*/		return 0x8209A058;
		  /* 8209A058h */ case    6:  		/* lwzx R11, <#[R27 + R28]> */
		/* 8209A058h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + regs.R28 + 0x00000000) );
		/* 8209A058h case    6:*/		return 0x8209A05C;
		  /* 8209A05Ch */ case    7:  		/* add R11, R11, R29 */
		/* 8209A05Ch case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8209A05Ch case    7:*/		return 0x8209A060;
		  /* 8209A060h */ case    8:  		/* lbz R11, <#[R11 + 4]> */
		/* 8209A060h case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8209A060h case    8:*/		return 0x8209A064;
		  /* 8209A064h */ case    9:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8209A064h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8209A064h case    9:*/		return 0x8209A068;
		  /* 8209A068h */ case   10:  		/* bc 12, CR0_EQ, -76 */
		/* 8209A068h case   10:*/		if ( regs.CR[0].eq ) { return 0x8209A01C;  }
		/* 8209A068h case   10:*/		return 0x8209A06C;
		  /* 8209A06Ch */ case   11:  		/* mr R3, R30 */
		/* 8209A06Ch case   11:*/		regs.R3 = regs.R30;
		/* 8209A06Ch case   11:*/		return 0x8209A070;
		  /* 8209A070h */ case   12:  		/* bl 14712 */
		/* 8209A070h case   12:*/		regs.LR = 0x8209A074; return 0x8209D9E8;
		/* 8209A070h case   12:*/		return 0x8209A074;
		  /* 8209A074h */ case   13:  		/* nop */
		/* 8209A074h case   13:*/		cpu::op::nop();
		/* 8209A074h case   13:*/		return 0x8209A078;
	}
	return 0x8209A078;
} // Block from 8209A040h-8209A078h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209A078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A078);
		  /* 8209A078h */ case    0:  		/* lwzx R11, <#[R27 + R28]> */
		/* 8209A078h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + regs.R28 + 0x00000000) );
		/* 8209A078h case    0:*/		return 0x8209A07C;
		  /* 8209A07Ch */ case    1:  		/* add R11, R11, R29 */
		/* 8209A07Ch case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8209A07Ch case    1:*/		return 0x8209A080;
		  /* 8209A080h */ case    2:  		/* lbz R11, <#[R11 + 4]> */
		/* 8209A080h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8209A080h case    2:*/		return 0x8209A084;
		  /* 8209A084h */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8209A084h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8209A084h case    3:*/		return 0x8209A088;
		  /* 8209A088h */ case    4:  		/* bc 12, CR0_EQ, 28 */
		/* 8209A088h case    4:*/		if ( regs.CR[0].eq ) { return 0x8209A0A4;  }
		/* 8209A088h case    4:*/		return 0x8209A08C;
		  /* 8209A08Ch */ case    5:  		/* mr R5, R25 */
		/* 8209A08Ch case    5:*/		regs.R5 = regs.R25;
		/* 8209A08Ch case    5:*/		return 0x8209A090;
		  /* 8209A090h */ case    6:  		/* mr R4, R26 */
		/* 8209A090h case    6:*/		regs.R4 = regs.R26;
		/* 8209A090h case    6:*/		return 0x8209A094;
		  /* 8209A094h */ case    7:  		/* mr R3, R30 */
		/* 8209A094h case    7:*/		regs.R3 = regs.R30;
		/* 8209A094h case    7:*/		return 0x8209A098;
		  /* 8209A098h */ case    8:  		/* bl -440 */
		/* 8209A098h case    8:*/		regs.LR = 0x8209A09C; return 0x82099EE0;
		/* 8209A098h case    8:*/		return 0x8209A09C;
		  /* 8209A09Ch */ case    9:  		/* std R3, <#[R31 + 80]> */
		/* 8209A09Ch case    9:*/		cpu::mem::store64( regs, regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 8209A09Ch case    9:*/		return 0x8209A0A0;
		  /* 8209A0A0h */ case   10:  		/* b 32 */
		/* 8209A0A0h case   10:*/		return 0x8209A0C0;
		/* 8209A0A0h case   10:*/		return 0x8209A0A4;
	}
	return 0x8209A0A4;
} // Block from 8209A078h-8209A0A4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209A0A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A0A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A0A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A0A4);
		  /* 8209A0A4h */ case    0:  		/* bl -20892 */
		/* 8209A0A4h case    0:*/		regs.LR = 0x8209A0A8; return 0x82094F08;
		/* 8209A0A4h case    0:*/		return 0x8209A0A8;
		  /* 8209A0A8h */ case    1:  		/* li R11, 9 */
		/* 8209A0A8h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 8209A0A8h case    1:*/		return 0x8209A0AC;
		  /* 8209A0ACh */ case    2:  		/* stw R11, <#[R3]> */
		/* 8209A0ACh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209A0ACh case    2:*/		return 0x8209A0B0;
		  /* 8209A0B0h */ case    3:  		/* bl -20848 */
		/* 8209A0B0h case    3:*/		regs.LR = 0x8209A0B4; return 0x82094F40;
		/* 8209A0B0h case    3:*/		return 0x8209A0B4;
		  /* 8209A0B4h */ case    4:  		/* li R11, 0 */
		/* 8209A0B4h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209A0B4h case    4:*/		return 0x8209A0B8;
		  /* 8209A0B8h */ case    5:  		/* stw R11, <#[R3]> */
		/* 8209A0B8h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209A0B8h case    5:*/		return 0x8209A0BC;
		  /* 8209A0BCh */ case    6:  		/* std R24, <#[R31 + 80]> */
		/* 8209A0BCh case    6:*/		cpu::mem::store64( regs, regs.R24, (uint32)(regs.R31 + 0x00000050) );
		/* 8209A0BCh case    6:*/		return 0x8209A0C0;
	}
	return 0x8209A0C0;
} // Block from 8209A0A4h-8209A0C0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209A0C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A0C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A0C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A0C0);
		  /* 8209A0C0h */ case    0:  		/* nop */
		/* 8209A0C0h case    0:*/		cpu::op::nop();
		/* 8209A0C0h case    0:*/		return 0x8209A0C4;
		  /* 8209A0C4h */ case    1:  		/* addi R12, R31, 160 */
		/* 8209A0C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R31,0xA0);
		/* 8209A0C4h case    1:*/		return 0x8209A0C8;
		  /* 8209A0C8h */ case    2:  		/* bl 48 */
		/* 8209A0C8h case    2:*/		regs.LR = 0x8209A0CC; return 0x8209A0F8;
		/* 8209A0C8h case    2:*/		return 0x8209A0CC;
		  /* 8209A0CCh */ case    3:  		/* ld R3, <#[R31 + 80]> */
		/* 8209A0CCh case    3:*/		cpu::mem::load64( regs, &regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 8209A0CCh case    3:*/		return 0x8209A0D0;
	}
	return 0x8209A0D0;
} // Block from 8209A0C0h-8209A0D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209A0D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A0D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A0D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A0D0);
		  /* 8209A0D0h */ case    0:  		/* addi R1, R31, 160 */
		/* 8209A0D0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0xA0);
		/* 8209A0D0h case    0:*/		return 0x8209A0D4;
		  /* 8209A0D4h */ case    1:  		/* b -36412 */
		/* 8209A0D4h case    1:*/		return 0x82091298;
		/* 8209A0D4h case    1:*/		return 0x8209A0D8;
	}
	return 0x8209A0D8;
} // Block from 8209A0D0h-8209A0D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209A0D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A0D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A0D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A0D8);
		  /* 8209A0D8h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8209A0D8h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A0D8h case    0:*/		return 0x8209A0DC;
		  /* 8209A0DCh */ case    1:  		/* addi R31, R12, -160 */
		/* 8209A0DCh case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFF60);
		/* 8209A0DCh case    1:*/		return 0x8209A0E0;
		  /* 8209A0E0h */ case    2:  		/* std R30, <#[R1 - 16]> */
		/* 8209A0E0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209A0E0h case    2:*/		return 0x8209A0E4;
		  /* 8209A0E4h */ case    3:  		/* mfspr R12, LR */
		/* 8209A0E4h case    3:*/		regs.R12 = regs.LR;
		/* 8209A0E4h case    3:*/		return 0x8209A0E8;
		  /* 8209A0E8h */ case    4:  		/* stw R12, <#[R1 - 24]> */
		/* 8209A0E8h case    4:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209A0E8h case    4:*/		return 0x8209A0EC;
		  /* 8209A0ECh */ case    5:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209A0ECh case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209A0ECh case    5:*/		return 0x8209A0F0;
		  /* 8209A0F0h */ case    6:  		/* lwz R30, <#[R31 + 180]> */
		/* 8209A0F0h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x000000B4) );
		/* 8209A0F0h case    6:*/		return 0x8209A0F4;
		  /* 8209A0F4h */ case    7:  		/* b 28 */
		/* 8209A0F4h case    7:*/		return 0x8209A110;
		/* 8209A0F4h case    7:*/		return 0x8209A0F8;
	}
	return 0x8209A0F8;
} // Block from 8209A0D8h-8209A0F8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209A0F8h
// Function '_msize'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A0F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A0F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A0F8);
		  /* 8209A0F8h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8209A0F8h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A0F8h case    0:*/		return 0x8209A0FC;
		  /* 8209A0FCh */ case    1:  		/* addi R31, R12, -160 */
		/* 8209A0FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFF60);
		/* 8209A0FCh case    1:*/		return 0x8209A100;
		  /* 8209A100h */ case    2:  		/* std R30, <#[R1 - 16]> */
		/* 8209A100h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209A100h case    2:*/		return 0x8209A104;
		  /* 8209A104h */ case    3:  		/* mfspr R12, LR */
		/* 8209A104h case    3:*/		regs.R12 = regs.LR;
		/* 8209A104h case    3:*/		return 0x8209A108;
		  /* 8209A108h */ case    4:  		/* stw R12, <#[R1 - 24]> */
		/* 8209A108h case    4:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209A108h case    4:*/		return 0x8209A10C;
		  /* 8209A10Ch */ case    5:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209A10Ch case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209A10Ch case    5:*/		return 0x8209A110;
	}
	return 0x8209A110;
} // Block from 8209A0F8h-8209A110h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209A110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A110);
		  /* 8209A110h */ case    0:  		/* mr R3, R30 */
		/* 8209A110h case    0:*/		regs.R3 = regs.R30;
		/* 8209A110h case    0:*/		return 0x8209A114;
		  /* 8209A114h */ case    1:  		/* bl 14804 */
		/* 8209A114h case    1:*/		regs.LR = 0x8209A118; return 0x8209DAE8;
		/* 8209A114h case    1:*/		return 0x8209A118;
		  /* 8209A118h */ case    2:  		/* lwz R1, <#[R1]> */
		/* 8209A118h case    2:*/		cpu::mem::load32z( regs, &regs.R1, (uint32)(regs.R1 + 0x00000000) );
		/* 8209A118h case    2:*/		return 0x8209A11C;
		  /* 8209A11Ch */ case    3:  		/* ld R31, <#[R1 - 8]> */
		/* 8209A11Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A11Ch case    3:*/		return 0x8209A120;
		  /* 8209A120h */ case    4:  		/* ld R30, <#[R1 - 16]> */
		/* 8209A120h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209A120h case    4:*/		return 0x8209A124;
		  /* 8209A124h */ case    5:  		/* lwz R12, <#[R1 - 24]> */
		/* 8209A124h case    5:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209A124h case    5:*/		return 0x8209A128;
		  /* 8209A128h */ case    6:  		/* mtspr LR, R12 */
		/* 8209A128h case    6:*/		regs.LR = regs.R12;
		/* 8209A128h case    6:*/		return 0x8209A12C;
		  /* 8209A12Ch */ case    7:  		/* bclr 20, CR0_LT */
		/* 8209A12Ch case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209A12Ch case    7:*/		return 0x8209A130;
	}
	return 0x8209A130;
} // Block from 8209A110h-8209A130h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209A130h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A130);
		  /* 8209A130h */ case    0:  		/* mfspr R12, LR */
		/* 8209A130h case    0:*/		regs.R12 = regs.LR;
		/* 8209A130h case    0:*/		return 0x8209A134;
		  /* 8209A134h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209A134h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A134h case    1:*/		return 0x8209A138;
		  /* 8209A138h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209A138h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209A138h case    2:*/		return 0x8209A13C;
		  /* 8209A13Ch */ case    3:  		/* li R4, 72 */
		/* 8209A13Ch case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x48);
		/* 8209A13Ch case    3:*/		return 0x8209A140;
		  /* 8209A140h */ case    4:  		/* li R3, 32 */
		/* 8209A140h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x20);
		/* 8209A140h case    4:*/		return 0x8209A144;
		  /* 8209A144h */ case    5:  		/* bl -3516 */
		/* 8209A144h case    5:*/		regs.LR = 0x8209A148; return 0x82099388;
		/* 8209A144h case    5:*/		return 0x8209A148;
		  /* 8209A148h */ case    6:  		/* or. R10, R3, R3 */
		/* 8209A148h case    6:*/		cpu::op::or<1>(regs,&regs.R10,regs.R3,regs.R3);
		/* 8209A148h case    6:*/		return 0x8209A14C;
		  /* 8209A14Ch */ case    7:  		/* bc 4, CR0_EQ, 12 */
		/* 8209A14Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x8209A158;  }
		/* 8209A14Ch case    7:*/		return 0x8209A150;
	}
	return 0x8209A150;
} // Block from 8209A130h-8209A150h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209A150h
// Function '_lseeki64_nolock'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A150);
		  /* 8209A150h */ case    0:  		/* li R3, -1 */
		/* 8209A150h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209A150h case    0:*/		return 0x8209A154;
		  /* 8209A154h */ case    1:  		/* b 160 */
		/* 8209A154h case    1:*/		return 0x8209A1F4;
		/* 8209A154h case    1:*/		return 0x8209A158;
	}
	return 0x8209A158;
} // Block from 8209A150h-8209A158h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209A158h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A158);
		  /* 8209A158h */ case    0:  		/* lis R7, -32215 */
		/* 8209A158h case    0:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8229);
		/* 8209A158h case    0:*/		return 0x8209A15C;
		  /* 8209A15Ch */ case    1:  		/* lis R8, -32215 */
		/* 8209A15Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8229);
		/* 8209A15Ch case    1:*/		return 0x8209A160;
		  /* 8209A160h */ case    2:  		/* addi R6, R10, 2304 */
		/* 8209A160h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0x900);
		/* 8209A160h case    2:*/		return 0x8209A164;
		  /* 8209A164h */ case    3:  		/* li R11, 32 */
		/* 8209A164h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x20);
		/* 8209A164h case    3:*/		return 0x8209A168;
		  /* 8209A168h */ case    4:  		/* li R9, 0 */
		/* 8209A168h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8209A168h case    4:*/		return 0x8209A16C;
		  /* 8209A16Ch */ case    5:  		/* stw R10, <#[R7 - 25504]> */
		/* 8209A16Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0xFFFF9C60) );
		/* 8209A16Ch case    5:*/		return 0x8209A170;
		  /* 8209A170h */ case    6:  		/* cmplw CR6, R10, R6 */
		/* 8209A170h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 8209A170h case    6:*/		return 0x8209A174;
		  /* 8209A174h */ case    7:  		/* stw R11, <#[R8 - 25512]> */
		/* 8209A174h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0xFFFF9C58) );
		/* 8209A174h case    7:*/		return 0x8209A178;
		  /* 8209A178h */ case    8:  		/* bc 4, CR6_LT, 76 */
		/* 8209A178h case    8:*/		if ( !regs.CR[6].lt ) { return 0x8209A1C4;  }
		/* 8209A178h case    8:*/		return 0x8209A17C;
		  /* 8209A17Ch */ case    9:  		/* addi R11, R10, 5 */
		/* 8209A17Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x5);
		/* 8209A17Ch case    9:*/		return 0x8209A180;
		  /* 8209A180h */ case   10:  		/* li R8, 10 */
		/* 8209A180h case   10:*/		cpu::op::li<0>(regs,&regs.R8,0xA);
		/* 8209A180h case   10:*/		return 0x8209A184;
		  /* 8209A184h */ case   11:  		/* li R10, -1 */
		/* 8209A184h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8209A184h case   11:*/		return 0x8209A188;
		  /* 8209A188h */ case   12:  		/* stb R9, <#[R11 - 1]> */
		/* 8209A188h case   12:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R11 + 0xFFFFFFFF) );
		/* 8209A188h case   12:*/		return 0x8209A18C;
		  /* 8209A18Ch */ case   13:  		/* stb R8, <#[R11]> */
		/* 8209A18Ch case   13:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8209A18Ch case   13:*/		return 0x8209A190;
		  /* 8209A190h */ case   14:  		/* stw R10, <#[R11 - 5]> */
		/* 8209A190h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0xFFFFFFFB) );
		/* 8209A190h case   14:*/		return 0x8209A194;
		  /* 8209A194h */ case   15:  		/* stw R9, <#[R11 + 3]> */
		/* 8209A194h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000003) );
		/* 8209A194h case   15:*/		return 0x8209A198;
		  /* 8209A198h */ case   16:  		/* stb R9, <#[R11 + 35]> */
		/* 8209A198h case   16:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R11 + 0x00000023) );
		/* 8209A198h case   16:*/		return 0x8209A19C;
		  /* 8209A19Ch */ case   17:  		/* stb R8, <#[R11 + 36]> */
		/* 8209A19Ch case   17:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R11 + 0x00000024) );
		/* 8209A19Ch case   17:*/		return 0x8209A1A0;
		  /* 8209A1A0h */ case   18:  		/* stb R8, <#[R11 + 37]> */
		/* 8209A1A0h case   18:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R11 + 0x00000025) );
		/* 8209A1A0h case   18:*/		return 0x8209A1A4;
		  /* 8209A1A4h */ case   19:  		/* stw R9, <#[R11 + 59]> */
		/* 8209A1A4h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000003B) );
		/* 8209A1A4h case   19:*/		return 0x8209A1A8;
		  /* 8209A1A8h */ case   20:  		/* stb R9, <#[R11 + 55]> */
		/* 8209A1A8h case   20:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R11 + 0x00000037) );
		/* 8209A1A8h case   20:*/		return 0x8209A1AC;
		  /* 8209A1ACh */ case   21:  		/* addi R11, R11, 72 */
		/* 8209A1ACh case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x48);
		/* 8209A1ACh case   21:*/		return 0x8209A1B0;
		  /* 8209A1B0h */ case   22:  		/* lwz R10, <#[R7 - 25504]> */
		/* 8209A1B0h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0xFFFF9C60) );
		/* 8209A1B0h case   22:*/		return 0x8209A1B4;
		  /* 8209A1B4h */ case   23:  		/* addi R6, R10, 2304 */
		/* 8209A1B4h case   23:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0x900);
		/* 8209A1B4h case   23:*/		return 0x8209A1B8;
		  /* 8209A1B8h */ case   24:  		/* addi R5, R11, -5 */
		/* 8209A1B8h case   24:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFB);
		/* 8209A1B8h case   24:*/		return 0x8209A1BC;
		  /* 8209A1BCh */ case   25:  		/* cmplw CR6, R5, R6 */
		/* 8209A1BCh case   25:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R6);
		/* 8209A1BCh case   25:*/		return 0x8209A1C0;
		  /* 8209A1C0h */ case   26:  		/* bc 12, CR6_LT, -60 */
		/* 8209A1C0h case   26:*/		if ( regs.CR[6].lt ) { return 0x8209A184;  }
		/* 8209A1C0h case   26:*/		return 0x8209A1C4;
	}
	return 0x8209A1C4;
} // Block from 8209A158h-8209A1C4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8209A1C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A1C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A1C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A1C4);
		  /* 8209A1C4h */ case    0:  		/* li R11, 3 */
		/* 8209A1C4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 8209A1C4h case    0:*/		return 0x8209A1C8;
		  /* 8209A1C8h */ case    1:  		/* mtspr CTR, R11 */
		/* 8209A1C8h case    1:*/		regs.CTR = regs.R11;
		/* 8209A1C8h case    1:*/		return 0x8209A1CC;
		  /* 8209A1CCh */ case    2:  		/* b 8 */
		/* 8209A1CCh case    2:*/		return 0x8209A1D4;
		/* 8209A1CCh case    2:*/		return 0x8209A1D0;
		  /* 8209A1D0h */ case    3:  		/* lwz R10, <#[R7 - 25504]> */
		/* 8209A1D0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0xFFFF9C60) );
		/* 8209A1D0h case    3:*/		return 0x8209A1D4;
	}
	return 0x8209A1D4;
} // Block from 8209A1C4h-8209A1D4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209A1D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A1D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A1D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A1D4);
		  /* 8209A1D4h */ case    0:  		/* add R11, R9, R10 */
		/* 8209A1D4h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R10);
		/* 8209A1D4h case    0:*/		return 0x8209A1D8;
		  /* 8209A1D8h */ case    1:  		/* li R10, -63 */
		/* 8209A1D8h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFC1);
		/* 8209A1D8h case    1:*/		return 0x8209A1DC;
		  /* 8209A1DCh */ case    2:  		/* li R8, -2 */
		/* 8209A1DCh case    2:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFE);
		/* 8209A1DCh case    2:*/		return 0x8209A1E0;
		  /* 8209A1E0h */ case    3:  		/* addi R9, R9, 72 */
		/* 8209A1E0h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x48);
		/* 8209A1E0h case    3:*/		return 0x8209A1E4;
		  /* 8209A1E4h */ case    4:  		/* stb R10, <#[R11 + 4]> */
		/* 8209A1E4h case    4:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8209A1E4h case    4:*/		return 0x8209A1E8;
		  /* 8209A1E8h */ case    5:  		/* stw R8, <#[R11]> */
		/* 8209A1E8h case    5:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8209A1E8h case    5:*/		return 0x8209A1EC;
		  /* 8209A1ECh */ case    6:  		/* bc 16, CR0_LT, -28 */
		/* 8209A1ECh case    6:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209A1D0;  }
		/* 8209A1ECh case    6:*/		return 0x8209A1F0;
		  /* 8209A1F0h */ case    7:  		/* li R3, 0 */
		/* 8209A1F0h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209A1F0h case    7:*/		return 0x8209A1F4;
	}
	return 0x8209A1F4;
} // Block from 8209A1D4h-8209A1F4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209A1F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A1F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A1F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A1F4);
		  /* 8209A1F4h */ case    0:  		/* addi R1, R1, 96 */
		/* 8209A1F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209A1F4h case    0:*/		return 0x8209A1F8;
		  /* 8209A1F8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209A1F8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A1F8h case    1:*/		return 0x8209A1FC;
		  /* 8209A1FCh */ case    2:  		/* mtspr LR, R12 */
		/* 8209A1FCh case    2:*/		regs.LR = regs.R12;
		/* 8209A1FCh case    2:*/		return 0x8209A200;
		  /* 8209A200h */ case    3:  		/* bclr 20, CR0_LT */
		/* 8209A200h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209A200h case    3:*/		return 0x8209A204;
	}
	return 0x8209A204;
} // Block from 8209A1F4h-8209A204h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209A204h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A204( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A204) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A204);
		  /* 8209A204h */ case    0:  		/* nop */
		/* 8209A204h case    0:*/		cpu::op::nop();
		/* 8209A204h case    0:*/		return 0x8209A208;
	}
	return 0x8209A208;
} // Block from 8209A204h-8209A208h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209A208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A208);
		  /* 8209A208h */ case    0:  		/* mfspr R12, LR */
		/* 8209A208h case    0:*/		regs.R12 = regs.LR;
		/* 8209A208h case    0:*/		return 0x8209A20C;
		  /* 8209A20Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209A20Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A20Ch case    1:*/		return 0x8209A210;
		  /* 8209A210h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8209A210h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209A210h case    2:*/		return 0x8209A214;
		  /* 8209A214h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8209A214h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209A214h case    3:*/		return 0x8209A218;
		  /* 8209A218h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209A218h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209A218h case    4:*/		return 0x8209A21C;
		  /* 8209A21Ch */ case    5:  		/* lis R11, -32215 */
		/* 8209A21Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8209A21Ch case    5:*/		return 0x8209A220;
	}
	return 0x8209A220;
} // Block from 8209A208h-8209A220h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209A220h
// Function '_lseeki64'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A220);
		  /* 8209A220h */ case    0:  		/* addi R30, R11, -25504 */
		/* 8209A220h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFF9C60);
		/* 8209A220h case    0:*/		return 0x8209A224;
		  /* 8209A224h */ case    1:  		/* mr R31, R30 */
		/* 8209A224h case    1:*/		regs.R31 = regs.R30;
		/* 8209A224h case    1:*/		return 0x8209A228;
		  /* 8209A228h */ case    2:  		/* lwz R3, <#[R31]> */
		/* 8209A228h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8209A228h case    2:*/		return 0x8209A22C;
		  /* 8209A22Ch */ case    3:  		/* cmplwi CR6, R3, 0 */
		/* 8209A22Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209A22Ch case    3:*/		return 0x8209A230;
		  /* 8209A230h */ case    4:  		/* bc 12, CR6_EQ, 52 */
		/* 8209A230h case    4:*/		if ( regs.CR[6].eq ) { return 0x8209A264;  }
		/* 8209A230h case    4:*/		return 0x8209A234;
		  /* 8209A234h */ case    5:  		/* addi R11, R3, 2304 */
		/* 8209A234h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x900);
		/* 8209A234h case    5:*/		return 0x8209A238;
		  /* 8209A238h */ case    6:  		/* mr R10, R3 */
		/* 8209A238h case    6:*/		regs.R10 = regs.R3;
		/* 8209A238h case    6:*/		return 0x8209A23C;
		  /* 8209A23Ch */ case    7:  		/* cmplw CR6, R3, R11 */
		/* 8209A23Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8209A23Ch case    7:*/		return 0x8209A240;
		  /* 8209A240h */ case    8:  		/* bc 4, CR6_LT, 24 */
		/* 8209A240h case    8:*/		if ( !regs.CR[6].lt ) { return 0x8209A258;  }
		/* 8209A240h case    8:*/		return 0x8209A244;
		  /* 8209A244h */ case    9:  		/* rlwinm R11, R3, 0, 0, 31 */
		/* 8209A244h case    9:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R3);
		/* 8209A244h case    9:*/		return 0x8209A248;
		  /* 8209A248h */ case   10:  		/* addi R11, R11, 2304 */
		/* 8209A248h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x900);
		/* 8209A248h case   10:*/		return 0x8209A24C;
		  /* 8209A24Ch */ case   11:  		/* addi R10, R10, 72 */
		/* 8209A24Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x48);
		/* 8209A24Ch case   11:*/		return 0x8209A250;
		  /* 8209A250h */ case   12:  		/* cmplw CR6, R10, R11 */
		/* 8209A250h case   12:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8209A250h case   12:*/		return 0x8209A254;
		  /* 8209A254h */ case   13:  		/* bc 12, CR6_LT, -8 */
		/* 8209A254h case   13:*/		if ( regs.CR[6].lt ) { return 0x8209A24C;  }
		/* 8209A254h case   13:*/		return 0x8209A258;
	}
	return 0x8209A258;
} // Block from 8209A220h-8209A258h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209A258h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A258);
		  /* 8209A258h */ case    0:  		/* bl -27184 */
		/* 8209A258h case    0:*/		regs.LR = 0x8209A25C; return 0x82093828;
		/* 8209A258h case    0:*/		return 0x8209A25C;
		  /* 8209A25Ch */ case    1:  		/* li R11, 0 */
		/* 8209A25Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209A25Ch case    1:*/		return 0x8209A260;
		  /* 8209A260h */ case    2:  		/* stw R11, <#[R31]> */
		/* 8209A260h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209A260h case    2:*/		return 0x8209A264;
	}
	return 0x8209A264;
} // Block from 8209A258h-8209A264h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209A264h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A264( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A264) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A264);
		  /* 8209A264h */ case    0:  		/* addi R31, R31, 4 */
		/* 8209A264h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8209A264h case    0:*/		return 0x8209A268;
		  /* 8209A268h */ case    1:  		/* addi R11, R30, 256 */
		/* 8209A268h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x100);
		/* 8209A268h case    1:*/		return 0x8209A26C;
		  /* 8209A26Ch */ case    2:  		/* cmpw CR6, R31, R11 */
		/* 8209A26Ch case    2:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R11);
		/* 8209A26Ch case    2:*/		return 0x8209A270;
		  /* 8209A270h */ case    3:  		/* bc 12, CR6_LT, -72 */
		/* 8209A270h case    3:*/		if ( regs.CR[6].lt ) { return 0x8209A228;  }
		/* 8209A270h case    3:*/		return 0x8209A274;
		  /* 8209A274h */ case    4:  		/* addi R1, R1, 112 */
		/* 8209A274h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8209A274h case    4:*/		return 0x8209A278;
		  /* 8209A278h */ case    5:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209A278h case    5:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A278h case    5:*/		return 0x8209A27C;
		  /* 8209A27Ch */ case    6:  		/* mtspr LR, R12 */
		/* 8209A27Ch case    6:*/		regs.LR = regs.R12;
		/* 8209A27Ch case    6:*/		return 0x8209A280;
		  /* 8209A280h */ case    7:  		/* ld R30, <#[R1 - 24]> */
		/* 8209A280h case    7:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209A280h case    7:*/		return 0x8209A284;
		  /* 8209A284h */ case    8:  		/* ld R31, <#[R1 - 16]> */
		/* 8209A284h case    8:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209A284h case    8:*/		return 0x8209A288;
		  /* 8209A288h */ case    9:  		/* bclr 20, CR0_LT */
		/* 8209A288h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209A288h case    9:*/		return 0x8209A28C;
	}
	return 0x8209A28C;
} // Block from 8209A264h-8209A28Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209A28Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A28C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A28C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A28C);
		  /* 8209A28Ch */ case    0:  		/* nop */
		/* 8209A28Ch case    0:*/		cpu::op::nop();
		/* 8209A28Ch case    0:*/		return 0x8209A290;
	}
	return 0x8209A290;
} // Block from 8209A28Ch-8209A290h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209A290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A290);
		  /* 8209A290h */ case    0:  		/* mfspr R12, LR */
		/* 8209A290h case    0:*/		regs.R12 = regs.LR;
		/* 8209A290h case    0:*/		return 0x8209A294;
		  /* 8209A294h */ case    1:  		/* bl -36952 */
		/* 8209A294h case    1:*/		regs.LR = 0x8209A298; return 0x8209123C;
		/* 8209A294h case    1:*/		return 0x8209A298;
		  /* 8209A298h */ case    2:  		/* ld R12, <#[R1 - 4096]> */
		/* 8209A298h case    2:*/		cpu::mem::load64( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFF000) );
		/* 8209A298h case    2:*/		return 0x8209A29C;
		  /* 8209A29Ch */ case    3:  		/* stwu R1, <#[R1 - 5312]> */
		/* 8209A29Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFEB40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFEB40);
		/* 8209A29Ch case    3:*/		return 0x8209A2A0;
		  /* 8209A2A0h */ case    4:  		/* li R21, 0 */
		/* 8209A2A0h case    4:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 8209A2A0h case    4:*/		return 0x8209A2A4;
		  /* 8209A2A4h */ case    5:  		/* mr R24, R4 */
		/* 8209A2A4h case    5:*/		regs.R24 = regs.R4;
		/* 8209A2A4h case    5:*/		return 0x8209A2A8;
		  /* 8209A2A8h */ case    6:  		/* mr R29, R5 */
		/* 8209A2A8h case    6:*/		regs.R29 = regs.R5;
		/* 8209A2A8h case    6:*/		return 0x8209A2AC;
		  /* 8209A2ACh */ case    7:  		/* cmplwi CR6, R5, 0 */
		/* 8209A2ACh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8209A2ACh case    7:*/		return 0x8209A2B0;
		  /* 8209A2B0h */ case    8:  		/* mr R23, R21 */
		/* 8209A2B0h case    8:*/		regs.R23 = regs.R21;
		/* 8209A2B0h case    8:*/		return 0x8209A2B4;
		  /* 8209A2B4h */ case    9:  		/* mr R22, R21 */
		/* 8209A2B4h case    9:*/		regs.R22 = regs.R21;
		/* 8209A2B4h case    9:*/		return 0x8209A2B8;
		  /* 8209A2B8h */ case   10:  		/* bc 4, CR6_EQ, 12 */
		/* 8209A2B8h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8209A2C4;  }
		/* 8209A2B8h case   10:*/		return 0x8209A2BC;
		  /* 8209A2BCh */ case   11:  		/* li R3, 0 */
		/* 8209A2BCh case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209A2BCh case   11:*/		return 0x8209A2C0;
		  /* 8209A2C0h */ case   12:  		/* b 520 */
		/* 8209A2C0h case   12:*/		return 0x8209A4C8;
		/* 8209A2C0h case   12:*/		return 0x8209A2C4;
	}
	return 0x8209A2C4;
} // Block from 8209A290h-8209A2C4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209A2C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A2C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A2C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A2C4);
		  /* 8209A2C4h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 8209A2C4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 8209A2C4h case    0:*/		return 0x8209A2C8;
		  /* 8209A2C8h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 8209A2C8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209A2EC;  }
		/* 8209A2C8h case    1:*/		return 0x8209A2CC;
		  /* 8209A2CCh */ case    2:  		/* bl -21388 */
		/* 8209A2CCh case    2:*/		regs.LR = 0x8209A2D0; return 0x82094F40;
		/* 8209A2CCh case    2:*/		return 0x8209A2D0;
		  /* 8209A2D0h */ case    3:  		/* stw R21, <#[R3]> */
		/* 8209A2D0h case    3:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R3 + 0x00000000) );
		/* 8209A2D0h case    3:*/		return 0x8209A2D4;
		  /* 8209A2D4h */ case    4:  		/* bl -21452 */
		/* 8209A2D4h case    4:*/		regs.LR = 0x8209A2D8; return 0x82094F08;
		/* 8209A2D4h case    4:*/		return 0x8209A2D8;
		  /* 8209A2D8h */ case    5:  		/* li R11, 22 */
		/* 8209A2D8h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 8209A2D8h case    5:*/		return 0x8209A2DC;
		  /* 8209A2DCh */ case    6:  		/* stw R11, <#[R3]> */
		/* 8209A2DCh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209A2DCh case    6:*/		return 0x8209A2E0;
		  /* 8209A2E0h */ case    7:  		/* bl -27008 */
		/* 8209A2E0h case    7:*/		regs.LR = 0x8209A2E4; return 0x82093960;
		/* 8209A2E0h case    7:*/		return 0x8209A2E4;
		  /* 8209A2E4h */ case    8:  		/* li R3, -1 */
		/* 8209A2E4h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209A2E4h case    8:*/		return 0x8209A2E8;
		  /* 8209A2E8h */ case    9:  		/* b 480 */
		/* 8209A2E8h case    9:*/		return 0x8209A4C8;
		/* 8209A2E8h case    9:*/		return 0x8209A2EC;
	}
	return 0x8209A2EC;
} // Block from 8209A2C4h-8209A2ECh (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209A2ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A2EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A2EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A2EC);
		  /* 8209A2ECh */ case    0:  		/* srawi R11, R3, 5 */
		/* 8209A2ECh case    0:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R3);
		/* 8209A2ECh case    0:*/		return 0x8209A2F0;
		  /* 8209A2F0h */ case    1:  		/* lis R10, -32215 */
		/* 8209A2F0h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 8209A2F0h case    1:*/		return 0x8209A2F4;
		  /* 8209A2F4h */ case    2:  		/* rlwinm R26, R11, 2, 0, 29 */
		/* 8209A2F4h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R26,regs.R11);
		/* 8209A2F4h case    2:*/		return 0x8209A2F8;
		  /* 8209A2F8h */ case    3:  		/* addi R27, R10, -25504 */
		/* 8209A2F8h case    3:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R10,0xFFFF9C60);
		/* 8209A2F8h case    3:*/		return 0x8209A2FC;
		  /* 8209A2FCh */ case    4:  		/* rlwinm R11, R3, 0, 27, 31 */
		/* 8209A2FCh case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R3);
		/* 8209A2FCh case    4:*/		return 0x8209A300;
		  /* 8209A300h */ case    5:  		/* mulli R28, R11, 72 */
		/* 8209A300h case    5:*/		cpu::op::mulli<0>(regs,&regs.R28,regs.R11,0x48);
		/* 8209A300h case    5:*/		return 0x8209A304;
		  /* 8209A304h */ case    6:  		/* lwzx R11, <#[R26 + R27]> */
		/* 8209A304h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + regs.R27 + 0x00000000) );
		/* 8209A304h case    6:*/		return 0x8209A308;
		  /* 8209A308h */ case    7:  		/* add R10, R11, R28 */
		/* 8209A308h case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R28);
		/* 8209A308h case    7:*/		return 0x8209A30C;
		  /* 8209A30Ch */ case    8:  		/* lbz R11, <#[R10 + 40]> */
		/* 8209A30Ch case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000028) );
		/* 8209A30Ch case    8:*/		return 0x8209A310;
		  /* 8209A310h */ case    9:  		/* rlwinm R11, R11, 24, 0, 31 */
		/* 8209A310h case    9:*/		cpu::op::rlwinm<0,24,0,31>(regs,&regs.R11,regs.R11);
		/* 8209A310h case    9:*/		return 0x8209A314;
		  /* 8209A314h */ case   10:  		/* srawi R11, R11, 25 */
		/* 8209A314h case   10:*/		cpu::op::srawi<0,25>(regs,&regs.R11,regs.R11);
		/* 8209A314h case   10:*/		return 0x8209A318;
		  /* 8209A318h */ case   11:  		/* extsb R11, R11 */
		/* 8209A318h case   11:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 8209A318h case   11:*/		return 0x8209A31C;
		  /* 8209A31Ch */ case   12:  		/* cmpwi CR6, R11, 2 */
		/* 8209A31Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 8209A31Ch case   12:*/		return 0x8209A320;
		  /* 8209A320h */ case   13:  		/* bc 12, CR6_EQ, 12 */
		/* 8209A320h case   13:*/		if ( regs.CR[6].eq ) { return 0x8209A32C;  }
		/* 8209A320h case   13:*/		return 0x8209A324;
		  /* 8209A324h */ case   14:  		/* cmpwi CR6, R11, 1 */
		/* 8209A324h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 8209A324h case   14:*/		return 0x8209A328;
		  /* 8209A328h */ case   15:  		/* bc 4, CR6_EQ, 16 */
		/* 8209A328h case   15:*/		if ( !regs.CR[6].eq ) { return 0x8209A338;  }
		/* 8209A328h case   15:*/		return 0x8209A32C;
	}
	return 0x8209A32C;
} // Block from 8209A2ECh-8209A32Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8209A32Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A32C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A32C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A32C);
		  /* 8209A32Ch */ case    0:  		/* nor R11, R29, R29 */
		/* 8209A32Ch case    0:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R29,regs.R29);
		/* 8209A32Ch case    0:*/		return 0x8209A330;
		  /* 8209A330h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8209A330h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8209A330h case    1:*/		return 0x8209A334;
		  /* 8209A334h */ case    2:  		/* bc 12, CR0_EQ, -104 */
		/* 8209A334h case    2:*/		if ( regs.CR[0].eq ) { return 0x8209A2CC;  }
		/* 8209A334h case    2:*/		return 0x8209A338;
	}
	return 0x8209A338;
} // Block from 8209A32Ch-8209A338h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209A338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A338);
		  /* 8209A338h */ case    0:  		/* lbz R11, <#[R10 + 4]> */
		/* 8209A338h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8209A338h case    0:*/		return 0x8209A33C;
		  /* 8209A33Ch */ case    1:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 8209A33Ch case    1:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 8209A33Ch case    1:*/		return 0x8209A340;
		  /* 8209A340h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8209A340h case    2:*/		if ( regs.CR[0].eq ) { return 0x8209A350;  }
		/* 8209A340h case    2:*/		return 0x8209A344;
		  /* 8209A344h */ case    3:  		/* li R5, 2 */
		/* 8209A344h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8209A344h case    3:*/		return 0x8209A348;
		  /* 8209A348h */ case    4:  		/* li R4, 0 */
		/* 8209A348h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8209A348h case    4:*/		return 0x8209A34C;
		  /* 8209A34Ch */ case    5:  		/* bl -1132 */
		/* 8209A34Ch case    5:*/		regs.LR = 0x8209A350; return 0x82099EE0;
		/* 8209A34Ch case    5:*/		return 0x8209A350;
	}
	return 0x8209A350;
} // Block from 8209A338h-8209A350h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209A350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A350);
		  /* 8209A350h */ case    0:  		/* lwzx R11, <#[R26 + R27]> */
		/* 8209A350h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + regs.R27 + 0x00000000) );
		/* 8209A350h case    0:*/		return 0x8209A354;
		  /* 8209A354h */ case    1:  		/* add R11, R11, R28 */
		/* 8209A354h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 8209A354h case    1:*/		return 0x8209A358;
		  /* 8209A358h */ case    2:  		/* lbz R10, <#[R11 + 4]> */
		/* 8209A358h case    2:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8209A358h case    2:*/		return 0x8209A35C;
		  /* 8209A35Ch */ case    3:  		/* rlwinm. R10, R10, 0, 0, 24 */
		/* 8209A35Ch case    3:*/		cpu::op::rlwinm<1,0,0,24>(regs,&regs.R10,regs.R10);
		/* 8209A35Ch case    3:*/		return 0x8209A360;
		  /* 8209A360h */ case    4:  		/* bc 12, CR0_EQ, 176 */
		/* 8209A360h case    4:*/		if ( regs.CR[0].eq ) { return 0x8209A410;  }
		/* 8209A360h case    4:*/		return 0x8209A364;
		  /* 8209A364h */ case    5:  		/* mr R25, R21 */
		/* 8209A364h case    5:*/		regs.R25 = regs.R21;
		/* 8209A364h case    5:*/		return 0x8209A368;
		  /* 8209A368h */ case    6:  		/* mr R30, R24 */
		/* 8209A368h case    6:*/		regs.R30 = regs.R24;
		/* 8209A368h case    6:*/		return 0x8209A36C;
		  /* 8209A36Ch */ case    7:  		/* cmplwi CR6, R29, 0 */
		/* 8209A36Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8209A36Ch case    7:*/		return 0x8209A370;
		  /* 8209A370h */ case    8:  		/* bc 12, CR6_EQ, 276 */
		/* 8209A370h case    8:*/		if ( regs.CR[6].eq ) { return 0x8209A484;  }
		/* 8209A370h case    8:*/		return 0x8209A374;
		  /* 8209A374h */ case    9:  		/* addi R11, R1, 96 */
		/* 8209A374h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 8209A374h case    9:*/		return 0x8209A378;
		  /* 8209A378h */ case   10:  		/* mr R10, R21 */
		/* 8209A378h case   10:*/		regs.R10 = regs.R21;
		/* 8209A378h case   10:*/		return 0x8209A37C;
		  /* 8209A37Ch */ case   11:  		/* subf R9, R24, R30 */
		/* 8209A37Ch case   11:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R24,regs.R30);
		/* 8209A37Ch case   11:*/		return 0x8209A380;
		  /* 8209A380h */ case   12:  		/* cmplw CR6, R9, R29 */
		/* 8209A380h case   12:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R29);
		/* 8209A380h case   12:*/		return 0x8209A384;
		  /* 8209A384h */ case   13:  		/* bc 4, CR6_LT, 64 */
		/* 8209A384h case   13:*/		if ( !regs.CR[6].lt ) { return 0x8209A3C4;  }
		/* 8209A384h case   13:*/		return 0x8209A388;
		  /* 8209A388h */ case   14:  		/* lbz R8, <#[R30]> */
		/* 8209A388h case   14:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000000) );
		/* 8209A388h case   14:*/		return 0x8209A38C;
		  /* 8209A38Ch */ case   15:  		/* addi R30, R30, 1 */
		/* 8209A38Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8209A38Ch case   15:*/		return 0x8209A390;
		  /* 8209A390h */ case   16:  		/* addi R9, R9, 1 */
		/* 8209A390h case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8209A390h case   16:*/		return 0x8209A394;
		  /* 8209A394h */ case   17:  		/* cmplwi CR6, R8, 10 */
		/* 8209A394h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000000A);
		/* 8209A394h case   17:*/		return 0x8209A398;
		  /* 8209A398h */ case   18:  		/* bc 4, CR6_EQ, 24 */
		/* 8209A398h case   18:*/		if ( !regs.CR[6].eq ) { return 0x8209A3B0;  }
		/* 8209A398h case   18:*/		return 0x8209A39C;
		  /* 8209A39Ch */ case   19:  		/* li R7, 13 */
		/* 8209A39Ch case   19:*/		cpu::op::li<0>(regs,&regs.R7,0xD);
		/* 8209A39Ch case   19:*/		return 0x8209A3A0;
	}
	return 0x8209A3A0;
} // Block from 8209A350h-8209A3A0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8209A3A0h
// Function '_ioinit'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A3A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A3A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A3A0);
		  /* 8209A3A0h */ case    0:  		/* addi R22, R22, 1 */
		/* 8209A3A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 8209A3A0h case    0:*/		return 0x8209A3A4;
		  /* 8209A3A4h */ case    1:  		/* stb R7, <#[R11]> */
		/* 8209A3A4h case    1:*/		cpu::mem::store8( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8209A3A4h case    1:*/		return 0x8209A3A8;
		  /* 8209A3A8h */ case    2:  		/* addi R11, R11, 1 */
		/* 8209A3A8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209A3A8h case    2:*/		return 0x8209A3AC;
		  /* 8209A3ACh */ case    3:  		/* addi R10, R10, 1 */
		/* 8209A3ACh case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8209A3ACh case    3:*/		return 0x8209A3B0;
	}
	return 0x8209A3B0;
} // Block from 8209A3A0h-8209A3B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209A3B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A3B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A3B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A3B0);
		  /* 8209A3B0h */ case    0:  		/* addi R10, R10, 1 */
		/* 8209A3B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8209A3B0h case    0:*/		return 0x8209A3B4;
		  /* 8209A3B4h */ case    1:  		/* stb R8, <#[R11]> */
		/* 8209A3B4h case    1:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8209A3B4h case    1:*/		return 0x8209A3B8;
		  /* 8209A3B8h */ case    2:  		/* addi R11, R11, 1 */
		/* 8209A3B8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209A3B8h case    2:*/		return 0x8209A3BC;
		  /* 8209A3BCh */ case    3:  		/* cmplwi CR6, R10, 5119 */
		/* 8209A3BCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x000013FF);
		/* 8209A3BCh case    3:*/		return 0x8209A3C0;
		  /* 8209A3C0h */ case    4:  		/* bc 12, CR6_LT, -64 */
		/* 8209A3C0h case    4:*/		if ( regs.CR[6].lt ) { return 0x8209A380;  }
		/* 8209A3C0h case    4:*/		return 0x8209A3C4;
	}
	return 0x8209A3C4;
} // Block from 8209A3B0h-8209A3C4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209A3C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A3C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A3C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A3C4);
		  /* 8209A3C4h */ case    0:  		/* addi R10, R1, 96 */
		/* 8209A3C4h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 8209A3C4h case    0:*/		return 0x8209A3C8;
		  /* 8209A3C8h */ case    1:  		/* lwzx R9, <#[R26 + R27]> */
		/* 8209A3C8h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + regs.R27 + 0x00000000) );
		/* 8209A3C8h case    1:*/		return 0x8209A3CC;
		  /* 8209A3CCh */ case    2:  		/* li R7, 0 */
		/* 8209A3CCh case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8209A3CCh case    2:*/		return 0x8209A3D0;
		  /* 8209A3D0h */ case    3:  		/* subf R31, R10, R11 */
		/* 8209A3D0h case    3:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R10,regs.R11);
		/* 8209A3D0h case    3:*/		return 0x8209A3D4;
		  /* 8209A3D4h */ case    4:  		/* addi R6, R1, 80 */
		/* 8209A3D4h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 8209A3D4h case    4:*/		return 0x8209A3D8;
		  /* 8209A3D8h */ case    5:  		/* mr R5, R31 */
		/* 8209A3D8h case    5:*/		regs.R5 = regs.R31;
		/* 8209A3D8h case    5:*/		return 0x8209A3DC;
		  /* 8209A3DCh */ case    6:  		/* addi R4, R1, 96 */
		/* 8209A3DCh case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 8209A3DCh case    6:*/		return 0x8209A3E0;
		  /* 8209A3E0h */ case    7:  		/* lwzx R3, <#[R9 + R28]> */
		/* 8209A3E0h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R9 + regs.R28 + 0x00000000) );
		/* 8209A3E0h case    7:*/		return 0x8209A3E4;
		  /* 8209A3E4h */ case    8:  		/* bl -72060 */
		/* 8209A3E4h case    8:*/		regs.LR = 0x8209A3E8; return 0x82088A68;
		/* 8209A3E4h case    8:*/		return 0x8209A3E8;
		  /* 8209A3E8h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 8209A3E8h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209A3E8h case    9:*/		return 0x8209A3EC;
		  /* 8209A3ECh */ case   10:  		/* bc 12, CR0_EQ, 80 */
		/* 8209A3ECh case   10:*/		if ( regs.CR[0].eq ) { return 0x8209A43C;  }
		/* 8209A3ECh case   10:*/		return 0x8209A3F0;
		  /* 8209A3F0h */ case   11:  		/* lwz R11, <#[R1 + 80]> */
		/* 8209A3F0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8209A3F0h case   11:*/		return 0x8209A3F4;
		  /* 8209A3F4h */ case   12:  		/* add R23, R11, R23 */
		/* 8209A3F4h case   12:*/		cpu::op::add<0>(regs,&regs.R23,regs.R11,regs.R23);
		/* 8209A3F4h case   12:*/		return 0x8209A3F8;
		  /* 8209A3F8h */ case   13:  		/* cmpw CR6, R11, R31 */
		/* 8209A3F8h case   13:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R31);
		/* 8209A3F8h case   13:*/		return 0x8209A3FC;
		  /* 8209A3FCh */ case   14:  		/* bc 12, CR6_LT, 72 */
		/* 8209A3FCh case   14:*/		if ( regs.CR[6].lt ) { return 0x8209A444;  }
		/* 8209A3FCh case   14:*/		return 0x8209A400;
		  /* 8209A400h */ case   15:  		/* subf R11, R24, R30 */
		/* 8209A400h case   15:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R24,regs.R30);
		/* 8209A400h case   15:*/		return 0x8209A404;
		  /* 8209A404h */ case   16:  		/* cmplw CR6, R11, R29 */
		/* 8209A404h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 8209A404h case   16:*/		return 0x8209A408;
		  /* 8209A408h */ case   17:  		/* bc 12, CR6_LT, -148 */
		/* 8209A408h case   17:*/		if ( regs.CR[6].lt ) { return 0x8209A374;  }
		/* 8209A408h case   17:*/		return 0x8209A40C;
		  /* 8209A40Ch */ case   18:  		/* b 56 */
		/* 8209A40Ch case   18:*/		return 0x8209A444;
		/* 8209A40Ch case   18:*/		return 0x8209A410;
	}
	return 0x8209A410;
} // Block from 8209A3C4h-8209A410h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8209A410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A410);
		  /* 8209A410h */ case    0:  		/* li R7, 0 */
		/* 8209A410h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8209A410h case    0:*/		return 0x8209A414;
		  /* 8209A414h */ case    1:  		/* lwz R3, <#[R11]> */
		/* 8209A414h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 8209A414h case    1:*/		return 0x8209A418;
		  /* 8209A418h */ case    2:  		/* addi R6, R1, 80 */
		/* 8209A418h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 8209A418h case    2:*/		return 0x8209A41C;
		  /* 8209A41Ch */ case    3:  		/* mr R5, R29 */
		/* 8209A41Ch case    3:*/		regs.R5 = regs.R29;
		/* 8209A41Ch case    3:*/		return 0x8209A420;
		  /* 8209A420h */ case    4:  		/* mr R4, R24 */
		/* 8209A420h case    4:*/		regs.R4 = regs.R24;
		/* 8209A420h case    4:*/		return 0x8209A424;
		  /* 8209A424h */ case    5:  		/* bl -72124 */
		/* 8209A424h case    5:*/		regs.LR = 0x8209A428; return 0x82088A68;
		/* 8209A424h case    5:*/		return 0x8209A428;
		  /* 8209A428h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 8209A428h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209A428h case    6:*/		return 0x8209A42C;
		  /* 8209A42Ch */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 8209A42Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x8209A43C;  }
		/* 8209A42Ch case    7:*/		return 0x8209A430;
		  /* 8209A430h */ case    8:  		/* lwz R23, <#[R1 + 80]> */
		/* 8209A430h case    8:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R1 + 0x00000050) );
		/* 8209A430h case    8:*/		return 0x8209A434;
		  /* 8209A434h */ case    9:  		/* mr R25, R21 */
		/* 8209A434h case    9:*/		regs.R25 = regs.R21;
		/* 8209A434h case    9:*/		return 0x8209A438;
		  /* 8209A438h */ case   10:  		/* b 12 */
		/* 8209A438h case   10:*/		return 0x8209A444;
		/* 8209A438h case   10:*/		return 0x8209A43C;
	}
	return 0x8209A43C;
} // Block from 8209A410h-8209A43Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209A43Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A43C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A43C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A43C);
		  /* 8209A43Ch */ case    0:  		/* bl -64828 */
		/* 8209A43Ch case    0:*/		regs.LR = 0x8209A440; return 0x8208A700;
		/* 8209A43Ch case    0:*/		return 0x8209A440;
		  /* 8209A440h */ case    1:  		/* mr R25, R3 */
		/* 8209A440h case    1:*/		regs.R25 = regs.R3;
		/* 8209A440h case    1:*/		return 0x8209A444;
	}
	return 0x8209A444;
} // Block from 8209A43Ch-8209A444h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209A444h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A444( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A444) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A444);
		  /* 8209A444h */ case    0:  		/* cmpwi CR6, R23, 0 */
		/* 8209A444h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 8209A444h case    0:*/		return 0x8209A448;
		  /* 8209A448h */ case    1:  		/* bc 4, CR6_EQ, 124 */
		/* 8209A448h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209A4C4;  }
		/* 8209A448h case    1:*/		return 0x8209A44C;
		  /* 8209A44Ch */ case    2:  		/* cmplwi CR6, R25, 0 */
		/* 8209A44Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 8209A44Ch case    2:*/		return 0x8209A450;
		  /* 8209A450h */ case    3:  		/* bc 12, CR6_EQ, 52 */
		/* 8209A450h case    3:*/		if ( regs.CR[6].eq ) { return 0x8209A484;  }
		/* 8209A450h case    3:*/		return 0x8209A454;
		  /* 8209A454h */ case    4:  		/* cmplwi CR6, R25, 5 */
		/* 8209A454h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000005);
		/* 8209A454h case    4:*/		return 0x8209A458;
		  /* 8209A458h */ case    5:  		/* bc 4, CR6_EQ, 32 */
		/* 8209A458h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8209A478;  }
		/* 8209A458h case    5:*/		return 0x8209A45C;
		  /* 8209A45Ch */ case    6:  		/* bl -21844 */
		/* 8209A45Ch case    6:*/		regs.LR = 0x8209A460; return 0x82094F08;
		/* 8209A45Ch case    6:*/		return 0x8209A460;
		  /* 8209A460h */ case    7:  		/* li R11, 9 */
		/* 8209A460h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 8209A460h case    7:*/		return 0x8209A464;
		  /* 8209A464h */ case    8:  		/* stw R11, <#[R3]> */
		/* 8209A464h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209A464h case    8:*/		return 0x8209A468;
		  /* 8209A468h */ case    9:  		/* bl -21800 */
		/* 8209A468h case    9:*/		regs.LR = 0x8209A46C; return 0x82094F40;
		/* 8209A468h case    9:*/		return 0x8209A46C;
		  /* 8209A46Ch */ case   10:  		/* li R11, 5 */
		/* 8209A46Ch case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 8209A46Ch case   10:*/		return 0x8209A470;
		  /* 8209A470h */ case   11:  		/* stw R11, <#[R3]> */
		/* 8209A470h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209A470h case   11:*/		return 0x8209A474;
		  /* 8209A474h */ case   12:  		/* b -400 */
		/* 8209A474h case   12:*/		return 0x8209A2E4;
		/* 8209A474h case   12:*/		return 0x8209A478;
	}
	return 0x8209A478;
} // Block from 8209A444h-8209A478h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209A478h
// Function '_ioterm'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A478);
		  /* 8209A478h */ case    0:  		/* mr R3, R25 */
		/* 8209A478h case    0:*/		regs.R3 = regs.R25;
		/* 8209A478h case    0:*/		return 0x8209A47C;
		  /* 8209A47Ch */ case    1:  		/* bl -21764 */
		/* 8209A47Ch case    1:*/		regs.LR = 0x8209A480; return 0x82094F78;
		/* 8209A47Ch case    1:*/		return 0x8209A480;
		  /* 8209A480h */ case    2:  		/* b -412 */
		/* 8209A480h case    2:*/		return 0x8209A2E4;
		/* 8209A480h case    2:*/		return 0x8209A484;
	}
	return 0x8209A484;
} // Block from 8209A478h-8209A484h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209A484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A484);
		  /* 8209A484h */ case    0:  		/* lwzx R11, <#[R26 + R27]> */
		/* 8209A484h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + regs.R27 + 0x00000000) );
		/* 8209A484h case    0:*/		return 0x8209A488;
		  /* 8209A488h */ case    1:  		/* add R11, R11, R28 */
		/* 8209A488h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 8209A488h case    1:*/		return 0x8209A48C;
		  /* 8209A48Ch */ case    2:  		/* lbz R11, <#[R11 + 4]> */
		/* 8209A48Ch case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8209A48Ch case    2:*/		return 0x8209A490;
		  /* 8209A490h */ case    3:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 8209A490h case    3:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 8209A490h case    3:*/		return 0x8209A494;
		  /* 8209A494h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 8209A494h case    4:*/		if ( regs.CR[0].eq ) { return 0x8209A4A4;  }
		/* 8209A494h case    4:*/		return 0x8209A498;
		  /* 8209A498h */ case    5:  		/* lbz R11, <#[R24]> */
		/* 8209A498h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 8209A498h case    5:*/		return 0x8209A49C;
		  /* 8209A49Ch */ case    6:  		/* cmplwi CR6, R11, 26 */
		/* 8209A49Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001A);
		/* 8209A49Ch case    6:*/		return 0x8209A4A0;
		  /* 8209A4A0h */ case    7:  		/* bc 12, CR6_EQ, -484 */
		/* 8209A4A0h case    7:*/		if ( regs.CR[6].eq ) { return 0x8209A2BC;  }
		/* 8209A4A0h case    7:*/		return 0x8209A4A4;
	}
	return 0x8209A4A4;
} // Block from 8209A484h-8209A4A4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209A4A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A4A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A4A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A4A4);
		  /* 8209A4A4h */ case    0:  		/* bl -21916 */
		/* 8209A4A4h case    0:*/		regs.LR = 0x8209A4A8; return 0x82094F08;
		/* 8209A4A4h case    0:*/		return 0x8209A4A8;
		  /* 8209A4A8h */ case    1:  		/* li R11, 28 */
		/* 8209A4A8h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1C);
		/* 8209A4A8h case    1:*/		return 0x8209A4AC;
		  /* 8209A4ACh */ case    2:  		/* stw R11, <#[R3]> */
		/* 8209A4ACh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209A4ACh case    2:*/		return 0x8209A4B0;
		  /* 8209A4B0h */ case    3:  		/* bl -21872 */
		/* 8209A4B0h case    3:*/		regs.LR = 0x8209A4B4; return 0x82094F40;
		/* 8209A4B0h case    3:*/		return 0x8209A4B4;
		  /* 8209A4B4h */ case    4:  		/* mr R11, R3 */
		/* 8209A4B4h case    4:*/		regs.R11 = regs.R3;
		/* 8209A4B4h case    4:*/		return 0x8209A4B8;
		  /* 8209A4B8h */ case    5:  		/* li R3, -1 */
		/* 8209A4B8h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209A4B8h case    5:*/		return 0x8209A4BC;
		  /* 8209A4BCh */ case    6:  		/* stw R21, <#[R11]> */
		/* 8209A4BCh case    6:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R11 + 0x00000000) );
		/* 8209A4BCh case    6:*/		return 0x8209A4C0;
		  /* 8209A4C0h */ case    7:  		/* b 8 */
		/* 8209A4C0h case    7:*/		return 0x8209A4C8;
		/* 8209A4C0h case    7:*/		return 0x8209A4C4;
	}
	return 0x8209A4C4;
} // Block from 8209A4A4h-8209A4C4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209A4C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A4C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A4C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A4C4);
		  /* 8209A4C4h */ case    0:  		/* subf R3, R22, R23 */
		/* 8209A4C4h case    0:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R22,regs.R23);
		/* 8209A4C4h case    0:*/		return 0x8209A4C8;
	}
	return 0x8209A4C8;
} // Block from 8209A4C4h-8209A4C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209A4C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A4C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A4C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A4C8);
		  /* 8209A4C8h */ case    0:  		/* addi R1, R1, 5312 */
		/* 8209A4C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x14C0);
		/* 8209A4C8h case    0:*/		return 0x8209A4CC;
		  /* 8209A4CCh */ case    1:  		/* b -37440 */
		/* 8209A4CCh case    1:*/		return 0x8209128C;
		/* 8209A4CCh case    1:*/		return 0x8209A4D0;
		  /* 8209A4D0h */ case    2:  		/* lwz R17, <#[R6 - 11576]> */
		/* 8209A4D0h case    2:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 8209A4D0h case    2:*/		return 0x8209A4D4;
		  /* 8209A4D4h */ case    3:  		/* lwz R16, <#[R4 - 15280]> */
		/* 8209A4D4h case    3:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC450) );
		/* 8209A4D4h case    3:*/		return 0x8209A4D8;
	}
	return 0x8209A4D8;
} // Block from 8209A4C8h-8209A4D8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209A4D8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A4D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A4D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A4D8);
		  /* 8209A4D8h */ case    0:  		/* mfspr R12, LR */
		/* 8209A4D8h case    0:*/		regs.R12 = regs.LR;
		/* 8209A4D8h case    0:*/		return 0x8209A4DC;
		  /* 8209A4DCh */ case    1:  		/* bl -37520 */
		/* 8209A4DCh case    1:*/		regs.LR = 0x8209A4E0; return 0x8209124C;
		/* 8209A4DCh case    1:*/		return 0x8209A4E0;
		  /* 8209A4E0h */ case    2:  		/* addi R31, R1, -160 */
		/* 8209A4E0h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFF60);
		/* 8209A4E0h case    2:*/		return 0x8209A4E4;
		  /* 8209A4E4h */ case    3:  		/* stwu R1, <#[R1 - 160]> */
		/* 8209A4E4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 8209A4E4h case    3:*/		return 0x8209A4E8;
		  /* 8209A4E8h */ case    4:  		/* mr R30, R3 */
		/* 8209A4E8h case    4:*/		regs.R30 = regs.R3;
		/* 8209A4E8h case    4:*/		return 0x8209A4EC;
		  /* 8209A4ECh */ case    5:  		/* stw R3, <#[R31 + 180]> */
		/* 8209A4ECh case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000000B4) );
		/* 8209A4ECh case    5:*/		return 0x8209A4F0;
		  /* 8209A4F0h */ case    6:  		/* mr R26, R4 */
		/* 8209A4F0h case    6:*/		regs.R26 = regs.R4;
		/* 8209A4F0h case    6:*/		return 0x8209A4F4;
		  /* 8209A4F4h */ case    7:  		/* mr R25, R5 */
		/* 8209A4F4h case    7:*/		regs.R25 = regs.R5;
		/* 8209A4F4h case    7:*/		return 0x8209A4F8;
		  /* 8209A4F8h */ case    8:  		/* cmpwi CR6, R3, -2 */
		/* 8209A4F8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFE);
		/* 8209A4F8h case    8:*/		return 0x8209A4FC;
		  /* 8209A4FCh */ case    9:  		/* bc 4, CR6_EQ, 40 */
		/* 8209A4FCh case    9:*/		if ( !regs.CR[6].eq ) { return 0x8209A524;  }
		/* 8209A4FCh case    9:*/		return 0x8209A500;
	}
	return 0x8209A500;
} // Block from 8209A4D8h-8209A500h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209A500h
// Function '_write_nolock'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A500);
		  /* 8209A500h */ case    0:  		/* bl -21952 */
		/* 8209A500h case    0:*/		regs.LR = 0x8209A504; return 0x82094F40;
		/* 8209A500h case    0:*/		return 0x8209A504;
		  /* 8209A504h */ case    1:  		/* li R11, 0 */
		/* 8209A504h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209A504h case    1:*/		return 0x8209A508;
		  /* 8209A508h */ case    2:  		/* stw R11, <#[R3]> */
		/* 8209A508h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209A508h case    2:*/		return 0x8209A50C;
		  /* 8209A50Ch */ case    3:  		/* bl -22020 */
		/* 8209A50Ch case    3:*/		regs.LR = 0x8209A510; return 0x82094F08;
		/* 8209A50Ch case    3:*/		return 0x8209A510;
		  /* 8209A510h */ case    4:  		/* mr R11, R3 */
		/* 8209A510h case    4:*/		regs.R11 = regs.R3;
		/* 8209A510h case    4:*/		return 0x8209A514;
		  /* 8209A514h */ case    5:  		/* li R10, 9 */
		/* 8209A514h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x9);
		/* 8209A514h case    5:*/		return 0x8209A518;
		  /* 8209A518h */ case    6:  		/* li R3, -1 */
		/* 8209A518h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209A518h case    6:*/		return 0x8209A51C;
		  /* 8209A51Ch */ case    7:  		/* stw R10, <#[R11]> */
		/* 8209A51Ch case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209A51Ch case    7:*/		return 0x8209A520;
		  /* 8209A520h */ case    8:  		/* b 212 */
		/* 8209A520h case    8:*/		return 0x8209A5F4;
		/* 8209A520h case    8:*/		return 0x8209A524;
	}
	return 0x8209A524;
} // Block from 8209A500h-8209A524h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209A524h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A524( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A524) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A524);
		  /* 8209A524h */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 8209A524h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 8209A524h case    0:*/		return 0x8209A528;
		  /* 8209A528h */ case    1:  		/* bc 12, CR6_LT, 20 */
		/* 8209A528h case    1:*/		if ( regs.CR[6].lt ) { return 0x8209A53C;  }
		/* 8209A528h case    1:*/		return 0x8209A52C;
		  /* 8209A52Ch */ case    2:  		/* lis R11, -32215 */
		/* 8209A52Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8209A52Ch case    2:*/		return 0x8209A530;
		  /* 8209A530h */ case    3:  		/* lwz R11, <#[R11 - 25512]> */
		/* 8209A530h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFF9C58) );
		/* 8209A530h case    3:*/		return 0x8209A534;
		  /* 8209A534h */ case    4:  		/* cmplw CR6, R30, R11 */
		/* 8209A534h case    4:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8209A534h case    4:*/		return 0x8209A538;
		  /* 8209A538h */ case    5:  		/* bc 12, CR6_LT, 40 */
		/* 8209A538h case    5:*/		if ( regs.CR[6].lt ) { return 0x8209A560;  }
		/* 8209A538h case    5:*/		return 0x8209A53C;
	}
	return 0x8209A53C;
} // Block from 8209A524h-8209A53Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209A53Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A53C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A53C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A53C);
		  /* 8209A53Ch */ case    0:  		/* bl -22012 */
		/* 8209A53Ch case    0:*/		regs.LR = 0x8209A540; return 0x82094F40;
		/* 8209A53Ch case    0:*/		return 0x8209A540;
		  /* 8209A540h */ case    1:  		/* li R11, 0 */
		/* 8209A540h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209A540h case    1:*/		return 0x8209A544;
		  /* 8209A544h */ case    2:  		/* stw R11, <#[R3]> */
		/* 8209A544h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209A544h case    2:*/		return 0x8209A548;
		  /* 8209A548h */ case    3:  		/* bl -22080 */
		/* 8209A548h case    3:*/		regs.LR = 0x8209A54C; return 0x82094F08;
		/* 8209A548h case    3:*/		return 0x8209A54C;
		  /* 8209A54Ch */ case    4:  		/* li R11, 9 */
		/* 8209A54Ch case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 8209A54Ch case    4:*/		return 0x8209A550;
		  /* 8209A550h */ case    5:  		/* stw R11, <#[R3]> */
		/* 8209A550h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209A550h case    5:*/		return 0x8209A554;
		  /* 8209A554h */ case    6:  		/* bl -27636 */
		/* 8209A554h case    6:*/		regs.LR = 0x8209A558; return 0x82093960;
		/* 8209A554h case    6:*/		return 0x8209A558;
		  /* 8209A558h */ case    7:  		/* li R3, -1 */
		/* 8209A558h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209A558h case    7:*/		return 0x8209A55C;
		  /* 8209A55Ch */ case    8:  		/* b 152 */
		/* 8209A55Ch case    8:*/		return 0x8209A5F4;
		/* 8209A55Ch case    8:*/		return 0x8209A560;
	}
	return 0x8209A560;
} // Block from 8209A53Ch-8209A560h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209A560h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A560);
		  /* 8209A560h */ case    0:  		/* srawi R11, R30, 5 */
		/* 8209A560h case    0:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R30);
		/* 8209A560h case    0:*/		return 0x8209A564;
		  /* 8209A564h */ case    1:  		/* lis R10, -32215 */
		/* 8209A564h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 8209A564h case    1:*/		return 0x8209A568;
		  /* 8209A568h */ case    2:  		/* rlwinm R27, R11, 2, 0, 29 */
		/* 8209A568h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R11);
		/* 8209A568h case    2:*/		return 0x8209A56C;
		  /* 8209A56Ch */ case    3:  		/* addi R28, R10, -25504 */
		/* 8209A56Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R10,0xFFFF9C60);
		/* 8209A56Ch case    3:*/		return 0x8209A570;
		  /* 8209A570h */ case    4:  		/* rlwinm R11, R30, 0, 27, 31 */
		/* 8209A570h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R30);
		/* 8209A570h case    4:*/		return 0x8209A574;
		  /* 8209A574h */ case    5:  		/* mulli R29, R11, 72 */
		/* 8209A574h case    5:*/		cpu::op::mulli<0>(regs,&regs.R29,regs.R11,0x48);
		/* 8209A574h case    5:*/		return 0x8209A578;
		  /* 8209A578h */ case    6:  		/* lwzx R11, <#[R27 + R28]> */
		/* 8209A578h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + regs.R28 + 0x00000000) );
		/* 8209A578h case    6:*/		return 0x8209A57C;
		  /* 8209A57Ch */ case    7:  		/* add R11, R11, R29 */
		/* 8209A57Ch case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8209A57Ch case    7:*/		return 0x8209A580;
		  /* 8209A580h */ case    8:  		/* lbz R11, <#[R11 + 4]> */
		/* 8209A580h case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8209A580h case    8:*/		return 0x8209A584;
		  /* 8209A584h */ case    9:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8209A584h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8209A584h case    9:*/		return 0x8209A588;
		  /* 8209A588h */ case   10:  		/* bc 12, CR0_EQ, -76 */
		/* 8209A588h case   10:*/		if ( regs.CR[0].eq ) { return 0x8209A53C;  }
		/* 8209A588h case   10:*/		return 0x8209A58C;
		  /* 8209A58Ch */ case   11:  		/* mr R3, R30 */
		/* 8209A58Ch case   11:*/		regs.R3 = regs.R30;
		/* 8209A58Ch case   11:*/		return 0x8209A590;
		  /* 8209A590h */ case   12:  		/* bl 13400 */
		/* 8209A590h case   12:*/		regs.LR = 0x8209A594; return 0x8209D9E8;
		/* 8209A590h case   12:*/		return 0x8209A594;
		  /* 8209A594h */ case   13:  		/* nop */
		/* 8209A594h case   13:*/		cpu::op::nop();
		/* 8209A594h case   13:*/		return 0x8209A598;
	}
	return 0x8209A598;
} // Block from 8209A560h-8209A598h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209A598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A598);
		  /* 8209A598h */ case    0:  		/* lwzx R11, <#[R27 + R28]> */
		/* 8209A598h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + regs.R28 + 0x00000000) );
		/* 8209A598h case    0:*/		return 0x8209A59C;
		  /* 8209A59Ch */ case    1:  		/* add R11, R11, R29 */
		/* 8209A59Ch case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8209A59Ch case    1:*/		return 0x8209A5A0;
		  /* 8209A5A0h */ case    2:  		/* lbz R11, <#[R11 + 4]> */
		/* 8209A5A0h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8209A5A0h case    2:*/		return 0x8209A5A4;
		  /* 8209A5A4h */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8209A5A4h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8209A5A4h case    3:*/		return 0x8209A5A8;
		  /* 8209A5A8h */ case    4:  		/* bc 12, CR0_EQ, 28 */
		/* 8209A5A8h case    4:*/		if ( regs.CR[0].eq ) { return 0x8209A5C4;  }
		/* 8209A5A8h case    4:*/		return 0x8209A5AC;
		  /* 8209A5ACh */ case    5:  		/* mr R5, R25 */
		/* 8209A5ACh case    5:*/		regs.R5 = regs.R25;
		/* 8209A5ACh case    5:*/		return 0x8209A5B0;
		  /* 8209A5B0h */ case    6:  		/* mr R4, R26 */
		/* 8209A5B0h case    6:*/		regs.R4 = regs.R26;
		/* 8209A5B0h case    6:*/		return 0x8209A5B4;
		  /* 8209A5B4h */ case    7:  		/* mr R3, R30 */
		/* 8209A5B4h case    7:*/		regs.R3 = regs.R30;
		/* 8209A5B4h case    7:*/		return 0x8209A5B8;
		  /* 8209A5B8h */ case    8:  		/* bl -808 */
		/* 8209A5B8h case    8:*/		regs.LR = 0x8209A5BC; return 0x8209A290;
		/* 8209A5B8h case    8:*/		return 0x8209A5BC;
		  /* 8209A5BCh */ case    9:  		/* stw R3, <#[R31 + 80]> */
		/* 8209A5BCh case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 8209A5BCh case    9:*/		return 0x8209A5C0;
		  /* 8209A5C0h */ case   10:  		/* b 36 */
		/* 8209A5C0h case   10:*/		return 0x8209A5E4;
		/* 8209A5C0h case   10:*/		return 0x8209A5C4;
	}
	return 0x8209A5C4;
} // Block from 8209A598h-8209A5C4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209A5C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A5C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A5C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A5C4);
		  /* 8209A5C4h */ case    0:  		/* bl -22204 */
		/* 8209A5C4h case    0:*/		regs.LR = 0x8209A5C8; return 0x82094F08;
		/* 8209A5C4h case    0:*/		return 0x8209A5C8;
		  /* 8209A5C8h */ case    1:  		/* li R11, 9 */
		/* 8209A5C8h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 8209A5C8h case    1:*/		return 0x8209A5CC;
		  /* 8209A5CCh */ case    2:  		/* stw R11, <#[R3]> */
		/* 8209A5CCh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209A5CCh case    2:*/		return 0x8209A5D0;
		  /* 8209A5D0h */ case    3:  		/* bl -22160 */
		/* 8209A5D0h case    3:*/		regs.LR = 0x8209A5D4; return 0x82094F40;
		/* 8209A5D0h case    3:*/		return 0x8209A5D4;
		  /* 8209A5D4h */ case    4:  		/* li R11, 0 */
		/* 8209A5D4h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209A5D4h case    4:*/		return 0x8209A5D8;
		  /* 8209A5D8h */ case    5:  		/* li R10, -1 */
		/* 8209A5D8h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8209A5D8h case    5:*/		return 0x8209A5DC;
		  /* 8209A5DCh */ case    6:  		/* stw R11, <#[R3]> */
		/* 8209A5DCh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209A5DCh case    6:*/		return 0x8209A5E0;
		  /* 8209A5E0h */ case    7:  		/* stw R10, <#[R31 + 80]> */
		/* 8209A5E0h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 8209A5E0h case    7:*/		return 0x8209A5E4;
	}
	return 0x8209A5E4;
} // Block from 8209A5C4h-8209A5E4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209A5E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A5E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A5E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A5E4);
		  /* 8209A5E4h */ case    0:  		/* nop */
		/* 8209A5E4h case    0:*/		cpu::op::nop();
		/* 8209A5E4h case    0:*/		return 0x8209A5E8;
		  /* 8209A5E8h */ case    1:  		/* addi R12, R31, 160 */
		/* 8209A5E8h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R31,0xA0);
		/* 8209A5E8h case    1:*/		return 0x8209A5EC;
		  /* 8209A5ECh */ case    2:  		/* bl 48 */
		/* 8209A5ECh case    2:*/		regs.LR = 0x8209A5F0; return 0x8209A61C;
		/* 8209A5ECh case    2:*/		return 0x8209A5F0;
		  /* 8209A5F0h */ case    3:  		/* lwz R3, <#[R31 + 80]> */
		/* 8209A5F0h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 8209A5F0h case    3:*/		return 0x8209A5F4;
	}
	return 0x8209A5F4;
} // Block from 8209A5E4h-8209A5F4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209A5F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A5F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A5F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A5F4);
		  /* 8209A5F4h */ case    0:  		/* addi R1, R31, 160 */
		/* 8209A5F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0xA0);
		/* 8209A5F4h case    0:*/		return 0x8209A5F8;
		  /* 8209A5F8h */ case    1:  		/* b -37724 */
		/* 8209A5F8h case    1:*/		return 0x8209129C;
		/* 8209A5F8h case    1:*/		return 0x8209A5FC;
	}
	return 0x8209A5FC;
} // Block from 8209A5F4h-8209A5FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209A5FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A5FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A5FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A5FC);
		  /* 8209A5FCh */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8209A5FCh case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A5FCh case    0:*/		return 0x8209A600;
		  /* 8209A600h */ case    1:  		/* addi R31, R12, -160 */
		/* 8209A600h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFF60);
		/* 8209A600h case    1:*/		return 0x8209A604;
		  /* 8209A604h */ case    2:  		/* std R30, <#[R1 - 16]> */
		/* 8209A604h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209A604h case    2:*/		return 0x8209A608;
		  /* 8209A608h */ case    3:  		/* mfspr R12, LR */
		/* 8209A608h case    3:*/		regs.R12 = regs.LR;
		/* 8209A608h case    3:*/		return 0x8209A60C;
		  /* 8209A60Ch */ case    4:  		/* stw R12, <#[R1 - 24]> */
		/* 8209A60Ch case    4:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209A60Ch case    4:*/		return 0x8209A610;
		  /* 8209A610h */ case    5:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209A610h case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209A610h case    5:*/		return 0x8209A614;
		  /* 8209A614h */ case    6:  		/* lwz R30, <#[R31 + 180]> */
		/* 8209A614h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x000000B4) );
		/* 8209A614h case    6:*/		return 0x8209A618;
		  /* 8209A618h */ case    7:  		/* b 28 */
		/* 8209A618h case    7:*/		return 0x8209A634;
		/* 8209A618h case    7:*/		return 0x8209A61C;
	}
	return 0x8209A61C;
} // Block from 8209A5FCh-8209A61Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209A61Ch
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A61C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A61C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A61C);
		  /* 8209A61Ch */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8209A61Ch case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A61Ch case    0:*/		return 0x8209A620;
		  /* 8209A620h */ case    1:  		/* addi R31, R12, -160 */
		/* 8209A620h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFF60);
		/* 8209A620h case    1:*/		return 0x8209A624;
		  /* 8209A624h */ case    2:  		/* std R30, <#[R1 - 16]> */
		/* 8209A624h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209A624h case    2:*/		return 0x8209A628;
		  /* 8209A628h */ case    3:  		/* mfspr R12, LR */
		/* 8209A628h case    3:*/		regs.R12 = regs.LR;
		/* 8209A628h case    3:*/		return 0x8209A62C;
		  /* 8209A62Ch */ case    4:  		/* stw R12, <#[R1 - 24]> */
		/* 8209A62Ch case    4:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209A62Ch case    4:*/		return 0x8209A630;
		  /* 8209A630h */ case    5:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209A630h case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209A630h case    5:*/		return 0x8209A634;
	}
	return 0x8209A634;
} // Block from 8209A61Ch-8209A634h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209A634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A634);
		  /* 8209A634h */ case    0:  		/* mr R3, R30 */
		/* 8209A634h case    0:*/		regs.R3 = regs.R30;
		/* 8209A634h case    0:*/		return 0x8209A638;
		  /* 8209A638h */ case    1:  		/* bl 13488 */
		/* 8209A638h case    1:*/		regs.LR = 0x8209A63C; return 0x8209DAE8;
		/* 8209A638h case    1:*/		return 0x8209A63C;
		  /* 8209A63Ch */ case    2:  		/* lwz R1, <#[R1]> */
		/* 8209A63Ch case    2:*/		cpu::mem::load32z( regs, &regs.R1, (uint32)(regs.R1 + 0x00000000) );
		/* 8209A63Ch case    2:*/		return 0x8209A640;
		  /* 8209A640h */ case    3:  		/* ld R31, <#[R1 - 8]> */
		/* 8209A640h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A640h case    3:*/		return 0x8209A644;
		  /* 8209A644h */ case    4:  		/* ld R30, <#[R1 - 16]> */
		/* 8209A644h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209A644h case    4:*/		return 0x8209A648;
		  /* 8209A648h */ case    5:  		/* lwz R12, <#[R1 - 24]> */
		/* 8209A648h case    5:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209A648h case    5:*/		return 0x8209A64C;
		  /* 8209A64Ch */ case    6:  		/* mtspr LR, R12 */
		/* 8209A64Ch case    6:*/		regs.LR = regs.R12;
		/* 8209A64Ch case    6:*/		return 0x8209A650;
		  /* 8209A650h */ case    7:  		/* bclr 20, CR0_LT */
		/* 8209A650h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209A650h case    7:*/		return 0x8209A654;
	}
	return 0x8209A654;
} // Block from 8209A634h-8209A654h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209A654h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A654( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A654) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A654);
		  /* 8209A654h */ case    0:  		/* nop */
		/* 8209A654h case    0:*/		cpu::op::nop();
		/* 8209A654h case    0:*/		return 0x8209A658;
	}
	return 0x8209A658;
} // Block from 8209A654h-8209A658h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209A658h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A658);
		  /* 8209A658h */ case    0:  		/* mfspr R12, LR */
		/* 8209A658h case    0:*/		regs.R12 = regs.LR;
		/* 8209A658h case    0:*/		return 0x8209A65C;
		  /* 8209A65Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209A65Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A65Ch case    1:*/		return 0x8209A660;
		  /* 8209A660h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8209A660h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209A660h case    2:*/		return 0x8209A664;
		  /* 8209A664h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209A664h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209A664h case    3:*/		return 0x8209A668;
		  /* 8209A668h */ case    4:  		/* lis R10, -32215 */
		/* 8209A668h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 8209A668h case    4:*/		return 0x8209A66C;
		  /* 8209A66Ch */ case    5:  		/* mr R31, R3 */
		/* 8209A66Ch case    5:*/		regs.R31 = regs.R3;
		/* 8209A66Ch case    5:*/		return 0x8209A670;
		  /* 8209A670h */ case    6:  		/* li R3, 4096 */
		/* 8209A670h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x1000);
		/* 8209A670h case    6:*/		return 0x8209A674;
		  /* 8209A674h */ case    7:  		/* lwz R11, <#[R10 - 30256]> */
		/* 8209A674h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0xFFFF89D0) );
		/* 8209A674h case    7:*/		return 0x8209A678;
		  /* 8209A678h */ case    8:  		/* addi R11, R11, 1 */
		/* 8209A678h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209A678h case    8:*/		return 0x8209A67C;
		  /* 8209A67Ch */ case    9:  		/* stw R11, <#[R10 - 30256]> */
		/* 8209A67Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0xFFFF89D0) );
		/* 8209A67Ch case    9:*/		return 0x8209A680;
		  /* 8209A680h */ case   10:  		/* bl -28152 */
		/* 8209A680h case   10:*/		regs.LR = 0x8209A684; return 0x82093888;
		/* 8209A680h case   10:*/		return 0x8209A684;
		  /* 8209A684h */ case   11:  		/* lwz R11, <#[R31 + 12]> */
		/* 8209A684h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209A684h case   11:*/		return 0x8209A688;
		  /* 8209A688h */ case   12:  		/* cmplwi CR0, R3, 0 */
		/* 8209A688h case   12:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8209A688h case   12:*/		return 0x8209A68C;
		  /* 8209A68Ch */ case   13:  		/* stw R3, <#[R31 + 8]> */
		/* 8209A68Ch case   13:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 8209A68Ch case   13:*/		return 0x8209A690;
		  /* 8209A690h */ case   14:  		/* bc 12, CR0_EQ, 20 */
		/* 8209A690h case   14:*/		if ( regs.CR[0].eq ) { return 0x8209A6A4;  }
		/* 8209A690h case   14:*/		return 0x8209A694;
		  /* 8209A694h */ case   15:  		/* li R10, 4096 */
		/* 8209A694h case   15:*/		cpu::op::li<0>(regs,&regs.R10,0x1000);
		/* 8209A694h case   15:*/		return 0x8209A698;
		  /* 8209A698h */ case   16:  		/* ori R11, R11, 8 */
		/* 8209A698h case   16:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8209A698h case   16:*/		return 0x8209A69C;
		  /* 8209A69Ch */ case   17:  		/* stw R10, <#[R31 + 24]> */
		/* 8209A69Ch case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 8209A69Ch case   17:*/		return 0x8209A6A0;
		  /* 8209A6A0h */ case   18:  		/* b 24 */
		/* 8209A6A0h case   18:*/		return 0x8209A6B8;
		/* 8209A6A0h case   18:*/		return 0x8209A6A4;
	}
	return 0x8209A6A4;
} // Block from 8209A658h-8209A6A4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8209A6A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A6A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A6A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A6A4);
		  /* 8209A6A4h */ case    0:  		/* addi R10, R31, 20 */
		/* 8209A6A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x14);
		/* 8209A6A4h case    0:*/		return 0x8209A6A8;
		  /* 8209A6A8h */ case    1:  		/* li R9, 2 */
		/* 8209A6A8h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 8209A6A8h case    1:*/		return 0x8209A6AC;
		  /* 8209A6ACh */ case    2:  		/* ori R11, R11, 4 */
		/* 8209A6ACh case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8209A6ACh case    2:*/		return 0x8209A6B0;
		  /* 8209A6B0h */ case    3:  		/* stw R10, <#[R31 + 8]> */
		/* 8209A6B0h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8209A6B0h case    3:*/		return 0x8209A6B4;
		  /* 8209A6B4h */ case    4:  		/* stw R9, <#[R31 + 24]> */
		/* 8209A6B4h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 8209A6B4h case    4:*/		return 0x8209A6B8;
	}
	return 0x8209A6B8;
} // Block from 8209A6A4h-8209A6B8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209A6B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A6B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A6B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A6B8);
		  /* 8209A6B8h */ case    0:  		/* stw R11, <#[R31 + 12]> */
		/* 8209A6B8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209A6B8h case    0:*/		return 0x8209A6BC;
		  /* 8209A6BCh */ case    1:  		/* li R10, 0 */
		/* 8209A6BCh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8209A6BCh case    1:*/		return 0x8209A6C0;
		  /* 8209A6C0h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 8209A6C0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8209A6C0h case    2:*/		return 0x8209A6C4;
		  /* 8209A6C4h */ case    3:  		/* stw R10, <#[R31 + 4]> */
		/* 8209A6C4h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8209A6C4h case    3:*/		return 0x8209A6C8;
		  /* 8209A6C8h */ case    4:  		/* stw R11, <#[R31]> */
		/* 8209A6C8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209A6C8h case    4:*/		return 0x8209A6CC;
		  /* 8209A6CCh */ case    5:  		/* addi R1, R1, 96 */
		/* 8209A6CCh case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209A6CCh case    5:*/		return 0x8209A6D0;
		  /* 8209A6D0h */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209A6D0h case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A6D0h case    6:*/		return 0x8209A6D4;
		  /* 8209A6D4h */ case    7:  		/* mtspr LR, R12 */
		/* 8209A6D4h case    7:*/		regs.LR = regs.R12;
		/* 8209A6D4h case    7:*/		return 0x8209A6D8;
		  /* 8209A6D8h */ case    8:  		/* ld R31, <#[R1 - 16]> */
		/* 8209A6D8h case    8:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209A6D8h case    8:*/		return 0x8209A6DC;
		  /* 8209A6DCh */ case    9:  		/* bclr 20, CR0_LT */
		/* 8209A6DCh case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209A6DCh case    9:*/		return 0x8209A6E0;
	}
	return 0x8209A6E0;
} // Block from 8209A6B8h-8209A6E0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209A6E0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A6E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A6E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A6E0);
		  /* 8209A6E0h */ case    0:  		/* lis R11, -32217 */
		/* 8209A6E0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 8209A6E0h case    0:*/		return 0x8209A6E4;
		  /* 8209A6E4h */ case    1:  		/* addi R3, R11, 8944 */
		/* 8209A6E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x22F0);
		/* 8209A6E4h case    1:*/		return 0x8209A6E8;
		  /* 8209A6E8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8209A6E8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209A6E8h case    2:*/		return 0x8209A6EC;
	}
	return 0x8209A6EC;
} // Block from 8209A6E0h-8209A6ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209A6ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A6EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A6EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A6EC);
		  /* 8209A6ECh */ case    0:  		/* nop */
		/* 8209A6ECh case    0:*/		cpu::op::nop();
		/* 8209A6ECh case    0:*/		return 0x8209A6F0;
	}
	return 0x8209A6F0;
} // Block from 8209A6ECh-8209A6F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209A6F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A6F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A6F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A6F0);
		  /* 8209A6F0h */ case    0:  		/* mfspr R12, LR */
		/* 8209A6F0h case    0:*/		regs.R12 = regs.LR;
		/* 8209A6F0h case    0:*/		return 0x8209A6F4;
		  /* 8209A6F4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209A6F4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A6F4h case    1:*/		return 0x8209A6F8;
		  /* 8209A6F8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8209A6F8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209A6F8h case    2:*/		return 0x8209A6FC;
		  /* 8209A6FCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8209A6FCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209A6FCh case    3:*/		return 0x8209A700;
		  /* 8209A700h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209A700h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209A700h case    4:*/		return 0x8209A704;
		  /* 8209A704h */ case    5:  		/* lis R31, -32215 */
		/* 8209A704h case    5:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8229);
		/* 8209A704h case    5:*/		return 0x8209A708;
		  /* 8209A708h */ case    6:  		/* lwz R3, <#[R31 - 25516]> */
		/* 8209A708h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0xFFFF9C54) );
		/* 8209A708h case    6:*/		return 0x8209A70C;
		  /* 8209A70Ch */ case    7:  		/* cmpwi CR6, R3, 0 */
		/* 8209A70Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8209A70Ch case    7:*/		return 0x8209A710;
		  /* 8209A710h */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 8209A710h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8209A71C;  }
		/* 8209A710h case    8:*/		return 0x8209A714;
		  /* 8209A714h */ case    9:  		/* li R3, 512 */
		/* 8209A714h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x200);
		/* 8209A714h case    9:*/		return 0x8209A718;
		  /* 8209A718h */ case   10:  		/* b 16 */
		/* 8209A718h case   10:*/		return 0x8209A728;
		/* 8209A718h case   10:*/		return 0x8209A71C;
	}
	return 0x8209A71C;
} // Block from 8209A6F0h-8209A71Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209A71Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A71C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A71C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A71C);
		  /* 8209A71Ch */ case    0:  		/* cmpwi CR6, R3, 20 */
		/* 8209A71Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000014);
		/* 8209A71Ch case    0:*/		return 0x8209A720;
		  /* 8209A720h */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 8209A720h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8209A72C;  }
		/* 8209A720h case    1:*/		return 0x8209A724;
		  /* 8209A724h */ case    2:  		/* li R3, 20 */
		/* 8209A724h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 8209A724h case    2:*/		return 0x8209A728;
	}
	return 0x8209A728;
} // Block from 8209A71Ch-8209A728h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209A728h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A728);
		  /* 8209A728h */ case    0:  		/* stw R3, <#[R31 - 25516]> */
		/* 8209A728h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0xFFFF9C54) );
		/* 8209A728h case    0:*/		return 0x8209A72C;
	}
	return 0x8209A72C;
} // Block from 8209A728h-8209A72Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209A72Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A72C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A72C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A72C);
		  /* 8209A72Ch */ case    0:  		/* li R4, 4 */
		/* 8209A72Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 8209A72Ch case    0:*/		return 0x8209A730;
		  /* 8209A730h */ case    1:  		/* bl -5032 */
		/* 8209A730h case    1:*/		regs.LR = 0x8209A734; return 0x82099388;
		/* 8209A730h case    1:*/		return 0x8209A734;
		  /* 8209A734h */ case    2:  		/* lis R30, -32215 */
		/* 8209A734h case    2:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8229);
		/* 8209A734h case    2:*/		return 0x8209A738;
		  /* 8209A738h */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 8209A738h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8209A738h case    3:*/		return 0x8209A73C;
		  /* 8209A73Ch */ case    4:  		/* stw R3, <#[R30 - 25520]> */
		/* 8209A73Ch case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0xFFFF9C50) );
		/* 8209A73Ch case    4:*/		return 0x8209A740;
		  /* 8209A740h */ case    5:  		/* bc 4, CR0_EQ, 44 */
		/* 8209A740h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8209A76C;  }
		/* 8209A740h case    5:*/		return 0x8209A744;
		  /* 8209A744h */ case    6:  		/* li R11, 20 */
		/* 8209A744h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x14);
		/* 8209A744h case    6:*/		return 0x8209A748;
	}
	return 0x8209A748;
} // Block from 8209A72Ch-8209A748h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209A748h
// Function '_write'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A748);
		  /* 8209A748h */ case    0:  		/* li R4, 4 */
		/* 8209A748h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 8209A748h case    0:*/		return 0x8209A74C;
		  /* 8209A74Ch */ case    1:  		/* li R3, 20 */
		/* 8209A74Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 8209A74Ch case    1:*/		return 0x8209A750;
		  /* 8209A750h */ case    2:  		/* stw R11, <#[R31 - 25516]> */
		/* 8209A750h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0xFFFF9C54) );
		/* 8209A750h case    2:*/		return 0x8209A754;
		  /* 8209A754h */ case    3:  		/* bl -5068 */
		/* 8209A754h case    3:*/		regs.LR = 0x8209A758; return 0x82099388;
		/* 8209A754h case    3:*/		return 0x8209A758;
		  /* 8209A758h */ case    4:  		/* stw R3, <#[R30 - 25520]> */
		/* 8209A758h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0xFFFF9C50) );
		/* 8209A758h case    4:*/		return 0x8209A75C;
		  /* 8209A75Ch */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 8209A75Ch case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8209A75Ch case    5:*/		return 0x8209A760;
		  /* 8209A760h */ case    6:  		/* bc 4, CR0_EQ, 12 */
		/* 8209A760h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8209A76C;  }
		/* 8209A760h case    6:*/		return 0x8209A764;
		  /* 8209A764h */ case    7:  		/* li R3, 26 */
		/* 8209A764h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x1A);
		/* 8209A764h case    7:*/		return 0x8209A768;
		  /* 8209A768h */ case    8:  		/* b 148 */
		/* 8209A768h case    8:*/		return 0x8209A7FC;
		/* 8209A768h case    8:*/		return 0x8209A76C;
	}
	return 0x8209A76C;
} // Block from 8209A748h-8209A76Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209A76Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A76C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A76C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A76C);
		  /* 8209A76Ch */ case    0:  		/* lis R11, -32217 */
		/* 8209A76Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 8209A76Ch case    0:*/		return 0x8209A770;
		  /* 8209A770h */ case    1:  		/* li R9, 20 */
		/* 8209A770h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x14);
		/* 8209A770h case    1:*/		return 0x8209A774;
		  /* 8209A774h */ case    2:  		/* addi R8, R11, 8944 */
		/* 8209A774h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x22F0);
		/* 8209A774h case    2:*/		return 0x8209A778;
		  /* 8209A778h */ case    3:  		/* li R10, 0 */
		/* 8209A778h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8209A778h case    3:*/		return 0x8209A77C;
		  /* 8209A77Ch */ case    4:  		/* mr R11, R8 */
		/* 8209A77Ch case    4:*/		regs.R11 = regs.R8;
		/* 8209A77Ch case    4:*/		return 0x8209A780;
		  /* 8209A780h */ case    5:  		/* mtspr CTR, R9 */
		/* 8209A780h case    5:*/		regs.CTR = regs.R9;
		/* 8209A780h case    5:*/		return 0x8209A784;
		  /* 8209A784h */ case    6:  		/* b 8 */
		/* 8209A784h case    6:*/		return 0x8209A78C;
		/* 8209A784h case    6:*/		return 0x8209A788;
		  /* 8209A788h */ case    7:  		/* lwz R3, <#[R30 - 25520]> */
		/* 8209A788h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0xFFFF9C50) );
		/* 8209A788h case    7:*/		return 0x8209A78C;
	}
	return 0x8209A78C;
} // Block from 8209A76Ch-8209A78Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209A78Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A78C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A78C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A78C);
		  /* 8209A78Ch */ case    0:  		/* stwx R11, <#[R10 + R3]> */
		/* 8209A78Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 8209A78Ch case    0:*/		return 0x8209A790;
		  /* 8209A790h */ case    1:  		/* addi R11, R11, 32 */
		/* 8209A790h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x20);
		/* 8209A790h case    1:*/		return 0x8209A794;
		  /* 8209A794h */ case    2:  		/* addi R10, R10, 4 */
		/* 8209A794h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8209A794h case    2:*/		return 0x8209A798;
		  /* 8209A798h */ case    3:  		/* bc 16, CR0_LT, -16 */
		/* 8209A798h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209A788;  }
		/* 8209A798h case    3:*/		return 0x8209A79C;
		  /* 8209A79Ch */ case    4:  		/* li R10, 3 */
		/* 8209A79Ch case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 8209A79Ch case    4:*/		return 0x8209A7A0;
		  /* 8209A7A0h */ case    5:  		/* addi R9, R8, 16 */
		/* 8209A7A0h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R8,0x10);
		/* 8209A7A0h case    5:*/		return 0x8209A7A4;
		  /* 8209A7A4h */ case    6:  		/* li R11, 0 */
		/* 8209A7A4h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209A7A4h case    6:*/		return 0x8209A7A8;
		  /* 8209A7A8h */ case    7:  		/* mtspr CTR, R10 */
		/* 8209A7A8h case    7:*/		regs.CTR = regs.R10;
		/* 8209A7A8h case    7:*/		return 0x8209A7AC;
		  /* 8209A7ACh */ case    8:  		/* lis R10, -32215 */
		/* 8209A7ACh case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 8209A7ACh case    8:*/		return 0x8209A7B0;
		  /* 8209A7B0h */ case    9:  		/* addi R8, R10, -25504 */
		/* 8209A7B0h case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xFFFF9C60);
		/* 8209A7B0h case    9:*/		return 0x8209A7B4;
		  /* 8209A7B4h */ case   10:  		/* srawi R10, R11, 5 */
		/* 8209A7B4h case   10:*/		cpu::op::srawi<0,5>(regs,&regs.R10,regs.R11);
		/* 8209A7B4h case   10:*/		return 0x8209A7B8;
		  /* 8209A7B8h */ case   11:  		/* rlwinm R7, R11, 0, 27, 31 */
		/* 8209A7B8h case   11:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R11);
		/* 8209A7B8h case   11:*/		return 0x8209A7BC;
		  /* 8209A7BCh */ case   12:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8209A7BCh case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8209A7BCh case   12:*/		return 0x8209A7C0;
		  /* 8209A7C0h */ case   13:  		/* mulli R7, R7, 72 */
		/* 8209A7C0h case   13:*/		cpu::op::mulli<0>(regs,&regs.R7,regs.R7,0x48);
		/* 8209A7C0h case   13:*/		return 0x8209A7C4;
		  /* 8209A7C4h */ case   14:  		/* lwzx R10, <#[R10 + R8]> */
		/* 8209A7C4h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 8209A7C4h case   14:*/		return 0x8209A7C8;
		  /* 8209A7C8h */ case   15:  		/* lwzx R10, <#[R10 + R7]> */
		/* 8209A7C8h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 8209A7C8h case   15:*/		return 0x8209A7CC;
		  /* 8209A7CCh */ case   16:  		/* cmpwi CR6, R10, -1 */
		/* 8209A7CCh case   16:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8209A7CCh case   16:*/		return 0x8209A7D0;
		  /* 8209A7D0h */ case   17:  		/* bc 12, CR6_EQ, 20 */
		/* 8209A7D0h case   17:*/		if ( regs.CR[6].eq ) { return 0x8209A7E4;  }
		/* 8209A7D0h case   17:*/		return 0x8209A7D4;
		  /* 8209A7D4h */ case   18:  		/* cmpwi CR6, R10, -2 */
		/* 8209A7D4h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFE);
		/* 8209A7D4h case   18:*/		return 0x8209A7D8;
		  /* 8209A7D8h */ case   19:  		/* bc 12, CR6_EQ, 12 */
		/* 8209A7D8h case   19:*/		if ( regs.CR[6].eq ) { return 0x8209A7E4;  }
		/* 8209A7D8h case   19:*/		return 0x8209A7DC;
		  /* 8209A7DCh */ case   20:  		/* cmpwi CR6, R10, 0 */
		/* 8209A7DCh case   20:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8209A7DCh case   20:*/		return 0x8209A7E0;
		  /* 8209A7E0h */ case   21:  		/* bc 4, CR6_EQ, 12 */
		/* 8209A7E0h case   21:*/		if ( !regs.CR[6].eq ) { return 0x8209A7EC;  }
		/* 8209A7E0h case   21:*/		return 0x8209A7E4;
	}
	return 0x8209A7E4;
} // Block from 8209A78Ch-8209A7E4h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8209A7E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A7E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A7E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A7E4);
		  /* 8209A7E4h */ case    0:  		/* li R10, -2 */
		/* 8209A7E4h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFE);
		/* 8209A7E4h case    0:*/		return 0x8209A7E8;
		  /* 8209A7E8h */ case    1:  		/* stw R10, <#[R9]> */
		/* 8209A7E8h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8209A7E8h case    1:*/		return 0x8209A7EC;
	}
	return 0x8209A7EC;
} // Block from 8209A7E4h-8209A7ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209A7ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A7EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A7EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A7EC);
		  /* 8209A7ECh */ case    0:  		/* addi R11, R11, 1 */
		/* 8209A7ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209A7ECh case    0:*/		return 0x8209A7F0;
		  /* 8209A7F0h */ case    1:  		/* addi R9, R9, 32 */
		/* 8209A7F0h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x20);
		/* 8209A7F0h case    1:*/		return 0x8209A7F4;
		  /* 8209A7F4h */ case    2:  		/* bc 16, CR0_LT, -64 */
		/* 8209A7F4h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209A7B4;  }
		/* 8209A7F4h case    2:*/		return 0x8209A7F8;
		  /* 8209A7F8h */ case    3:  		/* li R3, 0 */
		/* 8209A7F8h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209A7F8h case    3:*/		return 0x8209A7FC;
	}
	return 0x8209A7FC;
} // Block from 8209A7ECh-8209A7FCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209A7FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A7FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A7FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A7FC);
		  /* 8209A7FCh */ case    0:  		/* addi R1, R1, 112 */
		/* 8209A7FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8209A7FCh case    0:*/		return 0x8209A800;
		  /* 8209A800h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209A800h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A800h case    1:*/		return 0x8209A804;
		  /* 8209A804h */ case    2:  		/* mtspr LR, R12 */
		/* 8209A804h case    2:*/		regs.LR = regs.R12;
		/* 8209A804h case    2:*/		return 0x8209A808;
		  /* 8209A808h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 8209A808h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209A808h case    3:*/		return 0x8209A80C;
		  /* 8209A80Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8209A80Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209A80Ch case    4:*/		return 0x8209A810;
		  /* 8209A810h */ case    5:  		/* bclr 20, CR0_LT */
		/* 8209A810h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209A810h case    5:*/		return 0x8209A814;
	}
	return 0x8209A814;
} // Block from 8209A7FCh-8209A814h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209A814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A814);
		  /* 8209A814h */ case    0:  		/* nop */
		/* 8209A814h case    0:*/		cpu::op::nop();
		/* 8209A814h case    0:*/		return 0x8209A818;
	}
	return 0x8209A818;
} // Block from 8209A814h-8209A818h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209A818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A818);
		  /* 8209A818h */ case    0:  		/* mfspr R12, LR */
		/* 8209A818h case    0:*/		regs.R12 = regs.LR;
		/* 8209A818h case    0:*/		return 0x8209A81C;
		  /* 8209A81Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209A81Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A81Ch case    1:*/		return 0x8209A820;
		  /* 8209A820h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209A820h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209A820h case    2:*/		return 0x8209A824;
		  /* 8209A824h */ case    3:  		/* bl 14028 */
		/* 8209A824h case    3:*/		regs.LR = 0x8209A828; return 0x8209DEF0;
		/* 8209A824h case    3:*/		return 0x8209A828;
		  /* 8209A828h */ case    4:  		/* lis R11, -32215 */
		/* 8209A828h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8209A828h case    4:*/		return 0x8209A82C;
		  /* 8209A82Ch */ case    5:  		/* lbz R11, <#[R11 - 30732]> */
		/* 8209A82Ch case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFF87F4) );
		/* 8209A82Ch case    5:*/		return 0x8209A830;
		  /* 8209A830h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 8209A830h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8209A830h case    6:*/		return 0x8209A834;
		  /* 8209A834h */ case    7:  		/* bc 12, CR0_EQ, 8 */
		/* 8209A834h case    7:*/		if ( regs.CR[0].eq ) { return 0x8209A83C;  }
		/* 8209A834h case    7:*/		return 0x8209A838;
		  /* 8209A838h */ case    8:  		/* bl 13024 */
		/* 8209A838h case    8:*/		regs.LR = 0x8209A83C; return 0x8209DB18;
		/* 8209A838h case    8:*/		return 0x8209A83C;
	}
	return 0x8209A83C;
} // Block from 8209A818h-8209A83Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209A83Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A83C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A83C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A83C);
		  /* 8209A83Ch */ case    0:  		/* lis R11, -32215 */
		/* 8209A83Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8209A83Ch case    0:*/		return 0x8209A840;
		  /* 8209A840h */ case    1:  		/* lwz R3, <#[R11 - 25520]> */
		/* 8209A840h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFF9C50) );
		/* 8209A840h case    1:*/		return 0x8209A844;
		  /* 8209A844h */ case    2:  		/* bl -28700 */
		/* 8209A844h case    2:*/		regs.LR = 0x8209A848; return 0x82093828;
		/* 8209A844h case    2:*/		return 0x8209A848;
		  /* 8209A848h */ case    3:  		/* addi R1, R1, 96 */
		/* 8209A848h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209A848h case    3:*/		return 0x8209A84C;
		  /* 8209A84Ch */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209A84Ch case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A84Ch case    4:*/		return 0x8209A850;
		  /* 8209A850h */ case    5:  		/* mtspr LR, R12 */
		/* 8209A850h case    5:*/		regs.LR = regs.R12;
		/* 8209A850h case    5:*/		return 0x8209A854;
		  /* 8209A854h */ case    6:  		/* bclr 20, CR0_LT */
		/* 8209A854h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209A854h case    6:*/		return 0x8209A858;
	}
	return 0x8209A858;
} // Block from 8209A83Ch-8209A858h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209A858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A858);
		  /* 8209A858h */ case    0:  		/* mfspr R12, LR */
		/* 8209A858h case    0:*/		regs.R12 = regs.LR;
		/* 8209A858h case    0:*/		return 0x8209A85C;
		  /* 8209A85Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209A85Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A85Ch case    1:*/		return 0x8209A860;
		  /* 8209A860h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8209A860h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209A860h case    2:*/		return 0x8209A864;
		  /* 8209A864h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209A864h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209A864h case    3:*/		return 0x8209A868;
		  /* 8209A868h */ case    4:  		/* lis R11, -32217 */
		/* 8209A868h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 8209A868h case    4:*/		return 0x8209A86C;
		  /* 8209A86Ch */ case    5:  		/* mr R31, R3 */
		/* 8209A86Ch case    5:*/		regs.R31 = regs.R3;
		/* 8209A86Ch case    5:*/		return 0x8209A870;
		  /* 8209A870h */ case    6:  		/* addi R11, R11, 8944 */
		/* 8209A870h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x22F0);
		/* 8209A870h case    6:*/		return 0x8209A874;
		  /* 8209A874h */ case    7:  		/* cmplw CR6, R3, R11 */
		/* 8209A874h case    7:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8209A874h case    7:*/		return 0x8209A878;
		  /* 8209A878h */ case    8:  		/* bc 12, CR6_LT, 48 */
		/* 8209A878h case    8:*/		if ( regs.CR[6].lt ) { return 0x8209A8A8;  }
		/* 8209A878h case    8:*/		return 0x8209A87C;
		  /* 8209A87Ch */ case    9:  		/* addi R10, R11, 608 */
		/* 8209A87Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x260);
		/* 8209A87Ch case    9:*/		return 0x8209A880;
		  /* 8209A880h */ case   10:  		/* cmplw CR6, R3, R10 */
		/* 8209A880h case   10:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 8209A880h case   10:*/		return 0x8209A884;
		  /* 8209A884h */ case   11:  		/* bc 12, CR6_GT, 36 */
		/* 8209A884h case   11:*/		if ( regs.CR[6].gt ) { return 0x8209A8A8;  }
		/* 8209A884h case   11:*/		return 0x8209A888;
		  /* 8209A888h */ case   12:  		/* subf R11, R11, R3 */
		/* 8209A888h case   12:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8209A888h case   12:*/		return 0x8209A88C;
		  /* 8209A88Ch */ case   13:  		/* srawi R11, R11, 5 */
		/* 8209A88Ch case   13:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R11);
		/* 8209A88Ch case   13:*/		return 0x8209A890;
		  /* 8209A890h */ case   14:  		/* addi R3, R11, 16 */
		/* 8209A890h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 8209A890h case   14:*/		return 0x8209A894;
		  /* 8209A894h */ case   15:  		/* bl -5692 */
		/* 8209A894h case   15:*/		regs.LR = 0x8209A898; return 0x82099258;
		/* 8209A894h case   15:*/		return 0x8209A898;
		  /* 8209A898h */ case   16:  		/* lwz R11, <#[R31 + 12]> */
		/* 8209A898h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209A898h case   16:*/		return 0x8209A89C;
		  /* 8209A89Ch */ case   17:  		/* ori R11, R11, 32768 */
		/* 8209A89Ch case   17:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 8209A89Ch case   17:*/		return 0x8209A8A0;
		  /* 8209A8A0h */ case   18:  		/* stw R11, <#[R31 + 12]> */
		/* 8209A8A0h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209A8A0h case   18:*/		return 0x8209A8A4;
		  /* 8209A8A4h */ case   19:  		/* b 12 */
		/* 8209A8A4h case   19:*/		return 0x8209A8B0;
		/* 8209A8A4h case   19:*/		return 0x8209A8A8;
	}
	return 0x8209A8A8;
} // Block from 8209A858h-8209A8A8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8209A8A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A8A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A8A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A8A8);
		  /* 8209A8A8h */ case    0:  		/* addi R3, R31, 32 */
		/* 8209A8A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x20);
		/* 8209A8A8h case    0:*/		return 0x8209A8AC;
		  /* 8209A8ACh */ case    1:  		/* bl 1910668 */
		/* 8209A8ACh case    1:*/		regs.LR = 0x8209A8B0; return 0x8226D038;
		/* 8209A8ACh case    1:*/		return 0x8209A8B0;
	}
	return 0x8209A8B0;
} // Block from 8209A8A8h-8209A8B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209A8B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A8B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A8B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A8B0);
		  /* 8209A8B0h */ case    0:  		/* addi R1, R1, 96 */
		/* 8209A8B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209A8B0h case    0:*/		return 0x8209A8B4;
		  /* 8209A8B4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209A8B4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A8B4h case    1:*/		return 0x8209A8B8;
		  /* 8209A8B8h */ case    2:  		/* mtspr LR, R12 */
		/* 8209A8B8h case    2:*/		regs.LR = regs.R12;
		/* 8209A8B8h case    2:*/		return 0x8209A8BC;
		  /* 8209A8BCh */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8209A8BCh case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209A8BCh case    3:*/		return 0x8209A8C0;
		  /* 8209A8C0h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8209A8C0h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209A8C0h case    4:*/		return 0x8209A8C4;
	}
	return 0x8209A8C4;
} // Block from 8209A8B0h-8209A8C4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209A8C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A8C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A8C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A8C4);
		  /* 8209A8C4h */ case    0:  		/* nop */
		/* 8209A8C4h case    0:*/		cpu::op::nop();
		/* 8209A8C4h case    0:*/		return 0x8209A8C8;
	}
	return 0x8209A8C8;
} // Block from 8209A8C4h-8209A8C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209A8C8h
// Function '_getbuf'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A8C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A8C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A8C8);
		  /* 8209A8C8h */ case    0:  		/* mfspr R12, LR */
		/* 8209A8C8h case    0:*/		regs.R12 = regs.LR;
		/* 8209A8C8h case    0:*/		return 0x8209A8CC;
		  /* 8209A8CCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209A8CCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A8CCh case    1:*/		return 0x8209A8D0;
		  /* 8209A8D0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8209A8D0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209A8D0h case    2:*/		return 0x8209A8D4;
		  /* 8209A8D4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209A8D4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209A8D4h case    3:*/		return 0x8209A8D8;
		  /* 8209A8D8h */ case    4:  		/* mr R31, R4 */
		/* 8209A8D8h case    4:*/		regs.R31 = regs.R4;
		/* 8209A8D8h case    4:*/		return 0x8209A8DC;
		  /* 8209A8DCh */ case    5:  		/* cmpwi CR6, R3, 20 */
		/* 8209A8DCh case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000014);
		/* 8209A8DCh case    5:*/		return 0x8209A8E0;
		  /* 8209A8E0h */ case    6:  		/* bc 4, CR6_LT, 28 */
		/* 8209A8E0h case    6:*/		if ( !regs.CR[6].lt ) { return 0x8209A8FC;  }
		/* 8209A8E0h case    6:*/		return 0x8209A8E4;
		  /* 8209A8E4h */ case    7:  		/* addi R3, R3, 16 */
		/* 8209A8E4h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x10);
		/* 8209A8E4h case    7:*/		return 0x8209A8E8;
		  /* 8209A8E8h */ case    8:  		/* bl -5776 */
		/* 8209A8E8h case    8:*/		regs.LR = 0x8209A8EC; return 0x82099258;
		/* 8209A8E8h case    8:*/		return 0x8209A8EC;
		  /* 8209A8ECh */ case    9:  		/* lwz R11, <#[R31 + 12]> */
		/* 8209A8ECh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209A8ECh case    9:*/		return 0x8209A8F0;
		  /* 8209A8F0h */ case   10:  		/* ori R11, R11, 32768 */
		/* 8209A8F0h case   10:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 8209A8F0h case   10:*/		return 0x8209A8F4;
		  /* 8209A8F4h */ case   11:  		/* stw R11, <#[R31 + 12]> */
		/* 8209A8F4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209A8F4h case   11:*/		return 0x8209A8F8;
		  /* 8209A8F8h */ case   12:  		/* b 12 */
		/* 8209A8F8h case   12:*/		return 0x8209A904;
		/* 8209A8F8h case   12:*/		return 0x8209A8FC;
	}
	return 0x8209A8FC;
} // Block from 8209A8C8h-8209A8FCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209A8FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A8FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A8FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A8FC);
		  /* 8209A8FCh */ case    0:  		/* addi R3, R31, 32 */
		/* 8209A8FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x20);
		/* 8209A8FCh case    0:*/		return 0x8209A900;
		  /* 8209A900h */ case    1:  		/* bl 1910584 */
		/* 8209A900h case    1:*/		regs.LR = 0x8209A904; return 0x8226D038;
		/* 8209A900h case    1:*/		return 0x8209A904;
	}
	return 0x8209A904;
} // Block from 8209A8FCh-8209A904h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209A904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A904);
		  /* 8209A904h */ case    0:  		/* addi R1, R1, 96 */
		/* 8209A904h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209A904h case    0:*/		return 0x8209A908;
		  /* 8209A908h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209A908h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A908h case    1:*/		return 0x8209A90C;
		  /* 8209A90Ch */ case    2:  		/* mtspr LR, R12 */
		/* 8209A90Ch case    2:*/		regs.LR = regs.R12;
		/* 8209A90Ch case    2:*/		return 0x8209A910;
		  /* 8209A910h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8209A910h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209A910h case    3:*/		return 0x8209A914;
		  /* 8209A914h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8209A914h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209A914h case    4:*/		return 0x8209A918;
	}
	return 0x8209A918;
} // Block from 8209A904h-8209A918h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209A918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A918);
		  /* 8209A918h */ case    0:  		/* lis R11, -32217 */
		/* 8209A918h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 8209A918h case    0:*/		return 0x8209A91C;
		  /* 8209A91Ch */ case    1:  		/* addi R11, R11, 8944 */
		/* 8209A91Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x22F0);
		/* 8209A91Ch case    1:*/		return 0x8209A920;
		  /* 8209A920h */ case    2:  		/* cmplw CR6, R3, R11 */
		/* 8209A920h case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8209A920h case    2:*/		return 0x8209A924;
		  /* 8209A924h */ case    3:  		/* bc 12, CR6_LT, 44 */
		/* 8209A924h case    3:*/		if ( regs.CR[6].lt ) { return 0x8209A950;  }
		/* 8209A924h case    3:*/		return 0x8209A928;
		  /* 8209A928h */ case    4:  		/* addi R10, R11, 608 */
		/* 8209A928h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x260);
		/* 8209A928h case    4:*/		return 0x8209A92C;
		  /* 8209A92Ch */ case    5:  		/* cmplw CR6, R3, R10 */
		/* 8209A92Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 8209A92Ch case    5:*/		return 0x8209A930;
		  /* 8209A930h */ case    6:  		/* bc 12, CR6_GT, 32 */
		/* 8209A930h case    6:*/		if ( regs.CR[6].gt ) { return 0x8209A950;  }
		/* 8209A930h case    6:*/		return 0x8209A934;
		  /* 8209A934h */ case    7:  		/* lwz R10, <#[R3 + 12]> */
		/* 8209A934h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 8209A934h case    7:*/		return 0x8209A938;
		  /* 8209A938h */ case    8:  		/* subf R11, R11, R3 */
		/* 8209A938h case    8:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8209A938h case    8:*/		return 0x8209A93C;
		  /* 8209A93Ch */ case    9:  		/* rlwinm R10, R10, 0, 17, 15 */
		/* 8209A93Ch case    9:*/		cpu::op::rlwinm<0,0,17,15>(regs,&regs.R10,regs.R10);
		/* 8209A93Ch case    9:*/		return 0x8209A940;
		  /* 8209A940h */ case   10:  		/* srawi R11, R11, 5 */
		/* 8209A940h case   10:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R11);
		/* 8209A940h case   10:*/		return 0x8209A944;
		  /* 8209A944h */ case   11:  		/* stw R10, <#[R3 + 12]> */
		/* 8209A944h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 8209A944h case   11:*/		return 0x8209A948;
		  /* 8209A948h */ case   12:  		/* addi R3, R11, 16 */
		/* 8209A948h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 8209A948h case   12:*/		return 0x8209A94C;
		  /* 8209A94Ch */ case   13:  		/* b -6516 */
		/* 8209A94Ch case   13:*/		return 0x82098FD8;
		/* 8209A94Ch case   13:*/		return 0x8209A950;
	}
	return 0x8209A950;
} // Block from 8209A918h-8209A950h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209A950h
// Function '__iob_func'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A950);
		  /* 8209A950h */ case    0:  		/* addi R3, R3, 32 */
		/* 8209A950h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x20);
		/* 8209A950h case    0:*/		return 0x8209A954;
		  /* 8209A954h */ case    1:  		/* b 1910484 */
		/* 8209A954h case    1:*/		return 0x8226D028;
		/* 8209A954h case    1:*/		return 0x8209A958;
		  /* 8209A958h */ case    2:  		/* cmpwi CR6, R3, 20 */
		/* 8209A958h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000014);
		/* 8209A958h case    2:*/		return 0x8209A95C;
		  /* 8209A95Ch */ case    3:  		/* bc 4, CR6_LT, 24 */
		/* 8209A95Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x8209A974;  }
		/* 8209A95Ch case    3:*/		return 0x8209A960;
	}
	return 0x8209A960;
} // Block from 8209A950h-8209A960h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209A960h
// Function '__initstdio'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A960);
		  /* 8209A960h */ case    0:  		/* lwz R11, <#[R4 + 12]> */
		/* 8209A960h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 8209A960h case    0:*/		return 0x8209A964;
		  /* 8209A964h */ case    1:  		/* addi R3, R3, 16 */
		/* 8209A964h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x10);
		/* 8209A964h case    1:*/		return 0x8209A968;
		  /* 8209A968h */ case    2:  		/* rlwinm R11, R11, 0, 17, 15 */
		/* 8209A968h case    2:*/		cpu::op::rlwinm<0,0,17,15>(regs,&regs.R11,regs.R11);
		/* 8209A968h case    2:*/		return 0x8209A96C;
		  /* 8209A96Ch */ case    3:  		/* stw R11, <#[R4 + 12]> */
		/* 8209A96Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 8209A96Ch case    3:*/		return 0x8209A970;
		  /* 8209A970h */ case    4:  		/* b -6552 */
		/* 8209A970h case    4:*/		return 0x82098FD8;
		/* 8209A970h case    4:*/		return 0x8209A974;
	}
	return 0x8209A974;
} // Block from 8209A960h-8209A974h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209A974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A974);
		  /* 8209A974h */ case    0:  		/* addi R3, R4, 32 */
		/* 8209A974h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R4,0x20);
		/* 8209A974h case    0:*/		return 0x8209A978;
		  /* 8209A978h */ case    1:  		/* b 1910448 */
		/* 8209A978h case    1:*/		return 0x8226D028;
		/* 8209A978h case    1:*/		return 0x8209A97C;
		  /* 8209A97Ch */ case    2:  		/* nop */
		/* 8209A97Ch case    2:*/		cpu::op::nop();
		/* 8209A97Ch case    2:*/		return 0x8209A980;
	}
	return 0x8209A980;
} // Block from 8209A974h-8209A980h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209A980h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A980);
		  /* 8209A980h */ case    0:  		/* mfspr R12, LR */
		/* 8209A980h case    0:*/		regs.R12 = regs.LR;
		/* 8209A980h case    0:*/		return 0x8209A984;
		  /* 8209A984h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209A984h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A984h case    1:*/		return 0x8209A988;
		  /* 8209A988h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209A988h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209A988h case    2:*/		return 0x8209A98C;
		  /* 8209A98Ch */ case    3:  		/* cmplwi CR6, R3, 0 */
		/* 8209A98Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209A98Ch case    3:*/		return 0x8209A990;
		  /* 8209A990h */ case    4:  		/* bc 4, CR6_EQ, 28 */
		/* 8209A990h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8209A9AC;  }
		/* 8209A990h case    4:*/		return 0x8209A994;
		  /* 8209A994h */ case    5:  		/* bl -23180 */
		/* 8209A994h case    5:*/		regs.LR = 0x8209A998; return 0x82094F08;
		/* 8209A994h case    5:*/		return 0x8209A998;
		  /* 8209A998h */ case    6:  		/* li R11, 22 */
		/* 8209A998h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 8209A998h case    6:*/		return 0x8209A99C;
		  /* 8209A99Ch */ case    7:  		/* stw R11, <#[R3]> */
		/* 8209A99Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209A99Ch case    7:*/		return 0x8209A9A0;
		  /* 8209A9A0h */ case    8:  		/* bl -28736 */
		/* 8209A9A0h case    8:*/		regs.LR = 0x8209A9A4; return 0x82093960;
		/* 8209A9A0h case    8:*/		return 0x8209A9A4;
		  /* 8209A9A4h */ case    9:  		/* li R3, -1 */
		/* 8209A9A4h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209A9A4h case    9:*/		return 0x8209A9A8;
		  /* 8209A9A8h */ case   10:  		/* b 8 */
		/* 8209A9A8h case   10:*/		return 0x8209A9B0;
		/* 8209A9A8h case   10:*/		return 0x8209A9AC;
	}
	return 0x8209A9AC;
} // Block from 8209A980h-8209A9ACh (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209A9ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A9AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A9AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A9AC);
		  /* 8209A9ACh */ case    0:  		/* lwz R3, <#[R3 + 16]> */
		/* 8209A9ACh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000010) );
		/* 8209A9ACh case    0:*/		return 0x8209A9B0;
	}
	return 0x8209A9B0;
} // Block from 8209A9ACh-8209A9B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209A9B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A9B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A9B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A9B0);
		  /* 8209A9B0h */ case    0:  		/* addi R1, R1, 96 */
		/* 8209A9B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209A9B0h case    0:*/		return 0x8209A9B4;
		  /* 8209A9B4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209A9B4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209A9B4h case    1:*/		return 0x8209A9B8;
		  /* 8209A9B8h */ case    2:  		/* mtspr LR, R12 */
		/* 8209A9B8h case    2:*/		regs.LR = regs.R12;
		/* 8209A9B8h case    2:*/		return 0x8209A9BC;
		  /* 8209A9BCh */ case    3:  		/* bclr 20, CR0_LT */
		/* 8209A9BCh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209A9BCh case    3:*/		return 0x8209A9C0;
	}
	return 0x8209A9C0;
} // Block from 8209A9B0h-8209A9C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209A9C0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209A9C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209A9C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209A9C0);
		  /* 8209A9C0h */ case    0:  		/* mfspr R12, LR */
		/* 8209A9C0h case    0:*/		regs.R12 = regs.LR;
		/* 8209A9C0h case    0:*/		return 0x8209A9C4;
		  /* 8209A9C4h */ case    1:  		/* bl -38768 */
		/* 8209A9C4h case    1:*/		regs.LR = 0x8209A9C8; return 0x82091254;
		/* 8209A9C4h case    1:*/		return 0x8209A9C8;
		  /* 8209A9C8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8209A9C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8209A9C8h case    2:*/		return 0x8209A9CC;
		  /* 8209A9CCh */ case    3:  		/* mr R27, R3 */
		/* 8209A9CCh case    3:*/		regs.R27 = regs.R3;
		/* 8209A9CCh case    3:*/		return 0x8209A9D0;
		  /* 8209A9D0h */ case    4:  		/* mr R31, R4 */
		/* 8209A9D0h case    4:*/		regs.R31 = regs.R4;
		/* 8209A9D0h case    4:*/		return 0x8209A9D4;
		  /* 8209A9D4h */ case    5:  		/* bl -756 */
		/* 8209A9D4h case    5:*/		regs.LR = 0x8209A9D8; return 0x8209A6E0;
		/* 8209A9D4h case    5:*/		return 0x8209A9D8;
		  /* 8209A9D8h */ case    6:  		/* addi R11, R3, 32 */
		/* 8209A9D8h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x20);
		/* 8209A9D8h case    6:*/		return 0x8209A9DC;
		  /* 8209A9DCh */ case    7:  		/* cmplw CR6, R31, R11 */
		/* 8209A9DCh case    7:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8209A9DCh case    7:*/		return 0x8209A9E0;
		  /* 8209A9E0h */ case    8:  		/* bc 12, CR6_EQ, 536 */
		/* 8209A9E0h case    8:*/		if ( regs.CR[6].eq ) { return 0x8209ABF8;  }
		/* 8209A9E0h case    8:*/		return 0x8209A9E4;
		  /* 8209A9E4h */ case    9:  		/* bl -772 */
		/* 8209A9E4h case    9:*/		regs.LR = 0x8209A9E8; return 0x8209A6E0;
		/* 8209A9E4h case    9:*/		return 0x8209A9E8;
		  /* 8209A9E8h */ case   10:  		/* addi R11, R3, 64 */
		/* 8209A9E8h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x40);
		/* 8209A9E8h case   10:*/		return 0x8209A9EC;
		  /* 8209A9ECh */ case   11:  		/* cmplw CR6, R31, R11 */
		/* 8209A9ECh case   11:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8209A9ECh case   11:*/		return 0x8209A9F0;
		  /* 8209A9F0h */ case   12:  		/* bc 12, CR6_EQ, 520 */
		/* 8209A9F0h case   12:*/		if ( regs.CR[6].eq ) { return 0x8209ABF8;  }
		/* 8209A9F0h case   12:*/		return 0x8209A9F4;
		  /* 8209A9F4h */ case   13:  		/* lwz R11, <#[R31 + 12]> */
		/* 8209A9F4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209A9F4h case   13:*/		return 0x8209A9F8;
		  /* 8209A9F8h */ case   14:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 8209A9F8h case   14:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 8209A9F8h case   14:*/		return 0x8209A9FC;
		  /* 8209A9FCh */ case   15:  		/* bc 4, CR0_EQ, 448 */
		/* 8209A9FCh case   15:*/		if ( !regs.CR[0].eq ) { return 0x8209ABBC;  }
		/* 8209A9FCh case   15:*/		return 0x8209AA00;
		  /* 8209AA00h */ case   16:  		/* mr R3, R31 */
		/* 8209AA00h case   16:*/		regs.R3 = regs.R31;
		/* 8209AA00h case   16:*/		return 0x8209AA04;
		  /* 8209AA04h */ case   17:  		/* bl -132 */
		/* 8209AA04h case   17:*/		regs.LR = 0x8209AA08; return 0x8209A980;
		/* 8209AA04h case   17:*/		return 0x8209AA08;
		  /* 8209AA08h */ case   18:  		/* lis R10, -32215 */
		/* 8209AA08h case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 8209AA08h case   18:*/		return 0x8209AA0C;
		  /* 8209AA0Ch */ case   19:  		/* lis R11, -32217 */
		/* 8209AA0Ch case   19:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 8209AA0Ch case   19:*/		return 0x8209AA10;
		  /* 8209AA10h */ case   20:  		/* cmpwi CR6, R3, -1 */
		/* 8209AA10h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8209AA10h case   20:*/		return 0x8209AA14;
		  /* 8209AA14h */ case   21:  		/* addi R30, R10, -25504 */
		/* 8209AA14h case   21:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R10,0xFFFF9C60);
		/* 8209AA14h case   21:*/		return 0x8209AA18;
		  /* 8209AA18h */ case   22:  		/* addi R28, R11, 8872 */
		/* 8209AA18h case   22:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0x22A8);
		/* 8209AA18h case   22:*/		return 0x8209AA1C;
		  /* 8209AA1Ch */ case   23:  		/* bc 12, CR6_EQ, 64 */
		/* 8209AA1Ch case   23:*/		if ( regs.CR[6].eq ) { return 0x8209AA5C;  }
		/* 8209AA1Ch case   23:*/		return 0x8209AA20;
		  /* 8209AA20h */ case   24:  		/* mr R3, R31 */
		/* 8209AA20h case   24:*/		regs.R3 = regs.R31;
		/* 8209AA20h case   24:*/		return 0x8209AA24;
		  /* 8209AA24h */ case   25:  		/* bl -164 */
		/* 8209AA24h case   25:*/		regs.LR = 0x8209AA28; return 0x8209A980;
		/* 8209AA24h case   25:*/		return 0x8209AA28;
		  /* 8209AA28h */ case   26:  		/* cmpwi CR6, R3, -2 */
		/* 8209AA28h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFE);
		/* 8209AA28h case   26:*/		return 0x8209AA2C;
		  /* 8209AA2Ch */ case   27:  		/* bc 12, CR6_EQ, 48 */
		/* 8209AA2Ch case   27:*/		if ( regs.CR[6].eq ) { return 0x8209AA5C;  }
		/* 8209AA2Ch case   27:*/		return 0x8209AA30;
		  /* 8209AA30h */ case   28:  		/* mr R3, R31 */
		/* 8209AA30h case   28:*/		regs.R3 = regs.R31;
		/* 8209AA30h case   28:*/		return 0x8209AA34;
		  /* 8209AA34h */ case   29:  		/* bl -180 */
		/* 8209AA34h case   29:*/		regs.LR = 0x8209AA38; return 0x8209A980;
		/* 8209AA34h case   29:*/		return 0x8209AA38;
		  /* 8209AA38h */ case   30:  		/* srawi R11, R3, 5 */
		/* 8209AA38h case   30:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R3);
		/* 8209AA38h case   30:*/		return 0x8209AA3C;
		  /* 8209AA3Ch */ case   31:  		/* mr R3, R31 */
		/* 8209AA3Ch case   31:*/		regs.R3 = regs.R31;
		/* 8209AA3Ch case   31:*/		return 0x8209AA40;
		  /* 8209AA40h */ case   32:  		/* rlwinm R29, R11, 2, 0, 29 */
		/* 8209AA40h case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R11);
		/* 8209AA40h case   32:*/		return 0x8209AA44;
		  /* 8209AA44h */ case   33:  		/* bl -196 */
		/* 8209AA44h case   33:*/		regs.LR = 0x8209AA48; return 0x8209A980;
		/* 8209AA44h case   33:*/		return 0x8209AA48;
		  /* 8209AA48h */ case   34:  		/* rlwinm R11, R3, 0, 27, 31 */
		/* 8209AA48h case   34:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R3);
		/* 8209AA48h case   34:*/		return 0x8209AA4C;
		  /* 8209AA4Ch */ case   35:  		/* lwzx R10, <#[R29 + R30]> */
		/* 8209AA4Ch case   35:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + regs.R30 + 0x00000000) );
		/* 8209AA4Ch case   35:*/		return 0x8209AA50;
		  /* 8209AA50h */ case   36:  		/* mulli R11, R11, 72 */
		/* 8209AA50h case   36:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x48);
		/* 8209AA50h case   36:*/		return 0x8209AA54;
		  /* 8209AA54h */ case   37:  		/* add R11, R11, R10 */
		/* 8209AA54h case   37:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8209AA54h case   37:*/		return 0x8209AA58;
		  /* 8209AA58h */ case   38:  		/* b 8 */
		/* 8209AA58h case   38:*/		return 0x8209AA60;
		/* 8209AA58h case   38:*/		return 0x8209AA5C;
	}
	return 0x8209AA5C;
} // Block from 8209A9C0h-8209AA5Ch (39 instructions)

//////////////////////////////////////////////////////
// Block at 8209AA5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AA5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AA5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AA5C);
		  /* 8209AA5Ch */ case    0:  		/* mr R11, R28 */
		/* 8209AA5Ch case    0:*/		regs.R11 = regs.R28;
		/* 8209AA5Ch case    0:*/		return 0x8209AA60;
	}
	return 0x8209AA60;
} // Block from 8209AA5Ch-8209AA60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209AA60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AA60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AA60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AA60);
		  /* 8209AA60h */ case    0:  		/* lbz R11, <#[R11 + 40]> */
		/* 8209AA60h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8209AA60h case    0:*/		return 0x8209AA64;
		  /* 8209AA64h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8209AA64h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8209AA64h case    1:*/		return 0x8209AA68;
		  /* 8209AA68h */ case    2:  		/* cmplwi CR6, R11, 4 */
		/* 8209AA68h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 8209AA68h case    2:*/		return 0x8209AA6C;
		  /* 8209AA6Ch */ case    3:  		/* bc 12, CR6_EQ, 336 */
		/* 8209AA6Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8209ABBC;  }
		/* 8209AA6Ch case    3:*/		return 0x8209AA70;
		  /* 8209AA70h */ case    4:  		/* mr R3, R31 */
		/* 8209AA70h case    4:*/		regs.R3 = regs.R31;
		/* 8209AA70h case    4:*/		return 0x8209AA74;
		  /* 8209AA74h */ case    5:  		/* bl -244 */
		/* 8209AA74h case    5:*/		regs.LR = 0x8209AA78; return 0x8209A980;
		/* 8209AA74h case    5:*/		return 0x8209AA78;
		  /* 8209AA78h */ case    6:  		/* cmpwi CR6, R3, -1 */
		/* 8209AA78h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8209AA78h case    6:*/		return 0x8209AA7C;
		  /* 8209AA7Ch */ case    7:  		/* bc 12, CR6_EQ, 64 */
		/* 8209AA7Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x8209AABC;  }
		/* 8209AA7Ch case    7:*/		return 0x8209AA80;
		  /* 8209AA80h */ case    8:  		/* mr R3, R31 */
		/* 8209AA80h case    8:*/		regs.R3 = regs.R31;
		/* 8209AA80h case    8:*/		return 0x8209AA84;
		  /* 8209AA84h */ case    9:  		/* bl -260 */
		/* 8209AA84h case    9:*/		regs.LR = 0x8209AA88; return 0x8209A980;
		/* 8209AA84h case    9:*/		return 0x8209AA88;
	}
	return 0x8209AA88;
} // Block from 8209AA60h-8209AA88h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209AA88h
// Function '__endstdio'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AA88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AA88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AA88);
		  /* 8209AA88h */ case    0:  		/* cmpwi CR6, R3, -2 */
		/* 8209AA88h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFE);
		/* 8209AA88h case    0:*/		return 0x8209AA8C;
		  /* 8209AA8Ch */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 8209AA8Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8209AABC;  }
		/* 8209AA8Ch case    1:*/		return 0x8209AA90;
		  /* 8209AA90h */ case    2:  		/* mr R3, R31 */
		/* 8209AA90h case    2:*/		regs.R3 = regs.R31;
		/* 8209AA90h case    2:*/		return 0x8209AA94;
		  /* 8209AA94h */ case    3:  		/* bl -276 */
		/* 8209AA94h case    3:*/		regs.LR = 0x8209AA98; return 0x8209A980;
		/* 8209AA94h case    3:*/		return 0x8209AA98;
		  /* 8209AA98h */ case    4:  		/* srawi R11, R3, 5 */
		/* 8209AA98h case    4:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R3);
		/* 8209AA98h case    4:*/		return 0x8209AA9C;
		  /* 8209AA9Ch */ case    5:  		/* mr R3, R31 */
		/* 8209AA9Ch case    5:*/		regs.R3 = regs.R31;
		/* 8209AA9Ch case    5:*/		return 0x8209AAA0;
		  /* 8209AAA0h */ case    6:  		/* rlwinm R29, R11, 2, 0, 29 */
		/* 8209AAA0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R11);
		/* 8209AAA0h case    6:*/		return 0x8209AAA4;
		  /* 8209AAA4h */ case    7:  		/* bl -292 */
		/* 8209AAA4h case    7:*/		regs.LR = 0x8209AAA8; return 0x8209A980;
		/* 8209AAA4h case    7:*/		return 0x8209AAA8;
		  /* 8209AAA8h */ case    8:  		/* rlwinm R11, R3, 0, 27, 31 */
		/* 8209AAA8h case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R3);
		/* 8209AAA8h case    8:*/		return 0x8209AAAC;
		  /* 8209AAACh */ case    9:  		/* lwzx R10, <#[R29 + R30]> */
		/* 8209AAACh case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + regs.R30 + 0x00000000) );
		/* 8209AAACh case    9:*/		return 0x8209AAB0;
		  /* 8209AAB0h */ case   10:  		/* mulli R11, R11, 72 */
		/* 8209AAB0h case   10:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x48);
		/* 8209AAB0h case   10:*/		return 0x8209AAB4;
		  /* 8209AAB4h */ case   11:  		/* add R11, R11, R10 */
		/* 8209AAB4h case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8209AAB4h case   11:*/		return 0x8209AAB8;
		  /* 8209AAB8h */ case   12:  		/* b 8 */
		/* 8209AAB8h case   12:*/		return 0x8209AAC0;
		/* 8209AAB8h case   12:*/		return 0x8209AABC;
	}
	return 0x8209AABC;
} // Block from 8209AA88h-8209AABCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209AABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AABC);
		  /* 8209AABCh */ case    0:  		/* mr R11, R28 */
		/* 8209AABCh case    0:*/		regs.R11 = regs.R28;
		/* 8209AABCh case    0:*/		return 0x8209AAC0;
	}
	return 0x8209AAC0;
} // Block from 8209AABCh-8209AAC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209AAC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AAC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AAC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AAC0);
		  /* 8209AAC0h */ case    0:  		/* lbz R11, <#[R11 + 40]> */
		/* 8209AAC0h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8209AAC0h case    0:*/		return 0x8209AAC4;
		  /* 8209AAC4h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8209AAC4h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8209AAC4h case    1:*/		return 0x8209AAC8;
	}
	return 0x8209AAC8;
} // Block from 8209AAC0h-8209AAC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209AAC8h
// Function '_lock_file'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AAC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AAC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AAC8);
		  /* 8209AAC8h */ case    0:  		/* cmplwi CR6, R11, 2 */
		/* 8209AAC8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 8209AAC8h case    0:*/		return 0x8209AACC;
		  /* 8209AACCh */ case    1:  		/* bc 12, CR6_EQ, 240 */
		/* 8209AACCh case    1:*/		if ( regs.CR[6].eq ) { return 0x8209ABBC;  }
		/* 8209AACCh case    1:*/		return 0x8209AAD0;
		  /* 8209AAD0h */ case    2:  		/* mr R3, R31 */
		/* 8209AAD0h case    2:*/		regs.R3 = regs.R31;
		/* 8209AAD0h case    2:*/		return 0x8209AAD4;
		  /* 8209AAD4h */ case    3:  		/* bl -340 */
		/* 8209AAD4h case    3:*/		regs.LR = 0x8209AAD8; return 0x8209A980;
		/* 8209AAD4h case    3:*/		return 0x8209AAD8;
		  /* 8209AAD8h */ case    4:  		/* cmpwi CR6, R3, -1 */
		/* 8209AAD8h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8209AAD8h case    4:*/		return 0x8209AADC;
		  /* 8209AADCh */ case    5:  		/* bc 12, CR6_EQ, 64 */
		/* 8209AADCh case    5:*/		if ( regs.CR[6].eq ) { return 0x8209AB1C;  }
		/* 8209AADCh case    5:*/		return 0x8209AAE0;
		  /* 8209AAE0h */ case    6:  		/* mr R3, R31 */
		/* 8209AAE0h case    6:*/		regs.R3 = regs.R31;
		/* 8209AAE0h case    6:*/		return 0x8209AAE4;
		  /* 8209AAE4h */ case    7:  		/* bl -356 */
		/* 8209AAE4h case    7:*/		regs.LR = 0x8209AAE8; return 0x8209A980;
		/* 8209AAE4h case    7:*/		return 0x8209AAE8;
		  /* 8209AAE8h */ case    8:  		/* cmpwi CR6, R3, -2 */
		/* 8209AAE8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFE);
		/* 8209AAE8h case    8:*/		return 0x8209AAEC;
		  /* 8209AAECh */ case    9:  		/* bc 12, CR6_EQ, 48 */
		/* 8209AAECh case    9:*/		if ( regs.CR[6].eq ) { return 0x8209AB1C;  }
		/* 8209AAECh case    9:*/		return 0x8209AAF0;
		  /* 8209AAF0h */ case   10:  		/* mr R3, R31 */
		/* 8209AAF0h case   10:*/		regs.R3 = regs.R31;
		/* 8209AAF0h case   10:*/		return 0x8209AAF4;
		  /* 8209AAF4h */ case   11:  		/* bl -372 */
		/* 8209AAF4h case   11:*/		regs.LR = 0x8209AAF8; return 0x8209A980;
		/* 8209AAF4h case   11:*/		return 0x8209AAF8;
		  /* 8209AAF8h */ case   12:  		/* srawi R11, R3, 5 */
		/* 8209AAF8h case   12:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R3);
		/* 8209AAF8h case   12:*/		return 0x8209AAFC;
		  /* 8209AAFCh */ case   13:  		/* mr R3, R31 */
		/* 8209AAFCh case   13:*/		regs.R3 = regs.R31;
		/* 8209AAFCh case   13:*/		return 0x8209AB00;
		  /* 8209AB00h */ case   14:  		/* rlwinm R29, R11, 2, 0, 29 */
		/* 8209AB00h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R11);
		/* 8209AB00h case   14:*/		return 0x8209AB04;
		  /* 8209AB04h */ case   15:  		/* bl -388 */
		/* 8209AB04h case   15:*/		regs.LR = 0x8209AB08; return 0x8209A980;
		/* 8209AB04h case   15:*/		return 0x8209AB08;
		  /* 8209AB08h */ case   16:  		/* rlwinm R11, R3, 0, 27, 31 */
		/* 8209AB08h case   16:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R3);
		/* 8209AB08h case   16:*/		return 0x8209AB0C;
		  /* 8209AB0Ch */ case   17:  		/* lwzx R10, <#[R29 + R30]> */
		/* 8209AB0Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + regs.R30 + 0x00000000) );
		/* 8209AB0Ch case   17:*/		return 0x8209AB10;
		  /* 8209AB10h */ case   18:  		/* mulli R11, R11, 72 */
		/* 8209AB10h case   18:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x48);
		/* 8209AB10h case   18:*/		return 0x8209AB14;
		  /* 8209AB14h */ case   19:  		/* add R11, R11, R10 */
		/* 8209AB14h case   19:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8209AB14h case   19:*/		return 0x8209AB18;
		  /* 8209AB18h */ case   20:  		/* b 8 */
		/* 8209AB18h case   20:*/		return 0x8209AB20;
		/* 8209AB18h case   20:*/		return 0x8209AB1C;
	}
	return 0x8209AB1C;
} // Block from 8209AAC8h-8209AB1Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8209AB1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AB1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AB1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AB1C);
		  /* 8209AB1Ch */ case    0:  		/* mr R11, R28 */
		/* 8209AB1Ch case    0:*/		regs.R11 = regs.R28;
		/* 8209AB1Ch case    0:*/		return 0x8209AB20;
	}
	return 0x8209AB20;
} // Block from 8209AB1Ch-8209AB20h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209AB20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AB20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AB20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AB20);
		  /* 8209AB20h */ case    0:  		/* lbz R11, <#[R11 + 4]> */
		/* 8209AB20h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8209AB20h case    0:*/		return 0x8209AB24;
		  /* 8209AB24h */ case    1:  		/* rlwinm. R11, R11, 0, 0, 24 */
		/* 8209AB24h case    1:*/		cpu::op::rlwinm<1,0,0,24>(regs,&regs.R11,regs.R11);
		/* 8209AB24h case    1:*/		return 0x8209AB28;
		  /* 8209AB28h */ case    2:  		/* bc 12, CR0_EQ, 148 */
		/* 8209AB28h case    2:*/		if ( regs.CR[0].eq ) { return 0x8209ABBC;  }
		/* 8209AB28h case    2:*/		return 0x8209AB2C;
		  /* 8209AB2Ch */ case    3:  		/* mr R6, R27 */
		/* 8209AB2Ch case    3:*/		regs.R6 = regs.R27;
		/* 8209AB2Ch case    3:*/		return 0x8209AB30;
		  /* 8209AB30h */ case    4:  		/* li R5, 5 */
		/* 8209AB30h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x5);
		/* 8209AB30h case    4:*/		return 0x8209AB34;
		  /* 8209AB34h */ case    5:  		/* addi R4, R1, 84 */
		/* 8209AB34h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x54);
		/* 8209AB34h case    5:*/		return 0x8209AB38;
	}
	return 0x8209AB38;
} // Block from 8209AB20h-8209AB38h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209AB38h
// Function '_lock_file2'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AB38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AB38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AB38);
		  /* 8209AB38h */ case    0:  		/* addi R3, R1, 80 */
		/* 8209AB38h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8209AB38h case    0:*/		return 0x8209AB3C;
		  /* 8209AB3Ch */ case    1:  		/* bl 1428 */
		/* 8209AB3Ch case    1:*/		regs.LR = 0x8209AB40; return 0x8209B0D0;
		/* 8209AB3Ch case    1:*/		return 0x8209AB40;
		  /* 8209AB40h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 8209AB40h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209AB40h case    2:*/		return 0x8209AB44;
		  /* 8209AB44h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 8209AB44h case    3:*/		if ( regs.CR[0].eq ) { return 0x8209AB50;  }
		/* 8209AB44h case    3:*/		return 0x8209AB48;
		  /* 8209AB48h */ case    4:  		/* li R3, -1 */
		/* 8209AB48h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209AB48h case    4:*/		return 0x8209AB4C;
		  /* 8209AB4Ch */ case    5:  		/* b 196 */
		/* 8209AB4Ch case    5:*/		return 0x8209AC10;
		/* 8209AB4Ch case    5:*/		return 0x8209AB50;
	}
	return 0x8209AB50;
} // Block from 8209AB38h-8209AB50h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209AB50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AB50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AB50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AB50);
		  /* 8209AB50h */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 8209AB50h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8209AB50h case    0:*/		return 0x8209AB54;
		  /* 8209AB54h */ case    1:  		/* li R30, 0 */
		/* 8209AB54h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8209AB54h case    1:*/		return 0x8209AB58;
		  /* 8209AB58h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 8209AB58h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8209AB58h case    2:*/		return 0x8209AB5C;
		  /* 8209AB5Ch */ case    3:  		/* bc 4, CR6_GT, 176 */
		/* 8209AB5Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x8209AC0C;  }
		/* 8209AB5Ch case    3:*/		return 0x8209AB60;
		  /* 8209AB60h */ case    4:  		/* lwz R11, <#[R31 + 4]> */
		/* 8209AB60h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8209AB60h case    4:*/		return 0x8209AB64;
		  /* 8209AB64h */ case    5:  		/* addic. R11, R11, -1 */
		/* 8209AB64h case    5:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8209AB64h case    5:*/		return 0x8209AB68;
		  /* 8209AB68h */ case    6:  		/* stw R11, <#[R31 + 4]> */
		/* 8209AB68h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8209AB68h case    6:*/		return 0x8209AB6C;
		  /* 8209AB6Ch */ case    7:  		/* addi R11, R1, 84 */
		/* 8209AB6Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x54);
		/* 8209AB6Ch case    7:*/		return 0x8209AB70;
		  /* 8209AB70h */ case    8:  		/* lbzx R11, <#[R30 + R11]> */
		/* 8209AB70h case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8209AB70h case    8:*/		return 0x8209AB74;
		  /* 8209AB74h */ case    9:  		/* bc 12, CR0_LT, 32 */
		/* 8209AB74h case    9:*/		if ( regs.CR[0].lt ) { return 0x8209AB94;  }
		/* 8209AB74h case    9:*/		return 0x8209AB78;
		  /* 8209AB78h */ case   10:  		/* lwz R10, <#[R31]> */
		/* 8209AB78h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8209AB78h case   10:*/		return 0x8209AB7C;
		  /* 8209AB7Ch */ case   11:  		/* stb R11, <#[R10]> */
		/* 8209AB7Ch case   11:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8209AB7Ch case   11:*/		return 0x8209AB80;
		  /* 8209AB80h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 8209AB80h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209AB80h case   12:*/		return 0x8209AB84;
		  /* 8209AB84h */ case   13:  		/* addi R10, R11, 1 */
		/* 8209AB84h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x1);
		/* 8209AB84h case   13:*/		return 0x8209AB88;
	}
	return 0x8209AB88;
} // Block from 8209AB50h-8209AB88h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209AB88h
// Function '_unlock_file'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AB88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AB88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AB88);
		  /* 8209AB88h */ case    0:  		/* lbz R3, <#[R11]> */
		/* 8209AB88h case    0:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 8209AB88h case    0:*/		return 0x8209AB8C;
		  /* 8209AB8Ch */ case    1:  		/* stw R10, <#[R31]> */
		/* 8209AB8Ch case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8209AB8Ch case    1:*/		return 0x8209AB90;
		  /* 8209AB90h */ case    2:  		/* b 16 */
		/* 8209AB90h case    2:*/		return 0x8209ABA0;
		/* 8209AB90h case    2:*/		return 0x8209AB94;
	}
	return 0x8209AB94;
} // Block from 8209AB88h-8209AB94h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209AB94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AB94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AB94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AB94);
		  /* 8209AB94h */ case    0:  		/* mr R4, R31 */
		/* 8209AB94h case    0:*/		regs.R4 = regs.R31;
		/* 8209AB94h case    0:*/		return 0x8209AB98;
		  /* 8209AB98h */ case    1:  		/* extsb R3, R11 */
		/* 8209AB98h case    1:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 8209AB98h case    1:*/		return 0x8209AB9C;
		  /* 8209AB9Ch */ case    2:  		/* bl -24284 */
		/* 8209AB9Ch case    2:*/		regs.LR = 0x8209ABA0; return 0x82094CC0;
		/* 8209AB9Ch case    2:*/		return 0x8209ABA0;
	}
	return 0x8209ABA0;
} // Block from 8209AB94h-8209ABA0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209ABA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209ABA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209ABA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209ABA0);
		  /* 8209ABA0h */ case    0:  		/* cmpwi CR6, R3, -1 */
		/* 8209ABA0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8209ABA0h case    0:*/		return 0x8209ABA4;
		  /* 8209ABA4h */ case    1:  		/* bc 12, CR6_EQ, -92 */
		/* 8209ABA4h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209AB48;  }
		/* 8209ABA4h case    1:*/		return 0x8209ABA8;
		  /* 8209ABA8h */ case    2:  		/* lwz R11, <#[R1 + 80]> */
		/* 8209ABA8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8209ABA8h case    2:*/		return 0x8209ABAC;
		  /* 8209ABACh */ case    3:  		/* addi R30, R30, 1 */
		/* 8209ABACh case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8209ABACh case    3:*/		return 0x8209ABB0;
		  /* 8209ABB0h */ case    4:  		/* cmpw CR6, R30, R11 */
		/* 8209ABB0h case    4:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R11);
		/* 8209ABB0h case    4:*/		return 0x8209ABB4;
		  /* 8209ABB4h */ case    5:  		/* bc 12, CR6_LT, -84 */
		/* 8209ABB4h case    5:*/		if ( regs.CR[6].lt ) { return 0x8209AB60;  }
		/* 8209ABB4h case    5:*/		return 0x8209ABB8;
		  /* 8209ABB8h */ case    6:  		/* b 84 */
		/* 8209ABB8h case    6:*/		return 0x8209AC0C;
		/* 8209ABB8h case    6:*/		return 0x8209ABBC;
	}
	return 0x8209ABBC;
} // Block from 8209ABA0h-8209ABBCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209ABBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209ABBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209ABBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209ABBC);
		  /* 8209ABBCh */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8209ABBCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8209ABBCh case    0:*/		return 0x8209ABC0;
		  /* 8209ABC0h */ case    1:  		/* addic. R11, R11, -2 */
		/* 8209ABC0h case    1:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFE);
		/* 8209ABC0h case    1:*/		return 0x8209ABC4;
		  /* 8209ABC4h */ case    2:  		/* stw R11, <#[R31 + 4]> */
		/* 8209ABC4h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8209ABC4h case    2:*/		return 0x8209ABC8;
	}
	return 0x8209ABC8;
} // Block from 8209ABBCh-8209ABC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209ABC8h
// Function '_unlock_file2'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209ABC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209ABC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209ABC8);
		  /* 8209ABC8h */ case    0:  		/* bc 12, CR0_LT, 28 */
		/* 8209ABC8h case    0:*/		if ( regs.CR[0].lt ) { return 0x8209ABE4;  }
		/* 8209ABC8h case    0:*/		return 0x8209ABCC;
		  /* 8209ABCCh */ case    1:  		/* lwz R11, <#[R31]> */
		/* 8209ABCCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209ABCCh case    1:*/		return 0x8209ABD0;
		  /* 8209ABD0h */ case    2:  		/* sth R27, <#[R11]> */
		/* 8209ABD0h case    2:*/		cpu::mem::store16( regs, regs.R27, (uint32)(regs.R11 + 0x00000000) );
		/* 8209ABD0h case    2:*/		return 0x8209ABD4;
		  /* 8209ABD4h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 8209ABD4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209ABD4h case    3:*/		return 0x8209ABD8;
		  /* 8209ABD8h */ case    4:  		/* addi R11, R11, 2 */
		/* 8209ABD8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8209ABD8h case    4:*/		return 0x8209ABDC;
		  /* 8209ABDCh */ case    5:  		/* stw R11, <#[R31]> */
		/* 8209ABDCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209ABDCh case    5:*/		return 0x8209ABE0;
		  /* 8209ABE0h */ case    6:  		/* b 44 */
		/* 8209ABE0h case    6:*/		return 0x8209AC0C;
		/* 8209ABE0h case    6:*/		return 0x8209ABE4;
	}
	return 0x8209ABE4;
} // Block from 8209ABC8h-8209ABE4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209ABE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209ABE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209ABE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209ABE4);
		  /* 8209ABE4h */ case    0:  		/* mr R4, R31 */
		/* 8209ABE4h case    0:*/		regs.R4 = regs.R31;
		/* 8209ABE4h case    0:*/		return 0x8209ABE8;
		  /* 8209ABE8h */ case    1:  		/* rlwinm R3, R27, 0, 16, 31 */
		/* 8209ABE8h case    1:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R3,regs.R27);
		/* 8209ABE8h case    1:*/		return 0x8209ABEC;
		  /* 8209ABECh */ case    2:  		/* bl 13068 */
		/* 8209ABECh case    2:*/		regs.LR = 0x8209ABF0; return 0x8209DEF8;
		/* 8209ABECh case    2:*/		return 0x8209ABF0;
	}
	return 0x8209ABF0;
} // Block from 8209ABE4h-8209ABF0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209ABF0h
// Function '_fileno'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209ABF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209ABF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209ABF0);
		  /* 8209ABF0h */ case    0:  		/* rlwinm R3, R3, 0, 16, 31 */
		/* 8209ABF0h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R3,regs.R3);
		/* 8209ABF0h case    0:*/		return 0x8209ABF4;
		  /* 8209ABF4h */ case    1:  		/* b 28 */
		/* 8209ABF4h case    1:*/		return 0x8209AC10;
		/* 8209ABF4h case    1:*/		return 0x8209ABF8;
	}
	return 0x8209ABF8;
} // Block from 8209ABF0h-8209ABF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209ABF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209ABF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209ABF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209ABF8);
		  /* 8209ABF8h */ case    0:  		/* li R11, 0 */
		/* 8209ABF8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209ABF8h case    0:*/		return 0x8209ABFC;
		  /* 8209ABFCh */ case    1:  		/* sth R27, <#[R1 + 80]> */
		/* 8209ABFCh case    1:*/		cpu::mem::store16( regs, regs.R27, (uint32)(regs.R1 + 0x00000050) );
		/* 8209ABFCh case    1:*/		return 0x8209AC00;
		  /* 8209AC00h */ case    2:  		/* addi R3, R1, 80 */
		/* 8209AC00h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8209AC00h case    2:*/		return 0x8209AC04;
		  /* 8209AC04h */ case    3:  		/* sth R11, <#[R1 + 82]> */
		/* 8209AC04h case    3:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000052) );
		/* 8209AC04h case    3:*/		return 0x8209AC08;
		  /* 8209AC08h */ case    4:  		/* bl 1886256 */
		/* 8209AC08h case    4:*/		regs.LR = 0x8209AC0C; return 0x82267438;
		/* 8209AC08h case    4:*/		return 0x8209AC0C;
	}
	return 0x8209AC0C;
} // Block from 8209ABF8h-8209AC0Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209AC0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AC0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AC0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AC0C);
		  /* 8209AC0Ch */ case    0:  		/* mr R3, R27 */
		/* 8209AC0Ch case    0:*/		regs.R3 = regs.R27;
		/* 8209AC0Ch case    0:*/		return 0x8209AC10;
	}
	return 0x8209AC10;
} // Block from 8209AC0Ch-8209AC10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209AC10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AC10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AC10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AC10);
		  /* 8209AC10h */ case    0:  		/* addi R1, R1, 144 */
		/* 8209AC10h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8209AC10h case    0:*/		return 0x8209AC14;
		  /* 8209AC14h */ case    1:  		/* b -39280 */
		/* 8209AC14h case    1:*/		return 0x820912A4;
		/* 8209AC14h case    1:*/		return 0x8209AC18;
	}
	return 0x8209AC18;
} // Block from 8209AC10h-8209AC18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209AC18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AC18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AC18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AC18);
		  /* 8209AC18h */ case    0:  		/* mfspr R12, LR */
		/* 8209AC18h case    0:*/		regs.R12 = regs.LR;
		/* 8209AC18h case    0:*/		return 0x8209AC1C;
		  /* 8209AC1Ch */ case    1:  		/* bl -39372 */
		/* 8209AC1Ch case    1:*/		regs.LR = 0x8209AC20; return 0x82091250;
		/* 8209AC1Ch case    1:*/		return 0x8209AC20;
		  /* 8209AC20h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 8209AC20h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 8209AC20h case    2:*/		return 0x8209AC24;
		  /* 8209AC24h */ case    3:  		/* mr R31, R3 */
		/* 8209AC24h case    3:*/		regs.R31 = regs.R3;
		/* 8209AC24h case    3:*/		return 0x8209AC28;
		  /* 8209AC28h */ case    4:  		/* mr R29, R4 */
		/* 8209AC28h case    4:*/		regs.R29 = regs.R4;
		/* 8209AC28h case    4:*/		return 0x8209AC2C;
		  /* 8209AC2Ch */ case    5:  		/* mr R30, R5 */
		/* 8209AC2Ch case    5:*/		regs.R30 = regs.R5;
		/* 8209AC2Ch case    5:*/		return 0x8209AC30;
	}
	return 0x8209AC30;
} // Block from 8209AC18h-8209AC30h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209AC30h
// Function '_fputwc_nolock'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AC30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AC30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AC30);
		  /* 8209AC30h */ case    0:  		/* li R26, 0 */
		/* 8209AC30h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8209AC30h case    0:*/		return 0x8209AC34;
		  /* 8209AC34h */ case    1:  		/* li R5, 28 */
		/* 8209AC34h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x1C);
		/* 8209AC34h case    1:*/		return 0x8209AC38;
		  /* 8209AC38h */ case    2:  		/* li R4, 0 */
		/* 8209AC38h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8209AC38h case    2:*/		return 0x8209AC3C;
		  /* 8209AC3Ch */ case    3:  		/* stw R26, <#[R1 + 80]> */
		/* 8209AC3Ch case    3:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 8209AC3Ch case    3:*/		return 0x8209AC40;
		  /* 8209AC40h */ case    4:  		/* addi R3, R1, 84 */
		/* 8209AC40h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x54);
		/* 8209AC40h case    4:*/		return 0x8209AC44;
		  /* 8209AC44h */ case    5:  		/* mr R28, R6 */
		/* 8209AC44h case    5:*/		regs.R28 = regs.R6;
		/* 8209AC44h case    5:*/		return 0x8209AC48;
		  /* 8209AC48h */ case    6:  		/* mr R27, R7 */
		/* 8209AC48h case    6:*/		regs.R27 = regs.R7;
		/* 8209AC48h case    6:*/		return 0x8209AC4C;
		  /* 8209AC4Ch */ case    7:  		/* bl -39180 */
		/* 8209AC4Ch case    7:*/		regs.LR = 0x8209AC50; return 0x82091340;
		/* 8209AC4Ch case    7:*/		return 0x8209AC50;
		  /* 8209AC50h */ case    8:  		/* cmplwi CR6, R30, 0 */
		/* 8209AC50h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8209AC50h case    8:*/		return 0x8209AC54;
		  /* 8209AC54h */ case    9:  		/* bc 4, CR6_EQ, 28 */
		/* 8209AC54h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8209AC70;  }
		/* 8209AC54h case    9:*/		return 0x8209AC58;
		  /* 8209AC58h */ case   10:  		/* bl -23888 */
		/* 8209AC58h case   10:*/		regs.LR = 0x8209AC5C; return 0x82094F08;
		/* 8209AC58h case   10:*/		return 0x8209AC5C;
		  /* 8209AC5Ch */ case   11:  		/* li R11, 22 */
		/* 8209AC5Ch case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 8209AC5Ch case   11:*/		return 0x8209AC60;
		  /* 8209AC60h */ case   12:  		/* stw R11, <#[R3]> */
		/* 8209AC60h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209AC60h case   12:*/		return 0x8209AC64;
		  /* 8209AC64h */ case   13:  		/* bl -29444 */
		/* 8209AC64h case   13:*/		regs.LR = 0x8209AC68; return 0x82093960;
		/* 8209AC64h case   13:*/		return 0x8209AC68;
		  /* 8209AC68h */ case   14:  		/* li R3, -1 */
		/* 8209AC68h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209AC68h case   14:*/		return 0x8209AC6C;
		  /* 8209AC6Ch */ case   15:  		/* b 200 */
		/* 8209AC6Ch case   15:*/		return 0x8209AD34;
		/* 8209AC6Ch case   15:*/		return 0x8209AC70;
	}
	return 0x8209AC70;
} // Block from 8209AC30h-8209AC70h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8209AC70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AC70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AC70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AC70);
		  /* 8209AC70h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 8209AC70h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8209AC70h case    0:*/		return 0x8209AC74;
		  /* 8209AC74h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8209AC74h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209AC80;  }
		/* 8209AC74h case    1:*/		return 0x8209AC78;
		  /* 8209AC78h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 8209AC78h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8209AC78h case    2:*/		return 0x8209AC7C;
		  /* 8209AC7Ch */ case    3:  		/* bc 12, CR6_EQ, -36 */
		/* 8209AC7Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8209AC58;  }
		/* 8209AC7Ch case    3:*/		return 0x8209AC80;
	}
	return 0x8209AC80;
} // Block from 8209AC70h-8209AC80h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209AC80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AC80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AC80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AC80);
		  /* 8209AC80h */ case    0:  		/* lis R11, 16383 */
		/* 8209AC80h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x3FFF);
		/* 8209AC80h case    0:*/		return 0x8209AC84;
		  /* 8209AC84h */ case    1:  		/* stw R31, <#[R1 + 88]> */
		/* 8209AC84h case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000058) );
		/* 8209AC84h case    1:*/		return 0x8209AC88;
		  /* 8209AC88h */ case    2:  		/* li R10, 66 */
		/* 8209AC88h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x42);
		/* 8209AC88h case    2:*/		return 0x8209AC8C;
		  /* 8209AC8Ch */ case    3:  		/* stw R31, <#[R1 + 80]> */
		/* 8209AC8Ch case    3:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 8209AC8Ch case    3:*/		return 0x8209AC90;
		  /* 8209AC90h */ case    4:  		/* ori R11, R11, 65535 */
		/* 8209AC90h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFFF);
		/* 8209AC90h case    4:*/		return 0x8209AC94;
		  /* 8209AC94h */ case    5:  		/* stw R10, <#[R1 + 92]> */
		/* 8209AC94h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 8209AC94h case    5:*/		return 0x8209AC98;
		  /* 8209AC98h */ case    6:  		/* cmplw CR6, R29, R11 */
		/* 8209AC98h case    6:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8209AC98h case    6:*/		return 0x8209AC9C;
		  /* 8209AC9Ch */ case    7:  		/* bc 4, CR6_GT, 16 */
		/* 8209AC9Ch case    7:*/		if ( !regs.CR[6].gt ) { return 0x8209ACAC;  }
		/* 8209AC9Ch case    7:*/		return 0x8209ACA0;
		  /* 8209ACA0h */ case    8:  		/* lis R11, 32767 */
		/* 8209ACA0h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FFF);
		/* 8209ACA0h case    8:*/		return 0x8209ACA4;
		  /* 8209ACA4h */ case    9:  		/* ori R11, R11, 65535 */
		/* 8209ACA4h case    9:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFFF);
		/* 8209ACA4h case    9:*/		return 0x8209ACA8;
		  /* 8209ACA8h */ case   10:  		/* b 8 */
		/* 8209ACA8h case   10:*/		return 0x8209ACB0;
		/* 8209ACA8h case   10:*/		return 0x8209ACAC;
	}
	return 0x8209ACAC;
} // Block from 8209AC80h-8209ACACh (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209ACACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209ACAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209ACAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209ACAC);
		  /* 8209ACACh */ case    0:  		/* rlwinm R11, R29, 1, 0, 30 */
		/* 8209ACACh case    0:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R29);
		/* 8209ACACh case    0:*/		return 0x8209ACB0;
	}
	return 0x8209ACB0;
} // Block from 8209ACACh-8209ACB0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209ACB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209ACB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209ACB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209ACB0);
		  /* 8209ACB0h */ case    0:  		/* stw R11, <#[R1 + 84]> */
		/* 8209ACB0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8209ACB0h case    0:*/		return 0x8209ACB4;
		  /* 8209ACB4h */ case    1:  		/* mr R6, R27 */
		/* 8209ACB4h case    1:*/		regs.R6 = regs.R27;
		/* 8209ACB4h case    1:*/		return 0x8209ACB8;
		  /* 8209ACB8h */ case    2:  		/* mr R5, R28 */
		/* 8209ACB8h case    2:*/		regs.R5 = regs.R28;
		/* 8209ACB8h case    2:*/		return 0x8209ACBC;
		  /* 8209ACBCh */ case    3:  		/* mr R4, R30 */
		/* 8209ACBCh case    3:*/		regs.R4 = regs.R30;
		/* 8209ACBCh case    3:*/		return 0x8209ACC0;
		  /* 8209ACC0h */ case    4:  		/* addi R3, R1, 80 */
		/* 8209ACC0h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8209ACC0h case    4:*/		return 0x8209ACC4;
		  /* 8209ACC4h */ case    5:  		/* bl -23772 */
		/* 8209ACC4h case    5:*/		regs.LR = 0x8209ACC8; return 0x82094FE8;
		/* 8209ACC4h case    5:*/		return 0x8209ACC8;
		  /* 8209ACC8h */ case    6:  		/* mr R30, R3 */
		/* 8209ACC8h case    6:*/		regs.R30 = regs.R3;
		/* 8209ACC8h case    6:*/		return 0x8209ACCC;
		  /* 8209ACCCh */ case    7:  		/* cmplwi CR6, R31, 0 */
		/* 8209ACCCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8209ACCCh case    7:*/		return 0x8209ACD0;
		  /* 8209ACD0h */ case    8:  		/* bc 12, CR6_EQ, 96 */
		/* 8209ACD0h case    8:*/		if ( regs.CR[6].eq ) { return 0x8209AD30;  }
		/* 8209ACD0h case    8:*/		return 0x8209ACD4;
		  /* 8209ACD4h */ case    9:  		/* lwz R11, <#[R1 + 84]> */
		/* 8209ACD4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8209ACD4h case    9:*/		return 0x8209ACD8;
		  /* 8209ACD8h */ case   10:  		/* addic. R11, R11, -1 */
		/* 8209ACD8h case   10:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8209ACD8h case   10:*/		return 0x8209ACDC;
		  /* 8209ACDCh */ case   11:  		/* stw R11, <#[R1 + 84]> */
		/* 8209ACDCh case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8209ACDCh case   11:*/		return 0x8209ACE0;
		  /* 8209ACE0h */ case   12:  		/* bc 12, CR0_LT, 28 */
		/* 8209ACE0h case   12:*/		if ( regs.CR[0].lt ) { return 0x8209ACFC;  }
		/* 8209ACE0h case   12:*/		return 0x8209ACE4;
		  /* 8209ACE4h */ case   13:  		/* lwz R11, <#[R1 + 80]> */
		/* 8209ACE4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8209ACE4h case   13:*/		return 0x8209ACE8;
		  /* 8209ACE8h */ case   14:  		/* stb R26, <#[R11]> */
		/* 8209ACE8h case   14:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R11 + 0x00000000) );
		/* 8209ACE8h case   14:*/		return 0x8209ACEC;
		  /* 8209ACECh */ case   15:  		/* lwz R11, <#[R1 + 80]> */
		/* 8209ACECh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8209ACECh case   15:*/		return 0x8209ACF0;
		  /* 8209ACF0h */ case   16:  		/* addi R11, R11, 1 */
		/* 8209ACF0h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209ACF0h case   16:*/		return 0x8209ACF4;
		  /* 8209ACF4h */ case   17:  		/* stw R11, <#[R1 + 80]> */
		/* 8209ACF4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8209ACF4h case   17:*/		return 0x8209ACF8;
		  /* 8209ACF8h */ case   18:  		/* b 20 */
		/* 8209ACF8h case   18:*/		return 0x8209AD0C;
		/* 8209ACF8h case   18:*/		return 0x8209ACFC;
	}
	return 0x8209ACFC;
} // Block from 8209ACB0h-8209ACFCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 8209ACFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209ACFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209ACFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209ACFC);
		  /* 8209ACFCh */ case    0:  		/* addi R4, R1, 80 */
		/* 8209ACFCh case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8209ACFCh case    0:*/		return 0x8209AD00;
		  /* 8209AD00h */ case    1:  		/* li R3, 0 */
		/* 8209AD00h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209AD00h case    1:*/		return 0x8209AD04;
		  /* 8209AD04h */ case    2:  		/* bl -24644 */
		/* 8209AD04h case    2:*/		regs.LR = 0x8209AD08; return 0x82094CC0;
		/* 8209AD04h case    2:*/		return 0x8209AD08;
		  /* 8209AD08h */ case    3:  		/* lwz R11, <#[R1 + 80]> */
		/* 8209AD08h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8209AD08h case    3:*/		return 0x8209AD0C;
	}
	return 0x8209AD0C;
} // Block from 8209ACFCh-8209AD0Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209AD0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AD0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AD0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AD0C);
		  /* 8209AD0Ch */ case    0:  		/* lwz R10, <#[R1 + 84]> */
		/* 8209AD0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 8209AD0Ch case    0:*/		return 0x8209AD10;
		  /* 8209AD10h */ case    1:  		/* addic. R10, R10, -1 */
		/* 8209AD10h case    1:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8209AD10h case    1:*/		return 0x8209AD14;
		  /* 8209AD14h */ case    2:  		/* stw R10, <#[R1 + 84]> */
		/* 8209AD14h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 8209AD14h case    2:*/		return 0x8209AD18;
		  /* 8209AD18h */ case    3:  		/* bc 12, CR0_LT, 12 */
		/* 8209AD18h case    3:*/		if ( regs.CR[0].lt ) { return 0x8209AD24;  }
		/* 8209AD18h case    3:*/		return 0x8209AD1C;
		  /* 8209AD1Ch */ case    4:  		/* stb R26, <#[R11]> */
		/* 8209AD1Ch case    4:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R11 + 0x00000000) );
		/* 8209AD1Ch case    4:*/		return 0x8209AD20;
		  /* 8209AD20h */ case    5:  		/* b 16 */
		/* 8209AD20h case    5:*/		return 0x8209AD30;
		/* 8209AD20h case    5:*/		return 0x8209AD24;
	}
	return 0x8209AD24;
} // Block from 8209AD0Ch-8209AD24h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209AD24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AD24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AD24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AD24);
		  /* 8209AD24h */ case    0:  		/* addi R4, R1, 80 */
		/* 8209AD24h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8209AD24h case    0:*/		return 0x8209AD28;
		  /* 8209AD28h */ case    1:  		/* li R3, 0 */
		/* 8209AD28h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209AD28h case    1:*/		return 0x8209AD2C;
		  /* 8209AD2Ch */ case    2:  		/* bl -24684 */
		/* 8209AD2Ch case    2:*/		regs.LR = 0x8209AD30; return 0x82094CC0;
		/* 8209AD2Ch case    2:*/		return 0x8209AD30;
	}
	return 0x8209AD30;
} // Block from 8209AD24h-8209AD30h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209AD30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AD30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AD30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AD30);
		  /* 8209AD30h */ case    0:  		/* mr R3, R30 */
		/* 8209AD30h case    0:*/		regs.R3 = regs.R30;
		/* 8209AD30h case    0:*/		return 0x8209AD34;
	}
	return 0x8209AD34;
} // Block from 8209AD30h-8209AD34h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209AD34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AD34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AD34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AD34);
		  /* 8209AD34h */ case    0:  		/* addi R1, R1, 176 */
		/* 8209AD34h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 8209AD34h case    0:*/		return 0x8209AD38;
		  /* 8209AD38h */ case    1:  		/* b -39576 */
		/* 8209AD38h case    1:*/		return 0x820912A0;
		/* 8209AD38h case    1:*/		return 0x8209AD3C;
		  /* 8209AD3Ch */ case    2:  		/* nop */
		/* 8209AD3Ch case    2:*/		cpu::op::nop();
		/* 8209AD3Ch case    2:*/		return 0x8209AD40;
	}
	return 0x8209AD40;
} // Block from 8209AD34h-8209AD40h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209AD40h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AD40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AD40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AD40);
		  /* 8209AD40h */ case    0:  		/* mr R7, R6 */
		/* 8209AD40h case    0:*/		regs.R7 = regs.R6;
		/* 8209AD40h case    0:*/		return 0x8209AD44;
		  /* 8209AD44h */ case    1:  		/* li R6, 0 */
		/* 8209AD44h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8209AD44h case    1:*/		return 0x8209AD48;
		  /* 8209AD48h */ case    2:  		/* b -304 */
		/* 8209AD48h case    2:*/		return 0x8209AC18;
		/* 8209AD48h case    2:*/		return 0x8209AD4C;
		  /* 8209AD4Ch */ case    3:  		/* nop */
		/* 8209AD4Ch case    3:*/		cpu::op::nop();
		/* 8209AD4Ch case    3:*/		return 0x8209AD50;
		  /* 8209AD50h */ case    4:  		/* lwz R17, <#[R6 - 11576]> */
		/* 8209AD50h case    4:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 8209AD50h case    4:*/		return 0x8209AD54;
		  /* 8209AD54h */ case    5:  		/* lwz R16, <#[R4 - 15256]> */
		/* 8209AD54h case    5:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC468) );
		/* 8209AD54h case    5:*/		return 0x8209AD58;
	}
	return 0x8209AD58;
} // Block from 8209AD40h-8209AD58h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209AD58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AD58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AD58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AD58);
		  /* 8209AD58h */ case    0:  		/* mfspr R12, LR */
		/* 8209AD58h case    0:*/		regs.R12 = regs.LR;
		/* 8209AD58h case    0:*/		return 0x8209AD5C;
		  /* 8209AD5Ch */ case    1:  		/* bl -39680 */
		/* 8209AD5Ch case    1:*/		regs.LR = 0x8209AD60; return 0x8209125C;
		/* 8209AD5Ch case    1:*/		return 0x8209AD60;
		  /* 8209AD60h */ case    2:  		/* std R4, <#[R1 + 24]> */
		/* 8209AD60h case    2:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000018) );
		/* 8209AD60h case    2:*/		return 0x8209AD64;
		  /* 8209AD64h */ case    3:  		/* std R5, <#[R1 + 32]> */
		/* 8209AD64h case    3:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 8209AD64h case    3:*/		return 0x8209AD68;
		  /* 8209AD68h */ case    4:  		/* std R6, <#[R1 + 40]> */
		/* 8209AD68h case    4:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 8209AD68h case    4:*/		return 0x8209AD6C;
		  /* 8209AD6Ch */ case    5:  		/* std R7, <#[R1 + 48]> */
		/* 8209AD6Ch case    5:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 8209AD6Ch case    5:*/		return 0x8209AD70;
		  /* 8209AD70h */ case    6:  		/* std R8, <#[R1 + 56]> */
		/* 8209AD70h case    6:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 8209AD70h case    6:*/		return 0x8209AD74;
		  /* 8209AD74h */ case    7:  		/* std R9, <#[R1 + 64]> */
		/* 8209AD74h case    7:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 8209AD74h case    7:*/		return 0x8209AD78;
		  /* 8209AD78h */ case    8:  		/* std R10, <#[R1 + 72]> */
		/* 8209AD78h case    8:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 8209AD78h case    8:*/		return 0x8209AD7C;
		  /* 8209AD7Ch */ case    9:  		/* addi R31, R1, -128 */
		/* 8209AD7Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFF80);
		/* 8209AD7Ch case    9:*/		return 0x8209AD80;
		  /* 8209AD80h */ case   10:  		/* stwu R1, <#[R1 - 128]> */
		/* 8209AD80h case   10:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8209AD80h case   10:*/		return 0x8209AD84;
		  /* 8209AD84h */ case   11:  		/* stw R3, <#[R31 + 148]> */
		/* 8209AD84h case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000094) );
		/* 8209AD84h case   11:*/		return 0x8209AD88;
		  /* 8209AD88h */ case   12:  		/* addic R11, R3, -1 */
		/* 8209AD88h case   12:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R3,0xFFFFFFFF);
		/* 8209AD88h case   12:*/		return 0x8209AD8C;
		  /* 8209AD8Ch */ case   13:  		/* subfe. R11, R11, R3 */
		/* 8209AD8Ch case   13:*/		cpu::op::subfe<1>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8209AD8Ch case   13:*/		return 0x8209AD90;
		  /* 8209AD90h */ case   14:  		/* bc 4, CR0_EQ, 28 */
		/* 8209AD90h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8209ADAC;  }
		/* 8209AD90h case   14:*/		return 0x8209AD94;
		  /* 8209AD94h */ case   15:  		/* bl -24204 */
		/* 8209AD94h case   15:*/		regs.LR = 0x8209AD98; return 0x82094F08;
		/* 8209AD94h case   15:*/		return 0x8209AD98;
		  /* 8209AD98h */ case   16:  		/* li R11, 22 */
		/* 8209AD98h case   16:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 8209AD98h case   16:*/		return 0x8209AD9C;
		  /* 8209AD9Ch */ case   17:  		/* stw R11, <#[R3]> */
		/* 8209AD9Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209AD9Ch case   17:*/		return 0x8209ADA0;
		  /* 8209ADA0h */ case   18:  		/* bl -29760 */
		/* 8209ADA0h case   18:*/		regs.LR = 0x8209ADA4; return 0x82093960;
		/* 8209ADA0h case   18:*/		return 0x8209ADA4;
		  /* 8209ADA4h */ case   19:  		/* li R3, -1 */
		/* 8209ADA4h case   19:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209ADA4h case   19:*/		return 0x8209ADA8;
		  /* 8209ADA8h */ case   20:  		/* b 116 */
		/* 8209ADA8h case   20:*/		return 0x8209AE1C;
		/* 8209ADA8h case   20:*/		return 0x8209ADAC;
	}
	return 0x8209ADAC;
} // Block from 8209AD58h-8209ADACh (21 instructions)

//////////////////////////////////////////////////////
// Block at 8209ADACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209ADAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209ADAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209ADAC);
		  /* 8209ADACh */ case    0:  		/* addi R11, R31, 80 */
		/* 8209ADACh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x50);
		/* 8209ADACh case    0:*/		return 0x8209ADB0;
		  /* 8209ADB0h */ case    1:  		/* addi R10, R31, 152 */
		/* 8209ADB0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x98);
		/* 8209ADB0h case    1:*/		return 0x8209ADB4;
		  /* 8209ADB4h */ case    2:  		/* stw R10, <#[R11]> */
		/* 8209ADB4h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209ADB4h case    2:*/		return 0x8209ADB8;
		  /* 8209ADB8h */ case    3:  		/* bl -1752 */
		/* 8209ADB8h case    3:*/		regs.LR = 0x8209ADBC; return 0x8209A6E0;
		/* 8209ADB8h case    3:*/		return 0x8209ADBC;
		  /* 8209ADBCh */ case    4:  		/* addi R4, R3, 32 */
		/* 8209ADBCh case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0x20);
		/* 8209ADBCh case    4:*/		return 0x8209ADC0;
		  /* 8209ADC0h */ case    5:  		/* li R3, 1 */
		/* 8209ADC0h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8209ADC0h case    5:*/		return 0x8209ADC4;
		  /* 8209ADC4h */ case    6:  		/* bl -1276 */
		/* 8209ADC4h case    6:*/		regs.LR = 0x8209ADC8; return 0x8209A8C8;
		/* 8209ADC4h case    6:*/		return 0x8209ADC8;
		  /* 8209ADC8h */ case    7:  		/* nop */
		/* 8209ADC8h case    7:*/		cpu::op::nop();
		/* 8209ADC8h case    7:*/		return 0x8209ADCC;
	}
	return 0x8209ADCC;
} // Block from 8209ADACh-8209ADCCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209ADCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209ADCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209ADCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209ADCC);
		  /* 8209ADCCh */ case    0:  		/* bl -1772 */
		/* 8209ADCCh case    0:*/		regs.LR = 0x8209ADD0; return 0x8209A6E0;
		/* 8209ADCCh case    0:*/		return 0x8209ADD0;
		  /* 8209ADD0h */ case    1:  		/* addi R3, R3, 32 */
		/* 8209ADD0h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x20);
		/* 8209ADD0h case    1:*/		return 0x8209ADD4;
		  /* 8209ADD4h */ case    2:  		/* bl 13068 */
		/* 8209ADD4h case    2:*/		regs.LR = 0x8209ADD8; return 0x8209E0E0;
		/* 8209ADD4h case    2:*/		return 0x8209ADD8;
		  /* 8209ADD8h */ case    3:  		/* lwz R30, <#[R31 + 148]> */
		/* 8209ADD8h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000094) );
		/* 8209ADD8h case    3:*/		return 0x8209ADDC;
		  /* 8209ADDCh */ case    4:  		/* mr R29, R3 */
		/* 8209ADDCh case    4:*/		regs.R29 = regs.R3;
		/* 8209ADDCh case    4:*/		return 0x8209ADE0;
		  /* 8209ADE0h */ case    5:  		/* bl -1792 */
		/* 8209ADE0h case    5:*/		regs.LR = 0x8209ADE4; return 0x8209A6E0;
		/* 8209ADE0h case    5:*/		return 0x8209ADE4;
		  /* 8209ADE4h */ case    6:  		/* addi R3, R3, 32 */
		/* 8209ADE4h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x20);
		/* 8209ADE4h case    6:*/		return 0x8209ADE8;
		  /* 8209ADE8h */ case    7:  		/* lwz R6, <#[R31 + 80]> */
		/* 8209ADE8h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000050) );
		/* 8209ADE8h case    7:*/		return 0x8209ADEC;
		  /* 8209ADECh */ case    8:  		/* mr R4, R30 */
		/* 8209ADECh case    8:*/		regs.R4 = regs.R30;
		/* 8209ADECh case    8:*/		return 0x8209ADF0;
		  /* 8209ADF0h */ case    9:  		/* li R5, 0 */
		/* 8209ADF0h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8209ADF0h case    9:*/		return 0x8209ADF4;
		  /* 8209ADF4h */ case   10:  		/* bl -18428 */
		/* 8209ADF4h case   10:*/		regs.LR = 0x8209ADF8; return 0x820965F8;
		/* 8209ADF4h case   10:*/		return 0x8209ADF8;
		  /* 8209ADF8h */ case   11:  		/* stw R3, <#[R31 + 84]> */
		/* 8209ADF8h case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000054) );
		/* 8209ADF8h case   11:*/		return 0x8209ADFC;
		  /* 8209ADFCh */ case   12:  		/* bl -1820 */
		/* 8209ADFCh case   12:*/		regs.LR = 0x8209AE00; return 0x8209A6E0;
		/* 8209ADFCh case   12:*/		return 0x8209AE00;
		  /* 8209AE00h */ case   13:  		/* addi R4, R3, 32 */
		/* 8209AE00h case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0x20);
		/* 8209AE00h case   13:*/		return 0x8209AE04;
		  /* 8209AE04h */ case   14:  		/* mr R3, R29 */
		/* 8209AE04h case   14:*/		regs.R3 = regs.R29;
		/* 8209AE04h case   14:*/		return 0x8209AE08;
		  /* 8209AE08h */ case   15:  		/* bl 13256 */
		/* 8209AE08h case   15:*/		regs.LR = 0x8209AE0C; return 0x8209E1D0;
		/* 8209AE08h case   15:*/		return 0x8209AE0C;
	}
	return 0x8209AE0C;
} // Block from 8209ADCCh-8209AE0Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8209AE0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AE0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AE0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AE0C);
		  /* 8209AE0Ch */ case    0:  		/* nop */
		/* 8209AE0Ch case    0:*/		cpu::op::nop();
		/* 8209AE0Ch case    0:*/		return 0x8209AE10;
		  /* 8209AE10h */ case    1:  		/* addi R12, R31, 128 */
		/* 8209AE10h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R31,0x80);
		/* 8209AE10h case    1:*/		return 0x8209AE14;
		  /* 8209AE14h */ case    2:  		/* bl 16 */
		/* 8209AE14h case    2:*/		regs.LR = 0x8209AE18; return 0x8209AE24;
		/* 8209AE14h case    2:*/		return 0x8209AE18;
		  /* 8209AE18h */ case    3:  		/* lwz R3, <#[R31 + 84]> */
		/* 8209AE18h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000054) );
		/* 8209AE18h case    3:*/		return 0x8209AE1C;
	}
	return 0x8209AE1C;
} // Block from 8209AE0Ch-8209AE1Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209AE1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AE1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AE1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AE1C);
		  /* 8209AE1Ch */ case    0:  		/* addi R1, R31, 128 */
		/* 8209AE1Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0x80);
		/* 8209AE1Ch case    0:*/		return 0x8209AE20;
		  /* 8209AE20h */ case    1:  		/* b -39796 */
		/* 8209AE20h case    1:*/		return 0x820912AC;
		/* 8209AE20h case    1:*/		return 0x8209AE24;
	}
	return 0x8209AE24;
} // Block from 8209AE1Ch-8209AE24h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209AE24h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AE24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AE24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AE24);
		  /* 8209AE24h */ case    0:  		/* mfspr R12, LR */
		/* 8209AE24h case    0:*/		regs.R12 = regs.LR;
		/* 8209AE24h case    0:*/		return 0x8209AE28;
		  /* 8209AE28h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209AE28h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209AE28h case    1:*/		return 0x8209AE2C;
		  /* 8209AE2Ch */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209AE2Ch case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209AE2Ch case    2:*/		return 0x8209AE30;
		  /* 8209AE30h */ case    3:  		/* bl -1872 */
		/* 8209AE30h case    3:*/		regs.LR = 0x8209AE34; return 0x8209A6E0;
		/* 8209AE30h case    3:*/		return 0x8209AE34;
		  /* 8209AE34h */ case    4:  		/* addi R4, R3, 32 */
		/* 8209AE34h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0x20);
		/* 8209AE34h case    4:*/		return 0x8209AE38;
		  /* 8209AE38h */ case    5:  		/* li R3, 1 */
		/* 8209AE38h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8209AE38h case    5:*/		return 0x8209AE3C;
		  /* 8209AE3Ch */ case    6:  		/* bl -1252 */
		/* 8209AE3Ch case    6:*/		regs.LR = 0x8209AE40; return 0x8209A958;
		/* 8209AE3Ch case    6:*/		return 0x8209AE40;
		  /* 8209AE40h */ case    7:  		/* lwz R1, <#[R1]> */
		/* 8209AE40h case    7:*/		cpu::mem::load32z( regs, &regs.R1, (uint32)(regs.R1 + 0x00000000) );
		/* 8209AE40h case    7:*/		return 0x8209AE44;
		  /* 8209AE44h */ case    8:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209AE44h case    8:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209AE44h case    8:*/		return 0x8209AE48;
		  /* 8209AE48h */ case    9:  		/* mtspr LR, R12 */
		/* 8209AE48h case    9:*/		regs.LR = regs.R12;
		/* 8209AE48h case    9:*/		return 0x8209AE4C;
		  /* 8209AE4Ch */ case   10:  		/* bclr 20, CR0_LT */
		/* 8209AE4Ch case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209AE4Ch case   10:*/		return 0x8209AE50;
	}
	return 0x8209AE50;
} // Block from 8209AE24h-8209AE50h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209AE50h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AE50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AE50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AE50);
		  /* 8209AE50h */ case    0:  		/* lis R11, -32217 */
		/* 8209AE50h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 8209AE50h case    0:*/		return 0x8209AE54;
		  /* 8209AE54h */ case    1:  		/* lis R10, -32215 */
		/* 8209AE54h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 8209AE54h case    1:*/		return 0x8209AE58;
		  /* 8209AE58h */ case    2:  		/* lwz R11, <#[R11 + 10268]> */
		/* 8209AE58h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000281C) );
		/* 8209AE58h case    2:*/		return 0x8209AE5C;
		  /* 8209AE5Ch */ case    3:  		/* lwz R10, <#[R10 - 30252]> */
		/* 8209AE5Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0xFFFF89D4) );
		/* 8209AE5Ch case    3:*/		return 0x8209AE60;
		  /* 8209AE60h */ case    4:  		/* ori R11, R11, 1 */
		/* 8209AE60h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209AE60h case    4:*/		return 0x8209AE64;
		  /* 8209AE64h */ case    5:  		/* subf R11, R10, R11 */
		/* 8209AE64h case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8209AE64h case    5:*/		return 0x8209AE68;
		  /* 8209AE68h */ case    6:  		/* cntlzw R11, R11 */
		/* 8209AE68h case    6:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8209AE68h case    6:*/		return 0x8209AE6C;
		  /* 8209AE6Ch */ case    7:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 8209AE6Ch case    7:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 8209AE6Ch case    7:*/		return 0x8209AE70;
		  /* 8209AE70h */ case    8:  		/* bclr 20, CR0_LT */
		/* 8209AE70h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209AE70h case    8:*/		return 0x8209AE74;
	}
	return 0x8209AE74;
} // Block from 8209AE50h-8209AE74h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209AE74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AE74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AE74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AE74);
		  /* 8209AE74h */ case    0:  		/* nop */
		/* 8209AE74h case    0:*/		cpu::op::nop();
		/* 8209AE74h case    0:*/		return 0x8209AE78;
	}
	return 0x8209AE78;
} // Block from 8209AE74h-8209AE78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209AE78h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AE78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AE78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AE78);
		  /* 8209AE78h */ case    0:  		/* lis R11, -32217 */
		/* 8209AE78h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 8209AE78h case    0:*/		return 0x8209AE7C;
		  /* 8209AE7Ch */ case    1:  		/* rlwinm R10, R3, 1, 23, 30 */
		/* 8209AE7Ch case    1:*/		cpu::op::rlwinm<0,1,23,30>(regs,&regs.R10,regs.R3);
		/* 8209AE7Ch case    1:*/		return 0x8209AE80;
		  /* 8209AE80h */ case    2:  		/* lwz R11, <#[R11 + 8856]> */
		/* 8209AE80h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00002298) );
		/* 8209AE80h case    2:*/		return 0x8209AE84;
		  /* 8209AE84h */ case    3:  		/* lwz R11, <#[R11 + 200]> */
		/* 8209AE84h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000C8) );
		/* 8209AE84h case    3:*/		return 0x8209AE88;
	}
	return 0x8209AE88;
} // Block from 8209AE78h-8209AE88h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209AE88h
// Function '_vsnwprintf_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AE88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AE88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AE88);
		  /* 8209AE88h */ case    0:  		/* lhzx R11, <#[R10 + R11]> */
		/* 8209AE88h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8209AE88h case    0:*/		return 0x8209AE8C;
		  /* 8209AE8Ch */ case    1:  		/* rlwinm R3, R11, 0, 0, 16 */
		/* 8209AE8Ch case    1:*/		cpu::op::rlwinm<0,0,0,16>(regs,&regs.R3,regs.R11);
		/* 8209AE8Ch case    1:*/		return 0x8209AE90;
		  /* 8209AE90h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8209AE90h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209AE90h case    2:*/		return 0x8209AE94;
	}
	return 0x8209AE94;
} // Block from 8209AE88h-8209AE94h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209AE94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AE94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AE94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AE94);
		  /* 8209AE94h */ case    0:  		/* nop */
		/* 8209AE94h case    0:*/		cpu::op::nop();
		/* 8209AE94h case    0:*/		return 0x8209AE98;
	}
	return 0x8209AE98;
} // Block from 8209AE94h-8209AE98h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209AE98h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AE98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AE98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AE98);
		  /* 8209AE98h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 8209AE98h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8209AE98h case    0:*/		return 0x8209AE9C;
		  /* 8209AE9Ch */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 8209AE9Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8209AEC4;  }
		/* 8209AE9Ch case    1:*/		return 0x8209AEA0;
		  /* 8209AEA0h */ case    2:  		/* cmplwi CR6, R5, 0 */
		/* 8209AEA0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8209AEA0h case    2:*/		return 0x8209AEA4;
		  /* 8209AEA4h */ case    3:  		/* bc 12, CR6_EQ, 32 */
		/* 8209AEA4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8209AEC4;  }
		/* 8209AEA4h case    3:*/		return 0x8209AEA8;
		  /* 8209AEA8h */ case    4:  		/* lbz R11, <#[R4]> */
		/* 8209AEA8h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8209AEA8h case    4:*/		return 0x8209AEAC;
		  /* 8209AEACh */ case    5:  		/* cmplwi CR6, R3, 0 */
		/* 8209AEACh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209AEACh case    5:*/		return 0x8209AEB0;
		  /* 8209AEB0h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 8209AEB0h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8209AEB0h case    6:*/		return 0x8209AEB4;
		  /* 8209AEB4h */ case    7:  		/* bc 4, CR0_EQ, 24 */
		/* 8209AEB4h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8209AECC;  }
		/* 8209AEB4h case    7:*/		return 0x8209AEB8;
		  /* 8209AEB8h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 8209AEB8h case    8:*/		if ( regs.CR[6].eq ) { return 0x8209AEC4;  }
		/* 8209AEB8h case    8:*/		return 0x8209AEBC;
		  /* 8209AEBCh */ case    9:  		/* li R11, 0 */
		/* 8209AEBCh case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209AEBCh case    9:*/		return 0x8209AEC0;
		  /* 8209AEC0h */ case   10:  		/* sth R11, <#[R3]> */
		/* 8209AEC0h case   10:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209AEC0h case   10:*/		return 0x8209AEC4;
	}
	return 0x8209AEC4;
} // Block from 8209AE98h-8209AEC4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209AEC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AEC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AEC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AEC4);
		  /* 8209AEC4h */ case    0:  		/* li R3, 0 */
		/* 8209AEC4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209AEC4h case    0:*/		return 0x8209AEC8;
		  /* 8209AEC8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8209AEC8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209AEC8h case    1:*/		return 0x8209AECC;
	}
	return 0x8209AECC;
} // Block from 8209AEC4h-8209AECCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209AECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AECC);
		  /* 8209AECCh */ case    0:  		/* bc 12, CR6_EQ, 12 */
		/* 8209AECCh case    0:*/		if ( regs.CR[6].eq ) { return 0x8209AED8;  }
		/* 8209AECCh case    0:*/		return 0x8209AED0;
		  /* 8209AED0h */ case    1:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 8209AED0h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8209AED0h case    1:*/		return 0x8209AED4;
		  /* 8209AED4h */ case    2:  		/* sth R11, <#[R3]> */
		/* 8209AED4h case    2:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209AED4h case    2:*/		return 0x8209AED8;
	}
	return 0x8209AED8;
} // Block from 8209AECCh-8209AED8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209AED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AED8);
		  /* 8209AED8h */ case    0:  		/* li R3, 1 */
		/* 8209AED8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8209AED8h case    0:*/		return 0x8209AEDC;
		  /* 8209AEDCh */ case    1:  		/* bclr 20, CR0_LT */
		/* 8209AEDCh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209AEDCh case    1:*/		return 0x8209AEE0;
	}
	return 0x8209AEE0;
} // Block from 8209AED8h-8209AEE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209AEE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AEE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AEE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AEE0);
		  /* 8209AEE0h */ case    0:  		/* mfspr R12, LR */
		/* 8209AEE0h case    0:*/		regs.R12 = regs.LR;
		/* 8209AEE0h case    0:*/		return 0x8209AEE4;
		  /* 8209AEE4h */ case    1:  		/* bl -40084 */
		/* 8209AEE4h case    1:*/		regs.LR = 0x8209AEE8; return 0x82091250;
		/* 8209AEE4h case    1:*/		return 0x8209AEE8;
		  /* 8209AEE8h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 8209AEE8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 8209AEE8h case    2:*/		return 0x8209AEEC;
		  /* 8209AEECh */ case    3:  		/* mr R31, R3 */
		/* 8209AEECh case    3:*/		regs.R31 = regs.R3;
		/* 8209AEECh case    3:*/		return 0x8209AEF0;
		  /* 8209AEF0h */ case    4:  		/* mr R29, R4 */
		/* 8209AEF0h case    4:*/		regs.R29 = regs.R4;
		/* 8209AEF0h case    4:*/		return 0x8209AEF4;
		  /* 8209AEF4h */ case    5:  		/* mr R30, R5 */
		/* 8209AEF4h case    5:*/		regs.R30 = regs.R5;
		/* 8209AEF4h case    5:*/		return 0x8209AEF8;
		  /* 8209AEF8h */ case    6:  		/* li R26, 0 */
		/* 8209AEF8h case    6:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8209AEF8h case    6:*/		return 0x8209AEFC;
		  /* 8209AEFCh */ case    7:  		/* li R5, 28 */
		/* 8209AEFCh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x1C);
		/* 8209AEFCh case    7:*/		return 0x8209AF00;
		  /* 8209AF00h */ case    8:  		/* li R4, 0 */
		/* 8209AF00h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8209AF00h case    8:*/		return 0x8209AF04;
		  /* 8209AF04h */ case    9:  		/* stw R26, <#[R1 + 80]> */
		/* 8209AF04h case    9:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 8209AF04h case    9:*/		return 0x8209AF08;
		  /* 8209AF08h */ case   10:  		/* addi R3, R1, 84 */
		/* 8209AF08h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x54);
		/* 8209AF08h case   10:*/		return 0x8209AF0C;
		  /* 8209AF0Ch */ case   11:  		/* mr R28, R6 */
		/* 8209AF0Ch case   11:*/		regs.R28 = regs.R6;
		/* 8209AF0Ch case   11:*/		return 0x8209AF10;
		  /* 8209AF10h */ case   12:  		/* mr R27, R7 */
		/* 8209AF10h case   12:*/		regs.R27 = regs.R7;
		/* 8209AF10h case   12:*/		return 0x8209AF14;
		  /* 8209AF14h */ case   13:  		/* bl -39892 */
		/* 8209AF14h case   13:*/		regs.LR = 0x8209AF18; return 0x82091340;
		/* 8209AF14h case   13:*/		return 0x8209AF18;
		  /* 8209AF18h */ case   14:  		/* cmplwi CR6, R30, 0 */
		/* 8209AF18h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8209AF18h case   14:*/		return 0x8209AF1C;
		  /* 8209AF1Ch */ case   15:  		/* bc 4, CR6_EQ, 28 */
		/* 8209AF1Ch case   15:*/		if ( !regs.CR[6].eq ) { return 0x8209AF38;  }
		/* 8209AF1Ch case   15:*/		return 0x8209AF20;
		  /* 8209AF20h */ case   16:  		/* bl -24600 */
		/* 8209AF20h case   16:*/		regs.LR = 0x8209AF24; return 0x82094F08;
		/* 8209AF20h case   16:*/		return 0x8209AF24;
		  /* 8209AF24h */ case   17:  		/* li R11, 22 */
		/* 8209AF24h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 8209AF24h case   17:*/		return 0x8209AF28;
		  /* 8209AF28h */ case   18:  		/* stw R11, <#[R3]> */
		/* 8209AF28h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209AF28h case   18:*/		return 0x8209AF2C;
		  /* 8209AF2Ch */ case   19:  		/* bl -30156 */
		/* 8209AF2Ch case   19:*/		regs.LR = 0x8209AF30; return 0x82093960;
		/* 8209AF2Ch case   19:*/		return 0x8209AF30;
		  /* 8209AF30h */ case   20:  		/* li R3, -1 */
		/* 8209AF30h case   20:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209AF30h case   20:*/		return 0x8209AF34;
		  /* 8209AF34h */ case   21:  		/* b 136 */
		/* 8209AF34h case   21:*/		return 0x8209AFBC;
		/* 8209AF34h case   21:*/		return 0x8209AF38;
	}
	return 0x8209AF38;
} // Block from 8209AEE0h-8209AF38h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8209AF38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AF38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AF38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AF38);
		  /* 8209AF38h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 8209AF38h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8209AF38h case    0:*/		return 0x8209AF3C;
		  /* 8209AF3Ch */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8209AF3Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8209AF48;  }
		/* 8209AF3Ch case    1:*/		return 0x8209AF40;
		  /* 8209AF40h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 8209AF40h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8209AF40h case    2:*/		return 0x8209AF44;
		  /* 8209AF44h */ case    3:  		/* bc 12, CR6_EQ, -36 */
		/* 8209AF44h case    3:*/		if ( regs.CR[6].eq ) { return 0x8209AF20;  }
		/* 8209AF44h case    3:*/		return 0x8209AF48;
	}
	return 0x8209AF48;
} // Block from 8209AF38h-8209AF48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209AF48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AF48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AF48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AF48);
		  /* 8209AF48h */ case    0:  		/* lis R11, 32767 */
		/* 8209AF48h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FFF);
		/* 8209AF48h case    0:*/		return 0x8209AF4C;
		  /* 8209AF4Ch */ case    1:  		/* ori R11, R11, 65535 */
		/* 8209AF4Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFFF);
		/* 8209AF4Ch case    1:*/		return 0x8209AF50;
		  /* 8209AF50h */ case    2:  		/* cmplw CR6, R29, R11 */
		/* 8209AF50h case    2:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8209AF50h case    2:*/		return 0x8209AF54;
		  /* 8209AF54h */ case    3:  		/* stw R11, <#[R1 + 84]> */
		/* 8209AF54h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8209AF54h case    3:*/		return 0x8209AF58;
		  /* 8209AF58h */ case    4:  		/* bc 12, CR6_GT, 8 */
		/* 8209AF58h case    4:*/		if ( regs.CR[6].gt ) { return 0x8209AF60;  }
		/* 8209AF58h case    4:*/		return 0x8209AF5C;
		  /* 8209AF5Ch */ case    5:  		/* stw R29, <#[R1 + 84]> */
		/* 8209AF5Ch case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000054) );
		/* 8209AF5Ch case    5:*/		return 0x8209AF60;
	}
	return 0x8209AF60;
} // Block from 8209AF48h-8209AF60h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209AF60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AF60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AF60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AF60);
		  /* 8209AF60h */ case    0:  		/* li R11, 66 */
		/* 8209AF60h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x42);
		/* 8209AF60h case    0:*/		return 0x8209AF64;
		  /* 8209AF64h */ case    1:  		/* stw R31, <#[R1 + 88]> */
		/* 8209AF64h case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000058) );
		/* 8209AF64h case    1:*/		return 0x8209AF68;
		  /* 8209AF68h */ case    2:  		/* stw R31, <#[R1 + 80]> */
		/* 8209AF68h case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 8209AF68h case    2:*/		return 0x8209AF6C;
		  /* 8209AF6Ch */ case    3:  		/* mr R6, R27 */
		/* 8209AF6Ch case    3:*/		regs.R6 = regs.R27;
		/* 8209AF6Ch case    3:*/		return 0x8209AF70;
		  /* 8209AF70h */ case    4:  		/* stw R11, <#[R1 + 92]> */
		/* 8209AF70h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8209AF70h case    4:*/		return 0x8209AF74;
		  /* 8209AF74h */ case    5:  		/* mr R5, R28 */
		/* 8209AF74h case    5:*/		regs.R5 = regs.R28;
		/* 8209AF74h case    5:*/		return 0x8209AF78;
		  /* 8209AF78h */ case    6:  		/* mr R4, R30 */
		/* 8209AF78h case    6:*/		regs.R4 = regs.R30;
		/* 8209AF78h case    6:*/		return 0x8209AF7C;
		  /* 8209AF7Ch */ case    7:  		/* addi R3, R1, 80 */
		/* 8209AF7Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8209AF7Ch case    7:*/		return 0x8209AF80;
		  /* 8209AF80h */ case    8:  		/* bl -18824 */
		/* 8209AF80h case    8:*/		regs.LR = 0x8209AF84; return 0x820965F8;
		/* 8209AF80h case    8:*/		return 0x8209AF84;
		  /* 8209AF84h */ case    9:  		/* mr R30, R3 */
		/* 8209AF84h case    9:*/		regs.R30 = regs.R3;
		/* 8209AF84h case    9:*/		return 0x8209AF88;
		  /* 8209AF88h */ case   10:  		/* cmplwi CR6, R31, 0 */
		/* 8209AF88h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8209AF88h case   10:*/		return 0x8209AF8C;
		  /* 8209AF8Ch */ case   11:  		/* bc 12, CR6_EQ, 44 */
		/* 8209AF8Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x8209AFB8;  }
		/* 8209AF8Ch case   11:*/		return 0x8209AF90;
		  /* 8209AF90h */ case   12:  		/* lwz R11, <#[R1 + 84]> */
		/* 8209AF90h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8209AF90h case   12:*/		return 0x8209AF94;
		  /* 8209AF94h */ case   13:  		/* addic. R11, R11, -1 */
		/* 8209AF94h case   13:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8209AF94h case   13:*/		return 0x8209AF98;
		  /* 8209AF98h */ case   14:  		/* stw R11, <#[R1 + 84]> */
		/* 8209AF98h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8209AF98h case   14:*/		return 0x8209AF9C;
		  /* 8209AF9Ch */ case   15:  		/* bc 12, CR0_LT, 16 */
		/* 8209AF9Ch case   15:*/		if ( regs.CR[0].lt ) { return 0x8209AFAC;  }
		/* 8209AF9Ch case   15:*/		return 0x8209AFA0;
		  /* 8209AFA0h */ case   16:  		/* lwz R11, <#[R1 + 80]> */
		/* 8209AFA0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8209AFA0h case   16:*/		return 0x8209AFA4;
		  /* 8209AFA4h */ case   17:  		/* stb R26, <#[R11]> */
		/* 8209AFA4h case   17:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R11 + 0x00000000) );
		/* 8209AFA4h case   17:*/		return 0x8209AFA8;
		  /* 8209AFA8h */ case   18:  		/* b 16 */
		/* 8209AFA8h case   18:*/		return 0x8209AFB8;
		/* 8209AFA8h case   18:*/		return 0x8209AFAC;
	}
	return 0x8209AFAC;
} // Block from 8209AF60h-8209AFACh (19 instructions)

//////////////////////////////////////////////////////
// Block at 8209AFACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AFAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AFAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AFAC);
		  /* 8209AFACh */ case    0:  		/* addi R4, R1, 80 */
		/* 8209AFACh case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8209AFACh case    0:*/		return 0x8209AFB0;
	}
	return 0x8209AFB0;
} // Block from 8209AFACh-8209AFB0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209AFB0h
// Function '_vsnwprintf'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AFB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AFB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AFB0);
		  /* 8209AFB0h */ case    0:  		/* li R3, 0 */
		/* 8209AFB0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209AFB0h case    0:*/		return 0x8209AFB4;
		  /* 8209AFB4h */ case    1:  		/* bl -25332 */
		/* 8209AFB4h case    1:*/		regs.LR = 0x8209AFB8; return 0x82094CC0;
		/* 8209AFB4h case    1:*/		return 0x8209AFB8;
	}
	return 0x8209AFB8;
} // Block from 8209AFB0h-8209AFB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209AFB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AFB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AFB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AFB8);
		  /* 8209AFB8h */ case    0:  		/* mr R3, R30 */
		/* 8209AFB8h case    0:*/		regs.R3 = regs.R30;
		/* 8209AFB8h case    0:*/		return 0x8209AFBC;
	}
	return 0x8209AFBC;
} // Block from 8209AFB8h-8209AFBCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209AFBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AFBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AFBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AFBC);
		  /* 8209AFBCh */ case    0:  		/* addi R1, R1, 176 */
		/* 8209AFBCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 8209AFBCh case    0:*/		return 0x8209AFC0;
		  /* 8209AFC0h */ case    1:  		/* b -40224 */
		/* 8209AFC0h case    1:*/		return 0x820912A0;
		/* 8209AFC0h case    1:*/		return 0x8209AFC4;
		  /* 8209AFC4h */ case    2:  		/* nop */
		/* 8209AFC4h case    2:*/		cpu::op::nop();
		/* 8209AFC4h case    2:*/		return 0x8209AFC8;
	}
	return 0x8209AFC8;
} // Block from 8209AFBCh-8209AFC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209AFC8h
// Function 'printf'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AFC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AFC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AFC8);
		  /* 8209AFC8h */ case    0:  		/* mr R7, R6 */
		/* 8209AFC8h case    0:*/		regs.R7 = regs.R6;
		/* 8209AFC8h case    0:*/		return 0x8209AFCC;
		  /* 8209AFCCh */ case    1:  		/* li R6, 0 */
		/* 8209AFCCh case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8209AFCCh case    1:*/		return 0x8209AFD0;
		  /* 8209AFD0h */ case    2:  		/* b -240 */
		/* 8209AFD0h case    2:*/		return 0x8209AEE0;
		/* 8209AFD0h case    2:*/		return 0x8209AFD4;
		  /* 8209AFD4h */ case    3:  		/* nop */
		/* 8209AFD4h case    3:*/		cpu::op::nop();
		/* 8209AFD4h case    3:*/		return 0x8209AFD8;
	}
	return 0x8209AFD8;
} // Block from 8209AFC8h-8209AFD8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209AFD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209AFD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209AFD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209AFD8);
		  /* 8209AFD8h */ case    0:  		/* mfspr R12, LR */
		/* 8209AFD8h case    0:*/		regs.R12 = regs.LR;
		/* 8209AFD8h case    0:*/		return 0x8209AFDC;
		  /* 8209AFDCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209AFDCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209AFDCh case    1:*/		return 0x8209AFE0;
		  /* 8209AFE0h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209AFE0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209AFE0h case    2:*/		return 0x8209AFE4;
		  /* 8209AFE4h */ case    3:  		/* mr R11, R4 */
		/* 8209AFE4h case    3:*/		regs.R11 = regs.R4;
		/* 8209AFE4h case    3:*/		return 0x8209AFE8;
		  /* 8209AFE8h */ case    4:  		/* cmplwi CR6, R4, 0 */
		/* 8209AFE8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8209AFE8h case    4:*/		return 0x8209AFEC;
		  /* 8209AFECh */ case    5:  		/* bc 4, CR6_EQ, 24 */
		/* 8209AFECh case    5:*/		if ( !regs.CR[6].eq ) { return 0x8209B004;  }
		/* 8209AFECh case    5:*/		return 0x8209AFF0;
		  /* 8209AFF0h */ case    6:  		/* cmplwi CR6, R5, 0 */
		/* 8209AFF0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8209AFF0h case    6:*/		return 0x8209AFF4;
		  /* 8209AFF4h */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 8209AFF4h case    7:*/		if ( regs.CR[6].eq ) { return 0x8209B004;  }
		/* 8209AFF4h case    7:*/		return 0x8209AFF8;
		  /* 8209AFF8h */ case    8:  		/* cmplwi CR6, R3, 0 */
		/* 8209AFF8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209AFF8h case    8:*/		return 0x8209AFFC;
		  /* 8209AFFCh */ case    9:  		/* bc 12, CR6_EQ, 188 */
		/* 8209AFFCh case    9:*/		if ( regs.CR[6].eq ) { return 0x8209B0B8;  }
		/* 8209AFFCh case    9:*/		return 0x8209B000;
		  /* 8209B000h */ case   10:  		/* b 180 */
		/* 8209B000h case   10:*/		return 0x8209B0B4;
		/* 8209B000h case   10:*/		return 0x8209B004;
	}
	return 0x8209B004;
} // Block from 8209AFD8h-8209B004h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209B004h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B004( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B004) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B004);
		  /* 8209B004h */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 8209B004h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209B004h case    0:*/		return 0x8209B008;
		  /* 8209B008h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8209B008h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209B014;  }
		/* 8209B008h case    1:*/		return 0x8209B00C;
		  /* 8209B00Ch */ case    2:  		/* li R10, -1 */
		/* 8209B00Ch case    2:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8209B00Ch case    2:*/		return 0x8209B010;
		  /* 8209B010h */ case    3:  		/* stw R10, <#[R3]> */
		/* 8209B010h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8209B010h case    3:*/		return 0x8209B014;
	}
	return 0x8209B014;
} // Block from 8209B004h-8209B014h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209B014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B014);
		  /* 8209B014h */ case    0:  		/* lis R10, 32767 */
		/* 8209B014h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x7FFF);
		/* 8209B014h case    0:*/		return 0x8209B018;
		  /* 8209B018h */ case    1:  		/* ori R10, R10, 65535 */
		/* 8209B018h case    1:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0xFFFF);
		/* 8209B018h case    1:*/		return 0x8209B01C;
		  /* 8209B01Ch */ case    2:  		/* cmplw CR6, R5, R10 */
		/* 8209B01Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R10);
		/* 8209B01Ch case    2:*/		return 0x8209B020;
		  /* 8209B020h */ case    3:  		/* bc 4, CR6_GT, 28 */
		/* 8209B020h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8209B03C;  }
		/* 8209B020h case    3:*/		return 0x8209B024;
		  /* 8209B024h */ case    4:  		/* bl -24860 */
		/* 8209B024h case    4:*/		regs.LR = 0x8209B028; return 0x82094F08;
		/* 8209B024h case    4:*/		return 0x8209B028;
		  /* 8209B028h */ case    5:  		/* li R11, 22 */
		/* 8209B028h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 8209B028h case    5:*/		return 0x8209B02C;
		  /* 8209B02Ch */ case    6:  		/* stw R11, <#[R3]> */
		/* 8209B02Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209B02Ch case    6:*/		return 0x8209B030;
		  /* 8209B030h */ case    7:  		/* bl -30416 */
		/* 8209B030h case    7:*/		regs.LR = 0x8209B034; return 0x82093960;
		/* 8209B030h case    7:*/		return 0x8209B034;
		  /* 8209B034h */ case    8:  		/* li R3, 22 */
		/* 8209B034h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x16);
		/* 8209B034h case    8:*/		return 0x8209B038;
		  /* 8209B038h */ case    9:  		/* b 132 */
		/* 8209B038h case    9:*/		return 0x8209B0BC;
		/* 8209B038h case    9:*/		return 0x8209B03C;
	}
	return 0x8209B03C;
} // Block from 8209B014h-8209B03Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209B03Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B03C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B03C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B03C);
		  /* 8209B03Ch */ case    0:  		/* rlwinm R10, R6, 0, 16, 31 */
		/* 8209B03Ch case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R6);
		/* 8209B03Ch case    0:*/		return 0x8209B040;
		  /* 8209B040h */ case    1:  		/* cmplwi CR6, R10, 255 */
		/* 8209B040h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x000000FF);
		/* 8209B040h case    1:*/		return 0x8209B044;
		  /* 8209B044h */ case    2:  		/* bc 4, CR6_GT, 56 */
		/* 8209B044h case    2:*/		if ( !regs.CR[6].gt ) { return 0x8209B07C;  }
		/* 8209B044h case    2:*/		return 0x8209B048;
		  /* 8209B048h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8209B048h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209B048h case    3:*/		return 0x8209B04C;
		  /* 8209B04Ch */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 8209B04Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x8209B064;  }
		/* 8209B04Ch case    4:*/		return 0x8209B050;
		  /* 8209B050h */ case    5:  		/* cmplwi CR6, R5, 0 */
		/* 8209B050h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8209B050h case    5:*/		return 0x8209B054;
		  /* 8209B054h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 8209B054h case    6:*/		if ( regs.CR[6].eq ) { return 0x8209B064;  }
		/* 8209B054h case    6:*/		return 0x8209B058;
		  /* 8209B058h */ case    7:  		/* li R4, 0 */
		/* 8209B058h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8209B058h case    7:*/		return 0x8209B05C;
		  /* 8209B05Ch */ case    8:  		/* mr R3, R11 */
		/* 8209B05Ch case    8:*/		regs.R3 = regs.R11;
		/* 8209B05Ch case    8:*/		return 0x8209B060;
		  /* 8209B060h */ case    9:  		/* bl -40224 */
		/* 8209B060h case    9:*/		regs.LR = 0x8209B064; return 0x82091340;
		/* 8209B060h case    9:*/		return 0x8209B064;
	}
	return 0x8209B064;
} // Block from 8209B03Ch-8209B064h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209B064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B064);
		  /* 8209B064h */ case    0:  		/* bl -24924 */
		/* 8209B064h case    0:*/		regs.LR = 0x8209B068; return 0x82094F08;
		/* 8209B064h case    0:*/		return 0x8209B068;
		  /* 8209B068h */ case    1:  		/* li R11, 42 */
		/* 8209B068h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x2A);
		/* 8209B068h case    1:*/		return 0x8209B06C;
		  /* 8209B06Ch */ case    2:  		/* stw R11, <#[R3]> */
		/* 8209B06Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209B06Ch case    2:*/		return 0x8209B070;
		  /* 8209B070h */ case    3:  		/* bl -24936 */
		/* 8209B070h case    3:*/		regs.LR = 0x8209B074; return 0x82094F08;
		/* 8209B070h case    3:*/		return 0x8209B074;
		  /* 8209B074h */ case    4:  		/* lwz R3, <#[R3]> */
		/* 8209B074h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 8209B074h case    4:*/		return 0x8209B078;
		  /* 8209B078h */ case    5:  		/* b 68 */
		/* 8209B078h case    5:*/		return 0x8209B0BC;
		/* 8209B078h case    5:*/		return 0x8209B07C;
	}
	return 0x8209B07C;
} // Block from 8209B064h-8209B07Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209B07Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B07C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B07C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B07C);
		  /* 8209B07Ch */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8209B07Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209B07Ch case    0:*/		return 0x8209B080;
		  /* 8209B080h */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 8209B080h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209B0A8;  }
		/* 8209B080h case    1:*/		return 0x8209B084;
		  /* 8209B084h */ case    2:  		/* cmplwi CR6, R5, 0 */
		/* 8209B084h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8209B084h case    2:*/		return 0x8209B088;
		  /* 8209B088h */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 8209B088h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8209B0A4;  }
		/* 8209B088h case    3:*/		return 0x8209B08C;
		  /* 8209B08Ch */ case    4:  		/* bl -24964 */
		/* 8209B08Ch case    4:*/		regs.LR = 0x8209B090; return 0x82094F08;
		/* 8209B08Ch case    4:*/		return 0x8209B090;
		  /* 8209B090h */ case    5:  		/* li R11, 34 */
		/* 8209B090h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x22);
		/* 8209B090h case    5:*/		return 0x8209B094;
		  /* 8209B094h */ case    6:  		/* stw R11, <#[R3]> */
		/* 8209B094h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209B094h case    6:*/		return 0x8209B098;
		  /* 8209B098h */ case    7:  		/* bl -30520 */
		/* 8209B098h case    7:*/		regs.LR = 0x8209B09C; return 0x82093960;
		/* 8209B098h case    7:*/		return 0x8209B09C;
		  /* 8209B09Ch */ case    8:  		/* li R3, 34 */
		/* 8209B09Ch case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x22);
		/* 8209B09Ch case    8:*/		return 0x8209B0A0;
		  /* 8209B0A0h */ case    9:  		/* b 28 */
		/* 8209B0A0h case    9:*/		return 0x8209B0BC;
		/* 8209B0A0h case    9:*/		return 0x8209B0A4;
	}
	return 0x8209B0A4;
} // Block from 8209B07Ch-8209B0A4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209B0A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B0A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B0A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B0A4);
		  /* 8209B0A4h */ case    0:  		/* stb R6, <#[R11]> */
		/* 8209B0A4h case    0:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8209B0A4h case    0:*/		return 0x8209B0A8;
	}
	return 0x8209B0A8;
} // Block from 8209B0A4h-8209B0A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209B0A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B0A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B0A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B0A8);
		  /* 8209B0A8h */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 8209B0A8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209B0A8h case    0:*/		return 0x8209B0AC;
		  /* 8209B0ACh */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8209B0ACh case    1:*/		if ( regs.CR[6].eq ) { return 0x8209B0B8;  }
		/* 8209B0ACh case    1:*/		return 0x8209B0B0;
		  /* 8209B0B0h */ case    2:  		/* li R11, 1 */
		/* 8209B0B0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8209B0B0h case    2:*/		return 0x8209B0B4;
	}
	return 0x8209B0B4;
} // Block from 8209B0A8h-8209B0B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B0B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B0B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B0B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B0B4);
		  /* 8209B0B4h */ case    0:  		/* stw R11, <#[R3]> */
		/* 8209B0B4h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209B0B4h case    0:*/		return 0x8209B0B8;
	}
	return 0x8209B0B8;
} // Block from 8209B0B4h-8209B0B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209B0B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B0B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B0B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B0B8);
		  /* 8209B0B8h */ case    0:  		/* li R3, 0 */
		/* 8209B0B8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209B0B8h case    0:*/		return 0x8209B0BC;
	}
	return 0x8209B0BC;
} // Block from 8209B0B8h-8209B0BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209B0BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B0BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B0BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B0BC);
		  /* 8209B0BCh */ case    0:  		/* addi R1, R1, 96 */
		/* 8209B0BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209B0BCh case    0:*/		return 0x8209B0C0;
	}
	return 0x8209B0C0;
} // Block from 8209B0BCh-8209B0C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209B0C0h
// Function '_get_printf_count_output'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B0C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B0C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B0C0);
		  /* 8209B0C0h */ case    0:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209B0C0h case    0:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209B0C0h case    0:*/		return 0x8209B0C4;
		  /* 8209B0C4h */ case    1:  		/* mtspr LR, R12 */
		/* 8209B0C4h case    1:*/		regs.LR = regs.R12;
		/* 8209B0C4h case    1:*/		return 0x8209B0C8;
		  /* 8209B0C8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8209B0C8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209B0C8h case    2:*/		return 0x8209B0CC;
	}
	return 0x8209B0CC;
} // Block from 8209B0C0h-8209B0CCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B0CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B0CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B0CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B0CC);
		  /* 8209B0CCh */ case    0:  		/* nop */
		/* 8209B0CCh case    0:*/		cpu::op::nop();
		/* 8209B0CCh case    0:*/		return 0x8209B0D0;
	}
	return 0x8209B0D0;
} // Block from 8209B0CCh-8209B0D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209B0D0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B0D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B0D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B0D0);
		  /* 8209B0D0h */ case    0:  		/* li R7, 0 */
		/* 8209B0D0h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8209B0D0h case    0:*/		return 0x8209B0D4;
		  /* 8209B0D4h */ case    1:  		/* b -252 */
		/* 8209B0D4h case    1:*/		return 0x8209AFD8;
		/* 8209B0D4h case    1:*/		return 0x8209B0D8;
	}
	return 0x8209B0D8;
} // Block from 8209B0D0h-8209B0D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209B0D8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B0D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B0D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B0D8);
		  /* 8209B0D8h */ case    0:  		/* cmpwi CR6, R3, -1 */
		/* 8209B0D8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8209B0D8h case    0:*/		return 0x8209B0DC;
		  /* 8209B0DCh */ case    1:  		/* bc 12, CR6_LT, 40 */
		/* 8209B0DCh case    1:*/		if ( regs.CR[6].lt ) { return 0x8209B104;  }
		/* 8209B0DCh case    1:*/		return 0x8209B0E0;
		  /* 8209B0E0h */ case    2:  		/* cmpwi CR6, R3, 255 */
		/* 8209B0E0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x000000FF);
		/* 8209B0E0h case    2:*/		return 0x8209B0E4;
		  /* 8209B0E4h */ case    3:  		/* bc 12, CR6_GT, 32 */
		/* 8209B0E4h case    3:*/		if ( regs.CR[6].gt ) { return 0x8209B104;  }
		/* 8209B0E4h case    3:*/		return 0x8209B0E8;
	}
	return 0x8209B0E8;
} // Block from 8209B0D8h-8209B0E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209B0E8h
// Function '_isleadbyte_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B0E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B0E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B0E8);
		  /* 8209B0E8h */ case    0:  		/* lis R11, -32217 */
		/* 8209B0E8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 8209B0E8h case    0:*/		return 0x8209B0EC;
		  /* 8209B0ECh */ case    1:  		/* rlwinm R10, R3, 1, 0, 30 */
		/* 8209B0ECh case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R3);
		/* 8209B0ECh case    1:*/		return 0x8209B0F0;
		  /* 8209B0F0h */ case    2:  		/* lwz R11, <#[R11 + 8856]> */
		/* 8209B0F0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00002298) );
		/* 8209B0F0h case    2:*/		return 0x8209B0F4;
		  /* 8209B0F4h */ case    3:  		/* lwz R11, <#[R11 + 200]> */
		/* 8209B0F4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000C8) );
		/* 8209B0F4h case    3:*/		return 0x8209B0F8;
		  /* 8209B0F8h */ case    4:  		/* lhzx R11, <#[R11 + R10]> */
		/* 8209B0F8h case    4:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8209B0F8h case    4:*/		return 0x8209B0FC;
		  /* 8209B0FCh */ case    5:  		/* and R3, R11, R4 */
		/* 8209B0FCh case    5:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R4);
		/* 8209B0FCh case    5:*/		return 0x8209B100;
		  /* 8209B100h */ case    6:  		/* bclr 20, CR0_LT */
		/* 8209B100h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209B100h case    6:*/		return 0x8209B104;
	}
	return 0x8209B104;
} // Block from 8209B0E8h-8209B104h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209B104h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B104( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B104) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B104);
		  /* 8209B104h */ case    0:  		/* li R3, 0 */
		/* 8209B104h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209B104h case    0:*/		return 0x8209B108;
	}
	return 0x8209B108;
} // Block from 8209B104h-8209B108h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209B108h
// Function '_mbtowc_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B108);
		  /* 8209B108h */ case    0:  		/* bclr 20, CR0_LT */
		/* 8209B108h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209B108h case    0:*/		return 0x8209B10C;
	}
	return 0x8209B10C;
} // Block from 8209B108h-8209B10Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209B10Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B10C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B10C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B10C);
		  /* 8209B10Ch */ case    0:  		/* nop */
		/* 8209B10Ch case    0:*/		cpu::op::nop();
		/* 8209B10Ch case    0:*/		return 0x8209B110;
		  /* 8209B110h */ case    1:  		/* rlwinm. R10, R3, 0, 30, 31 */
		/* 8209B110h case    1:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R10,regs.R3);
		/* 8209B110h case    1:*/		return 0x8209B114;
		  /* 8209B114h */ case    2:  		/* li R11, 0 */
		/* 8209B114h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209B114h case    2:*/		return 0x8209B118;
		  /* 8209B118h */ case    3:  		/* bc 12, CR0_EQ, 48 */
		/* 8209B118h case    3:*/		if ( regs.CR[0].eq ) { return 0x8209B148;  }
		/* 8209B118h case    3:*/		return 0x8209B11C;
		  /* 8209B11Ch */ case    4:  		/* cmplwi CR6, R10, 1 */
		/* 8209B11Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 8209B11Ch case    4:*/		return 0x8209B120;
		  /* 8209B120h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 8209B120h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8209B12C;  }
		/* 8209B120h case    5:*/		return 0x8209B124;
		  /* 8209B124h */ case    6:  		/* li R11, 768 */
		/* 8209B124h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x300);
		/* 8209B124h case    6:*/		return 0x8209B128;
		  /* 8209B128h */ case    7:  		/* b 32 */
		/* 8209B128h case    7:*/		return 0x8209B148;
		/* 8209B128h case    7:*/		return 0x8209B12C;
	}
	return 0x8209B12C;
} // Block from 8209B10Ch-8209B12Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209B12Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B12C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B12C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B12C);
		  /* 8209B12Ch */ case    0:  		/* cmplwi CR6, R10, 2 */
		/* 8209B12Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 8209B12Ch case    0:*/		return 0x8209B130;
		  /* 8209B130h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 8209B130h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209B13C;  }
		/* 8209B130h case    1:*/		return 0x8209B134;
		  /* 8209B134h */ case    2:  		/* li R11, 512 */
		/* 8209B134h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x200);
		/* 8209B134h case    2:*/		return 0x8209B138;
		  /* 8209B138h */ case    3:  		/* b 16 */
		/* 8209B138h case    3:*/		return 0x8209B148;
		/* 8209B138h case    3:*/		return 0x8209B13C;
	}
	return 0x8209B13C;
} // Block from 8209B12Ch-8209B13Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209B13Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B13C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B13C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B13C);
		  /* 8209B13Ch */ case    0:  		/* cmplwi CR6, R10, 3 */
		/* 8209B13Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 8209B13Ch case    0:*/		return 0x8209B140;
		  /* 8209B140h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 8209B140h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209B148;  }
		/* 8209B140h case    1:*/		return 0x8209B144;
		  /* 8209B144h */ case    2:  		/* li R11, 256 */
		/* 8209B144h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x100);
		/* 8209B144h case    2:*/		return 0x8209B148;
	}
	return 0x8209B148;
} // Block from 8209B13Ch-8209B148h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B148);
		  /* 8209B148h */ case    0:  		/* rlwinm. R10, R3, 0, 28, 28 */
		/* 8209B148h case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R10,regs.R3);
		/* 8209B148h case    0:*/		return 0x8209B14C;
		  /* 8209B14Ch */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8209B14Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8209B154;  }
		/* 8209B14Ch case    1:*/		return 0x8209B150;
	}
	return 0x8209B150;
} // Block from 8209B148h-8209B150h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209B150h
// Function '_vsnprintf_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B150);
		  /* 8209B150h */ case    0:  		/* ori R11, R11, 1 */
		/* 8209B150h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209B150h case    0:*/		return 0x8209B154;
	}
	return 0x8209B154;
} // Block from 8209B150h-8209B154h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209B154h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B154( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B154) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B154);
		  /* 8209B154h */ case    0:  		/* rlwinm. R10, R3, 0, 26, 26 */
		/* 8209B154h case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R10,regs.R3);
		/* 8209B154h case    0:*/		return 0x8209B158;
		  /* 8209B158h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8209B158h case    1:*/		if ( regs.CR[0].eq ) { return 0x8209B160;  }
		/* 8209B158h case    1:*/		return 0x8209B15C;
		  /* 8209B15Ch */ case    2:  		/* ori R11, R11, 2 */
		/* 8209B15Ch case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8209B15Ch case    2:*/		return 0x8209B160;
	}
	return 0x8209B160;
} // Block from 8209B154h-8209B160h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B160);
		  /* 8209B160h */ case    0:  		/* rlwinm. R10, R3, 0, 25, 25 */
		/* 8209B160h case    0:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R3);
		/* 8209B160h case    0:*/		return 0x8209B164;
		  /* 8209B164h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8209B164h case    1:*/		if ( regs.CR[0].eq ) { return 0x8209B16C;  }
		/* 8209B164h case    1:*/		return 0x8209B168;
		  /* 8209B168h */ case    2:  		/* ori R11, R11, 4 */
		/* 8209B168h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8209B168h case    2:*/		return 0x8209B16C;
	}
	return 0x8209B16C;
} // Block from 8209B160h-8209B16Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B16Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B16C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B16C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B16C);
		  /* 8209B16Ch */ case    0:  		/* rlwinm. R10, R3, 0, 27, 27 */
		/* 8209B16Ch case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R3);
		/* 8209B16Ch case    0:*/		return 0x8209B170;
		  /* 8209B170h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8209B170h case    1:*/		if ( regs.CR[0].eq ) { return 0x8209B178;  }
		/* 8209B170h case    1:*/		return 0x8209B174;
		  /* 8209B174h */ case    2:  		/* ori R11, R11, 8 */
		/* 8209B174h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8209B174h case    2:*/		return 0x8209B178;
	}
	return 0x8209B178;
} // Block from 8209B16Ch-8209B178h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B178);
		  /* 8209B178h */ case    0:  		/* rlwinm. R10, R3, 0, 24, 24 */
		/* 8209B178h case    0:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R10,regs.R3);
		/* 8209B178h case    0:*/		return 0x8209B17C;
		  /* 8209B17Ch */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8209B17Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8209B184;  }
		/* 8209B17Ch case    1:*/		return 0x8209B180;
		  /* 8209B180h */ case    2:  		/* ori R11, R11, 16 */
		/* 8209B180h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8209B180h case    2:*/		return 0x8209B184;
	}
	return 0x8209B184;
} // Block from 8209B178h-8209B184h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B184h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B184( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B184) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B184);
		  /* 8209B184h */ case    0:  		/* oris R3, R11, 8 */
		/* 8209B184h case    0:*/		cpu::op::oris<0>(regs,&regs.R3,regs.R11,0x8);
		/* 8209B184h case    0:*/		return 0x8209B188;
		  /* 8209B188h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8209B188h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209B188h case    1:*/		return 0x8209B18C;
	}
	return 0x8209B18C;
} // Block from 8209B184h-8209B18Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209B18Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B18C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B18C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B18C);
		  /* 8209B18Ch */ case    0:  		/* nop */
		/* 8209B18Ch case    0:*/		cpu::op::nop();
		/* 8209B18Ch case    0:*/		return 0x8209B190;
	}
	return 0x8209B190;
} // Block from 8209B18Ch-8209B190h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209B190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B190);
		  /* 8209B190h */ case    0:  		/* mfspr R12, LR */
		/* 8209B190h case    0:*/		regs.R12 = regs.LR;
		/* 8209B190h case    0:*/		return 0x8209B194;
		  /* 8209B194h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209B194h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209B194h case    1:*/		return 0x8209B198;
		  /* 8209B198h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8209B198h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209B198h case    2:*/		return 0x8209B19C;
		  /* 8209B19Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209B19Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209B19Ch case    3:*/		return 0x8209B1A0;
		  /* 8209B1A0h */ case    4:  		/* mr R10, R3 */
		/* 8209B1A0h case    4:*/		regs.R10 = regs.R3;
		/* 8209B1A0h case    4:*/		return 0x8209B1A4;
		  /* 8209B1A4h */ case    5:  		/* rlwinm. R11, R3, 0, 22, 23 */
		/* 8209B1A4h case    5:*/		cpu::op::rlwinm<1,0,22,23>(regs,&regs.R11,regs.R3);
		/* 8209B1A4h case    5:*/		return 0x8209B1A8;
		  /* 8209B1A8h */ case    6:  		/* rlwinm R8, R4, 0, 22, 23 */
		/* 8209B1A8h case    6:*/		cpu::op::rlwinm<0,0,22,23>(regs,&regs.R8,regs.R4);
		/* 8209B1A8h case    6:*/		return 0x8209B1AC;
		  /* 8209B1ACh */ case    7:  		/* rlwinm R9, R4, 0, 24, 21 */
		/* 8209B1ACh case    7:*/		cpu::op::rlwinm<0,0,24,21>(regs,&regs.R9,regs.R4);
		/* 8209B1ACh case    7:*/		return 0x8209B1B0;
		  /* 8209B1B0h */ case    8:  		/* li R3, 0 */
		/* 8209B1B0h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209B1B0h case    8:*/		return 0x8209B1B4;
		  /* 8209B1B4h */ case    9:  		/* bc 12, CR0_EQ, 48 */
		/* 8209B1B4h case    9:*/		if ( regs.CR[0].eq ) { return 0x8209B1E4;  }
		/* 8209B1B4h case    9:*/		return 0x8209B1B8;
		  /* 8209B1B8h */ case   10:  		/* cmplwi CR6, R11, 768 */
		/* 8209B1B8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000300);
		/* 8209B1B8h case   10:*/		return 0x8209B1BC;
		  /* 8209B1BCh */ case   11:  		/* bc 4, CR6_EQ, 12 */
		/* 8209B1BCh case   11:*/		if ( !regs.CR[6].eq ) { return 0x8209B1C8;  }
		/* 8209B1BCh case   11:*/		return 0x8209B1C0;
		  /* 8209B1C0h */ case   12:  		/* li R3, 1 */
		/* 8209B1C0h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8209B1C0h case   12:*/		return 0x8209B1C4;
		  /* 8209B1C4h */ case   13:  		/* b 32 */
		/* 8209B1C4h case   13:*/		return 0x8209B1E4;
		/* 8209B1C4h case   13:*/		return 0x8209B1C8;
	}
	return 0x8209B1C8;
} // Block from 8209B190h-8209B1C8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209B1C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B1C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B1C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B1C8);
		  /* 8209B1C8h */ case    0:  		/* cmplwi CR6, R11, 512 */
		/* 8209B1C8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000200);
		/* 8209B1C8h case    0:*/		return 0x8209B1CC;
		  /* 8209B1CCh */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 8209B1CCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209B1D8;  }
		/* 8209B1CCh case    1:*/		return 0x8209B1D0;
		  /* 8209B1D0h */ case    2:  		/* li R3, 2 */
		/* 8209B1D0h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 8209B1D0h case    2:*/		return 0x8209B1D4;
		  /* 8209B1D4h */ case    3:  		/* b 16 */
		/* 8209B1D4h case    3:*/		return 0x8209B1E4;
		/* 8209B1D4h case    3:*/		return 0x8209B1D8;
	}
	return 0x8209B1D8;
} // Block from 8209B1C8h-8209B1D8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209B1D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B1D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B1D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B1D8);
		  /* 8209B1D8h */ case    0:  		/* cmplwi CR6, R11, 256 */
		/* 8209B1D8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000100);
		/* 8209B1D8h case    0:*/		return 0x8209B1DC;
		  /* 8209B1DCh */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 8209B1DCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209B1E4;  }
		/* 8209B1DCh case    1:*/		return 0x8209B1E0;
		  /* 8209B1E0h */ case    2:  		/* li R3, 3 */
		/* 8209B1E0h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 8209B1E0h case    2:*/		return 0x8209B1E4;
	}
	return 0x8209B1E4;
} // Block from 8209B1D8h-8209B1E4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B1E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B1E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B1E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B1E4);
		  /* 8209B1E4h */ case    0:  		/* rlwinm. R11, R10, 0, 31, 31 */
		/* 8209B1E4h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R10);
		/* 8209B1E4h case    0:*/		return 0x8209B1E8;
		  /* 8209B1E8h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8209B1E8h case    1:*/		if ( regs.CR[0].eq ) { return 0x8209B1F0;  }
		/* 8209B1E8h case    1:*/		return 0x8209B1EC;
		  /* 8209B1ECh */ case    2:  		/* ori R3, R3, 8 */
		/* 8209B1ECh case    2:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x8);
		/* 8209B1ECh case    2:*/		return 0x8209B1F0;
	}
	return 0x8209B1F0;
} // Block from 8209B1E4h-8209B1F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B1F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B1F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B1F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B1F0);
		  /* 8209B1F0h */ case    0:  		/* rlwinm. R11, R10, 0, 30, 30 */
		/* 8209B1F0h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R10);
		/* 8209B1F0h case    0:*/		return 0x8209B1F4;
		  /* 8209B1F4h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8209B1F4h case    1:*/		if ( regs.CR[0].eq ) { return 0x8209B1FC;  }
		/* 8209B1F4h case    1:*/		return 0x8209B1F8;
		  /* 8209B1F8h */ case    2:  		/* ori R3, R3, 32 */
		/* 8209B1F8h case    2:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x20);
		/* 8209B1F8h case    2:*/		return 0x8209B1FC;
	}
	return 0x8209B1FC;
} // Block from 8209B1F0h-8209B1FCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B1FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B1FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B1FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B1FC);
		  /* 8209B1FCh */ case    0:  		/* rlwinm. R11, R10, 0, 29, 29 */
		/* 8209B1FCh case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R10);
		/* 8209B1FCh case    0:*/		return 0x8209B200;
		  /* 8209B200h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8209B200h case    1:*/		if ( regs.CR[0].eq ) { return 0x8209B208;  }
		/* 8209B200h case    1:*/		return 0x8209B204;
		  /* 8209B204h */ case    2:  		/* ori R3, R3, 64 */
		/* 8209B204h case    2:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x40);
		/* 8209B204h case    2:*/		return 0x8209B208;
	}
	return 0x8209B208;
} // Block from 8209B1FCh-8209B208h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B208);
		  /* 8209B208h */ case    0:  		/* rlwinm. R11, R10, 0, 28, 28 */
		/* 8209B208h case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R10);
		/* 8209B208h case    0:*/		return 0x8209B20C;
		  /* 8209B20Ch */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8209B20Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8209B214;  }
		/* 8209B20Ch case    1:*/		return 0x8209B210;
		  /* 8209B210h */ case    2:  		/* ori R3, R3, 16 */
		/* 8209B210h case    2:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x10);
		/* 8209B210h case    2:*/		return 0x8209B214;
	}
	return 0x8209B214;
} // Block from 8209B208h-8209B214h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B214h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B214( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B214) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B214);
		  /* 8209B214h */ case    0:  		/* rlwinm. R11, R10, 0, 27, 27 */
		/* 8209B214h case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R10);
		/* 8209B214h case    0:*/		return 0x8209B218;
		  /* 8209B218h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8209B218h case    1:*/		if ( regs.CR[0].eq ) { return 0x8209B220;  }
		/* 8209B218h case    1:*/		return 0x8209B21C;
		  /* 8209B21Ch */ case    2:  		/* ori R3, R3, 128 */
		/* 8209B21Ch case    2:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x80);
		/* 8209B21Ch case    2:*/		return 0x8209B220;
	}
	return 0x8209B220;
} // Block from 8209B214h-8209B220h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B220);
		  /* 8209B220h */ case    0:  		/* rlwinm. R10, R9, 0, 22, 23 */
		/* 8209B220h case    0:*/		cpu::op::rlwinm<1,0,22,23>(regs,&regs.R10,regs.R9);
		/* 8209B220h case    0:*/		return 0x8209B224;
		  /* 8209B224h */ case    1:  		/* li R11, 0 */
		/* 8209B224h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209B224h case    1:*/		return 0x8209B228;
		  /* 8209B228h */ case    2:  		/* bc 12, CR0_EQ, 48 */
		/* 8209B228h case    2:*/		if ( regs.CR[0].eq ) { return 0x8209B258;  }
		/* 8209B228h case    2:*/		return 0x8209B22C;
		  /* 8209B22Ch */ case    3:  		/* cmplwi CR6, R10, 768 */
		/* 8209B22Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000300);
		/* 8209B22Ch case    3:*/		return 0x8209B230;
		  /* 8209B230h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 8209B230h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8209B23C;  }
		/* 8209B230h case    4:*/		return 0x8209B234;
		  /* 8209B234h */ case    5:  		/* li R11, 1 */
		/* 8209B234h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8209B234h case    5:*/		return 0x8209B238;
	}
	return 0x8209B238;
} // Block from 8209B220h-8209B238h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209B238h
// Function '_vsnprintf'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B238);
		  /* 8209B238h */ case    0:  		/* b 32 */
		/* 8209B238h case    0:*/		return 0x8209B258;
		/* 8209B238h case    0:*/		return 0x8209B23C;
	}
	return 0x8209B23C;
} // Block from 8209B238h-8209B23Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209B23Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B23C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B23C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B23C);
		  /* 8209B23Ch */ case    0:  		/* cmplwi CR6, R10, 512 */
		/* 8209B23Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000200);
		/* 8209B23Ch case    0:*/		return 0x8209B240;
		  /* 8209B240h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 8209B240h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209B24C;  }
		/* 8209B240h case    1:*/		return 0x8209B244;
		  /* 8209B244h */ case    2:  		/* li R11, 2 */
		/* 8209B244h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8209B244h case    2:*/		return 0x8209B248;
	}
	return 0x8209B248;
} // Block from 8209B23Ch-8209B248h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B248h
// Function '_wctomb_s_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B248);
		  /* 8209B248h */ case    0:  		/* b 16 */
		/* 8209B248h case    0:*/		return 0x8209B258;
		/* 8209B248h case    0:*/		return 0x8209B24C;
	}
	return 0x8209B24C;
} // Block from 8209B248h-8209B24Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209B24Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B24C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B24C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B24C);
		  /* 8209B24Ch */ case    0:  		/* cmplwi CR6, R10, 256 */
		/* 8209B24Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000100);
		/* 8209B24Ch case    0:*/		return 0x8209B250;
		  /* 8209B250h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 8209B250h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209B258;  }
		/* 8209B250h case    1:*/		return 0x8209B254;
		  /* 8209B254h */ case    2:  		/* li R11, 3 */
		/* 8209B254h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 8209B254h case    2:*/		return 0x8209B258;
	}
	return 0x8209B258;
} // Block from 8209B24Ch-8209B258h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B258h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B258);
		  /* 8209B258h */ case    0:  		/* rlwinm. R10, R9, 0, 31, 31 */
		/* 8209B258h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R9);
		/* 8209B258h case    0:*/		return 0x8209B25C;
		  /* 8209B25Ch */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8209B25Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8209B264;  }
		/* 8209B25Ch case    1:*/		return 0x8209B260;
		  /* 8209B260h */ case    2:  		/* ori R11, R11, 8 */
		/* 8209B260h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8209B260h case    2:*/		return 0x8209B264;
	}
	return 0x8209B264;
} // Block from 8209B258h-8209B264h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B264h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B264( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B264) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B264);
		  /* 8209B264h */ case    0:  		/* rlwinm. R10, R9, 0, 30, 30 */
		/* 8209B264h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R9);
		/* 8209B264h case    0:*/		return 0x8209B268;
		  /* 8209B268h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8209B268h case    1:*/		if ( regs.CR[0].eq ) { return 0x8209B270;  }
		/* 8209B268h case    1:*/		return 0x8209B26C;
		  /* 8209B26Ch */ case    2:  		/* ori R11, R11, 32 */
		/* 8209B26Ch case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x20);
		/* 8209B26Ch case    2:*/		return 0x8209B270;
	}
	return 0x8209B270;
} // Block from 8209B264h-8209B270h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B270);
		  /* 8209B270h */ case    0:  		/* rlwinm. R10, R9, 0, 29, 29 */
		/* 8209B270h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R9);
		/* 8209B270h case    0:*/		return 0x8209B274;
		  /* 8209B274h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8209B274h case    1:*/		if ( regs.CR[0].eq ) { return 0x8209B27C;  }
		/* 8209B274h case    1:*/		return 0x8209B278;
		  /* 8209B278h */ case    2:  		/* ori R11, R11, 64 */
		/* 8209B278h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 8209B278h case    2:*/		return 0x8209B27C;
	}
	return 0x8209B27C;
} // Block from 8209B270h-8209B27Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B27Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B27C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B27C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B27C);
		  /* 8209B27Ch */ case    0:  		/* rlwinm. R10, R9, 0, 28, 28 */
		/* 8209B27Ch case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R10,regs.R9);
		/* 8209B27Ch case    0:*/		return 0x8209B280;
		  /* 8209B280h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8209B280h case    1:*/		if ( regs.CR[0].eq ) { return 0x8209B288;  }
		/* 8209B280h case    1:*/		return 0x8209B284;
		  /* 8209B284h */ case    2:  		/* ori R11, R11, 16 */
		/* 8209B284h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8209B284h case    2:*/		return 0x8209B288;
	}
	return 0x8209B288;
} // Block from 8209B27Ch-8209B288h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B288);
		  /* 8209B288h */ case    0:  		/* rlwinm. R10, R9, 0, 27, 27 */
		/* 8209B288h case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R9);
		/* 8209B288h case    0:*/		return 0x8209B28C;
		  /* 8209B28Ch */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8209B28Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8209B294;  }
		/* 8209B28Ch case    1:*/		return 0x8209B290;
		  /* 8209B290h */ case    2:  		/* ori R11, R11, 128 */
		/* 8209B290h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x80);
		/* 8209B290h case    2:*/		return 0x8209B294;
	}
	return 0x8209B294;
} // Block from 8209B288h-8209B294h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B294h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B294( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B294) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B294);
		  /* 8209B294h */ case    0:  		/* rlwinm R10, R8, 24, 8, 31 */
		/* 8209B294h case    0:*/		cpu::op::rlwinm<0,24,8,31>(regs,&regs.R10,regs.R8);
		/* 8209B294h case    0:*/		return 0x8209B298;
		  /* 8209B298h */ case    1:  		/* or R4, R10, R11 */
		/* 8209B298h case    1:*/		cpu::op::or<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 8209B298h case    1:*/		return 0x8209B29C;
		  /* 8209B29Ch */ case    2:  		/* bl -9180 */
		/* 8209B29Ch case    2:*/		regs.LR = 0x8209B2A0; return 0x82098EC0;
		/* 8209B29Ch case    2:*/		return 0x8209B2A0;
		  /* 8209B2A0h */ case    3:  		/* bl -400 */
		/* 8209B2A0h case    3:*/		regs.LR = 0x8209B2A4; return 0x8209B110;
		/* 8209B2A0h case    3:*/		return 0x8209B2A4;
		  /* 8209B2A4h */ case    4:  		/* mr R31, R3 */
		/* 8209B2A4h case    4:*/		regs.R31 = regs.R3;
		/* 8209B2A4h case    4:*/		return 0x8209B2A8;
		  /* 8209B2A8h */ case    5:  		/* li R4, 0 */
		/* 8209B2A8h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8209B2A8h case    5:*/		return 0x8209B2AC;
		  /* 8209B2ACh */ case    6:  		/* li R3, 0 */
		/* 8209B2ACh case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209B2ACh case    6:*/		return 0x8209B2B0;
		  /* 8209B2B0h */ case    7:  		/* bl -9200 */
		/* 8209B2B0h case    7:*/		regs.LR = 0x8209B2B4; return 0x82098EC0;
		/* 8209B2B0h case    7:*/		return 0x8209B2B4;
		  /* 8209B2B4h */ case    8:  		/* bl -420 */
		/* 8209B2B4h case    8:*/		regs.LR = 0x8209B2B8; return 0x8209B110;
		/* 8209B2B4h case    8:*/		return 0x8209B2B8;
		  /* 8209B2B8h */ case    9:  		/* rlwinm R10, R3, 0, 12, 31 */
		/* 8209B2B8h case    9:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R10,regs.R3);
		/* 8209B2B8h case    9:*/		return 0x8209B2BC;
		  /* 8209B2BCh */ case   10:  		/* lis R11, 8 */
		/* 8209B2BCh case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0x8);
		/* 8209B2BCh case   10:*/		return 0x8209B2C0;
		  /* 8209B2C0h */ case   11:  		/* rlwinm R10, R10, 0, 27, 12 */
		/* 8209B2C0h case   11:*/		cpu::op::rlwinm<0,0,27,12>(regs,&regs.R10,regs.R10);
		/* 8209B2C0h case   11:*/		return 0x8209B2C4;
		  /* 8209B2C4h */ case   12:  		/* ori R11, R11, 31 */
		/* 8209B2C4h case   12:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1F);
		/* 8209B2C4h case   12:*/		return 0x8209B2C8;
		  /* 8209B2C8h */ case   13:  		/* li R3, 1 */
		/* 8209B2C8h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8209B2C8h case   13:*/		return 0x8209B2CC;
		  /* 8209B2CCh */ case   14:  		/* cmplw CR6, R10, R11 */
		/* 8209B2CCh case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8209B2CCh case   14:*/		return 0x8209B2D0;
		  /* 8209B2D0h */ case   15:  		/* bc 4, CR6_EQ, 8 */
		/* 8209B2D0h case   15:*/		if ( !regs.CR[6].eq ) { return 0x8209B2D8;  }
		/* 8209B2D0h case   15:*/		return 0x8209B2D4;
		  /* 8209B2D4h */ case   16:  		/* li R3, 0 */
		/* 8209B2D4h case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209B2D4h case   16:*/		return 0x8209B2D8;
	}
	return 0x8209B2D8;
} // Block from 8209B294h-8209B2D8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8209B2D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B2D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B2D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B2D8);
		  /* 8209B2D8h */ case    0:  		/* bl 1909328 */
		/* 8209B2D8h case    0:*/		regs.LR = 0x8209B2DC; return 0x8226D528;
		/* 8209B2D8h case    0:*/		return 0x8209B2DC;
		  /* 8209B2DCh */ case    1:  		/* mr R3, R31 */
		/* 8209B2DCh case    1:*/		regs.R3 = regs.R31;
		/* 8209B2DCh case    1:*/		return 0x8209B2E0;
		  /* 8209B2E0h */ case    2:  		/* addi R1, R1, 96 */
		/* 8209B2E0h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209B2E0h case    2:*/		return 0x8209B2E4;
		  /* 8209B2E4h */ case    3:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209B2E4h case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209B2E4h case    3:*/		return 0x8209B2E8;
		  /* 8209B2E8h */ case    4:  		/* mtspr LR, R12 */
		/* 8209B2E8h case    4:*/		regs.LR = regs.R12;
		/* 8209B2E8h case    4:*/		return 0x8209B2EC;
		  /* 8209B2ECh */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 8209B2ECh case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209B2ECh case    5:*/		return 0x8209B2F0;
		  /* 8209B2F0h */ case    6:  		/* bclr 20, CR0_LT */
		/* 8209B2F0h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209B2F0h case    6:*/		return 0x8209B2F4;
	}
	return 0x8209B2F4;
} // Block from 8209B2D8h-8209B2F4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209B2F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B2F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B2F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B2F4);
		  /* 8209B2F4h */ case    0:  		/* nop */
		/* 8209B2F4h case    0:*/		cpu::op::nop();
		/* 8209B2F4h case    0:*/		return 0x8209B2F8;
	}
	return 0x8209B2F8;
} // Block from 8209B2F4h-8209B2F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209B2F8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B2F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B2F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B2F8);
		  /* 8209B2F8h */ case    0:  		/* mfspr R12, LR */
		/* 8209B2F8h case    0:*/		regs.R12 = regs.LR;
		/* 8209B2F8h case    0:*/		return 0x8209B2FC;
		  /* 8209B2FCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209B2FCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209B2FCh case    1:*/		return 0x8209B300;
		  /* 8209B300h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209B300h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209B300h case    2:*/		return 0x8209B304;
		  /* 8209B304h */ case    3:  		/* lis R4, -8 */
		/* 8209B304h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFFFF8);
		/* 8209B304h case    3:*/		return 0x8209B308;
		  /* 8209B308h */ case    4:  		/* li R3, 0 */
		/* 8209B308h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209B308h case    4:*/		return 0x8209B30C;
		  /* 8209B30Ch */ case    5:  		/* ori R4, R4, 1792 */
		/* 8209B30Ch case    5:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x700);
		/* 8209B30Ch case    5:*/		return 0x8209B310;
		  /* 8209B310h */ case    6:  		/* bl -9296 */
		/* 8209B310h case    6:*/		regs.LR = 0x8209B314; return 0x82098EC0;
		/* 8209B310h case    6:*/		return 0x8209B314;
		  /* 8209B314h */ case    7:  		/* bl -516 */
		/* 8209B314h case    7:*/		regs.LR = 0x8209B318; return 0x8209B110;
		/* 8209B314h case    7:*/		return 0x8209B318;
		  /* 8209B318h */ case    8:  		/* addi R1, R1, 96 */
		/* 8209B318h case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209B318h case    8:*/		return 0x8209B31C;
		  /* 8209B31Ch */ case    9:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209B31Ch case    9:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209B31Ch case    9:*/		return 0x8209B320;
		  /* 8209B320h */ case   10:  		/* mtspr LR, R12 */
		/* 8209B320h case   10:*/		regs.LR = regs.R12;
		/* 8209B320h case   10:*/		return 0x8209B324;
		  /* 8209B324h */ case   11:  		/* bclr 20, CR0_LT */
		/* 8209B324h case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209B324h case   11:*/		return 0x8209B328;
	}
	return 0x8209B328;
} // Block from 8209B2F8h-8209B328h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8209B328h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B328);
		  /* 8209B328h */ case    0:  		/* mfspr R12, LR */
		/* 8209B328h case    0:*/		regs.R12 = regs.LR;
		/* 8209B328h case    0:*/		return 0x8209B32C;
		  /* 8209B32Ch */ case    1:  		/* bl -41172 */
		/* 8209B32Ch case    1:*/		regs.LR = 0x8209B330; return 0x82091258;
		/* 8209B32Ch case    1:*/		return 0x8209B330;
		  /* 8209B330h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8209B330h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8209B330h case    2:*/		return 0x8209B334;
		  /* 8209B334h */ case    3:  		/* mr R28, R5 */
		/* 8209B334h case    3:*/		regs.R28 = regs.R5;
		/* 8209B334h case    3:*/		return 0x8209B338;
		  /* 8209B338h */ case    4:  		/* li R30, -4096 */
		/* 8209B338h case    4:*/		cpu::op::li<0>(regs,&regs.R30,0xFFFFF000);
		/* 8209B338h case    4:*/		return 0x8209B33C;
		  /* 8209B33Ch */ case    5:  		/* cmplwi CR6, R3, 0 */
		/* 8209B33Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209B33Ch case    5:*/		return 0x8209B340;
	}
	return 0x8209B340;
} // Block from 8209B328h-8209B340h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209B340h
// Function 'wctomb_s'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B340);
		  /* 8209B340h */ case    0:  		/* bc 12, CR6_EQ, 44 */
		/* 8209B340h case    0:*/		if ( regs.CR[6].eq ) { return 0x8209B36C;  }
		/* 8209B340h case    0:*/		return 0x8209B344;
		  /* 8209B344h */ case    1:  		/* divwu R11, R30, R3 */
		/* 8209B344h case    1:*/		cpu::op::divwu<0>(regs,&regs.R11,regs.R30,regs.R3);
		/* 8209B344h case    1:*/		return 0x8209B348;
	}
	return 0x8209B348;
} // Block from 8209B340h-8209B348h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209B348h
// Function '__get_sigabrt'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B348);
		  /* 8209B348h */ case    0:  		/* twi 6, R3, 0 */
		/* 8209B348h case    0:*/		cpu::op::tw<6>(regs, 0x8209B348, regs.R3, 0x00000000);
		/* 8209B348h case    0:*/		return 0x8209B34C;
		  /* 8209B34Ch */ case    1:  		/* cmplw CR6, R11, R4 */
		/* 8209B34Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 8209B34Ch case    1:*/		return 0x8209B350;
		  /* 8209B350h */ case    2:  		/* bc 4, CR6_LT, 28 */
		/* 8209B350h case    2:*/		if ( !regs.CR[6].lt ) { return 0x8209B36C;  }
		/* 8209B350h case    2:*/		return 0x8209B354;
		  /* 8209B354h */ case    3:  		/* bl -25676 */
		/* 8209B354h case    3:*/		regs.LR = 0x8209B358; return 0x82094F08;
		/* 8209B354h case    3:*/		return 0x8209B358;
		  /* 8209B358h */ case    4:  		/* mr R11, R3 */
		/* 8209B358h case    4:*/		regs.R11 = regs.R3;
		/* 8209B358h case    4:*/		return 0x8209B35C;
		  /* 8209B35Ch */ case    5:  		/* li R10, 12 */
		/* 8209B35Ch case    5:*/		cpu::op::li<0>(regs,&regs.R10,0xC);
		/* 8209B35Ch case    5:*/		return 0x8209B360;
	}
	return 0x8209B360;
} // Block from 8209B348h-8209B360h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209B360h
// Function 'raise'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B360);
		  /* 8209B360h */ case    0:  		/* li R3, 0 */
		/* 8209B360h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209B360h case    0:*/		return 0x8209B364;
		  /* 8209B364h */ case    1:  		/* stw R10, <#[R11]> */
		/* 8209B364h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209B364h case    1:*/		return 0x8209B368;
		  /* 8209B368h */ case    2:  		/* b 124 */
		/* 8209B368h case    2:*/		return 0x8209B3E4;
		/* 8209B368h case    2:*/		return 0x8209B36C;
	}
	return 0x8209B36C;
} // Block from 8209B360h-8209B36Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B36Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B36C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B36C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B36C);
		  /* 8209B36Ch */ case    0:  		/* mullw. R31, R3, R4 */
		/* 8209B36Ch case    0:*/		cpu::op::mullw<1>(regs,&regs.R31,regs.R3,regs.R4);
		/* 8209B36Ch case    0:*/		return 0x8209B370;
		  /* 8209B370h */ case    1:  		/* bc 4, CR0_EQ, 8 */
		/* 8209B370h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8209B378;  }
		/* 8209B370h case    1:*/		return 0x8209B374;
		  /* 8209B374h */ case    2:  		/* li R31, 1 */
		/* 8209B374h case    2:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 8209B374h case    2:*/		return 0x8209B378;
	}
	return 0x8209B378;
} // Block from 8209B36Ch-8209B378h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B378);
		  /* 8209B378h */ case    0:  		/* lis R29, -32215 */
		/* 8209B378h case    0:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8229);
		/* 8209B378h case    0:*/		return 0x8209B37C;
		  /* 8209B37Ch */ case    1:  		/* li R3, 0 */
		/* 8209B37Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209B37Ch case    1:*/		return 0x8209B380;
		  /* 8209B380h */ case    2:  		/* cmplw CR6, R31, R30 */
		/* 8209B380h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 8209B380h case    2:*/		return 0x8209B384;
		  /* 8209B384h */ case    3:  		/* bc 12, CR6_GT, 28 */
		/* 8209B384h case    3:*/		if ( regs.CR[6].gt ) { return 0x8209B3A0;  }
		/* 8209B384h case    3:*/		return 0x8209B388;
		  /* 8209B388h */ case    4:  		/* bl -54872 */
		/* 8209B388h case    4:*/		regs.LR = 0x8209B38C; return 0x8208DD30;
		/* 8209B388h case    4:*/		return 0x8209B38C;
		  /* 8209B38Ch */ case    5:  		/* li R4, 8 */
		/* 8209B38Ch case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 8209B38Ch case    5:*/		return 0x8209B390;
		  /* 8209B390h */ case    6:  		/* mr R5, R31 */
		/* 8209B390h case    6:*/		regs.R5 = regs.R31;
		/* 8209B390h case    6:*/		return 0x8209B394;
		  /* 8209B394h */ case    7:  		/* bl -60540 */
		/* 8209B394h case    7:*/		regs.LR = 0x8209B398; return 0x8208C718;
		/* 8209B394h case    7:*/		return 0x8209B398;
		  /* 8209B398h */ case    8:  		/* cmplwi CR0, R3, 0 */
		/* 8209B398h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8209B398h case    8:*/		return 0x8209B39C;
		  /* 8209B39Ch */ case    9:  		/* bc 4, CR0_EQ, 72 */
		/* 8209B39Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x8209B3E4;  }
		/* 8209B39Ch case    9:*/		return 0x8209B3A0;
	}
	return 0x8209B3A0;
} // Block from 8209B378h-8209B3A0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209B3A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B3A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B3A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B3A0);
		  /* 8209B3A0h */ case    0:  		/* lwz R11, <#[R29 - 30280]> */
		/* 8209B3A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0xFFFF89B8) );
		/* 8209B3A0h case    0:*/		return 0x8209B3A4;
		  /* 8209B3A4h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8209B3A4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8209B3A4h case    1:*/		return 0x8209B3A8;
		  /* 8209B3A8h */ case    2:  		/* bc 12, CR6_EQ, 44 */
		/* 8209B3A8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209B3D4;  }
		/* 8209B3A8h case    2:*/		return 0x8209B3AC;
		  /* 8209B3ACh */ case    3:  		/* mr R3, R31 */
		/* 8209B3ACh case    3:*/		regs.R3 = regs.R31;
		/* 8209B3ACh case    3:*/		return 0x8209B3B0;
		  /* 8209B3B0h */ case    4:  		/* bl -8304 */
		/* 8209B3B0h case    4:*/		regs.LR = 0x8209B3B4; return 0x82099340;
		/* 8209B3B0h case    4:*/		return 0x8209B3B4;
		  /* 8209B3B4h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 8209B3B4h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209B3B4h case    5:*/		return 0x8209B3B8;
		  /* 8209B3B8h */ case    6:  		/* bc 4, CR0_EQ, -60 */
		/* 8209B3B8h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8209B37C;  }
		/* 8209B3B8h case    6:*/		return 0x8209B3BC;
		  /* 8209B3BCh */ case    7:  		/* cmplwi CR6, R28, 0 */
		/* 8209B3BCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8209B3BCh case    7:*/		return 0x8209B3C0;
		  /* 8209B3C0h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 8209B3C0h case    8:*/		if ( regs.CR[6].eq ) { return 0x8209B3CC;  }
		/* 8209B3C0h case    8:*/		return 0x8209B3C4;
		  /* 8209B3C4h */ case    9:  		/* li R11, 12 */
		/* 8209B3C4h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0xC);
		/* 8209B3C4h case    9:*/		return 0x8209B3C8;
		  /* 8209B3C8h */ case   10:  		/* stw R11, <#[R28]> */
		/* 8209B3C8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8209B3C8h case   10:*/		return 0x8209B3CC;
	}
	return 0x8209B3CC;
} // Block from 8209B3A0h-8209B3CCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209B3CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B3CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B3CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B3CC);
		  /* 8209B3CCh */ case    0:  		/* li R3, 0 */
		/* 8209B3CCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209B3CCh case    0:*/		return 0x8209B3D0;
		  /* 8209B3D0h */ case    1:  		/* b 20 */
		/* 8209B3D0h case    1:*/		return 0x8209B3E4;
		/* 8209B3D0h case    1:*/		return 0x8209B3D4;
	}
	return 0x8209B3D4;
} // Block from 8209B3CCh-8209B3D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209B3D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B3D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B3D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B3D4);
		  /* 8209B3D4h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 8209B3D4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8209B3D4h case    0:*/		return 0x8209B3D8;
		  /* 8209B3D8h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8209B3D8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209B3E4;  }
		/* 8209B3D8h case    1:*/		return 0x8209B3DC;
		  /* 8209B3DCh */ case    2:  		/* li R11, 12 */
		/* 8209B3DCh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xC);
		/* 8209B3DCh case    2:*/		return 0x8209B3E0;
		  /* 8209B3E0h */ case    3:  		/* stw R11, <#[R28]> */
		/* 8209B3E0h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8209B3E0h case    3:*/		return 0x8209B3E4;
	}
	return 0x8209B3E4;
} // Block from 8209B3D4h-8209B3E4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209B3E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B3E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B3E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B3E4);
		  /* 8209B3E4h */ case    0:  		/* addi R1, R1, 128 */
		/* 8209B3E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8209B3E4h case    0:*/		return 0x8209B3E8;
		  /* 8209B3E8h */ case    1:  		/* b -41280 */
		/* 8209B3E8h case    1:*/		return 0x820912A8;
		/* 8209B3E8h case    1:*/		return 0x8209B3EC;
		  /* 8209B3ECh */ case    2:  		/* nop */
		/* 8209B3ECh case    2:*/		cpu::op::nop();
		/* 8209B3ECh case    2:*/		return 0x8209B3F0;
		  /* 8209B3F0h */ case    3:  		/* lwz R17, <#[R6 - 11576]> */
		/* 8209B3F0h case    3:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 8209B3F0h case    3:*/		return 0x8209B3F4;
		  /* 8209B3F4h */ case    4:  		/* lwz R16, <#[R4 - 15232]> */
		/* 8209B3F4h case    4:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC480) );
		/* 8209B3F4h case    4:*/		return 0x8209B3F8;
	}
	return 0x8209B3F8;
} // Block from 8209B3E4h-8209B3F8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209B3F8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B3F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B3F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B3F8);
		  /* 8209B3F8h */ case    0:  		/* mfspr R12, LR */
		/* 8209B3F8h case    0:*/		regs.R12 = regs.LR;
		/* 8209B3F8h case    0:*/		return 0x8209B3FC;
		  /* 8209B3FCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209B3FCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209B3FCh case    1:*/		return 0x8209B400;
		  /* 8209B400h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8209B400h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209B400h case    2:*/		return 0x8209B404;
		  /* 8209B404h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8209B404h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209B404h case    3:*/		return 0x8209B408;
		  /* 8209B408h */ case    4:  		/* addi R31, R1, -112 */
		/* 8209B408h case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFF90);
		/* 8209B408h case    4:*/		return 0x8209B40C;
		  /* 8209B40Ch */ case    5:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209B40Ch case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209B40Ch case    5:*/		return 0x8209B410;
		  /* 8209B410h */ case    6:  		/* mr R30, R3 */
		/* 8209B410h case    6:*/		regs.R30 = regs.R3;
		/* 8209B410h case    6:*/		return 0x8209B414;
		  /* 8209B414h */ case    7:  		/* li R3, 14 */
		/* 8209B414h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0xE);
		/* 8209B414h case    7:*/		return 0x8209B418;
		  /* 8209B418h */ case    8:  		/* bl -8640 */
		/* 8209B418h case    8:*/		regs.LR = 0x8209B41C; return 0x82099258;
		/* 8209B418h case    8:*/		return 0x8209B41C;
		  /* 8209B41Ch */ case    9:  		/* nop */
		/* 8209B41Ch case    9:*/		cpu::op::nop();
		/* 8209B41Ch case    9:*/		return 0x8209B420;
	}
	return 0x8209B420;
} // Block from 8209B3F8h-8209B420h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209B420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B420);
		  /* 8209B420h */ case    0:  		/* lwz R10, <#[R30 + 4]> */
		/* 8209B420h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 8209B420h case    0:*/		return 0x8209B424;
		  /* 8209B424h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 8209B424h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8209B424h case    1:*/		return 0x8209B428;
		  /* 8209B428h */ case    2:  		/* bc 12, CR6_EQ, 84 */
		/* 8209B428h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209B47C;  }
		/* 8209B428h case    2:*/		return 0x8209B42C;
		  /* 8209B42Ch */ case    3:  		/* lis R11, -32215 */
		/* 8209B42Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8209B42Ch case    3:*/		return 0x8209B430;
		  /* 8209B430h */ case    4:  		/* addi R9, R11, -30248 */
		/* 8209B430h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFF89D8);
		/* 8209B430h case    4:*/		return 0x8209B434;
		  /* 8209B434h */ case    5:  		/* mr R11, R9 */
		/* 8209B434h case    5:*/		regs.R11 = regs.R9;
		/* 8209B434h case    5:*/		return 0x8209B438;
		  /* 8209B438h */ case    6:  		/* lwz R3, <#[R9 + 4]> */
		/* 8209B438h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R9 + 0x00000004) );
		/* 8209B438h case    6:*/		return 0x8209B43C;
		  /* 8209B43Ch */ case    7:  		/* stw R3, <#[R31 + 80]> */
		/* 8209B43Ch case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 8209B43Ch case    7:*/		return 0x8209B440;
		  /* 8209B440h */ case    8:  		/* cmplwi CR6, R3, 0 */
		/* 8209B440h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209B440h case    8:*/		return 0x8209B444;
		  /* 8209B444h */ case    9:  		/* bc 12, CR6_EQ, 40 */
		/* 8209B444h case    9:*/		if ( regs.CR[6].eq ) { return 0x8209B46C;  }
		/* 8209B444h case    9:*/		return 0x8209B448;
		  /* 8209B448h */ case   10:  		/* lwz R9, <#[R3]> */
		/* 8209B448h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 8209B448h case   10:*/		return 0x8209B44C;
		  /* 8209B44Ch */ case   11:  		/* cmplw CR6, R9, R10 */
		/* 8209B44Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 8209B44Ch case   11:*/		return 0x8209B450;
		  /* 8209B450h */ case   12:  		/* bc 12, CR6_EQ, 16 */
		/* 8209B450h case   12:*/		if ( regs.CR[6].eq ) { return 0x8209B460;  }
		/* 8209B450h case   12:*/		return 0x8209B454;
		  /* 8209B454h */ case   13:  		/* mr R11, R3 */
		/* 8209B454h case   13:*/		regs.R11 = regs.R3;
		/* 8209B454h case   13:*/		return 0x8209B458;
		  /* 8209B458h */ case   14:  		/* nop */
		/* 8209B458h case   14:*/		cpu::op::nop();
		/* 8209B458h case   14:*/		return 0x8209B45C;
		  /* 8209B45Ch */ case   15:  		/* b -32 */
		/* 8209B45Ch case   15:*/		return 0x8209B43C;
		/* 8209B45Ch case   15:*/		return 0x8209B460;
	}
	return 0x8209B460;
} // Block from 8209B420h-8209B460h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8209B460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B460);
		  /* 8209B460h */ case    0:  		/* lwz R10, <#[R3 + 4]> */
		/* 8209B460h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 8209B460h case    0:*/		return 0x8209B464;
		  /* 8209B464h */ case    1:  		/* stw R10, <#[R11 + 4]> */
		/* 8209B464h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8209B464h case    1:*/		return 0x8209B468;
		  /* 8209B468h */ case    2:  		/* bl -31808 */
		/* 8209B468h case    2:*/		regs.LR = 0x8209B46C; return 0x82093828;
		/* 8209B468h case    2:*/		return 0x8209B46C;
	}
	return 0x8209B46C;
} // Block from 8209B460h-8209B46Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B46Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B46C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B46C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B46C);
		  /* 8209B46Ch */ case    0:  		/* lwz R3, <#[R30 + 4]> */
		/* 8209B46Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000004) );
		/* 8209B46Ch case    0:*/		return 0x8209B470;
		  /* 8209B470h */ case    1:  		/* bl -31816 */
		/* 8209B470h case    1:*/		regs.LR = 0x8209B474; return 0x82093828;
		/* 8209B470h case    1:*/		return 0x8209B474;
		  /* 8209B474h */ case    2:  		/* li R11, 0 */
		/* 8209B474h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209B474h case    2:*/		return 0x8209B478;
		  /* 8209B478h */ case    3:  		/* stw R11, <#[R30 + 4]> */
		/* 8209B478h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8209B478h case    3:*/		return 0x8209B47C;
	}
	return 0x8209B47C;
} // Block from 8209B46Ch-8209B47Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209B47Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B47C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B47C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B47C);
		  /* 8209B47Ch */ case    0:  		/* nop */
		/* 8209B47Ch case    0:*/		cpu::op::nop();
		/* 8209B47Ch case    0:*/		return 0x8209B480;
		  /* 8209B480h */ case    1:  		/* addi R12, R31, 112 */
		/* 8209B480h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R31,0x70);
		/* 8209B480h case    1:*/		return 0x8209B484;
		  /* 8209B484h */ case    2:  		/* bl 28 */
		/* 8209B484h case    2:*/		regs.LR = 0x8209B488; return 0x8209B4A0;
		/* 8209B484h case    2:*/		return 0x8209B488;
		  /* 8209B488h */ case    3:  		/* addi R1, R31, 112 */
		/* 8209B488h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0x70);
		/* 8209B488h case    3:*/		return 0x8209B48C;
		  /* 8209B48Ch */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209B48Ch case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209B48Ch case    4:*/		return 0x8209B490;
		  /* 8209B490h */ case    5:  		/* mtspr LR, R12 */
		/* 8209B490h case    5:*/		regs.LR = regs.R12;
		/* 8209B490h case    5:*/		return 0x8209B494;
		  /* 8209B494h */ case    6:  		/* ld R30, <#[R1 - 24]> */
		/* 8209B494h case    6:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209B494h case    6:*/		return 0x8209B498;
		  /* 8209B498h */ case    7:  		/* ld R31, <#[R1 - 16]> */
		/* 8209B498h case    7:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209B498h case    7:*/		return 0x8209B49C;
		  /* 8209B49Ch */ case    8:  		/* bclr 20, CR0_LT */
		/* 8209B49Ch case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209B49Ch case    8:*/		return 0x8209B4A0;
	}
	return 0x8209B4A0;
} // Block from 8209B47Ch-8209B4A0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209B4A0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B4A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B4A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B4A0);
		  /* 8209B4A0h */ case    0:  		/* mfspr R12, LR */
		/* 8209B4A0h case    0:*/		regs.R12 = regs.LR;
		/* 8209B4A0h case    0:*/		return 0x8209B4A4;
		  /* 8209B4A4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209B4A4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209B4A4h case    1:*/		return 0x8209B4A8;
		  /* 8209B4A8h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209B4A8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209B4A8h case    2:*/		return 0x8209B4AC;
		  /* 8209B4ACh */ case    3:  		/* li R3, 14 */
		/* 8209B4ACh case    3:*/		cpu::op::li<0>(regs,&regs.R3,0xE);
		/* 8209B4ACh case    3:*/		return 0x8209B4B0;
		  /* 8209B4B0h */ case    4:  		/* bl -9432 */
		/* 8209B4B0h case    4:*/		regs.LR = 0x8209B4B4; return 0x82098FD8;
		/* 8209B4B0h case    4:*/		return 0x8209B4B4;
		  /* 8209B4B4h */ case    5:  		/* lwz R1, <#[R1]> */
		/* 8209B4B4h case    5:*/		cpu::mem::load32z( regs, &regs.R1, (uint32)(regs.R1 + 0x00000000) );
		/* 8209B4B4h case    5:*/		return 0x8209B4B8;
		  /* 8209B4B8h */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209B4B8h case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209B4B8h case    6:*/		return 0x8209B4BC;
		  /* 8209B4BCh */ case    7:  		/* mtspr LR, R12 */
		/* 8209B4BCh case    7:*/		regs.LR = regs.R12;
		/* 8209B4BCh case    7:*/		return 0x8209B4C0;
		  /* 8209B4C0h */ case    8:  		/* bclr 20, CR0_LT */
		/* 8209B4C0h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209B4C0h case    8:*/		return 0x8209B4C4;
	}
	return 0x8209B4C4;
} // Block from 8209B4A0h-8209B4C4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209B4C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B4C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B4C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B4C4);
		  /* 8209B4C4h */ case    0:  		/* nop */
		/* 8209B4C4h case    0:*/		cpu::op::nop();
		/* 8209B4C4h case    0:*/		return 0x8209B4C8;
	}
	return 0x8209B4C8;
} // Block from 8209B4C4h-8209B4C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209B4C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B4C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B4C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B4C8);
		  /* 8209B4C8h */ case    0:  		/* lis R11, -32215 */
		/* 8209B4C8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8209B4C8h case    0:*/		return 0x8209B4CC;
		  /* 8209B4CCh */ case    1:  		/* lwz R10, <#[R11 - 25236]> */
		/* 8209B4CCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0xFFFF9D6C) );
		/* 8209B4CCh case    1:*/		return 0x8209B4D0;
		  /* 8209B4D0h */ case    2:  		/* cmpwi CR6, R10, 0 */
		/* 8209B4D0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8209B4D0h case    2:*/		return 0x8209B4D4;
		  /* 8209B4D4h */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 8209B4D4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8209B4EC;  }
		/* 8209B4D4h case    3:*/		return 0x8209B4D8;
		  /* 8209B4D8h */ case    4:  		/* lis R8, -32215 */
		/* 8209B4D8h case    4:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8229);
		/* 8209B4D8h case    4:*/		return 0x8209B4DC;
		  /* 8209B4DCh */ case    5:  		/* li R10, -3 */
		/* 8209B4DCh case    5:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFD);
		/* 8209B4DCh case    5:*/		return 0x8209B4E0;
		  /* 8209B4E0h */ case    6:  		/* li R9, 1 */
		/* 8209B4E0h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8209B4E0h case    6:*/		return 0x8209B4E4;
		  /* 8209B4E4h */ case    7:  		/* stw R9, <#[R11 - 25236]> */
		/* 8209B4E4h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0xFFFF9D6C) );
		/* 8209B4E4h case    7:*/		return 0x8209B4E8;
		  /* 8209B4E8h */ case    8:  		/* stw R10, <#[R8 - 30224]> */
		/* 8209B4E8h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0xFFFF89F0) );
		/* 8209B4E8h case    8:*/		return 0x8209B4EC;
	}
	return 0x8209B4EC;
} // Block from 8209B4C8h-8209B4ECh (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209B4ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B4EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B4EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B4EC);
		  /* 8209B4ECh */ case    0:  		/* li R3, 0 */
		/* 8209B4ECh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209B4ECh case    0:*/		return 0x8209B4F0;
		  /* 8209B4F0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8209B4F0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209B4F0h case    1:*/		return 0x8209B4F4;
	}
	return 0x8209B4F4;
} // Block from 8209B4ECh-8209B4F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209B4F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B4F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B4F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B4F4);
		  /* 8209B4F4h */ case    0:  		/* nop */
		/* 8209B4F4h case    0:*/		cpu::op::nop();
		/* 8209B4F4h case    0:*/		return 0x8209B4F8;
	}
	return 0x8209B4F8;
} // Block from 8209B4F4h-8209B4F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209B4F8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B4F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B4F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B4F8);
		  /* 8209B4F8h */ case    0:  		/* mfspr R12, LR */
		/* 8209B4F8h case    0:*/		regs.R12 = regs.LR;
		/* 8209B4F8h case    0:*/		return 0x8209B4FC;
		  /* 8209B4FCh */ case    1:  		/* bl -41672 */
		/* 8209B4FCh case    1:*/		regs.LR = 0x8209B500; return 0x82091234;
		/* 8209B4FCh case    1:*/		return 0x8209B500;
		  /* 8209B500h */ case    2:  		/* lhz R9, <#[R3]> */
		/* 8209B500h case    2:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 8209B500h case    2:*/		return 0x8209B504;
		  /* 8209B504h */ case    3:  		/* lis R10, -32217 */
		/* 8209B504h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 8209B504h case    3:*/		return 0x8209B508;
		  /* 8209B508h */ case    4:  		/* lhz R8, <#[R3 + 10]> */
		/* 8209B508h case    4:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R3 + 0x0000000A) );
		/* 8209B508h case    4:*/		return 0x8209B50C;
		  /* 8209B50Ch */ case    5:  		/* li R23, 0 */
		/* 8209B50Ch case    5:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 8209B50Ch case    5:*/		return 0x8209B510;
		  /* 8209B510h */ case    6:  		/* rlwinm R11, R9, 0, 17, 31 */
		/* 8209B510h case    6:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R11,regs.R9);
		/* 8209B510h case    6:*/		return 0x8209B514;
		  /* 8209B514h */ case    7:  		/* lwz R7, <#[R3 + 2]> */
		/* 8209B514h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000002) );
		/* 8209B514h case    7:*/		return 0x8209B518;
		  /* 8209B518h */ case    8:  		/* lwz R6, <#[R3 + 6]> */
		/* 8209B518h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000006) );
		/* 8209B518h case    8:*/		return 0x8209B51C;
		  /* 8209B51Ch */ case    9:  		/* addi R20, R10, 10220 */
		/* 8209B51Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R10,0x27EC);
		/* 8209B51Ch case    9:*/		return 0x8209B520;
		  /* 8209B520h */ case   10:  		/* addi R30, R11, -16383 */
		/* 8209B520h case   10:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFC001);
		/* 8209B520h case   10:*/		return 0x8209B524;
		  /* 8209B524h */ case   11:  		/* rlwinm R11, R8, 16, 0, 31 */
		/* 8209B524h case   11:*/		cpu::op::rlwinm<0,16,0,31>(regs,&regs.R11,regs.R8);
		/* 8209B524h case   11:*/		return 0x8209B528;
		  /* 8209B528h */ case   12:  		/* rlwinm R19, R9, 0, 0, 16 */
		/* 8209B528h case   12:*/		cpu::op::rlwinm<0,0,0,16>(regs,&regs.R19,regs.R9);
		/* 8209B528h case   12:*/		return 0x8209B52C;
		  /* 8209B52Ch */ case   13:  		/* stw R7, <#[R1 - 152]> */
		/* 8209B52Ch case   13:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0xFFFFFF68) );
		/* 8209B52Ch case   13:*/		return 0x8209B530;
		  /* 8209B530h */ case   14:  		/* cmpwi CR6, R30, -16383 */
		/* 8209B530h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R30,0xFFFFC001);
		/* 8209B530h case   14:*/		return 0x8209B534;
		  /* 8209B534h */ case   15:  		/* lwz R21, <#[R20 + 12]> */
		/* 8209B534h case   15:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R20 + 0x0000000C) );
		/* 8209B534h case   15:*/		return 0x8209B538;
		  /* 8209B538h */ case   16:  		/* addi R10, R1, -152 */
		/* 8209B538h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFF68);
		/* 8209B538h case   16:*/		return 0x8209B53C;
		  /* 8209B53Ch */ case   17:  		/* stw R6, <#[R1 - 148]> */
		/* 8209B53Ch case   17:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0xFFFFFF6C) );
		/* 8209B53Ch case   17:*/		return 0x8209B540;
		  /* 8209B540h */ case   18:  		/* mr R5, R23 */
		/* 8209B540h case   18:*/		regs.R5 = regs.R23;
		/* 8209B540h case   18:*/		return 0x8209B544;
		  /* 8209B544h */ case   19:  		/* stw R11, <#[R1 - 144]> */
		/* 8209B544h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFF70) );
		/* 8209B544h case   19:*/		return 0x8209B548;
		  /* 8209B548h */ case   20:  		/* bc 4, CR6_EQ, 64 */
		/* 8209B548h case   20:*/		if ( !regs.CR[6].eq ) { return 0x8209B588;  }
		/* 8209B548h case   20:*/		return 0x8209B54C;
		  /* 8209B54Ch */ case   21:  		/* mr R11, R23 */
		/* 8209B54Ch case   21:*/		regs.R11 = regs.R23;
		/* 8209B54Ch case   21:*/		return 0x8209B550;
		  /* 8209B550h */ case   22:  		/* lwz R9, <#[R10]> */
		/* 8209B550h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8209B550h case   22:*/		return 0x8209B554;
		  /* 8209B554h */ case   23:  		/* cmplwi CR6, R9, 0 */
		/* 8209B554h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8209B554h case   23:*/		return 0x8209B558;
		  /* 8209B558h */ case   24:  		/* bc 4, CR6_EQ, 24 */
		/* 8209B558h case   24:*/		if ( !regs.CR[6].eq ) { return 0x8209B570;  }
		/* 8209B558h case   24:*/		return 0x8209B55C;
		  /* 8209B55Ch */ case   25:  		/* addi R11, R11, 1 */
		/* 8209B55Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209B55Ch case   25:*/		return 0x8209B560;
		  /* 8209B560h */ case   26:  		/* addi R10, R10, 4 */
		/* 8209B560h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8209B560h case   26:*/		return 0x8209B564;
		  /* 8209B564h */ case   27:  		/* cmpwi CR6, R11, 3 */
		/* 8209B564h case   27:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8209B564h case   27:*/		return 0x8209B568;
		  /* 8209B568h */ case   28:  		/* bc 12, CR6_LT, -24 */
		/* 8209B568h case   28:*/		if ( regs.CR[6].lt ) { return 0x8209B550;  }
		/* 8209B568h case   28:*/		return 0x8209B56C;
		  /* 8209B56Ch */ case   29:  		/* b 1616 */
		/* 8209B56Ch case   29:*/		return 0x8209BBBC;
		/* 8209B56Ch case   29:*/		return 0x8209B570;
	}
	return 0x8209B570;
} // Block from 8209B4F8h-8209B570h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8209B570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B570);
		  /* 8209B570h */ case    0:  		/* addi R11, R1, -152 */
		/* 8209B570h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xFFFFFF68);
		/* 8209B570h case    0:*/		return 0x8209B574;
		  /* 8209B574h */ case    1:  		/* li R3, 2 */
		/* 8209B574h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 8209B574h case    1:*/		return 0x8209B578;
		  /* 8209B578h */ case    2:  		/* stw R23, <#[R11]> */
		/* 8209B578h case    2:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 8209B578h case    2:*/		return 0x8209B57C;
		  /* 8209B57Ch */ case    3:  		/* stw R23, <#[R11 + 4]> */
		/* 8209B57Ch case    3:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000004) );
		/* 8209B57Ch case    3:*/		return 0x8209B580;
		  /* 8209B580h */ case    4:  		/* stw R23, <#[R11 + 8]> */
		/* 8209B580h case    4:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000008) );
		/* 8209B580h case    4:*/		return 0x8209B584;
		  /* 8209B584h */ case    5:  		/* b 1596 */
		/* 8209B584h case    5:*/		return 0x8209BBC0;
		/* 8209B584h case    5:*/		return 0x8209B588;
	}
	return 0x8209B588;
} // Block from 8209B570h-8209B588h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209B588h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B588( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B588) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B588);
		  /* 8209B588h */ case    0:  		/* lwz R25, <#[R20 + 8]> */
		/* 8209B588h case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R20 + 0x00000008) );
		/* 8209B588h case    0:*/		return 0x8209B58C;
		  /* 8209B58Ch */ case    1:  		/* addi R8, R1, -136 */
		/* 8209B58Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xFFFFFF78);
		/* 8209B58Ch case    1:*/		return 0x8209B590;
		  /* 8209B590h */ case    2:  		/* lwz R9, <#[R10]> */
		/* 8209B590h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8209B590h case    2:*/		return 0x8209B594;
		  /* 8209B594h */ case    3:  		/* addi R28, R1, -152 */
		/* 8209B594h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0xFFFFFF68);
		/* 8209B594h case    3:*/		return 0x8209B598;
		  /* 8209B598h */ case    4:  		/* addi R26, R25, -1 */
		/* 8209B598h case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R25,0xFFFFFFFF);
		/* 8209B598h case    4:*/		return 0x8209B59C;
		  /* 8209B59Ch */ case    5:  		/* lwz R6, <#[R10 + 4]> */
		/* 8209B59Ch case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 8209B59Ch case    5:*/		return 0x8209B5A0;
		  /* 8209B5A0h */ case    6:  		/* lwz R10, <#[R10 + 8]> */
		/* 8209B5A0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8209B5A0h case    6:*/		return 0x8209B5A4;
		  /* 8209B5A4h */ case    7:  		/* li R3, 1 */
		/* 8209B5A4h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8209B5A4h case    7:*/		return 0x8209B5A8;
		  /* 8209B5A8h */ case    8:  		/* addi R11, R26, 1 */
		/* 8209B5A8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x1);
		/* 8209B5A8h case    8:*/		return 0x8209B5AC;
		  /* 8209B5ACh */ case    9:  		/* li R22, -1 */
		/* 8209B5ACh case    9:*/		cpu::op::li<0>(regs,&regs.R22,0xFFFFFFFF);
		/* 8209B5ACh case    9:*/		return 0x8209B5B0;
		  /* 8209B5B0h */ case   10:  		/* srawi R7, R11, 5 */
		/* 8209B5B0h case   10:*/		cpu::op::srawi<0,5>(regs,&regs.R7,regs.R11);
		/* 8209B5B0h case   10:*/		return 0x8209B5B4;
		  /* 8209B5B4h */ case   11:  		/* stw R9, <#[R8]> */
		/* 8209B5B4h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 8209B5B4h case   11:*/		return 0x8209B5B8;
		  /* 8209B5B8h */ case   12:  		/* stw R6, <#[R8 + 4]> */
		/* 8209B5B8h case   12:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R8 + 0x00000004) );
		/* 8209B5B8h case   12:*/		return 0x8209B5BC;
		  /* 8209B5BCh */ case   13:  		/* mr R24, R30 */
		/* 8209B5BCh case   13:*/		regs.R24 = regs.R30;
		/* 8209B5BCh case   13:*/		return 0x8209B5C0;
		  /* 8209B5C0h */ case   14:  		/* addze R31, R7 */
		/* 8209B5C0h case   14:*/		cpu::op::addze<0>(regs,&regs.R31,regs.R7);
		/* 8209B5C0h case   14:*/		return 0x8209B5C4;
		  /* 8209B5C4h */ case   15:  		/* stw R10, <#[R8 + 8]> */
		/* 8209B5C4h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000008) );
		/* 8209B5C4h case   15:*/		return 0x8209B5C8;
		  /* 8209B5C8h */ case   16:  		/* srawi R7, R11, 5 */
		/* 8209B5C8h case   16:*/		cpu::op::srawi<0,5>(regs,&regs.R7,regs.R11);
		/* 8209B5C8h case   16:*/		return 0x8209B5CC;
		  /* 8209B5CCh */ case   17:  		/* rlwinm R27, R31, 2, 0, 29 */
		/* 8209B5CCh case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R31);
		/* 8209B5CCh case   17:*/		return 0x8209B5D0;
		  /* 8209B5D0h */ case   18:  		/* addze R9, R7 */
		/* 8209B5D0h case   18:*/		cpu::op::addze<0>(regs,&regs.R9,regs.R7);
		/* 8209B5D0h case   18:*/		return 0x8209B5D4;
		  /* 8209B5D4h */ case   19:  		/* rlwinm R10, R9, 5, 0, 26 */
		/* 8209B5D4h case   19:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R9);
		/* 8209B5D4h case   19:*/		return 0x8209B5D8;
		  /* 8209B5D8h */ case   20:  		/* subf R11, R10, R11 */
		/* 8209B5D8h case   20:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8209B5D8h case   20:*/		return 0x8209B5DC;
		  /* 8209B5DCh */ case   21:  		/* lwzx R10, <#[R27 + R28]> */
		/* 8209B5DCh case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + regs.R28 + 0x00000000) );
		/* 8209B5DCh case   21:*/		return 0x8209B5E0;
		  /* 8209B5E0h */ case   22:  		/* subfic R29, R11, 31 */
		/* 8209B5E0h case   22:*/		cpu::op::subfic<0>(regs,&regs.R29,regs.R11,0x1F);
		/* 8209B5E0h case   22:*/		return 0x8209B5E4;
		  /* 8209B5E4h */ case   23:  		/* slw R11, R3, R29 */
		/* 8209B5E4h case   23:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R3,regs.R29);
		/* 8209B5E4h case   23:*/		return 0x8209B5E8;
		  /* 8209B5E8h */ case   24:  		/* and. R11, R11, R10 */
		/* 8209B5E8h case   24:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8209B5E8h case   24:*/		return 0x8209B5EC;
		  /* 8209B5ECh */ case   25:  		/* bc 12, CR0_EQ, 232 */
		/* 8209B5ECh case   25:*/		if ( regs.CR[0].eq ) { return 0x8209B6D4;  }
		/* 8209B5ECh case   25:*/		return 0x8209B5F0;
		  /* 8209B5F0h */ case   26:  		/* rlwinm R11, R31, 2, 0, 29 */
		/* 8209B5F0h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R31);
		/* 8209B5F0h case   26:*/		return 0x8209B5F4;
		  /* 8209B5F4h */ case   27:  		/* addi R10, R1, -152 */
		/* 8209B5F4h case   27:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFF68);
		/* 8209B5F4h case   27:*/		return 0x8209B5F8;
		  /* 8209B5F8h */ case   28:  		/* slw R9, R22, R29 */
		/* 8209B5F8h case   28:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R22,regs.R29);
		/* 8209B5F8h case   28:*/		return 0x8209B5FC;
		  /* 8209B5FCh */ case   29:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8209B5FCh case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8209B5FCh case   29:*/		return 0x8209B600;
		  /* 8209B600h */ case   30:  		/* andc. R11, R11, R9 */
		/* 8209B600h case   30:*/		cpu::op::andc<1>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8209B600h case   30:*/		return 0x8209B604;
		  /* 8209B604h */ case   31:  		/* bc 4, CR0_EQ, 60 */
		/* 8209B604h case   31:*/		if ( !regs.CR[0].eq ) { return 0x8209B640;  }
		/* 8209B604h case   31:*/		return 0x8209B608;
		  /* 8209B608h */ case   32:  		/* addi R11, R31, 1 */
		/* 8209B608h case   32:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x1);
		/* 8209B608h case   32:*/		return 0x8209B60C;
		  /* 8209B60Ch */ case   33:  		/* cmpwi CR6, R11, 3 */
		/* 8209B60Ch case   33:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8209B60Ch case   33:*/		return 0x8209B610;
		  /* 8209B610h */ case   34:  		/* bc 4, CR6_LT, 196 */
		/* 8209B610h case   34:*/		if ( !regs.CR[6].lt ) { return 0x8209B6D4;  }
		/* 8209B610h case   34:*/		return 0x8209B614;
		  /* 8209B614h */ case   35:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8209B614h case   35:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8209B614h case   35:*/		return 0x8209B618;
		  /* 8209B618h */ case   36:  		/* addi R10, R1, -152 */
		/* 8209B618h case   36:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFF68);
		/* 8209B618h case   36:*/		return 0x8209B61C;
		  /* 8209B61Ch */ case   37:  		/* add R10, R9, R10 */
		/* 8209B61Ch case   37:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8209B61Ch case   37:*/		return 0x8209B620;
		  /* 8209B620h */ case   38:  		/* lwz R9, <#[R10]> */
		/* 8209B620h case   38:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8209B620h case   38:*/		return 0x8209B624;
		  /* 8209B624h */ case   39:  		/* cmplwi CR6, R9, 0 */
		/* 8209B624h case   39:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8209B624h case   39:*/		return 0x8209B628;
		  /* 8209B628h */ case   40:  		/* bc 4, CR6_EQ, 24 */
		/* 8209B628h case   40:*/		if ( !regs.CR[6].eq ) { return 0x8209B640;  }
		/* 8209B628h case   40:*/		return 0x8209B62C;
		  /* 8209B62Ch */ case   41:  		/* addi R11, R11, 1 */
		/* 8209B62Ch case   41:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209B62Ch case   41:*/		return 0x8209B630;
		  /* 8209B630h */ case   42:  		/* addi R10, R10, 4 */
		/* 8209B630h case   42:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8209B630h case   42:*/		return 0x8209B634;
		  /* 8209B634h */ case   43:  		/* cmpwi CR6, R11, 3 */
		/* 8209B634h case   43:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8209B634h case   43:*/		return 0x8209B638;
		  /* 8209B638h */ case   44:  		/* bc 12, CR6_LT, -24 */
		/* 8209B638h case   44:*/		if ( regs.CR[6].lt ) { return 0x8209B620;  }
		/* 8209B638h case   44:*/		return 0x8209B63C;
		  /* 8209B63Ch */ case   45:  		/* b 152 */
		/* 8209B63Ch case   45:*/		return 0x8209B6D4;
		/* 8209B63Ch case   45:*/		return 0x8209B640;
	}
	return 0x8209B640;
} // Block from 8209B588h-8209B640h (46 instructions)

//////////////////////////////////////////////////////
// Block at 8209B640h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B640);
		  /* 8209B640h */ case    0:  		/* srawi R11, R26, 5 */
		/* 8209B640h case    0:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R26);
		/* 8209B640h case    0:*/		return 0x8209B644;
		  /* 8209B644h */ case    1:  		/* addi R8, R1, -152 */
		/* 8209B644h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xFFFFFF68);
		/* 8209B644h case    1:*/		return 0x8209B648;
	}
	return 0x8209B648;
} // Block from 8209B640h-8209B648h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209B648h
// Function 'FPSCRToAbstract'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B648);
		  /* 8209B648h */ case    0:  		/* addze R9, R11 */
		/* 8209B648h case    0:*/		cpu::op::addze<0>(regs,&regs.R9,regs.R11);
		/* 8209B648h case    0:*/		return 0x8209B64C;
		  /* 8209B64Ch */ case    1:  		/* srawi R11, R26, 5 */
		/* 8209B64Ch case    1:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R26);
		/* 8209B64Ch case    1:*/		return 0x8209B650;
		  /* 8209B650h */ case    2:  		/* rlwinm R7, R9, 2, 0, 29 */
		/* 8209B650h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R9);
		/* 8209B650h case    2:*/		return 0x8209B654;
		  /* 8209B654h */ case    3:  		/* addze R11, R11 */
		/* 8209B654h case    3:*/		cpu::op::addze<0>(regs,&regs.R11,regs.R11);
		/* 8209B654h case    3:*/		return 0x8209B658;
		  /* 8209B658h */ case    4:  		/* mr R5, R23 */
		/* 8209B658h case    4:*/		regs.R5 = regs.R23;
		/* 8209B658h case    4:*/		return 0x8209B65C;
		  /* 8209B65Ch */ case    5:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 8209B65Ch case    5:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 8209B65Ch case    5:*/		return 0x8209B660;
		  /* 8209B660h */ case    6:  		/* subf R10, R11, R26 */
		/* 8209B660h case    6:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R26);
		/* 8209B660h case    6:*/		return 0x8209B664;
		  /* 8209B664h */ case    7:  		/* lwzx R11, <#[R7 + R8]> */
		/* 8209B664h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 8209B664h case    7:*/		return 0x8209B668;
		  /* 8209B668h */ case    8:  		/* subfic R10, R10, 31 */
		/* 8209B668h case    8:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0x1F);
		/* 8209B668h case    8:*/		return 0x8209B66C;
		  /* 8209B66Ch */ case    9:  		/* slw R6, R3, R10 */
		/* 8209B66Ch case    9:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R3,regs.R10);
		/* 8209B66Ch case    9:*/		return 0x8209B670;
		  /* 8209B670h */ case   10:  		/* add R10, R11, R6 */
		/* 8209B670h case   10:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R6);
		/* 8209B670h case   10:*/		return 0x8209B674;
		  /* 8209B674h */ case   11:  		/* cmplw CR6, R10, R11 */
		/* 8209B674h case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8209B674h case   11:*/		return 0x8209B678;
		  /* 8209B678h */ case   12:  		/* bc 12, CR6_LT, 12 */
		/* 8209B678h case   12:*/		if ( regs.CR[6].lt ) { return 0x8209B684;  }
		/* 8209B678h case   12:*/		return 0x8209B67C;
		  /* 8209B67Ch */ case   13:  		/* cmplw CR6, R10, R6 */
		/* 8209B67Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 8209B67Ch case   13:*/		return 0x8209B680;
		  /* 8209B680h */ case   14:  		/* bc 4, CR6_LT, 8 */
		/* 8209B680h case   14:*/		if ( !regs.CR[6].lt ) { return 0x8209B688;  }
		/* 8209B680h case   14:*/		return 0x8209B684;
	}
	return 0x8209B684;
} // Block from 8209B648h-8209B684h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8209B684h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B684( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B684) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B684);
		  /* 8209B684h */ case    0:  		/* mr R5, R3 */
		/* 8209B684h case    0:*/		regs.R5 = regs.R3;
		/* 8209B684h case    0:*/		return 0x8209B688;
	}
	return 0x8209B688;
} // Block from 8209B684h-8209B688h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209B688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B688);
		  /* 8209B688h */ case    0:  		/* addic. R11, R9, -1 */
		/* 8209B688h case    0:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 8209B688h case    0:*/		return 0x8209B68C;
		  /* 8209B68Ch */ case    1:  		/* stwx R10, <#[R7 + R8]> */
		/* 8209B68Ch case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 8209B68Ch case    1:*/		return 0x8209B690;
		  /* 8209B690h */ case    2:  		/* bc 12, CR0_LT, 68 */
		/* 8209B690h case    2:*/		if ( regs.CR[0].lt ) { return 0x8209B6D4;  }
		/* 8209B690h case    2:*/		return 0x8209B694;
		  /* 8209B694h */ case    3:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8209B694h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8209B694h case    3:*/		return 0x8209B698;
		  /* 8209B698h */ case    4:  		/* addi R10, R1, -148 */
		/* 8209B698h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFF6C);
		/* 8209B698h case    4:*/		return 0x8209B69C;
		  /* 8209B69Ch */ case    5:  		/* add R10, R9, R10 */
		/* 8209B69Ch case    5:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8209B69Ch case    5:*/		return 0x8209B6A0;
		  /* 8209B6A0h */ case    6:  		/* cmpwi CR6, R5, 0 */
		/* 8209B6A0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 8209B6A0h case    6:*/		return 0x8209B6A4;
		  /* 8209B6A4h */ case    7:  		/* bc 12, CR6_EQ, 48 */
		/* 8209B6A4h case    7:*/		if ( regs.CR[6].eq ) { return 0x8209B6D4;  }
		/* 8209B6A4h case    7:*/		return 0x8209B6A8;
		  /* 8209B6A8h */ case    8:  		/* lwz R9, <#[R10 - 4]> */
		/* 8209B6A8h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 8209B6A8h case    8:*/		return 0x8209B6AC;
		  /* 8209B6ACh */ case    9:  		/* mr R5, R23 */
		/* 8209B6ACh case    9:*/		regs.R5 = regs.R23;
		/* 8209B6ACh case    9:*/		return 0x8209B6B0;
		  /* 8209B6B0h */ case   10:  		/* addi R8, R9, 1 */
		/* 8209B6B0h case   10:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0x1);
		/* 8209B6B0h case   10:*/		return 0x8209B6B4;
		  /* 8209B6B4h */ case   11:  		/* cmplw CR6, R8, R9 */
		/* 8209B6B4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8209B6B4h case   11:*/		return 0x8209B6B8;
		  /* 8209B6B8h */ case   12:  		/* bc 12, CR6_LT, 12 */
		/* 8209B6B8h case   12:*/		if ( regs.CR[6].lt ) { return 0x8209B6C4;  }
		/* 8209B6B8h case   12:*/		return 0x8209B6BC;
		  /* 8209B6BCh */ case   13:  		/* cmplwi CR6, R8, 1 */
		/* 8209B6BCh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000001);
		/* 8209B6BCh case   13:*/		return 0x8209B6C0;
		  /* 8209B6C0h */ case   14:  		/* bc 4, CR6_LT, 8 */
		/* 8209B6C0h case   14:*/		if ( !regs.CR[6].lt ) { return 0x8209B6C8;  }
		/* 8209B6C0h case   14:*/		return 0x8209B6C4;
	}
	return 0x8209B6C4;
} // Block from 8209B688h-8209B6C4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8209B6C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B6C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B6C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B6C4);
		  /* 8209B6C4h */ case    0:  		/* mr R5, R3 */
		/* 8209B6C4h case    0:*/		regs.R5 = regs.R3;
		/* 8209B6C4h case    0:*/		return 0x8209B6C8;
	}
	return 0x8209B6C8;
} // Block from 8209B6C4h-8209B6C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209B6C8h
// Function '_controlfp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B6C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B6C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B6C8);
		  /* 8209B6C8h */ case    0:  		/* addic. R11, R11, -1 */
		/* 8209B6C8h case    0:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8209B6C8h case    0:*/		return 0x8209B6CC;
		  /* 8209B6CCh */ case    1:  		/* stwu R8, <#[R10 - 4]> */
		/* 8209B6CCh case    1:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0xFFFFFFFC) );
		regs.R10 = (uint32)(regs.R10 + 0xFFFFFFFC);
		/* 8209B6CCh case    1:*/		return 0x8209B6D0;
		  /* 8209B6D0h */ case    2:  		/* bc 4, CR0_LT, -48 */
		/* 8209B6D0h case    2:*/		if ( !regs.CR[0].lt ) { return 0x8209B6A0;  }
		/* 8209B6D0h case    2:*/		return 0x8209B6D4;
	}
	return 0x8209B6D4;
} // Block from 8209B6C8h-8209B6D4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B6D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B6D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B6D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B6D4);
		  /* 8209B6D4h */ case    0:  		/* lwzx R10, <#[R27 + R28]> */
		/* 8209B6D4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + regs.R28 + 0x00000000) );
		/* 8209B6D4h case    0:*/		return 0x8209B6D8;
		  /* 8209B6D8h */ case    1:  		/* slw R9, R22, R29 */
		/* 8209B6D8h case    1:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R22,regs.R29);
		/* 8209B6D8h case    1:*/		return 0x8209B6DC;
		  /* 8209B6DCh */ case    2:  		/* addi R11, R31, 1 */
		/* 8209B6DCh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x1);
		/* 8209B6DCh case    2:*/		return 0x8209B6E0;
		  /* 8209B6E0h */ case    3:  		/* and R10, R9, R10 */
		/* 8209B6E0h case    3:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8209B6E0h case    3:*/		return 0x8209B6E4;
		  /* 8209B6E4h */ case    4:  		/* cmpwi CR6, R11, 3 */
		/* 8209B6E4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8209B6E4h case    4:*/		return 0x8209B6E8;
		  /* 8209B6E8h */ case    5:  		/* stwx R10, <#[R27 + R28]> */
		/* 8209B6E8h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R27 + regs.R28 + 0x00000000) );
		/* 8209B6E8h case    5:*/		return 0x8209B6EC;
		  /* 8209B6ECh */ case    6:  		/* bc 4, CR6_LT, 48 */
		/* 8209B6ECh case    6:*/		if ( !regs.CR[6].lt ) { return 0x8209B71C;  }
		/* 8209B6ECh case    6:*/		return 0x8209B6F0;
		  /* 8209B6F0h */ case    7:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8209B6F0h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8209B6F0h case    7:*/		return 0x8209B6F4;
		  /* 8209B6F4h */ case    8:  		/* addi R10, R1, -152 */
		/* 8209B6F4h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFF68);
		/* 8209B6F4h case    8:*/		return 0x8209B6F8;
		  /* 8209B6F8h */ case    9:  		/* subfic R11, R11, 3 */
		/* 8209B6F8h case    9:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x3);
		/* 8209B6F8h case    9:*/		return 0x8209B6FC;
		  /* 8209B6FCh */ case   10:  		/* add R10, R9, R10 */
		/* 8209B6FCh case   10:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8209B6FCh case   10:*/		return 0x8209B700;
		  /* 8209B700h */ case   11:  		/* mr R9, R23 */
		/* 8209B700h case   11:*/		regs.R9 = regs.R23;
		/* 8209B700h case   11:*/		return 0x8209B704;
		  /* 8209B704h */ case   12:  		/* addi R10, R10, -4 */
		/* 8209B704h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 8209B704h case   12:*/		return 0x8209B708;
		  /* 8209B708h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 8209B708h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209B708h case   13:*/		return 0x8209B70C;
		  /* 8209B70Ch */ case   14:  		/* bc 12, CR6_EQ, 16 */
		/* 8209B70Ch case   14:*/		if ( regs.CR[6].eq ) { return 0x8209B71C;  }
		/* 8209B70Ch case   14:*/		return 0x8209B710;
		  /* 8209B710h */ case   15:  		/* mtspr CTR, R11 */
		/* 8209B710h case   15:*/		regs.CTR = regs.R11;
		/* 8209B710h case   15:*/		return 0x8209B714;
		  /* 8209B714h */ case   16:  		/* stwu R9, <#[R10 + 4]> */
		/* 8209B714h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8209B714h case   16:*/		return 0x8209B718;
		  /* 8209B718h */ case   17:  		/* bc 16, CR0_LT, -4 */
		/* 8209B718h case   17:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209B714;  }
		/* 8209B718h case   17:*/		return 0x8209B71C;
	}
	return 0x8209B71C;
} // Block from 8209B6D4h-8209B71Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 8209B71Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B71C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B71C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B71C);
		  /* 8209B71Ch */ case    0:  		/* cmpwi CR6, R5, 0 */
		/* 8209B71Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 8209B71Ch case    0:*/		return 0x8209B720;
		  /* 8209B720h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 8209B720h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209B728;  }
		/* 8209B720h case    1:*/		return 0x8209B724;
		  /* 8209B724h */ case    2:  		/* addi R30, R30, 1 */
		/* 8209B724h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8209B724h case    2:*/		return 0x8209B728;
	}
	return 0x8209B728;
} // Block from 8209B71Ch-8209B728h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B728h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B728);
		  /* 8209B728h */ case    0:  		/* lwz R11, <#[R20 + 4]> */
		/* 8209B728h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000004) );
		/* 8209B728h case    0:*/		return 0x8209B72C;
		  /* 8209B72Ch */ case    1:  		/* subf R10, R25, R11 */
		/* 8209B72Ch case    1:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R25,regs.R11);
		/* 8209B72Ch case    1:*/		return 0x8209B730;
		  /* 8209B730h */ case    2:  		/* cmpw CR6, R30, R10 */
		/* 8209B730h case    2:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R10);
		/* 8209B730h case    2:*/		return 0x8209B734;
		  /* 8209B734h */ case    3:  		/* bc 4, CR6_LT, 32 */
		/* 8209B734h case    3:*/		if ( !regs.CR[6].lt ) { return 0x8209B754;  }
		/* 8209B734h case    3:*/		return 0x8209B738;
		  /* 8209B738h */ case    4:  		/* addi R11, R1, -152 */
		/* 8209B738h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xFFFFFF68);
		/* 8209B738h case    4:*/		return 0x8209B73C;
		  /* 8209B73Ch */ case    5:  		/* mr R5, R23 */
		/* 8209B73Ch case    5:*/		regs.R5 = regs.R23;
		/* 8209B73Ch case    5:*/		return 0x8209B740;
		  /* 8209B740h */ case    6:  		/* li R3, 2 */
		/* 8209B740h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 8209B740h case    6:*/		return 0x8209B744;
		  /* 8209B744h */ case    7:  		/* stw R23, <#[R11]> */
		/* 8209B744h case    7:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 8209B744h case    7:*/		return 0x8209B748;
		  /* 8209B748h */ case    8:  		/* stw R23, <#[R11 + 4]> */
		/* 8209B748h case    8:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000004) );
		/* 8209B748h case    8:*/		return 0x8209B74C;
		  /* 8209B74Ch */ case    9:  		/* stw R23, <#[R11 + 8]> */
		/* 8209B74Ch case    9:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000008) );
		/* 8209B74Ch case    9:*/		return 0x8209B750;
		  /* 8209B750h */ case   10:  		/* b 1136 */
		/* 8209B750h case   10:*/		return 0x8209BBC0;
		/* 8209B750h case   10:*/		return 0x8209B754;
	}
	return 0x8209B754;
} // Block from 8209B728h-8209B754h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209B754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B754);
		  /* 8209B754h */ case    0:  		/* li R10, 3 */
		/* 8209B754h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 8209B754h case    0:*/		return 0x8209B758;
		  /* 8209B758h */ case    1:  		/* cmpw CR6, R30, R11 */
		/* 8209B758h case    1:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R11);
		/* 8209B758h case    1:*/		return 0x8209B75C;
		  /* 8209B75Ch */ case    2:  		/* mtspr CTR, R10 */
		/* 8209B75Ch case    2:*/		regs.CTR = regs.R10;
		/* 8209B75Ch case    2:*/		return 0x8209B760;
		  /* 8209B760h */ case    3:  		/* bc 12, CR6_GT, 732 */
		/* 8209B760h case    3:*/		if ( regs.CR[6].gt ) { return 0x8209BA3C;  }
		/* 8209B760h case    3:*/		return 0x8209B764;
		  /* 8209B764h */ case    4:  		/* subf R11, R24, R11 */
		/* 8209B764h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R24,regs.R11);
		/* 8209B764h case    4:*/		return 0x8209B768;
		  /* 8209B768h */ case    5:  		/* addi R9, R1, -136 */
		/* 8209B768h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xFFFFFF78);
		/* 8209B768h case    5:*/		return 0x8209B76C;
		  /* 8209B76Ch */ case    6:  		/* srawi R8, R11, 5 */
		/* 8209B76Ch case    6:*/		cpu::op::srawi<0,5>(regs,&regs.R8,regs.R11);
		/* 8209B76Ch case    6:*/		return 0x8209B770;
		  /* 8209B770h */ case    7:  		/* addi R6, R1, -152 */
		/* 8209B770h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0xFFFFFF68);
		/* 8209B770h case    7:*/		return 0x8209B774;
		  /* 8209B774h */ case    8:  		/* addze R5, R8 */
		/* 8209B774h case    8:*/		cpu::op::addze<0>(regs,&regs.R5,regs.R8);
		/* 8209B774h case    8:*/		return 0x8209B778;
		  /* 8209B778h */ case    9:  		/* srawi R8, R11, 5 */
		/* 8209B778h case    9:*/		cpu::op::srawi<0,5>(regs,&regs.R8,regs.R11);
		/* 8209B778h case    9:*/		return 0x8209B77C;
		  /* 8209B77Ch */ case   10:  		/* lwz R7, <#[R9]> */
		/* 8209B77Ch case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 8209B77Ch case   10:*/		return 0x8209B780;
		  /* 8209B780h */ case   11:  		/* li R27, -1 */
		/* 8209B780h case   11:*/		cpu::op::li<0>(regs,&regs.R27,0xFFFFFFFF);
		/* 8209B780h case   11:*/		return 0x8209B784;
		  /* 8209B784h */ case   12:  		/* addze R8, R8 */
		/* 8209B784h case   12:*/		cpu::op::addze<0>(regs,&regs.R8,regs.R8);
		/* 8209B784h case   12:*/		return 0x8209B788;
		  /* 8209B788h */ case   13:  		/* lwz R31, <#[R9 + 4]> */
		/* 8209B788h case   13:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R9 + 0x00000004) );
		/* 8209B788h case   13:*/		return 0x8209B78C;
		  /* 8209B78Ch */ case   14:  		/* lwz R30, <#[R9 + 8]> */
		/* 8209B78Ch case   14:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + 0x00000008) );
		/* 8209B78Ch case   14:*/		return 0x8209B790;
		  /* 8209B790h */ case   15:  		/* addi R9, R1, -152 */
		/* 8209B790h case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xFFFFFF68);
		/* 8209B790h case   15:*/		return 0x8209B794;
		  /* 8209B794h */ case   16:  		/* rlwinm R8, R8, 5, 0, 26 */
		/* 8209B794h case   16:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R8,regs.R8);
		/* 8209B794h case   16:*/		return 0x8209B798;
		  /* 8209B798h */ case   17:  		/* subf R11, R8, R11 */
		/* 8209B798h case   17:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 8209B798h case   17:*/		return 0x8209B79C;
		  /* 8209B79Ch */ case   18:  		/* stw R7, <#[R6]> */
		/* 8209B79Ch case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R6 + 0x00000000) );
		/* 8209B79Ch case   18:*/		return 0x8209B7A0;
		  /* 8209B7A0h */ case   19:  		/* stw R31, <#[R6 + 4]> */
		/* 8209B7A0h case   19:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R6 + 0x00000004) );
		/* 8209B7A0h case   19:*/		return 0x8209B7A4;
		  /* 8209B7A4h */ case   20:  		/* mr R8, R23 */
		/* 8209B7A4h case   20:*/		regs.R8 = regs.R23;
		/* 8209B7A4h case   20:*/		return 0x8209B7A8;
		  /* 8209B7A8h */ case   21:  		/* slw R10, R27, R11 */
		/* 8209B7A8h case   21:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R27,regs.R11);
		/* 8209B7A8h case   21:*/		return 0x8209B7AC;
		  /* 8209B7ACh */ case   22:  		/* stw R30, <#[R6 + 8]> */
		/* 8209B7ACh case   22:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R6 + 0x00000008) );
		/* 8209B7ACh case   22:*/		return 0x8209B7B0;
		  /* 8209B7B0h */ case   23:  		/* nor R7, R10, R10 */
		/* 8209B7B0h case   23:*/		cpu::op::nor<0>(regs,&regs.R7,regs.R10,regs.R10);
		/* 8209B7B0h case   23:*/		return 0x8209B7B4;
		  /* 8209B7B4h */ case   24:  		/* subfic R6, R11, 32 */
		/* 8209B7B4h case   24:*/		cpu::op::subfic<0>(regs,&regs.R6,regs.R11,0x20);
		/* 8209B7B4h case   24:*/		return 0x8209B7B8;
		  /* 8209B7B8h */ case   25:  		/* addi R10, R9, -4 */
		/* 8209B7B8h case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFFFFC);
		/* 8209B7B8h case   25:*/		return 0x8209B7BC;
		  /* 8209B7BCh */ case   26:  		/* lwz R9, <#[R10 + 4]> */
		/* 8209B7BCh case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 8209B7BCh case   26:*/		return 0x8209B7C0;
		  /* 8209B7C0h */ case   27:  		/* and R31, R9, R7 */
		/* 8209B7C0h case   27:*/		cpu::op::and<0>(regs,&regs.R31,regs.R9,regs.R7);
		/* 8209B7C0h case   27:*/		return 0x8209B7C4;
		  /* 8209B7C4h */ case   28:  		/* stw R31, <#[R1 - 160]> */
		/* 8209B7C4h case   28:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8209B7C4h case   28:*/		return 0x8209B7C8;
		  /* 8209B7C8h */ case   29:  		/* srw R9, R9, R11 */
		/* 8209B7C8h case   29:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 8209B7C8h case   29:*/		return 0x8209B7CC;
		  /* 8209B7CCh */ case   30:  		/* or R9, R9, R8 */
		/* 8209B7CCh case   30:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8209B7CCh case   30:*/		return 0x8209B7D0;
		  /* 8209B7D0h */ case   31:  		/* stwu R9, <#[R10 + 4]> */
		/* 8209B7D0h case   31:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8209B7D0h case   31:*/		return 0x8209B7D4;
		  /* 8209B7D4h */ case   32:  		/* lwz R9, <#[R1 - 160]> */
		/* 8209B7D4h case   32:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8209B7D4h case   32:*/		return 0x8209B7D8;
		  /* 8209B7D8h */ case   33:  		/* slw R8, R9, R6 */
		/* 8209B7D8h case   33:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R9,regs.R6);
		/* 8209B7D8h case   33:*/		return 0x8209B7DC;
		  /* 8209B7DCh */ case   34:  		/* bc 16, CR0_LT, -32 */
		/* 8209B7DCh case   34:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209B7BC;  }
		/* 8209B7DCh case   34:*/		return 0x8209B7E0;
		  /* 8209B7E0h */ case   35:  		/* li R10, 3 */
		/* 8209B7E0h case   35:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 8209B7E0h case   35:*/		return 0x8209B7E4;
		  /* 8209B7E4h */ case   36:  		/* rlwinm R8, R5, 2, 0, 29 */
		/* 8209B7E4h case   36:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R5);
		/* 8209B7E4h case   36:*/		return 0x8209B7E8;
		  /* 8209B7E8h */ case   37:  		/* addi R7, R1, -144 */
		/* 8209B7E8h case   37:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xFFFFFF70);
		/* 8209B7E8h case   37:*/		return 0x8209B7EC;
		  /* 8209B7ECh */ case   38:  		/* li R9, 2 */
		/* 8209B7ECh case   38:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 8209B7ECh case   38:*/		return 0x8209B7F0;
		  /* 8209B7F0h */ case   39:  		/* addi R11, R1, -144 */
		/* 8209B7F0h case   39:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xFFFFFF70);
		/* 8209B7F0h case   39:*/		return 0x8209B7F4;
		  /* 8209B7F4h */ case   40:  		/* subf R8, R8, R7 */
		/* 8209B7F4h case   40:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8209B7F4h case   40:*/		return 0x8209B7F8;
		  /* 8209B7F8h */ case   41:  		/* mtspr CTR, R10 */
		/* 8209B7F8h case   41:*/		regs.CTR = regs.R10;
		/* 8209B7F8h case   41:*/		return 0x8209B7FC;
		  /* 8209B7FCh */ case   42:  		/* cmpw CR6, R9, R5 */
		/* 8209B7FCh case   42:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R5);
		/* 8209B7FCh case   42:*/		return 0x8209B800;
		  /* 8209B800h */ case   43:  		/* bc 12, CR6_LT, 16 */
		/* 8209B800h case   43:*/		if ( regs.CR[6].lt ) { return 0x8209B810;  }
		/* 8209B800h case   43:*/		return 0x8209B804;
		  /* 8209B804h */ case   44:  		/* lwz R10, <#[R8]> */
		/* 8209B804h case   44:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8209B804h case   44:*/		return 0x8209B808;
		  /* 8209B808h */ case   45:  		/* stw R10, <#[R11]> */
		/* 8209B808h case   45:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209B808h case   45:*/		return 0x8209B80C;
		  /* 8209B80Ch */ case   46:  		/* b 8 */
		/* 8209B80Ch case   46:*/		return 0x8209B814;
		/* 8209B80Ch case   46:*/		return 0x8209B810;
	}
	return 0x8209B810;
} // Block from 8209B754h-8209B810h (47 instructions)

//////////////////////////////////////////////////////
// Block at 8209B810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B810);
		  /* 8209B810h */ case    0:  		/* stw R23, <#[R11]> */
		/* 8209B810h case    0:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 8209B810h case    0:*/		return 0x8209B814;
	}
	return 0x8209B814;
} // Block from 8209B810h-8209B814h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209B814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B814);
		  /* 8209B814h */ case    0:  		/* addi R9, R9, -1 */
		/* 8209B814h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8209B814h case    0:*/		return 0x8209B818;
		  /* 8209B818h */ case    1:  		/* addi R8, R8, -4 */
		/* 8209B818h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFC);
		/* 8209B818h case    1:*/		return 0x8209B81C;
		  /* 8209B81Ch */ case    2:  		/* addi R11, R11, -4 */
		/* 8209B81Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8209B81Ch case    2:*/		return 0x8209B820;
		  /* 8209B820h */ case    3:  		/* bc 16, CR0_LT, -36 */
		/* 8209B820h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209B7FC;  }
		/* 8209B820h case    3:*/		return 0x8209B824;
		  /* 8209B824h */ case    4:  		/* addi R11, R26, 1 */
		/* 8209B824h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x1);
		/* 8209B824h case    4:*/		return 0x8209B828;
		  /* 8209B828h */ case    5:  		/* addi R29, R1, -152 */
		/* 8209B828h case    5:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R1,0xFFFFFF68);
		/* 8209B828h case    5:*/		return 0x8209B82C;
		  /* 8209B82Ch */ case    6:  		/* srawi R10, R11, 5 */
		/* 8209B82Ch case    6:*/		cpu::op::srawi<0,5>(regs,&regs.R10,regs.R11);
		/* 8209B82Ch case    6:*/		return 0x8209B830;
	}
	return 0x8209B830;
} // Block from 8209B814h-8209B830h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209B830h
// Function '_clearfp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B830);
		  /* 8209B830h */ case    0:  		/* addze R31, R10 */
		/* 8209B830h case    0:*/		cpu::op::addze<0>(regs,&regs.R31,regs.R10);
		/* 8209B830h case    0:*/		return 0x8209B834;
		  /* 8209B834h */ case    1:  		/* srawi R10, R11, 5 */
		/* 8209B834h case    1:*/		cpu::op::srawi<0,5>(regs,&regs.R10,regs.R11);
		/* 8209B834h case    1:*/		return 0x8209B838;
		  /* 8209B838h */ case    2:  		/* rlwinm R28, R31, 2, 0, 29 */
		/* 8209B838h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R31);
		/* 8209B838h case    2:*/		return 0x8209B83C;
		  /* 8209B83Ch */ case    3:  		/* addze R10, R10 */
		/* 8209B83Ch case    3:*/		cpu::op::addze<0>(regs,&regs.R10,regs.R10);
		/* 8209B83Ch case    3:*/		return 0x8209B840;
		  /* 8209B840h */ case    4:  		/* rlwinm R10, R10, 5, 0, 26 */
		/* 8209B840h case    4:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R10);
		/* 8209B840h case    4:*/		return 0x8209B844;
		  /* 8209B844h */ case    5:  		/* subf R11, R10, R11 */
		/* 8209B844h case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8209B844h case    5:*/		return 0x8209B848;
		  /* 8209B848h */ case    6:  		/* lwzx R10, <#[R28 + R29]> */
		/* 8209B848h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + regs.R29 + 0x00000000) );
		/* 8209B848h case    6:*/		return 0x8209B84C;
		  /* 8209B84Ch */ case    7:  		/* subfic R30, R11, 31 */
		/* 8209B84Ch case    7:*/		cpu::op::subfic<0>(regs,&regs.R30,regs.R11,0x1F);
		/* 8209B84Ch case    7:*/		return 0x8209B850;
		  /* 8209B850h */ case    8:  		/* slw R11, R3, R30 */
		/* 8209B850h case    8:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R3,regs.R30);
		/* 8209B850h case    8:*/		return 0x8209B854;
		  /* 8209B854h */ case    9:  		/* and. R11, R11, R10 */
		/* 8209B854h case    9:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8209B854h case    9:*/		return 0x8209B858;
		  /* 8209B858h */ case   10:  		/* bc 12, CR0_EQ, 236 */
		/* 8209B858h case   10:*/		if ( regs.CR[0].eq ) { return 0x8209B944;  }
		/* 8209B858h case   10:*/		return 0x8209B85C;
		  /* 8209B85Ch */ case   11:  		/* rlwinm R11, R31, 2, 0, 29 */
		/* 8209B85Ch case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R31);
		/* 8209B85Ch case   11:*/		return 0x8209B860;
	}
	return 0x8209B860;
} // Block from 8209B830h-8209B860h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8209B860h
// Function '_isctype_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B860);
		  /* 8209B860h */ case    0:  		/* addi R10, R1, -152 */
		/* 8209B860h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFF68);
		/* 8209B860h case    0:*/		return 0x8209B864;
		  /* 8209B864h */ case    1:  		/* slw R9, R22, R30 */
		/* 8209B864h case    1:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R22,regs.R30);
		/* 8209B864h case    1:*/		return 0x8209B868;
		  /* 8209B868h */ case    2:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8209B868h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8209B868h case    2:*/		return 0x8209B86C;
		  /* 8209B86Ch */ case    3:  		/* andc. R11, R11, R9 */
		/* 8209B86Ch case    3:*/		cpu::op::andc<1>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8209B86Ch case    3:*/		return 0x8209B870;
		  /* 8209B870h */ case    4:  		/* bc 4, CR0_EQ, 60 */
		/* 8209B870h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8209B8AC;  }
		/* 8209B870h case    4:*/		return 0x8209B874;
		  /* 8209B874h */ case    5:  		/* addi R11, R31, 1 */
		/* 8209B874h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x1);
		/* 8209B874h case    5:*/		return 0x8209B878;
		  /* 8209B878h */ case    6:  		/* cmpwi CR6, R11, 3 */
		/* 8209B878h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8209B878h case    6:*/		return 0x8209B87C;
		  /* 8209B87Ch */ case    7:  		/* bc 4, CR6_LT, 200 */
		/* 8209B87Ch case    7:*/		if ( !regs.CR[6].lt ) { return 0x8209B944;  }
		/* 8209B87Ch case    7:*/		return 0x8209B880;
		  /* 8209B880h */ case    8:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8209B880h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8209B880h case    8:*/		return 0x8209B884;
		  /* 8209B884h */ case    9:  		/* addi R10, R1, -152 */
		/* 8209B884h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFF68);
		/* 8209B884h case    9:*/		return 0x8209B888;
		  /* 8209B888h */ case   10:  		/* add R10, R9, R10 */
		/* 8209B888h case   10:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8209B888h case   10:*/		return 0x8209B88C;
		  /* 8209B88Ch */ case   11:  		/* lwz R9, <#[R10]> */
		/* 8209B88Ch case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8209B88Ch case   11:*/		return 0x8209B890;
		  /* 8209B890h */ case   12:  		/* cmplwi CR6, R9, 0 */
		/* 8209B890h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8209B890h case   12:*/		return 0x8209B894;
		  /* 8209B894h */ case   13:  		/* bc 4, CR6_EQ, 24 */
		/* 8209B894h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8209B8AC;  }
		/* 8209B894h case   13:*/		return 0x8209B898;
	}
	return 0x8209B898;
} // Block from 8209B860h-8209B898h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209B898h
// Function '_calloc_impl'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B898);
		  /* 8209B898h */ case    0:  		/* addi R11, R11, 1 */
		/* 8209B898h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209B898h case    0:*/		return 0x8209B89C;
		  /* 8209B89Ch */ case    1:  		/* addi R10, R10, 4 */
		/* 8209B89Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8209B89Ch case    1:*/		return 0x8209B8A0;
		  /* 8209B8A0h */ case    2:  		/* cmpwi CR6, R11, 3 */
		/* 8209B8A0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8209B8A0h case    2:*/		return 0x8209B8A4;
		  /* 8209B8A4h */ case    3:  		/* bc 12, CR6_LT, -24 */
		/* 8209B8A4h case    3:*/		if ( regs.CR[6].lt ) { return 0x8209B88C;  }
		/* 8209B8A4h case    3:*/		return 0x8209B8A8;
		  /* 8209B8A8h */ case    4:  		/* b 156 */
		/* 8209B8A8h case    4:*/		return 0x8209B944;
		/* 8209B8A8h case    4:*/		return 0x8209B8AC;
	}
	return 0x8209B8AC;
} // Block from 8209B898h-8209B8ACh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209B8ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B8AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B8AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B8AC);
		  /* 8209B8ACh */ case    0:  		/* srawi R11, R26, 5 */
		/* 8209B8ACh case    0:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R26);
		/* 8209B8ACh case    0:*/		return 0x8209B8B0;
		  /* 8209B8B0h */ case    1:  		/* addi R8, R1, -152 */
		/* 8209B8B0h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xFFFFFF68);
		/* 8209B8B0h case    1:*/		return 0x8209B8B4;
		  /* 8209B8B4h */ case    2:  		/* addze R9, R11 */
		/* 8209B8B4h case    2:*/		cpu::op::addze<0>(regs,&regs.R9,regs.R11);
		/* 8209B8B4h case    2:*/		return 0x8209B8B8;
		  /* 8209B8B8h */ case    3:  		/* srawi R11, R26, 5 */
		/* 8209B8B8h case    3:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R26);
		/* 8209B8B8h case    3:*/		return 0x8209B8BC;
		  /* 8209B8BCh */ case    4:  		/* rlwinm R7, R9, 2, 0, 29 */
		/* 8209B8BCh case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R9);
		/* 8209B8BCh case    4:*/		return 0x8209B8C0;
		  /* 8209B8C0h */ case    5:  		/* addze R11, R11 */
		/* 8209B8C0h case    5:*/		cpu::op::addze<0>(regs,&regs.R11,regs.R11);
		/* 8209B8C0h case    5:*/		return 0x8209B8C4;
		  /* 8209B8C4h */ case    6:  		/* mr R5, R23 */
		/* 8209B8C4h case    6:*/		regs.R5 = regs.R23;
		/* 8209B8C4h case    6:*/		return 0x8209B8C8;
		  /* 8209B8C8h */ case    7:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 8209B8C8h case    7:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 8209B8C8h case    7:*/		return 0x8209B8CC;
		  /* 8209B8CCh */ case    8:  		/* subf R10, R11, R26 */
		/* 8209B8CCh case    8:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R26);
		/* 8209B8CCh case    8:*/		return 0x8209B8D0;
		  /* 8209B8D0h */ case    9:  		/* lwzx R11, <#[R7 + R8]> */
		/* 8209B8D0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 8209B8D0h case    9:*/		return 0x8209B8D4;
		  /* 8209B8D4h */ case   10:  		/* subfic R10, R10, 31 */
		/* 8209B8D4h case   10:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0x1F);
		/* 8209B8D4h case   10:*/		return 0x8209B8D8;
		  /* 8209B8D8h */ case   11:  		/* slw R6, R3, R10 */
		/* 8209B8D8h case   11:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R3,regs.R10);
		/* 8209B8D8h case   11:*/		return 0x8209B8DC;
		  /* 8209B8DCh */ case   12:  		/* add R10, R11, R6 */
		/* 8209B8DCh case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R6);
		/* 8209B8DCh case   12:*/		return 0x8209B8E0;
		  /* 8209B8E0h */ case   13:  		/* cmplw CR6, R10, R11 */
		/* 8209B8E0h case   13:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8209B8E0h case   13:*/		return 0x8209B8E4;
		  /* 8209B8E4h */ case   14:  		/* bc 12, CR6_LT, 12 */
		/* 8209B8E4h case   14:*/		if ( regs.CR[6].lt ) { return 0x8209B8F0;  }
		/* 8209B8E4h case   14:*/		return 0x8209B8E8;
		  /* 8209B8E8h */ case   15:  		/* cmplw CR6, R10, R6 */
		/* 8209B8E8h case   15:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 8209B8E8h case   15:*/		return 0x8209B8EC;
		  /* 8209B8ECh */ case   16:  		/* bc 4, CR6_LT, 8 */
		/* 8209B8ECh case   16:*/		if ( !regs.CR[6].lt ) { return 0x8209B8F4;  }
		/* 8209B8ECh case   16:*/		return 0x8209B8F0;
	}
	return 0x8209B8F0;
} // Block from 8209B8ACh-8209B8F0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8209B8F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B8F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B8F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B8F0);
		  /* 8209B8F0h */ case    0:  		/* mr R5, R3 */
		/* 8209B8F0h case    0:*/		regs.R5 = regs.R3;
		/* 8209B8F0h case    0:*/		return 0x8209B8F4;
	}
	return 0x8209B8F4;
} // Block from 8209B8F0h-8209B8F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209B8F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B8F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B8F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B8F4);
		  /* 8209B8F4h */ case    0:  		/* stwx R10, <#[R7 + R8]> */
		/* 8209B8F4h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 8209B8F4h case    0:*/		return 0x8209B8F8;
		  /* 8209B8F8h */ case    1:  		/* addic. R11, R9, -1 */
		/* 8209B8F8h case    1:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 8209B8F8h case    1:*/		return 0x8209B8FC;
		  /* 8209B8FCh */ case    2:  		/* mr R7, R5 */
		/* 8209B8FCh case    2:*/		regs.R7 = regs.R5;
		/* 8209B8FCh case    2:*/		return 0x8209B900;
		  /* 8209B900h */ case    3:  		/* bc 12, CR0_LT, 68 */
		/* 8209B900h case    3:*/		if ( regs.CR[0].lt ) { return 0x8209B944;  }
		/* 8209B900h case    3:*/		return 0x8209B904;
		  /* 8209B904h */ case    4:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8209B904h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8209B904h case    4:*/		return 0x8209B908;
		  /* 8209B908h */ case    5:  		/* addi R10, R1, -148 */
		/* 8209B908h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFF6C);
		/* 8209B908h case    5:*/		return 0x8209B90C;
		  /* 8209B90Ch */ case    6:  		/* add R10, R9, R10 */
		/* 8209B90Ch case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8209B90Ch case    6:*/		return 0x8209B910;
		  /* 8209B910h */ case    7:  		/* cmpwi CR6, R7, 0 */
		/* 8209B910h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 8209B910h case    7:*/		return 0x8209B914;
		  /* 8209B914h */ case    8:  		/* bc 12, CR6_EQ, 48 */
		/* 8209B914h case    8:*/		if ( regs.CR[6].eq ) { return 0x8209B944;  }
		/* 8209B914h case    8:*/		return 0x8209B918;
		  /* 8209B918h */ case    9:  		/* lwz R9, <#[R10 - 4]> */
		/* 8209B918h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 8209B918h case    9:*/		return 0x8209B91C;
		  /* 8209B91Ch */ case   10:  		/* mr R7, R23 */
		/* 8209B91Ch case   10:*/		regs.R7 = regs.R23;
		/* 8209B91Ch case   10:*/		return 0x8209B920;
		  /* 8209B920h */ case   11:  		/* addi R8, R9, 1 */
		/* 8209B920h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0x1);
		/* 8209B920h case   11:*/		return 0x8209B924;
		  /* 8209B924h */ case   12:  		/* cmplw CR6, R8, R9 */
		/* 8209B924h case   12:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8209B924h case   12:*/		return 0x8209B928;
		  /* 8209B928h */ case   13:  		/* bc 12, CR6_LT, 12 */
		/* 8209B928h case   13:*/		if ( regs.CR[6].lt ) { return 0x8209B934;  }
		/* 8209B928h case   13:*/		return 0x8209B92C;
		  /* 8209B92Ch */ case   14:  		/* cmplwi CR6, R8, 1 */
		/* 8209B92Ch case   14:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000001);
		/* 8209B92Ch case   14:*/		return 0x8209B930;
		  /* 8209B930h */ case   15:  		/* bc 4, CR6_LT, 8 */
		/* 8209B930h case   15:*/		if ( !regs.CR[6].lt ) { return 0x8209B938;  }
		/* 8209B930h case   15:*/		return 0x8209B934;
	}
	return 0x8209B934;
} // Block from 8209B8F4h-8209B934h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8209B934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B934);
		  /* 8209B934h */ case    0:  		/* mr R7, R3 */
		/* 8209B934h case    0:*/		regs.R7 = regs.R3;
		/* 8209B934h case    0:*/		return 0x8209B938;
	}
	return 0x8209B938;
} // Block from 8209B934h-8209B938h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209B938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B938);
		  /* 8209B938h */ case    0:  		/* addic. R11, R11, -1 */
		/* 8209B938h case    0:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8209B938h case    0:*/		return 0x8209B93C;
		  /* 8209B93Ch */ case    1:  		/* stwu R8, <#[R10 - 4]> */
		/* 8209B93Ch case    1:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0xFFFFFFFC) );
		regs.R10 = (uint32)(regs.R10 + 0xFFFFFFFC);
		/* 8209B93Ch case    1:*/		return 0x8209B940;
		  /* 8209B940h */ case    2:  		/* bc 4, CR0_LT, -48 */
		/* 8209B940h case    2:*/		if ( !regs.CR[0].lt ) { return 0x8209B910;  }
		/* 8209B940h case    2:*/		return 0x8209B944;
	}
	return 0x8209B944;
} // Block from 8209B938h-8209B944h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B944);
		  /* 8209B944h */ case    0:  		/* lwzx R10, <#[R28 + R29]> */
		/* 8209B944h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + regs.R29 + 0x00000000) );
		/* 8209B944h case    0:*/		return 0x8209B948;
		  /* 8209B948h */ case    1:  		/* slw R9, R22, R30 */
		/* 8209B948h case    1:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R22,regs.R30);
		/* 8209B948h case    1:*/		return 0x8209B94C;
		  /* 8209B94Ch */ case    2:  		/* addi R11, R31, 1 */
		/* 8209B94Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x1);
		/* 8209B94Ch case    2:*/		return 0x8209B950;
		  /* 8209B950h */ case    3:  		/* and R10, R9, R10 */
		/* 8209B950h case    3:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8209B950h case    3:*/		return 0x8209B954;
		  /* 8209B954h */ case    4:  		/* cmpwi CR6, R11, 3 */
		/* 8209B954h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8209B954h case    4:*/		return 0x8209B958;
		  /* 8209B958h */ case    5:  		/* stwx R10, <#[R28 + R29]> */
		/* 8209B958h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + regs.R29 + 0x00000000) );
		/* 8209B958h case    5:*/		return 0x8209B95C;
		  /* 8209B95Ch */ case    6:  		/* bc 4, CR6_LT, 48 */
		/* 8209B95Ch case    6:*/		if ( !regs.CR[6].lt ) { return 0x8209B98C;  }
		/* 8209B95Ch case    6:*/		return 0x8209B960;
	}
	return 0x8209B960;
} // Block from 8209B944h-8209B960h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209B960h
// Function 'isalpha'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B960);
		  /* 8209B960h */ case    0:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8209B960h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8209B960h case    0:*/		return 0x8209B964;
		  /* 8209B964h */ case    1:  		/* addi R10, R1, -152 */
		/* 8209B964h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFF68);
		/* 8209B964h case    1:*/		return 0x8209B968;
		  /* 8209B968h */ case    2:  		/* subfic R11, R11, 3 */
		/* 8209B968h case    2:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x3);
		/* 8209B968h case    2:*/		return 0x8209B96C;
		  /* 8209B96Ch */ case    3:  		/* add R10, R9, R10 */
		/* 8209B96Ch case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8209B96Ch case    3:*/		return 0x8209B970;
		  /* 8209B970h */ case    4:  		/* mr R9, R23 */
		/* 8209B970h case    4:*/		regs.R9 = regs.R23;
		/* 8209B970h case    4:*/		return 0x8209B974;
		  /* 8209B974h */ case    5:  		/* addi R10, R10, -4 */
		/* 8209B974h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 8209B974h case    5:*/		return 0x8209B978;
		  /* 8209B978h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 8209B978h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209B978h case    6:*/		return 0x8209B97C;
		  /* 8209B97Ch */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 8209B97Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x8209B98C;  }
		/* 8209B97Ch case    7:*/		return 0x8209B980;
	}
	return 0x8209B980;
} // Block from 8209B960h-8209B980h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209B980h
// Function 'isdigit'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B980);
		  /* 8209B980h */ case    0:  		/* mtspr CTR, R11 */
		/* 8209B980h case    0:*/		regs.CTR = regs.R11;
		/* 8209B980h case    0:*/		return 0x8209B984;
		  /* 8209B984h */ case    1:  		/* stwu R9, <#[R10 + 4]> */
		/* 8209B984h case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8209B984h case    1:*/		return 0x8209B988;
		  /* 8209B988h */ case    2:  		/* bc 16, CR0_LT, -4 */
		/* 8209B988h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209B984;  }
		/* 8209B988h case    2:*/		return 0x8209B98C;
	}
	return 0x8209B98C;
} // Block from 8209B980h-8209B98Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209B98Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B98C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B98C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B98C);
		  /* 8209B98Ch */ case    0:  		/* addi R11, R21, 1 */
		/* 8209B98Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R21,0x1);
		/* 8209B98Ch case    0:*/		return 0x8209B990;
		  /* 8209B990h */ case    1:  		/* li R10, 3 */
		/* 8209B990h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 8209B990h case    1:*/		return 0x8209B994;
		  /* 8209B994h */ case    2:  		/* srawi R8, R11, 5 */
		/* 8209B994h case    2:*/		cpu::op::srawi<0,5>(regs,&regs.R8,regs.R11);
		/* 8209B994h case    2:*/		return 0x8209B998;
		  /* 8209B998h */ case    3:  		/* addi R9, R1, -152 */
		/* 8209B998h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xFFFFFF68);
		/* 8209B998h case    3:*/		return 0x8209B99C;
		  /* 8209B99Ch */ case    4:  		/* addze R6, R8 */
		/* 8209B99Ch case    4:*/		cpu::op::addze<0>(regs,&regs.R6,regs.R8);
		/* 8209B99Ch case    4:*/		return 0x8209B9A0;
	}
	return 0x8209B9A0;
} // Block from 8209B98Ch-8209B9A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209B9A0h
// Function 'isxdigit'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B9A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B9A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B9A0);
		  /* 8209B9A0h */ case    0:  		/* srawi R8, R11, 5 */
		/* 8209B9A0h case    0:*/		cpu::op::srawi<0,5>(regs,&regs.R8,regs.R11);
		/* 8209B9A0h case    0:*/		return 0x8209B9A4;
		  /* 8209B9A4h */ case    1:  		/* mtspr CTR, R10 */
		/* 8209B9A4h case    1:*/		regs.CTR = regs.R10;
		/* 8209B9A4h case    1:*/		return 0x8209B9A8;
		  /* 8209B9A8h */ case    2:  		/* addi R10, R9, -4 */
		/* 8209B9A8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFFFFC);
		/* 8209B9A8h case    2:*/		return 0x8209B9AC;
		  /* 8209B9ACh */ case    3:  		/* addze R9, R8 */
		/* 8209B9ACh case    3:*/		cpu::op::addze<0>(regs,&regs.R9,regs.R8);
		/* 8209B9ACh case    3:*/		return 0x8209B9B0;
		  /* 8209B9B0h */ case    4:  		/* mr R8, R23 */
		/* 8209B9B0h case    4:*/		regs.R8 = regs.R23;
		/* 8209B9B0h case    4:*/		return 0x8209B9B4;
		  /* 8209B9B4h */ case    5:  		/* rlwinm R9, R9, 5, 0, 26 */
		/* 8209B9B4h case    5:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R9,regs.R9);
		/* 8209B9B4h case    5:*/		return 0x8209B9B8;
		  /* 8209B9B8h */ case    6:  		/* subf R11, R9, R11 */
		/* 8209B9B8h case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8209B9B8h case    6:*/		return 0x8209B9BC;
		  /* 8209B9BCh */ case    7:  		/* slw R9, R27, R11 */
		/* 8209B9BCh case    7:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R27,regs.R11);
		/* 8209B9BCh case    7:*/		return 0x8209B9C0;
	}
	return 0x8209B9C0;
} // Block from 8209B9A0h-8209B9C0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209B9C0h
// Function 'isspace'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B9C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B9C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B9C0);
		  /* 8209B9C0h */ case    0:  		/* nor R9, R9, R9 */
		/* 8209B9C0h case    0:*/		cpu::op::nor<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 8209B9C0h case    0:*/		return 0x8209B9C4;
		  /* 8209B9C4h */ case    1:  		/* subfic R7, R11, 32 */
		/* 8209B9C4h case    1:*/		cpu::op::subfic<0>(regs,&regs.R7,regs.R11,0x20);
		/* 8209B9C4h case    1:*/		return 0x8209B9C8;
		  /* 8209B9C8h */ case    2:  		/* lwz R5, <#[R10 + 4]> */
		/* 8209B9C8h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000004) );
		/* 8209B9C8h case    2:*/		return 0x8209B9CC;
		  /* 8209B9CCh */ case    3:  		/* and R3, R5, R9 */
		/* 8209B9CCh case    3:*/		cpu::op::and<0>(regs,&regs.R3,regs.R5,regs.R9);
		/* 8209B9CCh case    3:*/		return 0x8209B9D0;
		  /* 8209B9D0h */ case    4:  		/* stw R3, <#[R1 - 160]> */
		/* 8209B9D0h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8209B9D0h case    4:*/		return 0x8209B9D4;
		  /* 8209B9D4h */ case    5:  		/* srw R5, R5, R11 */
		/* 8209B9D4h case    5:*/		cpu::op::srw<0>(regs,&regs.R5,regs.R5,regs.R11);
		/* 8209B9D4h case    5:*/		return 0x8209B9D8;
		  /* 8209B9D8h */ case    6:  		/* or R8, R5, R8 */
		/* 8209B9D8h case    6:*/		cpu::op::or<0>(regs,&regs.R8,regs.R5,regs.R8);
		/* 8209B9D8h case    6:*/		return 0x8209B9DC;
		  /* 8209B9DCh */ case    7:  		/* stwu R8, <#[R10 + 4]> */
		/* 8209B9DCh case    7:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8209B9DCh case    7:*/		return 0x8209B9E0;
	}
	return 0x8209B9E0;
} // Block from 8209B9C0h-8209B9E0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209B9E0h
// Function 'isalnum'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209B9E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209B9E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209B9E0);
		  /* 8209B9E0h */ case    0:  		/* lwz R8, <#[R1 - 160]> */
		/* 8209B9E0h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8209B9E0h case    0:*/		return 0x8209B9E4;
		  /* 8209B9E4h */ case    1:  		/* slw R8, R8, R7 */
		/* 8209B9E4h case    1:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8209B9E4h case    1:*/		return 0x8209B9E8;
		  /* 8209B9E8h */ case    2:  		/* bc 16, CR0_LT, -32 */
		/* 8209B9E8h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209B9C8;  }
		/* 8209B9E8h case    2:*/		return 0x8209B9EC;
		  /* 8209B9ECh */ case    3:  		/* li R10, 3 */
		/* 8209B9ECh case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 8209B9ECh case    3:*/		return 0x8209B9F0;
		  /* 8209B9F0h */ case    4:  		/* rlwinm R8, R6, 2, 0, 29 */
		/* 8209B9F0h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R6);
		/* 8209B9F0h case    4:*/		return 0x8209B9F4;
		  /* 8209B9F4h */ case    5:  		/* addi R7, R1, -144 */
		/* 8209B9F4h case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xFFFFFF70);
		/* 8209B9F4h case    5:*/		return 0x8209B9F8;
		  /* 8209B9F8h */ case    6:  		/* li R9, 2 */
		/* 8209B9F8h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 8209B9F8h case    6:*/		return 0x8209B9FC;
		  /* 8209B9FCh */ case    7:  		/* addi R11, R1, -144 */
		/* 8209B9FCh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xFFFFFF70);
		/* 8209B9FCh case    7:*/		return 0x8209BA00;
	}
	return 0x8209BA00;
} // Block from 8209B9E0h-8209BA00h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209BA00h
// Function 'tolower'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BA00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BA00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BA00);
		  /* 8209BA00h */ case    0:  		/* subf R8, R8, R7 */
		/* 8209BA00h case    0:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8209BA00h case    0:*/		return 0x8209BA04;
		  /* 8209BA04h */ case    1:  		/* mtspr CTR, R10 */
		/* 8209BA04h case    1:*/		regs.CTR = regs.R10;
		/* 8209BA04h case    1:*/		return 0x8209BA08;
		  /* 8209BA08h */ case    2:  		/* cmpw CR6, R9, R6 */
		/* 8209BA08h case    2:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R6);
		/* 8209BA08h case    2:*/		return 0x8209BA0C;
		  /* 8209BA0Ch */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 8209BA0Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8209BA1C;  }
		/* 8209BA0Ch case    3:*/		return 0x8209BA10;
		  /* 8209BA10h */ case    4:  		/* lwz R10, <#[R8]> */
		/* 8209BA10h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8209BA10h case    4:*/		return 0x8209BA14;
		  /* 8209BA14h */ case    5:  		/* stw R10, <#[R11]> */
		/* 8209BA14h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209BA14h case    5:*/		return 0x8209BA18;
	}
	return 0x8209BA18;
} // Block from 8209BA00h-8209BA18h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209BA18h
// Function '_atodbl_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BA18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BA18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BA18);
		  /* 8209BA18h */ case    0:  		/* b 8 */
		/* 8209BA18h case    0:*/		return 0x8209BA20;
		/* 8209BA18h case    0:*/		return 0x8209BA1C;
	}
	return 0x8209BA1C;
} // Block from 8209BA18h-8209BA1Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209BA1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BA1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BA1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BA1C);
		  /* 8209BA1Ch */ case    0:  		/* stw R23, <#[R11]> */
		/* 8209BA1Ch case    0:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 8209BA1Ch case    0:*/		return 0x8209BA20;
	}
	return 0x8209BA20;
} // Block from 8209BA1Ch-8209BA20h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209BA20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BA20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BA20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BA20);
		  /* 8209BA20h */ case    0:  		/* addi R9, R9, -1 */
		/* 8209BA20h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8209BA20h case    0:*/		return 0x8209BA24;
		  /* 8209BA24h */ case    1:  		/* addi R8, R8, -4 */
		/* 8209BA24h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFC);
		/* 8209BA24h case    1:*/		return 0x8209BA28;
		  /* 8209BA28h */ case    2:  		/* addi R11, R11, -4 */
		/* 8209BA28h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8209BA28h case    2:*/		return 0x8209BA2C;
		  /* 8209BA2Ch */ case    3:  		/* bc 16, CR0_LT, -36 */
		/* 8209BA2Ch case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209BA08;  }
		/* 8209BA2Ch case    3:*/		return 0x8209BA30;
		  /* 8209BA30h */ case    4:  		/* mr R5, R23 */
		/* 8209BA30h case    4:*/		regs.R5 = regs.R23;
		/* 8209BA30h case    4:*/		return 0x8209BA34;
		  /* 8209BA34h */ case    5:  		/* li R3, 2 */
		/* 8209BA34h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 8209BA34h case    5:*/		return 0x8209BA38;
		  /* 8209BA38h */ case    6:  		/* b 392 */
		/* 8209BA38h case    6:*/		return 0x8209BBC0;
		/* 8209BA38h case    6:*/		return 0x8209BA3C;
	}
	return 0x8209BA3C;
} // Block from 8209BA20h-8209BA3Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209BA3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BA3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BA3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BA3C);
		  /* 8209BA3Ch */ case    0:  		/* lwz R5, <#[R20]> */
		/* 8209BA3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R20 + 0x00000000) );
		/* 8209BA3Ch case    0:*/		return 0x8209BA40;
		  /* 8209BA40h */ case    1:  		/* cmpw CR6, R30, R5 */
		/* 8209BA40h case    1:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R5);
		/* 8209BA40h case    1:*/		return 0x8209BA44;
		  /* 8209BA44h */ case    2:  		/* bc 12, CR6_LT, 200 */
		/* 8209BA44h case    2:*/		if ( regs.CR[6].lt ) { return 0x8209BB0C;  }
		/* 8209BA44h case    2:*/		return 0x8209BA48;
		  /* 8209BA48h */ case    3:  		/* addi R11, R1, -152 */
		/* 8209BA48h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xFFFFFF68);
		/* 8209BA48h case    3:*/		return 0x8209BA4C;
		  /* 8209BA4Ch */ case    4:  		/* srawi R9, R21, 5 */
		/* 8209BA4Ch case    4:*/		cpu::op::srawi<0,5>(regs,&regs.R9,regs.R21);
		/* 8209BA4Ch case    4:*/		return 0x8209BA50;
		  /* 8209BA50h */ case    5:  		/* li R7, -1 */
		/* 8209BA50h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0xFFFFFFFF);
		/* 8209BA50h case    5:*/		return 0x8209BA54;
		  /* 8209BA54h */ case    6:  		/* addze R6, R9 */
		/* 8209BA54h case    6:*/		cpu::op::addze<0>(regs,&regs.R6,regs.R9);
		/* 8209BA54h case    6:*/		return 0x8209BA58;
		  /* 8209BA58h */ case    7:  		/* srawi R9, R21, 5 */
		/* 8209BA58h case    7:*/		cpu::op::srawi<0,5>(regs,&regs.R9,regs.R21);
		/* 8209BA58h case    7:*/		return 0x8209BA5C;
		  /* 8209BA5Ch */ case    8:  		/* stw R23, <#[R11]> */
		/* 8209BA5Ch case    8:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 8209BA5Ch case    8:*/		return 0x8209BA60;
		  /* 8209BA60h */ case    9:  		/* stw R23, <#[R11 + 4]> */
		/* 8209BA60h case    9:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000004) );
		/* 8209BA60h case    9:*/		return 0x8209BA64;
		  /* 8209BA64h */ case   10:  		/* addze R8, R9 */
		/* 8209BA64h case   10:*/		cpu::op::addze<0>(regs,&regs.R8,regs.R9);
		/* 8209BA64h case   10:*/		return 0x8209BA68;
		  /* 8209BA68h */ case   11:  		/* stw R23, <#[R11 + 8]> */
		/* 8209BA68h case   11:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000008) );
		/* 8209BA68h case   11:*/		return 0x8209BA6C;
		  /* 8209BA6Ch */ case   12:  		/* rlwinm R11, R8, 5, 0, 26 */
		/* 8209BA6Ch case   12:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R8);
		/* 8209BA6Ch case   12:*/		return 0x8209BA70;
		  /* 8209BA70h */ case   13:  		/* addi R9, R1, -152 */
		/* 8209BA70h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xFFFFFF68);
		/* 8209BA70h case   13:*/		return 0x8209BA74;
		  /* 8209BA74h */ case   14:  		/* subf R11, R11, R21 */
		/* 8209BA74h case   14:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R21);
		/* 8209BA74h case   14:*/		return 0x8209BA78;
		  /* 8209BA78h */ case   15:  		/* addi R10, R9, -4 */
		/* 8209BA78h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFFFFC);
		/* 8209BA78h case   15:*/		return 0x8209BA7C;
		  /* 8209BA7Ch */ case   16:  		/* slw R9, R7, R11 */
		/* 8209BA7Ch case   16:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R7,regs.R11);
		/* 8209BA7Ch case   16:*/		return 0x8209BA80;
		  /* 8209BA80h */ case   17:  		/* lwz R31, <#[R1 - 152]> */
		/* 8209BA80h case   17:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFF68) );
		/* 8209BA80h case   17:*/		return 0x8209BA84;
		  /* 8209BA84h */ case   18:  		/* mr R8, R23 */
		/* 8209BA84h case   18:*/		regs.R8 = regs.R23;
		/* 8209BA84h case   18:*/		return 0x8209BA88;
		  /* 8209BA88h */ case   19:  		/* nor R9, R9, R9 */
		/* 8209BA88h case   19:*/		cpu::op::nor<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 8209BA88h case   19:*/		return 0x8209BA8C;
		  /* 8209BA8Ch */ case   20:  		/* oris R31, R31, 32768 */
		/* 8209BA8Ch case   20:*/		cpu::op::oris<0>(regs,&regs.R31,regs.R31,0x8000);
		/* 8209BA8Ch case   20:*/		return 0x8209BA90;
		  /* 8209BA90h */ case   21:  		/* subfic R7, R11, 32 */
		/* 8209BA90h case   21:*/		cpu::op::subfic<0>(regs,&regs.R7,regs.R11,0x20);
		/* 8209BA90h case   21:*/		return 0x8209BA94;
		  /* 8209BA94h */ case   22:  		/* stw R31, <#[R1 - 152]> */
		/* 8209BA94h case   22:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFF68) );
		/* 8209BA94h case   22:*/		return 0x8209BA98;
		  /* 8209BA98h */ case   23:  		/* lwz R31, <#[R10 + 4]> */
		/* 8209BA98h case   23:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x00000004) );
		/* 8209BA98h case   23:*/		return 0x8209BA9C;
		  /* 8209BA9Ch */ case   24:  		/* and R30, R31, R9 */
		/* 8209BA9Ch case   24:*/		cpu::op::and<0>(regs,&regs.R30,regs.R31,regs.R9);
		/* 8209BA9Ch case   24:*/		return 0x8209BAA0;
		  /* 8209BAA0h */ case   25:  		/* stw R30, <#[R1 - 160]> */
		/* 8209BAA0h case   25:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8209BAA0h case   25:*/		return 0x8209BAA4;
		  /* 8209BAA4h */ case   26:  		/* srw R31, R31, R11 */
		/* 8209BAA4h case   26:*/		cpu::op::srw<0>(regs,&regs.R31,regs.R31,regs.R11);
		/* 8209BAA4h case   26:*/		return 0x8209BAA8;
		  /* 8209BAA8h */ case   27:  		/* or R8, R31, R8 */
		/* 8209BAA8h case   27:*/		cpu::op::or<0>(regs,&regs.R8,regs.R31,regs.R8);
		/* 8209BAA8h case   27:*/		return 0x8209BAAC;
		  /* 8209BAACh */ case   28:  		/* stwu R8, <#[R10 + 4]> */
		/* 8209BAACh case   28:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8209BAACh case   28:*/		return 0x8209BAB0;
		  /* 8209BAB0h */ case   29:  		/* lwz R8, <#[R1 - 160]> */
		/* 8209BAB0h case   29:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8209BAB0h case   29:*/		return 0x8209BAB4;
		  /* 8209BAB4h */ case   30:  		/* slw R8, R8, R7 */
		/* 8209BAB4h case   30:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8209BAB4h case   30:*/		return 0x8209BAB8;
		  /* 8209BAB8h */ case   31:  		/* bc 16, CR0_LT, -32 */
		/* 8209BAB8h case   31:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209BA98;  }
		/* 8209BAB8h case   31:*/		return 0x8209BABC;
		  /* 8209BABCh */ case   32:  		/* li R10, 3 */
		/* 8209BABCh case   32:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 8209BABCh case   32:*/		return 0x8209BAC0;
	}
	return 0x8209BAC0;
} // Block from 8209BA3Ch-8209BAC0h (33 instructions)

//////////////////////////////////////////////////////
// Block at 8209BAC0h
// Function '_atoflt_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BAC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BAC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BAC0);
		  /* 8209BAC0h */ case    0:  		/* rlwinm R8, R6, 2, 0, 29 */
		/* 8209BAC0h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R6);
		/* 8209BAC0h case    0:*/		return 0x8209BAC4;
		  /* 8209BAC4h */ case    1:  		/* addi R7, R1, -144 */
		/* 8209BAC4h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xFFFFFF70);
		/* 8209BAC4h case    1:*/		return 0x8209BAC8;
		  /* 8209BAC8h */ case    2:  		/* li R9, 2 */
		/* 8209BAC8h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 8209BAC8h case    2:*/		return 0x8209BACC;
		  /* 8209BACCh */ case    3:  		/* addi R11, R1, -144 */
		/* 8209BACCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xFFFFFF70);
		/* 8209BACCh case    3:*/		return 0x8209BAD0;
		  /* 8209BAD0h */ case    4:  		/* subf R8, R8, R7 */
		/* 8209BAD0h case    4:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8209BAD0h case    4:*/		return 0x8209BAD4;
		  /* 8209BAD4h */ case    5:  		/* mtspr CTR, R10 */
		/* 8209BAD4h case    5:*/		regs.CTR = regs.R10;
		/* 8209BAD4h case    5:*/		return 0x8209BAD8;
		  /* 8209BAD8h */ case    6:  		/* cmpw CR6, R9, R6 */
		/* 8209BAD8h case    6:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R6);
		/* 8209BAD8h case    6:*/		return 0x8209BADC;
		  /* 8209BADCh */ case    7:  		/* bc 12, CR6_LT, 16 */
		/* 8209BADCh case    7:*/		if ( regs.CR[6].lt ) { return 0x8209BAEC;  }
		/* 8209BADCh case    7:*/		return 0x8209BAE0;
		  /* 8209BAE0h */ case    8:  		/* lwz R10, <#[R8]> */
		/* 8209BAE0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8209BAE0h case    8:*/		return 0x8209BAE4;
		  /* 8209BAE4h */ case    9:  		/* stw R10, <#[R11]> */
		/* 8209BAE4h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209BAE4h case    9:*/		return 0x8209BAE8;
		  /* 8209BAE8h */ case   10:  		/* b 8 */
		/* 8209BAE8h case   10:*/		return 0x8209BAF0;
		/* 8209BAE8h case   10:*/		return 0x8209BAEC;
	}
	return 0x8209BAEC;
} // Block from 8209BAC0h-8209BAECh (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209BAECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BAEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BAEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BAEC);
		  /* 8209BAECh */ case    0:  		/* stw R23, <#[R11]> */
		/* 8209BAECh case    0:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 8209BAECh case    0:*/		return 0x8209BAF0;
	}
	return 0x8209BAF0;
} // Block from 8209BAECh-8209BAF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209BAF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BAF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BAF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BAF0);
		  /* 8209BAF0h */ case    0:  		/* addi R9, R9, -1 */
		/* 8209BAF0h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8209BAF0h case    0:*/		return 0x8209BAF4;
		  /* 8209BAF4h */ case    1:  		/* addi R8, R8, -4 */
		/* 8209BAF4h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFC);
		/* 8209BAF4h case    1:*/		return 0x8209BAF8;
		  /* 8209BAF8h */ case    2:  		/* addi R11, R11, -4 */
		/* 8209BAF8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8209BAF8h case    2:*/		return 0x8209BAFC;
		  /* 8209BAFCh */ case    3:  		/* bc 16, CR0_LT, -36 */
		/* 8209BAFCh case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209BAD8;  }
		/* 8209BAFCh case    3:*/		return 0x8209BB00;
		  /* 8209BB00h */ case    4:  		/* lwz R11, <#[R20 + 20]> */
		/* 8209BB00h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000014) );
		/* 8209BB00h case    4:*/		return 0x8209BB04;
		  /* 8209BB04h */ case    5:  		/* add R5, R11, R5 */
		/* 8209BB04h case    5:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R5);
		/* 8209BB04h case    5:*/		return 0x8209BB08;
		  /* 8209BB08h */ case    6:  		/* b 184 */
		/* 8209BB08h case    6:*/		return 0x8209BBC0;
		/* 8209BB08h case    6:*/		return 0x8209BB0C;
	}
	return 0x8209BB0C;
} // Block from 8209BAF0h-8209BB0Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209BB0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BB0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BB0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BB0C);
		  /* 8209BB0Ch */ case    0:  		/* srawi R11, R21, 5 */
		/* 8209BB0Ch case    0:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R21);
		/* 8209BB0Ch case    0:*/		return 0x8209BB10;
		  /* 8209BB10h */ case    1:  		/* lwz R7, <#[R1 - 152]> */
		/* 8209BB10h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0xFFFFFF68) );
		/* 8209BB10h case    1:*/		return 0x8209BB14;
		  /* 8209BB14h */ case    2:  		/* li R6, -1 */
		/* 8209BB14h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFFFFF);
		/* 8209BB14h case    2:*/		return 0x8209BB18;
		  /* 8209BB18h */ case    3:  		/* lwz R9, <#[R20 + 20]> */
		/* 8209BB18h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R20 + 0x00000014) );
		/* 8209BB18h case    3:*/		return 0x8209BB1C;
		  /* 8209BB1Ch */ case    4:  		/* addze R3, R11 */
		/* 8209BB1Ch case    4:*/		cpu::op::addze<0>(regs,&regs.R3,regs.R11);
		/* 8209BB1Ch case    4:*/		return 0x8209BB20;
		  /* 8209BB20h */ case    5:  		/* srawi R11, R21, 5 */
		/* 8209BB20h case    5:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R21);
		/* 8209BB20h case    5:*/		return 0x8209BB24;
		  /* 8209BB24h */ case    6:  		/* rlwinm R10, R7, 0, 1, 31 */
		/* 8209BB24h case    6:*/		cpu::op::rlwinm<0,0,1,31>(regs,&regs.R10,regs.R7);
		/* 8209BB24h case    6:*/		return 0x8209BB28;
		  /* 8209BB28h */ case    7:  		/* addze R11, R11 */
		/* 8209BB28h case    7:*/		cpu::op::addze<0>(regs,&regs.R11,regs.R11);
		/* 8209BB28h case    7:*/		return 0x8209BB2C;
		  /* 8209BB2Ch */ case    8:  		/* stw R10, <#[R1 - 152]> */
		/* 8209BB2Ch case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0xFFFFFF68) );
		/* 8209BB2Ch case    8:*/		return 0x8209BB30;
		  /* 8209BB30h */ case    9:  		/* addi R8, R1, -152 */
		/* 8209BB30h case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xFFFFFF68);
		/* 8209BB30h case    9:*/		return 0x8209BB34;
		  /* 8209BB34h */ case   10:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 8209BB34h case   10:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 8209BB34h case   10:*/		return 0x8209BB38;
		  /* 8209BB38h */ case   11:  		/* add R5, R9, R30 */
		/* 8209BB38h case   11:*/		cpu::op::add<0>(regs,&regs.R5,regs.R9,regs.R30);
		/* 8209BB38h case   11:*/		return 0x8209BB3C;
		  /* 8209BB3Ch */ case   12:  		/* subf R11, R11, R21 */
		/* 8209BB3Ch case   12:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R21);
		/* 8209BB3Ch case   12:*/		return 0x8209BB40;
		  /* 8209BB40h */ case   13:  		/* mr R9, R23 */
		/* 8209BB40h case   13:*/		regs.R9 = regs.R23;
		/* 8209BB40h case   13:*/		return 0x8209BB44;
		  /* 8209BB44h */ case   14:  		/* slw R10, R6, R11 */
		/* 8209BB44h case   14:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R6,regs.R11);
		/* 8209BB44h case   14:*/		return 0x8209BB48;
		  /* 8209BB48h */ case   15:  		/* nor R7, R10, R10 */
		/* 8209BB48h case   15:*/		cpu::op::nor<0>(regs,&regs.R7,regs.R10,regs.R10);
		/* 8209BB48h case   15:*/		return 0x8209BB4C;
		  /* 8209BB4Ch */ case   16:  		/* subfic R6, R11, 32 */
		/* 8209BB4Ch case   16:*/		cpu::op::subfic<0>(regs,&regs.R6,regs.R11,0x20);
		/* 8209BB4Ch case   16:*/		return 0x8209BB50;
		  /* 8209BB50h */ case   17:  		/* addi R10, R8, -4 */
		/* 8209BB50h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R8,0xFFFFFFFC);
		/* 8209BB50h case   17:*/		return 0x8209BB54;
		  /* 8209BB54h */ case   18:  		/* lwz R8, <#[R10 + 4]> */
		/* 8209BB54h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 8209BB54h case   18:*/		return 0x8209BB58;
		  /* 8209BB58h */ case   19:  		/* and R31, R8, R7 */
		/* 8209BB58h case   19:*/		cpu::op::and<0>(regs,&regs.R31,regs.R8,regs.R7);
		/* 8209BB58h case   19:*/		return 0x8209BB5C;
		  /* 8209BB5Ch */ case   20:  		/* stw R31, <#[R1 - 160]> */
		/* 8209BB5Ch case   20:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8209BB5Ch case   20:*/		return 0x8209BB60;
		  /* 8209BB60h */ case   21:  		/* srw R8, R8, R11 */
		/* 8209BB60h case   21:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 8209BB60h case   21:*/		return 0x8209BB64;
		  /* 8209BB64h */ case   22:  		/* or R9, R8, R9 */
		/* 8209BB64h case   22:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8209BB64h case   22:*/		return 0x8209BB68;
	}
	return 0x8209BB68;
} // Block from 8209BB0Ch-8209BB68h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8209BB68h
// Function '_fptostr'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BB68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BB68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BB68);
		  /* 8209BB68h */ case    0:  		/* stwu R9, <#[R10 + 4]> */
		/* 8209BB68h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8209BB68h case    0:*/		return 0x8209BB6C;
		  /* 8209BB6Ch */ case    1:  		/* lwz R9, <#[R1 - 160]> */
		/* 8209BB6Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8209BB6Ch case    1:*/		return 0x8209BB70;
		  /* 8209BB70h */ case    2:  		/* slw R9, R9, R6 */
		/* 8209BB70h case    2:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R6);
		/* 8209BB70h case    2:*/		return 0x8209BB74;
		  /* 8209BB74h */ case    3:  		/* bc 16, CR0_LT, -32 */
		/* 8209BB74h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209BB54;  }
		/* 8209BB74h case    3:*/		return 0x8209BB78;
		  /* 8209BB78h */ case    4:  		/* li R10, 3 */
		/* 8209BB78h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 8209BB78h case    4:*/		return 0x8209BB7C;
		  /* 8209BB7Ch */ case    5:  		/* rlwinm R8, R3, 2, 0, 29 */
		/* 8209BB7Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R3);
		/* 8209BB7Ch case    5:*/		return 0x8209BB80;
		  /* 8209BB80h */ case    6:  		/* addi R7, R1, -144 */
		/* 8209BB80h case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xFFFFFF70);
		/* 8209BB80h case    6:*/		return 0x8209BB84;
		  /* 8209BB84h */ case    7:  		/* li R9, 2 */
		/* 8209BB84h case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 8209BB84h case    7:*/		return 0x8209BB88;
		  /* 8209BB88h */ case    8:  		/* addi R11, R1, -144 */
		/* 8209BB88h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xFFFFFF70);
		/* 8209BB88h case    8:*/		return 0x8209BB8C;
		  /* 8209BB8Ch */ case    9:  		/* subf R8, R8, R7 */
		/* 8209BB8Ch case    9:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8209BB8Ch case    9:*/		return 0x8209BB90;
		  /* 8209BB90h */ case   10:  		/* mtspr CTR, R10 */
		/* 8209BB90h case   10:*/		regs.CTR = regs.R10;
		/* 8209BB90h case   10:*/		return 0x8209BB94;
		  /* 8209BB94h */ case   11:  		/* cmpw CR6, R9, R3 */
		/* 8209BB94h case   11:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R3);
		/* 8209BB94h case   11:*/		return 0x8209BB98;
		  /* 8209BB98h */ case   12:  		/* bc 12, CR6_LT, 16 */
		/* 8209BB98h case   12:*/		if ( regs.CR[6].lt ) { return 0x8209BBA8;  }
		/* 8209BB98h case   12:*/		return 0x8209BB9C;
		  /* 8209BB9Ch */ case   13:  		/* lwz R10, <#[R8]> */
		/* 8209BB9Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8209BB9Ch case   13:*/		return 0x8209BBA0;
		  /* 8209BBA0h */ case   14:  		/* stw R10, <#[R11]> */
		/* 8209BBA0h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209BBA0h case   14:*/		return 0x8209BBA4;
		  /* 8209BBA4h */ case   15:  		/* b 8 */
		/* 8209BBA4h case   15:*/		return 0x8209BBAC;
		/* 8209BBA4h case   15:*/		return 0x8209BBA8;
	}
	return 0x8209BBA8;
} // Block from 8209BB68h-8209BBA8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8209BBA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BBA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BBA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BBA8);
		  /* 8209BBA8h */ case    0:  		/* stw R23, <#[R11]> */
		/* 8209BBA8h case    0:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 8209BBA8h case    0:*/		return 0x8209BBAC;
	}
	return 0x8209BBAC;
} // Block from 8209BBA8h-8209BBACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209BBACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BBAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BBAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BBAC);
		  /* 8209BBACh */ case    0:  		/* addi R9, R9, -1 */
		/* 8209BBACh case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8209BBACh case    0:*/		return 0x8209BBB0;
		  /* 8209BBB0h */ case    1:  		/* addi R8, R8, -4 */
		/* 8209BBB0h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFC);
		/* 8209BBB0h case    1:*/		return 0x8209BBB4;
		  /* 8209BBB4h */ case    2:  		/* addi R11, R11, -4 */
		/* 8209BBB4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8209BBB4h case    2:*/		return 0x8209BBB8;
		  /* 8209BBB8h */ case    3:  		/* bc 16, CR0_LT, -36 */
		/* 8209BBB8h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209BB94;  }
		/* 8209BBB8h case    3:*/		return 0x8209BBBC;
	}
	return 0x8209BBBC;
} // Block from 8209BBACh-8209BBBCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209BBBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BBBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BBBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BBBC);
		  /* 8209BBBCh */ case    0:  		/* mr R3, R23 */
		/* 8209BBBCh case    0:*/		regs.R3 = regs.R23;
		/* 8209BBBCh case    0:*/		return 0x8209BBC0;
	}
	return 0x8209BBC0;
} // Block from 8209BBBCh-8209BBC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209BBC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BBC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BBC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BBC0);
		  /* 8209BBC0h */ case    0:  		/* subfic R10, R21, 31 */
		/* 8209BBC0h case    0:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R21,0x1F);
		/* 8209BBC0h case    0:*/		return 0x8209BBC4;
		  /* 8209BBC4h */ case    1:  		/* lwz R11, <#[R20 + 16]> */
		/* 8209BBC4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000010) );
		/* 8209BBC4h case    1:*/		return 0x8209BBC8;
		  /* 8209BBC8h */ case    2:  		/* subfic R9, R19, 0 */
		/* 8209BBC8h case    2:*/		cpu::op::subfic<0>(regs,&regs.R9,regs.R19,0x0);
		/* 8209BBC8h case    2:*/		return 0x8209BBCC;
		  /* 8209BBCCh */ case    3:  		/* lwz R8, <#[R1 - 152]> */
		/* 8209BBCCh case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0xFFFFFF68) );
		/* 8209BBCCh case    3:*/		return 0x8209BBD0;
		  /* 8209BBD0h */ case    4:  		/* lis R7, -32768 */
		/* 8209BBD0h case    4:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8000);
		/* 8209BBD0h case    4:*/		return 0x8209BBD4;
		  /* 8209BBD4h */ case    5:  		/* subfe R9, R9, R9 */
		/* 8209BBD4h case    5:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 8209BBD4h case    5:*/		return 0x8209BBD8;
		  /* 8209BBD8h */ case    6:  		/* slw R10, R5, R10 */
		/* 8209BBD8h case    6:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R5,regs.R10);
		/* 8209BBD8h case    6:*/		return 0x8209BBDC;
		  /* 8209BBDCh */ case    7:  		/* and R9, R9, R7 */
		/* 8209BBDCh case    7:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 8209BBDCh case    7:*/		return 0x8209BBE0;
		  /* 8209BBE0h */ case    8:  		/* cmpwi CR6, R11, 64 */
		/* 8209BBE0h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000040);
		/* 8209BBE0h case    8:*/		return 0x8209BBE4;
		  /* 8209BBE4h */ case    9:  		/* or R10, R10, R9 */
		/* 8209BBE4h case    9:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8209BBE4h case    9:*/		return 0x8209BBE8;
		  /* 8209BBE8h */ case   10:  		/* or R10, R10, R8 */
		/* 8209BBE8h case   10:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8209BBE8h case   10:*/		return 0x8209BBEC;
		  /* 8209BBECh */ case   11:  		/* bc 4, CR6_EQ, 16 */
		/* 8209BBECh case   11:*/		if ( !regs.CR[6].eq ) { return 0x8209BBFC;  }
		/* 8209BBECh case   11:*/		return 0x8209BBF0;
		  /* 8209BBF0h */ case   12:  		/* lwz R11, <#[R1 - 148]> */
		/* 8209BBF0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0xFFFFFF6C) );
		/* 8209BBF0h case   12:*/		return 0x8209BBF4;
		  /* 8209BBF4h */ case   13:  		/* stw R11, <#[R4 + 4]> */
		/* 8209BBF4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 8209BBF4h case   13:*/		return 0x8209BBF8;
		  /* 8209BBF8h */ case   14:  		/* b 12 */
		/* 8209BBF8h case   14:*/		return 0x8209BC04;
		/* 8209BBF8h case   14:*/		return 0x8209BBFC;
	}
	return 0x8209BBFC;
} // Block from 8209BBC0h-8209BBFCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 8209BBFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BBFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BBFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BBFC);
		  /* 8209BBFCh */ case    0:  		/* cmpwi CR6, R11, 32 */
		/* 8209BBFCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000020);
		/* 8209BBFCh case    0:*/		return 0x8209BC00;
		  /* 8209BC00h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 8209BC00h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209BC08;  }
		/* 8209BC00h case    1:*/		return 0x8209BC04;
	}
	return 0x8209BC04;
} // Block from 8209BBFCh-8209BC04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209BC04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BC04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BC04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BC04);
		  /* 8209BC04h */ case    0:  		/* stw R10, <#[R4]> */
		/* 8209BC04h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 8209BC04h case    0:*/		return 0x8209BC08;
	}
	return 0x8209BC08;
} // Block from 8209BC04h-8209BC08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209BC08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BC08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BC08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BC08);
		  /* 8209BC08h */ case    0:  		/* b -43396 */
		/* 8209BC08h case    0:*/		return 0x82091284;
		/* 8209BC08h case    0:*/		return 0x8209BC0C;
		  /* 8209BC0Ch */ case    1:  		/* nop */
		/* 8209BC0Ch case    1:*/		cpu::op::nop();
		/* 8209BC0Ch case    1:*/		return 0x8209BC10;
	}
	return 0x8209BC10;
} // Block from 8209BC08h-8209BC10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209BC10h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BC10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BC10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BC10);
		  /* 8209BC10h */ case    0:  		/* mfspr R12, LR */
		/* 8209BC10h case    0:*/		regs.R12 = regs.LR;
		/* 8209BC10h case    0:*/		return 0x8209BC14;
		  /* 8209BC14h */ case    1:  		/* bl -43488 */
		/* 8209BC14h case    1:*/		regs.LR = 0x8209BC18; return 0x82091234;
		/* 8209BC14h case    1:*/		return 0x8209BC18;
		  /* 8209BC18h */ case    2:  		/* lhz R9, <#[R3]> */
		/* 8209BC18h case    2:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 8209BC18h case    2:*/		return 0x8209BC1C;
		  /* 8209BC1Ch */ case    3:  		/* lis R10, -32217 */
		/* 8209BC1Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 8209BC1Ch case    3:*/		return 0x8209BC20;
		  /* 8209BC20h */ case    4:  		/* lhz R8, <#[R3 + 10]> */
		/* 8209BC20h case    4:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R3 + 0x0000000A) );
		/* 8209BC20h case    4:*/		return 0x8209BC24;
		  /* 8209BC24h */ case    5:  		/* li R23, 0 */
		/* 8209BC24h case    5:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 8209BC24h case    5:*/		return 0x8209BC28;
		  /* 8209BC28h */ case    6:  		/* rlwinm R11, R9, 0, 17, 31 */
		/* 8209BC28h case    6:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R11,regs.R9);
		/* 8209BC28h case    6:*/		return 0x8209BC2C;
		  /* 8209BC2Ch */ case    7:  		/* lwz R7, <#[R3 + 2]> */
		/* 8209BC2Ch case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000002) );
		/* 8209BC2Ch case    7:*/		return 0x8209BC30;
		  /* 8209BC30h */ case    8:  		/* lwz R6, <#[R3 + 6]> */
		/* 8209BC30h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000006) );
		/* 8209BC30h case    8:*/		return 0x8209BC34;
		  /* 8209BC34h */ case    9:  		/* addi R20, R10, 10244 */
		/* 8209BC34h case    9:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R10,0x2804);
		/* 8209BC34h case    9:*/		return 0x8209BC38;
		  /* 8209BC38h */ case   10:  		/* addi R30, R11, -16383 */
		/* 8209BC38h case   10:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFC001);
		/* 8209BC38h case   10:*/		return 0x8209BC3C;
		  /* 8209BC3Ch */ case   11:  		/* rlwinm R11, R8, 16, 0, 31 */
		/* 8209BC3Ch case   11:*/		cpu::op::rlwinm<0,16,0,31>(regs,&regs.R11,regs.R8);
		/* 8209BC3Ch case   11:*/		return 0x8209BC40;
		  /* 8209BC40h */ case   12:  		/* rlwinm R19, R9, 0, 0, 16 */
		/* 8209BC40h case   12:*/		cpu::op::rlwinm<0,0,0,16>(regs,&regs.R19,regs.R9);
		/* 8209BC40h case   12:*/		return 0x8209BC44;
		  /* 8209BC44h */ case   13:  		/* stw R7, <#[R1 - 152]> */
		/* 8209BC44h case   13:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0xFFFFFF68) );
		/* 8209BC44h case   13:*/		return 0x8209BC48;
		  /* 8209BC48h */ case   14:  		/* cmpwi CR6, R30, -16383 */
		/* 8209BC48h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R30,0xFFFFC001);
		/* 8209BC48h case   14:*/		return 0x8209BC4C;
		  /* 8209BC4Ch */ case   15:  		/* lwz R21, <#[R20 + 12]> */
		/* 8209BC4Ch case   15:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R20 + 0x0000000C) );
		/* 8209BC4Ch case   15:*/		return 0x8209BC50;
		  /* 8209BC50h */ case   16:  		/* addi R10, R1, -152 */
		/* 8209BC50h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFF68);
		/* 8209BC50h case   16:*/		return 0x8209BC54;
		  /* 8209BC54h */ case   17:  		/* stw R6, <#[R1 - 148]> */
		/* 8209BC54h case   17:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0xFFFFFF6C) );
		/* 8209BC54h case   17:*/		return 0x8209BC58;
		  /* 8209BC58h */ case   18:  		/* mr R5, R23 */
		/* 8209BC58h case   18:*/		regs.R5 = regs.R23;
		/* 8209BC58h case   18:*/		return 0x8209BC5C;
		  /* 8209BC5Ch */ case   19:  		/* stw R11, <#[R1 - 144]> */
		/* 8209BC5Ch case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFF70) );
		/* 8209BC5Ch case   19:*/		return 0x8209BC60;
		  /* 8209BC60h */ case   20:  		/* bc 4, CR6_EQ, 64 */
		/* 8209BC60h case   20:*/		if ( !regs.CR[6].eq ) { return 0x8209BCA0;  }
		/* 8209BC60h case   20:*/		return 0x8209BC64;
		  /* 8209BC64h */ case   21:  		/* mr R11, R23 */
		/* 8209BC64h case   21:*/		regs.R11 = regs.R23;
		/* 8209BC64h case   21:*/		return 0x8209BC68;
		  /* 8209BC68h */ case   22:  		/* lwz R9, <#[R10]> */
		/* 8209BC68h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8209BC68h case   22:*/		return 0x8209BC6C;
		  /* 8209BC6Ch */ case   23:  		/* cmplwi CR6, R9, 0 */
		/* 8209BC6Ch case   23:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8209BC6Ch case   23:*/		return 0x8209BC70;
		  /* 8209BC70h */ case   24:  		/* bc 4, CR6_EQ, 24 */
		/* 8209BC70h case   24:*/		if ( !regs.CR[6].eq ) { return 0x8209BC88;  }
		/* 8209BC70h case   24:*/		return 0x8209BC74;
		  /* 8209BC74h */ case   25:  		/* addi R11, R11, 1 */
		/* 8209BC74h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209BC74h case   25:*/		return 0x8209BC78;
		  /* 8209BC78h */ case   26:  		/* addi R10, R10, 4 */
		/* 8209BC78h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8209BC78h case   26:*/		return 0x8209BC7C;
		  /* 8209BC7Ch */ case   27:  		/* cmpwi CR6, R11, 3 */
		/* 8209BC7Ch case   27:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8209BC7Ch case   27:*/		return 0x8209BC80;
		  /* 8209BC80h */ case   28:  		/* bc 12, CR6_LT, -24 */
		/* 8209BC80h case   28:*/		if ( regs.CR[6].lt ) { return 0x8209BC68;  }
		/* 8209BC80h case   28:*/		return 0x8209BC84;
		  /* 8209BC84h */ case   29:  		/* b 1616 */
		/* 8209BC84h case   29:*/		return 0x8209C2D4;
		/* 8209BC84h case   29:*/		return 0x8209BC88;
	}
	return 0x8209BC88;
} // Block from 8209BC10h-8209BC88h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8209BC88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BC88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BC88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BC88);
		  /* 8209BC88h */ case    0:  		/* addi R11, R1, -152 */
		/* 8209BC88h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xFFFFFF68);
		/* 8209BC88h case    0:*/		return 0x8209BC8C;
		  /* 8209BC8Ch */ case    1:  		/* li R3, 2 */
		/* 8209BC8Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 8209BC8Ch case    1:*/		return 0x8209BC90;
		  /* 8209BC90h */ case    2:  		/* stw R23, <#[R11]> */
		/* 8209BC90h case    2:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 8209BC90h case    2:*/		return 0x8209BC94;
		  /* 8209BC94h */ case    3:  		/* stw R23, <#[R11 + 4]> */
		/* 8209BC94h case    3:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000004) );
		/* 8209BC94h case    3:*/		return 0x8209BC98;
		  /* 8209BC98h */ case    4:  		/* stw R23, <#[R11 + 8]> */
		/* 8209BC98h case    4:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000008) );
		/* 8209BC98h case    4:*/		return 0x8209BC9C;
		  /* 8209BC9Ch */ case    5:  		/* b 1596 */
		/* 8209BC9Ch case    5:*/		return 0x8209C2D8;
		/* 8209BC9Ch case    5:*/		return 0x8209BCA0;
	}
	return 0x8209BCA0;
} // Block from 8209BC88h-8209BCA0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209BCA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BCA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BCA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BCA0);
		  /* 8209BCA0h */ case    0:  		/* lwz R25, <#[R20 + 8]> */
		/* 8209BCA0h case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R20 + 0x00000008) );
		/* 8209BCA0h case    0:*/		return 0x8209BCA4;
		  /* 8209BCA4h */ case    1:  		/* addi R8, R1, -136 */
		/* 8209BCA4h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xFFFFFF78);
		/* 8209BCA4h case    1:*/		return 0x8209BCA8;
		  /* 8209BCA8h */ case    2:  		/* lwz R9, <#[R10]> */
		/* 8209BCA8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8209BCA8h case    2:*/		return 0x8209BCAC;
		  /* 8209BCACh */ case    3:  		/* addi R28, R1, -152 */
		/* 8209BCACh case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0xFFFFFF68);
		/* 8209BCACh case    3:*/		return 0x8209BCB0;
		  /* 8209BCB0h */ case    4:  		/* addi R26, R25, -1 */
		/* 8209BCB0h case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R25,0xFFFFFFFF);
		/* 8209BCB0h case    4:*/		return 0x8209BCB4;
		  /* 8209BCB4h */ case    5:  		/* lwz R6, <#[R10 + 4]> */
		/* 8209BCB4h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 8209BCB4h case    5:*/		return 0x8209BCB8;
		  /* 8209BCB8h */ case    6:  		/* lwz R10, <#[R10 + 8]> */
		/* 8209BCB8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8209BCB8h case    6:*/		return 0x8209BCBC;
		  /* 8209BCBCh */ case    7:  		/* li R3, 1 */
		/* 8209BCBCh case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8209BCBCh case    7:*/		return 0x8209BCC0;
		  /* 8209BCC0h */ case    8:  		/* addi R11, R26, 1 */
		/* 8209BCC0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x1);
		/* 8209BCC0h case    8:*/		return 0x8209BCC4;
		  /* 8209BCC4h */ case    9:  		/* li R22, -1 */
		/* 8209BCC4h case    9:*/		cpu::op::li<0>(regs,&regs.R22,0xFFFFFFFF);
		/* 8209BCC4h case    9:*/		return 0x8209BCC8;
	}
	return 0x8209BCC8;
} // Block from 8209BCA0h-8209BCC8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209BCC8h
// Function '__dtold'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BCC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BCC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BCC8);
		  /* 8209BCC8h */ case    0:  		/* srawi R7, R11, 5 */
		/* 8209BCC8h case    0:*/		cpu::op::srawi<0,5>(regs,&regs.R7,regs.R11);
		/* 8209BCC8h case    0:*/		return 0x8209BCCC;
		  /* 8209BCCCh */ case    1:  		/* stw R9, <#[R8]> */
		/* 8209BCCCh case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 8209BCCCh case    1:*/		return 0x8209BCD0;
		  /* 8209BCD0h */ case    2:  		/* stw R6, <#[R8 + 4]> */
		/* 8209BCD0h case    2:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R8 + 0x00000004) );
		/* 8209BCD0h case    2:*/		return 0x8209BCD4;
		  /* 8209BCD4h */ case    3:  		/* mr R24, R30 */
		/* 8209BCD4h case    3:*/		regs.R24 = regs.R30;
		/* 8209BCD4h case    3:*/		return 0x8209BCD8;
		  /* 8209BCD8h */ case    4:  		/* addze R31, R7 */
		/* 8209BCD8h case    4:*/		cpu::op::addze<0>(regs,&regs.R31,regs.R7);
		/* 8209BCD8h case    4:*/		return 0x8209BCDC;
		  /* 8209BCDCh */ case    5:  		/* stw R10, <#[R8 + 8]> */
		/* 8209BCDCh case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000008) );
		/* 8209BCDCh case    5:*/		return 0x8209BCE0;
		  /* 8209BCE0h */ case    6:  		/* srawi R7, R11, 5 */
		/* 8209BCE0h case    6:*/		cpu::op::srawi<0,5>(regs,&regs.R7,regs.R11);
		/* 8209BCE0h case    6:*/		return 0x8209BCE4;
		  /* 8209BCE4h */ case    7:  		/* rlwinm R27, R31, 2, 0, 29 */
		/* 8209BCE4h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R31);
		/* 8209BCE4h case    7:*/		return 0x8209BCE8;
		  /* 8209BCE8h */ case    8:  		/* addze R9, R7 */
		/* 8209BCE8h case    8:*/		cpu::op::addze<0>(regs,&regs.R9,regs.R7);
		/* 8209BCE8h case    8:*/		return 0x8209BCEC;
		  /* 8209BCECh */ case    9:  		/* rlwinm R10, R9, 5, 0, 26 */
		/* 8209BCECh case    9:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R9);
		/* 8209BCECh case    9:*/		return 0x8209BCF0;
		  /* 8209BCF0h */ case   10:  		/* subf R11, R10, R11 */
		/* 8209BCF0h case   10:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8209BCF0h case   10:*/		return 0x8209BCF4;
		  /* 8209BCF4h */ case   11:  		/* lwzx R10, <#[R27 + R28]> */
		/* 8209BCF4h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + regs.R28 + 0x00000000) );
		/* 8209BCF4h case   11:*/		return 0x8209BCF8;
		  /* 8209BCF8h */ case   12:  		/* subfic R29, R11, 31 */
		/* 8209BCF8h case   12:*/		cpu::op::subfic<0>(regs,&regs.R29,regs.R11,0x1F);
		/* 8209BCF8h case   12:*/		return 0x8209BCFC;
		  /* 8209BCFCh */ case   13:  		/* slw R11, R3, R29 */
		/* 8209BCFCh case   13:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R3,regs.R29);
		/* 8209BCFCh case   13:*/		return 0x8209BD00;
		  /* 8209BD00h */ case   14:  		/* and. R11, R11, R10 */
		/* 8209BD00h case   14:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8209BD00h case   14:*/		return 0x8209BD04;
		  /* 8209BD04h */ case   15:  		/* bc 12, CR0_EQ, 232 */
		/* 8209BD04h case   15:*/		if ( regs.CR[0].eq ) { return 0x8209BDEC;  }
		/* 8209BD04h case   15:*/		return 0x8209BD08;
		  /* 8209BD08h */ case   16:  		/* rlwinm R11, R31, 2, 0, 29 */
		/* 8209BD08h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R31);
		/* 8209BD08h case   16:*/		return 0x8209BD0C;
		  /* 8209BD0Ch */ case   17:  		/* addi R10, R1, -152 */
		/* 8209BD0Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFF68);
		/* 8209BD0Ch case   17:*/		return 0x8209BD10;
		  /* 8209BD10h */ case   18:  		/* slw R9, R22, R29 */
		/* 8209BD10h case   18:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R22,regs.R29);
		/* 8209BD10h case   18:*/		return 0x8209BD14;
		  /* 8209BD14h */ case   19:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8209BD14h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8209BD14h case   19:*/		return 0x8209BD18;
		  /* 8209BD18h */ case   20:  		/* andc. R11, R11, R9 */
		/* 8209BD18h case   20:*/		cpu::op::andc<1>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8209BD18h case   20:*/		return 0x8209BD1C;
		  /* 8209BD1Ch */ case   21:  		/* bc 4, CR0_EQ, 60 */
		/* 8209BD1Ch case   21:*/		if ( !regs.CR[0].eq ) { return 0x8209BD58;  }
		/* 8209BD1Ch case   21:*/		return 0x8209BD20;
		  /* 8209BD20h */ case   22:  		/* addi R11, R31, 1 */
		/* 8209BD20h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x1);
		/* 8209BD20h case   22:*/		return 0x8209BD24;
		  /* 8209BD24h */ case   23:  		/* cmpwi CR6, R11, 3 */
		/* 8209BD24h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8209BD24h case   23:*/		return 0x8209BD28;
		  /* 8209BD28h */ case   24:  		/* bc 4, CR6_LT, 196 */
		/* 8209BD28h case   24:*/		if ( !regs.CR[6].lt ) { return 0x8209BDEC;  }
		/* 8209BD28h case   24:*/		return 0x8209BD2C;
		  /* 8209BD2Ch */ case   25:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8209BD2Ch case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8209BD2Ch case   25:*/		return 0x8209BD30;
		  /* 8209BD30h */ case   26:  		/* addi R10, R1, -152 */
		/* 8209BD30h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFF68);
		/* 8209BD30h case   26:*/		return 0x8209BD34;
		  /* 8209BD34h */ case   27:  		/* add R10, R9, R10 */
		/* 8209BD34h case   27:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8209BD34h case   27:*/		return 0x8209BD38;
		  /* 8209BD38h */ case   28:  		/* lwz R9, <#[R10]> */
		/* 8209BD38h case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8209BD38h case   28:*/		return 0x8209BD3C;
		  /* 8209BD3Ch */ case   29:  		/* cmplwi CR6, R9, 0 */
		/* 8209BD3Ch case   29:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8209BD3Ch case   29:*/		return 0x8209BD40;
		  /* 8209BD40h */ case   30:  		/* bc 4, CR6_EQ, 24 */
		/* 8209BD40h case   30:*/		if ( !regs.CR[6].eq ) { return 0x8209BD58;  }
		/* 8209BD40h case   30:*/		return 0x8209BD44;
		  /* 8209BD44h */ case   31:  		/* addi R11, R11, 1 */
		/* 8209BD44h case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209BD44h case   31:*/		return 0x8209BD48;
		  /* 8209BD48h */ case   32:  		/* addi R10, R10, 4 */
		/* 8209BD48h case   32:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8209BD48h case   32:*/		return 0x8209BD4C;
		  /* 8209BD4Ch */ case   33:  		/* cmpwi CR6, R11, 3 */
		/* 8209BD4Ch case   33:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8209BD4Ch case   33:*/		return 0x8209BD50;
		  /* 8209BD50h */ case   34:  		/* bc 12, CR6_LT, -24 */
		/* 8209BD50h case   34:*/		if ( regs.CR[6].lt ) { return 0x8209BD38;  }
		/* 8209BD50h case   34:*/		return 0x8209BD54;
		  /* 8209BD54h */ case   35:  		/* b 152 */
		/* 8209BD54h case   35:*/		return 0x8209BDEC;
		/* 8209BD54h case   35:*/		return 0x8209BD58;
	}
	return 0x8209BD58;
} // Block from 8209BCC8h-8209BD58h (36 instructions)

//////////////////////////////////////////////////////
// Block at 8209BD58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BD58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BD58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BD58);
		  /* 8209BD58h */ case    0:  		/* srawi R11, R26, 5 */
		/* 8209BD58h case    0:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R26);
		/* 8209BD58h case    0:*/		return 0x8209BD5C;
		  /* 8209BD5Ch */ case    1:  		/* addi R8, R1, -152 */
		/* 8209BD5Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xFFFFFF68);
		/* 8209BD5Ch case    1:*/		return 0x8209BD60;
		  /* 8209BD60h */ case    2:  		/* addze R9, R11 */
		/* 8209BD60h case    2:*/		cpu::op::addze<0>(regs,&regs.R9,regs.R11);
		/* 8209BD60h case    2:*/		return 0x8209BD64;
		  /* 8209BD64h */ case    3:  		/* srawi R11, R26, 5 */
		/* 8209BD64h case    3:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R26);
		/* 8209BD64h case    3:*/		return 0x8209BD68;
		  /* 8209BD68h */ case    4:  		/* rlwinm R7, R9, 2, 0, 29 */
		/* 8209BD68h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R9);
		/* 8209BD68h case    4:*/		return 0x8209BD6C;
		  /* 8209BD6Ch */ case    5:  		/* addze R11, R11 */
		/* 8209BD6Ch case    5:*/		cpu::op::addze<0>(regs,&regs.R11,regs.R11);
		/* 8209BD6Ch case    5:*/		return 0x8209BD70;
		  /* 8209BD70h */ case    6:  		/* mr R5, R23 */
		/* 8209BD70h case    6:*/		regs.R5 = regs.R23;
		/* 8209BD70h case    6:*/		return 0x8209BD74;
		  /* 8209BD74h */ case    7:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 8209BD74h case    7:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 8209BD74h case    7:*/		return 0x8209BD78;
		  /* 8209BD78h */ case    8:  		/* subf R10, R11, R26 */
		/* 8209BD78h case    8:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R26);
		/* 8209BD78h case    8:*/		return 0x8209BD7C;
		  /* 8209BD7Ch */ case    9:  		/* lwzx R11, <#[R7 + R8]> */
		/* 8209BD7Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 8209BD7Ch case    9:*/		return 0x8209BD80;
		  /* 8209BD80h */ case   10:  		/* subfic R10, R10, 31 */
		/* 8209BD80h case   10:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0x1F);
		/* 8209BD80h case   10:*/		return 0x8209BD84;
		  /* 8209BD84h */ case   11:  		/* slw R6, R3, R10 */
		/* 8209BD84h case   11:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R3,regs.R10);
		/* 8209BD84h case   11:*/		return 0x8209BD88;
		  /* 8209BD88h */ case   12:  		/* add R10, R11, R6 */
		/* 8209BD88h case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R6);
		/* 8209BD88h case   12:*/		return 0x8209BD8C;
		  /* 8209BD8Ch */ case   13:  		/* cmplw CR6, R10, R11 */
		/* 8209BD8Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8209BD8Ch case   13:*/		return 0x8209BD90;
		  /* 8209BD90h */ case   14:  		/* bc 12, CR6_LT, 12 */
		/* 8209BD90h case   14:*/		if ( regs.CR[6].lt ) { return 0x8209BD9C;  }
		/* 8209BD90h case   14:*/		return 0x8209BD94;
		  /* 8209BD94h */ case   15:  		/* cmplw CR6, R10, R6 */
		/* 8209BD94h case   15:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 8209BD94h case   15:*/		return 0x8209BD98;
		  /* 8209BD98h */ case   16:  		/* bc 4, CR6_LT, 8 */
		/* 8209BD98h case   16:*/		if ( !regs.CR[6].lt ) { return 0x8209BDA0;  }
		/* 8209BD98h case   16:*/		return 0x8209BD9C;
	}
	return 0x8209BD9C;
} // Block from 8209BD58h-8209BD9Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8209BD9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BD9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BD9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BD9C);
		  /* 8209BD9Ch */ case    0:  		/* mr R5, R3 */
		/* 8209BD9Ch case    0:*/		regs.R5 = regs.R3;
		/* 8209BD9Ch case    0:*/		return 0x8209BDA0;
	}
	return 0x8209BDA0;
} // Block from 8209BD9Ch-8209BDA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209BDA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BDA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BDA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BDA0);
		  /* 8209BDA0h */ case    0:  		/* addic. R11, R9, -1 */
		/* 8209BDA0h case    0:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 8209BDA0h case    0:*/		return 0x8209BDA4;
		  /* 8209BDA4h */ case    1:  		/* stwx R10, <#[R7 + R8]> */
		/* 8209BDA4h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 8209BDA4h case    1:*/		return 0x8209BDA8;
	}
	return 0x8209BDA8;
} // Block from 8209BDA0h-8209BDA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209BDA8h
// Function '_fltout2'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BDA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BDA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BDA8);
		  /* 8209BDA8h */ case    0:  		/* bc 12, CR0_LT, 68 */
		/* 8209BDA8h case    0:*/		if ( regs.CR[0].lt ) { return 0x8209BDEC;  }
		/* 8209BDA8h case    0:*/		return 0x8209BDAC;
		  /* 8209BDACh */ case    1:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8209BDACh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8209BDACh case    1:*/		return 0x8209BDB0;
		  /* 8209BDB0h */ case    2:  		/* addi R10, R1, -148 */
		/* 8209BDB0h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFF6C);
		/* 8209BDB0h case    2:*/		return 0x8209BDB4;
		  /* 8209BDB4h */ case    3:  		/* add R10, R9, R10 */
		/* 8209BDB4h case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8209BDB4h case    3:*/		return 0x8209BDB8;
		  /* 8209BDB8h */ case    4:  		/* cmpwi CR6, R5, 0 */
		/* 8209BDB8h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 8209BDB8h case    4:*/		return 0x8209BDBC;
		  /* 8209BDBCh */ case    5:  		/* bc 12, CR6_EQ, 48 */
		/* 8209BDBCh case    5:*/		if ( regs.CR[6].eq ) { return 0x8209BDEC;  }
		/* 8209BDBCh case    5:*/		return 0x8209BDC0;
		  /* 8209BDC0h */ case    6:  		/* lwz R9, <#[R10 - 4]> */
		/* 8209BDC0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 8209BDC0h case    6:*/		return 0x8209BDC4;
		  /* 8209BDC4h */ case    7:  		/* mr R5, R23 */
		/* 8209BDC4h case    7:*/		regs.R5 = regs.R23;
		/* 8209BDC4h case    7:*/		return 0x8209BDC8;
		  /* 8209BDC8h */ case    8:  		/* addi R8, R9, 1 */
		/* 8209BDC8h case    8:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0x1);
		/* 8209BDC8h case    8:*/		return 0x8209BDCC;
		  /* 8209BDCCh */ case    9:  		/* cmplw CR6, R8, R9 */
		/* 8209BDCCh case    9:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8209BDCCh case    9:*/		return 0x8209BDD0;
		  /* 8209BDD0h */ case   10:  		/* bc 12, CR6_LT, 12 */
		/* 8209BDD0h case   10:*/		if ( regs.CR[6].lt ) { return 0x8209BDDC;  }
		/* 8209BDD0h case   10:*/		return 0x8209BDD4;
		  /* 8209BDD4h */ case   11:  		/* cmplwi CR6, R8, 1 */
		/* 8209BDD4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000001);
		/* 8209BDD4h case   11:*/		return 0x8209BDD8;
		  /* 8209BDD8h */ case   12:  		/* bc 4, CR6_LT, 8 */
		/* 8209BDD8h case   12:*/		if ( !regs.CR[6].lt ) { return 0x8209BDE0;  }
		/* 8209BDD8h case   12:*/		return 0x8209BDDC;
	}
	return 0x8209BDDC;
} // Block from 8209BDA8h-8209BDDCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209BDDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BDDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BDDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BDDC);
		  /* 8209BDDCh */ case    0:  		/* mr R5, R3 */
		/* 8209BDDCh case    0:*/		regs.R5 = regs.R3;
		/* 8209BDDCh case    0:*/		return 0x8209BDE0;
	}
	return 0x8209BDE0;
} // Block from 8209BDDCh-8209BDE0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209BDE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BDE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BDE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BDE0);
		  /* 8209BDE0h */ case    0:  		/* addic. R11, R11, -1 */
		/* 8209BDE0h case    0:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8209BDE0h case    0:*/		return 0x8209BDE4;
		  /* 8209BDE4h */ case    1:  		/* stwu R8, <#[R10 - 4]> */
		/* 8209BDE4h case    1:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0xFFFFFFFC) );
		regs.R10 = (uint32)(regs.R10 + 0xFFFFFFFC);
		/* 8209BDE4h case    1:*/		return 0x8209BDE8;
		  /* 8209BDE8h */ case    2:  		/* bc 4, CR0_LT, -48 */
		/* 8209BDE8h case    2:*/		if ( !regs.CR[0].lt ) { return 0x8209BDB8;  }
		/* 8209BDE8h case    2:*/		return 0x8209BDEC;
	}
	return 0x8209BDEC;
} // Block from 8209BDE0h-8209BDECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209BDECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BDEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BDEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BDEC);
		  /* 8209BDECh */ case    0:  		/* lwzx R10, <#[R27 + R28]> */
		/* 8209BDECh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + regs.R28 + 0x00000000) );
		/* 8209BDECh case    0:*/		return 0x8209BDF0;
		  /* 8209BDF0h */ case    1:  		/* slw R9, R22, R29 */
		/* 8209BDF0h case    1:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R22,regs.R29);
		/* 8209BDF0h case    1:*/		return 0x8209BDF4;
		  /* 8209BDF4h */ case    2:  		/* addi R11, R31, 1 */
		/* 8209BDF4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x1);
		/* 8209BDF4h case    2:*/		return 0x8209BDF8;
		  /* 8209BDF8h */ case    3:  		/* and R10, R9, R10 */
		/* 8209BDF8h case    3:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8209BDF8h case    3:*/		return 0x8209BDFC;
		  /* 8209BDFCh */ case    4:  		/* cmpwi CR6, R11, 3 */
		/* 8209BDFCh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8209BDFCh case    4:*/		return 0x8209BE00;
		  /* 8209BE00h */ case    5:  		/* stwx R10, <#[R27 + R28]> */
		/* 8209BE00h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R27 + regs.R28 + 0x00000000) );
		/* 8209BE00h case    5:*/		return 0x8209BE04;
		  /* 8209BE04h */ case    6:  		/* bc 4, CR6_LT, 48 */
		/* 8209BE04h case    6:*/		if ( !regs.CR[6].lt ) { return 0x8209BE34;  }
		/* 8209BE04h case    6:*/		return 0x8209BE08;
		  /* 8209BE08h */ case    7:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8209BE08h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8209BE08h case    7:*/		return 0x8209BE0C;
		  /* 8209BE0Ch */ case    8:  		/* addi R10, R1, -152 */
		/* 8209BE0Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFF68);
		/* 8209BE0Ch case    8:*/		return 0x8209BE10;
		  /* 8209BE10h */ case    9:  		/* subfic R11, R11, 3 */
		/* 8209BE10h case    9:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x3);
		/* 8209BE10h case    9:*/		return 0x8209BE14;
		  /* 8209BE14h */ case   10:  		/* add R10, R9, R10 */
		/* 8209BE14h case   10:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8209BE14h case   10:*/		return 0x8209BE18;
		  /* 8209BE18h */ case   11:  		/* mr R9, R23 */
		/* 8209BE18h case   11:*/		regs.R9 = regs.R23;
		/* 8209BE18h case   11:*/		return 0x8209BE1C;
		  /* 8209BE1Ch */ case   12:  		/* addi R10, R10, -4 */
		/* 8209BE1Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 8209BE1Ch case   12:*/		return 0x8209BE20;
		  /* 8209BE20h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 8209BE20h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209BE20h case   13:*/		return 0x8209BE24;
		  /* 8209BE24h */ case   14:  		/* bc 12, CR6_EQ, 16 */
		/* 8209BE24h case   14:*/		if ( regs.CR[6].eq ) { return 0x8209BE34;  }
		/* 8209BE24h case   14:*/		return 0x8209BE28;
		  /* 8209BE28h */ case   15:  		/* mtspr CTR, R11 */
		/* 8209BE28h case   15:*/		regs.CTR = regs.R11;
		/* 8209BE28h case   15:*/		return 0x8209BE2C;
		  /* 8209BE2Ch */ case   16:  		/* stwu R9, <#[R10 + 4]> */
		/* 8209BE2Ch case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8209BE2Ch case   16:*/		return 0x8209BE30;
		  /* 8209BE30h */ case   17:  		/* bc 16, CR0_LT, -4 */
		/* 8209BE30h case   17:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209BE2C;  }
		/* 8209BE30h case   17:*/		return 0x8209BE34;
	}
	return 0x8209BE34;
} // Block from 8209BDECh-8209BE34h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8209BE34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BE34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BE34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BE34);
		  /* 8209BE34h */ case    0:  		/* cmpwi CR6, R5, 0 */
		/* 8209BE34h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 8209BE34h case    0:*/		return 0x8209BE38;
		  /* 8209BE38h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 8209BE38h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209BE40;  }
		/* 8209BE38h case    1:*/		return 0x8209BE3C;
		  /* 8209BE3Ch */ case    2:  		/* addi R30, R30, 1 */
		/* 8209BE3Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8209BE3Ch case    2:*/		return 0x8209BE40;
	}
	return 0x8209BE40;
} // Block from 8209BE34h-8209BE40h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209BE40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BE40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BE40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BE40);
		  /* 8209BE40h */ case    0:  		/* lwz R11, <#[R20 + 4]> */
		/* 8209BE40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000004) );
		/* 8209BE40h case    0:*/		return 0x8209BE44;
		  /* 8209BE44h */ case    1:  		/* subf R10, R25, R11 */
		/* 8209BE44h case    1:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R25,regs.R11);
		/* 8209BE44h case    1:*/		return 0x8209BE48;
	}
	return 0x8209BE48;
} // Block from 8209BE40h-8209BE48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209BE48h
// Function '_fptrap'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BE48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BE48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BE48);
		  /* 8209BE48h */ case    0:  		/* cmpw CR6, R30, R10 */
		/* 8209BE48h case    0:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R10);
		/* 8209BE48h case    0:*/		return 0x8209BE4C;
		  /* 8209BE4Ch */ case    1:  		/* bc 4, CR6_LT, 32 */
		/* 8209BE4Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x8209BE6C;  }
		/* 8209BE4Ch case    1:*/		return 0x8209BE50;
		  /* 8209BE50h */ case    2:  		/* addi R11, R1, -152 */
		/* 8209BE50h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xFFFFFF68);
		/* 8209BE50h case    2:*/		return 0x8209BE54;
		  /* 8209BE54h */ case    3:  		/* mr R5, R23 */
		/* 8209BE54h case    3:*/		regs.R5 = regs.R23;
		/* 8209BE54h case    3:*/		return 0x8209BE58;
	}
	return 0x8209BE58;
} // Block from 8209BE48h-8209BE58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209BE58h
// Function '?_Type_info_dtor@type_info@@CAXPAV1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BE58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BE58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BE58);
		  /* 8209BE58h */ case    0:  		/* li R3, 2 */
		/* 8209BE58h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 8209BE58h case    0:*/		return 0x8209BE5C;
		  /* 8209BE5Ch */ case    1:  		/* stw R23, <#[R11]> */
		/* 8209BE5Ch case    1:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 8209BE5Ch case    1:*/		return 0x8209BE60;
		  /* 8209BE60h */ case    2:  		/* stw R23, <#[R11 + 4]> */
		/* 8209BE60h case    2:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000004) );
		/* 8209BE60h case    2:*/		return 0x8209BE64;
		  /* 8209BE64h */ case    3:  		/* stw R23, <#[R11 + 8]> */
		/* 8209BE64h case    3:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000008) );
		/* 8209BE64h case    3:*/		return 0x8209BE68;
		  /* 8209BE68h */ case    4:  		/* b 1136 */
		/* 8209BE68h case    4:*/		return 0x8209C2D8;
		/* 8209BE68h case    4:*/		return 0x8209BE6C;
	}
	return 0x8209BE6C;
} // Block from 8209BE58h-8209BE6Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209BE6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BE6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BE6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BE6C);
		  /* 8209BE6Ch */ case    0:  		/* li R10, 3 */
		/* 8209BE6Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 8209BE6Ch case    0:*/		return 0x8209BE70;
		  /* 8209BE70h */ case    1:  		/* cmpw CR6, R30, R11 */
		/* 8209BE70h case    1:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R11);
		/* 8209BE70h case    1:*/		return 0x8209BE74;
		  /* 8209BE74h */ case    2:  		/* mtspr CTR, R10 */
		/* 8209BE74h case    2:*/		regs.CTR = regs.R10;
		/* 8209BE74h case    2:*/		return 0x8209BE78;
		  /* 8209BE78h */ case    3:  		/* bc 12, CR6_GT, 732 */
		/* 8209BE78h case    3:*/		if ( regs.CR[6].gt ) { return 0x8209C154;  }
		/* 8209BE78h case    3:*/		return 0x8209BE7C;
		  /* 8209BE7Ch */ case    4:  		/* subf R11, R24, R11 */
		/* 8209BE7Ch case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R24,regs.R11);
		/* 8209BE7Ch case    4:*/		return 0x8209BE80;
		  /* 8209BE80h */ case    5:  		/* addi R9, R1, -136 */
		/* 8209BE80h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xFFFFFF78);
		/* 8209BE80h case    5:*/		return 0x8209BE84;
		  /* 8209BE84h */ case    6:  		/* srawi R8, R11, 5 */
		/* 8209BE84h case    6:*/		cpu::op::srawi<0,5>(regs,&regs.R8,regs.R11);
		/* 8209BE84h case    6:*/		return 0x8209BE88;
		  /* 8209BE88h */ case    7:  		/* addi R6, R1, -152 */
		/* 8209BE88h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0xFFFFFF68);
		/* 8209BE88h case    7:*/		return 0x8209BE8C;
		  /* 8209BE8Ch */ case    8:  		/* addze R5, R8 */
		/* 8209BE8Ch case    8:*/		cpu::op::addze<0>(regs,&regs.R5,regs.R8);
		/* 8209BE8Ch case    8:*/		return 0x8209BE90;
		  /* 8209BE90h */ case    9:  		/* srawi R8, R11, 5 */
		/* 8209BE90h case    9:*/		cpu::op::srawi<0,5>(regs,&regs.R8,regs.R11);
		/* 8209BE90h case    9:*/		return 0x8209BE94;
		  /* 8209BE94h */ case   10:  		/* lwz R7, <#[R9]> */
		/* 8209BE94h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 8209BE94h case   10:*/		return 0x8209BE98;
		  /* 8209BE98h */ case   11:  		/* li R27, -1 */
		/* 8209BE98h case   11:*/		cpu::op::li<0>(regs,&regs.R27,0xFFFFFFFF);
		/* 8209BE98h case   11:*/		return 0x8209BE9C;
		  /* 8209BE9Ch */ case   12:  		/* addze R8, R8 */
		/* 8209BE9Ch case   12:*/		cpu::op::addze<0>(regs,&regs.R8,regs.R8);
		/* 8209BE9Ch case   12:*/		return 0x8209BEA0;
		  /* 8209BEA0h */ case   13:  		/* lwz R31, <#[R9 + 4]> */
		/* 8209BEA0h case   13:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R9 + 0x00000004) );
		/* 8209BEA0h case   13:*/		return 0x8209BEA4;
		  /* 8209BEA4h */ case   14:  		/* lwz R30, <#[R9 + 8]> */
		/* 8209BEA4h case   14:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + 0x00000008) );
		/* 8209BEA4h case   14:*/		return 0x8209BEA8;
		  /* 8209BEA8h */ case   15:  		/* addi R9, R1, -152 */
		/* 8209BEA8h case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xFFFFFF68);
		/* 8209BEA8h case   15:*/		return 0x8209BEAC;
		  /* 8209BEACh */ case   16:  		/* rlwinm R8, R8, 5, 0, 26 */
		/* 8209BEACh case   16:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R8,regs.R8);
		/* 8209BEACh case   16:*/		return 0x8209BEB0;
		  /* 8209BEB0h */ case   17:  		/* subf R11, R8, R11 */
		/* 8209BEB0h case   17:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 8209BEB0h case   17:*/		return 0x8209BEB4;
		  /* 8209BEB4h */ case   18:  		/* stw R7, <#[R6]> */
		/* 8209BEB4h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R6 + 0x00000000) );
		/* 8209BEB4h case   18:*/		return 0x8209BEB8;
		  /* 8209BEB8h */ case   19:  		/* stw R31, <#[R6 + 4]> */
		/* 8209BEB8h case   19:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R6 + 0x00000004) );
		/* 8209BEB8h case   19:*/		return 0x8209BEBC;
		  /* 8209BEBCh */ case   20:  		/* mr R8, R23 */
		/* 8209BEBCh case   20:*/		regs.R8 = regs.R23;
		/* 8209BEBCh case   20:*/		return 0x8209BEC0;
		  /* 8209BEC0h */ case   21:  		/* slw R10, R27, R11 */
		/* 8209BEC0h case   21:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R27,regs.R11);
		/* 8209BEC0h case   21:*/		return 0x8209BEC4;
		  /* 8209BEC4h */ case   22:  		/* stw R30, <#[R6 + 8]> */
		/* 8209BEC4h case   22:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R6 + 0x00000008) );
		/* 8209BEC4h case   22:*/		return 0x8209BEC8;
		  /* 8209BEC8h */ case   23:  		/* nor R7, R10, R10 */
		/* 8209BEC8h case   23:*/		cpu::op::nor<0>(regs,&regs.R7,regs.R10,regs.R10);
		/* 8209BEC8h case   23:*/		return 0x8209BECC;
		  /* 8209BECCh */ case   24:  		/* subfic R6, R11, 32 */
		/* 8209BECCh case   24:*/		cpu::op::subfic<0>(regs,&regs.R6,regs.R11,0x20);
		/* 8209BECCh case   24:*/		return 0x8209BED0;
		  /* 8209BED0h */ case   25:  		/* addi R10, R9, -4 */
		/* 8209BED0h case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFFFFC);
		/* 8209BED0h case   25:*/		return 0x8209BED4;
		  /* 8209BED4h */ case   26:  		/* lwz R9, <#[R10 + 4]> */
		/* 8209BED4h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 8209BED4h case   26:*/		return 0x8209BED8;
		  /* 8209BED8h */ case   27:  		/* and R31, R9, R7 */
		/* 8209BED8h case   27:*/		cpu::op::and<0>(regs,&regs.R31,regs.R9,regs.R7);
		/* 8209BED8h case   27:*/		return 0x8209BEDC;
		  /* 8209BEDCh */ case   28:  		/* stw R31, <#[R1 - 160]> */
		/* 8209BEDCh case   28:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8209BEDCh case   28:*/		return 0x8209BEE0;
		  /* 8209BEE0h */ case   29:  		/* srw R9, R9, R11 */
		/* 8209BEE0h case   29:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 8209BEE0h case   29:*/		return 0x8209BEE4;
		  /* 8209BEE4h */ case   30:  		/* or R9, R9, R8 */
		/* 8209BEE4h case   30:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8209BEE4h case   30:*/		return 0x8209BEE8;
		  /* 8209BEE8h */ case   31:  		/* stwu R9, <#[R10 + 4]> */
		/* 8209BEE8h case   31:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8209BEE8h case   31:*/		return 0x8209BEEC;
		  /* 8209BEECh */ case   32:  		/* lwz R9, <#[R1 - 160]> */
		/* 8209BEECh case   32:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8209BEECh case   32:*/		return 0x8209BEF0;
		  /* 8209BEF0h */ case   33:  		/* slw R8, R9, R6 */
		/* 8209BEF0h case   33:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R9,regs.R6);
		/* 8209BEF0h case   33:*/		return 0x8209BEF4;
		  /* 8209BEF4h */ case   34:  		/* bc 16, CR0_LT, -32 */
		/* 8209BEF4h case   34:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209BED4;  }
		/* 8209BEF4h case   34:*/		return 0x8209BEF8;
		  /* 8209BEF8h */ case   35:  		/* li R10, 3 */
		/* 8209BEF8h case   35:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 8209BEF8h case   35:*/		return 0x8209BEFC;
		  /* 8209BEFCh */ case   36:  		/* rlwinm R8, R5, 2, 0, 29 */
		/* 8209BEFCh case   36:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R5);
		/* 8209BEFCh case   36:*/		return 0x8209BF00;
		  /* 8209BF00h */ case   37:  		/* addi R7, R1, -144 */
		/* 8209BF00h case   37:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xFFFFFF70);
		/* 8209BF00h case   37:*/		return 0x8209BF04;
		  /* 8209BF04h */ case   38:  		/* li R9, 2 */
		/* 8209BF04h case   38:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 8209BF04h case   38:*/		return 0x8209BF08;
		  /* 8209BF08h */ case   39:  		/* addi R11, R1, -144 */
		/* 8209BF08h case   39:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xFFFFFF70);
		/* 8209BF08h case   39:*/		return 0x8209BF0C;
		  /* 8209BF0Ch */ case   40:  		/* subf R8, R8, R7 */
		/* 8209BF0Ch case   40:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8209BF0Ch case   40:*/		return 0x8209BF10;
		  /* 8209BF10h */ case   41:  		/* mtspr CTR, R10 */
		/* 8209BF10h case   41:*/		regs.CTR = regs.R10;
		/* 8209BF10h case   41:*/		return 0x8209BF14;
		  /* 8209BF14h */ case   42:  		/* cmpw CR6, R9, R5 */
		/* 8209BF14h case   42:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R5);
		/* 8209BF14h case   42:*/		return 0x8209BF18;
		  /* 8209BF18h */ case   43:  		/* bc 12, CR6_LT, 16 */
		/* 8209BF18h case   43:*/		if ( regs.CR[6].lt ) { return 0x8209BF28;  }
		/* 8209BF18h case   43:*/		return 0x8209BF1C;
		  /* 8209BF1Ch */ case   44:  		/* lwz R10, <#[R8]> */
		/* 8209BF1Ch case   44:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8209BF1Ch case   44:*/		return 0x8209BF20;
		  /* 8209BF20h */ case   45:  		/* stw R10, <#[R11]> */
		/* 8209BF20h case   45:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209BF20h case   45:*/		return 0x8209BF24;
		  /* 8209BF24h */ case   46:  		/* b 8 */
		/* 8209BF24h case   46:*/		return 0x8209BF2C;
		/* 8209BF24h case   46:*/		return 0x8209BF28;
	}
	return 0x8209BF28;
} // Block from 8209BE6Ch-8209BF28h (47 instructions)

//////////////////////////////////////////////////////
// Block at 8209BF28h
// Function '_free_osfhnd'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BF28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BF28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BF28);
		  /* 8209BF28h */ case    0:  		/* stw R23, <#[R11]> */
		/* 8209BF28h case    0:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 8209BF28h case    0:*/		return 0x8209BF2C;
	}
	return 0x8209BF2C;
} // Block from 8209BF28h-8209BF2Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209BF2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BF2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BF2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BF2C);
		  /* 8209BF2Ch */ case    0:  		/* addi R9, R9, -1 */
		/* 8209BF2Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8209BF2Ch case    0:*/		return 0x8209BF30;
		  /* 8209BF30h */ case    1:  		/* addi R8, R8, -4 */
		/* 8209BF30h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFC);
		/* 8209BF30h case    1:*/		return 0x8209BF34;
		  /* 8209BF34h */ case    2:  		/* addi R11, R11, -4 */
		/* 8209BF34h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8209BF34h case    2:*/		return 0x8209BF38;
		  /* 8209BF38h */ case    3:  		/* bc 16, CR0_LT, -36 */
		/* 8209BF38h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209BF14;  }
		/* 8209BF38h case    3:*/		return 0x8209BF3C;
		  /* 8209BF3Ch */ case    4:  		/* addi R11, R26, 1 */
		/* 8209BF3Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x1);
		/* 8209BF3Ch case    4:*/		return 0x8209BF40;
		  /* 8209BF40h */ case    5:  		/* addi R29, R1, -152 */
		/* 8209BF40h case    5:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R1,0xFFFFFF68);
		/* 8209BF40h case    5:*/		return 0x8209BF44;
		  /* 8209BF44h */ case    6:  		/* srawi R10, R11, 5 */
		/* 8209BF44h case    6:*/		cpu::op::srawi<0,5>(regs,&regs.R10,regs.R11);
		/* 8209BF44h case    6:*/		return 0x8209BF48;
		  /* 8209BF48h */ case    7:  		/* addze R31, R10 */
		/* 8209BF48h case    7:*/		cpu::op::addze<0>(regs,&regs.R31,regs.R10);
		/* 8209BF48h case    7:*/		return 0x8209BF4C;
		  /* 8209BF4Ch */ case    8:  		/* srawi R10, R11, 5 */
		/* 8209BF4Ch case    8:*/		cpu::op::srawi<0,5>(regs,&regs.R10,regs.R11);
		/* 8209BF4Ch case    8:*/		return 0x8209BF50;
		  /* 8209BF50h */ case    9:  		/* rlwinm R28, R31, 2, 0, 29 */
		/* 8209BF50h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R31);
		/* 8209BF50h case    9:*/		return 0x8209BF54;
		  /* 8209BF54h */ case   10:  		/* addze R10, R10 */
		/* 8209BF54h case   10:*/		cpu::op::addze<0>(regs,&regs.R10,regs.R10);
		/* 8209BF54h case   10:*/		return 0x8209BF58;
		  /* 8209BF58h */ case   11:  		/* rlwinm R10, R10, 5, 0, 26 */
		/* 8209BF58h case   11:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R10);
		/* 8209BF58h case   11:*/		return 0x8209BF5C;
		  /* 8209BF5Ch */ case   12:  		/* subf R11, R10, R11 */
		/* 8209BF5Ch case   12:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8209BF5Ch case   12:*/		return 0x8209BF60;
		  /* 8209BF60h */ case   13:  		/* lwzx R10, <#[R28 + R29]> */
		/* 8209BF60h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + regs.R29 + 0x00000000) );
		/* 8209BF60h case   13:*/		return 0x8209BF64;
		  /* 8209BF64h */ case   14:  		/* subfic R30, R11, 31 */
		/* 8209BF64h case   14:*/		cpu::op::subfic<0>(regs,&regs.R30,regs.R11,0x1F);
		/* 8209BF64h case   14:*/		return 0x8209BF68;
		  /* 8209BF68h */ case   15:  		/* slw R11, R3, R30 */
		/* 8209BF68h case   15:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R3,regs.R30);
		/* 8209BF68h case   15:*/		return 0x8209BF6C;
		  /* 8209BF6Ch */ case   16:  		/* and. R11, R11, R10 */
		/* 8209BF6Ch case   16:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8209BF6Ch case   16:*/		return 0x8209BF70;
		  /* 8209BF70h */ case   17:  		/* bc 12, CR0_EQ, 236 */
		/* 8209BF70h case   17:*/		if ( regs.CR[0].eq ) { return 0x8209C05C;  }
		/* 8209BF70h case   17:*/		return 0x8209BF74;
		  /* 8209BF74h */ case   18:  		/* rlwinm R11, R31, 2, 0, 29 */
		/* 8209BF74h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R31);
		/* 8209BF74h case   18:*/		return 0x8209BF78;
		  /* 8209BF78h */ case   19:  		/* addi R10, R1, -152 */
		/* 8209BF78h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFF68);
		/* 8209BF78h case   19:*/		return 0x8209BF7C;
		  /* 8209BF7Ch */ case   20:  		/* slw R9, R22, R30 */
		/* 8209BF7Ch case   20:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R22,regs.R30);
		/* 8209BF7Ch case   20:*/		return 0x8209BF80;
		  /* 8209BF80h */ case   21:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8209BF80h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8209BF80h case   21:*/		return 0x8209BF84;
		  /* 8209BF84h */ case   22:  		/* andc. R11, R11, R9 */
		/* 8209BF84h case   22:*/		cpu::op::andc<1>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8209BF84h case   22:*/		return 0x8209BF88;
		  /* 8209BF88h */ case   23:  		/* bc 4, CR0_EQ, 60 */
		/* 8209BF88h case   23:*/		if ( !regs.CR[0].eq ) { return 0x8209BFC4;  }
		/* 8209BF88h case   23:*/		return 0x8209BF8C;
		  /* 8209BF8Ch */ case   24:  		/* addi R11, R31, 1 */
		/* 8209BF8Ch case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x1);
		/* 8209BF8Ch case   24:*/		return 0x8209BF90;
		  /* 8209BF90h */ case   25:  		/* cmpwi CR6, R11, 3 */
		/* 8209BF90h case   25:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8209BF90h case   25:*/		return 0x8209BF94;
		  /* 8209BF94h */ case   26:  		/* bc 4, CR6_LT, 200 */
		/* 8209BF94h case   26:*/		if ( !regs.CR[6].lt ) { return 0x8209C05C;  }
		/* 8209BF94h case   26:*/		return 0x8209BF98;
		  /* 8209BF98h */ case   27:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8209BF98h case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8209BF98h case   27:*/		return 0x8209BF9C;
		  /* 8209BF9Ch */ case   28:  		/* addi R10, R1, -152 */
		/* 8209BF9Ch case   28:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFF68);
		/* 8209BF9Ch case   28:*/		return 0x8209BFA0;
		  /* 8209BFA0h */ case   29:  		/* add R10, R9, R10 */
		/* 8209BFA0h case   29:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8209BFA0h case   29:*/		return 0x8209BFA4;
		  /* 8209BFA4h */ case   30:  		/* lwz R9, <#[R10]> */
		/* 8209BFA4h case   30:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8209BFA4h case   30:*/		return 0x8209BFA8;
		  /* 8209BFA8h */ case   31:  		/* cmplwi CR6, R9, 0 */
		/* 8209BFA8h case   31:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8209BFA8h case   31:*/		return 0x8209BFAC;
		  /* 8209BFACh */ case   32:  		/* bc 4, CR6_EQ, 24 */
		/* 8209BFACh case   32:*/		if ( !regs.CR[6].eq ) { return 0x8209BFC4;  }
		/* 8209BFACh case   32:*/		return 0x8209BFB0;
		  /* 8209BFB0h */ case   33:  		/* addi R11, R11, 1 */
		/* 8209BFB0h case   33:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209BFB0h case   33:*/		return 0x8209BFB4;
		  /* 8209BFB4h */ case   34:  		/* addi R10, R10, 4 */
		/* 8209BFB4h case   34:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8209BFB4h case   34:*/		return 0x8209BFB8;
		  /* 8209BFB8h */ case   35:  		/* cmpwi CR6, R11, 3 */
		/* 8209BFB8h case   35:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8209BFB8h case   35:*/		return 0x8209BFBC;
		  /* 8209BFBCh */ case   36:  		/* bc 12, CR6_LT, -24 */
		/* 8209BFBCh case   36:*/		if ( regs.CR[6].lt ) { return 0x8209BFA4;  }
		/* 8209BFBCh case   36:*/		return 0x8209BFC0;
	}
	return 0x8209BFC0;
} // Block from 8209BF2Ch-8209BFC0h (37 instructions)

//////////////////////////////////////////////////////
// Block at 8209BFC0h
// Function '_get_osfhandle'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BFC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BFC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BFC0);
		  /* 8209BFC0h */ case    0:  		/* b 156 */
		/* 8209BFC0h case    0:*/		return 0x8209C05C;
		/* 8209BFC0h case    0:*/		return 0x8209BFC4;
	}
	return 0x8209BFC4;
} // Block from 8209BFC0h-8209BFC4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209BFC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209BFC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209BFC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209BFC4);
		  /* 8209BFC4h */ case    0:  		/* srawi R11, R26, 5 */
		/* 8209BFC4h case    0:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R26);
		/* 8209BFC4h case    0:*/		return 0x8209BFC8;
		  /* 8209BFC8h */ case    1:  		/* addi R8, R1, -152 */
		/* 8209BFC8h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xFFFFFF68);
		/* 8209BFC8h case    1:*/		return 0x8209BFCC;
		  /* 8209BFCCh */ case    2:  		/* addze R9, R11 */
		/* 8209BFCCh case    2:*/		cpu::op::addze<0>(regs,&regs.R9,regs.R11);
		/* 8209BFCCh case    2:*/		return 0x8209BFD0;
		  /* 8209BFD0h */ case    3:  		/* srawi R11, R26, 5 */
		/* 8209BFD0h case    3:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R26);
		/* 8209BFD0h case    3:*/		return 0x8209BFD4;
		  /* 8209BFD4h */ case    4:  		/* rlwinm R7, R9, 2, 0, 29 */
		/* 8209BFD4h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R9);
		/* 8209BFD4h case    4:*/		return 0x8209BFD8;
		  /* 8209BFD8h */ case    5:  		/* addze R11, R11 */
		/* 8209BFD8h case    5:*/		cpu::op::addze<0>(regs,&regs.R11,regs.R11);
		/* 8209BFD8h case    5:*/		return 0x8209BFDC;
		  /* 8209BFDCh */ case    6:  		/* mr R5, R23 */
		/* 8209BFDCh case    6:*/		regs.R5 = regs.R23;
		/* 8209BFDCh case    6:*/		return 0x8209BFE0;
		  /* 8209BFE0h */ case    7:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 8209BFE0h case    7:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 8209BFE0h case    7:*/		return 0x8209BFE4;
		  /* 8209BFE4h */ case    8:  		/* subf R10, R11, R26 */
		/* 8209BFE4h case    8:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R26);
		/* 8209BFE4h case    8:*/		return 0x8209BFE8;
		  /* 8209BFE8h */ case    9:  		/* lwzx R11, <#[R7 + R8]> */
		/* 8209BFE8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 8209BFE8h case    9:*/		return 0x8209BFEC;
		  /* 8209BFECh */ case   10:  		/* subfic R10, R10, 31 */
		/* 8209BFECh case   10:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0x1F);
		/* 8209BFECh case   10:*/		return 0x8209BFF0;
		  /* 8209BFF0h */ case   11:  		/* slw R6, R3, R10 */
		/* 8209BFF0h case   11:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R3,regs.R10);
		/* 8209BFF0h case   11:*/		return 0x8209BFF4;
		  /* 8209BFF4h */ case   12:  		/* add R10, R11, R6 */
		/* 8209BFF4h case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R6);
		/* 8209BFF4h case   12:*/		return 0x8209BFF8;
		  /* 8209BFF8h */ case   13:  		/* cmplw CR6, R10, R11 */
		/* 8209BFF8h case   13:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8209BFF8h case   13:*/		return 0x8209BFFC;
		  /* 8209BFFCh */ case   14:  		/* bc 12, CR6_LT, 12 */
		/* 8209BFFCh case   14:*/		if ( regs.CR[6].lt ) { return 0x8209C008;  }
		/* 8209BFFCh case   14:*/		return 0x8209C000;
		  /* 8209C000h */ case   15:  		/* cmplw CR6, R10, R6 */
		/* 8209C000h case   15:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 8209C000h case   15:*/		return 0x8209C004;
		  /* 8209C004h */ case   16:  		/* bc 4, CR6_LT, 8 */
		/* 8209C004h case   16:*/		if ( !regs.CR[6].lt ) { return 0x8209C00C;  }
		/* 8209C004h case   16:*/		return 0x8209C008;
	}
	return 0x8209C008;
} // Block from 8209BFC4h-8209C008h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8209C008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C008);
		  /* 8209C008h */ case    0:  		/* mr R5, R3 */
		/* 8209C008h case    0:*/		regs.R5 = regs.R3;
		/* 8209C008h case    0:*/		return 0x8209C00C;
	}
	return 0x8209C00C;
} // Block from 8209C008h-8209C00Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209C00Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C00C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C00C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C00C);
		  /* 8209C00Ch */ case    0:  		/* stwx R10, <#[R7 + R8]> */
		/* 8209C00Ch case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 8209C00Ch case    0:*/		return 0x8209C010;
		  /* 8209C010h */ case    1:  		/* addic. R11, R9, -1 */
		/* 8209C010h case    1:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 8209C010h case    1:*/		return 0x8209C014;
		  /* 8209C014h */ case    2:  		/* mr R7, R5 */
		/* 8209C014h case    2:*/		regs.R7 = regs.R5;
		/* 8209C014h case    2:*/		return 0x8209C018;
		  /* 8209C018h */ case    3:  		/* bc 12, CR0_LT, 68 */
		/* 8209C018h case    3:*/		if ( regs.CR[0].lt ) { return 0x8209C05C;  }
		/* 8209C018h case    3:*/		return 0x8209C01C;
		  /* 8209C01Ch */ case    4:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8209C01Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8209C01Ch case    4:*/		return 0x8209C020;
		  /* 8209C020h */ case    5:  		/* addi R10, R1, -148 */
		/* 8209C020h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFF6C);
		/* 8209C020h case    5:*/		return 0x8209C024;
		  /* 8209C024h */ case    6:  		/* add R10, R9, R10 */
		/* 8209C024h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8209C024h case    6:*/		return 0x8209C028;
		  /* 8209C028h */ case    7:  		/* cmpwi CR6, R7, 0 */
		/* 8209C028h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 8209C028h case    7:*/		return 0x8209C02C;
		  /* 8209C02Ch */ case    8:  		/* bc 12, CR6_EQ, 48 */
		/* 8209C02Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x8209C05C;  }
		/* 8209C02Ch case    8:*/		return 0x8209C030;
		  /* 8209C030h */ case    9:  		/* lwz R9, <#[R10 - 4]> */
		/* 8209C030h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 8209C030h case    9:*/		return 0x8209C034;
		  /* 8209C034h */ case   10:  		/* mr R7, R23 */
		/* 8209C034h case   10:*/		regs.R7 = regs.R23;
		/* 8209C034h case   10:*/		return 0x8209C038;
		  /* 8209C038h */ case   11:  		/* addi R8, R9, 1 */
		/* 8209C038h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0x1);
		/* 8209C038h case   11:*/		return 0x8209C03C;
		  /* 8209C03Ch */ case   12:  		/* cmplw CR6, R8, R9 */
		/* 8209C03Ch case   12:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8209C03Ch case   12:*/		return 0x8209C040;
		  /* 8209C040h */ case   13:  		/* bc 12, CR6_LT, 12 */
		/* 8209C040h case   13:*/		if ( regs.CR[6].lt ) { return 0x8209C04C;  }
		/* 8209C040h case   13:*/		return 0x8209C044;
		  /* 8209C044h */ case   14:  		/* cmplwi CR6, R8, 1 */
		/* 8209C044h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000001);
		/* 8209C044h case   14:*/		return 0x8209C048;
		  /* 8209C048h */ case   15:  		/* bc 4, CR6_LT, 8 */
		/* 8209C048h case   15:*/		if ( !regs.CR[6].lt ) { return 0x8209C050;  }
		/* 8209C048h case   15:*/		return 0x8209C04C;
	}
	return 0x8209C04C;
} // Block from 8209C00Ch-8209C04Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8209C04Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C04C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C04C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C04C);
		  /* 8209C04Ch */ case    0:  		/* mr R7, R3 */
		/* 8209C04Ch case    0:*/		regs.R7 = regs.R3;
		/* 8209C04Ch case    0:*/		return 0x8209C050;
	}
	return 0x8209C050;
} // Block from 8209C04Ch-8209C050h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209C050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C050);
		  /* 8209C050h */ case    0:  		/* addic. R11, R11, -1 */
		/* 8209C050h case    0:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8209C050h case    0:*/		return 0x8209C054;
		  /* 8209C054h */ case    1:  		/* stwu R8, <#[R10 - 4]> */
		/* 8209C054h case    1:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0xFFFFFFFC) );
		regs.R10 = (uint32)(regs.R10 + 0xFFFFFFFC);
		/* 8209C054h case    1:*/		return 0x8209C058;
		  /* 8209C058h */ case    2:  		/* bc 4, CR0_LT, -48 */
		/* 8209C058h case    2:*/		if ( !regs.CR[0].lt ) { return 0x8209C028;  }
		/* 8209C058h case    2:*/		return 0x8209C05C;
	}
	return 0x8209C05C;
} // Block from 8209C050h-8209C05Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209C05Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C05C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C05C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C05C);
		  /* 8209C05Ch */ case    0:  		/* lwzx R10, <#[R28 + R29]> */
		/* 8209C05Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + regs.R29 + 0x00000000) );
		/* 8209C05Ch case    0:*/		return 0x8209C060;
		  /* 8209C060h */ case    1:  		/* slw R9, R22, R30 */
		/* 8209C060h case    1:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R22,regs.R30);
		/* 8209C060h case    1:*/		return 0x8209C064;
		  /* 8209C064h */ case    2:  		/* addi R11, R31, 1 */
		/* 8209C064h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x1);
		/* 8209C064h case    2:*/		return 0x8209C068;
		  /* 8209C068h */ case    3:  		/* and R10, R9, R10 */
		/* 8209C068h case    3:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8209C068h case    3:*/		return 0x8209C06C;
		  /* 8209C06Ch */ case    4:  		/* cmpwi CR6, R11, 3 */
		/* 8209C06Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8209C06Ch case    4:*/		return 0x8209C070;
		  /* 8209C070h */ case    5:  		/* stwx R10, <#[R28 + R29]> */
		/* 8209C070h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + regs.R29 + 0x00000000) );
		/* 8209C070h case    5:*/		return 0x8209C074;
		  /* 8209C074h */ case    6:  		/* bc 4, CR6_LT, 48 */
		/* 8209C074h case    6:*/		if ( !regs.CR[6].lt ) { return 0x8209C0A4;  }
		/* 8209C074h case    6:*/		return 0x8209C078;
		  /* 8209C078h */ case    7:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8209C078h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8209C078h case    7:*/		return 0x8209C07C;
		  /* 8209C07Ch */ case    8:  		/* addi R10, R1, -152 */
		/* 8209C07Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFF68);
		/* 8209C07Ch case    8:*/		return 0x8209C080;
	}
	return 0x8209C080;
} // Block from 8209C05Ch-8209C080h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209C080h
// Function '__lock_fhandle'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C080);
		  /* 8209C080h */ case    0:  		/* subfic R11, R11, 3 */
		/* 8209C080h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x3);
		/* 8209C080h case    0:*/		return 0x8209C084;
		  /* 8209C084h */ case    1:  		/* add R10, R9, R10 */
		/* 8209C084h case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8209C084h case    1:*/		return 0x8209C088;
		  /* 8209C088h */ case    2:  		/* mr R9, R23 */
		/* 8209C088h case    2:*/		regs.R9 = regs.R23;
		/* 8209C088h case    2:*/		return 0x8209C08C;
		  /* 8209C08Ch */ case    3:  		/* addi R10, R10, -4 */
		/* 8209C08Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 8209C08Ch case    3:*/		return 0x8209C090;
		  /* 8209C090h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8209C090h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209C090h case    4:*/		return 0x8209C094;
		  /* 8209C094h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 8209C094h case    5:*/		if ( regs.CR[6].eq ) { return 0x8209C0A4;  }
		/* 8209C094h case    5:*/		return 0x8209C098;
		  /* 8209C098h */ case    6:  		/* mtspr CTR, R11 */
		/* 8209C098h case    6:*/		regs.CTR = regs.R11;
		/* 8209C098h case    6:*/		return 0x8209C09C;
		  /* 8209C09Ch */ case    7:  		/* stwu R9, <#[R10 + 4]> */
		/* 8209C09Ch case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8209C09Ch case    7:*/		return 0x8209C0A0;
		  /* 8209C0A0h */ case    8:  		/* bc 16, CR0_LT, -4 */
		/* 8209C0A0h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209C09C;  }
		/* 8209C0A0h case    8:*/		return 0x8209C0A4;
	}
	return 0x8209C0A4;
} // Block from 8209C080h-8209C0A4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209C0A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C0A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C0A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C0A4);
		  /* 8209C0A4h */ case    0:  		/* addi R11, R21, 1 */
		/* 8209C0A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R21,0x1);
		/* 8209C0A4h case    0:*/		return 0x8209C0A8;
		  /* 8209C0A8h */ case    1:  		/* li R10, 3 */
		/* 8209C0A8h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 8209C0A8h case    1:*/		return 0x8209C0AC;
		  /* 8209C0ACh */ case    2:  		/* srawi R8, R11, 5 */
		/* 8209C0ACh case    2:*/		cpu::op::srawi<0,5>(regs,&regs.R8,regs.R11);
		/* 8209C0ACh case    2:*/		return 0x8209C0B0;
		  /* 8209C0B0h */ case    3:  		/* addi R9, R1, -152 */
		/* 8209C0B0h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xFFFFFF68);
		/* 8209C0B0h case    3:*/		return 0x8209C0B4;
		  /* 8209C0B4h */ case    4:  		/* addze R6, R8 */
		/* 8209C0B4h case    4:*/		cpu::op::addze<0>(regs,&regs.R6,regs.R8);
		/* 8209C0B4h case    4:*/		return 0x8209C0B8;
		  /* 8209C0B8h */ case    5:  		/* srawi R8, R11, 5 */
		/* 8209C0B8h case    5:*/		cpu::op::srawi<0,5>(regs,&regs.R8,regs.R11);
		/* 8209C0B8h case    5:*/		return 0x8209C0BC;
		  /* 8209C0BCh */ case    6:  		/* mtspr CTR, R10 */
		/* 8209C0BCh case    6:*/		regs.CTR = regs.R10;
		/* 8209C0BCh case    6:*/		return 0x8209C0C0;
		  /* 8209C0C0h */ case    7:  		/* addi R10, R9, -4 */
		/* 8209C0C0h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFFFFC);
		/* 8209C0C0h case    7:*/		return 0x8209C0C4;
		  /* 8209C0C4h */ case    8:  		/* addze R9, R8 */
		/* 8209C0C4h case    8:*/		cpu::op::addze<0>(regs,&regs.R9,regs.R8);
		/* 8209C0C4h case    8:*/		return 0x8209C0C8;
		  /* 8209C0C8h */ case    9:  		/* mr R8, R23 */
		/* 8209C0C8h case    9:*/		regs.R8 = regs.R23;
		/* 8209C0C8h case    9:*/		return 0x8209C0CC;
		  /* 8209C0CCh */ case   10:  		/* rlwinm R9, R9, 5, 0, 26 */
		/* 8209C0CCh case   10:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R9,regs.R9);
		/* 8209C0CCh case   10:*/		return 0x8209C0D0;
		  /* 8209C0D0h */ case   11:  		/* subf R11, R9, R11 */
		/* 8209C0D0h case   11:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8209C0D0h case   11:*/		return 0x8209C0D4;
		  /* 8209C0D4h */ case   12:  		/* slw R9, R27, R11 */
		/* 8209C0D4h case   12:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R27,regs.R11);
		/* 8209C0D4h case   12:*/		return 0x8209C0D8;
		  /* 8209C0D8h */ case   13:  		/* nor R9, R9, R9 */
		/* 8209C0D8h case   13:*/		cpu::op::nor<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 8209C0D8h case   13:*/		return 0x8209C0DC;
		  /* 8209C0DCh */ case   14:  		/* subfic R7, R11, 32 */
		/* 8209C0DCh case   14:*/		cpu::op::subfic<0>(regs,&regs.R7,regs.R11,0x20);
		/* 8209C0DCh case   14:*/		return 0x8209C0E0;
		  /* 8209C0E0h */ case   15:  		/* lwz R5, <#[R10 + 4]> */
		/* 8209C0E0h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000004) );
		/* 8209C0E0h case   15:*/		return 0x8209C0E4;
		  /* 8209C0E4h */ case   16:  		/* and R3, R5, R9 */
		/* 8209C0E4h case   16:*/		cpu::op::and<0>(regs,&regs.R3,regs.R5,regs.R9);
		/* 8209C0E4h case   16:*/		return 0x8209C0E8;
		  /* 8209C0E8h */ case   17:  		/* stw R3, <#[R1 - 160]> */
		/* 8209C0E8h case   17:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8209C0E8h case   17:*/		return 0x8209C0EC;
		  /* 8209C0ECh */ case   18:  		/* srw R5, R5, R11 */
		/* 8209C0ECh case   18:*/		cpu::op::srw<0>(regs,&regs.R5,regs.R5,regs.R11);
		/* 8209C0ECh case   18:*/		return 0x8209C0F0;
		  /* 8209C0F0h */ case   19:  		/* or R8, R5, R8 */
		/* 8209C0F0h case   19:*/		cpu::op::or<0>(regs,&regs.R8,regs.R5,regs.R8);
		/* 8209C0F0h case   19:*/		return 0x8209C0F4;
		  /* 8209C0F4h */ case   20:  		/* stwu R8, <#[R10 + 4]> */
		/* 8209C0F4h case   20:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8209C0F4h case   20:*/		return 0x8209C0F8;
		  /* 8209C0F8h */ case   21:  		/* lwz R8, <#[R1 - 160]> */
		/* 8209C0F8h case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8209C0F8h case   21:*/		return 0x8209C0FC;
		  /* 8209C0FCh */ case   22:  		/* slw R8, R8, R7 */
		/* 8209C0FCh case   22:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8209C0FCh case   22:*/		return 0x8209C100;
		  /* 8209C100h */ case   23:  		/* bc 16, CR0_LT, -32 */
		/* 8209C100h case   23:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209C0E0;  }
		/* 8209C100h case   23:*/		return 0x8209C104;
		  /* 8209C104h */ case   24:  		/* li R10, 3 */
		/* 8209C104h case   24:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 8209C104h case   24:*/		return 0x8209C108;
		  /* 8209C108h */ case   25:  		/* rlwinm R8, R6, 2, 0, 29 */
		/* 8209C108h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R6);
		/* 8209C108h case   25:*/		return 0x8209C10C;
		  /* 8209C10Ch */ case   26:  		/* addi R7, R1, -144 */
		/* 8209C10Ch case   26:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xFFFFFF70);
		/* 8209C10Ch case   26:*/		return 0x8209C110;
		  /* 8209C110h */ case   27:  		/* li R9, 2 */
		/* 8209C110h case   27:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 8209C110h case   27:*/		return 0x8209C114;
		  /* 8209C114h */ case   28:  		/* addi R11, R1, -144 */
		/* 8209C114h case   28:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xFFFFFF70);
		/* 8209C114h case   28:*/		return 0x8209C118;
		  /* 8209C118h */ case   29:  		/* subf R8, R8, R7 */
		/* 8209C118h case   29:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8209C118h case   29:*/		return 0x8209C11C;
		  /* 8209C11Ch */ case   30:  		/* mtspr CTR, R10 */
		/* 8209C11Ch case   30:*/		regs.CTR = regs.R10;
		/* 8209C11Ch case   30:*/		return 0x8209C120;
		  /* 8209C120h */ case   31:  		/* cmpw CR6, R9, R6 */
		/* 8209C120h case   31:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R6);
		/* 8209C120h case   31:*/		return 0x8209C124;
		  /* 8209C124h */ case   32:  		/* bc 12, CR6_LT, 16 */
		/* 8209C124h case   32:*/		if ( regs.CR[6].lt ) { return 0x8209C134;  }
		/* 8209C124h case   32:*/		return 0x8209C128;
		  /* 8209C128h */ case   33:  		/* lwz R10, <#[R8]> */
		/* 8209C128h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8209C128h case   33:*/		return 0x8209C12C;
		  /* 8209C12Ch */ case   34:  		/* stw R10, <#[R11]> */
		/* 8209C12Ch case   34:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209C12Ch case   34:*/		return 0x8209C130;
		  /* 8209C130h */ case   35:  		/* b 8 */
		/* 8209C130h case   35:*/		return 0x8209C138;
		/* 8209C130h case   35:*/		return 0x8209C134;
	}
	return 0x8209C134;
} // Block from 8209C0A4h-8209C134h (36 instructions)

//////////////////////////////////////////////////////
// Block at 8209C134h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C134( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C134) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C134);
		  /* 8209C134h */ case    0:  		/* stw R23, <#[R11]> */
		/* 8209C134h case    0:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 8209C134h case    0:*/		return 0x8209C138;
	}
	return 0x8209C138;
} // Block from 8209C134h-8209C138h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209C138h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C138);
		  /* 8209C138h */ case    0:  		/* addi R9, R9, -1 */
		/* 8209C138h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8209C138h case    0:*/		return 0x8209C13C;
		  /* 8209C13Ch */ case    1:  		/* addi R8, R8, -4 */
		/* 8209C13Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFC);
		/* 8209C13Ch case    1:*/		return 0x8209C140;
		  /* 8209C140h */ case    2:  		/* addi R11, R11, -4 */
		/* 8209C140h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8209C140h case    2:*/		return 0x8209C144;
		  /* 8209C144h */ case    3:  		/* bc 16, CR0_LT, -36 */
		/* 8209C144h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209C120;  }
		/* 8209C144h case    3:*/		return 0x8209C148;
		  /* 8209C148h */ case    4:  		/* mr R5, R23 */
		/* 8209C148h case    4:*/		regs.R5 = regs.R23;
		/* 8209C148h case    4:*/		return 0x8209C14C;
		  /* 8209C14Ch */ case    5:  		/* li R3, 2 */
		/* 8209C14Ch case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 8209C14Ch case    5:*/		return 0x8209C150;
		  /* 8209C150h */ case    6:  		/* b 392 */
		/* 8209C150h case    6:*/		return 0x8209C2D8;
		/* 8209C150h case    6:*/		return 0x8209C154;
	}
	return 0x8209C154;
} // Block from 8209C138h-8209C154h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209C154h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C154( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C154) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C154);
		  /* 8209C154h */ case    0:  		/* lwz R5, <#[R20]> */
		/* 8209C154h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R20 + 0x00000000) );
		/* 8209C154h case    0:*/		return 0x8209C158;
		  /* 8209C158h */ case    1:  		/* cmpw CR6, R30, R5 */
		/* 8209C158h case    1:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R5);
		/* 8209C158h case    1:*/		return 0x8209C15C;
		  /* 8209C15Ch */ case    2:  		/* bc 12, CR6_LT, 200 */
		/* 8209C15Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x8209C224;  }
		/* 8209C15Ch case    2:*/		return 0x8209C160;
		  /* 8209C160h */ case    3:  		/* addi R11, R1, -152 */
		/* 8209C160h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xFFFFFF68);
		/* 8209C160h case    3:*/		return 0x8209C164;
		  /* 8209C164h */ case    4:  		/* srawi R9, R21, 5 */
		/* 8209C164h case    4:*/		cpu::op::srawi<0,5>(regs,&regs.R9,regs.R21);
		/* 8209C164h case    4:*/		return 0x8209C168;
		  /* 8209C168h */ case    5:  		/* li R7, -1 */
		/* 8209C168h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0xFFFFFFFF);
		/* 8209C168h case    5:*/		return 0x8209C16C;
		  /* 8209C16Ch */ case    6:  		/* addze R6, R9 */
		/* 8209C16Ch case    6:*/		cpu::op::addze<0>(regs,&regs.R6,regs.R9);
		/* 8209C16Ch case    6:*/		return 0x8209C170;
		  /* 8209C170h */ case    7:  		/* srawi R9, R21, 5 */
		/* 8209C170h case    7:*/		cpu::op::srawi<0,5>(regs,&regs.R9,regs.R21);
		/* 8209C170h case    7:*/		return 0x8209C174;
		  /* 8209C174h */ case    8:  		/* stw R23, <#[R11]> */
		/* 8209C174h case    8:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 8209C174h case    8:*/		return 0x8209C178;
		  /* 8209C178h */ case    9:  		/* stw R23, <#[R11 + 4]> */
		/* 8209C178h case    9:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000004) );
		/* 8209C178h case    9:*/		return 0x8209C17C;
		  /* 8209C17Ch */ case   10:  		/* addze R8, R9 */
		/* 8209C17Ch case   10:*/		cpu::op::addze<0>(regs,&regs.R8,regs.R9);
		/* 8209C17Ch case   10:*/		return 0x8209C180;
	}
	return 0x8209C180;
} // Block from 8209C154h-8209C180h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209C180h
// Function '_unlock_fhandle'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C180);
		  /* 8209C180h */ case    0:  		/* stw R23, <#[R11 + 8]> */
		/* 8209C180h case    0:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000008) );
		/* 8209C180h case    0:*/		return 0x8209C184;
		  /* 8209C184h */ case    1:  		/* rlwinm R11, R8, 5, 0, 26 */
		/* 8209C184h case    1:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R8);
		/* 8209C184h case    1:*/		return 0x8209C188;
		  /* 8209C188h */ case    2:  		/* addi R9, R1, -152 */
		/* 8209C188h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xFFFFFF68);
		/* 8209C188h case    2:*/		return 0x8209C18C;
		  /* 8209C18Ch */ case    3:  		/* subf R11, R11, R21 */
		/* 8209C18Ch case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R21);
		/* 8209C18Ch case    3:*/		return 0x8209C190;
		  /* 8209C190h */ case    4:  		/* addi R10, R9, -4 */
		/* 8209C190h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFFFFC);
		/* 8209C190h case    4:*/		return 0x8209C194;
		  /* 8209C194h */ case    5:  		/* slw R9, R7, R11 */
		/* 8209C194h case    5:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R7,regs.R11);
		/* 8209C194h case    5:*/		return 0x8209C198;
		  /* 8209C198h */ case    6:  		/* lwz R31, <#[R1 - 152]> */
		/* 8209C198h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFF68) );
		/* 8209C198h case    6:*/		return 0x8209C19C;
		  /* 8209C19Ch */ case    7:  		/* mr R8, R23 */
		/* 8209C19Ch case    7:*/		regs.R8 = regs.R23;
		/* 8209C19Ch case    7:*/		return 0x8209C1A0;
		  /* 8209C1A0h */ case    8:  		/* nor R9, R9, R9 */
		/* 8209C1A0h case    8:*/		cpu::op::nor<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 8209C1A0h case    8:*/		return 0x8209C1A4;
		  /* 8209C1A4h */ case    9:  		/* oris R31, R31, 32768 */
		/* 8209C1A4h case    9:*/		cpu::op::oris<0>(regs,&regs.R31,regs.R31,0x8000);
		/* 8209C1A4h case    9:*/		return 0x8209C1A8;
		  /* 8209C1A8h */ case   10:  		/* subfic R7, R11, 32 */
		/* 8209C1A8h case   10:*/		cpu::op::subfic<0>(regs,&regs.R7,regs.R11,0x20);
		/* 8209C1A8h case   10:*/		return 0x8209C1AC;
		  /* 8209C1ACh */ case   11:  		/* stw R31, <#[R1 - 152]> */
		/* 8209C1ACh case   11:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFF68) );
		/* 8209C1ACh case   11:*/		return 0x8209C1B0;
	}
	return 0x8209C1B0;
} // Block from 8209C180h-8209C1B0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8209C1B0h
// Function '_fcloseall'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C1B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C1B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C1B0);
		  /* 8209C1B0h */ case    0:  		/* lwz R31, <#[R10 + 4]> */
		/* 8209C1B0h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x00000004) );
		/* 8209C1B0h case    0:*/		return 0x8209C1B4;
		  /* 8209C1B4h */ case    1:  		/* and R30, R31, R9 */
		/* 8209C1B4h case    1:*/		cpu::op::and<0>(regs,&regs.R30,regs.R31,regs.R9);
		/* 8209C1B4h case    1:*/		return 0x8209C1B8;
		  /* 8209C1B8h */ case    2:  		/* stw R30, <#[R1 - 160]> */
		/* 8209C1B8h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8209C1B8h case    2:*/		return 0x8209C1BC;
		  /* 8209C1BCh */ case    3:  		/* srw R31, R31, R11 */
		/* 8209C1BCh case    3:*/		cpu::op::srw<0>(regs,&regs.R31,regs.R31,regs.R11);
		/* 8209C1BCh case    3:*/		return 0x8209C1C0;
		  /* 8209C1C0h */ case    4:  		/* or R8, R31, R8 */
		/* 8209C1C0h case    4:*/		cpu::op::or<0>(regs,&regs.R8,regs.R31,regs.R8);
		/* 8209C1C0h case    4:*/		return 0x8209C1C4;
		  /* 8209C1C4h */ case    5:  		/* stwu R8, <#[R10 + 4]> */
		/* 8209C1C4h case    5:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8209C1C4h case    5:*/		return 0x8209C1C8;
		  /* 8209C1C8h */ case    6:  		/* lwz R8, <#[R1 - 160]> */
		/* 8209C1C8h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8209C1C8h case    6:*/		return 0x8209C1CC;
		  /* 8209C1CCh */ case    7:  		/* slw R8, R8, R7 */
		/* 8209C1CCh case    7:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8209C1CCh case    7:*/		return 0x8209C1D0;
		  /* 8209C1D0h */ case    8:  		/* bc 16, CR0_LT, -32 */
		/* 8209C1D0h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209C1B0;  }
		/* 8209C1D0h case    8:*/		return 0x8209C1D4;
		  /* 8209C1D4h */ case    9:  		/* li R10, 3 */
		/* 8209C1D4h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 8209C1D4h case    9:*/		return 0x8209C1D8;
		  /* 8209C1D8h */ case   10:  		/* rlwinm R8, R6, 2, 0, 29 */
		/* 8209C1D8h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R6);
		/* 8209C1D8h case   10:*/		return 0x8209C1DC;
		  /* 8209C1DCh */ case   11:  		/* addi R7, R1, -144 */
		/* 8209C1DCh case   11:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xFFFFFF70);
		/* 8209C1DCh case   11:*/		return 0x8209C1E0;
		  /* 8209C1E0h */ case   12:  		/* li R9, 2 */
		/* 8209C1E0h case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 8209C1E0h case   12:*/		return 0x8209C1E4;
		  /* 8209C1E4h */ case   13:  		/* addi R11, R1, -144 */
		/* 8209C1E4h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xFFFFFF70);
		/* 8209C1E4h case   13:*/		return 0x8209C1E8;
		  /* 8209C1E8h */ case   14:  		/* subf R8, R8, R7 */
		/* 8209C1E8h case   14:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8209C1E8h case   14:*/		return 0x8209C1EC;
		  /* 8209C1ECh */ case   15:  		/* mtspr CTR, R10 */
		/* 8209C1ECh case   15:*/		regs.CTR = regs.R10;
		/* 8209C1ECh case   15:*/		return 0x8209C1F0;
		  /* 8209C1F0h */ case   16:  		/* cmpw CR6, R9, R6 */
		/* 8209C1F0h case   16:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R6);
		/* 8209C1F0h case   16:*/		return 0x8209C1F4;
		  /* 8209C1F4h */ case   17:  		/* bc 12, CR6_LT, 16 */
		/* 8209C1F4h case   17:*/		if ( regs.CR[6].lt ) { return 0x8209C204;  }
		/* 8209C1F4h case   17:*/		return 0x8209C1F8;
		  /* 8209C1F8h */ case   18:  		/* lwz R10, <#[R8]> */
		/* 8209C1F8h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8209C1F8h case   18:*/		return 0x8209C1FC;
		  /* 8209C1FCh */ case   19:  		/* stw R10, <#[R11]> */
		/* 8209C1FCh case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209C1FCh case   19:*/		return 0x8209C200;
		  /* 8209C200h */ case   20:  		/* b 8 */
		/* 8209C200h case   20:*/		return 0x8209C208;
		/* 8209C200h case   20:*/		return 0x8209C204;
	}
	return 0x8209C204;
} // Block from 8209C1B0h-8209C204h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8209C204h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C204( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C204) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C204);
		  /* 8209C204h */ case    0:  		/* stw R23, <#[R11]> */
		/* 8209C204h case    0:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 8209C204h case    0:*/		return 0x8209C208;
	}
	return 0x8209C208;
} // Block from 8209C204h-8209C208h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209C208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C208);
		  /* 8209C208h */ case    0:  		/* addi R9, R9, -1 */
		/* 8209C208h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8209C208h case    0:*/		return 0x8209C20C;
		  /* 8209C20Ch */ case    1:  		/* addi R8, R8, -4 */
		/* 8209C20Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFC);
		/* 8209C20Ch case    1:*/		return 0x8209C210;
		  /* 8209C210h */ case    2:  		/* addi R11, R11, -4 */
		/* 8209C210h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8209C210h case    2:*/		return 0x8209C214;
		  /* 8209C214h */ case    3:  		/* bc 16, CR0_LT, -36 */
		/* 8209C214h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209C1F0;  }
		/* 8209C214h case    3:*/		return 0x8209C218;
		  /* 8209C218h */ case    4:  		/* lwz R11, <#[R20 + 20]> */
		/* 8209C218h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000014) );
		/* 8209C218h case    4:*/		return 0x8209C21C;
		  /* 8209C21Ch */ case    5:  		/* add R5, R11, R5 */
		/* 8209C21Ch case    5:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R5);
		/* 8209C21Ch case    5:*/		return 0x8209C220;
		  /* 8209C220h */ case    6:  		/* b 184 */
		/* 8209C220h case    6:*/		return 0x8209C2D8;
		/* 8209C220h case    6:*/		return 0x8209C224;
	}
	return 0x8209C224;
} // Block from 8209C208h-8209C224h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209C224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C224);
		  /* 8209C224h */ case    0:  		/* srawi R11, R21, 5 */
		/* 8209C224h case    0:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R21);
		/* 8209C224h case    0:*/		return 0x8209C228;
		  /* 8209C228h */ case    1:  		/* lwz R7, <#[R1 - 152]> */
		/* 8209C228h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0xFFFFFF68) );
		/* 8209C228h case    1:*/		return 0x8209C22C;
		  /* 8209C22Ch */ case    2:  		/* li R6, -1 */
		/* 8209C22Ch case    2:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFFFFF);
		/* 8209C22Ch case    2:*/		return 0x8209C230;
		  /* 8209C230h */ case    3:  		/* lwz R9, <#[R20 + 20]> */
		/* 8209C230h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R20 + 0x00000014) );
		/* 8209C230h case    3:*/		return 0x8209C234;
		  /* 8209C234h */ case    4:  		/* addze R3, R11 */
		/* 8209C234h case    4:*/		cpu::op::addze<0>(regs,&regs.R3,regs.R11);
		/* 8209C234h case    4:*/		return 0x8209C238;
		  /* 8209C238h */ case    5:  		/* srawi R11, R21, 5 */
		/* 8209C238h case    5:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R21);
		/* 8209C238h case    5:*/		return 0x8209C23C;
		  /* 8209C23Ch */ case    6:  		/* rlwinm R10, R7, 0, 1, 31 */
		/* 8209C23Ch case    6:*/		cpu::op::rlwinm<0,0,1,31>(regs,&regs.R10,regs.R7);
		/* 8209C23Ch case    6:*/		return 0x8209C240;
		  /* 8209C240h */ case    7:  		/* addze R11, R11 */
		/* 8209C240h case    7:*/		cpu::op::addze<0>(regs,&regs.R11,regs.R11);
		/* 8209C240h case    7:*/		return 0x8209C244;
		  /* 8209C244h */ case    8:  		/* stw R10, <#[R1 - 152]> */
		/* 8209C244h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0xFFFFFF68) );
		/* 8209C244h case    8:*/		return 0x8209C248;
		  /* 8209C248h */ case    9:  		/* addi R8, R1, -152 */
		/* 8209C248h case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xFFFFFF68);
		/* 8209C248h case    9:*/		return 0x8209C24C;
		  /* 8209C24Ch */ case   10:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 8209C24Ch case   10:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 8209C24Ch case   10:*/		return 0x8209C250;
		  /* 8209C250h */ case   11:  		/* add R5, R9, R30 */
		/* 8209C250h case   11:*/		cpu::op::add<0>(regs,&regs.R5,regs.R9,regs.R30);
		/* 8209C250h case   11:*/		return 0x8209C254;
		  /* 8209C254h */ case   12:  		/* subf R11, R11, R21 */
		/* 8209C254h case   12:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R21);
		/* 8209C254h case   12:*/		return 0x8209C258;
		  /* 8209C258h */ case   13:  		/* mr R9, R23 */
		/* 8209C258h case   13:*/		regs.R9 = regs.R23;
		/* 8209C258h case   13:*/		return 0x8209C25C;
		  /* 8209C25Ch */ case   14:  		/* slw R10, R6, R11 */
		/* 8209C25Ch case   14:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R6,regs.R11);
		/* 8209C25Ch case   14:*/		return 0x8209C260;
		  /* 8209C260h */ case   15:  		/* nor R7, R10, R10 */
		/* 8209C260h case   15:*/		cpu::op::nor<0>(regs,&regs.R7,regs.R10,regs.R10);
		/* 8209C260h case   15:*/		return 0x8209C264;
		  /* 8209C264h */ case   16:  		/* subfic R6, R11, 32 */
		/* 8209C264h case   16:*/		cpu::op::subfic<0>(regs,&regs.R6,regs.R11,0x20);
		/* 8209C264h case   16:*/		return 0x8209C268;
		  /* 8209C268h */ case   17:  		/* addi R10, R8, -4 */
		/* 8209C268h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R8,0xFFFFFFFC);
		/* 8209C268h case   17:*/		return 0x8209C26C;
		  /* 8209C26Ch */ case   18:  		/* lwz R8, <#[R10 + 4]> */
		/* 8209C26Ch case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 8209C26Ch case   18:*/		return 0x8209C270;
		  /* 8209C270h */ case   19:  		/* and R31, R8, R7 */
		/* 8209C270h case   19:*/		cpu::op::and<0>(regs,&regs.R31,regs.R8,regs.R7);
		/* 8209C270h case   19:*/		return 0x8209C274;
		  /* 8209C274h */ case   20:  		/* stw R31, <#[R1 - 160]> */
		/* 8209C274h case   20:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8209C274h case   20:*/		return 0x8209C278;
		  /* 8209C278h */ case   21:  		/* srw R8, R8, R11 */
		/* 8209C278h case   21:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 8209C278h case   21:*/		return 0x8209C27C;
		  /* 8209C27Ch */ case   22:  		/* or R9, R8, R9 */
		/* 8209C27Ch case   22:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8209C27Ch case   22:*/		return 0x8209C280;
		  /* 8209C280h */ case   23:  		/* stwu R9, <#[R10 + 4]> */
		/* 8209C280h case   23:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8209C280h case   23:*/		return 0x8209C284;
		  /* 8209C284h */ case   24:  		/* lwz R9, <#[R1 - 160]> */
		/* 8209C284h case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8209C284h case   24:*/		return 0x8209C288;
		  /* 8209C288h */ case   25:  		/* slw R9, R9, R6 */
		/* 8209C288h case   25:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R6);
		/* 8209C288h case   25:*/		return 0x8209C28C;
		  /* 8209C28Ch */ case   26:  		/* bc 16, CR0_LT, -32 */
		/* 8209C28Ch case   26:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209C26C;  }
		/* 8209C28Ch case   26:*/		return 0x8209C290;
		  /* 8209C290h */ case   27:  		/* li R10, 3 */
		/* 8209C290h case   27:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 8209C290h case   27:*/		return 0x8209C294;
		  /* 8209C294h */ case   28:  		/* rlwinm R8, R3, 2, 0, 29 */
		/* 8209C294h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R3);
		/* 8209C294h case   28:*/		return 0x8209C298;
	}
	return 0x8209C298;
} // Block from 8209C224h-8209C298h (29 instructions)

//////////////////////////////////////////////////////
// Block at 8209C298h
// Function '_flush'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C298);
		  /* 8209C298h */ case    0:  		/* addi R7, R1, -144 */
		/* 8209C298h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xFFFFFF70);
		/* 8209C298h case    0:*/		return 0x8209C29C;
		  /* 8209C29Ch */ case    1:  		/* li R9, 2 */
		/* 8209C29Ch case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 8209C29Ch case    1:*/		return 0x8209C2A0;
		  /* 8209C2A0h */ case    2:  		/* addi R11, R1, -144 */
		/* 8209C2A0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xFFFFFF70);
		/* 8209C2A0h case    2:*/		return 0x8209C2A4;
		  /* 8209C2A4h */ case    3:  		/* subf R8, R8, R7 */
		/* 8209C2A4h case    3:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8209C2A4h case    3:*/		return 0x8209C2A8;
		  /* 8209C2A8h */ case    4:  		/* mtspr CTR, R10 */
		/* 8209C2A8h case    4:*/		regs.CTR = regs.R10;
		/* 8209C2A8h case    4:*/		return 0x8209C2AC;
		  /* 8209C2ACh */ case    5:  		/* cmpw CR6, R9, R3 */
		/* 8209C2ACh case    5:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R3);
		/* 8209C2ACh case    5:*/		return 0x8209C2B0;
		  /* 8209C2B0h */ case    6:  		/* bc 12, CR6_LT, 16 */
		/* 8209C2B0h case    6:*/		if ( regs.CR[6].lt ) { return 0x8209C2C0;  }
		/* 8209C2B0h case    6:*/		return 0x8209C2B4;
		  /* 8209C2B4h */ case    7:  		/* lwz R10, <#[R8]> */
		/* 8209C2B4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8209C2B4h case    7:*/		return 0x8209C2B8;
		  /* 8209C2B8h */ case    8:  		/* stw R10, <#[R11]> */
		/* 8209C2B8h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209C2B8h case    8:*/		return 0x8209C2BC;
		  /* 8209C2BCh */ case    9:  		/* b 8 */
		/* 8209C2BCh case    9:*/		return 0x8209C2C4;
		/* 8209C2BCh case    9:*/		return 0x8209C2C0;
	}
	return 0x8209C2C0;
} // Block from 8209C298h-8209C2C0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209C2C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C2C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C2C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C2C0);
		  /* 8209C2C0h */ case    0:  		/* stw R23, <#[R11]> */
		/* 8209C2C0h case    0:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 8209C2C0h case    0:*/		return 0x8209C2C4;
	}
	return 0x8209C2C4;
} // Block from 8209C2C0h-8209C2C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209C2C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C2C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C2C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C2C4);
		  /* 8209C2C4h */ case    0:  		/* addi R9, R9, -1 */
		/* 8209C2C4h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8209C2C4h case    0:*/		return 0x8209C2C8;
		  /* 8209C2C8h */ case    1:  		/* addi R8, R8, -4 */
		/* 8209C2C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFC);
		/* 8209C2C8h case    1:*/		return 0x8209C2CC;
		  /* 8209C2CCh */ case    2:  		/* addi R11, R11, -4 */
		/* 8209C2CCh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8209C2CCh case    2:*/		return 0x8209C2D0;
		  /* 8209C2D0h */ case    3:  		/* bc 16, CR0_LT, -36 */
		/* 8209C2D0h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209C2AC;  }
		/* 8209C2D0h case    3:*/		return 0x8209C2D4;
	}
	return 0x8209C2D4;
} // Block from 8209C2C4h-8209C2D4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209C2D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C2D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C2D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C2D4);
		  /* 8209C2D4h */ case    0:  		/* mr R3, R23 */
		/* 8209C2D4h case    0:*/		regs.R3 = regs.R23;
		/* 8209C2D4h case    0:*/		return 0x8209C2D8;
	}
	return 0x8209C2D8;
} // Block from 8209C2D4h-8209C2D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209C2D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C2D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C2D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C2D8);
		  /* 8209C2D8h */ case    0:  		/* subfic R10, R21, 31 */
		/* 8209C2D8h case    0:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R21,0x1F);
		/* 8209C2D8h case    0:*/		return 0x8209C2DC;
		  /* 8209C2DCh */ case    1:  		/* lwz R11, <#[R20 + 16]> */
		/* 8209C2DCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000010) );
		/* 8209C2DCh case    1:*/		return 0x8209C2E0;
		  /* 8209C2E0h */ case    2:  		/* subfic R9, R19, 0 */
		/* 8209C2E0h case    2:*/		cpu::op::subfic<0>(regs,&regs.R9,regs.R19,0x0);
		/* 8209C2E0h case    2:*/		return 0x8209C2E4;
		  /* 8209C2E4h */ case    3:  		/* lwz R8, <#[R1 - 152]> */
		/* 8209C2E4h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0xFFFFFF68) );
		/* 8209C2E4h case    3:*/		return 0x8209C2E8;
		  /* 8209C2E8h */ case    4:  		/* lis R7, -32768 */
		/* 8209C2E8h case    4:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8000);
		/* 8209C2E8h case    4:*/		return 0x8209C2EC;
		  /* 8209C2ECh */ case    5:  		/* subfe R9, R9, R9 */
		/* 8209C2ECh case    5:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 8209C2ECh case    5:*/		return 0x8209C2F0;
		  /* 8209C2F0h */ case    6:  		/* slw R10, R5, R10 */
		/* 8209C2F0h case    6:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R5,regs.R10);
		/* 8209C2F0h case    6:*/		return 0x8209C2F4;
		  /* 8209C2F4h */ case    7:  		/* and R9, R9, R7 */
		/* 8209C2F4h case    7:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 8209C2F4h case    7:*/		return 0x8209C2F8;
		  /* 8209C2F8h */ case    8:  		/* cmpwi CR6, R11, 64 */
		/* 8209C2F8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000040);
		/* 8209C2F8h case    8:*/		return 0x8209C2FC;
		  /* 8209C2FCh */ case    9:  		/* or R10, R10, R9 */
		/* 8209C2FCh case    9:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8209C2FCh case    9:*/		return 0x8209C300;
		  /* 8209C300h */ case   10:  		/* or R10, R10, R8 */
		/* 8209C300h case   10:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8209C300h case   10:*/		return 0x8209C304;
		  /* 8209C304h */ case   11:  		/* bc 4, CR6_EQ, 16 */
		/* 8209C304h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8209C314;  }
		/* 8209C304h case   11:*/		return 0x8209C308;
		  /* 8209C308h */ case   12:  		/* lwz R11, <#[R1 - 148]> */
		/* 8209C308h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0xFFFFFF6C) );
		/* 8209C308h case   12:*/		return 0x8209C30C;
		  /* 8209C30Ch */ case   13:  		/* stw R11, <#[R4 + 4]> */
		/* 8209C30Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 8209C30Ch case   13:*/		return 0x8209C310;
		  /* 8209C310h */ case   14:  		/* b 12 */
		/* 8209C310h case   14:*/		return 0x8209C31C;
		/* 8209C310h case   14:*/		return 0x8209C314;
	}
	return 0x8209C314;
} // Block from 8209C2D8h-8209C314h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8209C314h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C314( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C314) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C314);
		  /* 8209C314h */ case    0:  		/* cmpwi CR6, R11, 32 */
		/* 8209C314h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000020);
		/* 8209C314h case    0:*/		return 0x8209C318;
		  /* 8209C318h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 8209C318h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209C320;  }
		/* 8209C318h case    1:*/		return 0x8209C31C;
	}
	return 0x8209C31C;
} // Block from 8209C314h-8209C31Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209C31Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C31C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C31C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C31C);
		  /* 8209C31Ch */ case    0:  		/* stw R10, <#[R4]> */
		/* 8209C31Ch case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 8209C31Ch case    0:*/		return 0x8209C320;
	}
	return 0x8209C320;
} // Block from 8209C31Ch-8209C320h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209C320h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C320);
		  /* 8209C320h */ case    0:  		/* b -45212 */
		/* 8209C320h case    0:*/		return 0x82091284;
		/* 8209C320h case    0:*/		return 0x8209C324;
		  /* 8209C324h */ case    1:  		/* nop */
		/* 8209C324h case    1:*/		cpu::op::nop();
		/* 8209C324h case    1:*/		return 0x8209C328;
	}
	return 0x8209C328;
} // Block from 8209C320h-8209C328h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209C328h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C328);
		  /* 8209C328h */ case    0:  		/* mfspr R12, LR */
		/* 8209C328h case    0:*/		regs.R12 = regs.LR;
		/* 8209C328h case    0:*/		return 0x8209C32C;
		  /* 8209C32Ch */ case    1:  		/* bl -45304 */
		/* 8209C32Ch case    1:*/		regs.LR = 0x8209C330; return 0x82091234;
		/* 8209C32Ch case    1:*/		return 0x8209C330;
	}
	return 0x8209C330;
} // Block from 8209C328h-8209C330h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209C330h
// Function '_fflush_nolock'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C330);
		  /* 8209C330h */ case    0:  		/* stwu R1, <#[R1 - 272]> */
		/* 8209C330h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEF0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEF0);
		/* 8209C330h case    0:*/		return 0x8209C334;
		  /* 8209C334h */ case    1:  		/* li R22, 0 */
		/* 8209C334h case    1:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 8209C334h case    1:*/		return 0x8209C338;
		  /* 8209C338h */ case    2:  		/* mr R20, R3 */
		/* 8209C338h case    2:*/		regs.R20 = regs.R3;
		/* 8209C338h case    2:*/		return 0x8209C33C;
		  /* 8209C33Ch */ case    3:  		/* mr R23, R6 */
		/* 8209C33Ch case    3:*/		regs.R23 = regs.R6;
		/* 8209C33Ch case    3:*/		return 0x8209C340;
		  /* 8209C340h */ case    4:  		/* mr R25, R7 */
		/* 8209C340h case    4:*/		regs.R25 = regs.R7;
		/* 8209C340h case    4:*/		return 0x8209C344;
		  /* 8209C344h */ case    5:  		/* mr R24, R8 */
		/* 8209C344h case    5:*/		regs.R24 = regs.R8;
		/* 8209C344h case    5:*/		return 0x8209C348;
		  /* 8209C348h */ case    6:  		/* addi R3, R1, 128 */
		/* 8209C348h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 8209C348h case    6:*/		return 0x8209C34C;
		  /* 8209C34Ch */ case    7:  		/* mr R19, R22 */
		/* 8209C34Ch case    7:*/		regs.R19 = regs.R22;
		/* 8209C34Ch case    7:*/		return 0x8209C350;
		  /* 8209C350h */ case    8:  		/* mr R6, R22 */
		/* 8209C350h case    8:*/		regs.R6 = regs.R22;
		/* 8209C350h case    8:*/		return 0x8209C354;
		  /* 8209C354h */ case    9:  		/* mr R30, R22 */
		/* 8209C354h case    9:*/		regs.R30 = regs.R22;
		/* 8209C354h case    9:*/		return 0x8209C358;
		  /* 8209C358h */ case   10:  		/* mr R26, R22 */
		/* 8209C358h case   10:*/		regs.R26 = regs.R22;
		/* 8209C358h case   10:*/		return 0x8209C35C;
		  /* 8209C35Ch */ case   11:  		/* mr R28, R22 */
		/* 8209C35Ch case   11:*/		regs.R28 = regs.R22;
		/* 8209C35Ch case   11:*/		return 0x8209C360;
		  /* 8209C360h */ case   12:  		/* mr R29, R22 */
		/* 8209C360h case   12:*/		regs.R29 = regs.R22;
		/* 8209C360h case   12:*/		return 0x8209C364;
		  /* 8209C364h */ case   13:  		/* mr R31, R22 */
		/* 8209C364h case   13:*/		regs.R31 = regs.R22;
		/* 8209C364h case   13:*/		return 0x8209C368;
		  /* 8209C368h */ case   14:  		/* li R27, 1 */
		/* 8209C368h case   14:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 8209C368h case   14:*/		return 0x8209C36C;
		  /* 8209C36Ch */ case   15:  		/* mr R11, R22 */
		/* 8209C36Ch case   15:*/		regs.R11 = regs.R22;
		/* 8209C36Ch case   15:*/		return 0x8209C370;
		  /* 8209C370h */ case   16:  		/* cmplwi CR6, R10, 0 */
		/* 8209C370h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8209C370h case   16:*/		return 0x8209C374;
		  /* 8209C374h */ case   17:  		/* bc 4, CR6_EQ, 28 */
		/* 8209C374h case   17:*/		if ( !regs.CR[6].eq ) { return 0x8209C390;  }
		/* 8209C374h case   17:*/		return 0x8209C378;
		  /* 8209C378h */ case   18:  		/* bl -29808 */
		/* 8209C378h case   18:*/		regs.LR = 0x8209C37C; return 0x82094F08;
		/* 8209C378h case   18:*/		return 0x8209C37C;
		  /* 8209C37Ch */ case   19:  		/* li R11, 22 */
		/* 8209C37Ch case   19:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 8209C37Ch case   19:*/		return 0x8209C380;
		  /* 8209C380h */ case   20:  		/* stw R11, <#[R3]> */
		/* 8209C380h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209C380h case   20:*/		return 0x8209C384;
		  /* 8209C384h */ case   21:  		/* bl -35364 */
		/* 8209C384h case   21:*/		regs.LR = 0x8209C388; return 0x82093960;
		/* 8209C384h case   21:*/		return 0x8209C388;
		  /* 8209C388h */ case   22:  		/* li R3, 0 */
		/* 8209C388h case   22:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209C388h case   22:*/		return 0x8209C38C;
		  /* 8209C38Ch */ case   23:  		/* b 2292 */
		/* 8209C38Ch case   23:*/		return 0x8209CC80;
		/* 8209C38Ch case   23:*/		return 0x8209C390;
	}
	return 0x8209C390;
} // Block from 8209C330h-8209C390h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8209C390h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C390);
		  /* 8209C390h */ case    0:  		/* mr R7, R5 */
		/* 8209C390h case    0:*/		regs.R7 = regs.R5;
		/* 8209C390h case    0:*/		return 0x8209C394;
		  /* 8209C394h */ case    1:  		/* lbz R8, <#[R7]> */
		/* 8209C394h case    1:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 8209C394h case    1:*/		return 0x8209C398;
		  /* 8209C398h */ case    2:  		/* extsb R8, R8 */
		/* 8209C398h case    2:*/		cpu::op::extsb<0>(regs,&regs.R8,regs.R8);
		/* 8209C398h case    2:*/		return 0x8209C39C;
		  /* 8209C39Ch */ case    3:  		/* cmpwi CR6, R8, 32 */
		/* 8209C39Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000020);
		/* 8209C39Ch case    3:*/		return 0x8209C3A0;
		  /* 8209C3A0h */ case    4:  		/* bc 12, CR6_EQ, 28 */
		/* 8209C3A0h case    4:*/		if ( regs.CR[6].eq ) { return 0x8209C3BC;  }
		/* 8209C3A0h case    4:*/		return 0x8209C3A4;
		  /* 8209C3A4h */ case    5:  		/* cmpwi CR6, R8, 9 */
		/* 8209C3A4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000009);
		/* 8209C3A4h case    5:*/		return 0x8209C3A8;
		  /* 8209C3A8h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 8209C3A8h case    6:*/		if ( regs.CR[6].eq ) { return 0x8209C3BC;  }
		/* 8209C3A8h case    6:*/		return 0x8209C3AC;
		  /* 8209C3ACh */ case    7:  		/* cmpwi CR6, R8, 10 */
		/* 8209C3ACh case    7:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000000A);
		/* 8209C3ACh case    7:*/		return 0x8209C3B0;
	}
	return 0x8209C3B0;
} // Block from 8209C390h-8209C3B0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209C3B0h
// Function 'flsall'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C3B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C3B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C3B0);
		  /* 8209C3B0h */ case    0:  		/* bc 12, CR6_EQ, 12 */
		/* 8209C3B0h case    0:*/		if ( regs.CR[6].eq ) { return 0x8209C3BC;  }
		/* 8209C3B0h case    0:*/		return 0x8209C3B4;
		  /* 8209C3B4h */ case    1:  		/* cmpwi CR6, R8, 13 */
		/* 8209C3B4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000000D);
		/* 8209C3B4h case    1:*/		return 0x8209C3B8;
		  /* 8209C3B8h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 8209C3B8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8209C3C4;  }
		/* 8209C3B8h case    2:*/		return 0x8209C3BC;
	}
	return 0x8209C3BC;
} // Block from 8209C3B0h-8209C3BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209C3BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C3BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C3BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C3BC);
		  /* 8209C3BCh */ case    0:  		/* addi R7, R7, 1 */
		/* 8209C3BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8209C3BCh case    0:*/		return 0x8209C3C0;
		  /* 8209C3C0h */ case    1:  		/* b -44 */
		/* 8209C3C0h case    1:*/		return 0x8209C394;
		/* 8209C3C0h case    1:*/		return 0x8209C3C4;
	}
	return 0x8209C3C4;
} // Block from 8209C3BCh-8209C3C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209C3C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C3C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C3C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C3C4);
		  /* 8209C3C4h */ case    0:  		/* lis R8, 0 */
		/* 8209C3C4h case    0:*/		cpu::op::lis<0>(regs,&regs.R8,0x0);
		/* 8209C3C4h case    0:*/		return 0x8209C3C8;
		  /* 8209C3C8h */ case    1:  		/* ori R21, R8, 32768 */
		/* 8209C3C8h case    1:*/		cpu::op::ori<0>(regs,&regs.R21,regs.R8,0x8000);
		/* 8209C3C8h case    1:*/		return 0x8209C3CC;
		  /* 8209C3CCh */ case    2:  		/* lbz R8, <#[R7]> */
		/* 8209C3CCh case    2:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 8209C3CCh case    2:*/		return 0x8209C3D0;
		  /* 8209C3D0h */ case    3:  		/* addi R7, R7, 1 */
		/* 8209C3D0h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8209C3D0h case    3:*/		return 0x8209C3D4;
		  /* 8209C3D4h */ case    4:  		/* cmplwi CR6, R11, 11 */
		/* 8209C3D4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000B);
		/* 8209C3D4h case    4:*/		return 0x8209C3D8;
		  /* 8209C3D8h */ case    5:  		/* bc 12, CR6_GT, 904 */
		/* 8209C3D8h case    5:*/		if ( regs.CR[6].gt ) { return 0x8209C760;  }
		/* 8209C3D8h case    5:*/		return 0x8209C3DC;
		  /* 8209C3DCh */ case    6:  		/* lis R12, -32255 */
		/* 8209C3DCh case    6:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8201);
		/* 8209C3DCh case    6:*/		return 0x8209C3E0;
		  /* 8209C3E0h */ case    7:  		/* addi R12, R12, -17824 */
		/* 8209C3E0h case    7:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFBA60);
		/* 8209C3E0h case    7:*/		return 0x8209C3E4;
		  /* 8209C3E4h */ case    8:  		/* lbzx R0, <#[R12 + R11]> */
		/* 8209C3E4h case    8:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R11 + 0x00000000) );
		/* 8209C3E4h case    8:*/		return 0x8209C3E8;
		  /* 8209C3E8h */ case    9:  		/* rlwinm R0, R0, 2, 0, 29 */
		/* 8209C3E8h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R0,regs.R0);
		/* 8209C3E8h case    9:*/		return 0x8209C3EC;
		  /* 8209C3ECh */ case   10:  		/* lis R12, -32246 */
		/* 8209C3ECh case   10:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF820A);
		/* 8209C3ECh case   10:*/		return 0x8209C3F0;
		  /* 8209C3F0h */ case   11:  		/* ori R0, R0, 0 */
		/* 8209C3F0h case   11:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 8209C3F0h case   11:*/		return 0x8209C3F4;
		  /* 8209C3F4h */ case   12:  		/* addi R12, R12, -15356 */
		/* 8209C3F4h case   12:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFC404);
		/* 8209C3F4h case   12:*/		return 0x8209C3F8;
		  /* 8209C3F8h */ case   13:  		/* add R12, R12, R0 */
		/* 8209C3F8h case   13:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 8209C3F8h case   13:*/		return 0x8209C3FC;
		  /* 8209C3FCh */ case   14:  		/* mtspr CTR, R12 */
		/* 8209C3FCh case   14:*/		regs.CTR = regs.R12;
		/* 8209C3FCh case   14:*/		return 0x8209C400;
		  /* 8209C400h */ case   15:  		/* bcctr 20, CR0_LT */
		/* 8209C400h case   15:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 8209C400h case   15:*/		return 0x8209C404;
		  /* 8209C404h */ case   16:  		/* extsb R11, R8 */
		/* 8209C404h case   16:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R8);
		/* 8209C404h case   16:*/		return 0x8209C408;
		  /* 8209C408h */ case   17:  		/* cmpwi CR6, R11, 49 */
		/* 8209C408h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000031);
		/* 8209C408h case   17:*/		return 0x8209C40C;
		  /* 8209C40Ch */ case   18:  		/* bc 12, CR6_LT, 24 */
		/* 8209C40Ch case   18:*/		if ( regs.CR[6].lt ) { return 0x8209C424;  }
		/* 8209C40Ch case   18:*/		return 0x8209C410;
		  /* 8209C410h */ case   19:  		/* cmpwi CR6, R11, 57 */
		/* 8209C410h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000039);
		/* 8209C410h case   19:*/		return 0x8209C414;
		  /* 8209C414h */ case   20:  		/* bc 12, CR6_GT, 16 */
		/* 8209C414h case   20:*/		if ( regs.CR[6].gt ) { return 0x8209C424;  }
		/* 8209C414h case   20:*/		return 0x8209C418;
		  /* 8209C418h */ case   21:  		/* li R11, 3 */
		/* 8209C418h case   21:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 8209C418h case   21:*/		return 0x8209C41C;
		  /* 8209C41Ch */ case   22:  		/* addi R7, R7, -1 */
		/* 8209C41Ch case   22:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0xFFFFFFFF);
		/* 8209C41Ch case   22:*/		return 0x8209C420;
		  /* 8209C420h */ case   23:  		/* b -84 */
		/* 8209C420h case   23:*/		return 0x8209C3CC;
		/* 8209C420h case   23:*/		return 0x8209C424;
	}
	return 0x8209C424;
} // Block from 8209C3C4h-8209C424h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8209C424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C424);
		  /* 8209C424h */ case    0:  		/* lwz R8, <#[R10]> */
		/* 8209C424h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8209C424h case    0:*/		return 0x8209C428;
		  /* 8209C428h */ case    1:  		/* lwz R8, <#[R8 + 188]> */
		/* 8209C428h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x000000BC) );
		/* 8209C428h case    1:*/		return 0x8209C42C;
		  /* 8209C42Ch */ case    2:  		/* lwz R8, <#[R8]> */
		/* 8209C42Ch case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000000) );
		/* 8209C42Ch case    2:*/		return 0x8209C430;
		  /* 8209C430h */ case    3:  		/* lbz R8, <#[R8]> */
		/* 8209C430h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000000) );
		/* 8209C430h case    3:*/		return 0x8209C434;
		  /* 8209C434h */ case    4:  		/* extsb R8, R8 */
		/* 8209C434h case    4:*/		cpu::op::extsb<0>(regs,&regs.R8,regs.R8);
		/* 8209C434h case    4:*/		return 0x8209C438;
		  /* 8209C438h */ case    5:  		/* cmpw CR6, R11, R8 */
		/* 8209C438h case    5:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 8209C438h case    5:*/		return 0x8209C43C;
		  /* 8209C43Ch */ case    6:  		/* bc 4, CR6_EQ, 12 */
		/* 8209C43Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x8209C448;  }
		/* 8209C43Ch case    6:*/		return 0x8209C440;
		  /* 8209C440h */ case    7:  		/* li R11, 5 */
		/* 8209C440h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 8209C440h case    7:*/		return 0x8209C444;
		  /* 8209C444h */ case    8:  		/* b -120 */
		/* 8209C444h case    8:*/		return 0x8209C3CC;
		/* 8209C444h case    8:*/		return 0x8209C448;
	}
	return 0x8209C448;
} // Block from 8209C424h-8209C448h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209C448h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C448);
		  /* 8209C448h */ case    0:  		/* cmpwi CR6, R11, 43 */
		/* 8209C448h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002B);
		/* 8209C448h case    0:*/		return 0x8209C44C;
		  /* 8209C44Ch */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 8209C44Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8209C474;  }
		/* 8209C44Ch case    1:*/		return 0x8209C450;
		  /* 8209C450h */ case    2:  		/* cmpwi CR6, R11, 45 */
		/* 8209C450h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002D);
		/* 8209C450h case    2:*/		return 0x8209C454;
		  /* 8209C454h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 8209C454h case    3:*/		if ( regs.CR[6].eq ) { return 0x8209C468;  }
		/* 8209C454h case    3:*/		return 0x8209C458;
		  /* 8209C458h */ case    4:  		/* cmpwi CR6, R11, 48 */
		/* 8209C458h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000030);
		/* 8209C458h case    4:*/		return 0x8209C45C;
		  /* 8209C45Ch */ case    5:  		/* bc 4, CR6_EQ, 688 */
		/* 8209C45Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x8209C70C;  }
		/* 8209C45Ch case    5:*/		return 0x8209C460;
		  /* 8209C460h */ case    6:  		/* li R11, 1 */
		/* 8209C460h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8209C460h case    6:*/		return 0x8209C464;
		  /* 8209C464h */ case    7:  		/* b -152 */
		/* 8209C464h case    7:*/		return 0x8209C3CC;
		/* 8209C464h case    7:*/		return 0x8209C468;
	}
	return 0x8209C468;
} // Block from 8209C448h-8209C468h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209C468h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C468( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C468) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C468);
		  /* 8209C468h */ case    0:  		/* li R11, 2 */
		/* 8209C468h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8209C468h case    0:*/		return 0x8209C46C;
		  /* 8209C46Ch */ case    1:  		/* mr R19, R21 */
		/* 8209C46Ch case    1:*/		regs.R19 = regs.R21;
		/* 8209C46Ch case    1:*/		return 0x8209C470;
		  /* 8209C470h */ case    2:  		/* b -164 */
		/* 8209C470h case    2:*/		return 0x8209C3CC;
		/* 8209C470h case    2:*/		return 0x8209C474;
	}
	return 0x8209C474;
} // Block from 8209C468h-8209C474h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209C474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C474);
		  /* 8209C474h */ case    0:  		/* li R11, 2 */
		/* 8209C474h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8209C474h case    0:*/		return 0x8209C478;
		  /* 8209C478h */ case    1:  		/* mr R19, R22 */
		/* 8209C478h case    1:*/		regs.R19 = regs.R22;
		/* 8209C478h case    1:*/		return 0x8209C47C;
		  /* 8209C47Ch */ case    2:  		/* b -176 */
		/* 8209C47Ch case    2:*/		return 0x8209C3CC;
		/* 8209C47Ch case    2:*/		return 0x8209C480;
		  /* 8209C480h */ case    3:  		/* extsb R11, R8 */
		/* 8209C480h case    3:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R8);
		/* 8209C480h case    3:*/		return 0x8209C484;
		  /* 8209C484h */ case    4:  		/* li R30, 1 */
		/* 8209C484h case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 8209C484h case    4:*/		return 0x8209C488;
		  /* 8209C488h */ case    5:  		/* cmpwi CR6, R11, 49 */
		/* 8209C488h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000031);
		/* 8209C488h case    5:*/		return 0x8209C48C;
		  /* 8209C48Ch */ case    6:  		/* bc 12, CR6_LT, 12 */
		/* 8209C48Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x8209C498;  }
		/* 8209C48Ch case    6:*/		return 0x8209C490;
		  /* 8209C490h */ case    7:  		/* cmpwi CR6, R11, 57 */
		/* 8209C490h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000039);
		/* 8209C490h case    7:*/		return 0x8209C494;
		  /* 8209C494h */ case    8:  		/* bc 4, CR6_GT, -124 */
		/* 8209C494h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8209C418;  }
		/* 8209C494h case    8:*/		return 0x8209C498;
	}
	return 0x8209C498;
} // Block from 8209C474h-8209C498h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209C498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C498);
		  /* 8209C498h */ case    0:  		/* lwz R8, <#[R10]> */
		/* 8209C498h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8209C498h case    0:*/		return 0x8209C49C;
		  /* 8209C49Ch */ case    1:  		/* lwz R8, <#[R8 + 188]> */
		/* 8209C49Ch case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x000000BC) );
		/* 8209C49Ch case    1:*/		return 0x8209C4A0;
		  /* 8209C4A0h */ case    2:  		/* lwz R8, <#[R8]> */
		/* 8209C4A0h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000000) );
		/* 8209C4A0h case    2:*/		return 0x8209C4A4;
		  /* 8209C4A4h */ case    3:  		/* lbz R8, <#[R8]> */
		/* 8209C4A4h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000000) );
		/* 8209C4A4h case    3:*/		return 0x8209C4A8;
		  /* 8209C4A8h */ case    4:  		/* extsb R8, R8 */
		/* 8209C4A8h case    4:*/		cpu::op::extsb<0>(regs,&regs.R8,regs.R8);
		/* 8209C4A8h case    4:*/		return 0x8209C4AC;
		  /* 8209C4ACh */ case    5:  		/* cmpw CR6, R11, R8 */
		/* 8209C4ACh case    5:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 8209C4ACh case    5:*/		return 0x8209C4B0;
		  /* 8209C4B0h */ case    6:  		/* bc 4, CR6_EQ, 12 */
		/* 8209C4B0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8209C4BC;  }
		/* 8209C4B0h case    6:*/		return 0x8209C4B4;
		  /* 8209C4B4h */ case    7:  		/* li R11, 4 */
		/* 8209C4B4h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 8209C4B4h case    7:*/		return 0x8209C4B8;
		  /* 8209C4B8h */ case    8:  		/* b -236 */
		/* 8209C4B8h case    8:*/		return 0x8209C3CC;
		/* 8209C4B8h case    8:*/		return 0x8209C4BC;
	}
	return 0x8209C4BC;
} // Block from 8209C498h-8209C4BCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209C4BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C4BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C4BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C4BC);
		  /* 8209C4BCh */ case    0:  		/* cmpwi CR6, R11, 43 */
		/* 8209C4BCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002B);
		/* 8209C4BCh case    0:*/		return 0x8209C4C0;
		  /* 8209C4C0h */ case    1:  		/* bc 12, CR6_EQ, 60 */
		/* 8209C4C0h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209C4FC;  }
		/* 8209C4C0h case    1:*/		return 0x8209C4C4;
		  /* 8209C4C4h */ case    2:  		/* cmpwi CR6, R11, 45 */
		/* 8209C4C4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002D);
		/* 8209C4C4h case    2:*/		return 0x8209C4C8;
		  /* 8209C4C8h */ case    3:  		/* bc 12, CR6_EQ, 52 */
		/* 8209C4C8h case    3:*/		if ( regs.CR[6].eq ) { return 0x8209C4FC;  }
		/* 8209C4C8h case    3:*/		return 0x8209C4CC;
		  /* 8209C4CCh */ case    4:  		/* cmpwi CR6, R11, 48 */
		/* 8209C4CCh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000030);
		/* 8209C4CCh case    4:*/		return 0x8209C4D0;
		  /* 8209C4D0h */ case    5:  		/* bc 12, CR6_EQ, -112 */
		/* 8209C4D0h case    5:*/		if ( regs.CR[6].eq ) { return 0x8209C460;  }
		/* 8209C4D0h case    5:*/		return 0x8209C4D4;
		  /* 8209C4D4h */ case    6:  		/* cmpwi CR6, R11, 67 */
		/* 8209C4D4h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000043);
		/* 8209C4D4h case    6:*/		return 0x8209C4D8;
		  /* 8209C4D8h */ case    7:  		/* bc 4, CR6_GT, 564 */
		/* 8209C4D8h case    7:*/		if ( !regs.CR[6].gt ) { return 0x8209C70C;  }
		/* 8209C4D8h case    7:*/		return 0x8209C4DC;
		  /* 8209C4DCh */ case    8:  		/* cmpwi CR6, R11, 69 */
		/* 8209C4DCh case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000045);
		/* 8209C4DCh case    8:*/		return 0x8209C4E0;
		  /* 8209C4E0h */ case    9:  		/* bc 4, CR6_GT, 20 */
		/* 8209C4E0h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8209C4F4;  }
		/* 8209C4E0h case    9:*/		return 0x8209C4E4;
		  /* 8209C4E4h */ case   10:  		/* cmpwi CR6, R11, 99 */
		/* 8209C4E4h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000063);
		/* 8209C4E4h case   10:*/		return 0x8209C4E8;
		  /* 8209C4E8h */ case   11:  		/* bc 4, CR6_GT, 548 */
		/* 8209C4E8h case   11:*/		if ( !regs.CR[6].gt ) { return 0x8209C70C;  }
		/* 8209C4E8h case   11:*/		return 0x8209C4EC;
		  /* 8209C4ECh */ case   12:  		/* cmpwi CR6, R11, 101 */
		/* 8209C4ECh case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000065);
		/* 8209C4ECh case   12:*/		return 0x8209C4F0;
		  /* 8209C4F0h */ case   13:  		/* bc 12, CR6_GT, 540 */
		/* 8209C4F0h case   13:*/		if ( regs.CR[6].gt ) { return 0x8209C70C;  }
		/* 8209C4F0h case   13:*/		return 0x8209C4F4;
	}
	return 0x8209C4F4;
} // Block from 8209C4BCh-8209C4F4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209C4F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C4F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C4F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C4F4);
		  /* 8209C4F4h */ case    0:  		/* li R11, 6 */
		/* 8209C4F4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x6);
		/* 8209C4F4h case    0:*/		return 0x8209C4F8;
		  /* 8209C4F8h */ case    1:  		/* b -300 */
		/* 8209C4F8h case    1:*/		return 0x8209C3CC;
		/* 8209C4F8h case    1:*/		return 0x8209C4FC;
	}
	return 0x8209C4FC;
} // Block from 8209C4F4h-8209C4FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209C4FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C4FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C4FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C4FC);
		  /* 8209C4FCh */ case    0:  		/* addi R7, R7, -1 */
		/* 8209C4FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0xFFFFFFFF);
		/* 8209C4FCh case    0:*/		return 0x8209C500;
		  /* 8209C500h */ case    1:  		/* li R11, 11 */
		/* 8209C500h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0xB);
		/* 8209C500h case    1:*/		return 0x8209C504;
		  /* 8209C504h */ case    2:  		/* b -312 */
		/* 8209C504h case    2:*/		return 0x8209C3CC;
		/* 8209C504h case    2:*/		return 0x8209C508;
		  /* 8209C508h */ case    3:  		/* extsb R11, R8 */
		/* 8209C508h case    3:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R8);
		/* 8209C508h case    3:*/		return 0x8209C50C;
		  /* 8209C50Ch */ case    4:  		/* cmpwi CR6, R11, 49 */
		/* 8209C50Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000031);
		/* 8209C50Ch case    4:*/		return 0x8209C510;
		  /* 8209C510h */ case    5:  		/* bc 12, CR6_LT, 12 */
		/* 8209C510h case    5:*/		if ( regs.CR[6].lt ) { return 0x8209C51C;  }
		/* 8209C510h case    5:*/		return 0x8209C514;
		  /* 8209C514h */ case    6:  		/* cmpwi CR6, R11, 57 */
		/* 8209C514h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000039);
		/* 8209C514h case    6:*/		return 0x8209C518;
		  /* 8209C518h */ case    7:  		/* bc 4, CR6_GT, -256 */
		/* 8209C518h case    7:*/		if ( !regs.CR[6].gt ) { return 0x8209C418;  }
		/* 8209C518h case    7:*/		return 0x8209C51C;
	}
	return 0x8209C51C;
} // Block from 8209C4FCh-8209C51Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209C51Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C51C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C51C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C51C);
		  /* 8209C51Ch */ case    0:  		/* lwz R8, <#[R10]> */
		/* 8209C51Ch case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8209C51Ch case    0:*/		return 0x8209C520;
		  /* 8209C520h */ case    1:  		/* lwz R8, <#[R8 + 188]> */
		/* 8209C520h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x000000BC) );
		/* 8209C520h case    1:*/		return 0x8209C524;
		  /* 8209C524h */ case    2:  		/* lwz R8, <#[R8]> */
		/* 8209C524h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000000) );
		/* 8209C524h case    2:*/		return 0x8209C528;
		  /* 8209C528h */ case    3:  		/* lbz R8, <#[R8]> */
		/* 8209C528h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000000) );
		/* 8209C528h case    3:*/		return 0x8209C52C;
		  /* 8209C52Ch */ case    4:  		/* extsb R8, R8 */
		/* 8209C52Ch case    4:*/		cpu::op::extsb<0>(regs,&regs.R8,regs.R8);
		/* 8209C52Ch case    4:*/		return 0x8209C530;
		  /* 8209C530h */ case    5:  		/* cmpw CR6, R11, R8 */
		/* 8209C530h case    5:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 8209C530h case    5:*/		return 0x8209C534;
		  /* 8209C534h */ case    6:  		/* bc 12, CR6_EQ, -244 */
		/* 8209C534h case    6:*/		if ( regs.CR[6].eq ) { return 0x8209C440;  }
		/* 8209C534h case    6:*/		return 0x8209C538;
		  /* 8209C538h */ case    7:  		/* cmpwi CR6, R11, 48 */
		/* 8209C538h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000030);
		/* 8209C538h case    7:*/		return 0x8209C53C;
		  /* 8209C53Ch */ case    8:  		/* bc 12, CR6_EQ, -220 */
		/* 8209C53Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x8209C460;  }
		/* 8209C53Ch case    8:*/		return 0x8209C540;
		  /* 8209C540h */ case    9:  		/* mr R7, R5 */
		/* 8209C540h case    9:*/		regs.R7 = regs.R5;
		/* 8209C540h case    9:*/		return 0x8209C544;
		  /* 8209C544h */ case   10:  		/* stw R7, <#[R4]> */
		/* 8209C544h case   10:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R4 + 0x00000000) );
		/* 8209C544h case   10:*/		return 0x8209C548;
		  /* 8209C548h */ case   11:  		/* cmpwi CR6, R30, 0 */
		/* 8209C548h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 8209C548h case   11:*/		return 0x8209C54C;
		  /* 8209C54Ch */ case   12:  		/* bc 12, CR6_EQ, 1744 */
		/* 8209C54Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x8209CC1C;  }
		/* 8209C54Ch case   12:*/		return 0x8209C550;
		  /* 8209C550h */ case   13:  		/* cmplwi CR6, R6, 24 */
		/* 8209C550h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000018);
		/* 8209C550h case   13:*/		return 0x8209C554;
		  /* 8209C554h */ case   14:  		/* bc 4, CR6_GT, 40 */
		/* 8209C554h case   14:*/		if ( !regs.CR[6].gt ) { return 0x8209C57C;  }
		/* 8209C554h case   14:*/		return 0x8209C558;
		  /* 8209C558h */ case   15:  		/* lbz R11, <#[R1 + 151]> */
		/* 8209C558h case   15:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000097) );
		/* 8209C558h case   15:*/		return 0x8209C55C;
		  /* 8209C55Ch */ case   16:  		/* extsb R11, R11 */
		/* 8209C55Ch case   16:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 8209C55Ch case   16:*/		return 0x8209C560;
		  /* 8209C560h */ case   17:  		/* cmpwi CR6, R11, 5 */
		/* 8209C560h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000005);
		/* 8209C560h case   17:*/		return 0x8209C564;
		  /* 8209C564h */ case   18:  		/* bc 12, CR6_LT, 12 */
		/* 8209C564h case   18:*/		if ( regs.CR[6].lt ) { return 0x8209C570;  }
		/* 8209C564h case   18:*/		return 0x8209C568;
		  /* 8209C568h */ case   19:  		/* addi R11, R11, 1 */
		/* 8209C568h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209C568h case   19:*/		return 0x8209C56C;
		  /* 8209C56Ch */ case   20:  		/* stb R11, <#[R1 + 151]> */
		/* 8209C56Ch case   20:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000097) );
		/* 8209C56Ch case   20:*/		return 0x8209C570;
	}
	return 0x8209C570;
} // Block from 8209C51Ch-8209C570h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8209C570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C570);
		  /* 8209C570h */ case    0:  		/* li R6, 24 */
		/* 8209C570h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x18);
		/* 8209C570h case    0:*/		return 0x8209C574;
		  /* 8209C574h */ case    1:  		/* addi R3, R3, -1 */
		/* 8209C574h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0xFFFFFFFF);
		/* 8209C574h case    1:*/		return 0x8209C578;
		  /* 8209C578h */ case    2:  		/* addi R31, R31, 1 */
		/* 8209C578h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8209C578h case    2:*/		return 0x8209C57C;
	}
	return 0x8209C57C;
} // Block from 8209C570h-8209C57Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209C57Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C57C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C57C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C57C);
		  /* 8209C57Ch */ case    0:  		/* cmplwi CR6, R6, 0 */
		/* 8209C57Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8209C57Ch case    0:*/		return 0x8209C580;
		  /* 8209C580h */ case    1:  		/* bc 12, CR6_EQ, 1672 */
		/* 8209C580h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209CC08;  }
		/* 8209C580h case    1:*/		return 0x8209C584;
		  /* 8209C584h */ case    2:  		/* lbzu R11, <#[R3 - 1]> */
		/* 8209C584h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0xFFFFFFFF) );
		regs.R3 = (uint32)(regs.R3 + 0xFFFFFFFF);
		/* 8209C584h case    2:*/		return 0x8209C588;
	}
	return 0x8209C588;
} // Block from 8209C57Ch-8209C588h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209C588h
// Function '_flushall'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C588( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C588) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C588);
		  /* 8209C588h */ case    0:  		/* b 608 */
		/* 8209C588h case    0:*/		return 0x8209C7E8;
		/* 8209C588h case    0:*/		return 0x8209C58C;
		  /* 8209C58Ch */ case    1:  		/* extsb R11, R8 */
		/* 8209C58Ch case    1:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R8);
		/* 8209C58Ch case    1:*/		return 0x8209C590;
	}
	return 0x8209C590;
} // Block from 8209C588h-8209C590h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209C590h
// Function '__initmbctable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C590( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C590) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C590);
		  /* 8209C590h */ case    0:  		/* li R30, 1 */
		/* 8209C590h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 8209C590h case    0:*/		return 0x8209C594;
		  /* 8209C594h */ case    1:  		/* b 56 */
		/* 8209C594h case    1:*/		return 0x8209C5CC;
		/* 8209C594h case    1:*/		return 0x8209C598;
		  /* 8209C598h */ case    2:  		/* cmpwi CR6, R11, 57 */
		/* 8209C598h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000039);
		/* 8209C598h case    2:*/		return 0x8209C59C;
		  /* 8209C59Ch */ case    3:  		/* bc 12, CR6_GT, 56 */
		/* 8209C59Ch case    3:*/		if ( regs.CR[6].gt ) { return 0x8209C5D4;  }
		/* 8209C59Ch case    3:*/		return 0x8209C5A0;
		  /* 8209C5A0h */ case    4:  		/* cmplwi CR6, R6, 25 */
		/* 8209C5A0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000019);
		/* 8209C5A0h case    4:*/		return 0x8209C5A4;
		  /* 8209C5A4h */ case    5:  		/* bc 4, CR6_LT, 24 */
		/* 8209C5A4h case    5:*/		if ( !regs.CR[6].lt ) { return 0x8209C5BC;  }
		/* 8209C5A4h case    5:*/		return 0x8209C5A8;
		  /* 8209C5A8h */ case    6:  		/* addi R11, R11, -48 */
		/* 8209C5A8h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFD0);
		/* 8209C5A8h case    6:*/		return 0x8209C5AC;
		  /* 8209C5ACh */ case    7:  		/* addi R6, R6, 1 */
		/* 8209C5ACh case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8209C5ACh case    7:*/		return 0x8209C5B0;
		  /* 8209C5B0h */ case    8:  		/* stb R11, <#[R3]> */
		/* 8209C5B0h case    8:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209C5B0h case    8:*/		return 0x8209C5B4;
		  /* 8209C5B4h */ case    9:  		/* addi R3, R3, 1 */
		/* 8209C5B4h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 8209C5B4h case    9:*/		return 0x8209C5B8;
		  /* 8209C5B8h */ case   10:  		/* b 8 */
		/* 8209C5B8h case   10:*/		return 0x8209C5C0;
		/* 8209C5B8h case   10:*/		return 0x8209C5BC;
	}
	return 0x8209C5BC;
} // Block from 8209C590h-8209C5BCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209C5BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C5BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C5BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C5BC);
		  /* 8209C5BCh */ case    0:  		/* addi R31, R31, 1 */
		/* 8209C5BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8209C5BCh case    0:*/		return 0x8209C5C0;
	}
	return 0x8209C5C0;
} // Block from 8209C5BCh-8209C5C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209C5C0h
// Function '_flswbuf'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C5C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C5C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C5C0);
		  /* 8209C5C0h */ case    0:  		/* lbz R11, <#[R7]> */
		/* 8209C5C0h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 8209C5C0h case    0:*/		return 0x8209C5C4;
		  /* 8209C5C4h */ case    1:  		/* addi R7, R7, 1 */
		/* 8209C5C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8209C5C4h case    1:*/		return 0x8209C5C8;
		  /* 8209C5C8h */ case    2:  		/* extsb R11, R11 */
		/* 8209C5C8h case    2:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 8209C5C8h case    2:*/		return 0x8209C5CC;
	}
	return 0x8209C5CC;
} // Block from 8209C5C0h-8209C5CCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209C5CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C5CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C5CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C5CC);
		  /* 8209C5CCh */ case    0:  		/* cmpwi CR6, R11, 48 */
		/* 8209C5CCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000030);
		/* 8209C5CCh case    0:*/		return 0x8209C5D0;
		  /* 8209C5D0h */ case    1:  		/* bc 4, CR6_LT, -56 */
		/* 8209C5D0h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8209C598;  }
		/* 8209C5D0h case    1:*/		return 0x8209C5D4;
	}
	return 0x8209C5D4;
} // Block from 8209C5CCh-8209C5D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209C5D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C5D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C5D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C5D4);
		  /* 8209C5D4h */ case    0:  		/* lwz R8, <#[R10]> */
		/* 8209C5D4h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8209C5D4h case    0:*/		return 0x8209C5D8;
		  /* 8209C5D8h */ case    1:  		/* lwz R8, <#[R8 + 188]> */
		/* 8209C5D8h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x000000BC) );
		/* 8209C5D8h case    1:*/		return 0x8209C5DC;
		  /* 8209C5DCh */ case    2:  		/* lwz R8, <#[R8]> */
		/* 8209C5DCh case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000000) );
		/* 8209C5DCh case    2:*/		return 0x8209C5E0;
		  /* 8209C5E0h */ case    3:  		/* lbz R8, <#[R8]> */
		/* 8209C5E0h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000000) );
		/* 8209C5E0h case    3:*/		return 0x8209C5E4;
		  /* 8209C5E4h */ case    4:  		/* extsb R8, R8 */
		/* 8209C5E4h case    4:*/		cpu::op::extsb<0>(regs,&regs.R8,regs.R8);
		/* 8209C5E4h case    4:*/		return 0x8209C5E8;
		  /* 8209C5E8h */ case    5:  		/* cmpw CR6, R11, R8 */
		/* 8209C5E8h case    5:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 8209C5E8h case    5:*/		return 0x8209C5EC;
		  /* 8209C5ECh */ case    6:  		/* bc 12, CR6_EQ, -312 */
		/* 8209C5ECh case    6:*/		if ( regs.CR[6].eq ) { return 0x8209C4B4;  }
		/* 8209C5ECh case    6:*/		return 0x8209C5F0;
		  /* 8209C5F0h */ case    7:  		/* cmpwi CR6, R11, 43 */
		/* 8209C5F0h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002B);
		/* 8209C5F0h case    7:*/		return 0x8209C5F4;
		  /* 8209C5F4h */ case    8:  		/* bc 12, CR6_EQ, -248 */
		/* 8209C5F4h case    8:*/		if ( regs.CR[6].eq ) { return 0x8209C4FC;  }
		/* 8209C5F4h case    8:*/		return 0x8209C5F8;
		  /* 8209C5F8h */ case    9:  		/* cmpwi CR6, R11, 45 */
		/* 8209C5F8h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002D);
		/* 8209C5F8h case    9:*/		return 0x8209C5FC;
		  /* 8209C5FCh */ case   10:  		/* bc 12, CR6_EQ, -256 */
		/* 8209C5FCh case   10:*/		if ( regs.CR[6].eq ) { return 0x8209C4FC;  }
		/* 8209C5FCh case   10:*/		return 0x8209C600;
		  /* 8209C600h */ case   11:  		/* b -300 */
		/* 8209C600h case   11:*/		return 0x8209C4D4;
		/* 8209C600h case   11:*/		return 0x8209C604;
		  /* 8209C604h */ case   12:  		/* li R30, 1 */
		/* 8209C604h case   12:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 8209C604h case   12:*/		return 0x8209C608;
		  /* 8209C608h */ case   13:  		/* li R26, 1 */
		/* 8209C608h case   13:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 8209C608h case   13:*/		return 0x8209C60C;
		  /* 8209C60Ch */ case   14:  		/* cmplwi CR6, R6, 0 */
		/* 8209C60Ch case   14:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8209C60Ch case   14:*/		return 0x8209C610;
		  /* 8209C610h */ case   15:  		/* bc 4, CR6_EQ, 32 */
		/* 8209C610h case   15:*/		if ( !regs.CR[6].eq ) { return 0x8209C630;  }
		/* 8209C610h case   15:*/		return 0x8209C614;
		  /* 8209C614h */ case   16:  		/* b 16 */
		/* 8209C614h case   16:*/		return 0x8209C624;
		/* 8209C614h case   16:*/		return 0x8209C618;
		  /* 8209C618h */ case   17:  		/* lbz R8, <#[R7]> */
		/* 8209C618h case   17:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 8209C618h case   17:*/		return 0x8209C61C;
		  /* 8209C61Ch */ case   18:  		/* addi R31, R31, -1 */
		/* 8209C61Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 8209C61Ch case   18:*/		return 0x8209C620;
		  /* 8209C620h */ case   19:  		/* addi R7, R7, 1 */
		/* 8209C620h case   19:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8209C620h case   19:*/		return 0x8209C624;
	}
	return 0x8209C624;
} // Block from 8209C5D4h-8209C624h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8209C624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C624);
		  /* 8209C624h */ case    0:  		/* extsb R11, R8 */
		/* 8209C624h case    0:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R8);
		/* 8209C624h case    0:*/		return 0x8209C628;
		  /* 8209C628h */ case    1:  		/* cmpwi CR6, R11, 48 */
		/* 8209C628h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000030);
		/* 8209C628h case    1:*/		return 0x8209C62C;
		  /* 8209C62Ch */ case    2:  		/* bc 12, CR6_EQ, -20 */
		/* 8209C62Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x8209C618;  }
		/* 8209C62Ch case    2:*/		return 0x8209C630;
	}
	return 0x8209C630;
} // Block from 8209C624h-8209C630h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209C630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C630);
		  /* 8209C630h */ case    0:  		/* extsb R11, R8 */
		/* 8209C630h case    0:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R8);
		/* 8209C630h case    0:*/		return 0x8209C634;
		  /* 8209C634h */ case    1:  		/* b 52 */
		/* 8209C634h case    1:*/		return 0x8209C668;
		/* 8209C634h case    1:*/		return 0x8209C638;
		  /* 8209C638h */ case    2:  		/* cmpwi CR6, R11, 57 */
		/* 8209C638h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000039);
		/* 8209C638h case    2:*/		return 0x8209C63C;
		  /* 8209C63Ch */ case    3:  		/* bc 12, CR6_GT, -76 */
		/* 8209C63Ch case    3:*/		if ( regs.CR[6].gt ) { return 0x8209C5F0;  }
		/* 8209C63Ch case    3:*/		return 0x8209C640;
		  /* 8209C640h */ case    4:  		/* cmplwi CR6, R6, 25 */
		/* 8209C640h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000019);
		/* 8209C640h case    4:*/		return 0x8209C644;
		  /* 8209C644h */ case    5:  		/* bc 4, CR6_LT, 24 */
		/* 8209C644h case    5:*/		if ( !regs.CR[6].lt ) { return 0x8209C65C;  }
		/* 8209C644h case    5:*/		return 0x8209C648;
		  /* 8209C648h */ case    6:  		/* addi R11, R11, -48 */
		/* 8209C648h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFD0);
		/* 8209C648h case    6:*/		return 0x8209C64C;
		  /* 8209C64Ch */ case    7:  		/* addi R6, R6, 1 */
		/* 8209C64Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8209C64Ch case    7:*/		return 0x8209C650;
		  /* 8209C650h */ case    8:  		/* stb R11, <#[R3]> */
		/* 8209C650h case    8:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209C650h case    8:*/		return 0x8209C654;
		  /* 8209C654h */ case    9:  		/* addi R31, R31, -1 */
		/* 8209C654h case    9:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 8209C654h case    9:*/		return 0x8209C658;
		  /* 8209C658h */ case   10:  		/* addi R3, R3, 1 */
		/* 8209C658h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 8209C658h case   10:*/		return 0x8209C65C;
	}
	return 0x8209C65C;
} // Block from 8209C630h-8209C65Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209C65Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C65C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C65C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C65C);
		  /* 8209C65Ch */ case    0:  		/* lbz R11, <#[R7]> */
		/* 8209C65Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 8209C65Ch case    0:*/		return 0x8209C660;
		  /* 8209C660h */ case    1:  		/* addi R7, R7, 1 */
		/* 8209C660h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8209C660h case    1:*/		return 0x8209C664;
		  /* 8209C664h */ case    2:  		/* extsb R11, R11 */
		/* 8209C664h case    2:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 8209C664h case    2:*/		return 0x8209C668;
	}
	return 0x8209C668;
} // Block from 8209C65Ch-8209C668h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209C668h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C668);
		  /* 8209C668h */ case    0:  		/* cmpwi CR6, R11, 48 */
		/* 8209C668h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000030);
		/* 8209C668h case    0:*/		return 0x8209C66C;
		  /* 8209C66Ch */ case    1:  		/* bc 4, CR6_LT, -52 */
		/* 8209C66Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x8209C638;  }
		/* 8209C66Ch case    1:*/		return 0x8209C670;
		  /* 8209C670h */ case    2:  		/* b -128 */
		/* 8209C670h case    2:*/		return 0x8209C5F0;
		/* 8209C670h case    2:*/		return 0x8209C674;
		  /* 8209C674h */ case    3:  		/* extsb R11, R8 */
		/* 8209C674h case    3:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R8);
		/* 8209C674h case    3:*/		return 0x8209C678;
		  /* 8209C678h */ case    4:  		/* li R26, 1 */
		/* 8209C678h case    4:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 8209C678h case    4:*/		return 0x8209C67C;
		  /* 8209C67Ch */ case    5:  		/* cmpwi CR6, R11, 48 */
		/* 8209C67Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000030);
		/* 8209C67Ch case    5:*/		return 0x8209C680;
		  /* 8209C680h */ case    6:  		/* bc 12, CR6_LT, -320 */
		/* 8209C680h case    6:*/		if ( regs.CR[6].lt ) { return 0x8209C540;  }
		/* 8209C680h case    6:*/		return 0x8209C684;
		  /* 8209C684h */ case    7:  		/* cmpwi CR6, R11, 57 */
		/* 8209C684h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000039);
		/* 8209C684h case    7:*/		return 0x8209C688;
		  /* 8209C688h */ case    8:  		/* bc 12, CR6_GT, -328 */
		/* 8209C688h case    8:*/		if ( regs.CR[6].gt ) { return 0x8209C540;  }
		/* 8209C688h case    8:*/		return 0x8209C68C;
		  /* 8209C68Ch */ case    9:  		/* li R11, 4 */
		/* 8209C68Ch case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 8209C68Ch case    9:*/		return 0x8209C690;
		  /* 8209C690h */ case   10:  		/* b -628 */
		/* 8209C690h case   10:*/		return 0x8209C41C;
		/* 8209C690h case   10:*/		return 0x8209C694;
		  /* 8209C694h */ case   11:  		/* extsb R11, R8 */
		/* 8209C694h case   11:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R8);
		/* 8209C694h case   11:*/		return 0x8209C698;
		  /* 8209C698h */ case   12:  		/* addi R5, R7, -2 */
		/* 8209C698h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R7,0xFFFFFFFE);
		/* 8209C698h case   12:*/		return 0x8209C69C;
		  /* 8209C69Ch */ case   13:  		/* cmpwi CR6, R11, 49 */
		/* 8209C69Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000031);
		/* 8209C69Ch case   13:*/		return 0x8209C6A0;
		  /* 8209C6A0h */ case   14:  		/* bc 12, CR6_LT, 20 */
		/* 8209C6A0h case   14:*/		if ( regs.CR[6].lt ) { return 0x8209C6B4;  }
		/* 8209C6A0h case   14:*/		return 0x8209C6A4;
		  /* 8209C6A4h */ case   15:  		/* cmpwi CR6, R11, 57 */
		/* 8209C6A4h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000039);
		/* 8209C6A4h case   15:*/		return 0x8209C6A8;
		  /* 8209C6A8h */ case   16:  		/* bc 12, CR6_GT, 12 */
		/* 8209C6A8h case   16:*/		if ( regs.CR[6].gt ) { return 0x8209C6B4;  }
		/* 8209C6A8h case   16:*/		return 0x8209C6AC;
		  /* 8209C6ACh */ case   17:  		/* li R11, 9 */
		/* 8209C6ACh case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 8209C6ACh case   17:*/		return 0x8209C6B0;
		  /* 8209C6B0h */ case   18:  		/* b -660 */
		/* 8209C6B0h case   18:*/		return 0x8209C41C;
		/* 8209C6B0h case   18:*/		return 0x8209C6B4;
	}
	return 0x8209C6B4;
} // Block from 8209C668h-8209C6B4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8209C6B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C6B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C6B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C6B4);
		  /* 8209C6B4h */ case    0:  		/* cmpwi CR6, R11, 43 */
		/* 8209C6B4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002B);
		/* 8209C6B4h case    0:*/		return 0x8209C6B8;
		  /* 8209C6B8h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 8209C6B8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209C6D4;  }
		/* 8209C6B8h case    1:*/		return 0x8209C6BC;
		  /* 8209C6BCh */ case    2:  		/* cmpwi CR6, R11, 45 */
		/* 8209C6BCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002D);
		/* 8209C6BCh case    2:*/		return 0x8209C6C0;
		  /* 8209C6C0h */ case    3:  		/* bc 12, CR6_EQ, 140 */
		/* 8209C6C0h case    3:*/		if ( regs.CR[6].eq ) { return 0x8209C74C;  }
		/* 8209C6C0h case    3:*/		return 0x8209C6C4;
		  /* 8209C6C4h */ case    4:  		/* cmpwi CR6, R11, 48 */
		/* 8209C6C4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000030);
		/* 8209C6C4h case    4:*/		return 0x8209C6C8;
		  /* 8209C6C8h */ case    5:  		/* bc 4, CR6_EQ, -392 */
		/* 8209C6C8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8209C540;  }
		/* 8209C6C8h case    5:*/		return 0x8209C6CC;
		  /* 8209C6CCh */ case    6:  		/* li R11, 8 */
		/* 8209C6CCh case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x8);
		/* 8209C6CCh case    6:*/		return 0x8209C6D0;
		  /* 8209C6D0h */ case    7:  		/* b -772 */
		/* 8209C6D0h case    7:*/		return 0x8209C3CC;
		/* 8209C6D0h case    7:*/		return 0x8209C6D4;
	}
	return 0x8209C6D4;
} // Block from 8209C6B4h-8209C6D4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209C6D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C6D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C6D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C6D4);
		  /* 8209C6D4h */ case    0:  		/* li R11, 7 */
		/* 8209C6D4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 8209C6D4h case    0:*/		return 0x8209C6D8;
		  /* 8209C6D8h */ case    1:  		/* b -780 */
		/* 8209C6D8h case    1:*/		return 0x8209C3CC;
		/* 8209C6D8h case    1:*/		return 0x8209C6DC;
		  /* 8209C6DCh */ case    2:  		/* extsb R11, R8 */
		/* 8209C6DCh case    2:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R8);
		/* 8209C6DCh case    2:*/		return 0x8209C6E0;
		  /* 8209C6E0h */ case    3:  		/* li R28, 1 */
		/* 8209C6E0h case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 8209C6E0h case    3:*/		return 0x8209C6E4;
		  /* 8209C6E4h */ case    4:  		/* b 16 */
		/* 8209C6E4h case    4:*/		return 0x8209C6F4;
		/* 8209C6E4h case    4:*/		return 0x8209C6E8;
		  /* 8209C6E8h */ case    5:  		/* lbz R11, <#[R7]> */
		/* 8209C6E8h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 8209C6E8h case    5:*/		return 0x8209C6EC;
		  /* 8209C6ECh */ case    6:  		/* addi R7, R7, 1 */
		/* 8209C6ECh case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8209C6ECh case    6:*/		return 0x8209C6F0;
		  /* 8209C6F0h */ case    7:  		/* extsb R11, R11 */
		/* 8209C6F0h case    7:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 8209C6F0h case    7:*/		return 0x8209C6F4;
	}
	return 0x8209C6F4;
} // Block from 8209C6D4h-8209C6F4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209C6F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C6F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C6F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C6F4);
		  /* 8209C6F4h */ case    0:  		/* cmpwi CR6, R11, 48 */
		/* 8209C6F4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000030);
		/* 8209C6F4h case    0:*/		return 0x8209C6F8;
		  /* 8209C6F8h */ case    1:  		/* bc 12, CR6_EQ, -16 */
		/* 8209C6F8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209C6E8;  }
		/* 8209C6F8h case    1:*/		return 0x8209C6FC;
		  /* 8209C6FCh */ case    2:  		/* cmpwi CR6, R11, 49 */
		/* 8209C6FCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000031);
		/* 8209C6FCh case    2:*/		return 0x8209C700;
		  /* 8209C700h */ case    3:  		/* bc 12, CR6_LT, 12 */
		/* 8209C700h case    3:*/		if ( regs.CR[6].lt ) { return 0x8209C70C;  }
		/* 8209C700h case    3:*/		return 0x8209C704;
		  /* 8209C704h */ case    4:  		/* cmpwi CR6, R11, 57 */
		/* 8209C704h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000039);
		/* 8209C704h case    4:*/		return 0x8209C708;
		  /* 8209C708h */ case    5:  		/* bc 4, CR6_GT, -92 */
		/* 8209C708h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8209C6AC;  }
		/* 8209C708h case    5:*/		return 0x8209C70C;
	}
	return 0x8209C70C;
} // Block from 8209C6F4h-8209C70Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209C70Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C70C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C70C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C70C);
		  /* 8209C70Ch */ case    0:  		/* addi R7, R7, -1 */
		/* 8209C70Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0xFFFFFFFF);
		/* 8209C70Ch case    0:*/		return 0x8209C710;
		  /* 8209C710h */ case    1:  		/* b -460 */
		/* 8209C710h case    1:*/		return 0x8209C544;
		/* 8209C710h case    1:*/		return 0x8209C714;
		  /* 8209C714h */ case    2:  		/* extsb R11, R8 */
		/* 8209C714h case    2:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R8);
		/* 8209C714h case    2:*/		return 0x8209C718;
		  /* 8209C718h */ case    3:  		/* cmpwi CR6, R11, 49 */
		/* 8209C718h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000031);
		/* 8209C718h case    3:*/		return 0x8209C71C;
		  /* 8209C71Ch */ case    4:  		/* bc 12, CR6_LT, -88 */
		/* 8209C71Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x8209C6C4;  }
		/* 8209C71Ch case    4:*/		return 0x8209C720;
		  /* 8209C720h */ case    5:  		/* cmpwi CR6, R11, 57 */
		/* 8209C720h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000039);
		/* 8209C720h case    5:*/		return 0x8209C724;
		  /* 8209C724h */ case    6:  		/* bc 4, CR6_GT, -120 */
		/* 8209C724h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8209C6AC;  }
		/* 8209C724h case    6:*/		return 0x8209C728;
		  /* 8209C728h */ case    7:  		/* b -100 */
		/* 8209C728h case    7:*/		return 0x8209C6C4;
		/* 8209C728h case    7:*/		return 0x8209C72C;
		  /* 8209C72Ch */ case    8:  		/* cmpwi CR6, R9, 0 */
		/* 8209C72Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 8209C72Ch case    8:*/		return 0x8209C730;
		  /* 8209C730h */ case    9:  		/* bc 12, CR6_EQ, 40 */
		/* 8209C730h case    9:*/		if ( regs.CR[6].eq ) { return 0x8209C758;  }
		/* 8209C730h case    9:*/		return 0x8209C734;
		  /* 8209C734h */ case   10:  		/* extsb R11, R8 */
		/* 8209C734h case   10:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R8);
		/* 8209C734h case   10:*/		return 0x8209C738;
		  /* 8209C738h */ case   11:  		/* addi R5, R7, -1 */
		/* 8209C738h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R7,0xFFFFFFFF);
		/* 8209C738h case   11:*/		return 0x8209C73C;
		  /* 8209C73Ch */ case   12:  		/* cmpwi CR6, R11, 43 */
		/* 8209C73Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002B);
		/* 8209C73Ch case   12:*/		return 0x8209C740;
		  /* 8209C740h */ case   13:  		/* bc 12, CR6_EQ, -108 */
		/* 8209C740h case   13:*/		if ( regs.CR[6].eq ) { return 0x8209C6D4;  }
		/* 8209C740h case   13:*/		return 0x8209C744;
		  /* 8209C744h */ case   14:  		/* cmpwi CR6, R11, 45 */
		/* 8209C744h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002D);
		/* 8209C744h case   14:*/		return 0x8209C748;
		  /* 8209C748h */ case   15:  		/* bc 4, CR6_EQ, -520 */
		/* 8209C748h case   15:*/		if ( !regs.CR[6].eq ) { return 0x8209C540;  }
		/* 8209C748h case   15:*/		return 0x8209C74C;
	}
	return 0x8209C74C;
} // Block from 8209C70Ch-8209C74Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8209C74Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C74C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C74C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C74C);
		  /* 8209C74Ch */ case    0:  		/* li R11, 7 */
		/* 8209C74Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 8209C74Ch case    0:*/		return 0x8209C750;
		  /* 8209C750h */ case    1:  		/* li R27, -1 */
		/* 8209C750h case    1:*/		cpu::op::li<0>(regs,&regs.R27,0xFFFFFFFF);
		/* 8209C750h case    1:*/		return 0x8209C754;
		  /* 8209C754h */ case    2:  		/* b -904 */
		/* 8209C754h case    2:*/		return 0x8209C3CC;
		/* 8209C754h case    2:*/		return 0x8209C758;
	}
	return 0x8209C758;
} // Block from 8209C74Ch-8209C758h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209C758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C758);
		  /* 8209C758h */ case    0:  		/* li R11, 10 */
		/* 8209C758h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xA);
		/* 8209C758h case    0:*/		return 0x8209C75C;
		  /* 8209C75Ch */ case    1:  		/* addi R7, R7, -1 */
		/* 8209C75Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0xFFFFFFFF);
		/* 8209C75Ch case    1:*/		return 0x8209C760;
	}
	return 0x8209C760;
} // Block from 8209C758h-8209C760h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209C760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C760);
		  /* 8209C760h */ case    0:  		/* cmpwi CR6, R11, 10 */
		/* 8209C760h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000A);
		/* 8209C760h case    0:*/		return 0x8209C764;
		  /* 8209C764h */ case    1:  		/* bc 4, CR6_EQ, -920 */
		/* 8209C764h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209C3CC;  }
		/* 8209C764h case    1:*/		return 0x8209C768;
		  /* 8209C768h */ case    2:  		/* b -548 */
		/* 8209C768h case    2:*/		return 0x8209C544;
		/* 8209C768h case    2:*/		return 0x8209C76C;
		  /* 8209C76Ch */ case    3:  		/* extsb R11, R8 */
		/* 8209C76Ch case    3:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R8);
		/* 8209C76Ch case    3:*/		return 0x8209C770;
		  /* 8209C770h */ case    4:  		/* li R28, 1 */
		/* 8209C770h case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 8209C770h case    4:*/		return 0x8209C774;
		  /* 8209C774h */ case    5:  		/* mr R10, R22 */
		/* 8209C774h case    5:*/		regs.R10 = regs.R22;
		/* 8209C774h case    5:*/		return 0x8209C778;
		  /* 8209C778h */ case    6:  		/* b 44 */
		/* 8209C778h case    6:*/		return 0x8209C7A4;
		/* 8209C778h case    6:*/		return 0x8209C77C;
		  /* 8209C77Ch */ case    7:  		/* cmpwi CR6, R11, 57 */
		/* 8209C77Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000039);
		/* 8209C77Ch case    7:*/		return 0x8209C780;
		  /* 8209C780h */ case    8:  		/* bc 12, CR6_GT, 52 */
		/* 8209C780h case    8:*/		if ( regs.CR[6].gt ) { return 0x8209C7B4;  }
		/* 8209C780h case    8:*/		return 0x8209C784;
		  /* 8209C784h */ case    9:  		/* mulli R10, R10, 10 */
		/* 8209C784h case    9:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0xA);
		/* 8209C784h case    9:*/		return 0x8209C788;
		  /* 8209C788h */ case   10:  		/* add R10, R10, R11 */
		/* 8209C788h case   10:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8209C788h case   10:*/		return 0x8209C78C;
		  /* 8209C78Ch */ case   11:  		/* addi R10, R10, -48 */
		/* 8209C78Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFD0);
		/* 8209C78Ch case   11:*/		return 0x8209C790;
		  /* 8209C790h */ case   12:  		/* cmpwi CR6, R10, 5200 */
		/* 8209C790h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00001450);
		/* 8209C790h case   12:*/		return 0x8209C794;
		  /* 8209C794h */ case   13:  		/* bc 12, CR6_GT, 28 */
		/* 8209C794h case   13:*/		if ( regs.CR[6].gt ) { return 0x8209C7B0;  }
		/* 8209C794h case   13:*/		return 0x8209C798;
		  /* 8209C798h */ case   14:  		/* lbz R11, <#[R7]> */
		/* 8209C798h case   14:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 8209C798h case   14:*/		return 0x8209C79C;
		  /* 8209C79Ch */ case   15:  		/* addi R7, R7, 1 */
		/* 8209C79Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8209C79Ch case   15:*/		return 0x8209C7A0;
		  /* 8209C7A0h */ case   16:  		/* extsb R11, R11 */
		/* 8209C7A0h case   16:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 8209C7A0h case   16:*/		return 0x8209C7A4;
	}
	return 0x8209C7A4;
} // Block from 8209C760h-8209C7A4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8209C7A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C7A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C7A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C7A4);
		  /* 8209C7A4h */ case    0:  		/* cmpwi CR6, R11, 48 */
		/* 8209C7A4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000030);
		/* 8209C7A4h case    0:*/		return 0x8209C7A8;
	}
	return 0x8209C7A8;
} // Block from 8209C7A4h-8209C7A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209C7A8h
// Function '_stbuf'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C7A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C7A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C7A8);
		  /* 8209C7A8h */ case    0:  		/* bc 4, CR6_LT, -44 */
		/* 8209C7A8h case    0:*/		if ( !regs.CR[6].lt ) { return 0x8209C77C;  }
		/* 8209C7A8h case    0:*/		return 0x8209C7AC;
		  /* 8209C7ACh */ case    1:  		/* b 8 */
		/* 8209C7ACh case    1:*/		return 0x8209C7B4;
		/* 8209C7ACh case    1:*/		return 0x8209C7B0;
	}
	return 0x8209C7B0;
} // Block from 8209C7A8h-8209C7B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209C7B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C7B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C7B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C7B0);
		  /* 8209C7B0h */ case    0:  		/* li R10, 5201 */
		/* 8209C7B0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1451);
		/* 8209C7B0h case    0:*/		return 0x8209C7B4;
	}
	return 0x8209C7B4;
} // Block from 8209C7B0h-8209C7B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209C7B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C7B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C7B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C7B4);
		  /* 8209C7B4h */ case    0:  		/* mr R29, R10 */
		/* 8209C7B4h case    0:*/		regs.R29 = regs.R10;
		/* 8209C7B4h case    0:*/		return 0x8209C7B8;
		  /* 8209C7B8h */ case    1:  		/* b 24 */
		/* 8209C7B8h case    1:*/		return 0x8209C7D0;
		/* 8209C7B8h case    1:*/		return 0x8209C7BC;
		  /* 8209C7BCh */ case    2:  		/* cmpwi CR6, R11, 57 */
		/* 8209C7BCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000039);
		/* 8209C7BCh case    2:*/		return 0x8209C7C0;
		  /* 8209C7C0h */ case    3:  		/* bc 12, CR6_GT, -180 */
		/* 8209C7C0h case    3:*/		if ( regs.CR[6].gt ) { return 0x8209C70C;  }
		/* 8209C7C0h case    3:*/		return 0x8209C7C4;
		  /* 8209C7C4h */ case    4:  		/* lbz R11, <#[R7]> */
		/* 8209C7C4h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 8209C7C4h case    4:*/		return 0x8209C7C8;
		  /* 8209C7C8h */ case    5:  		/* addi R7, R7, 1 */
		/* 8209C7C8h case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8209C7C8h case    5:*/		return 0x8209C7CC;
		  /* 8209C7CCh */ case    6:  		/* extsb R11, R11 */
		/* 8209C7CCh case    6:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 8209C7CCh case    6:*/		return 0x8209C7D0;
	}
	return 0x8209C7D0;
} // Block from 8209C7B4h-8209C7D0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209C7D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C7D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C7D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C7D0);
		  /* 8209C7D0h */ case    0:  		/* cmpwi CR6, R11, 48 */
		/* 8209C7D0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000030);
		/* 8209C7D0h case    0:*/		return 0x8209C7D4;
		  /* 8209C7D4h */ case    1:  		/* bc 4, CR6_LT, -24 */
		/* 8209C7D4h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8209C7BC;  }
		/* 8209C7D4h case    1:*/		return 0x8209C7D8;
		  /* 8209C7D8h */ case    2:  		/* b -204 */
		/* 8209C7D8h case    2:*/		return 0x8209C70C;
		/* 8209C7D8h case    2:*/		return 0x8209C7DC;
		  /* 8209C7DCh */ case    3:  		/* lbzu R11, <#[R3 - 1]> */
		/* 8209C7DCh case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0xFFFFFFFF) );
		regs.R3 = (uint32)(regs.R3 + 0xFFFFFFFF);
		/* 8209C7DCh case    3:*/		return 0x8209C7E0;
		  /* 8209C7E0h */ case    4:  		/* addi R6, R6, -1 */
		/* 8209C7E0h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0xFFFFFFFF);
		/* 8209C7E0h case    4:*/		return 0x8209C7E4;
		  /* 8209C7E4h */ case    5:  		/* addi R31, R31, 1 */
		/* 8209C7E4h case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8209C7E4h case    5:*/		return 0x8209C7E8;
	}
	return 0x8209C7E8;
} // Block from 8209C7D0h-8209C7E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209C7E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C7E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C7E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C7E8);
		  /* 8209C7E8h */ case    0:  		/* cmplwi CR0, R11, 0 */
		/* 8209C7E8h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8209C7E8h case    0:*/		return 0x8209C7EC;
		  /* 8209C7ECh */ case    1:  		/* bc 12, CR0_EQ, -16 */
		/* 8209C7ECh case    1:*/		if ( regs.CR[0].eq ) { return 0x8209C7DC;  }
		/* 8209C7ECh case    1:*/		return 0x8209C7F0;
		  /* 8209C7F0h */ case    2:  		/* addi R5, R1, 96 */
		/* 8209C7F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 8209C7F0h case    2:*/		return 0x8209C7F4;
		  /* 8209C7F4h */ case    3:  		/* mr R4, R6 */
		/* 8209C7F4h case    3:*/		regs.R4 = regs.R6;
		/* 8209C7F4h case    3:*/		return 0x8209C7F8;
		  /* 8209C7F8h */ case    4:  		/* addi R3, R1, 128 */
		/* 8209C7F8h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 8209C7F8h case    4:*/		return 0x8209C7FC;
		  /* 8209C7FCh */ case    5:  		/* bl 6764 */
		/* 8209C7FCh case    5:*/		regs.LR = 0x8209C800; return 0x8209E268;
		/* 8209C7FCh case    5:*/		return 0x8209C800;
		  /* 8209C800h */ case    6:  		/* cmpwi CR6, R27, 0 */
		/* 8209C800h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 8209C800h case    6:*/		return 0x8209C804;
		  /* 8209C804h */ case    7:  		/* bc 4, CR6_LT, 8 */
		/* 8209C804h case    7:*/		if ( !regs.CR[6].lt ) { return 0x8209C80C;  }
		/* 8209C804h case    7:*/		return 0x8209C808;
		  /* 8209C808h */ case    8:  		/* neg R29, R29 */
		/* 8209C808h case    8:*/		cpu::op::neg<0>(regs,&regs.R29,regs.R29);
		/* 8209C808h case    8:*/		return 0x8209C80C;
	}
	return 0x8209C80C;
} // Block from 8209C7E8h-8209C80Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209C80Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C80C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C80C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C80C);
		  /* 8209C80Ch */ case    0:  		/* add R11, R31, R29 */
		/* 8209C80Ch case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R29);
		/* 8209C80Ch case    0:*/		return 0x8209C810;
		  /* 8209C810h */ case    1:  		/* cmpwi CR6, R28, 0 */
		/* 8209C810h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 8209C810h case    1:*/		return 0x8209C814;
		  /* 8209C814h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 8209C814h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8209C81C;  }
		/* 8209C814h case    2:*/		return 0x8209C818;
		  /* 8209C818h */ case    3:  		/* add R11, R11, R25 */
		/* 8209C818h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R25);
		/* 8209C818h case    3:*/		return 0x8209C81C;
	}
	return 0x8209C81C;
} // Block from 8209C80Ch-8209C81Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209C81Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C81C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C81C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C81C);
		  /* 8209C81Ch */ case    0:  		/* cmpwi CR6, R26, 0 */
		/* 8209C81Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 8209C81Ch case    0:*/		return 0x8209C820;
		  /* 8209C820h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 8209C820h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209C828;  }
		/* 8209C820h case    1:*/		return 0x8209C824;
		  /* 8209C824h */ case    2:  		/* subf R11, R24, R11 */
		/* 8209C824h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R24,regs.R11);
		/* 8209C824h case    2:*/		return 0x8209C828;
	}
	return 0x8209C828;
} // Block from 8209C81Ch-8209C828h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209C828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C828);
		  /* 8209C828h */ case    0:  		/* cmpwi CR6, R11, 5200 */
		/* 8209C828h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00001450);
		/* 8209C828h case    0:*/		return 0x8209C82C;
		  /* 8209C82Ch */ case    1:  		/* bc 12, CR6_GT, 1032 */
		/* 8209C82Ch case    1:*/		if ( regs.CR[6].gt ) { return 0x8209CC34;  }
		/* 8209C82Ch case    1:*/		return 0x8209C830;
		  /* 8209C830h */ case    2:  		/* cmpwi CR6, R11, -5200 */
		/* 8209C830h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFEBB0);
		/* 8209C830h case    2:*/		return 0x8209C834;
		  /* 8209C834h */ case    3:  		/* bc 12, CR6_LT, 1048 */
		/* 8209C834h case    3:*/		if ( regs.CR[6].lt ) { return 0x8209CC4C;  }
		/* 8209C834h case    3:*/		return 0x8209C838;
		  /* 8209C838h */ case    4:  		/* lis R10, -32217 */
		/* 8209C838h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 8209C838h case    4:*/		return 0x8209C83C;
		  /* 8209C83Ch */ case    5:  		/* mr R26, R11 */
		/* 8209C83Ch case    5:*/		regs.R26 = regs.R11;
		/* 8209C83Ch case    5:*/		return 0x8209C840;
		  /* 8209C840h */ case    6:  		/* addi R10, R10, 10272 */
		/* 8209C840h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2820);
		/* 8209C840h case    6:*/		return 0x8209C844;
		  /* 8209C844h */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 8209C844h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8209C844h case    7:*/		return 0x8209C848;
		  /* 8209C848h */ case    8:  		/* addi R25, R10, -96 */
		/* 8209C848h case    8:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R10,0xFFFFFFA0);
		/* 8209C848h case    8:*/		return 0x8209C84C;
		  /* 8209C84Ch */ case    9:  		/* bc 12, CR6_EQ, 936 */
		/* 8209C84Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x8209CBF4;  }
		/* 8209C84Ch case    9:*/		return 0x8209C850;
		  /* 8209C850h */ case   10:  		/* bc 4, CR6_LT, 20 */
		/* 8209C850h case   10:*/		if ( !regs.CR[6].lt ) { return 0x8209C864;  }
		/* 8209C850h case   10:*/		return 0x8209C854;
		  /* 8209C854h */ case   11:  		/* lis R10, -32217 */
		/* 8209C854h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 8209C854h case   11:*/		return 0x8209C858;
		  /* 8209C858h */ case   12:  		/* neg R26, R11 */
		/* 8209C858h case   12:*/		cpu::op::neg<0>(regs,&regs.R26,regs.R11);
		/* 8209C858h case   12:*/		return 0x8209C85C;
		  /* 8209C85Ch */ case   13:  		/* addi R11, R10, 10624 */
		/* 8209C85Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x2980);
		/* 8209C85Ch case   13:*/		return 0x8209C860;
		  /* 8209C860h */ case   14:  		/* addi R25, R11, -96 */
		/* 8209C860h case   14:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R11,0xFFFFFFA0);
		/* 8209C860h case   14:*/		return 0x8209C864;
	}
	return 0x8209C864;
} // Block from 8209C828h-8209C864h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8209C864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C864);
		  /* 8209C864h */ case    0:  		/* subfic R11, R23, 0 */
		/* 8209C864h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R23,0x0);
		/* 8209C864h case    0:*/		return 0x8209C868;
		  /* 8209C868h */ case    1:  		/* lhz R10, <#[R1 + 106]> */
		/* 8209C868h case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000006A) );
		/* 8209C868h case    1:*/		return 0x8209C86C;
		  /* 8209C86Ch */ case    2:  		/* cmpwi CR6, R26, 0 */
		/* 8209C86Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 8209C86Ch case    2:*/		return 0x8209C870;
		  /* 8209C870h */ case    3:  		/* subfe R11, R11, R11 */
		/* 8209C870h case    3:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8209C870h case    3:*/		return 0x8209C874;
		  /* 8209C874h */ case    4:  		/* and R11, R11, R10 */
		/* 8209C874h case    4:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8209C874h case    4:*/		return 0x8209C878;
		  /* 8209C878h */ case    5:  		/* sth R11, <#[R1 + 106]> */
		/* 8209C878h case    5:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x0000006A) );
		/* 8209C878h case    5:*/		return 0x8209C87C;
		  /* 8209C87Ch */ case    6:  		/* bc 12, CR6_EQ, 888 */
		/* 8209C87Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x8209CBF4;  }
		/* 8209C87Ch case    6:*/		return 0x8209C880;
		  /* 8209C880h */ case    7:  		/* lis R11, 0 */
		/* 8209C880h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0x0);
		/* 8209C880h case    7:*/		return 0x8209C884;
		  /* 8209C884h */ case    8:  		/* lis R10, 32767 */
		/* 8209C884h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0x7FFF);
		/* 8209C884h case    8:*/		return 0x8209C888;
		  /* 8209C888h */ case    9:  		/* ori R27, R11, 65535 */
		/* 8209C888h case    9:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R11,0xFFFF);
		/* 8209C888h case    9:*/		return 0x8209C88C;
		  /* 8209C88Ch */ case   10:  		/* li R24, -32768 */
		/* 8209C88Ch case   10:*/		cpu::op::li<0>(regs,&regs.R24,0xFFFF8000);
		/* 8209C88Ch case   10:*/		return 0x8209C890;
		  /* 8209C890h */ case   11:  		/* ori R23, R10, 32768 */
		/* 8209C890h case   11:*/		cpu::op::ori<0>(regs,&regs.R23,regs.R10,0x8000);
		/* 8209C890h case   11:*/		return 0x8209C894;
		  /* 8209C894h */ case   12:  		/* rlwinm. R11, R26, 0, 29, 31 */
		/* 8209C894h case   12:*/		cpu::op::rlwinm<1,0,29,31>(regs,&regs.R11,regs.R26);
		/* 8209C894h case   12:*/		return 0x8209C898;
	}
	return 0x8209C898;
} // Block from 8209C864h-8209C898h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209C898h
// Function '_ftbuf'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C898);
		  /* 8209C898h */ case    0:  		/* addi R25, R25, 84 */
		/* 8209C898h case    0:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x54);
		/* 8209C898h case    0:*/		return 0x8209C89C;
		  /* 8209C89Ch */ case    1:  		/* srawi R26, R26, 3 */
		/* 8209C89Ch case    1:*/		cpu::op::srawi<0,3>(regs,&regs.R26,regs.R26);
		/* 8209C89Ch case    1:*/		return 0x8209C8A0;
		  /* 8209C8A0h */ case    2:  		/* bc 12, CR0_EQ, 844 */
		/* 8209C8A0h case    2:*/		if ( regs.CR[0].eq ) { return 0x8209CBEC;  }
		/* 8209C8A0h case    2:*/		return 0x8209C8A4;
		  /* 8209C8A4h */ case    3:  		/* mulli R11, R11, 12 */
		/* 8209C8A4h case    3:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8209C8A4h case    3:*/		return 0x8209C8A8;
		  /* 8209C8A8h */ case    4:  		/* add R4, R11, R25 */
		/* 8209C8A8h case    4:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R25);
		/* 8209C8A8h case    4:*/		return 0x8209C8AC;
		  /* 8209C8ACh */ case    5:  		/* lhz R11, <#[R4 + 10]> */
		/* 8209C8ACh case    5:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000A) );
		/* 8209C8ACh case    5:*/		return 0x8209C8B0;
		  /* 8209C8B0h */ case    6:  		/* cmplwi CR6, R11, 32768 */
		/* 8209C8B0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00008000);
		/* 8209C8B0h case    6:*/		return 0x8209C8B4;
		  /* 8209C8B4h */ case    7:  		/* bc 12, CR6_LT, 32 */
		/* 8209C8B4h case    7:*/		if ( regs.CR[6].lt ) { return 0x8209C8D4;  }
		/* 8209C8B4h case    7:*/		return 0x8209C8B8;
		  /* 8209C8B8h */ case    8:  		/* addi R3, R1, 112 */
		/* 8209C8B8h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 8209C8B8h case    8:*/		return 0x8209C8BC;
		  /* 8209C8BCh */ case    9:  		/* li R5, 12 */
		/* 8209C8BCh case    9:*/		cpu::op::li<0>(regs,&regs.R5,0xC);
		/* 8209C8BCh case    9:*/		return 0x8209C8C0;
		  /* 8209C8C0h */ case   10:  		/* bl -44816 */
		/* 8209C8C0h case   10:*/		regs.LR = 0x8209C8C4; return 0x820919B0;
		/* 8209C8C0h case   10:*/		return 0x8209C8C4;
		  /* 8209C8C4h */ case   11:  		/* lwz R11, <#[R1 + 118]> */
		/* 8209C8C4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000076) );
		/* 8209C8C4h case   11:*/		return 0x8209C8C8;
		  /* 8209C8C8h */ case   12:  		/* addi R4, R1, 112 */
		/* 8209C8C8h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 8209C8C8h case   12:*/		return 0x8209C8CC;
		  /* 8209C8CCh */ case   13:  		/* addi R11, R11, -1 */
		/* 8209C8CCh case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8209C8CCh case   13:*/		return 0x8209C8D0;
		  /* 8209C8D0h */ case   14:  		/* stw R11, <#[R1 + 118]> */
		/* 8209C8D0h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000076) );
		/* 8209C8D0h case   14:*/		return 0x8209C8D4;
	}
	return 0x8209C8D4;
} // Block from 8209C898h-8209C8D4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8209C8D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C8D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C8D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C8D4);
		  /* 8209C8D4h */ case    0:  		/* lhz R10, <#[R1 + 96]> */
		/* 8209C8D4h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 8209C8D4h case    0:*/		return 0x8209C8D8;
		  /* 8209C8D8h */ case    1:  		/* mr R29, R22 */
		/* 8209C8D8h case    1:*/		regs.R29 = regs.R22;
		/* 8209C8D8h case    1:*/		return 0x8209C8DC;
		  /* 8209C8DCh */ case    2:  		/* stw R22, <#[R1 + 88]> */
		/* 8209C8DCh case    2:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000058) );
		/* 8209C8DCh case    2:*/		return 0x8209C8E0;
		  /* 8209C8E0h */ case    3:  		/* stw R22, <#[R1 + 84]> */
		/* 8209C8E0h case    3:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000054) );
		/* 8209C8E0h case    3:*/		return 0x8209C8E4;
		  /* 8209C8E4h */ case    4:  		/* rlwinm R11, R10, 0, 17, 31 */
		/* 8209C8E4h case    4:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R11,regs.R10);
		/* 8209C8E4h case    4:*/		return 0x8209C8E8;
		  /* 8209C8E8h */ case    5:  		/* stw R22, <#[R1 + 80]> */
		/* 8209C8E8h case    5:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000050) );
		/* 8209C8E8h case    5:*/		return 0x8209C8EC;
		  /* 8209C8ECh */ case    6:  		/* mr R9, R10 */
		/* 8209C8ECh case    6:*/		regs.R9 = regs.R10;
		/* 8209C8ECh case    6:*/		return 0x8209C8F0;
		  /* 8209C8F0h */ case    7:  		/* lhz R8, <#[R4]> */
		/* 8209C8F0h case    7:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000000) );
		/* 8209C8F0h case    7:*/		return 0x8209C8F4;
		  /* 8209C8F4h */ case    8:  		/* rlwinm R10, R8, 0, 17, 31 */
		/* 8209C8F4h case    8:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R10,regs.R8);
		/* 8209C8F4h case    8:*/		return 0x8209C8F8;
		  /* 8209C8F8h */ case    9:  		/* xor R8, R9, R8 */
		/* 8209C8F8h case    9:*/		cpu::op::xor<0>(regs,&regs.R8,regs.R9,regs.R8);
		/* 8209C8F8h case    9:*/		return 0x8209C8FC;
		  /* 8209C8FCh */ case   10:  		/* add R7, R11, R10 */
		/* 8209C8FCh case   10:*/		cpu::op::add<0>(regs,&regs.R7,regs.R11,regs.R10);
		/* 8209C8FCh case   10:*/		return 0x8209C900;
	}
	return 0x8209C900;
} // Block from 8209C8D4h-8209C900h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209C900h
// Function '_ld12tod'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C900);
		  /* 8209C900h */ case    0:  		/* mr R9, R11 */
		/* 8209C900h case    0:*/		regs.R9 = regs.R11;
		/* 8209C900h case    0:*/		return 0x8209C904;
		  /* 8209C904h */ case    1:  		/* cmplwi CR6, R11, 32767 */
		/* 8209C904h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00007FFF);
		/* 8209C904h case    1:*/		return 0x8209C908;
		  /* 8209C908h */ case    2:  		/* rlwinm R28, R8, 0, 16, 16 */
		/* 8209C908h case    2:*/		cpu::op::rlwinm<0,0,16,16>(regs,&regs.R28,regs.R8);
		/* 8209C908h case    2:*/		return 0x8209C90C;
		  /* 8209C90Ch */ case    3:  		/* rlwinm R30, R7, 0, 16, 31 */
		/* 8209C90Ch case    3:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R30,regs.R7);
		/* 8209C90Ch case    3:*/		return 0x8209C910;
		  /* 8209C910h */ case    4:  		/* bc 4, CR6_LT, 708 */
		/* 8209C910h case    4:*/		if ( !regs.CR[6].lt ) { return 0x8209CBD4;  }
		/* 8209C910h case    4:*/		return 0x8209C914;
		  /* 8209C914h */ case    5:  		/* cmplwi CR6, R10, 32767 */
		/* 8209C914h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00007FFF);
		/* 8209C914h case    5:*/		return 0x8209C918;
		  /* 8209C918h */ case    6:  		/* bc 4, CR6_LT, 700 */
		/* 8209C918h case    6:*/		if ( !regs.CR[6].lt ) { return 0x8209CBD4;  }
		/* 8209C918h case    6:*/		return 0x8209C91C;
		  /* 8209C91Ch */ case    7:  		/* rlwinm R11, R30, 0, 16, 31 */
		/* 8209C91Ch case    7:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R30);
		/* 8209C91Ch case    7:*/		return 0x8209C920;
		  /* 8209C920h */ case    8:  		/* cmplwi CR6, R11, 49149 */
		/* 8209C920h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000BFFD);
		/* 8209C920h case    8:*/		return 0x8209C924;
		  /* 8209C924h */ case    9:  		/* bc 12, CR6_GT, 688 */
		/* 8209C924h case    9:*/		if ( regs.CR[6].gt ) { return 0x8209CBD4;  }
		/* 8209C924h case    9:*/		return 0x8209C928;
		  /* 8209C928h */ case   10:  		/* cmplwi CR6, R11, 16319 */
		/* 8209C928h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003FBF);
		/* 8209C928h case   10:*/		return 0x8209C92C;
		  /* 8209C92Ch */ case   11:  		/* bc 12, CR6_GT, 12 */
		/* 8209C92Ch case   11:*/		if ( regs.CR[6].gt ) { return 0x8209C938;  }
		/* 8209C92Ch case   11:*/		return 0x8209C930;
		  /* 8209C930h */ case   12:  		/* stw R22, <#[R1 + 96]> */
		/* 8209C930h case   12:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000060) );
		/* 8209C930h case   12:*/		return 0x8209C934;
		  /* 8209C934h */ case   13:  		/* b 688 */
		/* 8209C934h case   13:*/		return 0x8209CBE4;
		/* 8209C934h case   13:*/		return 0x8209C938;
	}
	return 0x8209C938;
} // Block from 8209C900h-8209C938h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209C938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C938);
		  /* 8209C938h */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 8209C938h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8209C938h case    0:*/		return 0x8209C93C;
		  /* 8209C93Ch */ case    1:  		/* bc 4, CR6_EQ, 56 */
		/* 8209C93Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209C974;  }
		/* 8209C93Ch case    1:*/		return 0x8209C940;
		  /* 8209C940h */ case    2:  		/* lwz R9, <#[R1 + 96]> */
		/* 8209C940h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000060) );
		/* 8209C940h case    2:*/		return 0x8209C944;
		  /* 8209C944h */ case    3:  		/* addi R11, R11, 1 */
		/* 8209C944h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209C944h case    3:*/		return 0x8209C948;
		  /* 8209C948h */ case    4:  		/* rlwinm. R9, R9, 0, 1, 31 */
		/* 8209C948h case    4:*/		cpu::op::rlwinm<1,0,1,31>(regs,&regs.R9,regs.R9);
		/* 8209C948h case    4:*/		return 0x8209C94C;
		  /* 8209C94Ch */ case    5:  		/* rlwinm R30, R11, 0, 16, 31 */
		/* 8209C94Ch case    5:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R30,regs.R11);
		/* 8209C94Ch case    5:*/		return 0x8209C950;
		  /* 8209C950h */ case    6:  		/* bc 4, CR0_EQ, 36 */
		/* 8209C950h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8209C974;  }
		/* 8209C950h case    6:*/		return 0x8209C954;
		  /* 8209C954h */ case    7:  		/* lwz R11, <#[R1 + 100]> */
		/* 8209C954h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 8209C954h case    7:*/		return 0x8209C958;
		  /* 8209C958h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 8209C958h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209C958h case    8:*/		return 0x8209C95C;
		  /* 8209C95Ch */ case    9:  		/* bc 4, CR6_EQ, 24 */
		/* 8209C95Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x8209C974;  }
		/* 8209C95Ch case    9:*/		return 0x8209C960;
		  /* 8209C960h */ case   10:  		/* lwz R11, <#[R1 + 104]> */
		/* 8209C960h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 8209C960h case   10:*/		return 0x8209C964;
		  /* 8209C964h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 8209C964h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209C964h case   11:*/		return 0x8209C968;
		  /* 8209C968h */ case   12:  		/* bc 4, CR6_EQ, 12 */
		/* 8209C968h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8209C974;  }
		/* 8209C968h case   12:*/		return 0x8209C96C;
		  /* 8209C96Ch */ case   13:  		/* sth R22, <#[R1 + 96]> */
		/* 8209C96Ch case   13:*/		cpu::mem::store16( regs, regs.R22, (uint32)(regs.R1 + 0x00000060) );
		/* 8209C96Ch case   13:*/		return 0x8209C970;
		  /* 8209C970h */ case   14:  		/* b 636 */
		/* 8209C970h case   14:*/		return 0x8209CBEC;
		/* 8209C970h case   14:*/		return 0x8209C974;
	}
	return 0x8209C974;
} // Block from 8209C938h-8209C974h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8209C974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C974);
		  /* 8209C974h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 8209C974h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8209C974h case    0:*/		return 0x8209C978;
		  /* 8209C978h */ case    1:  		/* bc 4, CR6_EQ, 52 */
		/* 8209C978h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209C9AC;  }
		/* 8209C978h case    1:*/		return 0x8209C97C;
		  /* 8209C97Ch */ case    2:  		/* rlwinm R11, R30, 0, 16, 31 */
		/* 8209C97Ch case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R30);
		/* 8209C97Ch case    2:*/		return 0x8209C980;
		  /* 8209C980h */ case    3:  		/* lwz R10, <#[R4]> */
		/* 8209C980h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 8209C980h case    3:*/		return 0x8209C984;
		  /* 8209C984h */ case    4:  		/* addi R11, R11, 1 */
		/* 8209C984h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209C984h case    4:*/		return 0x8209C988;
		  /* 8209C988h */ case    5:  		/* rlwinm. R10, R10, 0, 1, 31 */
		/* 8209C988h case    5:*/		cpu::op::rlwinm<1,0,1,31>(regs,&regs.R10,regs.R10);
		/* 8209C988h case    5:*/		return 0x8209C98C;
		  /* 8209C98Ch */ case    6:  		/* rlwinm R30, R11, 0, 16, 31 */
		/* 8209C98Ch case    6:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R30,regs.R11);
		/* 8209C98Ch case    6:*/		return 0x8209C990;
		  /* 8209C990h */ case    7:  		/* bc 4, CR0_EQ, 28 */
		/* 8209C990h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8209C9AC;  }
		/* 8209C990h case    7:*/		return 0x8209C994;
		  /* 8209C994h */ case    8:  		/* lwz R11, <#[R4 + 4]> */
		/* 8209C994h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 8209C994h case    8:*/		return 0x8209C998;
		  /* 8209C998h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 8209C998h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209C998h case    9:*/		return 0x8209C99C;
		  /* 8209C99Ch */ case   10:  		/* bc 4, CR6_EQ, 16 */
		/* 8209C99Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x8209C9AC;  }
		/* 8209C99Ch case   10:*/		return 0x8209C9A0;
		  /* 8209C9A0h */ case   11:  		/* lwz R11, <#[R4 + 8]> */
		/* 8209C9A0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8209C9A0h case   11:*/		return 0x8209C9A4;
		  /* 8209C9A4h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 8209C9A4h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209C9A4h case   12:*/		return 0x8209C9A8;
		  /* 8209C9A8h */ case   13:  		/* bc 12, CR6_EQ, -120 */
		/* 8209C9A8h case   13:*/		if ( regs.CR[6].eq ) { return 0x8209C930;  }
		/* 8209C9A8h case   13:*/		return 0x8209C9AC;
	}
	return 0x8209C9AC;
} // Block from 8209C974h-8209C9ACh (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209C9ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C9AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C9AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C9AC);
		  /* 8209C9ACh */ case    0:  		/* mr R31, R22 */
		/* 8209C9ACh case    0:*/		regs.R31 = regs.R22;
		/* 8209C9ACh case    0:*/		return 0x8209C9B0;
		  /* 8209C9B0h */ case    1:  		/* addi R8, R1, 86 */
		/* 8209C9B0h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x56);
		/* 8209C9B0h case    1:*/		return 0x8209C9B4;
		  /* 8209C9B4h */ case    2:  		/* li R3, 5 */
		/* 8209C9B4h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x5);
		/* 8209C9B4h case    2:*/		return 0x8209C9B8;
		  /* 8209C9B8h */ case    3:  		/* rlwinm R11, R31, 1, 0, 30 */
		/* 8209C9B8h case    3:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R31);
		/* 8209C9B8h case    3:*/		return 0x8209C9BC;
		  /* 8209C9BCh */ case    4:  		/* cmpwi CR6, R3, 0 */
		/* 8209C9BCh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8209C9BCh case    4:*/		return 0x8209C9C0;
		  /* 8209C9C0h */ case    5:  		/* bc 4, CR6_GT, 100 */
		/* 8209C9C0h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8209CA24;  }
		/* 8209C9C0h case    5:*/		return 0x8209C9C4;
		  /* 8209C9C4h */ case    6:  		/* addi R10, R1, 106 */
		/* 8209C9C4h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x6A);
		/* 8209C9C4h case    6:*/		return 0x8209C9C8;
		  /* 8209C9C8h */ case    7:  		/* mtspr CTR, R3 */
		/* 8209C9C8h case    7:*/		regs.CTR = regs.R3;
		/* 8209C9C8h case    7:*/		return 0x8209C9CC;
		  /* 8209C9CCh */ case    8:  		/* addi R5, R4, 2 */
		/* 8209C9CCh case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x2);
		/* 8209C9CCh case    8:*/		return 0x8209C9D0;
		  /* 8209C9D0h */ case    9:  		/* subf R6, R11, R10 */
		/* 8209C9D0h case    9:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R11,regs.R10);
		/* 8209C9D0h case    9:*/		return 0x8209C9D4;
		  /* 8209C9D4h */ case   10:  		/* lhz R10, <#[R6]> */
		/* 8209C9D4h case   10:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000000) );
		/* 8209C9D4h case   10:*/		return 0x8209C9D8;
		  /* 8209C9D8h */ case   11:  		/* mr R7, R22 */
		/* 8209C9D8h case   11:*/		regs.R7 = regs.R22;
		/* 8209C9D8h case   11:*/		return 0x8209C9DC;
		  /* 8209C9DCh */ case   12:  		/* lhz R9, <#[R5]> */
		/* 8209C9DCh case   12:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000000) );
		/* 8209C9DCh case   12:*/		return 0x8209C9E0;
		  /* 8209C9E0h */ case   13:  		/* lwz R11, <#[R8 + 2]> */
		/* 8209C9E0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000002) );
		/* 8209C9E0h case   13:*/		return 0x8209C9E4;
		  /* 8209C9E4h */ case   14:  		/* mullw R9, R9, R10 */
		/* 8209C9E4h case   14:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 8209C9E4h case   14:*/		return 0x8209C9E8;
		  /* 8209C9E8h */ case   15:  		/* add R10, R11, R9 */
		/* 8209C9E8h case   15:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R9);
		/* 8209C9E8h case   15:*/		return 0x8209C9EC;
		  /* 8209C9ECh */ case   16:  		/* cmplw CR6, R10, R11 */
		/* 8209C9ECh case   16:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8209C9ECh case   16:*/		return 0x8209C9F0;
		  /* 8209C9F0h */ case   17:  		/* bc 12, CR6_LT, 12 */
		/* 8209C9F0h case   17:*/		if ( regs.CR[6].lt ) { return 0x8209C9FC;  }
		/* 8209C9F0h case   17:*/		return 0x8209C9F4;
		  /* 8209C9F4h */ case   18:  		/* cmplw CR6, R10, R9 */
		/* 8209C9F4h case   18:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8209C9F4h case   18:*/		return 0x8209C9F8;
		  /* 8209C9F8h */ case   19:  		/* bc 4, CR6_LT, 8 */
		/* 8209C9F8h case   19:*/		if ( !regs.CR[6].lt ) { return 0x8209CA00;  }
		/* 8209C9F8h case   19:*/		return 0x8209C9FC;
	}
	return 0x8209C9FC;
} // Block from 8209C9ACh-8209C9FCh (20 instructions)

//////////////////////////////////////////////////////
// Block at 8209C9FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209C9FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209C9FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209C9FC);
		  /* 8209C9FCh */ case    0:  		/* li R7, 1 */
		/* 8209C9FCh case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8209C9FCh case    0:*/		return 0x8209CA00;
	}
	return 0x8209CA00;
} // Block from 8209C9FCh-8209CA00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209CA00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CA00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CA00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CA00);
		  /* 8209CA00h */ case    0:  		/* stw R10, <#[R8 + 2]> */
		/* 8209CA00h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000002) );
		/* 8209CA00h case    0:*/		return 0x8209CA04;
		  /* 8209CA04h */ case    1:  		/* cmpwi CR6, R7, 0 */
		/* 8209CA04h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 8209CA04h case    1:*/		return 0x8209CA08;
		  /* 8209CA08h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8209CA08h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209CA18;  }
		/* 8209CA08h case    2:*/		return 0x8209CA0C;
		  /* 8209CA0Ch */ case    3:  		/* lhz R11, <#[R8]> */
		/* 8209CA0Ch case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8209CA0Ch case    3:*/		return 0x8209CA10;
		  /* 8209CA10h */ case    4:  		/* addi R11, R11, 1 */
		/* 8209CA10h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209CA10h case    4:*/		return 0x8209CA14;
		  /* 8209CA14h */ case    5:  		/* sth R11, <#[R8]> */
		/* 8209CA14h case    5:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8209CA14h case    5:*/		return 0x8209CA18;
	}
	return 0x8209CA18;
} // Block from 8209CA00h-8209CA18h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209CA18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CA18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CA18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CA18);
		  /* 8209CA18h */ case    0:  		/* addi R6, R6, -2 */
		/* 8209CA18h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0xFFFFFFFE);
		/* 8209CA18h case    0:*/		return 0x8209CA1C;
		  /* 8209CA1Ch */ case    1:  		/* addi R5, R5, 2 */
		/* 8209CA1Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x2);
		/* 8209CA1Ch case    1:*/		return 0x8209CA20;
		  /* 8209CA20h */ case    2:  		/* bc 16, CR0_LT, -76 */
		/* 8209CA20h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209C9D4;  }
		/* 8209CA20h case    2:*/		return 0x8209CA24;
	}
	return 0x8209CA24;
} // Block from 8209CA18h-8209CA24h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209CA24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CA24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CA24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CA24);
		  /* 8209CA24h */ case    0:  		/* addic. R3, R3, -1 */
		/* 8209CA24h case    0:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0xFFFFFFFF);
		/* 8209CA24h case    0:*/		return 0x8209CA28;
		  /* 8209CA28h */ case    1:  		/* addi R8, R8, -2 */
		/* 8209CA28h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFE);
		/* 8209CA28h case    1:*/		return 0x8209CA2C;
		  /* 8209CA2Ch */ case    2:  		/* addi R31, R31, 1 */
		/* 8209CA2Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8209CA2Ch case    2:*/		return 0x8209CA30;
		  /* 8209CA30h */ case    3:  		/* bc 12, CR0_GT, -120 */
		/* 8209CA30h case    3:*/		if ( regs.CR[0].gt ) { return 0x8209C9B8;  }
		/* 8209CA30h case    3:*/		return 0x8209CA34;
		  /* 8209CA34h */ case    4:  		/* rlwinm R11, R30, 0, 16, 31 */
		/* 8209CA34h case    4:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R30);
		/* 8209CA34h case    4:*/		return 0x8209CA38;
		  /* 8209CA38h */ case    5:  		/* lwz R10, <#[R1 + 88]> */
		/* 8209CA38h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 8209CA38h case    5:*/		return 0x8209CA3C;
		  /* 8209CA3Ch */ case    6:  		/* addis R11, R11, 1 */
		/* 8209CA3Ch case    6:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209CA3Ch case    6:*/		return 0x8209CA40;
		  /* 8209CA40h */ case    7:  		/* addi R11, R11, -16382 */
		/* 8209CA40h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFC002);
		/* 8209CA40h case    7:*/		return 0x8209CA44;
		  /* 8209CA44h */ case    8:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209CA44h case    8:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209CA44h case    8:*/		return 0x8209CA48;
		  /* 8209CA48h */ case    9:  		/* extsh. R9, R11 */
		/* 8209CA48h case    9:*/		cpu::op::extsh<1>(regs,&regs.R9,regs.R11);
		/* 8209CA48h case    9:*/		return 0x8209CA4C;
		  /* 8209CA4Ch */ case   10:  		/* bc 4, CR0_GT, 72 */
		/* 8209CA4Ch case   10:*/		if ( !regs.CR[0].gt ) { return 0x8209CA94;  }
		/* 8209CA4Ch case   10:*/		return 0x8209CA50;
		  /* 8209CA50h */ case   11:  		/* lwz R8, <#[R1 + 80]> */
		/* 8209CA50h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 8209CA50h case   11:*/		return 0x8209CA54;
		  /* 8209CA54h */ case   12:  		/* rlwinm. R7, R8, 0, 0, 0 */
		/* 8209CA54h case   12:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R7,regs.R8);
		/* 8209CA54h case   12:*/		return 0x8209CA58;
		  /* 8209CA58h */ case   13:  		/* bc 4, CR0_EQ, 60 */
		/* 8209CA58h case   13:*/		if ( !regs.CR[0].eq ) { return 0x8209CA94;  }
		/* 8209CA58h case   13:*/		return 0x8209CA5C;
		  /* 8209CA5Ch */ case   14:  		/* lwz R9, <#[R1 + 84]> */
		/* 8209CA5Ch case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 8209CA5Ch case   14:*/		return 0x8209CA60;
		  /* 8209CA60h */ case   15:  		/* rlwinm R7, R10, 1, 31, 31 */
		/* 8209CA60h case   15:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R7,regs.R10);
		/* 8209CA60h case   15:*/		return 0x8209CA64;
		  /* 8209CA64h */ case   16:  		/* rlwinm R8, R8, 1, 0, 30 */
		/* 8209CA64h case   16:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R8,regs.R8);
		/* 8209CA64h case   16:*/		return 0x8209CA68;
		  /* 8209CA68h */ case   17:  		/* rlwinm R6, R9, 1, 31, 31 */
		/* 8209CA68h case   17:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R6,regs.R9);
		/* 8209CA68h case   17:*/		return 0x8209CA6C;
		  /* 8209CA6Ch */ case   18:  		/* rlwinm R5, R9, 1, 0, 30 */
		/* 8209CA6Ch case   18:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R5,regs.R9);
		/* 8209CA6Ch case   18:*/		return 0x8209CA70;
		  /* 8209CA70h */ case   19:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209CA70h case   19:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209CA70h case   19:*/		return 0x8209CA74;
		  /* 8209CA74h */ case   20:  		/* rlwinm R10, R10, 1, 0, 30 */
		/* 8209CA74h case   20:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R10);
		/* 8209CA74h case   20:*/		return 0x8209CA78;
		  /* 8209CA78h */ case   21:  		/* or R7, R5, R7 */
		/* 8209CA78h case   21:*/		cpu::op::or<0>(regs,&regs.R7,regs.R5,regs.R7);
		/* 8209CA78h case   21:*/		return 0x8209CA7C;
		  /* 8209CA7Ch */ case   22:  		/* or R8, R8, R6 */
		/* 8209CA7Ch case   22:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R6);
		/* 8209CA7Ch case   22:*/		return 0x8209CA80;
		  /* 8209CA80h */ case   23:  		/* stw R10, <#[R1 + 88]> */
		/* 8209CA80h case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 8209CA80h case   23:*/		return 0x8209CA84;
		  /* 8209CA84h */ case   24:  		/* add R11, R11, R27 */
		/* 8209CA84h case   24:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 8209CA84h case   24:*/		return 0x8209CA88;
		  /* 8209CA88h */ case   25:  		/* stw R7, <#[R1 + 84]> */
		/* 8209CA88h case   25:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000054) );
		/* 8209CA88h case   25:*/		return 0x8209CA8C;
		  /* 8209CA8Ch */ case   26:  		/* stw R8, <#[R1 + 80]> */
		/* 8209CA8Ch case   26:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 8209CA8Ch case   26:*/		return 0x8209CA90;
		  /* 8209CA90h */ case   27:  		/* b -76 */
		/* 8209CA90h case   27:*/		return 0x8209CA44;
		/* 8209CA90h case   27:*/		return 0x8209CA94;
	}
	return 0x8209CA94;
} // Block from 8209CA24h-8209CA94h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8209CA94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CA94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CA94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CA94);
		  /* 8209CA94h */ case    0:  		/* cmpwi CR6, R9, 0 */
		/* 8209CA94h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 8209CA94h case    0:*/		return 0x8209CA98;
		  /* 8209CA98h */ case    1:  		/* bc 12, CR6_GT, 132 */
		/* 8209CA98h case    1:*/		if ( regs.CR[6].gt ) { return 0x8209CB1C;  }
		/* 8209CA98h case    1:*/		return 0x8209CA9C;
		  /* 8209CA9Ch */ case    2:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209CA9Ch case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209CA9Ch case    2:*/		return 0x8209CAA0;
		  /* 8209CAA0h */ case    3:  		/* add R11, R11, R27 */
		/* 8209CAA0h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 8209CAA0h case    3:*/		return 0x8209CAA4;
		  /* 8209CAA4h */ case    4:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209CAA4h case    4:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209CAA4h case    4:*/		return 0x8209CAA8;
		  /* 8209CAA8h */ case    5:  		/* extsh. R9, R11 */
		/* 8209CAA8h case    5:*/		cpu::op::extsh<1>(regs,&regs.R9,regs.R11);
		/* 8209CAA8h case    5:*/		return 0x8209CAAC;
		  /* 8209CAACh */ case    6:  		/* bc 4, CR0_LT, 112 */
		/* 8209CAACh case    6:*/		if ( !regs.CR[0].lt ) { return 0x8209CB1C;  }
		/* 8209CAACh case    6:*/		return 0x8209CAB0;
		  /* 8209CAB0h */ case    7:  		/* lwz R8, <#[R1 + 80]> */
		/* 8209CAB0h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 8209CAB0h case    7:*/		return 0x8209CAB4;
		  /* 8209CAB4h */ case    8:  		/* lwz R9, <#[R1 + 84]> */
		/* 8209CAB4h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 8209CAB4h case    8:*/		return 0x8209CAB8;
		  /* 8209CAB8h */ case    9:  		/* lhz R7, <#[R1 + 90]> */
		/* 8209CAB8h case    9:*/		cpu::mem::load16z( regs, &regs.R7, (uint32)(regs.R1 + 0x0000005A) );
		/* 8209CAB8h case    9:*/		return 0x8209CABC;
		  /* 8209CABCh */ case   10:  		/* rlwinm. R7, R7, 0, 31, 31 */
		/* 8209CABCh case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R7,regs.R7);
		/* 8209CABCh case   10:*/		return 0x8209CAC0;
		  /* 8209CAC0h */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 8209CAC0h case   11:*/		if ( regs.CR[0].eq ) { return 0x8209CAC8;  }
		/* 8209CAC0h case   11:*/		return 0x8209CAC4;
		  /* 8209CAC4h */ case   12:  		/* addi R29, R29, 1 */
		/* 8209CAC4h case   12:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8209CAC4h case   12:*/		return 0x8209CAC8;
	}
	return 0x8209CAC8;
} // Block from 8209CA94h-8209CAC8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209CAC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CAC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CAC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CAC8);
		  /* 8209CAC8h */ case    0:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209CAC8h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209CAC8h case    0:*/		return 0x8209CACC;
		  /* 8209CACCh */ case    1:  		/* rlwinm R7, R9, 31, 0, 0 */
		/* 8209CACCh case    1:*/		cpu::op::rlwinm<0,31,0,0>(regs,&regs.R7,regs.R9);
		/* 8209CACCh case    1:*/		return 0x8209CAD0;
		  /* 8209CAD0h */ case    2:  		/* addi R11, R11, 1 */
		/* 8209CAD0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209CAD0h case    2:*/		return 0x8209CAD4;
		  /* 8209CAD4h */ case    3:  		/* rlwinm R10, R10, 31, 1, 31 */
		/* 8209CAD4h case    3:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R10,regs.R10);
		/* 8209CAD4h case    3:*/		return 0x8209CAD8;
		  /* 8209CAD8h */ case    4:  		/* rlwinm R6, R8, 31, 0, 0 */
		/* 8209CAD8h case    4:*/		cpu::op::rlwinm<0,31,0,0>(regs,&regs.R6,regs.R8);
		/* 8209CAD8h case    4:*/		return 0x8209CADC;
		  /* 8209CADCh */ case    5:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209CADCh case    5:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209CADCh case    5:*/		return 0x8209CAE0;
		  /* 8209CAE0h */ case    6:  		/* rlwinm R9, R9, 31, 1, 31 */
		/* 8209CAE0h case    6:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R9,regs.R9);
		/* 8209CAE0h case    6:*/		return 0x8209CAE4;
		  /* 8209CAE4h */ case    7:  		/* or R10, R10, R7 */
		/* 8209CAE4h case    7:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 8209CAE4h case    7:*/		return 0x8209CAE8;
		  /* 8209CAE8h */ case    8:  		/* extsh. R5, R11 */
		/* 8209CAE8h case    8:*/		cpu::op::extsh<1>(regs,&regs.R5,regs.R11);
		/* 8209CAE8h case    8:*/		return 0x8209CAEC;
		  /* 8209CAECh */ case    9:  		/* rlwinm R8, R8, 31, 1, 31 */
		/* 8209CAECh case    9:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R8,regs.R8);
		/* 8209CAECh case    9:*/		return 0x8209CAF0;
		  /* 8209CAF0h */ case   10:  		/* stw R10, <#[R1 + 88]> */
		/* 8209CAF0h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 8209CAF0h case   10:*/		return 0x8209CAF4;
		  /* 8209CAF4h */ case   11:  		/* or R9, R9, R6 */
		/* 8209CAF4h case   11:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R6);
		/* 8209CAF4h case   11:*/		return 0x8209CAF8;
		  /* 8209CAF8h */ case   12:  		/* bc 12, CR0_LT, -64 */
		/* 8209CAF8h case   12:*/		if ( regs.CR[0].lt ) { return 0x8209CAB8;  }
		/* 8209CAF8h case   12:*/		return 0x8209CAFC;
		  /* 8209CAFCh */ case   13:  		/* stw R9, <#[R1 + 84]> */
		/* 8209CAFCh case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 8209CAFCh case   13:*/		return 0x8209CB00;
		  /* 8209CB00h */ case   14:  		/* cmpwi CR6, R29, 0 */
		/* 8209CB00h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 8209CB00h case   14:*/		return 0x8209CB04;
		  /* 8209CB04h */ case   15:  		/* stw R8, <#[R1 + 80]> */
		/* 8209CB04h case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 8209CB04h case   15:*/		return 0x8209CB08;
		  /* 8209CB08h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 8209CB08h case   16:*/		if ( regs.CR[6].eq ) { return 0x8209CB1C;  }
		/* 8209CB08h case   16:*/		return 0x8209CB0C;
		  /* 8209CB0Ch */ case   17:  		/* lhz R10, <#[R1 + 90]> */
		/* 8209CB0Ch case   17:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000005A) );
		/* 8209CB0Ch case   17:*/		return 0x8209CB10;
		  /* 8209CB10h */ case   18:  		/* ori R10, R10, 1 */
		/* 8209CB10h case   18:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8209CB10h case   18:*/		return 0x8209CB14;
		  /* 8209CB14h */ case   19:  		/* sth R10, <#[R1 + 90]> */
		/* 8209CB14h case   19:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R1 + 0x0000005A) );
		/* 8209CB14h case   19:*/		return 0x8209CB18;
		  /* 8209CB18h */ case   20:  		/* lwz R10, <#[R1 + 88]> */
		/* 8209CB18h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 8209CB18h case   20:*/		return 0x8209CB1C;
	}
	return 0x8209CB1C;
} // Block from 8209CAC8h-8209CB1Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8209CB1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CB1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CB1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CB1C);
		  /* 8209CB1Ch */ case    0:  		/* lhz R9, <#[R1 + 90]> */
		/* 8209CB1Ch case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000005A) );
		/* 8209CB1Ch case    0:*/		return 0x8209CB20;
		  /* 8209CB20h */ case    1:  		/* cmplwi CR6, R9, 32768 */
		/* 8209CB20h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00008000);
		/* 8209CB20h case    1:*/		return 0x8209CB24;
		  /* 8209CB24h */ case    2:  		/* bc 12, CR6_GT, 24 */
		/* 8209CB24h case    2:*/		if ( regs.CR[6].gt ) { return 0x8209CB3C;  }
		/* 8209CB24h case    2:*/		return 0x8209CB28;
		  /* 8209CB28h */ case    3:  		/* lis R9, 1 */
		/* 8209CB28h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0x1);
		/* 8209CB28h case    3:*/		return 0x8209CB2C;
		  /* 8209CB2Ch */ case    4:  		/* rlwinm R10, R10, 0, 15, 31 */
		/* 8209CB2Ch case    4:*/		cpu::op::rlwinm<0,0,15,31>(regs,&regs.R10,regs.R10);
		/* 8209CB2Ch case    4:*/		return 0x8209CB30;
		  /* 8209CB30h */ case    5:  		/* ori R9, R9, 32768 */
		/* 8209CB30h case    5:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x8000);
		/* 8209CB30h case    5:*/		return 0x8209CB34;
		  /* 8209CB34h */ case    6:  		/* cmplw CR6, R10, R9 */
		/* 8209CB34h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8209CB34h case    6:*/		return 0x8209CB38;
		  /* 8209CB38h */ case    7:  		/* bc 4, CR6_EQ, 100 */
		/* 8209CB38h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8209CB9C;  }
		/* 8209CB38h case    7:*/		return 0x8209CB3C;
	}
	return 0x8209CB3C;
} // Block from 8209CB1Ch-8209CB3Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209CB3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CB3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CB3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CB3C);
		  /* 8209CB3Ch */ case    0:  		/* lwz R10, <#[R1 + 86]> */
		/* 8209CB3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000056) );
		/* 8209CB3Ch case    0:*/		return 0x8209CB40;
		  /* 8209CB40h */ case    1:  		/* cmpwi CR6, R10, -1 */
		/* 8209CB40h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8209CB40h case    1:*/		return 0x8209CB44;
		  /* 8209CB44h */ case    2:  		/* bc 4, CR6_EQ, 80 */
		/* 8209CB44h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8209CB94;  }
		/* 8209CB44h case    2:*/		return 0x8209CB48;
		  /* 8209CB48h */ case    3:  		/* lwz R10, <#[R1 + 82]> */
		/* 8209CB48h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000052) );
		/* 8209CB48h case    3:*/		return 0x8209CB4C;
		  /* 8209CB4Ch */ case    4:  		/* stw R22, <#[R1 + 86]> */
		/* 8209CB4Ch case    4:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000056) );
		/* 8209CB4Ch case    4:*/		return 0x8209CB50;
		  /* 8209CB50h */ case    5:  		/* cmpwi CR6, R10, -1 */
		/* 8209CB50h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8209CB50h case    5:*/		return 0x8209CB54;
		  /* 8209CB54h */ case    6:  		/* bc 4, CR6_EQ, 52 */
		/* 8209CB54h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8209CB88;  }
		/* 8209CB54h case    6:*/		return 0x8209CB58;
		  /* 8209CB58h */ case    7:  		/* lhz R10, <#[R1 + 80]> */
		/* 8209CB58h case    7:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8209CB58h case    7:*/		return 0x8209CB5C;
		  /* 8209CB5Ch */ case    8:  		/* stw R22, <#[R1 + 82]> */
		/* 8209CB5Ch case    8:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000052) );
		/* 8209CB5Ch case    8:*/		return 0x8209CB60;
		  /* 8209CB60h */ case    9:  		/* cmplwi CR6, R10, 65535 */
		/* 8209CB60h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000FFFF);
		/* 8209CB60h case    9:*/		return 0x8209CB64;
		  /* 8209CB64h */ case   10:  		/* bc 4, CR6_EQ, 24 */
		/* 8209CB64h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8209CB7C;  }
		/* 8209CB64h case   10:*/		return 0x8209CB68;
		  /* 8209CB68h */ case   11:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209CB68h case   11:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209CB68h case   11:*/		return 0x8209CB6C;
		  /* 8209CB6Ch */ case   12:  		/* sth R21, <#[R1 + 80]> */
		/* 8209CB6Ch case   12:*/		cpu::mem::store16( regs, regs.R21, (uint32)(regs.R1 + 0x00000050) );
		/* 8209CB6Ch case   12:*/		return 0x8209CB70;
		  /* 8209CB70h */ case   13:  		/* addi R11, R11, 1 */
		/* 8209CB70h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209CB70h case   13:*/		return 0x8209CB74;
		  /* 8209CB74h */ case   14:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209CB74h case   14:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209CB74h case   14:*/		return 0x8209CB78;
		  /* 8209CB78h */ case   15:  		/* b 36 */
		/* 8209CB78h case   15:*/		return 0x8209CB9C;
		/* 8209CB78h case   15:*/		return 0x8209CB7C;
	}
	return 0x8209CB7C;
} // Block from 8209CB3Ch-8209CB7Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8209CB7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CB7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CB7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CB7C);
		  /* 8209CB7Ch */ case    0:  		/* addi R10, R10, 1 */
		/* 8209CB7Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8209CB7Ch case    0:*/		return 0x8209CB80;
		  /* 8209CB80h */ case    1:  		/* sth R10, <#[R1 + 80]> */
		/* 8209CB80h case    1:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8209CB80h case    1:*/		return 0x8209CB84;
		  /* 8209CB84h */ case    2:  		/* b 24 */
		/* 8209CB84h case    2:*/		return 0x8209CB9C;
		/* 8209CB84h case    2:*/		return 0x8209CB88;
	}
	return 0x8209CB88;
} // Block from 8209CB7Ch-8209CB88h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209CB88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CB88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CB88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CB88);
		  /* 8209CB88h */ case    0:  		/* addi R10, R10, 1 */
		/* 8209CB88h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8209CB88h case    0:*/		return 0x8209CB8C;
		  /* 8209CB8Ch */ case    1:  		/* stw R10, <#[R1 + 82]> */
		/* 8209CB8Ch case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000052) );
		/* 8209CB8Ch case    1:*/		return 0x8209CB90;
		  /* 8209CB90h */ case    2:  		/* b 12 */
		/* 8209CB90h case    2:*/		return 0x8209CB9C;
		/* 8209CB90h case    2:*/		return 0x8209CB94;
	}
	return 0x8209CB94;
} // Block from 8209CB88h-8209CB94h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209CB94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CB94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CB94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CB94);
		  /* 8209CB94h */ case    0:  		/* addi R10, R10, 1 */
		/* 8209CB94h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8209CB94h case    0:*/		return 0x8209CB98;
		  /* 8209CB98h */ case    1:  		/* stw R10, <#[R1 + 86]> */
		/* 8209CB98h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000056) );
		/* 8209CB98h case    1:*/		return 0x8209CB9C;
	}
	return 0x8209CB9C;
} // Block from 8209CB94h-8209CB9Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209CB9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CB9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CB9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CB9C);
		  /* 8209CB9Ch */ case    0:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209CB9Ch case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209CB9Ch case    0:*/		return 0x8209CBA0;
		  /* 8209CBA0h */ case    1:  		/* cmplwi CR6, R11, 32767 */
		/* 8209CBA0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00007FFF);
		/* 8209CBA0h case    1:*/		return 0x8209CBA4;
		  /* 8209CBA4h */ case    2:  		/* bc 4, CR6_LT, 48 */
		/* 8209CBA4h case    2:*/		if ( !regs.CR[6].lt ) { return 0x8209CBD4;  }
		/* 8209CBA4h case    2:*/		return 0x8209CBA8;
		  /* 8209CBA8h */ case    3:  		/* rlwinm R10, R28, 0, 16, 31 */
		/* 8209CBA8h case    3:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R28);
		/* 8209CBA8h case    3:*/		return 0x8209CBAC;
		  /* 8209CBACh */ case    4:  		/* lhz R9, <#[R1 + 88]> */
		/* 8209CBACh case    4:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 8209CBACh case    4:*/		return 0x8209CBB0;
		  /* 8209CBB0h */ case    5:  		/* lwz R8, <#[R1 + 84]> */
		/* 8209CBB0h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 8209CBB0h case    5:*/		return 0x8209CBB4;
		  /* 8209CBB4h */ case    6:  		/* lwz R7, <#[R1 + 80]> */
		/* 8209CBB4h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 8209CBB4h case    6:*/		return 0x8209CBB8;
		  /* 8209CBB8h */ case    7:  		/* or R11, R10, R11 */
		/* 8209CBB8h case    7:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8209CBB8h case    7:*/		return 0x8209CBBC;
		  /* 8209CBBCh */ case    8:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209CBBCh case    8:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209CBBCh case    8:*/		return 0x8209CBC0;
		  /* 8209CBC0h */ case    9:  		/* sth R9, <#[R1 + 106]> */
		/* 8209CBC0h case    9:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R1 + 0x0000006A) );
		/* 8209CBC0h case    9:*/		return 0x8209CBC4;
		  /* 8209CBC4h */ case   10:  		/* stw R8, <#[R1 + 102]> */
		/* 8209CBC4h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000066) );
		/* 8209CBC4h case   10:*/		return 0x8209CBC8;
		  /* 8209CBC8h */ case   11:  		/* stw R7, <#[R1 + 98]> */
		/* 8209CBC8h case   11:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000062) );
		/* 8209CBC8h case   11:*/		return 0x8209CBCC;
		  /* 8209CBCCh */ case   12:  		/* sth R11, <#[R1 + 96]> */
		/* 8209CBCCh case   12:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 8209CBCCh case   12:*/		return 0x8209CBD0;
		  /* 8209CBD0h */ case   13:  		/* b 28 */
		/* 8209CBD0h case   13:*/		return 0x8209CBEC;
		/* 8209CBD0h case   13:*/		return 0x8209CBD4;
	}
	return 0x8209CBD4;
} // Block from 8209CB9Ch-8209CBD4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209CBD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CBD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CBD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CBD4);
		  /* 8209CBD4h */ case    0:  		/* stw R24, <#[R1 + 96]> */
		/* 8209CBD4h case    0:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000060) );
		/* 8209CBD4h case    0:*/		return 0x8209CBD8;
		  /* 8209CBD8h */ case    1:  		/* rlwinm. R11, R28, 0, 16, 31 */
		/* 8209CBD8h case    1:*/		cpu::op::rlwinm<1,0,16,31>(regs,&regs.R11,regs.R28);
		/* 8209CBD8h case    1:*/		return 0x8209CBDC;
		  /* 8209CBDCh */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 8209CBDCh case    2:*/		if ( !regs.CR[0].eq ) { return 0x8209CBE4;  }
		/* 8209CBDCh case    2:*/		return 0x8209CBE0;
		  /* 8209CBE0h */ case    3:  		/* stw R23, <#[R1 + 96]> */
		/* 8209CBE0h case    3:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000060) );
		/* 8209CBE0h case    3:*/		return 0x8209CBE4;
	}
	return 0x8209CBE4;
} // Block from 8209CBD4h-8209CBE4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209CBE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CBE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CBE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CBE4);
		  /* 8209CBE4h */ case    0:  		/* stw R22, <#[R1 + 104]> */
		/* 8209CBE4h case    0:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000068) );
		/* 8209CBE4h case    0:*/		return 0x8209CBE8;
		  /* 8209CBE8h */ case    1:  		/* stw R22, <#[R1 + 100]> */
		/* 8209CBE8h case    1:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000064) );
		/* 8209CBE8h case    1:*/		return 0x8209CBEC;
	}
	return 0x8209CBEC;
} // Block from 8209CBE4h-8209CBECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209CBECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CBEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CBEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CBEC);
		  /* 8209CBECh */ case    0:  		/* cmpwi CR6, R26, 0 */
		/* 8209CBECh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 8209CBECh case    0:*/		return 0x8209CBF0;
		  /* 8209CBF0h */ case    1:  		/* bc 4, CR6_EQ, -860 */
		/* 8209CBF0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209C894;  }
		/* 8209CBF0h case    1:*/		return 0x8209CBF4;
	}
	return 0x8209CBF4;
} // Block from 8209CBECh-8209CBF4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209CBF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CBF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CBF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CBF4);
		  /* 8209CBF4h */ case    0:  		/* lhz R11, <#[R1 + 106]> */
		/* 8209CBF4h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000006A) );
		/* 8209CBF4h case    0:*/		return 0x8209CBF8;
		  /* 8209CBF8h */ case    1:  		/* lwz R8, <#[R1 + 102]> */
		/* 8209CBF8h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000066) );
		/* 8209CBF8h case    1:*/		return 0x8209CBFC;
		  /* 8209CBFCh */ case    2:  		/* lwz R9, <#[R1 + 98]> */
		/* 8209CBFCh case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000062) );
		/* 8209CBFCh case    2:*/		return 0x8209CC00;
		  /* 8209CC00h */ case    3:  		/* lhz R10, <#[R1 + 96]> */
		/* 8209CC00h case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 8209CC00h case    3:*/		return 0x8209CC04;
		  /* 8209CC04h */ case    4:  		/* b 92 */
		/* 8209CC04h case    4:*/		return 0x8209CC60;
		/* 8209CC04h case    4:*/		return 0x8209CC08;
	}
	return 0x8209CC08;
} // Block from 8209CBF4h-8209CC08h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209CC08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CC08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CC08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CC08);
		  /* 8209CC08h */ case    0:  		/* mr R11, R22 */
		/* 8209CC08h case    0:*/		regs.R11 = regs.R22;
		/* 8209CC08h case    0:*/		return 0x8209CC0C;
		  /* 8209CC0Ch */ case    1:  		/* mr R10, R22 */
		/* 8209CC0Ch case    1:*/		regs.R10 = regs.R22;
		/* 8209CC0Ch case    1:*/		return 0x8209CC10;
		  /* 8209CC10h */ case    2:  		/* mr R9, R22 */
		/* 8209CC10h case    2:*/		regs.R9 = regs.R22;
		/* 8209CC10h case    2:*/		return 0x8209CC14;
		  /* 8209CC14h */ case    3:  		/* mr R8, R22 */
		/* 8209CC14h case    3:*/		regs.R8 = regs.R22;
		/* 8209CC14h case    3:*/		return 0x8209CC18;
		  /* 8209CC18h */ case    4:  		/* b 72 */
		/* 8209CC18h case    4:*/		return 0x8209CC60;
		/* 8209CC18h case    4:*/		return 0x8209CC1C;
	}
	return 0x8209CC1C;
} // Block from 8209CC08h-8209CC1Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209CC1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CC1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CC1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CC1C);
		  /* 8209CC1Ch */ case    0:  		/* mr R11, R22 */
		/* 8209CC1Ch case    0:*/		regs.R11 = regs.R22;
		/* 8209CC1Ch case    0:*/		return 0x8209CC20;
		  /* 8209CC20h */ case    1:  		/* mr R10, R22 */
		/* 8209CC20h case    1:*/		regs.R10 = regs.R22;
		/* 8209CC20h case    1:*/		return 0x8209CC24;
		  /* 8209CC24h */ case    2:  		/* mr R9, R22 */
		/* 8209CC24h case    2:*/		regs.R9 = regs.R22;
		/* 8209CC24h case    2:*/		return 0x8209CC28;
		  /* 8209CC28h */ case    3:  		/* mr R8, R22 */
		/* 8209CC28h case    3:*/		regs.R8 = regs.R22;
		/* 8209CC28h case    3:*/		return 0x8209CC2C;
		  /* 8209CC2Ch */ case    4:  		/* li R22, 4 */
		/* 8209CC2Ch case    4:*/		cpu::op::li<0>(regs,&regs.R22,0x4);
		/* 8209CC2Ch case    4:*/		return 0x8209CC30;
		  /* 8209CC30h */ case    5:  		/* b 48 */
		/* 8209CC30h case    5:*/		return 0x8209CC60;
		/* 8209CC30h case    5:*/		return 0x8209CC34;
	}
	return 0x8209CC34;
} // Block from 8209CC1Ch-8209CC34h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209CC34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CC34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CC34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CC34);
		  /* 8209CC34h */ case    0:  		/* mr R8, R22 */
		/* 8209CC34h case    0:*/		regs.R8 = regs.R22;
		/* 8209CC34h case    0:*/		return 0x8209CC38;
		  /* 8209CC38h */ case    1:  		/* mr R11, R22 */
		/* 8209CC38h case    1:*/		regs.R11 = regs.R22;
		/* 8209CC38h case    1:*/		return 0x8209CC3C;
		  /* 8209CC3Ch */ case    2:  		/* li R10, 32767 */
		/* 8209CC3Ch case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x7FFF);
		/* 8209CC3Ch case    2:*/		return 0x8209CC40;
		  /* 8209CC40h */ case    3:  		/* lis R9, -32768 */
		/* 8209CC40h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8000);
		/* 8209CC40h case    3:*/		return 0x8209CC44;
		  /* 8209CC44h */ case    4:  		/* li R22, 2 */
		/* 8209CC44h case    4:*/		cpu::op::li<0>(regs,&regs.R22,0x2);
		/* 8209CC44h case    4:*/		return 0x8209CC48;
		  /* 8209CC48h */ case    5:  		/* b 24 */
		/* 8209CC48h case    5:*/		return 0x8209CC60;
		/* 8209CC48h case    5:*/		return 0x8209CC4C;
	}
	return 0x8209CC4C;
} // Block from 8209CC34h-8209CC4Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209CC4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CC4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CC4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CC4C);
		  /* 8209CC4Ch */ case    0:  		/* mr R11, R22 */
		/* 8209CC4Ch case    0:*/		regs.R11 = regs.R22;
		/* 8209CC4Ch case    0:*/		return 0x8209CC50;
		  /* 8209CC50h */ case    1:  		/* mr R10, R22 */
		/* 8209CC50h case    1:*/		regs.R10 = regs.R22;
		/* 8209CC50h case    1:*/		return 0x8209CC54;
		  /* 8209CC54h */ case    2:  		/* mr R9, R22 */
		/* 8209CC54h case    2:*/		regs.R9 = regs.R22;
		/* 8209CC54h case    2:*/		return 0x8209CC58;
		  /* 8209CC58h */ case    3:  		/* mr R8, R22 */
		/* 8209CC58h case    3:*/		regs.R8 = regs.R22;
		/* 8209CC58h case    3:*/		return 0x8209CC5C;
		  /* 8209CC5Ch */ case    4:  		/* li R22, 1 */
		/* 8209CC5Ch case    4:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 8209CC5Ch case    4:*/		return 0x8209CC60;
	}
	return 0x8209CC60;
} // Block from 8209CC4Ch-8209CC60h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209CC60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CC60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CC60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CC60);
		  /* 8209CC60h */ case    0:  		/* sth R11, <#[R20 + 10]> */
		/* 8209CC60h case    0:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R20 + 0x0000000A) );
		/* 8209CC60h case    0:*/		return 0x8209CC64;
		  /* 8209CC64h */ case    1:  		/* rlwinm R10, R10, 0, 16, 31 */
		/* 8209CC64h case    1:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R10);
		/* 8209CC64h case    1:*/		return 0x8209CC68;
		  /* 8209CC68h */ case    2:  		/* rlwinm R11, R19, 0, 16, 31 */
		/* 8209CC68h case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R19);
		/* 8209CC68h case    2:*/		return 0x8209CC6C;
		  /* 8209CC6Ch */ case    3:  		/* stw R8, <#[R20 + 6]> */
		/* 8209CC6Ch case    3:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R20 + 0x00000006) );
		/* 8209CC6Ch case    3:*/		return 0x8209CC70;
		  /* 8209CC70h */ case    4:  		/* stw R9, <#[R20 + 2]> */
		/* 8209CC70h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R20 + 0x00000002) );
		/* 8209CC70h case    4:*/		return 0x8209CC74;
		  /* 8209CC74h */ case    5:  		/* mr R3, R22 */
		/* 8209CC74h case    5:*/		regs.R3 = regs.R22;
		/* 8209CC74h case    5:*/		return 0x8209CC78;
		  /* 8209CC78h */ case    6:  		/* or R11, R10, R11 */
		/* 8209CC78h case    6:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8209CC78h case    6:*/		return 0x8209CC7C;
		  /* 8209CC7Ch */ case    7:  		/* sth R11, <#[R20]> */
		/* 8209CC7Ch case    7:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 8209CC7Ch case    7:*/		return 0x8209CC80;
	}
	return 0x8209CC80;
} // Block from 8209CC60h-8209CC80h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209CC80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CC80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CC80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CC80);
		  /* 8209CC80h */ case    0:  		/* addi R1, R1, 272 */
		/* 8209CC80h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x110);
		/* 8209CC80h case    0:*/		return 0x8209CC84;
		  /* 8209CC84h */ case    1:  		/* b -47616 */
		/* 8209CC84h case    1:*/		return 0x82091284;
		/* 8209CC84h case    1:*/		return 0x8209CC88;
	}
	return 0x8209CC88;
} // Block from 8209CC80h-8209CC88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209CC88h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CC88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CC88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CC88);
		  /* 8209CC88h */ case    0:  		/* mfspr R12, LR */
		/* 8209CC88h case    0:*/		regs.R12 = regs.LR;
		/* 8209CC88h case    0:*/		return 0x8209CC8C;
		  /* 8209CC8Ch */ case    1:  		/* bl -47724 */
		/* 8209CC8Ch case    1:*/		regs.LR = 0x8209CC90; return 0x82091220;
		/* 8209CC8Ch case    1:*/		return 0x8209CC90;
		  /* 8209CC90h */ case    2:  		/* stwu R1, <#[R1 - 320]> */
		/* 8209CC90h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEC0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEC0);
		/* 8209CC90h case    2:*/		return 0x8209CC94;
		  /* 8209CC94h */ case    3:  		/* std R3, <#[R1 + 336]> */
		/* 8209CC94h case    3:*/		cpu::mem::store64( regs, regs.R3, (uint32)(regs.R1 + 0x00000150) );
		/* 8209CC94h case    3:*/		return 0x8209CC98;
		  /* 8209CC98h */ case    4:  		/* li R11, 204 */
		/* 8209CC98h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0xCC);
		/* 8209CC98h case    4:*/		return 0x8209CC9C;
		  /* 8209CC9Ch */ case    5:  		/* lhz R9, <#[R1 + 336]> */
		/* 8209CC9Ch case    5:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000150) );
		/* 8209CC9Ch case    5:*/		return 0x8209CCA0;
		  /* 8209CCA0h */ case    6:  		/* mr R14, R7 */
		/* 8209CCA0h case    6:*/		regs.R14 = regs.R7;
		/* 8209CCA0h case    6:*/		return 0x8209CCA4;
		  /* 8209CCA4h */ case    7:  		/* stw R5, <#[R1 + 356]> */
		/* 8209CCA4h case    7:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000164) );
		/* 8209CCA4h case    7:*/		return 0x8209CCA8;
		  /* 8209CCA8h */ case    8:  		/* rlwinm. R10, R9, 0, 0, 16 */
		/* 8209CCA8h case    8:*/		cpu::op::rlwinm<1,0,0,16>(regs,&regs.R10,regs.R9);
		/* 8209CCA8h case    8:*/		return 0x8209CCAC;
		  /* 8209CCACh */ case    9:  		/* stw R6, <#[R1 + 364]> */
		/* 8209CCACh case    9:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x0000016C) );
		/* 8209CCACh case    9:*/		return 0x8209CCB0;
		  /* 8209CCB0h */ case   10:  		/* li R6, 1 */
		/* 8209CCB0h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8209CCB0h case   10:*/		return 0x8209CCB4;
		  /* 8209CCB4h */ case   11:  		/* li R7, 63 */
		/* 8209CCB4h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x3F);
		/* 8209CCB4h case   11:*/		return 0x8209CCB8;
		  /* 8209CCB8h */ case   12:  		/* stb R11, <#[R1 + 138]> */
		/* 8209CCB8h case   12:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x0000008A) );
		/* 8209CCB8h case   12:*/		return 0x8209CCBC;
		  /* 8209CCBCh */ case   13:  		/* li R5, 251 */
		/* 8209CCBCh case   13:*/		cpu::op::li<0>(regs,&regs.R5,0xFB);
		/* 8209CCBCh case   13:*/		return 0x8209CCC0;
		  /* 8209CCC0h */ case   14:  		/* stb R11, <#[R1 + 139]> */
		/* 8209CCC0h case   14:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x0000008B) );
		/* 8209CCC0h case   14:*/		return 0x8209CCC4;
		  /* 8209CCC4h */ case   15:  		/* rlwinm R8, R9, 0, 17, 31 */
		/* 8209CCC4h case   15:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R8,regs.R9);
		/* 8209CCC4h case   15:*/		return 0x8209CCC8;
		  /* 8209CCC8h */ case   16:  		/* stb R11, <#[R1 + 140]> */
		/* 8209CCC8h case   16:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 8209CCC8h case   16:*/		return 0x8209CCCC;
		  /* 8209CCCCh */ case   17:  		/* stb R11, <#[R1 + 141]> */
		/* 8209CCCCh case   17:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x0000008D) );
		/* 8209CCCCh case   17:*/		return 0x8209CCD0;
		  /* 8209CCD0h */ case   18:  		/* mr R9, R10 */
		/* 8209CCD0h case   18:*/		regs.R9 = regs.R10;
		/* 8209CCD0h case   18:*/		return 0x8209CCD4;
		  /* 8209CCD4h */ case   19:  		/* stb R11, <#[R1 + 142]> */
		/* 8209CCD4h case   19:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x0000008E) );
		/* 8209CCD4h case   19:*/		return 0x8209CCD8;
		  /* 8209CCD8h */ case   20:  		/* stb R11, <#[R1 + 143]> */
		/* 8209CCD8h case   20:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x0000008F) );
		/* 8209CCD8h case   20:*/		return 0x8209CCDC;
		  /* 8209CCDCh */ case   21:  		/* stb R11, <#[R1 + 144]> */
		/* 8209CCDCh case   21:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 8209CCDCh case   21:*/		return 0x8209CCE0;
		  /* 8209CCE0h */ case   22:  		/* stb R11, <#[R1 + 145]> */
		/* 8209CCE0h case   22:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000091) );
		/* 8209CCE0h case   22:*/		return 0x8209CCE4;
		  /* 8209CCE4h */ case   23:  		/* stb R11, <#[R1 + 146]> */
		/* 8209CCE4h case   23:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000092) );
		/* 8209CCE4h case   23:*/		return 0x8209CCE8;
		  /* 8209CCE8h */ case   24:  		/* stb R11, <#[R1 + 147]> */
		/* 8209CCE8h case   24:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000093) );
		/* 8209CCE8h case   24:*/		return 0x8209CCEC;
		  /* 8209CCECh */ case   25:  		/* li R11, 45 */
		/* 8209CCECh case   25:*/		cpu::op::li<0>(regs,&regs.R11,0x2D);
		/* 8209CCECh case   25:*/		return 0x8209CCF0;
		  /* 8209CCF0h */ case   26:  		/* std R4, <#[R1 + 344]> */
		/* 8209CCF0h case   26:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000158) );
		/* 8209CCF0h case   26:*/		return 0x8209CCF4;
		  /* 8209CCF4h */ case   27:  		/* stb R7, <#[R1 + 136]> */
		/* 8209CCF4h case   27:*/		cpu::mem::store8( regs, regs.R7, (uint32)(regs.R1 + 0x00000088) );
		/* 8209CCF4h case   27:*/		return 0x8209CCF8;
		  /* 8209CCF8h */ case   28:  		/* stb R5, <#[R1 + 137]> */
		/* 8209CCF8h case   28:*/		cpu::mem::store8( regs, regs.R5, (uint32)(regs.R1 + 0x00000089) );
		/* 8209CCF8h case   28:*/		return 0x8209CCFC;
		  /* 8209CCFCh */ case   29:  		/* stw R6, <#[R1 + 80]> */
		/* 8209CCFCh case   29:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 8209CCFCh case   29:*/		return 0x8209CD00;
		  /* 8209CD00h */ case   30:  		/* stw R10, <#[R1 + 84]> */
		/* 8209CD00h case   30:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 8209CD00h case   30:*/		return 0x8209CD04;
		  /* 8209CD04h */ case   31:  		/* bc 4, CR0_EQ, 8 */
		/* 8209CD04h case   31:*/		if ( !regs.CR[0].eq ) { return 0x8209CD0C;  }
		/* 8209CD04h case   31:*/		return 0x8209CD08;
		  /* 8209CD08h */ case   32:  		/* li R11, 32 */
		/* 8209CD08h case   32:*/		cpu::op::li<0>(regs,&regs.R11,0x20);
		/* 8209CD08h case   32:*/		return 0x8209CD0C;
	}
	return 0x8209CD0C;
} // Block from 8209CC88h-8209CD0Ch (33 instructions)

//////////////////////////////////////////////////////
// Block at 8209CD0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CD0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CD0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CD0C);
		  /* 8209CD0Ch */ case    0:  		/* stb R11, <#[R14 + 2]> */
		/* 8209CD0Ch case    0:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R14 + 0x00000002) );
		/* 8209CD0Ch case    0:*/		return 0x8209CD10;
		  /* 8209CD10h */ case    1:  		/* rlwinm. R11, R8, 0, 16, 31 */
		/* 8209CD10h case    1:*/		cpu::op::rlwinm<1,0,16,31>(regs,&regs.R11,regs.R8);
		/* 8209CD10h case    1:*/		return 0x8209CD14;
		  /* 8209CD14h */ case    2:  		/* lwz R7, <#[R1 + 342]> */
		/* 8209CD14h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000156) );
		/* 8209CD14h case    2:*/		return 0x8209CD18;
		  /* 8209CD18h */ case    3:  		/* lwz R10, <#[R1 + 338]> */
		/* 8209CD18h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000152) );
		/* 8209CD18h case    3:*/		return 0x8209CD1C;
		  /* 8209CD1Ch */ case    4:  		/* bc 4, CR0_EQ, 72 */
		/* 8209CD1Ch case    4:*/		if ( !regs.CR[0].eq ) { return 0x8209CD64;  }
		/* 8209CD1Ch case    4:*/		return 0x8209CD20;
		  /* 8209CD20h */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 8209CD20h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8209CD20h case    5:*/		return 0x8209CD24;
		  /* 8209CD24h */ case    6:  		/* bc 4, CR6_EQ, 64 */
		/* 8209CD24h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8209CD64;  }
		/* 8209CD24h case    6:*/		return 0x8209CD28;
		  /* 8209CD28h */ case    7:  		/* cmplwi CR6, R7, 0 */
		/* 8209CD28h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8209CD28h case    7:*/		return 0x8209CD2C;
		  /* 8209CD2Ch */ case    8:  		/* bc 4, CR6_EQ, 56 */
		/* 8209CD2Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x8209CD64;  }
		/* 8209CD2Ch case    8:*/		return 0x8209CD30;
		  /* 8209CD30h */ case    9:  		/* li R22, 0 */
		/* 8209CD30h case    9:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 8209CD30h case    9:*/		return 0x8209CD34;
		  /* 8209CD34h */ case   10:  		/* cmplwi CR6, R9, 32768 */
		/* 8209CD34h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00008000);
		/* 8209CD34h case   10:*/		return 0x8209CD38;
		  /* 8209CD38h */ case   11:  		/* sth R22, <#[R14]> */
		/* 8209CD38h case   11:*/		cpu::mem::store16( regs, regs.R22, (uint32)(regs.R14 + 0x00000000) );
		/* 8209CD38h case   11:*/		return 0x8209CD3C;
		  /* 8209CD3Ch */ case   12:  		/* li R11, 45 */
		/* 8209CD3Ch case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x2D);
		/* 8209CD3Ch case   12:*/		return 0x8209CD40;
		  /* 8209CD40h */ case   13:  		/* bc 12, CR6_EQ, 8 */
		/* 8209CD40h case   13:*/		if ( regs.CR[6].eq ) { return 0x8209CD48;  }
		/* 8209CD40h case   13:*/		return 0x8209CD44;
		  /* 8209CD44h */ case   14:  		/* li R11, 32 */
		/* 8209CD44h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x20);
		/* 8209CD44h case   14:*/		return 0x8209CD48;
	}
	return 0x8209CD48;
} // Block from 8209CD0Ch-8209CD48h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8209CD48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CD48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CD48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CD48);
		  /* 8209CD48h */ case    0:  		/* li R10, 48 */
		/* 8209CD48h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x30);
		/* 8209CD48h case    0:*/		return 0x8209CD4C;
		  /* 8209CD4Ch */ case    1:  		/* stb R6, <#[R14 + 3]> */
		/* 8209CD4Ch case    1:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R14 + 0x00000003) );
		/* 8209CD4Ch case    1:*/		return 0x8209CD50;
		  /* 8209CD50h */ case    2:  		/* stb R22, <#[R14 + 5]> */
		/* 8209CD50h case    2:*/		cpu::mem::store8( regs, regs.R22, (uint32)(regs.R14 + 0x00000005) );
		/* 8209CD50h case    2:*/		return 0x8209CD54;
		  /* 8209CD54h */ case    3:  		/* li R3, 1 */
		/* 8209CD54h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8209CD54h case    3:*/		return 0x8209CD58;
		  /* 8209CD58h */ case    4:  		/* stb R11, <#[R14 + 2]> */
		/* 8209CD58h case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R14 + 0x00000002) );
		/* 8209CD58h case    4:*/		return 0x8209CD5C;
		  /* 8209CD5Ch */ case    5:  		/* stb R10, <#[R14 + 4]> */
		/* 8209CD5Ch case    5:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R14 + 0x00000004) );
		/* 8209CD5Ch case    5:*/		return 0x8209CD60;
		  /* 8209CD60h */ case    6:  		/* b 2788 */
		/* 8209CD60h case    6:*/		return 0x8209D844;
		/* 8209CD60h case    6:*/		return 0x8209CD64;
	}
	return 0x8209CD64;
} // Block from 8209CD48h-8209CD64h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209CD64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CD64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CD64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CD64);
		  /* 8209CD64h */ case    0:  		/* cmplwi CR6, R11, 32767 */
		/* 8209CD64h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00007FFF);
		/* 8209CD64h case    0:*/		return 0x8209CD68;
		  /* 8209CD68h */ case    1:  		/* bc 4, CR6_EQ, 316 */
		/* 8209CD68h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209CEA4;  }
		/* 8209CD68h case    1:*/		return 0x8209CD6C;
		  /* 8209CD6Ch */ case    2:  		/* lis R11, -32768 */
		/* 8209CD6Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8000);
		/* 8209CD6Ch case    2:*/		return 0x8209CD70;
		  /* 8209CD70h */ case    3:  		/* sth R6, <#[R14]> */
		/* 8209CD70h case    3:*/		cpu::mem::store16( regs, regs.R6, (uint32)(regs.R14 + 0x00000000) );
		/* 8209CD70h case    3:*/		return 0x8209CD74;
		  /* 8209CD74h */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 8209CD74h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8209CD74h case    4:*/		return 0x8209CD78;
		  /* 8209CD78h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 8209CD78h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8209CD84;  }
		/* 8209CD78h case    5:*/		return 0x8209CD7C;
		  /* 8209CD7Ch */ case    6:  		/* cmplwi CR6, R7, 0 */
		/* 8209CD7Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8209CD7Ch case    6:*/		return 0x8209CD80;
		  /* 8209CD80h */ case    7:  		/* bc 12, CR6_EQ, 64 */
		/* 8209CD80h case    7:*/		if ( regs.CR[6].eq ) { return 0x8209CDC0;  }
		/* 8209CD80h case    7:*/		return 0x8209CD84;
	}
	return 0x8209CD84;
} // Block from 8209CD64h-8209CD84h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209CD84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CD84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CD84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CD84);
		  /* 8209CD84h */ case    0:  		/* rlwinm. R8, R10, 0, 1, 1 */
		/* 8209CD84h case    0:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R8,regs.R10);
		/* 8209CD84h case    0:*/		return 0x8209CD88;
		  /* 8209CD88h */ case    1:  		/* bc 4, CR0_EQ, 56 */
		/* 8209CD88h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8209CDC0;  }
		/* 8209CD88h case    1:*/		return 0x8209CD8C;
		  /* 8209CD8Ch */ case    2:  		/* lis R11, -32255 */
		/* 8209CD8Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209CD8Ch case    2:*/		return 0x8209CD90;
		  /* 8209CD90h */ case    3:  		/* li R4, 22 */
		/* 8209CD90h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x16);
		/* 8209CD90h case    3:*/		return 0x8209CD94;
		  /* 8209CD94h */ case    4:  		/* addi R5, R11, -17788 */
		/* 8209CD94h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFBA84);
		/* 8209CD94h case    4:*/		return 0x8209CD98;
		  /* 8209CD98h */ case    5:  		/* addi R3, R14, 4 */
		/* 8209CD98h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R14,0x4);
		/* 8209CD98h case    5:*/		return 0x8209CD9C;
		  /* 8209CD9Ch */ case    6:  		/* bl -14748 */
		/* 8209CD9Ch case    6:*/		regs.LR = 0x8209CDA0; return 0x82099400;
		/* 8209CD9Ch case    6:*/		return 0x8209CDA0;
		  /* 8209CDA0h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 8209CDA0h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209CDA0h case    7:*/		return 0x8209CDA4;
		  /* 8209CDA4h */ case    8:  		/* bc 12, CR0_EQ, 212 */
		/* 8209CDA4h case    8:*/		if ( regs.CR[0].eq ) { return 0x8209CE78;  }
		/* 8209CDA4h case    8:*/		return 0x8209CDA8;
		  /* 8209CDA8h */ case    9:  		/* li R7, 0 */
		/* 8209CDA8h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8209CDA8h case    9:*/		return 0x8209CDAC;
		  /* 8209CDACh */ case   10:  		/* li R6, 0 */
		/* 8209CDACh case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8209CDACh case   10:*/		return 0x8209CDB0;
		  /* 8209CDB0h */ case   11:  		/* li R5, 0 */
		/* 8209CDB0h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8209CDB0h case   11:*/		return 0x8209CDB4;
		  /* 8209CDB4h */ case   12:  		/* li R4, 0 */
		/* 8209CDB4h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8209CDB4h case   12:*/		return 0x8209CDB8;
		  /* 8209CDB8h */ case   13:  		/* li R3, 0 */
		/* 8209CDB8h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209CDB8h case   13:*/		return 0x8209CDBC;
		  /* 8209CDBCh */ case   14:  		/* bl -37764 */
		/* 8209CDBCh case   14:*/		regs.LR = 0x8209CDC0; return 0x82093A38;
		/* 8209CDBCh case   14:*/		return 0x8209CDC0;
	}
	return 0x8209CDC0;
} // Block from 8209CD84h-8209CDC0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8209CDC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CDC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CDC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CDC0);
		  /* 8209CDC0h */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 8209CDC0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8209CDC0h case    0:*/		return 0x8209CDC4;
		  /* 8209CDC4h */ case    1:  		/* bc 12, CR6_EQ, 76 */
		/* 8209CDC4h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209CE10;  }
		/* 8209CDC4h case    1:*/		return 0x8209CDC8;
		  /* 8209CDC8h */ case    2:  		/* lis R9, -16384 */
		/* 8209CDC8h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFC000);
		/* 8209CDC8h case    2:*/		return 0x8209CDCC;
		  /* 8209CDCCh */ case    3:  		/* cmplw CR6, R10, R9 */
		/* 8209CDCCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8209CDCCh case    3:*/		return 0x8209CDD0;
		  /* 8209CDD0h */ case    4:  		/* bc 4, CR6_EQ, 64 */
		/* 8209CDD0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8209CE10;  }
		/* 8209CDD0h case    4:*/		return 0x8209CDD4;
		  /* 8209CDD4h */ case    5:  		/* cmplwi CR6, R7, 0 */
		/* 8209CDD4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8209CDD4h case    5:*/		return 0x8209CDD8;
		  /* 8209CDD8h */ case    6:  		/* bc 4, CR6_EQ, 132 */
		/* 8209CDD8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8209CE5C;  }
		/* 8209CDD8h case    6:*/		return 0x8209CDDC;
		  /* 8209CDDCh */ case    7:  		/* lis R11, -32255 */
		/* 8209CDDCh case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209CDDCh case    7:*/		return 0x8209CDE0;
		  /* 8209CDE0h */ case    8:  		/* li R4, 22 */
		/* 8209CDE0h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x16);
		/* 8209CDE0h case    8:*/		return 0x8209CDE4;
		  /* 8209CDE4h */ case    9:  		/* addi R5, R11, -17796 */
		/* 8209CDE4h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFBA7C);
		/* 8209CDE4h case    9:*/		return 0x8209CDE8;
		  /* 8209CDE8h */ case   10:  		/* addi R3, R14, 4 */
		/* 8209CDE8h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R14,0x4);
		/* 8209CDE8h case   10:*/		return 0x8209CDEC;
		  /* 8209CDECh */ case   11:  		/* bl -14828 */
		/* 8209CDECh case   11:*/		regs.LR = 0x8209CDF0; return 0x82099400;
		/* 8209CDECh case   11:*/		return 0x8209CDF0;
		  /* 8209CDF0h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 8209CDF0h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209CDF0h case   12:*/		return 0x8209CDF4;
		  /* 8209CDF4h */ case   13:  		/* bc 12, CR0_EQ, 72 */
		/* 8209CDF4h case   13:*/		if ( regs.CR[0].eq ) { return 0x8209CE3C;  }
		/* 8209CDF4h case   13:*/		return 0x8209CDF8;
		  /* 8209CDF8h */ case   14:  		/* li R7, 0 */
		/* 8209CDF8h case   14:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8209CDF8h case   14:*/		return 0x8209CDFC;
		  /* 8209CDFCh */ case   15:  		/* li R6, 0 */
		/* 8209CDFCh case   15:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8209CDFCh case   15:*/		return 0x8209CE00;
		  /* 8209CE00h */ case   16:  		/* li R5, 0 */
		/* 8209CE00h case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8209CE00h case   16:*/		return 0x8209CE04;
		  /* 8209CE04h */ case   17:  		/* li R4, 0 */
		/* 8209CE04h case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8209CE04h case   17:*/		return 0x8209CE08;
		  /* 8209CE08h */ case   18:  		/* li R3, 0 */
		/* 8209CE08h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209CE08h case   18:*/		return 0x8209CE0C;
		  /* 8209CE0Ch */ case   19:  		/* bl -37844 */
		/* 8209CE0Ch case   19:*/		regs.LR = 0x8209CE10; return 0x82093A38;
		/* 8209CE0Ch case   19:*/		return 0x8209CE10;
	}
	return 0x8209CE10;
} // Block from 8209CDC0h-8209CE10h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8209CE10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CE10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CE10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CE10);
		  /* 8209CE10h */ case    0:  		/* cmplw CR6, R10, R11 */
		/* 8209CE10h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8209CE10h case    0:*/		return 0x8209CE14;
		  /* 8209CE14h */ case    1:  		/* bc 4, CR6_EQ, 72 */
		/* 8209CE14h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209CE5C;  }
		/* 8209CE14h case    1:*/		return 0x8209CE18;
		  /* 8209CE18h */ case    2:  		/* cmplwi CR6, R7, 0 */
		/* 8209CE18h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8209CE18h case    2:*/		return 0x8209CE1C;
		  /* 8209CE1Ch */ case    3:  		/* bc 4, CR6_EQ, 64 */
		/* 8209CE1Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8209CE5C;  }
		/* 8209CE1Ch case    3:*/		return 0x8209CE20;
		  /* 8209CE20h */ case    4:  		/* lis R11, -32255 */
		/* 8209CE20h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209CE20h case    4:*/		return 0x8209CE24;
		  /* 8209CE24h */ case    5:  		/* li R4, 22 */
		/* 8209CE24h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x16);
		/* 8209CE24h case    5:*/		return 0x8209CE28;
		  /* 8209CE28h */ case    6:  		/* addi R5, R11, -17804 */
		/* 8209CE28h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFBA74);
		/* 8209CE28h case    6:*/		return 0x8209CE2C;
		  /* 8209CE2Ch */ case    7:  		/* addi R3, R14, 4 */
		/* 8209CE2Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R14,0x4);
		/* 8209CE2Ch case    7:*/		return 0x8209CE30;
		  /* 8209CE30h */ case    8:  		/* bl -14896 */
		/* 8209CE30h case    8:*/		regs.LR = 0x8209CE34; return 0x82099400;
		/* 8209CE30h case    8:*/		return 0x8209CE34;
		  /* 8209CE34h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 8209CE34h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209CE34h case    9:*/		return 0x8209CE38;
		  /* 8209CE38h */ case   10:  		/* bc 4, CR0_EQ, 12 */
		/* 8209CE38h case   10:*/		if ( !regs.CR[0].eq ) { return 0x8209CE44;  }
		/* 8209CE38h case   10:*/		return 0x8209CE3C;
	}
	return 0x8209CE3C;
} // Block from 8209CE10h-8209CE3Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209CE3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CE3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CE3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CE3C);
		  /* 8209CE3Ch */ case    0:  		/* li R11, 5 */
		/* 8209CE3Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 8209CE3Ch case    0:*/		return 0x8209CE40;
		  /* 8209CE40h */ case    1:  		/* b 60 */
		/* 8209CE40h case    1:*/		return 0x8209CE7C;
		/* 8209CE40h case    1:*/		return 0x8209CE44;
	}
	return 0x8209CE44;
} // Block from 8209CE3Ch-8209CE44h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209CE44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CE44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CE44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CE44);
		  /* 8209CE44h */ case    0:  		/* li R7, 0 */
		/* 8209CE44h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8209CE44h case    0:*/		return 0x8209CE48;
		  /* 8209CE48h */ case    1:  		/* li R6, 0 */
		/* 8209CE48h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8209CE48h case    1:*/		return 0x8209CE4C;
		  /* 8209CE4Ch */ case    2:  		/* li R5, 0 */
		/* 8209CE4Ch case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8209CE4Ch case    2:*/		return 0x8209CE50;
		  /* 8209CE50h */ case    3:  		/* li R4, 0 */
		/* 8209CE50h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8209CE50h case    3:*/		return 0x8209CE54;
		  /* 8209CE54h */ case    4:  		/* li R3, 0 */
		/* 8209CE54h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209CE54h case    4:*/		return 0x8209CE58;
		  /* 8209CE58h */ case    5:  		/* bl -37920 */
		/* 8209CE58h case    5:*/		regs.LR = 0x8209CE5C; return 0x82093A38;
		/* 8209CE58h case    5:*/		return 0x8209CE5C;
	}
	return 0x8209CE5C;
} // Block from 8209CE44h-8209CE5Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209CE5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CE5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CE5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CE5C);
		  /* 8209CE5Ch */ case    0:  		/* lis R11, -32255 */
		/* 8209CE5Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209CE5Ch case    0:*/		return 0x8209CE60;
		  /* 8209CE60h */ case    1:  		/* li R4, 22 */
		/* 8209CE60h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x16);
		/* 8209CE60h case    1:*/		return 0x8209CE64;
		  /* 8209CE64h */ case    2:  		/* addi R5, R11, -17812 */
		/* 8209CE64h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFBA6C);
		/* 8209CE64h case    2:*/		return 0x8209CE68;
		  /* 8209CE68h */ case    3:  		/* addi R3, R14, 4 */
		/* 8209CE68h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R14,0x4);
		/* 8209CE68h case    3:*/		return 0x8209CE6C;
		  /* 8209CE6Ch */ case    4:  		/* bl -14956 */
		/* 8209CE6Ch case    4:*/		regs.LR = 0x8209CE70; return 0x82099400;
		/* 8209CE6Ch case    4:*/		return 0x8209CE70;
		  /* 8209CE70h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 8209CE70h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209CE70h case    5:*/		return 0x8209CE74;
		  /* 8209CE74h */ case    6:  		/* bc 4, CR0_EQ, 24 */
		/* 8209CE74h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8209CE8C;  }
		/* 8209CE74h case    6:*/		return 0x8209CE78;
	}
	return 0x8209CE78;
} // Block from 8209CE5Ch-8209CE78h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209CE78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CE78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CE78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CE78);
		  /* 8209CE78h */ case    0:  		/* li R11, 6 */
		/* 8209CE78h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x6);
		/* 8209CE78h case    0:*/		return 0x8209CE7C;
	}
	return 0x8209CE7C;
} // Block from 8209CE78h-8209CE7Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209CE7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CE7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CE7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CE7C);
		  /* 8209CE7Ch */ case    0:  		/* li R10, 0 */
		/* 8209CE7Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8209CE7Ch case    0:*/		return 0x8209CE80;
		  /* 8209CE80h */ case    1:  		/* stb R11, <#[R14 + 3]> */
		/* 8209CE80h case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R14 + 0x00000003) );
		/* 8209CE80h case    1:*/		return 0x8209CE84;
		  /* 8209CE84h */ case    2:  		/* stw R10, <#[R1 + 80]> */
		/* 8209CE84h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8209CE84h case    2:*/		return 0x8209CE88;
		  /* 8209CE88h */ case    3:  		/* b 2488 */
		/* 8209CE88h case    3:*/		return 0x8209D840;
		/* 8209CE88h case    3:*/		return 0x8209CE8C;
	}
	return 0x8209CE8C;
} // Block from 8209CE7Ch-8209CE8Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209CE8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CE8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CE8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CE8C);
		  /* 8209CE8Ch */ case    0:  		/* li R7, 0 */
		/* 8209CE8Ch case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8209CE8Ch case    0:*/		return 0x8209CE90;
		  /* 8209CE90h */ case    1:  		/* li R6, 0 */
		/* 8209CE90h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8209CE90h case    1:*/		return 0x8209CE94;
		  /* 8209CE94h */ case    2:  		/* li R5, 0 */
		/* 8209CE94h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8209CE94h case    2:*/		return 0x8209CE98;
		  /* 8209CE98h */ case    3:  		/* li R4, 0 */
		/* 8209CE98h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8209CE98h case    3:*/		return 0x8209CE9C;
		  /* 8209CE9Ch */ case    4:  		/* li R3, 0 */
		/* 8209CE9Ch case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209CE9Ch case    4:*/		return 0x8209CEA0;
		  /* 8209CEA0h */ case    5:  		/* bl -37992 */
		/* 8209CEA0h case    5:*/		regs.LR = 0x8209CEA4; return 0x82093A38;
		/* 8209CEA0h case    5:*/		return 0x8209CEA4;
	}
	return 0x8209CEA4;
} // Block from 8209CE8Ch-8209CEA4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209CEA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CEA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CEA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CEA4);
		  /* 8209CEA4h */ case    0:  		/* rlwinm R9, R10, 9, 23, 30 */
		/* 8209CEA4h case    0:*/		cpu::op::rlwinm<0,9,23,30>(regs,&regs.R9,regs.R10);
		/* 8209CEA4h case    0:*/		return 0x8209CEA8;
		  /* 8209CEA8h */ case    1:  		/* stw R10, <#[R1 + 90]> */
		/* 8209CEA8h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000005A) );
		/* 8209CEA8h case    1:*/		return 0x8209CEAC;
		  /* 8209CEACh */ case    2:  		/* rlwinm R10, R11, 24, 8, 31 */
		/* 8209CEACh case    2:*/		cpu::op::rlwinm<0,24,8,31>(regs,&regs.R10,regs.R11);
		/* 8209CEACh case    2:*/		return 0x8209CEB0;
		  /* 8209CEB0h */ case    3:  		/* stw R7, <#[R1 + 94]> */
		/* 8209CEB0h case    3:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x0000005E) );
		/* 8209CEB0h case    3:*/		return 0x8209CEB4;
		  /* 8209CEB4h */ case    4:  		/* mulli R11, R11, 19728 */
		/* 8209CEB4h case    4:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x4D10);
		/* 8209CEB4h case    4:*/		return 0x8209CEB8;
		  /* 8209CEB8h */ case    5:  		/* sth R8, <#[R1 + 88]> */
		/* 8209CEB8h case    5:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R1 + 0x00000058) );
		/* 8209CEB8h case    5:*/		return 0x8209CEBC;
		  /* 8209CEBCh */ case    6:  		/* add R10, R9, R10 */
		/* 8209CEBCh case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8209CEBCh case    6:*/		return 0x8209CEC0;
		  /* 8209CEC0h */ case    7:  		/* lis R9, -32217 */
		/* 8209CEC0h case    7:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8227);
		/* 8209CEC0h case    7:*/		return 0x8209CEC4;
		  /* 8209CEC4h */ case    8:  		/* mulli R10, R10, 77 */
		/* 8209CEC4h case    8:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x4D);
		/* 8209CEC4h case    8:*/		return 0x8209CEC8;
		  /* 8209CEC8h */ case    9:  		/* add R11, R10, R11 */
		/* 8209CEC8h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8209CEC8h case    9:*/		return 0x8209CECC;
		  /* 8209CECCh */ case   10:  		/* li R22, 0 */
		/* 8209CECCh case   10:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 8209CECCh case   10:*/		return 0x8209CED0;
		  /* 8209CED0h */ case   11:  		/* addis R11, R11, -4931 */
		/* 8209CED0h case   11:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R11,0xFFFFECBD);
		/* 8209CED0h case   11:*/		return 0x8209CED4;
		  /* 8209CED4h */ case   12:  		/* lis R10, 0 */
		/* 8209CED4h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 8209CED4h case   12:*/		return 0x8209CED8;
		  /* 8209CED8h */ case   13:  		/* sth R22, <#[R1 + 98]> */
		/* 8209CED8h case   13:*/		cpu::mem::store16( regs, regs.R22, (uint32)(regs.R1 + 0x00000062) );
		/* 8209CED8h case   13:*/		return 0x8209CEDC;
		  /* 8209CEDCh */ case   14:  		/* addi R11, R11, -4852 */
		/* 8209CEDCh case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFED0C);
		/* 8209CEDCh case   14:*/		return 0x8209CEE0;
		  /* 8209CEE0h */ case   15:  		/* lis R7, 0 */
		/* 8209CEE0h case   15:*/		cpu::op::lis<0>(regs,&regs.R7,0x0);
		/* 8209CEE0h case   15:*/		return 0x8209CEE4;
		  /* 8209CEE4h */ case   16:  		/* srawi R11, R11, 16 */
		/* 8209CEE4h case   16:*/		cpu::op::srawi<0,16>(regs,&regs.R11,regs.R11);
		/* 8209CEE4h case   16:*/		return 0x8209CEE8;
		  /* 8209CEE8h */ case   17:  		/* lis R6, 1 */
		/* 8209CEE8h case   17:*/		cpu::op::lis<0>(regs,&regs.R6,0x1);
		/* 8209CEE8h case   17:*/		return 0x8209CEEC;
		  /* 8209CEECh */ case   18:  		/* extsh R19, R11 */
		/* 8209CEECh case   18:*/		cpu::op::extsh<0>(regs,&regs.R19,regs.R11);
		/* 8209CEECh case   18:*/		return 0x8209CEF0;
		  /* 8209CEF0h */ case   19:  		/* lis R5, 0 */
		/* 8209CEF0h case   19:*/		cpu::op::lis<0>(regs,&regs.R5,0x0);
		/* 8209CEF0h case   19:*/		return 0x8209CEF4;
		  /* 8209CEF4h */ case   20:  		/* lis R4, 32767 */
		/* 8209CEF4h case   20:*/		cpu::op::lis<0>(regs,&regs.R4,0x7FFF);
		/* 8209CEF4h case   20:*/		return 0x8209CEF8;
		  /* 8209CEF8h */ case   21:  		/* addi R11, R9, 10272 */
		/* 8209CEF8h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x2820);
		/* 8209CEF8h case   21:*/		return 0x8209CEFC;
		  /* 8209CEFCh */ case   22:  		/* mr R24, R19 */
		/* 8209CEFCh case   22:*/		regs.R24 = regs.R19;
		/* 8209CEFCh case   22:*/		return 0x8209CF00;
		  /* 8209CF00h */ case   23:  		/* mr R31, R8 */
		/* 8209CF00h case   23:*/		regs.R31 = regs.R8;
		/* 8209CF00h case   23:*/		return 0x8209CF04;
		  /* 8209CF04h */ case   24:  		/* neg. R25, R19 */
		/* 8209CF04h case   24:*/		cpu::op::neg<1>(regs,&regs.R25,regs.R19);
		/* 8209CF04h case   24:*/		return 0x8209CF08;
		  /* 8209CF08h */ case   25:  		/* ori R20, R10, 49154 */
		/* 8209CF08h case   25:*/		cpu::op::ori<0>(regs,&regs.R20,regs.R10,0xC002);
		/* 8209CF08h case   25:*/		return 0x8209CF0C;
		  /* 8209CF0Ch */ case   26:  		/* ori R21, R7, 65535 */
		/* 8209CF0Ch case   26:*/		cpu::op::ori<0>(regs,&regs.R21,regs.R7,0xFFFF);
		/* 8209CF0Ch case   26:*/		return 0x8209CF10;
		  /* 8209CF10h */ case   27:  		/* ori R17, R6, 32768 */
		/* 8209CF10h case   27:*/		cpu::op::ori<0>(regs,&regs.R17,regs.R6,0x8000);
		/* 8209CF10h case   27:*/		return 0x8209CF14;
		  /* 8209CF14h */ case   28:  		/* ori R18, R5, 32768 */
		/* 8209CF14h case   28:*/		cpu::op::ori<0>(regs,&regs.R18,regs.R5,0x8000);
		/* 8209CF14h case   28:*/		return 0x8209CF18;
		  /* 8209CF18h */ case   29:  		/* li R15, -32768 */
		/* 8209CF18h case   29:*/		cpu::op::li<0>(regs,&regs.R15,0xFFFF8000);
		/* 8209CF18h case   29:*/		return 0x8209CF1C;
		  /* 8209CF1Ch */ case   30:  		/* ori R16, R4, 32768 */
		/* 8209CF1Ch case   30:*/		cpu::op::ori<0>(regs,&regs.R16,regs.R4,0x8000);
		/* 8209CF1Ch case   30:*/		return 0x8209CF20;
		  /* 8209CF20h */ case   31:  		/* addi R23, R11, -96 */
		/* 8209CF20h case   31:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R11,0xFFFFFFA0);
		/* 8209CF20h case   31:*/		return 0x8209CF24;
		  /* 8209CF24h */ case   32:  		/* bc 12, CR0_EQ, 908 */
		/* 8209CF24h case   32:*/		if ( regs.CR[0].eq ) { return 0x8209D2B0;  }
		/* 8209CF24h case   32:*/		return 0x8209CF28;
		  /* 8209CF28h */ case   33:  		/* cmpwi CR6, R25, 0 */
		/* 8209CF28h case   33:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 8209CF28h case   33:*/		return 0x8209CF2C;
		  /* 8209CF2Ch */ case   34:  		/* bc 4, CR6_LT, 24 */
		/* 8209CF2Ch case   34:*/		if ( !regs.CR[6].lt ) { return 0x8209CF44;  }
		/* 8209CF2Ch case   34:*/		return 0x8209CF30;
		  /* 8209CF30h */ case   35:  		/* lis R11, -32217 */
		/* 8209CF30h case   35:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 8209CF30h case   35:*/		return 0x8209CF34;
		  /* 8209CF34h */ case   36:  		/* neg R25, R25 */
		/* 8209CF34h case   36:*/		cpu::op::neg<0>(regs,&regs.R25,regs.R25);
		/* 8209CF34h case   36:*/		return 0x8209CF38;
		  /* 8209CF38h */ case   37:  		/* addi R11, R11, 10624 */
		/* 8209CF38h case   37:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2980);
		/* 8209CF38h case   37:*/		return 0x8209CF3C;
		  /* 8209CF3Ch */ case   38:  		/* cmpwi CR6, R25, 0 */
		/* 8209CF3Ch case   38:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 8209CF3Ch case   38:*/		return 0x8209CF40;
		  /* 8209CF40h */ case   39:  		/* addi R23, R11, -96 */
		/* 8209CF40h case   39:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R11,0xFFFFFFA0);
		/* 8209CF40h case   39:*/		return 0x8209CF44;
	}
	return 0x8209CF44;
} // Block from 8209CEA4h-8209CF44h (40 instructions)

//////////////////////////////////////////////////////
// Block at 8209CF44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CF44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CF44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CF44);
		  /* 8209CF44h */ case    0:  		/* bc 12, CR6_EQ, 876 */
		/* 8209CF44h case    0:*/		if ( regs.CR[6].eq ) { return 0x8209D2B0;  }
		/* 8209CF44h case    0:*/		return 0x8209CF48;
		  /* 8209CF48h */ case    1:  		/* lwz R27, <#[R1 + 96]> */
		/* 8209CF48h case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000060) );
		/* 8209CF48h case    1:*/		return 0x8209CF4C;
		  /* 8209CF4Ch */ case    2:  		/* lwz R28, <#[R1 + 92]> */
		/* 8209CF4Ch case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x0000005C) );
		/* 8209CF4Ch case    2:*/		return 0x8209CF50;
		  /* 8209CF50h */ case    3:  		/* rlwinm. R11, R25, 0, 29, 31 */
		/* 8209CF50h case    3:*/		cpu::op::rlwinm<1,0,29,31>(regs,&regs.R11,regs.R25);
		/* 8209CF50h case    3:*/		return 0x8209CF54;
		  /* 8209CF54h */ case    4:  		/* addi R23, R23, 84 */
		/* 8209CF54h case    4:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x54);
		/* 8209CF54h case    4:*/		return 0x8209CF58;
		  /* 8209CF58h */ case    5:  		/* srawi R25, R25, 3 */
		/* 8209CF58h case    5:*/		cpu::op::srawi<0,3>(regs,&regs.R25,regs.R25);
		/* 8209CF58h case    5:*/		return 0x8209CF5C;
		  /* 8209CF5Ch */ case    6:  		/* bc 12, CR0_EQ, 836 */
		/* 8209CF5Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x8209D2A0;  }
		/* 8209CF5Ch case    6:*/		return 0x8209CF60;
		  /* 8209CF60h */ case    7:  		/* mulli R11, R11, 12 */
		/* 8209CF60h case    7:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8209CF60h case    7:*/		return 0x8209CF64;
		  /* 8209CF64h */ case    8:  		/* add R4, R11, R23 */
		/* 8209CF64h case    8:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R23);
		/* 8209CF64h case    8:*/		return 0x8209CF68;
		  /* 8209CF68h */ case    9:  		/* lhz R11, <#[R4 + 10]> */
		/* 8209CF68h case    9:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000A) );
		/* 8209CF68h case    9:*/		return 0x8209CF6C;
		  /* 8209CF6Ch */ case   10:  		/* cmplwi CR6, R11, 32768 */
		/* 8209CF6Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00008000);
		/* 8209CF6Ch case   10:*/		return 0x8209CF70;
		  /* 8209CF70h */ case   11:  		/* bc 12, CR6_LT, 32 */
		/* 8209CF70h case   11:*/		if ( regs.CR[6].lt ) { return 0x8209CF90;  }
		/* 8209CF70h case   11:*/		return 0x8209CF74;
		  /* 8209CF74h */ case   12:  		/* addi R3, R1, 152 */
		/* 8209CF74h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x98);
		/* 8209CF74h case   12:*/		return 0x8209CF78;
		  /* 8209CF78h */ case   13:  		/* li R5, 12 */
		/* 8209CF78h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0xC);
		/* 8209CF78h case   13:*/		return 0x8209CF7C;
		  /* 8209CF7Ch */ case   14:  		/* bl -46540 */
		/* 8209CF7Ch case   14:*/		regs.LR = 0x8209CF80; return 0x820919B0;
		/* 8209CF7Ch case   14:*/		return 0x8209CF80;
		  /* 8209CF80h */ case   15:  		/* lwz R11, <#[R1 + 158]> */
		/* 8209CF80h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000009E) );
		/* 8209CF80h case   15:*/		return 0x8209CF84;
		  /* 8209CF84h */ case   16:  		/* addi R4, R1, 152 */
		/* 8209CF84h case   16:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x98);
		/* 8209CF84h case   16:*/		return 0x8209CF88;
		  /* 8209CF88h */ case   17:  		/* addi R11, R11, -1 */
		/* 8209CF88h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8209CF88h case   17:*/		return 0x8209CF8C;
		  /* 8209CF8Ch */ case   18:  		/* stw R11, <#[R1 + 158]> */
		/* 8209CF8Ch case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000009E) );
		/* 8209CF8Ch case   18:*/		return 0x8209CF90;
	}
	return 0x8209CF90;
} // Block from 8209CF44h-8209CF90h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8209CF90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CF90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CF90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CF90);
		  /* 8209CF90h */ case    0:  		/* stw R22, <#[R1 + 104]> */
		/* 8209CF90h case    0:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000068) );
		/* 8209CF90h case    0:*/		return 0x8209CF94;
		  /* 8209CF94h */ case    1:  		/* rlwinm R11, R31, 0, 17, 31 */
		/* 8209CF94h case    1:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R11,regs.R31);
		/* 8209CF94h case    1:*/		return 0x8209CF98;
		  /* 8209CF98h */ case    2:  		/* stw R22, <#[R1 + 112]> */
		/* 8209CF98h case    2:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000070) );
		/* 8209CF98h case    2:*/		return 0x8209CF9C;
		  /* 8209CF9Ch */ case    3:  		/* rlwinm R9, R31, 0, 16, 31 */
		/* 8209CF9Ch case    3:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R31);
		/* 8209CF9Ch case    3:*/		return 0x8209CFA0;
		  /* 8209CFA0h */ case    4:  		/* stw R22, <#[R1 + 108]> */
		/* 8209CFA0h case    4:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x0000006C) );
		/* 8209CFA0h case    4:*/		return 0x8209CFA4;
		  /* 8209CFA4h */ case    5:  		/* mr R29, R22 */
		/* 8209CFA4h case    5:*/		regs.R29 = regs.R22;
		/* 8209CFA4h case    5:*/		return 0x8209CFA8;
		  /* 8209CFA8h */ case    6:  		/* cmplwi CR6, R11, 32767 */
		/* 8209CFA8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00007FFF);
		/* 8209CFA8h case    6:*/		return 0x8209CFAC;
		  /* 8209CFACh */ case    7:  		/* lhz R8, <#[R4]> */
		/* 8209CFACh case    7:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000000) );
		/* 8209CFACh case    7:*/		return 0x8209CFB0;
		  /* 8209CFB0h */ case    8:  		/* rlwinm R10, R8, 0, 17, 31 */
		/* 8209CFB0h case    8:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R10,regs.R8);
		/* 8209CFB0h case    8:*/		return 0x8209CFB4;
		  /* 8209CFB4h */ case    9:  		/* xor R8, R9, R8 */
		/* 8209CFB4h case    9:*/		cpu::op::xor<0>(regs,&regs.R8,regs.R9,regs.R8);
		/* 8209CFB4h case    9:*/		return 0x8209CFB8;
		  /* 8209CFB8h */ case   10:  		/* add R7, R11, R10 */
		/* 8209CFB8h case   10:*/		cpu::op::add<0>(regs,&regs.R7,regs.R11,regs.R10);
		/* 8209CFB8h case   10:*/		return 0x8209CFBC;
		  /* 8209CFBCh */ case   11:  		/* mr R9, R11 */
		/* 8209CFBCh case   11:*/		regs.R9 = regs.R11;
		/* 8209CFBCh case   11:*/		return 0x8209CFC0;
		  /* 8209CFC0h */ case   12:  		/* rlwinm R26, R8, 0, 16, 16 */
		/* 8209CFC0h case   12:*/		cpu::op::rlwinm<0,0,16,16>(regs,&regs.R26,regs.R8);
		/* 8209CFC0h case   12:*/		return 0x8209CFC4;
		  /* 8209CFC4h */ case   13:  		/* rlwinm R30, R7, 0, 16, 31 */
		/* 8209CFC4h case   13:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R30,regs.R7);
		/* 8209CFC4h case   13:*/		return 0x8209CFC8;
		  /* 8209CFC8h */ case   14:  		/* bc 4, CR6_LT, 696 */
		/* 8209CFC8h case   14:*/		if ( !regs.CR[6].lt ) { return 0x8209D280;  }
		/* 8209CFC8h case   14:*/		return 0x8209CFCC;
		  /* 8209CFCCh */ case   15:  		/* cmplwi CR6, R10, 32767 */
		/* 8209CFCCh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00007FFF);
		/* 8209CFCCh case   15:*/		return 0x8209CFD0;
		  /* 8209CFD0h */ case   16:  		/* bc 4, CR6_LT, 688 */
		/* 8209CFD0h case   16:*/		if ( !regs.CR[6].lt ) { return 0x8209D280;  }
		/* 8209CFD0h case   16:*/		return 0x8209CFD4;
		  /* 8209CFD4h */ case   17:  		/* rlwinm R11, R30, 0, 16, 31 */
		/* 8209CFD4h case   17:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R30);
		/* 8209CFD4h case   17:*/		return 0x8209CFD8;
		  /* 8209CFD8h */ case   18:  		/* cmplwi CR6, R11, 49149 */
		/* 8209CFD8h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000BFFD);
		/* 8209CFD8h case   18:*/		return 0x8209CFDC;
		  /* 8209CFDCh */ case   19:  		/* bc 12, CR6_GT, 676 */
		/* 8209CFDCh case   19:*/		if ( regs.CR[6].gt ) { return 0x8209D280;  }
		/* 8209CFDCh case   19:*/		return 0x8209CFE0;
		  /* 8209CFE0h */ case   20:  		/* cmplwi CR6, R11, 16319 */
		/* 8209CFE0h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003FBF);
		/* 8209CFE0h case   20:*/		return 0x8209CFE4;
		  /* 8209CFE4h */ case   21:  		/* bc 12, CR6_GT, 12 */
		/* 8209CFE4h case   21:*/		if ( regs.CR[6].gt ) { return 0x8209CFF0;  }
		/* 8209CFE4h case   21:*/		return 0x8209CFE8;
		  /* 8209CFE8h */ case   22:  		/* stw R22, <#[R1 + 88]> */
		/* 8209CFE8h case   22:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000058) );
		/* 8209CFE8h case   22:*/		return 0x8209CFEC;
		  /* 8209CFECh */ case   23:  		/* b 676 */
		/* 8209CFECh case   23:*/		return 0x8209D290;
		/* 8209CFECh case   23:*/		return 0x8209CFF0;
	}
	return 0x8209CFF0;
} // Block from 8209CF90h-8209CFF0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8209CFF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209CFF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209CFF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209CFF0);
		  /* 8209CFF0h */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 8209CFF0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8209CFF0h case    0:*/		return 0x8209CFF4;
		  /* 8209CFF4h */ case    1:  		/* bc 4, CR6_EQ, 48 */
		/* 8209CFF4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209D024;  }
		/* 8209CFF4h case    1:*/		return 0x8209CFF8;
		  /* 8209CFF8h */ case    2:  		/* lwz R9, <#[R1 + 88]> */
		/* 8209CFF8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 8209CFF8h case    2:*/		return 0x8209CFFC;
		  /* 8209CFFCh */ case    3:  		/* addi R11, R11, 1 */
		/* 8209CFFCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209CFFCh case    3:*/		return 0x8209D000;
		  /* 8209D000h */ case    4:  		/* rlwinm. R9, R9, 0, 1, 31 */
		/* 8209D000h case    4:*/		cpu::op::rlwinm<1,0,1,31>(regs,&regs.R9,regs.R9);
		/* 8209D000h case    4:*/		return 0x8209D004;
		  /* 8209D004h */ case    5:  		/* rlwinm R30, R11, 0, 16, 31 */
		/* 8209D004h case    5:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R30,regs.R11);
		/* 8209D004h case    5:*/		return 0x8209D008;
		  /* 8209D008h */ case    6:  		/* bc 4, CR0_EQ, 28 */
		/* 8209D008h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8209D024;  }
		/* 8209D008h case    6:*/		return 0x8209D00C;
		  /* 8209D00Ch */ case    7:  		/* cmplwi CR6, R28, 0 */
		/* 8209D00Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8209D00Ch case    7:*/		return 0x8209D010;
		  /* 8209D010h */ case    8:  		/* bc 4, CR6_EQ, 20 */
		/* 8209D010h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8209D024;  }
		/* 8209D010h case    8:*/		return 0x8209D014;
		  /* 8209D014h */ case    9:  		/* cmplwi CR6, R27, 0 */
		/* 8209D014h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8209D014h case    9:*/		return 0x8209D018;
	}
	return 0x8209D018;
} // Block from 8209CFF0h-8209D018h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209D018h
// Function '_ld12tof'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D018);
		  /* 8209D018h */ case    0:  		/* bc 4, CR6_EQ, 12 */
		/* 8209D018h case    0:*/		if ( !regs.CR[6].eq ) { return 0x8209D024;  }
		/* 8209D018h case    0:*/		return 0x8209D01C;
		  /* 8209D01Ch */ case    1:  		/* sth R22, <#[R1 + 88]> */
		/* 8209D01Ch case    1:*/		cpu::mem::store16( regs, regs.R22, (uint32)(regs.R1 + 0x00000058) );
		/* 8209D01Ch case    1:*/		return 0x8209D020;
		  /* 8209D020h */ case    2:  		/* b 640 */
		/* 8209D020h case    2:*/		return 0x8209D2A0;
		/* 8209D020h case    2:*/		return 0x8209D024;
	}
	return 0x8209D024;
} // Block from 8209D018h-8209D024h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209D024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D024);
		  /* 8209D024h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 8209D024h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8209D024h case    0:*/		return 0x8209D028;
		  /* 8209D028h */ case    1:  		/* bc 4, CR6_EQ, 52 */
		/* 8209D028h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209D05C;  }
		/* 8209D028h case    1:*/		return 0x8209D02C;
		  /* 8209D02Ch */ case    2:  		/* rlwinm R11, R30, 0, 16, 31 */
		/* 8209D02Ch case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R30);
		/* 8209D02Ch case    2:*/		return 0x8209D030;
		  /* 8209D030h */ case    3:  		/* lwz R10, <#[R4]> */
		/* 8209D030h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 8209D030h case    3:*/		return 0x8209D034;
		  /* 8209D034h */ case    4:  		/* addi R11, R11, 1 */
		/* 8209D034h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209D034h case    4:*/		return 0x8209D038;
		  /* 8209D038h */ case    5:  		/* rlwinm. R10, R10, 0, 1, 31 */
		/* 8209D038h case    5:*/		cpu::op::rlwinm<1,0,1,31>(regs,&regs.R10,regs.R10);
		/* 8209D038h case    5:*/		return 0x8209D03C;
		  /* 8209D03Ch */ case    6:  		/* rlwinm R30, R11, 0, 16, 31 */
		/* 8209D03Ch case    6:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R30,regs.R11);
		/* 8209D03Ch case    6:*/		return 0x8209D040;
		  /* 8209D040h */ case    7:  		/* bc 4, CR0_EQ, 28 */
		/* 8209D040h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8209D05C;  }
		/* 8209D040h case    7:*/		return 0x8209D044;
		  /* 8209D044h */ case    8:  		/* lwz R11, <#[R4 + 4]> */
		/* 8209D044h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 8209D044h case    8:*/		return 0x8209D048;
		  /* 8209D048h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 8209D048h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209D048h case    9:*/		return 0x8209D04C;
		  /* 8209D04Ch */ case   10:  		/* bc 4, CR6_EQ, 16 */
		/* 8209D04Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x8209D05C;  }
		/* 8209D04Ch case   10:*/		return 0x8209D050;
		  /* 8209D050h */ case   11:  		/* lwz R11, <#[R4 + 8]> */
		/* 8209D050h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8209D050h case   11:*/		return 0x8209D054;
		  /* 8209D054h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 8209D054h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209D054h case   12:*/		return 0x8209D058;
		  /* 8209D058h */ case   13:  		/* bc 12, CR6_EQ, -112 */
		/* 8209D058h case   13:*/		if ( regs.CR[6].eq ) { return 0x8209CFE8;  }
		/* 8209D058h case   13:*/		return 0x8209D05C;
	}
	return 0x8209D05C;
} // Block from 8209D024h-8209D05Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209D05Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D05C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D05C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D05C);
		  /* 8209D05Ch */ case    0:  		/* mr R31, R22 */
		/* 8209D05Ch case    0:*/		regs.R31 = regs.R22;
		/* 8209D05Ch case    0:*/		return 0x8209D060;
		  /* 8209D060h */ case    1:  		/* addi R8, R1, 110 */
		/* 8209D060h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x6E);
		/* 8209D060h case    1:*/		return 0x8209D064;
		  /* 8209D064h */ case    2:  		/* li R3, 5 */
		/* 8209D064h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x5);
		/* 8209D064h case    2:*/		return 0x8209D068;
		  /* 8209D068h */ case    3:  		/* rlwinm R11, R31, 1, 0, 30 */
		/* 8209D068h case    3:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R31);
		/* 8209D068h case    3:*/		return 0x8209D06C;
		  /* 8209D06Ch */ case    4:  		/* cmpwi CR6, R3, 0 */
		/* 8209D06Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8209D06Ch case    4:*/		return 0x8209D070;
		  /* 8209D070h */ case    5:  		/* bc 4, CR6_GT, 100 */
		/* 8209D070h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8209D0D4;  }
		/* 8209D070h case    5:*/		return 0x8209D074;
		  /* 8209D074h */ case    6:  		/* addi R10, R1, 98 */
		/* 8209D074h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x62);
		/* 8209D074h case    6:*/		return 0x8209D078;
		  /* 8209D078h */ case    7:  		/* mtspr CTR, R3 */
		/* 8209D078h case    7:*/		regs.CTR = regs.R3;
		/* 8209D078h case    7:*/		return 0x8209D07C;
		  /* 8209D07Ch */ case    8:  		/* addi R5, R4, 2 */
		/* 8209D07Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x2);
		/* 8209D07Ch case    8:*/		return 0x8209D080;
		  /* 8209D080h */ case    9:  		/* subf R6, R11, R10 */
		/* 8209D080h case    9:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R11,regs.R10);
		/* 8209D080h case    9:*/		return 0x8209D084;
		  /* 8209D084h */ case   10:  		/* lhz R10, <#[R6]> */
		/* 8209D084h case   10:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000000) );
		/* 8209D084h case   10:*/		return 0x8209D088;
		  /* 8209D088h */ case   11:  		/* mr R7, R22 */
		/* 8209D088h case   11:*/		regs.R7 = regs.R22;
		/* 8209D088h case   11:*/		return 0x8209D08C;
		  /* 8209D08Ch */ case   12:  		/* lhz R9, <#[R5]> */
		/* 8209D08Ch case   12:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000000) );
		/* 8209D08Ch case   12:*/		return 0x8209D090;
		  /* 8209D090h */ case   13:  		/* lwz R11, <#[R8 + 2]> */
		/* 8209D090h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000002) );
		/* 8209D090h case   13:*/		return 0x8209D094;
		  /* 8209D094h */ case   14:  		/* mullw R9, R9, R10 */
		/* 8209D094h case   14:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 8209D094h case   14:*/		return 0x8209D098;
		  /* 8209D098h */ case   15:  		/* add R10, R11, R9 */
		/* 8209D098h case   15:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R9);
		/* 8209D098h case   15:*/		return 0x8209D09C;
		  /* 8209D09Ch */ case   16:  		/* cmplw CR6, R10, R11 */
		/* 8209D09Ch case   16:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8209D09Ch case   16:*/		return 0x8209D0A0;
		  /* 8209D0A0h */ case   17:  		/* bc 12, CR6_LT, 12 */
		/* 8209D0A0h case   17:*/		if ( regs.CR[6].lt ) { return 0x8209D0AC;  }
		/* 8209D0A0h case   17:*/		return 0x8209D0A4;
		  /* 8209D0A4h */ case   18:  		/* cmplw CR6, R10, R9 */
		/* 8209D0A4h case   18:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8209D0A4h case   18:*/		return 0x8209D0A8;
		  /* 8209D0A8h */ case   19:  		/* bc 4, CR6_LT, 8 */
		/* 8209D0A8h case   19:*/		if ( !regs.CR[6].lt ) { return 0x8209D0B0;  }
		/* 8209D0A8h case   19:*/		return 0x8209D0AC;
	}
	return 0x8209D0AC;
} // Block from 8209D05Ch-8209D0ACh (20 instructions)

//////////////////////////////////////////////////////
// Block at 8209D0ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D0AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D0AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D0AC);
		  /* 8209D0ACh */ case    0:  		/* li R7, 1 */
		/* 8209D0ACh case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8209D0ACh case    0:*/		return 0x8209D0B0;
	}
	return 0x8209D0B0;
} // Block from 8209D0ACh-8209D0B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209D0B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D0B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D0B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D0B0);
		  /* 8209D0B0h */ case    0:  		/* stw R10, <#[R8 + 2]> */
		/* 8209D0B0h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000002) );
		/* 8209D0B0h case    0:*/		return 0x8209D0B4;
		  /* 8209D0B4h */ case    1:  		/* cmpwi CR6, R7, 0 */
		/* 8209D0B4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 8209D0B4h case    1:*/		return 0x8209D0B8;
		  /* 8209D0B8h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8209D0B8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209D0C8;  }
		/* 8209D0B8h case    2:*/		return 0x8209D0BC;
		  /* 8209D0BCh */ case    3:  		/* lhz R11, <#[R8]> */
		/* 8209D0BCh case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8209D0BCh case    3:*/		return 0x8209D0C0;
		  /* 8209D0C0h */ case    4:  		/* addi R11, R11, 1 */
		/* 8209D0C0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209D0C0h case    4:*/		return 0x8209D0C4;
		  /* 8209D0C4h */ case    5:  		/* sth R11, <#[R8]> */
		/* 8209D0C4h case    5:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8209D0C4h case    5:*/		return 0x8209D0C8;
	}
	return 0x8209D0C8;
} // Block from 8209D0B0h-8209D0C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209D0C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D0C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D0C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D0C8);
		  /* 8209D0C8h */ case    0:  		/* addi R6, R6, -2 */
		/* 8209D0C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0xFFFFFFFE);
		/* 8209D0C8h case    0:*/		return 0x8209D0CC;
		  /* 8209D0CCh */ case    1:  		/* addi R5, R5, 2 */
		/* 8209D0CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x2);
		/* 8209D0CCh case    1:*/		return 0x8209D0D0;
		  /* 8209D0D0h */ case    2:  		/* bc 16, CR0_LT, -76 */
		/* 8209D0D0h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209D084;  }
		/* 8209D0D0h case    2:*/		return 0x8209D0D4;
	}
	return 0x8209D0D4;
} // Block from 8209D0C8h-8209D0D4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209D0D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D0D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D0D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D0D4);
		  /* 8209D0D4h */ case    0:  		/* addic. R3, R3, -1 */
		/* 8209D0D4h case    0:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0xFFFFFFFF);
		/* 8209D0D4h case    0:*/		return 0x8209D0D8;
		  /* 8209D0D8h */ case    1:  		/* addi R8, R8, -2 */
		/* 8209D0D8h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFE);
		/* 8209D0D8h case    1:*/		return 0x8209D0DC;
		  /* 8209D0DCh */ case    2:  		/* addi R31, R31, 1 */
		/* 8209D0DCh case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8209D0DCh case    2:*/		return 0x8209D0E0;
		  /* 8209D0E0h */ case    3:  		/* bc 12, CR0_GT, -120 */
		/* 8209D0E0h case    3:*/		if ( regs.CR[0].gt ) { return 0x8209D068;  }
		/* 8209D0E0h case    3:*/		return 0x8209D0E4;
		  /* 8209D0E4h */ case    4:  		/* rlwinm R11, R30, 0, 16, 31 */
		/* 8209D0E4h case    4:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R30);
		/* 8209D0E4h case    4:*/		return 0x8209D0E8;
		  /* 8209D0E8h */ case    5:  		/* lwz R10, <#[R1 + 112]> */
		/* 8209D0E8h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000070) );
		/* 8209D0E8h case    5:*/		return 0x8209D0EC;
		  /* 8209D0ECh */ case    6:  		/* add R11, R11, R20 */
		/* 8209D0ECh case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R20);
		/* 8209D0ECh case    6:*/		return 0x8209D0F0;
		  /* 8209D0F0h */ case    7:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209D0F0h case    7:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209D0F0h case    7:*/		return 0x8209D0F4;
		  /* 8209D0F4h */ case    8:  		/* extsh. R9, R11 */
		/* 8209D0F4h case    8:*/		cpu::op::extsh<1>(regs,&regs.R9,regs.R11);
		/* 8209D0F4h case    8:*/		return 0x8209D0F8;
		  /* 8209D0F8h */ case    9:  		/* bc 4, CR0_GT, 72 */
		/* 8209D0F8h case    9:*/		if ( !regs.CR[0].gt ) { return 0x8209D140;  }
		/* 8209D0F8h case    9:*/		return 0x8209D0FC;
		  /* 8209D0FCh */ case   10:  		/* lwz R8, <#[R1 + 104]> */
		/* 8209D0FCh case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000068) );
		/* 8209D0FCh case   10:*/		return 0x8209D100;
		  /* 8209D100h */ case   11:  		/* rlwinm. R7, R8, 0, 0, 0 */
		/* 8209D100h case   11:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R7,regs.R8);
		/* 8209D100h case   11:*/		return 0x8209D104;
		  /* 8209D104h */ case   12:  		/* bc 4, CR0_EQ, 60 */
		/* 8209D104h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8209D140;  }
		/* 8209D104h case   12:*/		return 0x8209D108;
		  /* 8209D108h */ case   13:  		/* lwz R9, <#[R1 + 108]> */
		/* 8209D108h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000006C) );
		/* 8209D108h case   13:*/		return 0x8209D10C;
		  /* 8209D10Ch */ case   14:  		/* rlwinm R7, R10, 1, 31, 31 */
		/* 8209D10Ch case   14:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R7,regs.R10);
		/* 8209D10Ch case   14:*/		return 0x8209D110;
		  /* 8209D110h */ case   15:  		/* rlwinm R8, R8, 1, 0, 30 */
		/* 8209D110h case   15:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R8,regs.R8);
		/* 8209D110h case   15:*/		return 0x8209D114;
		  /* 8209D114h */ case   16:  		/* rlwinm R6, R9, 1, 31, 31 */
		/* 8209D114h case   16:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R6,regs.R9);
		/* 8209D114h case   16:*/		return 0x8209D118;
		  /* 8209D118h */ case   17:  		/* rlwinm R5, R9, 1, 0, 30 */
		/* 8209D118h case   17:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R5,regs.R9);
		/* 8209D118h case   17:*/		return 0x8209D11C;
		  /* 8209D11Ch */ case   18:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209D11Ch case   18:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209D11Ch case   18:*/		return 0x8209D120;
		  /* 8209D120h */ case   19:  		/* rlwinm R10, R10, 1, 0, 30 */
		/* 8209D120h case   19:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R10);
		/* 8209D120h case   19:*/		return 0x8209D124;
		  /* 8209D124h */ case   20:  		/* or R7, R5, R7 */
		/* 8209D124h case   20:*/		cpu::op::or<0>(regs,&regs.R7,regs.R5,regs.R7);
		/* 8209D124h case   20:*/		return 0x8209D128;
		  /* 8209D128h */ case   21:  		/* or R8, R8, R6 */
		/* 8209D128h case   21:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R6);
		/* 8209D128h case   21:*/		return 0x8209D12C;
		  /* 8209D12Ch */ case   22:  		/* stw R10, <#[R1 + 112]> */
		/* 8209D12Ch case   22:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000070) );
		/* 8209D12Ch case   22:*/		return 0x8209D130;
		  /* 8209D130h */ case   23:  		/* add R11, R11, R21 */
		/* 8209D130h case   23:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R21);
		/* 8209D130h case   23:*/		return 0x8209D134;
		  /* 8209D134h */ case   24:  		/* stw R7, <#[R1 + 108]> */
		/* 8209D134h case   24:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x0000006C) );
		/* 8209D134h case   24:*/		return 0x8209D138;
		  /* 8209D138h */ case   25:  		/* stw R8, <#[R1 + 104]> */
		/* 8209D138h case   25:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000068) );
		/* 8209D138h case   25:*/		return 0x8209D13C;
		  /* 8209D13Ch */ case   26:  		/* b -76 */
		/* 8209D13Ch case   26:*/		return 0x8209D0F0;
		/* 8209D13Ch case   26:*/		return 0x8209D140;
	}
	return 0x8209D140;
} // Block from 8209D0D4h-8209D140h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8209D140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D140);
		  /* 8209D140h */ case    0:  		/* cmpwi CR6, R9, 0 */
		/* 8209D140h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 8209D140h case    0:*/		return 0x8209D144;
		  /* 8209D144h */ case    1:  		/* bc 12, CR6_GT, 132 */
		/* 8209D144h case    1:*/		if ( regs.CR[6].gt ) { return 0x8209D1C8;  }
		/* 8209D144h case    1:*/		return 0x8209D148;
		  /* 8209D148h */ case    2:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209D148h case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209D148h case    2:*/		return 0x8209D14C;
		  /* 8209D14Ch */ case    3:  		/* add R11, R11, R21 */
		/* 8209D14Ch case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R21);
		/* 8209D14Ch case    3:*/		return 0x8209D150;
		  /* 8209D150h */ case    4:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209D150h case    4:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209D150h case    4:*/		return 0x8209D154;
		  /* 8209D154h */ case    5:  		/* extsh. R9, R11 */
		/* 8209D154h case    5:*/		cpu::op::extsh<1>(regs,&regs.R9,regs.R11);
		/* 8209D154h case    5:*/		return 0x8209D158;
		  /* 8209D158h */ case    6:  		/* bc 4, CR0_LT, 112 */
		/* 8209D158h case    6:*/		if ( !regs.CR[0].lt ) { return 0x8209D1C8;  }
		/* 8209D158h case    6:*/		return 0x8209D15C;
		  /* 8209D15Ch */ case    7:  		/* lwz R8, <#[R1 + 104]> */
		/* 8209D15Ch case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000068) );
		/* 8209D15Ch case    7:*/		return 0x8209D160;
		  /* 8209D160h */ case    8:  		/* lwz R9, <#[R1 + 108]> */
		/* 8209D160h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000006C) );
		/* 8209D160h case    8:*/		return 0x8209D164;
		  /* 8209D164h */ case    9:  		/* lhz R7, <#[R1 + 114]> */
		/* 8209D164h case    9:*/		cpu::mem::load16z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000072) );
		/* 8209D164h case    9:*/		return 0x8209D168;
		  /* 8209D168h */ case   10:  		/* rlwinm. R7, R7, 0, 31, 31 */
		/* 8209D168h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R7,regs.R7);
		/* 8209D168h case   10:*/		return 0x8209D16C;
		  /* 8209D16Ch */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 8209D16Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x8209D174;  }
		/* 8209D16Ch case   11:*/		return 0x8209D170;
		  /* 8209D170h */ case   12:  		/* addi R29, R29, 1 */
		/* 8209D170h case   12:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8209D170h case   12:*/		return 0x8209D174;
	}
	return 0x8209D174;
} // Block from 8209D140h-8209D174h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209D174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D174);
		  /* 8209D174h */ case    0:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209D174h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209D174h case    0:*/		return 0x8209D178;
		  /* 8209D178h */ case    1:  		/* rlwinm R7, R9, 31, 0, 0 */
		/* 8209D178h case    1:*/		cpu::op::rlwinm<0,31,0,0>(regs,&regs.R7,regs.R9);
		/* 8209D178h case    1:*/		return 0x8209D17C;
		  /* 8209D17Ch */ case    2:  		/* addi R11, R11, 1 */
		/* 8209D17Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209D17Ch case    2:*/		return 0x8209D180;
		  /* 8209D180h */ case    3:  		/* rlwinm R10, R10, 31, 1, 31 */
		/* 8209D180h case    3:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R10,regs.R10);
		/* 8209D180h case    3:*/		return 0x8209D184;
		  /* 8209D184h */ case    4:  		/* rlwinm R6, R8, 31, 0, 0 */
		/* 8209D184h case    4:*/		cpu::op::rlwinm<0,31,0,0>(regs,&regs.R6,regs.R8);
		/* 8209D184h case    4:*/		return 0x8209D188;
		  /* 8209D188h */ case    5:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209D188h case    5:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209D188h case    5:*/		return 0x8209D18C;
		  /* 8209D18Ch */ case    6:  		/* rlwinm R9, R9, 31, 1, 31 */
		/* 8209D18Ch case    6:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R9,regs.R9);
		/* 8209D18Ch case    6:*/		return 0x8209D190;
		  /* 8209D190h */ case    7:  		/* or R10, R10, R7 */
		/* 8209D190h case    7:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 8209D190h case    7:*/		return 0x8209D194;
		  /* 8209D194h */ case    8:  		/* extsh. R5, R11 */
		/* 8209D194h case    8:*/		cpu::op::extsh<1>(regs,&regs.R5,regs.R11);
		/* 8209D194h case    8:*/		return 0x8209D198;
		  /* 8209D198h */ case    9:  		/* rlwinm R8, R8, 31, 1, 31 */
		/* 8209D198h case    9:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R8,regs.R8);
		/* 8209D198h case    9:*/		return 0x8209D19C;
		  /* 8209D19Ch */ case   10:  		/* stw R10, <#[R1 + 112]> */
		/* 8209D19Ch case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000070) );
		/* 8209D19Ch case   10:*/		return 0x8209D1A0;
		  /* 8209D1A0h */ case   11:  		/* or R9, R9, R6 */
		/* 8209D1A0h case   11:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R6);
		/* 8209D1A0h case   11:*/		return 0x8209D1A4;
		  /* 8209D1A4h */ case   12:  		/* bc 12, CR0_LT, -64 */
		/* 8209D1A4h case   12:*/		if ( regs.CR[0].lt ) { return 0x8209D164;  }
		/* 8209D1A4h case   12:*/		return 0x8209D1A8;
		  /* 8209D1A8h */ case   13:  		/* stw R9, <#[R1 + 108]> */
		/* 8209D1A8h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000006C) );
		/* 8209D1A8h case   13:*/		return 0x8209D1AC;
		  /* 8209D1ACh */ case   14:  		/* cmpwi CR6, R29, 0 */
		/* 8209D1ACh case   14:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 8209D1ACh case   14:*/		return 0x8209D1B0;
		  /* 8209D1B0h */ case   15:  		/* stw R8, <#[R1 + 104]> */
		/* 8209D1B0h case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000068) );
		/* 8209D1B0h case   15:*/		return 0x8209D1B4;
		  /* 8209D1B4h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 8209D1B4h case   16:*/		if ( regs.CR[6].eq ) { return 0x8209D1C8;  }
		/* 8209D1B4h case   16:*/		return 0x8209D1B8;
		  /* 8209D1B8h */ case   17:  		/* lhz R10, <#[R1 + 114]> */
		/* 8209D1B8h case   17:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000072) );
		/* 8209D1B8h case   17:*/		return 0x8209D1BC;
		  /* 8209D1BCh */ case   18:  		/* ori R10, R10, 1 */
		/* 8209D1BCh case   18:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8209D1BCh case   18:*/		return 0x8209D1C0;
		  /* 8209D1C0h */ case   19:  		/* sth R10, <#[R1 + 114]> */
		/* 8209D1C0h case   19:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R1 + 0x00000072) );
		/* 8209D1C0h case   19:*/		return 0x8209D1C4;
		  /* 8209D1C4h */ case   20:  		/* lwz R10, <#[R1 + 112]> */
		/* 8209D1C4h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000070) );
		/* 8209D1C4h case   20:*/		return 0x8209D1C8;
	}
	return 0x8209D1C8;
} // Block from 8209D174h-8209D1C8h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8209D1C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D1C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D1C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D1C8);
		  /* 8209D1C8h */ case    0:  		/* lhz R9, <#[R1 + 114]> */
		/* 8209D1C8h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000072) );
		/* 8209D1C8h case    0:*/		return 0x8209D1CC;
		  /* 8209D1CCh */ case    1:  		/* cmplwi CR6, R9, 32768 */
		/* 8209D1CCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00008000);
		/* 8209D1CCh case    1:*/		return 0x8209D1D0;
		  /* 8209D1D0h */ case    2:  		/* bc 12, CR6_GT, 16 */
		/* 8209D1D0h case    2:*/		if ( regs.CR[6].gt ) { return 0x8209D1E0;  }
		/* 8209D1D0h case    2:*/		return 0x8209D1D4;
		  /* 8209D1D4h */ case    3:  		/* rlwinm R10, R10, 0, 15, 31 */
		/* 8209D1D4h case    3:*/		cpu::op::rlwinm<0,0,15,31>(regs,&regs.R10,regs.R10);
		/* 8209D1D4h case    3:*/		return 0x8209D1D8;
		  /* 8209D1D8h */ case    4:  		/* cmplw CR6, R10, R17 */
		/* 8209D1D8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R17);
		/* 8209D1D8h case    4:*/		return 0x8209D1DC;
		  /* 8209D1DCh */ case    5:  		/* bc 4, CR6_EQ, 100 */
		/* 8209D1DCh case    5:*/		if ( !regs.CR[6].eq ) { return 0x8209D240;  }
		/* 8209D1DCh case    5:*/		return 0x8209D1E0;
	}
	return 0x8209D1E0;
} // Block from 8209D1C8h-8209D1E0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209D1E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D1E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D1E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D1E0);
		  /* 8209D1E0h */ case    0:  		/* lwz R10, <#[R1 + 110]> */
		/* 8209D1E0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000006E) );
		/* 8209D1E0h case    0:*/		return 0x8209D1E4;
		  /* 8209D1E4h */ case    1:  		/* cmpwi CR6, R10, -1 */
		/* 8209D1E4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8209D1E4h case    1:*/		return 0x8209D1E8;
		  /* 8209D1E8h */ case    2:  		/* bc 4, CR6_EQ, 80 */
		/* 8209D1E8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8209D238;  }
		/* 8209D1E8h case    2:*/		return 0x8209D1EC;
		  /* 8209D1ECh */ case    3:  		/* lwz R10, <#[R1 + 106]> */
		/* 8209D1ECh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000006A) );
		/* 8209D1ECh case    3:*/		return 0x8209D1F0;
		  /* 8209D1F0h */ case    4:  		/* stw R22, <#[R1 + 110]> */
		/* 8209D1F0h case    4:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x0000006E) );
		/* 8209D1F0h case    4:*/		return 0x8209D1F4;
		  /* 8209D1F4h */ case    5:  		/* cmpwi CR6, R10, -1 */
		/* 8209D1F4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8209D1F4h case    5:*/		return 0x8209D1F8;
		  /* 8209D1F8h */ case    6:  		/* bc 4, CR6_EQ, 52 */
		/* 8209D1F8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8209D22C;  }
		/* 8209D1F8h case    6:*/		return 0x8209D1FC;
		  /* 8209D1FCh */ case    7:  		/* lhz R10, <#[R1 + 104]> */
		/* 8209D1FCh case    7:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000068) );
		/* 8209D1FCh case    7:*/		return 0x8209D200;
		  /* 8209D200h */ case    8:  		/* stw R22, <#[R1 + 106]> */
		/* 8209D200h case    8:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x0000006A) );
		/* 8209D200h case    8:*/		return 0x8209D204;
		  /* 8209D204h */ case    9:  		/* cmplwi CR6, R10, 65535 */
		/* 8209D204h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000FFFF);
		/* 8209D204h case    9:*/		return 0x8209D208;
		  /* 8209D208h */ case   10:  		/* bc 4, CR6_EQ, 24 */
		/* 8209D208h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8209D220;  }
		/* 8209D208h case   10:*/		return 0x8209D20C;
		  /* 8209D20Ch */ case   11:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209D20Ch case   11:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209D20Ch case   11:*/		return 0x8209D210;
		  /* 8209D210h */ case   12:  		/* sth R18, <#[R1 + 104]> */
		/* 8209D210h case   12:*/		cpu::mem::store16( regs, regs.R18, (uint32)(regs.R1 + 0x00000068) );
		/* 8209D210h case   12:*/		return 0x8209D214;
		  /* 8209D214h */ case   13:  		/* addi R11, R11, 1 */
		/* 8209D214h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209D214h case   13:*/		return 0x8209D218;
		  /* 8209D218h */ case   14:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209D218h case   14:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209D218h case   14:*/		return 0x8209D21C;
		  /* 8209D21Ch */ case   15:  		/* b 36 */
		/* 8209D21Ch case   15:*/		return 0x8209D240;
		/* 8209D21Ch case   15:*/		return 0x8209D220;
	}
	return 0x8209D220;
} // Block from 8209D1E0h-8209D220h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8209D220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D220);
		  /* 8209D220h */ case    0:  		/* addi R10, R10, 1 */
		/* 8209D220h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8209D220h case    0:*/		return 0x8209D224;
		  /* 8209D224h */ case    1:  		/* sth R10, <#[R1 + 104]> */
		/* 8209D224h case    1:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R1 + 0x00000068) );
		/* 8209D224h case    1:*/		return 0x8209D228;
		  /* 8209D228h */ case    2:  		/* b 24 */
		/* 8209D228h case    2:*/		return 0x8209D240;
		/* 8209D228h case    2:*/		return 0x8209D22C;
	}
	return 0x8209D22C;
} // Block from 8209D220h-8209D22Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209D22Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D22C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D22C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D22C);
		  /* 8209D22Ch */ case    0:  		/* addi R10, R10, 1 */
		/* 8209D22Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8209D22Ch case    0:*/		return 0x8209D230;
		  /* 8209D230h */ case    1:  		/* stw R10, <#[R1 + 106]> */
		/* 8209D230h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000006A) );
		/* 8209D230h case    1:*/		return 0x8209D234;
		  /* 8209D234h */ case    2:  		/* b 12 */
		/* 8209D234h case    2:*/		return 0x8209D240;
		/* 8209D234h case    2:*/		return 0x8209D238;
	}
	return 0x8209D238;
} // Block from 8209D22Ch-8209D238h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209D238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D238);
		  /* 8209D238h */ case    0:  		/* addi R10, R10, 1 */
		/* 8209D238h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8209D238h case    0:*/		return 0x8209D23C;
		  /* 8209D23Ch */ case    1:  		/* stw R10, <#[R1 + 110]> */
		/* 8209D23Ch case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000006E) );
		/* 8209D23Ch case    1:*/		return 0x8209D240;
	}
	return 0x8209D240;
} // Block from 8209D238h-8209D240h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209D240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D240);
		  /* 8209D240h */ case    0:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209D240h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209D240h case    0:*/		return 0x8209D244;
		  /* 8209D244h */ case    1:  		/* cmplwi CR6, R11, 32767 */
		/* 8209D244h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00007FFF);
		/* 8209D244h case    1:*/		return 0x8209D248;
		  /* 8209D248h */ case    2:  		/* bc 4, CR6_LT, 56 */
		/* 8209D248h case    2:*/		if ( !regs.CR[6].lt ) { return 0x8209D280;  }
		/* 8209D248h case    2:*/		return 0x8209D24C;
		  /* 8209D24Ch */ case    3:  		/* rlwinm R10, R26, 0, 16, 31 */
		/* 8209D24Ch case    3:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R26);
		/* 8209D24Ch case    3:*/		return 0x8209D250;
		  /* 8209D250h */ case    4:  		/* lhz R9, <#[R1 + 112]> */
		/* 8209D250h case    4:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000070) );
		/* 8209D250h case    4:*/		return 0x8209D254;
		  /* 8209D254h */ case    5:  		/* lwz R8, <#[R1 + 108]> */
		/* 8209D254h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x0000006C) );
		/* 8209D254h case    5:*/		return 0x8209D258;
		  /* 8209D258h */ case    6:  		/* lwz R7, <#[R1 + 104]> */
		/* 8209D258h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000068) );
		/* 8209D258h case    6:*/		return 0x8209D25C;
		  /* 8209D25Ch */ case    7:  		/* or R11, R10, R11 */
		/* 8209D25Ch case    7:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8209D25Ch case    7:*/		return 0x8209D260;
		  /* 8209D260h */ case    8:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209D260h case    8:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209D260h case    8:*/		return 0x8209D264;
		  /* 8209D264h */ case    9:  		/* sth R9, <#[R1 + 98]> */
		/* 8209D264h case    9:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R1 + 0x00000062) );
		/* 8209D264h case    9:*/		return 0x8209D268;
		  /* 8209D268h */ case   10:  		/* stw R8, <#[R1 + 94]> */
		/* 8209D268h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x0000005E) );
		/* 8209D268h case   10:*/		return 0x8209D26C;
		  /* 8209D26Ch */ case   11:  		/* stw R7, <#[R1 + 90]> */
		/* 8209D26Ch case   11:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x0000005A) );
		/* 8209D26Ch case   11:*/		return 0x8209D270;
		  /* 8209D270h */ case   12:  		/* lwz R28, <#[R1 + 92]> */
		/* 8209D270h case   12:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x0000005C) );
		/* 8209D270h case   12:*/		return 0x8209D274;
		  /* 8209D274h */ case   13:  		/* lwz R27, <#[R1 + 96]> */
		/* 8209D274h case   13:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000060) );
		/* 8209D274h case   13:*/		return 0x8209D278;
		  /* 8209D278h */ case   14:  		/* sth R11, <#[R1 + 88]> */
		/* 8209D278h case   14:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8209D278h case   14:*/		return 0x8209D27C;
		  /* 8209D27Ch */ case   15:  		/* b 36 */
		/* 8209D27Ch case   15:*/		return 0x8209D2A0;
		/* 8209D27Ch case   15:*/		return 0x8209D280;
	}
	return 0x8209D280;
} // Block from 8209D240h-8209D280h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8209D280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D280);
		  /* 8209D280h */ case    0:  		/* stw R15, <#[R1 + 88]> */
		/* 8209D280h case    0:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x00000058) );
		/* 8209D280h case    0:*/		return 0x8209D284;
		  /* 8209D284h */ case    1:  		/* rlwinm. R11, R26, 0, 16, 31 */
		/* 8209D284h case    1:*/		cpu::op::rlwinm<1,0,16,31>(regs,&regs.R11,regs.R26);
		/* 8209D284h case    1:*/		return 0x8209D288;
		  /* 8209D288h */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 8209D288h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8209D290;  }
		/* 8209D288h case    2:*/		return 0x8209D28C;
		  /* 8209D28Ch */ case    3:  		/* stw R16, <#[R1 + 88]> */
		/* 8209D28Ch case    3:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R1 + 0x00000058) );
		/* 8209D28Ch case    3:*/		return 0x8209D290;
	}
	return 0x8209D290;
} // Block from 8209D280h-8209D290h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209D290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D290);
		  /* 8209D290h */ case    0:  		/* mr R28, R22 */
		/* 8209D290h case    0:*/		regs.R28 = regs.R22;
		/* 8209D290h case    0:*/		return 0x8209D294;
		  /* 8209D294h */ case    1:  		/* stw R22, <#[R1 + 96]> */
		/* 8209D294h case    1:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000060) );
		/* 8209D294h case    1:*/		return 0x8209D298;
		  /* 8209D298h */ case    2:  		/* mr R27, R22 */
		/* 8209D298h case    2:*/		regs.R27 = regs.R22;
		/* 8209D298h case    2:*/		return 0x8209D29C;
		  /* 8209D29Ch */ case    3:  		/* stw R22, <#[R1 + 92]> */
		/* 8209D29Ch case    3:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x0000005C) );
		/* 8209D29Ch case    3:*/		return 0x8209D2A0;
	}
	return 0x8209D2A0;
} // Block from 8209D290h-8209D2A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209D2A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D2A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D2A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D2A0);
		  /* 8209D2A0h */ case    0:  		/* lhz R31, <#[R1 + 88]> */
		/* 8209D2A0h case    0:*/		cpu::mem::load16z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000058) );
		/* 8209D2A0h case    0:*/		return 0x8209D2A4;
		  /* 8209D2A4h */ case    1:  		/* cmpwi CR6, R25, 0 */
		/* 8209D2A4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 8209D2A4h case    1:*/		return 0x8209D2A8;
		  /* 8209D2A8h */ case    2:  		/* bc 4, CR6_EQ, -856 */
		/* 8209D2A8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8209CF50;  }
		/* 8209D2A8h case    2:*/		return 0x8209D2AC;
		  /* 8209D2ACh */ case    3:  		/* b 12 */
		/* 8209D2ACh case    3:*/		return 0x8209D2B8;
		/* 8209D2ACh case    3:*/		return 0x8209D2B0;
	}
	return 0x8209D2B0;
} // Block from 8209D2A0h-8209D2B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209D2B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D2B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D2B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D2B0);
		  /* 8209D2B0h */ case    0:  		/* lwz R27, <#[R1 + 96]> */
		/* 8209D2B0h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000060) );
		/* 8209D2B0h case    0:*/		return 0x8209D2B4;
		  /* 8209D2B4h */ case    1:  		/* lwz R28, <#[R1 + 92]> */
		/* 8209D2B4h case    1:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x0000005C) );
		/* 8209D2B4h case    1:*/		return 0x8209D2B8;
	}
	return 0x8209D2B8;
} // Block from 8209D2B0h-8209D2B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209D2B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D2B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D2B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D2B8);
		  /* 8209D2B8h */ case    0:  		/* rlwinm R9, R31, 0, 16, 31 */
		/* 8209D2B8h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R31);
		/* 8209D2B8h case    0:*/		return 0x8209D2BC;
		  /* 8209D2BCh */ case    1:  		/* cmplwi CR6, R9, 16383 */
		/* 8209D2BCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00003FFF);
		/* 8209D2BCh case    1:*/		return 0x8209D2C0;
		  /* 8209D2C0h */ case    2:  		/* bc 12, CR6_LT, 776 */
		/* 8209D2C0h case    2:*/		if ( regs.CR[6].lt ) { return 0x8209D5C8;  }
		/* 8209D2C0h case    2:*/		return 0x8209D2C4;
		  /* 8209D2C4h */ case    3:  		/* lhz R8, <#[R1 + 136]> */
		/* 8209D2C4h case    3:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000088) );
		/* 8209D2C4h case    3:*/		return 0x8209D2C8;
		  /* 8209D2C8h */ case    4:  		/* rlwinm R11, R9, 0, 17, 31 */
		/* 8209D2C8h case    4:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R11,regs.R9);
		/* 8209D2C8h case    4:*/		return 0x8209D2CC;
		  /* 8209D2CCh */ case    5:  		/* addi R7, R24, 1 */
		/* 8209D2CCh case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R24,0x1);
		/* 8209D2CCh case    5:*/		return 0x8209D2D0;
		  /* 8209D2D0h */ case    6:  		/* stw R22, <#[R1 + 128]> */
		/* 8209D2D0h case    6:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000080) );
		/* 8209D2D0h case    6:*/		return 0x8209D2D4;
		  /* 8209D2D4h */ case    7:  		/* rlwinm R10, R8, 0, 17, 31 */
		/* 8209D2D4h case    7:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R10,regs.R8);
		/* 8209D2D4h case    7:*/		return 0x8209D2D8;
		  /* 8209D2D8h */ case    8:  		/* stw R22, <#[R1 + 124]> */
		/* 8209D2D8h case    8:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x0000007C) );
		/* 8209D2D8h case    8:*/		return 0x8209D2DC;
		  /* 8209D2DCh */ case    9:  		/* xor R9, R8, R9 */
		/* 8209D2DCh case    9:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8209D2DCh case    9:*/		return 0x8209D2E0;
		  /* 8209D2E0h */ case   10:  		/* stw R22, <#[R1 + 120]> */
		/* 8209D2E0h case   10:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000078) );
		/* 8209D2E0h case   10:*/		return 0x8209D2E4;
		  /* 8209D2E4h */ case   11:  		/* add R6, R11, R10 */
		/* 8209D2E4h case   11:*/		cpu::op::add<0>(regs,&regs.R6,regs.R11,regs.R10);
		/* 8209D2E4h case   11:*/		return 0x8209D2E8;
		  /* 8209D2E8h */ case   12:  		/* extsh R19, R7 */
		/* 8209D2E8h case   12:*/		cpu::op::extsh<0>(regs,&regs.R19,regs.R7);
		/* 8209D2E8h case   12:*/		return 0x8209D2EC;
		  /* 8209D2ECh */ case   13:  		/* mr R30, R22 */
		/* 8209D2ECh case   13:*/		regs.R30 = regs.R22;
		/* 8209D2ECh case   13:*/		return 0x8209D2F0;
		  /* 8209D2F0h */ case   14:  		/* rlwinm R29, R9, 0, 16, 16 */
		/* 8209D2F0h case   14:*/		cpu::op::rlwinm<0,0,16,16>(regs,&regs.R29,regs.R9);
		/* 8209D2F0h case   14:*/		return 0x8209D2F4;
		  /* 8209D2F4h */ case   15:  		/* rlwinm R31, R6, 0, 16, 31 */
		/* 8209D2F4h case   15:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R31,regs.R6);
		/* 8209D2F4h case   15:*/		return 0x8209D2F8;
		  /* 8209D2F8h */ case   16:  		/* cmplwi CR6, R11, 32767 */
		/* 8209D2F8h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00007FFF);
		/* 8209D2F8h case   16:*/		return 0x8209D2FC;
		  /* 8209D2FCh */ case   17:  		/* bc 4, CR6_LT, 692 */
		/* 8209D2FCh case   17:*/		if ( !regs.CR[6].lt ) { return 0x8209D5B0;  }
		/* 8209D2FCh case   17:*/		return 0x8209D300;
		  /* 8209D300h */ case   18:  		/* cmplwi CR6, R10, 32767 */
		/* 8209D300h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00007FFF);
		/* 8209D300h case   18:*/		return 0x8209D304;
		  /* 8209D304h */ case   19:  		/* bc 4, CR6_LT, 684 */
		/* 8209D304h case   19:*/		if ( !regs.CR[6].lt ) { return 0x8209D5B0;  }
		/* 8209D304h case   19:*/		return 0x8209D308;
		  /* 8209D308h */ case   20:  		/* rlwinm R9, R31, 0, 16, 31 */
		/* 8209D308h case   20:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R31);
		/* 8209D308h case   20:*/		return 0x8209D30C;
		  /* 8209D30Ch */ case   21:  		/* cmplwi CR6, R9, 49149 */
		/* 8209D30Ch case   21:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000BFFD);
		/* 8209D30Ch case   21:*/		return 0x8209D310;
		  /* 8209D310h */ case   22:  		/* bc 12, CR6_GT, 672 */
		/* 8209D310h case   22:*/		if ( regs.CR[6].gt ) { return 0x8209D5B0;  }
		/* 8209D310h case   22:*/		return 0x8209D314;
		  /* 8209D314h */ case   23:  		/* cmplwi CR6, R9, 16319 */
		/* 8209D314h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00003FBF);
		/* 8209D314h case   23:*/		return 0x8209D318;
		  /* 8209D318h */ case   24:  		/* bc 12, CR6_GT, 12 */
		/* 8209D318h case   24:*/		if ( regs.CR[6].gt ) { return 0x8209D324;  }
		/* 8209D318h case   24:*/		return 0x8209D31C;
		  /* 8209D31Ch */ case   25:  		/* stw R22, <#[R1 + 88]> */
		/* 8209D31Ch case   25:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000058) );
		/* 8209D31Ch case   25:*/		return 0x8209D320;
		  /* 8209D320h */ case   26:  		/* b 672 */
		/* 8209D320h case   26:*/		return 0x8209D5C0;
		/* 8209D320h case   26:*/		return 0x8209D324;
	}
	return 0x8209D324;
} // Block from 8209D2B8h-8209D324h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8209D324h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D324( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D324) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D324);
		  /* 8209D324h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8209D324h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209D324h case    0:*/		return 0x8209D328;
		  /* 8209D328h */ case    1:  		/* bc 4, CR6_EQ, 48 */
		/* 8209D328h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209D358;  }
		/* 8209D328h case    1:*/		return 0x8209D32C;
		  /* 8209D32Ch */ case    2:  		/* lwz R11, <#[R1 + 88]> */
		/* 8209D32Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8209D32Ch case    2:*/		return 0x8209D330;
		  /* 8209D330h */ case    3:  		/* addi R9, R9, 1 */
		/* 8209D330h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8209D330h case    3:*/		return 0x8209D334;
		  /* 8209D334h */ case    4:  		/* rlwinm. R11, R11, 0, 1, 31 */
		/* 8209D334h case    4:*/		cpu::op::rlwinm<1,0,1,31>(regs,&regs.R11,regs.R11);
		/* 8209D334h case    4:*/		return 0x8209D338;
		  /* 8209D338h */ case    5:  		/* rlwinm R31, R9, 0, 16, 31 */
		/* 8209D338h case    5:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R31,regs.R9);
		/* 8209D338h case    5:*/		return 0x8209D33C;
		  /* 8209D33Ch */ case    6:  		/* bc 4, CR0_EQ, 28 */
		/* 8209D33Ch case    6:*/		if ( !regs.CR[0].eq ) { return 0x8209D358;  }
		/* 8209D33Ch case    6:*/		return 0x8209D340;
		  /* 8209D340h */ case    7:  		/* cmplwi CR6, R28, 0 */
		/* 8209D340h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8209D340h case    7:*/		return 0x8209D344;
		  /* 8209D344h */ case    8:  		/* bc 4, CR6_EQ, 20 */
		/* 8209D344h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8209D358;  }
		/* 8209D344h case    8:*/		return 0x8209D348;
		  /* 8209D348h */ case    9:  		/* cmplwi CR6, R27, 0 */
		/* 8209D348h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8209D348h case    9:*/		return 0x8209D34C;
		  /* 8209D34Ch */ case   10:  		/* bc 4, CR6_EQ, 12 */
		/* 8209D34Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x8209D358;  }
		/* 8209D34Ch case   10:*/		return 0x8209D350;
		  /* 8209D350h */ case   11:  		/* sth R22, <#[R1 + 88]> */
		/* 8209D350h case   11:*/		cpu::mem::store16( regs, regs.R22, (uint32)(regs.R1 + 0x00000058) );
		/* 8209D350h case   11:*/		return 0x8209D354;
		  /* 8209D354h */ case   12:  		/* b 628 */
		/* 8209D354h case   12:*/		return 0x8209D5C8;
		/* 8209D354h case   12:*/		return 0x8209D358;
	}
	return 0x8209D358;
} // Block from 8209D324h-8209D358h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209D358h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D358);
		  /* 8209D358h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 8209D358h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8209D358h case    0:*/		return 0x8209D35C;
		  /* 8209D35Ch */ case    1:  		/* bc 4, CR6_EQ, 52 */
		/* 8209D35Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209D390;  }
		/* 8209D35Ch case    1:*/		return 0x8209D360;
		  /* 8209D360h */ case    2:  		/* rlwinm R11, R31, 0, 16, 31 */
		/* 8209D360h case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R31);
		/* 8209D360h case    2:*/		return 0x8209D364;
		  /* 8209D364h */ case    3:  		/* lwz R10, <#[R1 + 136]> */
		/* 8209D364h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000088) );
		/* 8209D364h case    3:*/		return 0x8209D368;
		  /* 8209D368h */ case    4:  		/* addi R11, R11, 1 */
		/* 8209D368h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209D368h case    4:*/		return 0x8209D36C;
		  /* 8209D36Ch */ case    5:  		/* rlwinm. R10, R10, 0, 1, 31 */
		/* 8209D36Ch case    5:*/		cpu::op::rlwinm<1,0,1,31>(regs,&regs.R10,regs.R10);
		/* 8209D36Ch case    5:*/		return 0x8209D370;
		  /* 8209D370h */ case    6:  		/* rlwinm R31, R11, 0, 16, 31 */
		/* 8209D370h case    6:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R31,regs.R11);
		/* 8209D370h case    6:*/		return 0x8209D374;
		  /* 8209D374h */ case    7:  		/* bc 4, CR0_EQ, 28 */
		/* 8209D374h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8209D390;  }
		/* 8209D374h case    7:*/		return 0x8209D378;
		  /* 8209D378h */ case    8:  		/* lwz R11, <#[R1 + 140]> */
		/* 8209D378h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 8209D378h case    8:*/		return 0x8209D37C;
		  /* 8209D37Ch */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 8209D37Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209D37Ch case    9:*/		return 0x8209D380;
		  /* 8209D380h */ case   10:  		/* bc 4, CR6_EQ, 16 */
		/* 8209D380h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8209D390;  }
		/* 8209D380h case   10:*/		return 0x8209D384;
		  /* 8209D384h */ case   11:  		/* lwz R11, <#[R1 + 144]> */
		/* 8209D384h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 8209D384h case   11:*/		return 0x8209D388;
		  /* 8209D388h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 8209D388h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209D388h case   12:*/		return 0x8209D38C;
		  /* 8209D38Ch */ case   13:  		/* bc 12, CR6_EQ, -112 */
		/* 8209D38Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x8209D31C;  }
		/* 8209D38Ch case   13:*/		return 0x8209D390;
	}
	return 0x8209D390;
} // Block from 8209D358h-8209D390h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209D390h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D390);
		  /* 8209D390h */ case    0:  		/* mr R3, R22 */
		/* 8209D390h case    0:*/		regs.R3 = regs.R22;
		/* 8209D390h case    0:*/		return 0x8209D394;
		  /* 8209D394h */ case    1:  		/* addi R8, R1, 126 */
		/* 8209D394h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x7E);
		/* 8209D394h case    1:*/		return 0x8209D398;
		  /* 8209D398h */ case    2:  		/* li R4, 5 */
		/* 8209D398h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x5);
		/* 8209D398h case    2:*/		return 0x8209D39C;
		  /* 8209D39Ch */ case    3:  		/* rlwinm R11, R3, 1, 0, 30 */
		/* 8209D39Ch case    3:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R3);
		/* 8209D39Ch case    3:*/		return 0x8209D3A0;
		  /* 8209D3A0h */ case    4:  		/* cmpwi CR6, R4, 0 */
		/* 8209D3A0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 8209D3A0h case    4:*/		return 0x8209D3A4;
		  /* 8209D3A4h */ case    5:  		/* bc 4, CR6_GT, 100 */
		/* 8209D3A4h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8209D408;  }
		/* 8209D3A4h case    5:*/		return 0x8209D3A8;
		  /* 8209D3A8h */ case    6:  		/* addi R10, R1, 98 */
		/* 8209D3A8h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x62);
		/* 8209D3A8h case    6:*/		return 0x8209D3AC;
		  /* 8209D3ACh */ case    7:  		/* mtspr CTR, R4 */
		/* 8209D3ACh case    7:*/		regs.CTR = regs.R4;
		/* 8209D3ACh case    7:*/		return 0x8209D3B0;
		  /* 8209D3B0h */ case    8:  		/* addi R5, R1, 138 */
		/* 8209D3B0h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x8A);
		/* 8209D3B0h case    8:*/		return 0x8209D3B4;
		  /* 8209D3B4h */ case    9:  		/* subf R6, R11, R10 */
		/* 8209D3B4h case    9:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R11,regs.R10);
		/* 8209D3B4h case    9:*/		return 0x8209D3B8;
		  /* 8209D3B8h */ case   10:  		/* lhz R10, <#[R5]> */
		/* 8209D3B8h case   10:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 8209D3B8h case   10:*/		return 0x8209D3BC;
		  /* 8209D3BCh */ case   11:  		/* mr R7, R22 */
		/* 8209D3BCh case   11:*/		regs.R7 = regs.R22;
		/* 8209D3BCh case   11:*/		return 0x8209D3C0;
		  /* 8209D3C0h */ case   12:  		/* lhz R9, <#[R6]> */
		/* 8209D3C0h case   12:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000000) );
		/* 8209D3C0h case   12:*/		return 0x8209D3C4;
		  /* 8209D3C4h */ case   13:  		/* lwz R11, <#[R8 + 2]> */
		/* 8209D3C4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000002) );
		/* 8209D3C4h case   13:*/		return 0x8209D3C8;
		  /* 8209D3C8h */ case   14:  		/* mullw R9, R9, R10 */
		/* 8209D3C8h case   14:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 8209D3C8h case   14:*/		return 0x8209D3CC;
		  /* 8209D3CCh */ case   15:  		/* add R10, R11, R9 */
		/* 8209D3CCh case   15:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R9);
		/* 8209D3CCh case   15:*/		return 0x8209D3D0;
		  /* 8209D3D0h */ case   16:  		/* cmplw CR6, R10, R11 */
		/* 8209D3D0h case   16:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8209D3D0h case   16:*/		return 0x8209D3D4;
		  /* 8209D3D4h */ case   17:  		/* bc 12, CR6_LT, 12 */
		/* 8209D3D4h case   17:*/		if ( regs.CR[6].lt ) { return 0x8209D3E0;  }
		/* 8209D3D4h case   17:*/		return 0x8209D3D8;
		  /* 8209D3D8h */ case   18:  		/* cmplw CR6, R10, R9 */
		/* 8209D3D8h case   18:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8209D3D8h case   18:*/		return 0x8209D3DC;
		  /* 8209D3DCh */ case   19:  		/* bc 4, CR6_LT, 8 */
		/* 8209D3DCh case   19:*/		if ( !regs.CR[6].lt ) { return 0x8209D3E4;  }
		/* 8209D3DCh case   19:*/		return 0x8209D3E0;
	}
	return 0x8209D3E0;
} // Block from 8209D390h-8209D3E0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8209D3E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D3E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D3E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D3E0);
		  /* 8209D3E0h */ case    0:  		/* li R7, 1 */
		/* 8209D3E0h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8209D3E0h case    0:*/		return 0x8209D3E4;
	}
	return 0x8209D3E4;
} // Block from 8209D3E0h-8209D3E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209D3E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D3E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D3E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D3E4);
		  /* 8209D3E4h */ case    0:  		/* stw R10, <#[R8 + 2]> */
		/* 8209D3E4h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000002) );
		/* 8209D3E4h case    0:*/		return 0x8209D3E8;
		  /* 8209D3E8h */ case    1:  		/* cmpwi CR6, R7, 0 */
		/* 8209D3E8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 8209D3E8h case    1:*/		return 0x8209D3EC;
		  /* 8209D3ECh */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8209D3ECh case    2:*/		if ( regs.CR[6].eq ) { return 0x8209D3FC;  }
		/* 8209D3ECh case    2:*/		return 0x8209D3F0;
		  /* 8209D3F0h */ case    3:  		/* lhz R11, <#[R8]> */
		/* 8209D3F0h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8209D3F0h case    3:*/		return 0x8209D3F4;
		  /* 8209D3F4h */ case    4:  		/* addi R11, R11, 1 */
		/* 8209D3F4h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209D3F4h case    4:*/		return 0x8209D3F8;
		  /* 8209D3F8h */ case    5:  		/* sth R11, <#[R8]> */
		/* 8209D3F8h case    5:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8209D3F8h case    5:*/		return 0x8209D3FC;
	}
	return 0x8209D3FC;
} // Block from 8209D3E4h-8209D3FCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209D3FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D3FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D3FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D3FC);
		  /* 8209D3FCh */ case    0:  		/* addi R6, R6, -2 */
		/* 8209D3FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0xFFFFFFFE);
		/* 8209D3FCh case    0:*/		return 0x8209D400;
		  /* 8209D400h */ case    1:  		/* addi R5, R5, 2 */
		/* 8209D400h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x2);
		/* 8209D400h case    1:*/		return 0x8209D404;
		  /* 8209D404h */ case    2:  		/* bc 16, CR0_LT, -76 */
		/* 8209D404h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209D3B8;  }
		/* 8209D404h case    2:*/		return 0x8209D408;
	}
	return 0x8209D408;
} // Block from 8209D3FCh-8209D408h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209D408h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D408);
		  /* 8209D408h */ case    0:  		/* addic. R4, R4, -1 */
		/* 8209D408h case    0:*/		cpu::op::addic<1>(regs,&regs.R4,regs.R4,0xFFFFFFFF);
		/* 8209D408h case    0:*/		return 0x8209D40C;
		  /* 8209D40Ch */ case    1:  		/* addi R8, R8, -2 */
		/* 8209D40Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFE);
		/* 8209D40Ch case    1:*/		return 0x8209D410;
		  /* 8209D410h */ case    2:  		/* addi R3, R3, 1 */
		/* 8209D410h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 8209D410h case    2:*/		return 0x8209D414;
		  /* 8209D414h */ case    3:  		/* bc 12, CR0_GT, -120 */
		/* 8209D414h case    3:*/		if ( regs.CR[0].gt ) { return 0x8209D39C;  }
		/* 8209D414h case    3:*/		return 0x8209D418;
		  /* 8209D418h */ case    4:  		/* rlwinm R11, R31, 0, 16, 31 */
		/* 8209D418h case    4:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R31);
		/* 8209D418h case    4:*/		return 0x8209D41C;
		  /* 8209D41Ch */ case    5:  		/* lwz R10, <#[R1 + 128]> */
		/* 8209D41Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000080) );
		/* 8209D41Ch case    5:*/		return 0x8209D420;
		  /* 8209D420h */ case    6:  		/* add R11, R11, R20 */
		/* 8209D420h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R20);
		/* 8209D420h case    6:*/		return 0x8209D424;
		  /* 8209D424h */ case    7:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209D424h case    7:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209D424h case    7:*/		return 0x8209D428;
		  /* 8209D428h */ case    8:  		/* extsh. R9, R11 */
		/* 8209D428h case    8:*/		cpu::op::extsh<1>(regs,&regs.R9,regs.R11);
		/* 8209D428h case    8:*/		return 0x8209D42C;
		  /* 8209D42Ch */ case    9:  		/* bc 4, CR0_GT, 72 */
		/* 8209D42Ch case    9:*/		if ( !regs.CR[0].gt ) { return 0x8209D474;  }
		/* 8209D42Ch case    9:*/		return 0x8209D430;
		  /* 8209D430h */ case   10:  		/* lwz R8, <#[R1 + 120]> */
		/* 8209D430h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000078) );
		/* 8209D430h case   10:*/		return 0x8209D434;
		  /* 8209D434h */ case   11:  		/* rlwinm. R7, R8, 0, 0, 0 */
		/* 8209D434h case   11:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R7,regs.R8);
		/* 8209D434h case   11:*/		return 0x8209D438;
		  /* 8209D438h */ case   12:  		/* bc 4, CR0_EQ, 60 */
		/* 8209D438h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8209D474;  }
		/* 8209D438h case   12:*/		return 0x8209D43C;
		  /* 8209D43Ch */ case   13:  		/* lwz R9, <#[R1 + 124]> */
		/* 8209D43Ch case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000007C) );
		/* 8209D43Ch case   13:*/		return 0x8209D440;
		  /* 8209D440h */ case   14:  		/* rlwinm R7, R10, 1, 31, 31 */
		/* 8209D440h case   14:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R7,regs.R10);
		/* 8209D440h case   14:*/		return 0x8209D444;
		  /* 8209D444h */ case   15:  		/* rlwinm R8, R8, 1, 0, 30 */
		/* 8209D444h case   15:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R8,regs.R8);
		/* 8209D444h case   15:*/		return 0x8209D448;
		  /* 8209D448h */ case   16:  		/* rlwinm R6, R9, 1, 31, 31 */
		/* 8209D448h case   16:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R6,regs.R9);
		/* 8209D448h case   16:*/		return 0x8209D44C;
		  /* 8209D44Ch */ case   17:  		/* rlwinm R5, R9, 1, 0, 30 */
		/* 8209D44Ch case   17:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R5,regs.R9);
		/* 8209D44Ch case   17:*/		return 0x8209D450;
		  /* 8209D450h */ case   18:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209D450h case   18:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209D450h case   18:*/		return 0x8209D454;
		  /* 8209D454h */ case   19:  		/* rlwinm R10, R10, 1, 0, 30 */
		/* 8209D454h case   19:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R10);
		/* 8209D454h case   19:*/		return 0x8209D458;
		  /* 8209D458h */ case   20:  		/* or R7, R5, R7 */
		/* 8209D458h case   20:*/		cpu::op::or<0>(regs,&regs.R7,regs.R5,regs.R7);
		/* 8209D458h case   20:*/		return 0x8209D45C;
		  /* 8209D45Ch */ case   21:  		/* or R8, R8, R6 */
		/* 8209D45Ch case   21:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R6);
		/* 8209D45Ch case   21:*/		return 0x8209D460;
		  /* 8209D460h */ case   22:  		/* stw R10, <#[R1 + 128]> */
		/* 8209D460h case   22:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000080) );
		/* 8209D460h case   22:*/		return 0x8209D464;
		  /* 8209D464h */ case   23:  		/* add R11, R11, R21 */
		/* 8209D464h case   23:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R21);
		/* 8209D464h case   23:*/		return 0x8209D468;
		  /* 8209D468h */ case   24:  		/* stw R7, <#[R1 + 124]> */
		/* 8209D468h case   24:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x0000007C) );
		/* 8209D468h case   24:*/		return 0x8209D46C;
		  /* 8209D46Ch */ case   25:  		/* stw R8, <#[R1 + 120]> */
		/* 8209D46Ch case   25:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000078) );
		/* 8209D46Ch case   25:*/		return 0x8209D470;
		  /* 8209D470h */ case   26:  		/* b -76 */
		/* 8209D470h case   26:*/		return 0x8209D424;
		/* 8209D470h case   26:*/		return 0x8209D474;
	}
	return 0x8209D474;
} // Block from 8209D408h-8209D474h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8209D474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D474);
		  /* 8209D474h */ case    0:  		/* cmpwi CR6, R9, 0 */
		/* 8209D474h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 8209D474h case    0:*/		return 0x8209D478;
		  /* 8209D478h */ case    1:  		/* bc 12, CR6_GT, 132 */
		/* 8209D478h case    1:*/		if ( regs.CR[6].gt ) { return 0x8209D4FC;  }
		/* 8209D478h case    1:*/		return 0x8209D47C;
		  /* 8209D47Ch */ case    2:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209D47Ch case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209D47Ch case    2:*/		return 0x8209D480;
		  /* 8209D480h */ case    3:  		/* add R11, R11, R21 */
		/* 8209D480h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R21);
		/* 8209D480h case    3:*/		return 0x8209D484;
		  /* 8209D484h */ case    4:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209D484h case    4:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209D484h case    4:*/		return 0x8209D488;
		  /* 8209D488h */ case    5:  		/* extsh. R9, R11 */
		/* 8209D488h case    5:*/		cpu::op::extsh<1>(regs,&regs.R9,regs.R11);
		/* 8209D488h case    5:*/		return 0x8209D48C;
		  /* 8209D48Ch */ case    6:  		/* bc 4, CR0_LT, 112 */
		/* 8209D48Ch case    6:*/		if ( !regs.CR[0].lt ) { return 0x8209D4FC;  }
		/* 8209D48Ch case    6:*/		return 0x8209D490;
		  /* 8209D490h */ case    7:  		/* lwz R8, <#[R1 + 120]> */
		/* 8209D490h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000078) );
		/* 8209D490h case    7:*/		return 0x8209D494;
		  /* 8209D494h */ case    8:  		/* lwz R9, <#[R1 + 124]> */
		/* 8209D494h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000007C) );
		/* 8209D494h case    8:*/		return 0x8209D498;
		  /* 8209D498h */ case    9:  		/* lhz R7, <#[R1 + 130]> */
		/* 8209D498h case    9:*/		cpu::mem::load16z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000082) );
		/* 8209D498h case    9:*/		return 0x8209D49C;
		  /* 8209D49Ch */ case   10:  		/* rlwinm. R7, R7, 0, 31, 31 */
		/* 8209D49Ch case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R7,regs.R7);
		/* 8209D49Ch case   10:*/		return 0x8209D4A0;
		  /* 8209D4A0h */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 8209D4A0h case   11:*/		if ( regs.CR[0].eq ) { return 0x8209D4A8;  }
		/* 8209D4A0h case   11:*/		return 0x8209D4A4;
		  /* 8209D4A4h */ case   12:  		/* addi R30, R30, 1 */
		/* 8209D4A4h case   12:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8209D4A4h case   12:*/		return 0x8209D4A8;
	}
	return 0x8209D4A8;
} // Block from 8209D474h-8209D4A8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209D4A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D4A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D4A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D4A8);
		  /* 8209D4A8h */ case    0:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209D4A8h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209D4A8h case    0:*/		return 0x8209D4AC;
		  /* 8209D4ACh */ case    1:  		/* rlwinm R7, R9, 31, 0, 0 */
		/* 8209D4ACh case    1:*/		cpu::op::rlwinm<0,31,0,0>(regs,&regs.R7,regs.R9);
		/* 8209D4ACh case    1:*/		return 0x8209D4B0;
		  /* 8209D4B0h */ case    2:  		/* addi R11, R11, 1 */
		/* 8209D4B0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209D4B0h case    2:*/		return 0x8209D4B4;
		  /* 8209D4B4h */ case    3:  		/* rlwinm R10, R10, 31, 1, 31 */
		/* 8209D4B4h case    3:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R10,regs.R10);
		/* 8209D4B4h case    3:*/		return 0x8209D4B8;
		  /* 8209D4B8h */ case    4:  		/* rlwinm R6, R8, 31, 0, 0 */
		/* 8209D4B8h case    4:*/		cpu::op::rlwinm<0,31,0,0>(regs,&regs.R6,regs.R8);
		/* 8209D4B8h case    4:*/		return 0x8209D4BC;
		  /* 8209D4BCh */ case    5:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209D4BCh case    5:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209D4BCh case    5:*/		return 0x8209D4C0;
		  /* 8209D4C0h */ case    6:  		/* rlwinm R9, R9, 31, 1, 31 */
		/* 8209D4C0h case    6:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R9,regs.R9);
		/* 8209D4C0h case    6:*/		return 0x8209D4C4;
		  /* 8209D4C4h */ case    7:  		/* or R10, R10, R7 */
		/* 8209D4C4h case    7:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 8209D4C4h case    7:*/		return 0x8209D4C8;
		  /* 8209D4C8h */ case    8:  		/* extsh. R5, R11 */
		/* 8209D4C8h case    8:*/		cpu::op::extsh<1>(regs,&regs.R5,regs.R11);
		/* 8209D4C8h case    8:*/		return 0x8209D4CC;
		  /* 8209D4CCh */ case    9:  		/* rlwinm R8, R8, 31, 1, 31 */
		/* 8209D4CCh case    9:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R8,regs.R8);
		/* 8209D4CCh case    9:*/		return 0x8209D4D0;
		  /* 8209D4D0h */ case   10:  		/* stw R10, <#[R1 + 128]> */
		/* 8209D4D0h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000080) );
		/* 8209D4D0h case   10:*/		return 0x8209D4D4;
		  /* 8209D4D4h */ case   11:  		/* or R9, R9, R6 */
		/* 8209D4D4h case   11:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R6);
		/* 8209D4D4h case   11:*/		return 0x8209D4D8;
		  /* 8209D4D8h */ case   12:  		/* bc 12, CR0_LT, -64 */
		/* 8209D4D8h case   12:*/		if ( regs.CR[0].lt ) { return 0x8209D498;  }
		/* 8209D4D8h case   12:*/		return 0x8209D4DC;
		  /* 8209D4DCh */ case   13:  		/* stw R9, <#[R1 + 124]> */
		/* 8209D4DCh case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000007C) );
		/* 8209D4DCh case   13:*/		return 0x8209D4E0;
		  /* 8209D4E0h */ case   14:  		/* cmpwi CR6, R30, 0 */
		/* 8209D4E0h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 8209D4E0h case   14:*/		return 0x8209D4E4;
		  /* 8209D4E4h */ case   15:  		/* stw R8, <#[R1 + 120]> */
		/* 8209D4E4h case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000078) );
		/* 8209D4E4h case   15:*/		return 0x8209D4E8;
		  /* 8209D4E8h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 8209D4E8h case   16:*/		if ( regs.CR[6].eq ) { return 0x8209D4FC;  }
		/* 8209D4E8h case   16:*/		return 0x8209D4EC;
		  /* 8209D4ECh */ case   17:  		/* lhz R10, <#[R1 + 130]> */
		/* 8209D4ECh case   17:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000082) );
		/* 8209D4ECh case   17:*/		return 0x8209D4F0;
		  /* 8209D4F0h */ case   18:  		/* ori R10, R10, 1 */
		/* 8209D4F0h case   18:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8209D4F0h case   18:*/		return 0x8209D4F4;
		  /* 8209D4F4h */ case   19:  		/* sth R10, <#[R1 + 130]> */
		/* 8209D4F4h case   19:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R1 + 0x00000082) );
		/* 8209D4F4h case   19:*/		return 0x8209D4F8;
		  /* 8209D4F8h */ case   20:  		/* lwz R10, <#[R1 + 128]> */
		/* 8209D4F8h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000080) );
		/* 8209D4F8h case   20:*/		return 0x8209D4FC;
	}
	return 0x8209D4FC;
} // Block from 8209D4A8h-8209D4FCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 8209D4FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D4FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D4FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D4FC);
		  /* 8209D4FCh */ case    0:  		/* lhz R9, <#[R1 + 130]> */
		/* 8209D4FCh case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000082) );
		/* 8209D4FCh case    0:*/		return 0x8209D500;
		  /* 8209D500h */ case    1:  		/* cmplwi CR6, R9, 32768 */
		/* 8209D500h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00008000);
		/* 8209D500h case    1:*/		return 0x8209D504;
		  /* 8209D504h */ case    2:  		/* bc 12, CR6_GT, 16 */
		/* 8209D504h case    2:*/		if ( regs.CR[6].gt ) { return 0x8209D514;  }
		/* 8209D504h case    2:*/		return 0x8209D508;
		  /* 8209D508h */ case    3:  		/* rlwinm R10, R10, 0, 15, 31 */
		/* 8209D508h case    3:*/		cpu::op::rlwinm<0,0,15,31>(regs,&regs.R10,regs.R10);
		/* 8209D508h case    3:*/		return 0x8209D50C;
		  /* 8209D50Ch */ case    4:  		/* cmplw CR6, R10, R17 */
		/* 8209D50Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R17);
		/* 8209D50Ch case    4:*/		return 0x8209D510;
		  /* 8209D510h */ case    5:  		/* bc 4, CR6_EQ, 100 */
		/* 8209D510h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8209D574;  }
		/* 8209D510h case    5:*/		return 0x8209D514;
	}
	return 0x8209D514;
} // Block from 8209D4FCh-8209D514h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209D514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D514);
		  /* 8209D514h */ case    0:  		/* lwz R10, <#[R1 + 126]> */
		/* 8209D514h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000007E) );
		/* 8209D514h case    0:*/		return 0x8209D518;
		  /* 8209D518h */ case    1:  		/* cmpwi CR6, R10, -1 */
		/* 8209D518h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8209D518h case    1:*/		return 0x8209D51C;
		  /* 8209D51Ch */ case    2:  		/* bc 4, CR6_EQ, 80 */
		/* 8209D51Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x8209D56C;  }
		/* 8209D51Ch case    2:*/		return 0x8209D520;
		  /* 8209D520h */ case    3:  		/* lwz R10, <#[R1 + 122]> */
		/* 8209D520h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000007A) );
		/* 8209D520h case    3:*/		return 0x8209D524;
		  /* 8209D524h */ case    4:  		/* stw R22, <#[R1 + 126]> */
		/* 8209D524h case    4:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x0000007E) );
		/* 8209D524h case    4:*/		return 0x8209D528;
		  /* 8209D528h */ case    5:  		/* cmpwi CR6, R10, -1 */
		/* 8209D528h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8209D528h case    5:*/		return 0x8209D52C;
		  /* 8209D52Ch */ case    6:  		/* bc 4, CR6_EQ, 52 */
		/* 8209D52Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x8209D560;  }
		/* 8209D52Ch case    6:*/		return 0x8209D530;
		  /* 8209D530h */ case    7:  		/* lhz R10, <#[R1 + 120]> */
		/* 8209D530h case    7:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000078) );
		/* 8209D530h case    7:*/		return 0x8209D534;
		  /* 8209D534h */ case    8:  		/* stw R22, <#[R1 + 122]> */
		/* 8209D534h case    8:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x0000007A) );
		/* 8209D534h case    8:*/		return 0x8209D538;
		  /* 8209D538h */ case    9:  		/* cmplwi CR6, R10, 65535 */
		/* 8209D538h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000FFFF);
		/* 8209D538h case    9:*/		return 0x8209D53C;
		  /* 8209D53Ch */ case   10:  		/* bc 4, CR6_EQ, 24 */
		/* 8209D53Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x8209D554;  }
		/* 8209D53Ch case   10:*/		return 0x8209D540;
		  /* 8209D540h */ case   11:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209D540h case   11:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209D540h case   11:*/		return 0x8209D544;
		  /* 8209D544h */ case   12:  		/* sth R18, <#[R1 + 120]> */
		/* 8209D544h case   12:*/		cpu::mem::store16( regs, regs.R18, (uint32)(regs.R1 + 0x00000078) );
		/* 8209D544h case   12:*/		return 0x8209D548;
		  /* 8209D548h */ case   13:  		/* addi R11, R11, 1 */
		/* 8209D548h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209D548h case   13:*/		return 0x8209D54C;
		  /* 8209D54Ch */ case   14:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209D54Ch case   14:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209D54Ch case   14:*/		return 0x8209D550;
		  /* 8209D550h */ case   15:  		/* b 36 */
		/* 8209D550h case   15:*/		return 0x8209D574;
		/* 8209D550h case   15:*/		return 0x8209D554;
	}
	return 0x8209D554;
} // Block from 8209D514h-8209D554h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8209D554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D554);
		  /* 8209D554h */ case    0:  		/* addi R10, R10, 1 */
		/* 8209D554h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8209D554h case    0:*/		return 0x8209D558;
		  /* 8209D558h */ case    1:  		/* sth R10, <#[R1 + 120]> */
		/* 8209D558h case    1:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R1 + 0x00000078) );
		/* 8209D558h case    1:*/		return 0x8209D55C;
		  /* 8209D55Ch */ case    2:  		/* b 24 */
		/* 8209D55Ch case    2:*/		return 0x8209D574;
		/* 8209D55Ch case    2:*/		return 0x8209D560;
	}
	return 0x8209D560;
} // Block from 8209D554h-8209D560h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209D560h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D560);
		  /* 8209D560h */ case    0:  		/* addi R10, R10, 1 */
		/* 8209D560h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8209D560h case    0:*/		return 0x8209D564;
		  /* 8209D564h */ case    1:  		/* stw R10, <#[R1 + 122]> */
		/* 8209D564h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000007A) );
		/* 8209D564h case    1:*/		return 0x8209D568;
		  /* 8209D568h */ case    2:  		/* b 12 */
		/* 8209D568h case    2:*/		return 0x8209D574;
		/* 8209D568h case    2:*/		return 0x8209D56C;
	}
	return 0x8209D56C;
} // Block from 8209D560h-8209D56Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209D56Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D56C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D56C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D56C);
		  /* 8209D56Ch */ case    0:  		/* addi R10, R10, 1 */
		/* 8209D56Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8209D56Ch case    0:*/		return 0x8209D570;
		  /* 8209D570h */ case    1:  		/* stw R10, <#[R1 + 126]> */
		/* 8209D570h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000007E) );
		/* 8209D570h case    1:*/		return 0x8209D574;
	}
	return 0x8209D574;
} // Block from 8209D56Ch-8209D574h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209D574h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D574( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D574) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D574);
		  /* 8209D574h */ case    0:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8209D574h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8209D574h case    0:*/		return 0x8209D578;
		  /* 8209D578h */ case    1:  		/* cmplwi CR6, R11, 32767 */
		/* 8209D578h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00007FFF);
		/* 8209D578h case    1:*/		return 0x8209D57C;
		  /* 8209D57Ch */ case    2:  		/* bc 4, CR6_LT, 52 */
		/* 8209D57Ch case    2:*/		if ( !regs.CR[6].lt ) { return 0x8209D5B0;  }
		/* 8209D57Ch case    2:*/		return 0x8209D580;
		  /* 8209D580h */ case    3:  		/* lhz R10, <#[R1 + 128]> */
		/* 8209D580h case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000080) );
		/* 8209D580h case    3:*/		return 0x8209D584;
		  /* 8209D584h */ case    4:  		/* rlwinm R9, R29, 0, 16, 31 */
		/* 8209D584h case    4:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R29);
		/* 8209D584h case    4:*/		return 0x8209D588;
		  /* 8209D588h */ case    5:  		/* lwz R8, <#[R1 + 124]> */
		/* 8209D588h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x0000007C) );
		/* 8209D588h case    5:*/		return 0x8209D58C;
		  /* 8209D58Ch */ case    6:  		/* lwz R7, <#[R1 + 120]> */
		/* 8209D58Ch case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000078) );
		/* 8209D58Ch case    6:*/		return 0x8209D590;
		  /* 8209D590h */ case    7:  		/* or R11, R9, R11 */
		/* 8209D590h case    7:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8209D590h case    7:*/		return 0x8209D594;
		  /* 8209D594h */ case    8:  		/* sth R11, <#[R1 + 88]> */
		/* 8209D594h case    8:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8209D594h case    8:*/		return 0x8209D598;
		  /* 8209D598h */ case    9:  		/* sth R10, <#[R1 + 98]> */
		/* 8209D598h case    9:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R1 + 0x00000062) );
		/* 8209D598h case    9:*/		return 0x8209D59C;
		  /* 8209D59Ch */ case   10:  		/* stw R8, <#[R1 + 94]> */
		/* 8209D59Ch case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x0000005E) );
		/* 8209D59Ch case   10:*/		return 0x8209D5A0;
		  /* 8209D5A0h */ case   11:  		/* stw R7, <#[R1 + 90]> */
		/* 8209D5A0h case   11:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x0000005A) );
		/* 8209D5A0h case   11:*/		return 0x8209D5A4;
		  /* 8209D5A4h */ case   12:  		/* lwz R27, <#[R1 + 96]> */
		/* 8209D5A4h case   12:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000060) );
		/* 8209D5A4h case   12:*/		return 0x8209D5A8;
		  /* 8209D5A8h */ case   13:  		/* lwz R28, <#[R1 + 92]> */
		/* 8209D5A8h case   13:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x0000005C) );
		/* 8209D5A8h case   13:*/		return 0x8209D5AC;
		  /* 8209D5ACh */ case   14:  		/* b 28 */
		/* 8209D5ACh case   14:*/		return 0x8209D5C8;
		/* 8209D5ACh case   14:*/		return 0x8209D5B0;
	}
	return 0x8209D5B0;
} // Block from 8209D574h-8209D5B0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8209D5B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D5B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D5B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D5B0);
		  /* 8209D5B0h */ case    0:  		/* stw R15, <#[R1 + 88]> */
		/* 8209D5B0h case    0:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x00000058) );
		/* 8209D5B0h case    0:*/		return 0x8209D5B4;
		  /* 8209D5B4h */ case    1:  		/* rlwinm. R11, R29, 0, 16, 31 */
		/* 8209D5B4h case    1:*/		cpu::op::rlwinm<1,0,16,31>(regs,&regs.R11,regs.R29);
		/* 8209D5B4h case    1:*/		return 0x8209D5B8;
		  /* 8209D5B8h */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 8209D5B8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8209D5C0;  }
		/* 8209D5B8h case    2:*/		return 0x8209D5BC;
		  /* 8209D5BCh */ case    3:  		/* stw R16, <#[R1 + 88]> */
		/* 8209D5BCh case    3:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R1 + 0x00000058) );
		/* 8209D5BCh case    3:*/		return 0x8209D5C0;
	}
	return 0x8209D5C0;
} // Block from 8209D5B0h-8209D5C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209D5C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D5C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D5C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D5C0);
		  /* 8209D5C0h */ case    0:  		/* mr R28, R22 */
		/* 8209D5C0h case    0:*/		regs.R28 = regs.R22;
		/* 8209D5C0h case    0:*/		return 0x8209D5C4;
		  /* 8209D5C4h */ case    1:  		/* mr R27, R22 */
		/* 8209D5C4h case    1:*/		regs.R27 = regs.R22;
		/* 8209D5C4h case    1:*/		return 0x8209D5C8;
	}
	return 0x8209D5C8;
} // Block from 8209D5C0h-8209D5C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209D5C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D5C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D5C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D5C8);
		  /* 8209D5C8h */ case    0:  		/* lwz R11, <#[R1 + 364]> */
		/* 8209D5C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000016C) );
		/* 8209D5C8h case    0:*/		return 0x8209D5CC;
		  /* 8209D5CCh */ case    1:  		/* sth R19, <#[R14]> */
		/* 8209D5CCh case    1:*/		cpu::mem::store16( regs, regs.R19, (uint32)(regs.R14 + 0x00000000) );
		/* 8209D5CCh case    1:*/		return 0x8209D5D0;
		  /* 8209D5D0h */ case    2:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8209D5D0h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8209D5D0h case    2:*/		return 0x8209D5D4;
		  /* 8209D5D4h */ case    3:  		/* bc 12, CR0_EQ, 76 */
		/* 8209D5D4h case    3:*/		if ( regs.CR[0].eq ) { return 0x8209D620;  }
		/* 8209D5D4h case    3:*/		return 0x8209D5D8;
		  /* 8209D5D8h */ case    4:  		/* lwz R10, <#[R1 + 356]> */
		/* 8209D5D8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000164) );
		/* 8209D5D8h case    4:*/		return 0x8209D5DC;
		  /* 8209D5DCh */ case    5:  		/* extsh R11, R19 */
		/* 8209D5DCh case    5:*/		cpu::op::extsh<0>(regs,&regs.R11,regs.R19);
		/* 8209D5DCh case    5:*/		return 0x8209D5E0;
		  /* 8209D5E0h */ case    6:  		/* add. R9, R11, R10 */
		/* 8209D5E0h case    6:*/		cpu::op::add<1>(regs,&regs.R9,regs.R11,regs.R10);
		/* 8209D5E0h case    6:*/		return 0x8209D5E4;
		  /* 8209D5E4h */ case    7:  		/* bc 12, CR0_GT, 64 */
		/* 8209D5E4h case    7:*/		if ( regs.CR[0].gt ) { return 0x8209D624;  }
		/* 8209D5E4h case    7:*/		return 0x8209D5E8;
		  /* 8209D5E8h */ case    8:  		/* lwz R11, <#[R1 + 84]> */
		/* 8209D5E8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8209D5E8h case    8:*/		return 0x8209D5EC;
		  /* 8209D5ECh */ case    9:  		/* sth R22, <#[R14]> */
		/* 8209D5ECh case    9:*/		cpu::mem::store16( regs, regs.R22, (uint32)(regs.R14 + 0x00000000) );
		/* 8209D5ECh case    9:*/		return 0x8209D5F0;
		  /* 8209D5F0h */ case   10:  		/* cmplwi CR6, R11, 32768 */
		/* 8209D5F0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00008000);
		/* 8209D5F0h case   10:*/		return 0x8209D5F4;
		  /* 8209D5F4h */ case   11:  		/* li R11, 45 */
		/* 8209D5F4h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x2D);
		/* 8209D5F4h case   11:*/		return 0x8209D5F8;
		  /* 8209D5F8h */ case   12:  		/* bc 12, CR6_EQ, 8 */
		/* 8209D5F8h case   12:*/		if ( regs.CR[6].eq ) { return 0x8209D600;  }
		/* 8209D5F8h case   12:*/		return 0x8209D5FC;
		  /* 8209D5FCh */ case   13:  		/* li R11, 32 */
		/* 8209D5FCh case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x20);
		/* 8209D5FCh case   13:*/		return 0x8209D600;
	}
	return 0x8209D600;
} // Block from 8209D5C8h-8209D600h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209D600h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D600);
		  /* 8209D600h */ case    0:  		/* li R10, 48 */
		/* 8209D600h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x30);
		/* 8209D600h case    0:*/		return 0x8209D604;
		  /* 8209D604h */ case    1:  		/* stb R10, <#[R14 + 4]> */
		/* 8209D604h case    1:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R14 + 0x00000004) );
		/* 8209D604h case    1:*/		return 0x8209D608;
		  /* 8209D608h */ case    2:  		/* li R9, 1 */
		/* 8209D608h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8209D608h case    2:*/		return 0x8209D60C;
		  /* 8209D60Ch */ case    3:  		/* stb R11, <#[R14 + 2]> */
		/* 8209D60Ch case    3:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R14 + 0x00000002) );
		/* 8209D60Ch case    3:*/		return 0x8209D610;
		  /* 8209D610h */ case    4:  		/* stb R22, <#[R14 + 5]> */
		/* 8209D610h case    4:*/		cpu::mem::store8( regs, regs.R22, (uint32)(regs.R14 + 0x00000005) );
		/* 8209D610h case    4:*/		return 0x8209D614;
		  /* 8209D614h */ case    5:  		/* li R3, 1 */
		/* 8209D614h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8209D614h case    5:*/		return 0x8209D618;
		  /* 8209D618h */ case    6:  		/* stb R9, <#[R14 + 3]> */
		/* 8209D618h case    6:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R14 + 0x00000003) );
		/* 8209D618h case    6:*/		return 0x8209D61C;
		  /* 8209D61Ch */ case    7:  		/* b 552 */
		/* 8209D61Ch case    7:*/		return 0x8209D844;
		/* 8209D61Ch case    7:*/		return 0x8209D620;
	}
	return 0x8209D620;
} // Block from 8209D600h-8209D620h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209D620h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D620( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D620) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D620);
		  /* 8209D620h */ case    0:  		/* lwz R9, <#[R1 + 356]> */
		/* 8209D620h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000164) );
		/* 8209D620h case    0:*/		return 0x8209D624;
	}
	return 0x8209D624;
} // Block from 8209D620h-8209D624h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209D624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D624);
		  /* 8209D624h */ case    0:  		/* cmpwi CR6, R9, 21 */
		/* 8209D624h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000015);
		/* 8209D624h case    0:*/		return 0x8209D628;
		  /* 8209D628h */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 8209D628h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8209D630;  }
		/* 8209D628h case    1:*/		return 0x8209D62C;
		  /* 8209D62Ch */ case    2:  		/* li R9, 21 */
		/* 8209D62Ch case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x15);
		/* 8209D62Ch case    2:*/		return 0x8209D630;
	}
	return 0x8209D630;
} // Block from 8209D624h-8209D630h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209D630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D630);
		  /* 8209D630h */ case    0:  		/* lhz R10, <#[R1 + 88]> */
		/* 8209D630h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 8209D630h case    0:*/		return 0x8209D634;
		  /* 8209D634h */ case    1:  		/* li R11, 8 */
		/* 8209D634h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x8);
		/* 8209D634h case    1:*/		return 0x8209D638;
		  /* 8209D638h */ case    2:  		/* sth R22, <#[R1 + 88]> */
		/* 8209D638h case    2:*/		cpu::mem::store16( regs, regs.R22, (uint32)(regs.R1 + 0x00000058) );
		/* 8209D638h case    2:*/		return 0x8209D63C;
		  /* 8209D63Ch */ case    3:  		/* addi R10, R10, -16382 */
		/* 8209D63Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFC002);
		/* 8209D63Ch case    3:*/		return 0x8209D640;
		  /* 8209D640h */ case    4:  		/* mtspr CTR, R11 */
		/* 8209D640h case    4:*/		regs.CTR = regs.R11;
		/* 8209D640h case    4:*/		return 0x8209D644;
		  /* 8209D644h */ case    5:  		/* lwz R30, <#[R1 + 88]> */
		/* 8209D644h case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000058) );
		/* 8209D644h case    5:*/		return 0x8209D648;
		  /* 8209D648h */ case    6:  		/* rlwinm R11, R27, 1, 31, 31 */
		/* 8209D648h case    6:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R27);
		/* 8209D648h case    6:*/		return 0x8209D64C;
		  /* 8209D64Ch */ case    7:  		/* rlwinm R8, R28, 1, 31, 31 */
		/* 8209D64Ch case    7:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R8,regs.R28);
		/* 8209D64Ch case    7:*/		return 0x8209D650;
		  /* 8209D650h */ case    8:  		/* rlwinm R7, R28, 1, 0, 30 */
		/* 8209D650h case    8:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R7,regs.R28);
		/* 8209D650h case    8:*/		return 0x8209D654;
		  /* 8209D654h */ case    9:  		/* rlwinm R6, R30, 1, 0, 30 */
		/* 8209D654h case    9:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R6,regs.R30);
		/* 8209D654h case    9:*/		return 0x8209D658;
		  /* 8209D658h */ case   10:  		/* rlwinm R27, R27, 1, 0, 30 */
		/* 8209D658h case   10:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R27,regs.R27);
		/* 8209D658h case   10:*/		return 0x8209D65C;
		  /* 8209D65Ch */ case   11:  		/* or R28, R7, R11 */
		/* 8209D65Ch case   11:*/		cpu::op::or<0>(regs,&regs.R28,regs.R7,regs.R11);
		/* 8209D65Ch case   11:*/		return 0x8209D660;
		  /* 8209D660h */ case   12:  		/* or R30, R6, R8 */
		/* 8209D660h case   12:*/		cpu::op::or<0>(regs,&regs.R30,regs.R6,regs.R8);
		/* 8209D660h case   12:*/		return 0x8209D664;
		  /* 8209D664h */ case   13:  		/* bc 16, CR0_LT, -28 */
		/* 8209D664h case   13:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209D648;  }
		/* 8209D664h case   13:*/		return 0x8209D668;
		  /* 8209D668h */ case   14:  		/* stw R30, <#[R1 + 88]> */
		/* 8209D668h case   14:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000058) );
		/* 8209D668h case   14:*/		return 0x8209D66C;
		  /* 8209D66Ch */ case   15:  		/* cmpwi CR6, R10, 0 */
		/* 8209D66Ch case   15:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8209D66Ch case   15:*/		return 0x8209D670;
		  /* 8209D670h */ case   16:  		/* stw R28, <#[R1 + 92]> */
		/* 8209D670h case   16:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x0000005C) );
		/* 8209D670h case   16:*/		return 0x8209D674;
		  /* 8209D674h */ case   17:  		/* stw R27, <#[R1 + 96]> */
		/* 8209D674h case   17:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000060) );
		/* 8209D674h case   17:*/		return 0x8209D678;
		  /* 8209D678h */ case   18:  		/* bc 4, CR6_LT, 64 */
		/* 8209D678h case   18:*/		if ( !regs.CR[6].lt ) { return 0x8209D6B8;  }
		/* 8209D678h case   18:*/		return 0x8209D67C;
		  /* 8209D67Ch */ case   19:  		/* neg R11, R10 */
		/* 8209D67Ch case   19:*/		cpu::op::neg<0>(regs,&regs.R11,regs.R10);
		/* 8209D67Ch case   19:*/		return 0x8209D680;
		  /* 8209D680h */ case   20:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8209D680h case   20:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8209D680h case   20:*/		return 0x8209D684;
		  /* 8209D684h */ case   21:  		/* bc 4, CR0_GT, 52 */
		/* 8209D684h case   21:*/		if ( !regs.CR[0].gt ) { return 0x8209D6B8;  }
		/* 8209D684h case   21:*/		return 0x8209D688;
		  /* 8209D688h */ case   22:  		/* mtspr CTR, R11 */
		/* 8209D688h case   22:*/		regs.CTR = regs.R11;
		/* 8209D688h case   22:*/		return 0x8209D68C;
		  /* 8209D68Ch */ case   23:  		/* rlwinm R11, R30, 31, 0, 0 */
		/* 8209D68Ch case   23:*/		cpu::op::rlwinm<0,31,0,0>(regs,&regs.R11,regs.R30);
		/* 8209D68Ch case   23:*/		return 0x8209D690;
		  /* 8209D690h */ case   24:  		/* rlwinm R10, R28, 31, 0, 0 */
		/* 8209D690h case   24:*/		cpu::op::rlwinm<0,31,0,0>(regs,&regs.R10,regs.R28);
		/* 8209D690h case   24:*/		return 0x8209D694;
		  /* 8209D694h */ case   25:  		/* rlwinm R8, R28, 31, 1, 31 */
		/* 8209D694h case   25:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R8,regs.R28);
		/* 8209D694h case   25:*/		return 0x8209D698;
		  /* 8209D698h */ case   26:  		/* rlwinm R7, R27, 31, 1, 31 */
		/* 8209D698h case   26:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R7,regs.R27);
		/* 8209D698h case   26:*/		return 0x8209D69C;
		  /* 8209D69Ch */ case   27:  		/* rlwinm R30, R30, 31, 1, 31 */
		/* 8209D69Ch case   27:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R30,regs.R30);
		/* 8209D69Ch case   27:*/		return 0x8209D6A0;
		  /* 8209D6A0h */ case   28:  		/* or R28, R8, R11 */
		/* 8209D6A0h case   28:*/		cpu::op::or<0>(regs,&regs.R28,regs.R8,regs.R11);
		/* 8209D6A0h case   28:*/		return 0x8209D6A4;
		  /* 8209D6A4h */ case   29:  		/* or R27, R7, R10 */
		/* 8209D6A4h case   29:*/		cpu::op::or<0>(regs,&regs.R27,regs.R7,regs.R10);
		/* 8209D6A4h case   29:*/		return 0x8209D6A8;
		  /* 8209D6A8h */ case   30:  		/* bc 16, CR0_LT, -28 */
		/* 8209D6A8h case   30:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209D68C;  }
		/* 8209D6A8h case   30:*/		return 0x8209D6AC;
		  /* 8209D6ACh */ case   31:  		/* stw R27, <#[R1 + 96]> */
		/* 8209D6ACh case   31:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000060) );
		/* 8209D6ACh case   31:*/		return 0x8209D6B0;
		  /* 8209D6B0h */ case   32:  		/* stw R28, <#[R1 + 92]> */
		/* 8209D6B0h case   32:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x0000005C) );
		/* 8209D6B0h case   32:*/		return 0x8209D6B4;
		  /* 8209D6B4h */ case   33:  		/* stw R30, <#[R1 + 88]> */
		/* 8209D6B4h case   33:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000058) );
		/* 8209D6B4h case   33:*/		return 0x8209D6B8;
	}
	return 0x8209D6B8;
} // Block from 8209D630h-8209D6B8h (34 instructions)

//////////////////////////////////////////////////////
// Block at 8209D6B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D6B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D6B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D6B8);
		  /* 8209D6B8h */ case    0:  		/* addi R26, R14, 4 */
		/* 8209D6B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R14,0x4);
		/* 8209D6B8h case    0:*/		return 0x8209D6BC;
		  /* 8209D6BCh */ case    1:  		/* addic. R11, R9, 1 */
		/* 8209D6BCh case    1:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R9,0x1);
		/* 8209D6BCh case    1:*/		return 0x8209D6C0;
		  /* 8209D6C0h */ case    2:  		/* mr R31, R26 */
		/* 8209D6C0h case    2:*/		regs.R31 = regs.R26;
		/* 8209D6C0h case    2:*/		return 0x8209D6C4;
		  /* 8209D6C4h */ case    3:  		/* bc 4, CR0_GT, 264 */
		/* 8209D6C4h case    3:*/		if ( !regs.CR[0].gt ) { return 0x8209D7CC;  }
		/* 8209D6C4h case    3:*/		return 0x8209D6C8;
		  /* 8209D6C8h */ case    4:  		/* mr R29, R11 */
		/* 8209D6C8h case    4:*/		regs.R29 = regs.R11;
		/* 8209D6C8h case    4:*/		return 0x8209D6CC;
		  /* 8209D6CCh */ case    5:  		/* b 8 */
		/* 8209D6CCh case    5:*/		return 0x8209D6D4;
		/* 8209D6CCh case    5:*/		return 0x8209D6D0;
		  /* 8209D6D0h */ case    6:  		/* lwz R30, <#[R1 + 88]> */
		/* 8209D6D0h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000058) );
		/* 8209D6D0h case    6:*/		return 0x8209D6D4;
	}
	return 0x8209D6D4;
} // Block from 8209D6B8h-8209D6D4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209D6D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D6D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D6D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D6D4);
		  /* 8209D6D4h */ case    0:  		/* addi R3, R1, 152 */
		/* 8209D6D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x98);
		/* 8209D6D4h case    0:*/		return 0x8209D6D8;
		  /* 8209D6D8h */ case    1:  		/* addi R4, R1, 88 */
		/* 8209D6D8h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x58);
		/* 8209D6D8h case    1:*/		return 0x8209D6DC;
		  /* 8209D6DCh */ case    2:  		/* li R5, 12 */
		/* 8209D6DCh case    2:*/		cpu::op::li<0>(regs,&regs.R5,0xC);
		/* 8209D6DCh case    2:*/		return 0x8209D6E0;
		  /* 8209D6E0h */ case    3:  		/* bl -48432 */
		/* 8209D6E0h case    3:*/		regs.LR = 0x8209D6E4; return 0x820919B0;
		/* 8209D6E0h case    3:*/		return 0x8209D6E4;
		  /* 8209D6E4h */ case    4:  		/* rlwinm R5, R27, 1, 31, 31 */
		/* 8209D6E4h case    4:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R5,regs.R27);
		/* 8209D6E4h case    4:*/		return 0x8209D6E8;
		  /* 8209D6E8h */ case    5:  		/* rlwinm R7, R28, 1, 0, 30 */
		/* 8209D6E8h case    5:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R7,regs.R28);
		/* 8209D6E8h case    5:*/		return 0x8209D6EC;
		  /* 8209D6ECh */ case    6:  		/* lwz R8, <#[R1 + 160]> */
		/* 8209D6ECh case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x000000A0) );
		/* 8209D6ECh case    6:*/		return 0x8209D6F0;
		  /* 8209D6F0h */ case    7:  		/* rlwinm R10, R27, 1, 0, 30 */
		/* 8209D6F0h case    7:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R27);
		/* 8209D6F0h case    7:*/		return 0x8209D6F4;
		  /* 8209D6F4h */ case    8:  		/* rlwinm R6, R30, 1, 0, 30 */
		/* 8209D6F4h case    8:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R6,regs.R30);
		/* 8209D6F4h case    8:*/		return 0x8209D6F8;
		  /* 8209D6F8h */ case    9:  		/* rlwinm R9, R28, 1, 31, 31 */
		/* 8209D6F8h case    9:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R9,regs.R28);
		/* 8209D6F8h case    9:*/		return 0x8209D6FC;
		  /* 8209D6FCh */ case   10:  		/* or R7, R7, R5 */
		/* 8209D6FCh case   10:*/		cpu::op::or<0>(regs,&regs.R7,regs.R7,regs.R5);
		/* 8209D6FCh case   10:*/		return 0x8209D700;
		  /* 8209D700h */ case   11:  		/* or R9, R6, R9 */
		/* 8209D700h case   11:*/		cpu::op::or<0>(regs,&regs.R9,regs.R6,regs.R9);
		/* 8209D700h case   11:*/		return 0x8209D704;
		  /* 8209D704h */ case   12:  		/* rlwinm R11, R10, 1, 0, 30 */
		/* 8209D704h case   12:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R10);
		/* 8209D704h case   12:*/		return 0x8209D708;
		  /* 8209D708h */ case   13:  		/* rlwinm R5, R7, 1, 31, 31 */
		/* 8209D708h case   13:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R5,regs.R7);
		/* 8209D708h case   13:*/		return 0x8209D70C;
		  /* 8209D70Ch */ case   14:  		/* rlwinm R6, R10, 1, 31, 31 */
		/* 8209D70Ch case   14:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R6,regs.R10);
		/* 8209D70Ch case   14:*/		return 0x8209D710;
		  /* 8209D710h */ case   15:  		/* rlwinm R7, R7, 1, 0, 30 */
		/* 8209D710h case   15:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R7,regs.R7);
		/* 8209D710h case   15:*/		return 0x8209D714;
		  /* 8209D714h */ case   16:  		/* rlwinm R4, R9, 1, 0, 30 */
		/* 8209D714h case   16:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R4,regs.R9);
		/* 8209D714h case   16:*/		return 0x8209D718;
		  /* 8209D718h */ case   17:  		/* add R10, R8, R11 */
		/* 8209D718h case   17:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R11);
		/* 8209D718h case   17:*/		return 0x8209D71C;
		  /* 8209D71Ch */ case   18:  		/* or R9, R7, R6 */
		/* 8209D71Ch case   18:*/		cpu::op::or<0>(regs,&regs.R9,regs.R7,regs.R6);
		/* 8209D71Ch case   18:*/		return 0x8209D720;
		  /* 8209D720h */ case   19:  		/* or R7, R4, R5 */
		/* 8209D720h case   19:*/		cpu::op::or<0>(regs,&regs.R7,regs.R4,regs.R5);
		/* 8209D720h case   19:*/		return 0x8209D724;
		  /* 8209D724h */ case   20:  		/* cmplw CR6, R10, R11 */
		/* 8209D724h case   20:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8209D724h case   20:*/		return 0x8209D728;
		  /* 8209D728h */ case   21:  		/* bc 12, CR6_LT, 12 */
		/* 8209D728h case   21:*/		if ( regs.CR[6].lt ) { return 0x8209D734;  }
		/* 8209D728h case   21:*/		return 0x8209D72C;
		  /* 8209D72Ch */ case   22:  		/* cmplw CR6, R10, R8 */
		/* 8209D72Ch case   22:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8209D72Ch case   22:*/		return 0x8209D730;
	}
	return 0x8209D730;
} // Block from 8209D6D4h-8209D730h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8209D730h
// Function '__strgtold12_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D730);
		  /* 8209D730h */ case    0:  		/* bc 4, CR6_LT, 48 */
		/* 8209D730h case    0:*/		if ( !regs.CR[6].lt ) { return 0x8209D760;  }
		/* 8209D730h case    0:*/		return 0x8209D734;
	}
	return 0x8209D734;
} // Block from 8209D730h-8209D734h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209D734h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D734( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D734) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D734);
		  /* 8209D734h */ case    0:  		/* addi R11, R9, 1 */
		/* 8209D734h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x1);
		/* 8209D734h case    0:*/		return 0x8209D738;
		  /* 8209D738h */ case    1:  		/* mr R8, R22 */
		/* 8209D738h case    1:*/		regs.R8 = regs.R22;
		/* 8209D738h case    1:*/		return 0x8209D73C;
		  /* 8209D73Ch */ case    2:  		/* cmplw CR6, R11, R9 */
		/* 8209D73Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8209D73Ch case    2:*/		return 0x8209D740;
		  /* 8209D740h */ case    3:  		/* bc 12, CR6_LT, 12 */
		/* 8209D740h case    3:*/		if ( regs.CR[6].lt ) { return 0x8209D74C;  }
		/* 8209D740h case    3:*/		return 0x8209D744;
		  /* 8209D744h */ case    4:  		/* cmplwi CR6, R11, 1 */
		/* 8209D744h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8209D744h case    4:*/		return 0x8209D748;
		  /* 8209D748h */ case    5:  		/* bc 4, CR6_LT, 8 */
		/* 8209D748h case    5:*/		if ( !regs.CR[6].lt ) { return 0x8209D750;  }
		/* 8209D748h case    5:*/		return 0x8209D74C;
	}
	return 0x8209D74C;
} // Block from 8209D734h-8209D74Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209D74Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D74C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D74C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D74C);
		  /* 8209D74Ch */ case    0:  		/* li R8, 1 */
		/* 8209D74Ch case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8209D74Ch case    0:*/		return 0x8209D750;
	}
	return 0x8209D750;
} // Block from 8209D74Ch-8209D750h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209D750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D750);
		  /* 8209D750h */ case    0:  		/* mr R9, R11 */
		/* 8209D750h case    0:*/		regs.R9 = regs.R11;
		/* 8209D750h case    0:*/		return 0x8209D754;
		  /* 8209D754h */ case    1:  		/* cmpwi CR6, R8, 0 */
		/* 8209D754h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 8209D754h case    1:*/		return 0x8209D758;
		  /* 8209D758h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 8209D758h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209D760;  }
		/* 8209D758h case    2:*/		return 0x8209D75C;
		  /* 8209D75Ch */ case    3:  		/* addi R7, R7, 1 */
		/* 8209D75Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8209D75Ch case    3:*/		return 0x8209D760;
	}
	return 0x8209D760;
} // Block from 8209D750h-8209D760h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209D760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D760);
		  /* 8209D760h */ case    0:  		/* lwz R8, <#[R1 + 156]> */
		/* 8209D760h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x0000009C) );
		/* 8209D760h case    0:*/		return 0x8209D764;
		  /* 8209D764h */ case    1:  		/* add R11, R8, R9 */
		/* 8209D764h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R9);
		/* 8209D764h case    1:*/		return 0x8209D768;
		  /* 8209D768h */ case    2:  		/* cmplw CR6, R11, R9 */
		/* 8209D768h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8209D768h case    2:*/		return 0x8209D76C;
		  /* 8209D76Ch */ case    3:  		/* bc 12, CR6_LT, 12 */
		/* 8209D76Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8209D778;  }
		/* 8209D76Ch case    3:*/		return 0x8209D770;
		  /* 8209D770h */ case    4:  		/* cmplw CR6, R11, R8 */
		/* 8209D770h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8209D770h case    4:*/		return 0x8209D774;
		  /* 8209D774h */ case    5:  		/* bc 4, CR6_LT, 8 */
		/* 8209D774h case    5:*/		if ( !regs.CR[6].lt ) { return 0x8209D77C;  }
		/* 8209D774h case    5:*/		return 0x8209D778;
	}
	return 0x8209D778;
} // Block from 8209D760h-8209D778h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209D778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D778);
		  /* 8209D778h */ case    0:  		/* addi R7, R7, 1 */
		/* 8209D778h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8209D778h case    0:*/		return 0x8209D77C;
	}
	return 0x8209D77C;
} // Block from 8209D778h-8209D77Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209D77Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D77C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D77C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D77C);
		  /* 8209D77Ch */ case    0:  		/* lwz R9, <#[R1 + 152]> */
		/* 8209D77Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000098) );
		/* 8209D77Ch case    0:*/		return 0x8209D780;
		  /* 8209D780h */ case    1:  		/* rlwinm R8, R11, 1, 31, 31 */
		/* 8209D780h case    1:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R8,regs.R11);
		/* 8209D780h case    1:*/		return 0x8209D784;
		  /* 8209D784h */ case    2:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 8209D784h case    2:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 8209D784h case    2:*/		return 0x8209D788;
		  /* 8209D788h */ case    3:  		/* add R9, R9, R7 */
		/* 8209D788h case    3:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 8209D788h case    3:*/		return 0x8209D78C;
		  /* 8209D78Ch */ case    4:  		/* rlwinm R7, R10, 1, 31, 31 */
		/* 8209D78Ch case    4:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R7,regs.R10);
		/* 8209D78Ch case    4:*/		return 0x8209D790;
		  /* 8209D790h */ case    5:  		/* rlwinm R9, R9, 1, 0, 30 */
		/* 8209D790h case    5:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R9);
		/* 8209D790h case    5:*/		return 0x8209D794;
		  /* 8209D794h */ case    6:  		/* or R28, R11, R7 */
		/* 8209D794h case    6:*/		cpu::op::or<0>(regs,&regs.R28,regs.R11,regs.R7);
		/* 8209D794h case    6:*/		return 0x8209D798;
		  /* 8209D798h */ case    7:  		/* or R9, R9, R8 */
		/* 8209D798h case    7:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8209D798h case    7:*/		return 0x8209D79C;
		  /* 8209D79Ch */ case    8:  		/* rlwinm R27, R10, 1, 0, 30 */
		/* 8209D79Ch case    8:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R27,regs.R10);
		/* 8209D79Ch case    8:*/		return 0x8209D7A0;
		  /* 8209D7A0h */ case    9:  		/* stw R28, <#[R1 + 92]> */
		/* 8209D7A0h case    9:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x0000005C) );
		/* 8209D7A0h case    9:*/		return 0x8209D7A4;
		  /* 8209D7A4h */ case   10:  		/* stw R9, <#[R1 + 88]> */
		/* 8209D7A4h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 8209D7A4h case   10:*/		return 0x8209D7A8;
		  /* 8209D7A8h */ case   11:  		/* addic. R29, R29, -1 */
		/* 8209D7A8h case   11:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 8209D7A8h case   11:*/		return 0x8209D7AC;
		  /* 8209D7ACh */ case   12:  		/* lbz R11, <#[R1 + 88]> */
		/* 8209D7ACh case   12:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8209D7ACh case   12:*/		return 0x8209D7B0;
		  /* 8209D7B0h */ case   13:  		/* addi R11, R11, 48 */
		/* 8209D7B0h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x30);
		/* 8209D7B0h case   13:*/		return 0x8209D7B4;
		  /* 8209D7B4h */ case   14:  		/* extsb R11, R11 */
		/* 8209D7B4h case   14:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 8209D7B4h case   14:*/		return 0x8209D7B8;
		  /* 8209D7B8h */ case   15:  		/* stw R27, <#[R1 + 96]> */
		/* 8209D7B8h case   15:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000060) );
		/* 8209D7B8h case   15:*/		return 0x8209D7BC;
		  /* 8209D7BCh */ case   16:  		/* stb R22, <#[R1 + 88]> */
		/* 8209D7BCh case   16:*/		cpu::mem::store8( regs, regs.R22, (uint32)(regs.R1 + 0x00000058) );
		/* 8209D7BCh case   16:*/		return 0x8209D7C0;
		  /* 8209D7C0h */ case   17:  		/* stb R11, <#[R31]> */
		/* 8209D7C0h case   17:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209D7C0h case   17:*/		return 0x8209D7C4;
		  /* 8209D7C4h */ case   18:  		/* addi R31, R31, 1 */
		/* 8209D7C4h case   18:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8209D7C4h case   18:*/		return 0x8209D7C8;
		  /* 8209D7C8h */ case   19:  		/* bc 4, CR0_EQ, -248 */
		/* 8209D7C8h case   19:*/		if ( !regs.CR[0].eq ) { return 0x8209D6D0;  }
		/* 8209D7C8h case   19:*/		return 0x8209D7CC;
	}
	return 0x8209D7CC;
} // Block from 8209D77Ch-8209D7CCh (20 instructions)

//////////////////////////////////////////////////////
// Block at 8209D7CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D7CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D7CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D7CC);
		  /* 8209D7CCh */ case    0:  		/* lbzu R10, <#[R31 - 1]> */
		/* 8209D7CCh case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0xFFFFFFFF) );
		regs.R31 = (uint32)(regs.R31 + 0xFFFFFFFF);
		/* 8209D7CCh case    0:*/		return 0x8209D7D0;
		  /* 8209D7D0h */ case    1:  		/* extsb R10, R10 */
		/* 8209D7D0h case    1:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 8209D7D0h case    1:*/		return 0x8209D7D4;
		  /* 8209D7D4h */ case    2:  		/* addi R11, R31, -1 */
		/* 8209D7D4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFF);
		/* 8209D7D4h case    2:*/		return 0x8209D7D8;
		  /* 8209D7D8h */ case    3:  		/* cmpwi CR6, R10, 53 */
		/* 8209D7D8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000035);
		/* 8209D7D8h case    3:*/		return 0x8209D7DC;
		  /* 8209D7DCh */ case    4:  		/* bc 12, CR6_LT, 128 */
		/* 8209D7DCh case    4:*/		if ( regs.CR[6].lt ) { return 0x8209D85C;  }
		/* 8209D7DCh case    4:*/		return 0x8209D7E0;
		  /* 8209D7E0h */ case    5:  		/* b 28 */
		/* 8209D7E0h case    5:*/		return 0x8209D7FC;
		/* 8209D7E0h case    5:*/		return 0x8209D7E4;
		  /* 8209D7E4h */ case    6:  		/* lbz R10, <#[R11]> */
		/* 8209D7E4h case    6:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209D7E4h case    6:*/		return 0x8209D7E8;
		  /* 8209D7E8h */ case    7:  		/* cmplwi CR6, R10, 57 */
		/* 8209D7E8h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000039);
		/* 8209D7E8h case    7:*/		return 0x8209D7EC;
		  /* 8209D7ECh */ case    8:  		/* bc 4, CR6_EQ, 24 */
		/* 8209D7ECh case    8:*/		if ( !regs.CR[6].eq ) { return 0x8209D804;  }
		/* 8209D7ECh case    8:*/		return 0x8209D7F0;
		  /* 8209D7F0h */ case    9:  		/* li R10, 48 */
		/* 8209D7F0h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x30);
		/* 8209D7F0h case    9:*/		return 0x8209D7F4;
		  /* 8209D7F4h */ case   10:  		/* stb R10, <#[R11]> */
		/* 8209D7F4h case   10:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209D7F4h case   10:*/		return 0x8209D7F8;
		  /* 8209D7F8h */ case   11:  		/* addi R11, R11, -1 */
		/* 8209D7F8h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8209D7F8h case   11:*/		return 0x8209D7FC;
	}
	return 0x8209D7FC;
} // Block from 8209D7CCh-8209D7FCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 8209D7FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D7FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D7FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D7FC);
		  /* 8209D7FCh */ case    0:  		/* cmplw CR6, R11, R26 */
		/* 8209D7FCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 8209D7FCh case    0:*/		return 0x8209D800;
		  /* 8209D800h */ case    1:  		/* bc 4, CR6_LT, -28 */
		/* 8209D800h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8209D7E4;  }
		/* 8209D800h case    1:*/		return 0x8209D804;
	}
	return 0x8209D804;
} // Block from 8209D7FCh-8209D804h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209D804h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D804( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D804) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D804);
		  /* 8209D804h */ case    0:  		/* cmplw CR6, R11, R26 */
		/* 8209D804h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 8209D804h case    0:*/		return 0x8209D808;
		  /* 8209D808h */ case    1:  		/* bc 4, CR6_LT, 20 */
		/* 8209D808h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8209D81C;  }
		/* 8209D808h case    1:*/		return 0x8209D80C;
		  /* 8209D80Ch */ case    2:  		/* lhz R10, <#[R14]> */
		/* 8209D80Ch case    2:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000000) );
		/* 8209D80Ch case    2:*/		return 0x8209D810;
		  /* 8209D810h */ case    3:  		/* addi R11, R11, 1 */
		/* 8209D810h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209D810h case    3:*/		return 0x8209D814;
		  /* 8209D814h */ case    4:  		/* addi R10, R10, 1 */
		/* 8209D814h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8209D814h case    4:*/		return 0x8209D818;
		  /* 8209D818h */ case    5:  		/* sth R10, <#[R14]> */
		/* 8209D818h case    5:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R14 + 0x00000000) );
		/* 8209D818h case    5:*/		return 0x8209D81C;
	}
	return 0x8209D81C;
} // Block from 8209D804h-8209D81Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209D81Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D81C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D81C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D81C);
		  /* 8209D81Ch */ case    0:  		/* lbz R10, <#[R11]> */
		/* 8209D81Ch case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209D81Ch case    0:*/		return 0x8209D820;
		  /* 8209D820h */ case    1:  		/* addi R10, R10, 1 */
		/* 8209D820h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8209D820h case    1:*/		return 0x8209D824;
		  /* 8209D824h */ case    2:  		/* stb R10, <#[R11]> */
		/* 8209D824h case    2:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209D824h case    2:*/		return 0x8209D828;
		  /* 8209D828h */ case    3:  		/* subf R11, R14, R11 */
		/* 8209D828h case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R14,regs.R11);
		/* 8209D828h case    3:*/		return 0x8209D82C;
		  /* 8209D82Ch */ case    4:  		/* addi R11, R11, -3 */
		/* 8209D82Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFD);
		/* 8209D82Ch case    4:*/		return 0x8209D830;
		  /* 8209D830h */ case    5:  		/* extsb R10, R11 */
		/* 8209D830h case    5:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R11);
		/* 8209D830h case    5:*/		return 0x8209D834;
		  /* 8209D834h */ case    6:  		/* add R11, R10, R14 */
		/* 8209D834h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R14);
		/* 8209D834h case    6:*/		return 0x8209D838;
		  /* 8209D838h */ case    7:  		/* stb R10, <#[R14 + 3]> */
		/* 8209D838h case    7:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R14 + 0x00000003) );
		/* 8209D838h case    7:*/		return 0x8209D83C;
		  /* 8209D83Ch */ case    8:  		/* stb R22, <#[R11 + 4]> */
		/* 8209D83Ch case    8:*/		cpu::mem::store8( regs, regs.R22, (uint32)(regs.R11 + 0x00000004) );
		/* 8209D83Ch case    8:*/		return 0x8209D840;
	}
	return 0x8209D840;
} // Block from 8209D81Ch-8209D840h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209D840h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D840);
		  /* 8209D840h */ case    0:  		/* lwz R3, <#[R1 + 80]> */
		/* 8209D840h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 8209D840h case    0:*/		return 0x8209D844;
	}
	return 0x8209D844;
} // Block from 8209D840h-8209D844h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209D844h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D844( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D844) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D844);
		  /* 8209D844h */ case    0:  		/* addi R1, R1, 320 */
		/* 8209D844h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x140);
		/* 8209D844h case    0:*/		return 0x8209D848;
		  /* 8209D848h */ case    1:  		/* b -50648 */
		/* 8209D848h case    1:*/		return 0x82091270;
		/* 8209D848h case    1:*/		return 0x8209D84C;
		  /* 8209D84Ch */ case    2:  		/* lbz R10, <#[R11]> */
		/* 8209D84Ch case    2:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209D84Ch case    2:*/		return 0x8209D850;
		  /* 8209D850h */ case    3:  		/* cmplwi CR6, R10, 48 */
		/* 8209D850h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000030);
		/* 8209D850h case    3:*/		return 0x8209D854;
		  /* 8209D854h */ case    4:  		/* bc 4, CR6_EQ, 16 */
		/* 8209D854h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8209D864;  }
		/* 8209D854h case    4:*/		return 0x8209D858;
		  /* 8209D858h */ case    5:  		/* addi R11, R11, -1 */
		/* 8209D858h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8209D858h case    5:*/		return 0x8209D85C;
	}
	return 0x8209D85C;
} // Block from 8209D844h-8209D85Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209D85Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D85C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D85C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D85C);
		  /* 8209D85Ch */ case    0:  		/* cmplw CR6, R11, R26 */
		/* 8209D85Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 8209D85Ch case    0:*/		return 0x8209D860;
		  /* 8209D860h */ case    1:  		/* bc 4, CR6_LT, -20 */
		/* 8209D860h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8209D84C;  }
		/* 8209D860h case    1:*/		return 0x8209D864;
	}
	return 0x8209D864;
} // Block from 8209D85Ch-8209D864h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209D864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D864);
		  /* 8209D864h */ case    0:  		/* cmplw CR6, R11, R26 */
		/* 8209D864h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 8209D864h case    0:*/		return 0x8209D868;
		  /* 8209D868h */ case    1:  		/* bc 4, CR6_LT, -64 */
		/* 8209D868h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8209D828;  }
		/* 8209D868h case    1:*/		return 0x8209D86C;
		  /* 8209D86Ch */ case    2:  		/* lwz R11, <#[R1 + 84]> */
		/* 8209D86Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8209D86Ch case    2:*/		return 0x8209D870;
		  /* 8209D870h */ case    3:  		/* sth R22, <#[R14]> */
		/* 8209D870h case    3:*/		cpu::mem::store16( regs, regs.R22, (uint32)(regs.R14 + 0x00000000) );
		/* 8209D870h case    3:*/		return 0x8209D874;
		  /* 8209D874h */ case    4:  		/* cmplwi CR6, R11, 32768 */
		/* 8209D874h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00008000);
		/* 8209D874h case    4:*/		return 0x8209D878;
		  /* 8209D878h */ case    5:  		/* li R11, 45 */
		/* 8209D878h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x2D);
		/* 8209D878h case    5:*/		return 0x8209D87C;
		  /* 8209D87Ch */ case    6:  		/* bc 12, CR6_EQ, 8 */
		/* 8209D87Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x8209D884;  }
		/* 8209D87Ch case    6:*/		return 0x8209D880;
		  /* 8209D880h */ case    7:  		/* li R11, 32 */
		/* 8209D880h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x20);
		/* 8209D880h case    7:*/		return 0x8209D884;
	}
	return 0x8209D884;
} // Block from 8209D864h-8209D884h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209D884h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D884( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D884) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D884);
		  /* 8209D884h */ case    0:  		/* li R10, 48 */
		/* 8209D884h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x30);
		/* 8209D884h case    0:*/		return 0x8209D888;
		  /* 8209D888h */ case    1:  		/* stb R10, <#[R26]> */
		/* 8209D888h case    1:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 8209D888h case    1:*/		return 0x8209D88C;
		  /* 8209D88Ch */ case    2:  		/* b -644 */
		/* 8209D88Ch case    2:*/		return 0x8209D608;
		/* 8209D88Ch case    2:*/		return 0x8209D890;
	}
	return 0x8209D890;
} // Block from 8209D884h-8209D890h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209D890h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D890);
		  /* 8209D890h */ case    0:  		/* mfspr R12, LR */
		/* 8209D890h case    0:*/		regs.R12 = regs.LR;
		/* 8209D890h case    0:*/		return 0x8209D894;
		  /* 8209D894h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209D894h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209D894h case    1:*/		return 0x8209D898;
		  /* 8209D898h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209D898h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209D898h case    2:*/		return 0x8209D89C;
		  /* 8209D89Ch */ case    3:  		/* cmpwi CR6, R3, 0 */
		/* 8209D89Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8209D89Ch case    3:*/		return 0x8209D8A0;
		  /* 8209D8A0h */ case    4:  		/* bc 12, CR6_LT, 88 */
		/* 8209D8A0h case    4:*/		if ( regs.CR[6].lt ) { return 0x8209D8F8;  }
		/* 8209D8A0h case    4:*/		return 0x8209D8A4;
		  /* 8209D8A4h */ case    5:  		/* lis R11, -32215 */
		/* 8209D8A4h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8209D8A4h case    5:*/		return 0x8209D8A8;
		  /* 8209D8A8h */ case    6:  		/* lwz R11, <#[R11 - 25512]> */
		/* 8209D8A8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFF9C58) );
		/* 8209D8A8h case    6:*/		return 0x8209D8AC;
		  /* 8209D8ACh */ case    7:  		/* cmplw CR6, R3, R11 */
		/* 8209D8ACh case    7:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8209D8ACh case    7:*/		return 0x8209D8B0;
		  /* 8209D8B0h */ case    8:  		/* bc 4, CR6_LT, 72 */
		/* 8209D8B0h case    8:*/		if ( !regs.CR[6].lt ) { return 0x8209D8F8;  }
		/* 8209D8B0h case    8:*/		return 0x8209D8B4;
		  /* 8209D8B4h */ case    9:  		/* srawi R11, R3, 5 */
		/* 8209D8B4h case    9:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R3);
		/* 8209D8B4h case    9:*/		return 0x8209D8B8;
		  /* 8209D8B8h */ case   10:  		/* lis R10, -32215 */
		/* 8209D8B8h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 8209D8B8h case   10:*/		return 0x8209D8BC;
		  /* 8209D8BCh */ case   11:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8209D8BCh case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8209D8BCh case   11:*/		return 0x8209D8C0;
		  /* 8209D8C0h */ case   12:  		/* addi R10, R10, -25504 */
		/* 8209D8C0h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFF9C60);
		/* 8209D8C0h case   12:*/		return 0x8209D8C4;
		  /* 8209D8C4h */ case   13:  		/* rlwinm R11, R3, 0, 27, 31 */
		/* 8209D8C4h case   13:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R3);
		/* 8209D8C4h case   13:*/		return 0x8209D8C8;
		  /* 8209D8C8h */ case   14:  		/* mulli R11, R11, 72 */
		/* 8209D8C8h case   14:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x48);
		/* 8209D8C8h case   14:*/		return 0x8209D8CC;
		  /* 8209D8CCh */ case   15:  		/* lwzx R10, <#[R9 + R10]> */
		/* 8209D8CCh case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8209D8CCh case   15:*/		return 0x8209D8D0;
		  /* 8209D8D0h */ case   16:  		/* add R11, R10, R11 */
		/* 8209D8D0h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8209D8D0h case   16:*/		return 0x8209D8D4;
		  /* 8209D8D4h */ case   17:  		/* lbz R10, <#[R11 + 4]> */
		/* 8209D8D4h case   17:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8209D8D4h case   17:*/		return 0x8209D8D8;
		  /* 8209D8D8h */ case   18:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 8209D8D8h case   18:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 8209D8D8h case   18:*/		return 0x8209D8DC;
		  /* 8209D8DCh */ case   19:  		/* bc 12, CR0_EQ, 28 */
		/* 8209D8DCh case   19:*/		if ( regs.CR[0].eq ) { return 0x8209D8F8;  }
		/* 8209D8DCh case   19:*/		return 0x8209D8E0;
		  /* 8209D8E0h */ case   20:  		/* lwz R10, <#[R11]> */
		/* 8209D8E0h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209D8E0h case   20:*/		return 0x8209D8E4;
		  /* 8209D8E4h */ case   21:  		/* cmpwi CR6, R10, -1 */
		/* 8209D8E4h case   21:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8209D8E4h case   21:*/		return 0x8209D8E8;
		  /* 8209D8E8h */ case   22:  		/* bc 12, CR6_EQ, 16 */
		/* 8209D8E8h case   22:*/		if ( regs.CR[6].eq ) { return 0x8209D8F8;  }
		/* 8209D8E8h case   22:*/		return 0x8209D8EC;
		  /* 8209D8ECh */ case   23:  		/* li R10, -1 */
		/* 8209D8ECh case   23:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8209D8ECh case   23:*/		return 0x8209D8F0;
		  /* 8209D8F0h */ case   24:  		/* li R3, 0 */
		/* 8209D8F0h case   24:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209D8F0h case   24:*/		return 0x8209D8F4;
		  /* 8209D8F4h */ case   25:  		/* b 32 */
		/* 8209D8F4h case   25:*/		return 0x8209D914;
		/* 8209D8F4h case   25:*/		return 0x8209D8F8;
	}
	return 0x8209D8F8;
} // Block from 8209D890h-8209D8F8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8209D8F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D8F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D8F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D8F8);
		  /* 8209D8F8h */ case    0:  		/* bl -35312 */
		/* 8209D8F8h case    0:*/		regs.LR = 0x8209D8FC; return 0x82094F08;
		/* 8209D8F8h case    0:*/		return 0x8209D8FC;
		  /* 8209D8FCh */ case    1:  		/* li R11, 9 */
		/* 8209D8FCh case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 8209D8FCh case    1:*/		return 0x8209D900;
		  /* 8209D900h */ case    2:  		/* stw R11, <#[R3]> */
		/* 8209D900h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209D900h case    2:*/		return 0x8209D904;
		  /* 8209D904h */ case    3:  		/* bl -35268 */
		/* 8209D904h case    3:*/		regs.LR = 0x8209D908; return 0x82094F40;
		/* 8209D904h case    3:*/		return 0x8209D908;
		  /* 8209D908h */ case    4:  		/* mr R11, R3 */
		/* 8209D908h case    4:*/		regs.R11 = regs.R3;
		/* 8209D908h case    4:*/		return 0x8209D90C;
		  /* 8209D90Ch */ case    5:  		/* li R10, 0 */
		/* 8209D90Ch case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8209D90Ch case    5:*/		return 0x8209D910;
		  /* 8209D910h */ case    6:  		/* li R3, -1 */
		/* 8209D910h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209D910h case    6:*/		return 0x8209D914;
	}
	return 0x8209D914;
} // Block from 8209D8F8h-8209D914h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209D914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D914);
		  /* 8209D914h */ case    0:  		/* stw R10, <#[R11]> */
		/* 8209D914h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209D914h case    0:*/		return 0x8209D918;
		  /* 8209D918h */ case    1:  		/* addi R1, R1, 96 */
		/* 8209D918h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209D918h case    1:*/		return 0x8209D91C;
		  /* 8209D91Ch */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209D91Ch case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209D91Ch case    2:*/		return 0x8209D920;
		  /* 8209D920h */ case    3:  		/* mtspr LR, R12 */
		/* 8209D920h case    3:*/		regs.LR = regs.R12;
		/* 8209D920h case    3:*/		return 0x8209D924;
		  /* 8209D924h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8209D924h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209D924h case    4:*/		return 0x8209D928;
	}
	return 0x8209D928;
} // Block from 8209D914h-8209D928h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209D928h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D928);
		  /* 8209D928h */ case    0:  		/* mfspr R12, LR */
		/* 8209D928h case    0:*/		regs.R12 = regs.LR;
		/* 8209D928h case    0:*/		return 0x8209D92C;
		  /* 8209D92Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209D92Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209D92Ch case    1:*/		return 0x8209D930;
		  /* 8209D930h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209D930h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209D930h case    2:*/		return 0x8209D934;
		  /* 8209D934h */ case    3:  		/* cmpwi CR6, R3, -2 */
		/* 8209D934h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFE);
		/* 8209D934h case    3:*/		return 0x8209D938;
		  /* 8209D938h */ case    4:  		/* bc 4, CR6_EQ, 40 */
		/* 8209D938h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8209D960;  }
		/* 8209D938h case    4:*/		return 0x8209D93C;
		  /* 8209D93Ch */ case    5:  		/* bl -35324 */
		/* 8209D93Ch case    5:*/		regs.LR = 0x8209D940; return 0x82094F40;
		/* 8209D93Ch case    5:*/		return 0x8209D940;
		  /* 8209D940h */ case    6:  		/* li R11, 0 */
		/* 8209D940h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209D940h case    6:*/		return 0x8209D944;
		  /* 8209D944h */ case    7:  		/* stw R11, <#[R3]> */
		/* 8209D944h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209D944h case    7:*/		return 0x8209D948;
		  /* 8209D948h */ case    8:  		/* bl -35392 */
		/* 8209D948h case    8:*/		regs.LR = 0x8209D94C; return 0x82094F08;
		/* 8209D948h case    8:*/		return 0x8209D94C;
		  /* 8209D94Ch */ case    9:  		/* mr R11, R3 */
		/* 8209D94Ch case    9:*/		regs.R11 = regs.R3;
		/* 8209D94Ch case    9:*/		return 0x8209D950;
		  /* 8209D950h */ case   10:  		/* li R10, 9 */
		/* 8209D950h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x9);
		/* 8209D950h case   10:*/		return 0x8209D954;
		  /* 8209D954h */ case   11:  		/* li R3, -1 */
		/* 8209D954h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209D954h case   11:*/		return 0x8209D958;
		  /* 8209D958h */ case   12:  		/* stw R10, <#[R11]> */
		/* 8209D958h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209D958h case   12:*/		return 0x8209D95C;
		  /* 8209D95Ch */ case   13:  		/* b 112 */
		/* 8209D95Ch case   13:*/		return 0x8209D9CC;
		/* 8209D95Ch case   13:*/		return 0x8209D960;
	}
	return 0x8209D960;
} // Block from 8209D928h-8209D960h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209D960h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D960);
		  /* 8209D960h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 8209D960h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8209D960h case    0:*/		return 0x8209D964;
		  /* 8209D964h */ case    1:  		/* bc 12, CR6_LT, 20 */
		/* 8209D964h case    1:*/		if ( regs.CR[6].lt ) { return 0x8209D978;  }
		/* 8209D964h case    1:*/		return 0x8209D968;
		  /* 8209D968h */ case    2:  		/* lis R11, -32215 */
		/* 8209D968h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8209D968h case    2:*/		return 0x8209D96C;
		  /* 8209D96Ch */ case    3:  		/* lwz R11, <#[R11 - 25512]> */
		/* 8209D96Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFF9C58) );
		/* 8209D96Ch case    3:*/		return 0x8209D970;
		  /* 8209D970h */ case    4:  		/* cmplw CR6, R3, R11 */
		/* 8209D970h case    4:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8209D970h case    4:*/		return 0x8209D974;
		  /* 8209D974h */ case    5:  		/* bc 12, CR6_LT, 40 */
		/* 8209D974h case    5:*/		if ( regs.CR[6].lt ) { return 0x8209D99C;  }
		/* 8209D974h case    5:*/		return 0x8209D978;
	}
	return 0x8209D978;
} // Block from 8209D960h-8209D978h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209D978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D978);
		  /* 8209D978h */ case    0:  		/* bl -35384 */
		/* 8209D978h case    0:*/		regs.LR = 0x8209D97C; return 0x82094F40;
		/* 8209D978h case    0:*/		return 0x8209D97C;
		  /* 8209D97Ch */ case    1:  		/* li R11, 0 */
		/* 8209D97Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209D97Ch case    1:*/		return 0x8209D980;
		  /* 8209D980h */ case    2:  		/* stw R11, <#[R3]> */
		/* 8209D980h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209D980h case    2:*/		return 0x8209D984;
		  /* 8209D984h */ case    3:  		/* bl -35452 */
		/* 8209D984h case    3:*/		regs.LR = 0x8209D988; return 0x82094F08;
		/* 8209D984h case    3:*/		return 0x8209D988;
		  /* 8209D988h */ case    4:  		/* li R11, 9 */
		/* 8209D988h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 8209D988h case    4:*/		return 0x8209D98C;
		  /* 8209D98Ch */ case    5:  		/* stw R11, <#[R3]> */
		/* 8209D98Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209D98Ch case    5:*/		return 0x8209D990;
		  /* 8209D990h */ case    6:  		/* bl -41008 */
		/* 8209D990h case    6:*/		regs.LR = 0x8209D994; return 0x82093960;
		/* 8209D990h case    6:*/		return 0x8209D994;
		  /* 8209D994h */ case    7:  		/* li R3, -1 */
		/* 8209D994h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209D994h case    7:*/		return 0x8209D998;
		  /* 8209D998h */ case    8:  		/* b 52 */
		/* 8209D998h case    8:*/		return 0x8209D9CC;
		/* 8209D998h case    8:*/		return 0x8209D99C;
	}
	return 0x8209D99C;
} // Block from 8209D978h-8209D99Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209D99Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D99C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D99C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D99C);
		  /* 8209D99Ch */ case    0:  		/* srawi R11, R3, 5 */
		/* 8209D99Ch case    0:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R3);
		/* 8209D99Ch case    0:*/		return 0x8209D9A0;
		  /* 8209D9A0h */ case    1:  		/* lis R10, -32215 */
		/* 8209D9A0h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 8209D9A0h case    1:*/		return 0x8209D9A4;
		  /* 8209D9A4h */ case    2:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8209D9A4h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8209D9A4h case    2:*/		return 0x8209D9A8;
		  /* 8209D9A8h */ case    3:  		/* addi R10, R10, -25504 */
		/* 8209D9A8h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFF9C60);
		/* 8209D9A8h case    3:*/		return 0x8209D9AC;
		  /* 8209D9ACh */ case    4:  		/* rlwinm R11, R3, 0, 27, 31 */
		/* 8209D9ACh case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R3);
		/* 8209D9ACh case    4:*/		return 0x8209D9B0;
		  /* 8209D9B0h */ case    5:  		/* mulli R11, R11, 72 */
		/* 8209D9B0h case    5:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x48);
		/* 8209D9B0h case    5:*/		return 0x8209D9B4;
		  /* 8209D9B4h */ case    6:  		/* lwzx R10, <#[R9 + R10]> */
		/* 8209D9B4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8209D9B4h case    6:*/		return 0x8209D9B8;
		  /* 8209D9B8h */ case    7:  		/* add R11, R10, R11 */
		/* 8209D9B8h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8209D9B8h case    7:*/		return 0x8209D9BC;
		  /* 8209D9BCh */ case    8:  		/* lbz R10, <#[R11 + 4]> */
		/* 8209D9BCh case    8:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8209D9BCh case    8:*/		return 0x8209D9C0;
		  /* 8209D9C0h */ case    9:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 8209D9C0h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 8209D9C0h case    9:*/		return 0x8209D9C4;
		  /* 8209D9C4h */ case   10:  		/* bc 12, CR0_EQ, -76 */
		/* 8209D9C4h case   10:*/		if ( regs.CR[0].eq ) { return 0x8209D978;  }
		/* 8209D9C4h case   10:*/		return 0x8209D9C8;
		  /* 8209D9C8h */ case   11:  		/* lwz R3, <#[R11]> */
		/* 8209D9C8h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 8209D9C8h case   11:*/		return 0x8209D9CC;
	}
	return 0x8209D9CC;
} // Block from 8209D99Ch-8209D9CCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 8209D9CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D9CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D9CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D9CC);
		  /* 8209D9CCh */ case    0:  		/* addi R1, R1, 96 */
		/* 8209D9CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209D9CCh case    0:*/		return 0x8209D9D0;
		  /* 8209D9D0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209D9D0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209D9D0h case    1:*/		return 0x8209D9D4;
		  /* 8209D9D4h */ case    2:  		/* mtspr LR, R12 */
		/* 8209D9D4h case    2:*/		regs.LR = regs.R12;
		/* 8209D9D4h case    2:*/		return 0x8209D9D8;
		  /* 8209D9D8h */ case    3:  		/* bclr 20, CR0_LT */
		/* 8209D9D8h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209D9D8h case    3:*/		return 0x8209D9DC;
	}
	return 0x8209D9DC;
} // Block from 8209D9CCh-8209D9DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209D9DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D9DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D9DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D9DC);
		  /* 8209D9DCh */ case    0:  		/* nop */
		/* 8209D9DCh case    0:*/		cpu::op::nop();
		/* 8209D9DCh case    0:*/		return 0x8209D9E0;
		  /* 8209D9E0h */ case    1:  		/* lwz R17, <#[R6 - 11576]> */
		/* 8209D9E0h case    1:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 8209D9E0h case    1:*/		return 0x8209D9E4;
		  /* 8209D9E4h */ case    2:  		/* lwz R16, <#[R4 - 15208]> */
		/* 8209D9E4h case    2:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC498) );
		/* 8209D9E4h case    2:*/		return 0x8209D9E8;
	}
	return 0x8209D9E8;
} // Block from 8209D9DCh-8209D9E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209D9E8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209D9E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209D9E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209D9E8);
		  /* 8209D9E8h */ case    0:  		/* mfspr R12, LR */
		/* 8209D9E8h case    0:*/		regs.R12 = regs.LR;
		/* 8209D9E8h case    0:*/		return 0x8209D9EC;
		  /* 8209D9ECh */ case    1:  		/* bl -51088 */
		/* 8209D9ECh case    1:*/		regs.LR = 0x8209D9F0; return 0x8209125C;
		/* 8209D9ECh case    1:*/		return 0x8209D9F0;
		  /* 8209D9F0h */ case    2:  		/* addi R31, R1, -128 */
		/* 8209D9F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFF80);
		/* 8209D9F0h case    2:*/		return 0x8209D9F4;
		  /* 8209D9F4h */ case    3:  		/* stwu R1, <#[R1 - 128]> */
		/* 8209D9F4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8209D9F4h case    3:*/		return 0x8209D9F8;
		  /* 8209D9F8h */ case    4:  		/* stw R3, <#[R31 + 148]> */
		/* 8209D9F8h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000094) );
		/* 8209D9F8h case    4:*/		return 0x8209D9FC;
		  /* 8209D9FCh */ case    5:  		/* lis R11, -32215 */
		/* 8209D9FCh case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8209D9FCh case    5:*/		return 0x8209DA00;
		  /* 8209DA00h */ case    6:  		/* srawi R10, R3, 5 */
		/* 8209DA00h case    6:*/		cpu::op::srawi<0,5>(regs,&regs.R10,regs.R3);
		/* 8209DA00h case    6:*/		return 0x8209DA04;
		  /* 8209DA04h */ case    7:  		/* addi R11, R11, -25504 */
		/* 8209DA04h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF9C60);
		/* 8209DA04h case    7:*/		return 0x8209DA08;
		  /* 8209DA08h */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8209DA08h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8209DA08h case    8:*/		return 0x8209DA0C;
		  /* 8209DA0Ch */ case    9:  		/* rlwinm R9, R3, 0, 27, 31 */
		/* 8209DA0Ch case    9:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R3);
		/* 8209DA0Ch case    9:*/		return 0x8209DA10;
		  /* 8209DA10h */ case   10:  		/* li R29, 1 */
		/* 8209DA10h case   10:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 8209DA10h case   10:*/		return 0x8209DA14;
		  /* 8209DA14h */ case   11:  		/* mulli R9, R9, 72 */
		/* 8209DA14h case   11:*/		cpu::op::mulli<0>(regs,&regs.R9,regs.R9,0x48);
		/* 8209DA14h case   11:*/		return 0x8209DA18;
		  /* 8209DA18h */ case   12:  		/* stw R29, <#[R31 + 80]> */
		/* 8209DA18h case   12:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000050) );
		/* 8209DA18h case   12:*/		return 0x8209DA1C;
		  /* 8209DA1Ch */ case   13:  		/* lwzx R10, <#[R10 + R11]> */
		/* 8209DA1Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8209DA1Ch case   13:*/		return 0x8209DA20;
		  /* 8209DA20h */ case   14:  		/* add R30, R10, R9 */
		/* 8209DA20h case   14:*/		cpu::op::add<0>(regs,&regs.R30,regs.R10,regs.R9);
		/* 8209DA20h case   14:*/		return 0x8209DA24;
		  /* 8209DA24h */ case   15:  		/* lwz R10, <#[R30 + 8]> */
		/* 8209DA24h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 8209DA24h case   15:*/		return 0x8209DA28;
		  /* 8209DA28h */ case   16:  		/* cmpwi CR6, R10, 0 */
		/* 8209DA28h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8209DA28h case   16:*/		return 0x8209DA2C;
		  /* 8209DA2Ch */ case   17:  		/* bc 4, CR6_EQ, 80 */
		/* 8209DA2Ch case   17:*/		if ( !regs.CR[6].eq ) { return 0x8209DA7C;  }
		/* 8209DA2Ch case   17:*/		return 0x8209DA30;
		  /* 8209DA30h */ case   18:  		/* li R3, 10 */
		/* 8209DA30h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0xA);
		/* 8209DA30h case   18:*/		return 0x8209DA34;
		  /* 8209DA34h */ case   19:  		/* bl -18396 */
		/* 8209DA34h case   19:*/		regs.LR = 0x8209DA38; return 0x82099258;
		/* 8209DA34h case   19:*/		return 0x8209DA38;
		  /* 8209DA38h */ case   20:  		/* nop */
		/* 8209DA38h case   20:*/		cpu::op::nop();
		/* 8209DA38h case   20:*/		return 0x8209DA3C;
	}
	return 0x8209DA3C;
} // Block from 8209D9E8h-8209DA3Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8209DA3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DA3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DA3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DA3C);
		  /* 8209DA3Ch */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 8209DA3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8209DA3Ch case    0:*/		return 0x8209DA40;
		  /* 8209DA40h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8209DA40h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8209DA40h case    1:*/		return 0x8209DA44;
		  /* 8209DA44h */ case    2:  		/* bc 4, CR6_EQ, 44 */
		/* 8209DA44h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8209DA70;  }
		/* 8209DA44h case    2:*/		return 0x8209DA48;
		  /* 8209DA48h */ case    3:  		/* li R4, 4000 */
		/* 8209DA48h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0xFA0);
		/* 8209DA48h case    3:*/		return 0x8209DA4C;
		  /* 8209DA4Ch */ case    4:  		/* addi R3, R30, 12 */
		/* 8209DA4Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0xC);
		/* 8209DA4Ch case    4:*/		return 0x8209DA50;
		  /* 8209DA50h */ case    5:  		/* bl -19032 */
		/* 8209DA50h case    5:*/		regs.LR = 0x8209DA54; return 0x82098FF8;
		/* 8209DA50h case    5:*/		return 0x8209DA54;
		  /* 8209DA54h */ case    6:  		/* subfic R11, R3, 0 */
		/* 8209DA54h case    6:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R3,0x0);
		/* 8209DA54h case    6:*/		return 0x8209DA58;
		  /* 8209DA58h */ case    7:  		/* subfe R11, R11, R11 */
		/* 8209DA58h case    7:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8209DA58h case    7:*/		return 0x8209DA5C;
		  /* 8209DA5Ch */ case    8:  		/* and R11, R11, R29 */
		/* 8209DA5Ch case    8:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8209DA5Ch case    8:*/		return 0x8209DA60;
		  /* 8209DA60h */ case    9:  		/* stw R11, <#[R31 + 80]> */
		/* 8209DA60h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8209DA60h case    9:*/		return 0x8209DA64;
		  /* 8209DA64h */ case   10:  		/* lwz R11, <#[R30 + 8]> */
		/* 8209DA64h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8209DA64h case   10:*/		return 0x8209DA68;
		  /* 8209DA68h */ case   11:  		/* addi R11, R11, 1 */
		/* 8209DA68h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209DA68h case   11:*/		return 0x8209DA6C;
		  /* 8209DA6Ch */ case   12:  		/* stw R11, <#[R30 + 8]> */
		/* 8209DA6Ch case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8209DA6Ch case   12:*/		return 0x8209DA70;
	}
	return 0x8209DA70;
} // Block from 8209DA3Ch-8209DA70h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209DA70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DA70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DA70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DA70);
		  /* 8209DA70h */ case    0:  		/* nop */
		/* 8209DA70h case    0:*/		cpu::op::nop();
		/* 8209DA70h case    0:*/		return 0x8209DA74;
		  /* 8209DA74h */ case    1:  		/* addi R12, R31, 128 */
		/* 8209DA74h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R31,0x80);
		/* 8209DA74h case    1:*/		return 0x8209DA78;
		  /* 8209DA78h */ case    2:  		/* bl 56 */
		/* 8209DA78h case    2:*/		regs.LR = 0x8209DA7C; return 0x8209DAB0;
		/* 8209DA78h case    2:*/		return 0x8209DA7C;
	}
	return 0x8209DA7C;
} // Block from 8209DA70h-8209DA7Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209DA7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DA7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DA7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DA7C);
		  /* 8209DA7Ch */ case    0:  		/* cmpwi CR6, R29, 0 */
		/* 8209DA7Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 8209DA7Ch case    0:*/		return 0x8209DA80;
		  /* 8209DA80h */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 8209DA80h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209DAA4;  }
		/* 8209DA80h case    1:*/		return 0x8209DA84;
		  /* 8209DA84h */ case    2:  		/* srawi R10, R3, 5 */
		/* 8209DA84h case    2:*/		cpu::op::srawi<0,5>(regs,&regs.R10,regs.R3);
		/* 8209DA84h case    2:*/		return 0x8209DA88;
		  /* 8209DA88h */ case    3:  		/* rlwinm R9, R3, 0, 27, 31 */
		/* 8209DA88h case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R3);
		/* 8209DA88h case    3:*/		return 0x8209DA8C;
		  /* 8209DA8Ch */ case    4:  		/* rlwinm R8, R10, 2, 0, 29 */
		/* 8209DA8Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R10);
		/* 8209DA8Ch case    4:*/		return 0x8209DA90;
		  /* 8209DA90h */ case    5:  		/* mulli R10, R9, 72 */
		/* 8209DA90h case    5:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R9,0x48);
		/* 8209DA90h case    5:*/		return 0x8209DA94;
		  /* 8209DA94h */ case    6:  		/* lwzx R11, <#[R8 + R11]> */
		/* 8209DA94h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8209DA94h case    6:*/		return 0x8209DA98;
		  /* 8209DA98h */ case    7:  		/* add R11, R11, R10 */
		/* 8209DA98h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8209DA98h case    7:*/		return 0x8209DA9C;
		  /* 8209DA9Ch */ case    8:  		/* addi R3, R11, 12 */
		/* 8209DA9Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xC);
		/* 8209DA9Ch case    8:*/		return 0x8209DAA0;
		  /* 8209DAA0h */ case    9:  		/* bl 1897880 */
		/* 8209DAA0h case    9:*/		regs.LR = 0x8209DAA4; return 0x8226D038;
		/* 8209DAA0h case    9:*/		return 0x8209DAA4;
	}
	return 0x8209DAA4;
} // Block from 8209DA7Ch-8209DAA4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209DAA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DAA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DAA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DAA4);
		  /* 8209DAA4h */ case    0:  		/* mr R3, R29 */
		/* 8209DAA4h case    0:*/		regs.R3 = regs.R29;
		/* 8209DAA4h case    0:*/		return 0x8209DAA8;
		  /* 8209DAA8h */ case    1:  		/* addi R1, R31, 128 */
		/* 8209DAA8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0x80);
		/* 8209DAA8h case    1:*/		return 0x8209DAAC;
		  /* 8209DAACh */ case    2:  		/* b -51200 */
		/* 8209DAACh case    2:*/		return 0x820912AC;
		/* 8209DAACh case    2:*/		return 0x8209DAB0;
	}
	return 0x8209DAB0;
} // Block from 8209DAA4h-8209DAB0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209DAB0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DAB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DAB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DAB0);
		  /* 8209DAB0h */ case    0:  		/* mfspr R12, LR */
		/* 8209DAB0h case    0:*/		regs.R12 = regs.LR;
		/* 8209DAB0h case    0:*/		return 0x8209DAB4;
		  /* 8209DAB4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209DAB4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209DAB4h case    1:*/		return 0x8209DAB8;
		  /* 8209DAB8h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209DAB8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209DAB8h case    2:*/		return 0x8209DABC;
		  /* 8209DABCh */ case    3:  		/* li R3, 10 */
		/* 8209DABCh case    3:*/		cpu::op::li<0>(regs,&regs.R3,0xA);
		/* 8209DABCh case    3:*/		return 0x8209DAC0;
		  /* 8209DAC0h */ case    4:  		/* bl -19176 */
		/* 8209DAC0h case    4:*/		regs.LR = 0x8209DAC4; return 0x82098FD8;
		/* 8209DAC0h case    4:*/		return 0x8209DAC4;
		  /* 8209DAC4h */ case    5:  		/* lis R11, -32215 */
		/* 8209DAC4h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8209DAC4h case    5:*/		return 0x8209DAC8;
		  /* 8209DAC8h */ case    6:  		/* lwz R3, <#[R31 + 148]> */
		/* 8209DAC8h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000094) );
		/* 8209DAC8h case    6:*/		return 0x8209DACC;
		  /* 8209DACCh */ case    7:  		/* lwz R29, <#[R31 + 80]> */
		/* 8209DACCh case    7:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000050) );
		/* 8209DACCh case    7:*/		return 0x8209DAD0;
		  /* 8209DAD0h */ case    8:  		/* addi R11, R11, -25504 */
		/* 8209DAD0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF9C60);
		/* 8209DAD0h case    8:*/		return 0x8209DAD4;
		  /* 8209DAD4h */ case    9:  		/* lwz R1, <#[R1]> */
		/* 8209DAD4h case    9:*/		cpu::mem::load32z( regs, &regs.R1, (uint32)(regs.R1 + 0x00000000) );
		/* 8209DAD4h case    9:*/		return 0x8209DAD8;
		  /* 8209DAD8h */ case   10:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209DAD8h case   10:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209DAD8h case   10:*/		return 0x8209DADC;
		  /* 8209DADCh */ case   11:  		/* mtspr LR, R12 */
		/* 8209DADCh case   11:*/		regs.LR = regs.R12;
		/* 8209DADCh case   11:*/		return 0x8209DAE0;
		  /* 8209DAE0h */ case   12:  		/* bclr 20, CR0_LT */
		/* 8209DAE0h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209DAE0h case   12:*/		return 0x8209DAE4;
	}
	return 0x8209DAE4;
} // Block from 8209DAB0h-8209DAE4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209DAE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DAE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DAE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DAE4);
		  /* 8209DAE4h */ case    0:  		/* nop */
		/* 8209DAE4h case    0:*/		cpu::op::nop();
		/* 8209DAE4h case    0:*/		return 0x8209DAE8;
	}
	return 0x8209DAE8;
} // Block from 8209DAE4h-8209DAE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209DAE8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DAE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DAE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DAE8);
		  /* 8209DAE8h */ case    0:  		/* srawi R11, R3, 5 */
		/* 8209DAE8h case    0:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R3);
		/* 8209DAE8h case    0:*/		return 0x8209DAEC;
		  /* 8209DAECh */ case    1:  		/* lis R10, -32215 */
		/* 8209DAECh case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 8209DAECh case    1:*/		return 0x8209DAF0;
		  /* 8209DAF0h */ case    2:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8209DAF0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8209DAF0h case    2:*/		return 0x8209DAF4;
		  /* 8209DAF4h */ case    3:  		/* addi R10, R10, -25504 */
		/* 8209DAF4h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFF9C60);
		/* 8209DAF4h case    3:*/		return 0x8209DAF8;
		  /* 8209DAF8h */ case    4:  		/* rlwinm R11, R3, 0, 27, 31 */
		/* 8209DAF8h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R3);
		/* 8209DAF8h case    4:*/		return 0x8209DAFC;
		  /* 8209DAFCh */ case    5:  		/* mulli R11, R11, 72 */
		/* 8209DAFCh case    5:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x48);
		/* 8209DAFCh case    5:*/		return 0x8209DB00;
		  /* 8209DB00h */ case    6:  		/* lwzx R10, <#[R9 + R10]> */
		/* 8209DB00h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8209DB00h case    6:*/		return 0x8209DB04;
		  /* 8209DB04h */ case    7:  		/* add R11, R10, R11 */
		/* 8209DB04h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8209DB04h case    7:*/		return 0x8209DB08;
		  /* 8209DB08h */ case    8:  		/* addi R3, R11, 12 */
		/* 8209DB08h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xC);
		/* 8209DB08h case    8:*/		return 0x8209DB0C;
		  /* 8209DB0Ch */ case    9:  		/* b 1897756 */
		/* 8209DB0Ch case    9:*/		return 0x8226D028;
		/* 8209DB0Ch case    9:*/		return 0x8209DB10;
		  /* 8209DB10h */ case   10:  		/* lwz R17, <#[R6 - 11576]> */
		/* 8209DB10h case   10:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 8209DB10h case   10:*/		return 0x8209DB14;
		  /* 8209DB14h */ case   11:  		/* lwz R16, <#[R4 - 15184]> */
		/* 8209DB14h case   11:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC4B0) );
		/* 8209DB14h case   11:*/		return 0x8209DB18;
	}
	return 0x8209DB18;
} // Block from 8209DAE8h-8209DB18h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8209DB18h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DB18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DB18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DB18);
		  /* 8209DB18h */ case    0:  		/* mfspr R12, LR */
		/* 8209DB18h case    0:*/		regs.R12 = regs.LR;
		/* 8209DB18h case    0:*/		return 0x8209DB1C;
		  /* 8209DB1Ch */ case    1:  		/* bl -51404 */
		/* 8209DB1Ch case    1:*/		regs.LR = 0x8209DB20; return 0x82091250;
		/* 8209DB1Ch case    1:*/		return 0x8209DB20;
		  /* 8209DB20h */ case    2:  		/* addi R31, R1, -144 */
		/* 8209DB20h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFF70);
		/* 8209DB20h case    2:*/		return 0x8209DB24;
		  /* 8209DB24h */ case    3:  		/* stwu R1, <#[R1 - 144]> */
		/* 8209DB24h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8209DB24h case    3:*/		return 0x8209DB28;
		  /* 8209DB28h */ case    4:  		/* li R26, 0 */
		/* 8209DB28h case    4:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8209DB28h case    4:*/		return 0x8209DB2C;
		  /* 8209DB2Ch */ case    5:  		/* li R3, 1 */
		/* 8209DB2Ch case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8209DB2Ch case    5:*/		return 0x8209DB30;
		  /* 8209DB30h */ case    6:  		/* stw R26, <#[R31 + 80]> */
		/* 8209DB30h case    6:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000050) );
		/* 8209DB30h case    6:*/		return 0x8209DB34;
		  /* 8209DB34h */ case    7:  		/* bl -18652 */
		/* 8209DB34h case    7:*/		regs.LR = 0x8209DB38; return 0x82099258;
		/* 8209DB34h case    7:*/		return 0x8209DB38;
		  /* 8209DB38h */ case    8:  		/* nop */
		/* 8209DB38h case    8:*/		cpu::op::nop();
		/* 8209DB38h case    8:*/		return 0x8209DB3C;
	}
	return 0x8209DB3C;
} // Block from 8209DB18h-8209DB3Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209DB3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DB3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DB3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DB3C);
		  /* 8209DB3Ch */ case    0:  		/* li R28, 3 */
		/* 8209DB3Ch case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x3);
		/* 8209DB3Ch case    0:*/		return 0x8209DB40;
		  /* 8209DB40h */ case    1:  		/* lis R29, -32215 */
		/* 8209DB40h case    1:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8229);
		/* 8209DB40h case    1:*/		return 0x8209DB44;
		  /* 8209DB44h */ case    2:  		/* lis R27, -32215 */
		/* 8209DB44h case    2:*/		cpu::op::lis<0>(regs,&regs.R27,0xFFFF8229);
		/* 8209DB44h case    2:*/		return 0x8209DB48;
		  /* 8209DB48h */ case    3:  		/* stw R28, <#[R31 + 84]> */
		/* 8209DB48h case    3:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000054) );
		/* 8209DB48h case    3:*/		return 0x8209DB4C;
		  /* 8209DB4Ch */ case    4:  		/* lwz R11, <#[R27 - 25516]> */
		/* 8209DB4Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFF9C54) );
		/* 8209DB4Ch case    4:*/		return 0x8209DB50;
		  /* 8209DB50h */ case    5:  		/* cmpw CR6, R28, R11 */
		/* 8209DB50h case    5:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R11);
		/* 8209DB50h case    5:*/		return 0x8209DB54;
		  /* 8209DB54h */ case    6:  		/* bc 4, CR6_LT, 108 */
		/* 8209DB54h case    6:*/		if ( !regs.CR[6].lt ) { return 0x8209DBC0;  }
		/* 8209DB54h case    6:*/		return 0x8209DB58;
		  /* 8209DB58h */ case    7:  		/* lwz R11, <#[R29 - 25520]> */
		/* 8209DB58h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0xFFFF9C50) );
		/* 8209DB58h case    7:*/		return 0x8209DB5C;
		  /* 8209DB5Ch */ case    8:  		/* rlwinm R30, R28, 2, 0, 29 */
		/* 8209DB5Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R28);
		/* 8209DB5Ch case    8:*/		return 0x8209DB60;
		  /* 8209DB60h */ case    9:  		/* lwzx R10, <#[R30 + R11]> */
		/* 8209DB60h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8209DB60h case    9:*/		return 0x8209DB64;
		  /* 8209DB64h */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 8209DB64h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8209DB64h case   10:*/		return 0x8209DB68;
		  /* 8209DB68h */ case   11:  		/* bc 12, CR6_EQ, 76 */
		/* 8209DB68h case   11:*/		if ( regs.CR[6].eq ) { return 0x8209DBB4;  }
		/* 8209DB68h case   11:*/		return 0x8209DB6C;
		  /* 8209DB6Ch */ case   12:  		/* rlwinm R3, R10, 0, 0, 31 */
		/* 8209DB6Ch case   12:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R10);
		/* 8209DB6Ch case   12:*/		return 0x8209DB70;
		  /* 8209DB70h */ case   13:  		/* lwz R11, <#[R3 + 12]> */
		/* 8209DB70h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8209DB70h case   13:*/		return 0x8209DB74;
		  /* 8209DB74h */ case   14:  		/* andi. R11, R11, 131 */
		/* 8209DB74h case   14:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x83);
		/* 8209DB74h case   14:*/		return 0x8209DB78;
		  /* 8209DB78h */ case   15:  		/* cmpwi CR0, R11, 0 */
		/* 8209DB78h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 8209DB78h case   15:*/		return 0x8209DB7C;
		  /* 8209DB7Ch */ case   16:  		/* bc 12, CR0_EQ, 24 */
		/* 8209DB7Ch case   16:*/		if ( regs.CR[0].eq ) { return 0x8209DB94;  }
		/* 8209DB7Ch case   16:*/		return 0x8209DB80;
		  /* 8209DB80h */ case   17:  		/* bl 2600 */
		/* 8209DB80h case   17:*/		regs.LR = 0x8209DB84; return 0x8209E5A8;
		/* 8209DB80h case   17:*/		return 0x8209DB84;
		  /* 8209DB84h */ case   18:  		/* cmpwi CR6, R3, -1 */
		/* 8209DB84h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8209DB84h case   18:*/		return 0x8209DB88;
		  /* 8209DB88h */ case   19:  		/* bc 12, CR6_EQ, 12 */
		/* 8209DB88h case   19:*/		if ( regs.CR[6].eq ) { return 0x8209DB94;  }
		/* 8209DB88h case   19:*/		return 0x8209DB8C;
		  /* 8209DB8Ch */ case   20:  		/* addi R26, R26, 1 */
		/* 8209DB8Ch case   20:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 8209DB8Ch case   20:*/		return 0x8209DB90;
		  /* 8209DB90h */ case   21:  		/* stw R26, <#[R31 + 80]> */
		/* 8209DB90h case   21:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000050) );
		/* 8209DB90h case   21:*/		return 0x8209DB94;
	}
	return 0x8209DB94;
} // Block from 8209DB3Ch-8209DB94h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8209DB94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DB94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DB94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DB94);
		  /* 8209DB94h */ case    0:  		/* cmpwi CR6, R28, 20 */
		/* 8209DB94h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000014);
		/* 8209DB94h case    0:*/		return 0x8209DB98;
		  /* 8209DB98h */ case    1:  		/* bc 12, CR6_LT, 28 */
		/* 8209DB98h case    1:*/		if ( regs.CR[6].lt ) { return 0x8209DBB4;  }
		/* 8209DB98h case    1:*/		return 0x8209DB9C;
		  /* 8209DB9Ch */ case    2:  		/* lwz R11, <#[R29 - 25520]> */
		/* 8209DB9Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0xFFFF9C50) );
		/* 8209DB9Ch case    2:*/		return 0x8209DBA0;
		  /* 8209DBA0h */ case    3:  		/* lwzx R3, <#[R30 + R11]> */
		/* 8209DBA0h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8209DBA0h case    3:*/		return 0x8209DBA4;
		  /* 8209DBA4h */ case    4:  		/* bl -41852 */
		/* 8209DBA4h case    4:*/		regs.LR = 0x8209DBA8; return 0x82093828;
		/* 8209DBA4h case    4:*/		return 0x8209DBA8;
		  /* 8209DBA8h */ case    5:  		/* lwz R11, <#[R29 - 25520]> */
		/* 8209DBA8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0xFFFF9C50) );
		/* 8209DBA8h case    5:*/		return 0x8209DBAC;
		  /* 8209DBACh */ case    6:  		/* li R10, 0 */
		/* 8209DBACh case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8209DBACh case    6:*/		return 0x8209DBB0;
		  /* 8209DBB0h */ case    7:  		/* stwx R10, <#[R30 + R11]> */
		/* 8209DBB0h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8209DBB0h case    7:*/		return 0x8209DBB4;
	}
	return 0x8209DBB4;
} // Block from 8209DB94h-8209DBB4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209DBB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DBB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DBB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DBB4);
		  /* 8209DBB4h */ case    0:  		/* nop */
		/* 8209DBB4h case    0:*/		cpu::op::nop();
		/* 8209DBB4h case    0:*/		return 0x8209DBB8;
		  /* 8209DBB8h */ case    1:  		/* addi R28, R28, 1 */
		/* 8209DBB8h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8209DBB8h case    1:*/		return 0x8209DBBC;
		  /* 8209DBBCh */ case    2:  		/* b -116 */
		/* 8209DBBCh case    2:*/		return 0x8209DB48;
		/* 8209DBBCh case    2:*/		return 0x8209DBC0;
	}
	return 0x8209DBC0;
} // Block from 8209DBB4h-8209DBC0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209DBC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DBC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DBC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DBC0);
		  /* 8209DBC0h */ case    0:  		/* nop */
		/* 8209DBC0h case    0:*/		cpu::op::nop();
		/* 8209DBC0h case    0:*/		return 0x8209DBC4;
		  /* 8209DBC4h */ case    1:  		/* addi R12, R31, 144 */
		/* 8209DBC4h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R31,0x90);
		/* 8209DBC4h case    1:*/		return 0x8209DBC8;
		  /* 8209DBC8h */ case    2:  		/* bl 16 */
		/* 8209DBC8h case    2:*/		regs.LR = 0x8209DBCC; return 0x8209DBD8;
		/* 8209DBC8h case    2:*/		return 0x8209DBCC;
		  /* 8209DBCCh */ case    3:  		/* lwz R3, <#[R31 + 80]> */
		/* 8209DBCCh case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 8209DBCCh case    3:*/		return 0x8209DBD0;
		  /* 8209DBD0h */ case    4:  		/* addi R1, R31, 144 */
		/* 8209DBD0h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0x90);
		/* 8209DBD0h case    4:*/		return 0x8209DBD4;
		  /* 8209DBD4h */ case    5:  		/* b -51508 */
		/* 8209DBD4h case    5:*/		return 0x820912A0;
		/* 8209DBD4h case    5:*/		return 0x8209DBD8;
	}
	return 0x8209DBD8;
} // Block from 8209DBC0h-8209DBD8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209DBD8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DBD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DBD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DBD8);
		  /* 8209DBD8h */ case    0:  		/* mfspr R12, LR */
		/* 8209DBD8h case    0:*/		regs.R12 = regs.LR;
		/* 8209DBD8h case    0:*/		return 0x8209DBDC;
		  /* 8209DBDCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209DBDCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209DBDCh case    1:*/		return 0x8209DBE0;
		  /* 8209DBE0h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209DBE0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209DBE0h case    2:*/		return 0x8209DBE4;
		  /* 8209DBE4h */ case    3:  		/* li R3, 1 */
		/* 8209DBE4h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8209DBE4h case    3:*/		return 0x8209DBE8;
		  /* 8209DBE8h */ case    4:  		/* bl -19472 */
		/* 8209DBE8h case    4:*/		regs.LR = 0x8209DBEC; return 0x82098FD8;
		/* 8209DBE8h case    4:*/		return 0x8209DBEC;
		  /* 8209DBECh */ case    5:  		/* lwz R1, <#[R1]> */
		/* 8209DBECh case    5:*/		cpu::mem::load32z( regs, &regs.R1, (uint32)(regs.R1 + 0x00000000) );
		/* 8209DBECh case    5:*/		return 0x8209DBF0;
		  /* 8209DBF0h */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209DBF0h case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209DBF0h case    6:*/		return 0x8209DBF4;
		  /* 8209DBF4h */ case    7:  		/* mtspr LR, R12 */
		/* 8209DBF4h case    7:*/		regs.LR = regs.R12;
		/* 8209DBF4h case    7:*/		return 0x8209DBF8;
		  /* 8209DBF8h */ case    8:  		/* bclr 20, CR0_LT */
		/* 8209DBF8h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209DBF8h case    8:*/		return 0x8209DBFC;
	}
	return 0x8209DBFC;
} // Block from 8209DBD8h-8209DBFCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209DBFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DBFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DBFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DBFC);
		  /* 8209DBFCh */ case    0:  		/* nop */
		/* 8209DBFCh case    0:*/		cpu::op::nop();
		/* 8209DBFCh case    0:*/		return 0x8209DC00;
	}
	return 0x8209DC00;
} // Block from 8209DBFCh-8209DC00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209DC00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DC00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DC00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DC00);
		  /* 8209DC00h */ case    0:  		/* mfspr R12, LR */
		/* 8209DC00h case    0:*/		regs.R12 = regs.LR;
		/* 8209DC00h case    0:*/		return 0x8209DC04;
		  /* 8209DC04h */ case    1:  		/* bl -51628 */
		/* 8209DC04h case    1:*/		regs.LR = 0x8209DC08; return 0x82091258;
		/* 8209DC04h case    1:*/		return 0x8209DC08;
		  /* 8209DC08h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8209DC08h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8209DC08h case    2:*/		return 0x8209DC0C;
		  /* 8209DC0Ch */ case    3:  		/* lwz R11, <#[R3 + 12]> */
		/* 8209DC0Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8209DC0Ch case    3:*/		return 0x8209DC10;
		  /* 8209DC10h */ case    4:  		/* mr R31, R3 */
		/* 8209DC10h case    4:*/		regs.R31 = regs.R3;
		/* 8209DC10h case    4:*/		return 0x8209DC14;
		  /* 8209DC14h */ case    5:  		/* li R28, 0 */
		/* 8209DC14h case    5:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8209DC14h case    5:*/		return 0x8209DC18;
		  /* 8209DC18h */ case    6:  		/* rlwinm R10, R11, 0, 30, 31 */
		/* 8209DC18h case    6:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R11);
		/* 8209DC18h case    6:*/		return 0x8209DC1C;
		  /* 8209DC1Ch */ case    7:  		/* cmpwi CR6, R10, 2 */
		/* 8209DC1Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000002);
		/* 8209DC1Ch case    7:*/		return 0x8209DC20;
		  /* 8209DC20h */ case    8:  		/* bc 4, CR6_EQ, 88 */
		/* 8209DC20h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8209DC78;  }
		/* 8209DC20h case    8:*/		return 0x8209DC24;
		  /* 8209DC24h */ case    9:  		/* andi. R11, R11, 264 */
		/* 8209DC24h case    9:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x108);
		/* 8209DC24h case    9:*/		return 0x8209DC28;
		  /* 8209DC28h */ case   10:  		/* cmpwi CR0, R11, 0 */
		/* 8209DC28h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 8209DC28h case   10:*/		return 0x8209DC2C;
		  /* 8209DC2Ch */ case   11:  		/* bc 12, CR0_EQ, 76 */
		/* 8209DC2Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x8209DC78;  }
		/* 8209DC2Ch case   11:*/		return 0x8209DC30;
		  /* 8209DC30h */ case   12:  		/* lwz R29, <#[R3 + 8]> */
		/* 8209DC30h case   12:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000008) );
		/* 8209DC30h case   12:*/		return 0x8209DC34;
		  /* 8209DC34h */ case   13:  		/* lwz R11, <#[R3]> */
		/* 8209DC34h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209DC34h case   13:*/		return 0x8209DC38;
		  /* 8209DC38h */ case   14:  		/* subf. R30, R29, R11 */
		/* 8209DC38h case   14:*/		cpu::op::subf<1>(regs,&regs.R30,regs.R29,regs.R11);
		/* 8209DC38h case   14:*/		return 0x8209DC3C;
		  /* 8209DC3Ch */ case   15:  		/* bc 4, CR0_GT, 60 */
		/* 8209DC3Ch case   15:*/		if ( !regs.CR[0].gt ) { return 0x8209DC78;  }
		/* 8209DC3Ch case   15:*/		return 0x8209DC40;
		  /* 8209DC40h */ case   16:  		/* bl -12992 */
		/* 8209DC40h case   16:*/		regs.LR = 0x8209DC44; return 0x8209A980;
		/* 8209DC40h case   16:*/		return 0x8209DC44;
		  /* 8209DC44h */ case   17:  		/* mr R4, R29 */
		/* 8209DC44h case   17:*/		regs.R4 = regs.R29;
		/* 8209DC44h case   17:*/		return 0x8209DC48;
		  /* 8209DC48h */ case   18:  		/* mr R5, R30 */
		/* 8209DC48h case   18:*/		regs.R5 = regs.R30;
		/* 8209DC48h case   18:*/		return 0x8209DC4C;
		  /* 8209DC4Ch */ case   19:  		/* bl -14196 */
		/* 8209DC4Ch case   19:*/		regs.LR = 0x8209DC50; return 0x8209A4D8;
		/* 8209DC4Ch case   19:*/		return 0x8209DC50;
		  /* 8209DC50h */ case   20:  		/* lwz R11, <#[R31 + 12]> */
		/* 8209DC50h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209DC50h case   20:*/		return 0x8209DC54;
		  /* 8209DC54h */ case   21:  		/* cmpw CR6, R3, R30 */
		/* 8209DC54h case   21:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R30);
		/* 8209DC54h case   21:*/		return 0x8209DC58;
		  /* 8209DC58h */ case   22:  		/* bc 4, CR6_EQ, 20 */
		/* 8209DC58h case   22:*/		if ( !regs.CR[6].eq ) { return 0x8209DC6C;  }
		/* 8209DC58h case   22:*/		return 0x8209DC5C;
		  /* 8209DC5Ch */ case   23:  		/* rlwinm. R10, R11, 0, 24, 24 */
		/* 8209DC5Ch case   23:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R10,regs.R11);
		/* 8209DC5Ch case   23:*/		return 0x8209DC60;
		  /* 8209DC60h */ case   24:  		/* bc 12, CR0_EQ, 24 */
		/* 8209DC60h case   24:*/		if ( regs.CR[0].eq ) { return 0x8209DC78;  }
		/* 8209DC60h case   24:*/		return 0x8209DC64;
		  /* 8209DC64h */ case   25:  		/* rlwinm R11, R11, 0, 31, 29 */
		/* 8209DC64h case   25:*/		cpu::op::rlwinm<0,0,31,29>(regs,&regs.R11,regs.R11);
		/* 8209DC64h case   25:*/		return 0x8209DC68;
		  /* 8209DC68h */ case   26:  		/* b 12 */
		/* 8209DC68h case   26:*/		return 0x8209DC74;
		/* 8209DC68h case   26:*/		return 0x8209DC6C;
	}
	return 0x8209DC6C;
} // Block from 8209DC00h-8209DC6Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 8209DC6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DC6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DC6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DC6C);
		  /* 8209DC6Ch */ case    0:  		/* li R28, -1 */
		/* 8209DC6Ch case    0:*/		cpu::op::li<0>(regs,&regs.R28,0xFFFFFFFF);
		/* 8209DC6Ch case    0:*/		return 0x8209DC70;
		  /* 8209DC70h */ case    1:  		/* ori R11, R11, 32 */
		/* 8209DC70h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x20);
		/* 8209DC70h case    1:*/		return 0x8209DC74;
	}
	return 0x8209DC74;
} // Block from 8209DC6Ch-8209DC74h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209DC74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DC74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DC74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DC74);
		  /* 8209DC74h */ case    0:  		/* stw R11, <#[R31 + 12]> */
		/* 8209DC74h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209DC74h case    0:*/		return 0x8209DC78;
	}
	return 0x8209DC78;
} // Block from 8209DC74h-8209DC78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209DC78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DC78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DC78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DC78);
		  /* 8209DC78h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8209DC78h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8209DC78h case    0:*/		return 0x8209DC7C;
		  /* 8209DC7Ch */ case    1:  		/* li R10, 0 */
		/* 8209DC7Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8209DC7Ch case    1:*/		return 0x8209DC80;
		  /* 8209DC80h */ case    2:  		/* mr R3, R28 */
		/* 8209DC80h case    2:*/		regs.R3 = regs.R28;
		/* 8209DC80h case    2:*/		return 0x8209DC84;
		  /* 8209DC84h */ case    3:  		/* stw R10, <#[R31 + 4]> */
		/* 8209DC84h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8209DC84h case    3:*/		return 0x8209DC88;
		  /* 8209DC88h */ case    4:  		/* stw R11, <#[R31]> */
		/* 8209DC88h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209DC88h case    4:*/		return 0x8209DC8C;
		  /* 8209DC8Ch */ case    5:  		/* addi R1, R1, 128 */
		/* 8209DC8Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8209DC8Ch case    5:*/		return 0x8209DC90;
		  /* 8209DC90h */ case    6:  		/* b -51688 */
		/* 8209DC90h case    6:*/		return 0x820912A8;
		/* 8209DC90h case    6:*/		return 0x8209DC94;
		  /* 8209DC94h */ case    7:  		/* nop */
		/* 8209DC94h case    7:*/		cpu::op::nop();
		/* 8209DC94h case    7:*/		return 0x8209DC98;
	}
	return 0x8209DC98;
} // Block from 8209DC78h-8209DC98h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209DC98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DC98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DC98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DC98);
		  /* 8209DC98h */ case    0:  		/* mfspr R12, LR */
		/* 8209DC98h case    0:*/		regs.R12 = regs.LR;
		/* 8209DC98h case    0:*/		return 0x8209DC9C;
		  /* 8209DC9Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209DC9Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209DC9Ch case    1:*/		return 0x8209DCA0;
		  /* 8209DCA0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8209DCA0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209DCA0h case    2:*/		return 0x8209DCA4;
		  /* 8209DCA4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209DCA4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209DCA4h case    3:*/		return 0x8209DCA8;
		  /* 8209DCA8h */ case    4:  		/* mr R31, R3 */
		/* 8209DCA8h case    4:*/		regs.R31 = regs.R3;
		/* 8209DCA8h case    4:*/		return 0x8209DCAC;
		  /* 8209DCACh */ case    5:  		/* cmplwi CR6, R3, 0 */
		/* 8209DCACh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209DCACh case    5:*/		return 0x8209DCB0;
		  /* 8209DCB0h */ case    6:  		/* bc 4, CR6_EQ, 12 */
		/* 8209DCB0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8209DCBC;  }
		/* 8209DCB0h case    6:*/		return 0x8209DCB4;
		  /* 8209DCB4h */ case    7:  		/* bl 100 */
		/* 8209DCB4h case    7:*/		regs.LR = 0x8209DCB8; return 0x8209DD18;
		/* 8209DCB4h case    7:*/		return 0x8209DCB8;
		  /* 8209DCB8h */ case    8:  		/* b 68 */
		/* 8209DCB8h case    8:*/		return 0x8209DCFC;
		/* 8209DCB8h case    8:*/		return 0x8209DCBC;
	}
	return 0x8209DCBC;
} // Block from 8209DC98h-8209DCBCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209DCBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DCBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DCBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DCBC);
		  /* 8209DCBCh */ case    0:  		/* mr R3, R31 */
		/* 8209DCBCh case    0:*/		regs.R3 = regs.R31;
		/* 8209DCBCh case    0:*/		return 0x8209DCC0;
		  /* 8209DCC0h */ case    1:  		/* bl -192 */
		/* 8209DCC0h case    1:*/		regs.LR = 0x8209DCC4; return 0x8209DC00;
		/* 8209DCC0h case    1:*/		return 0x8209DCC4;
		  /* 8209DCC4h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 8209DCC4h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209DCC4h case    2:*/		return 0x8209DCC8;
		  /* 8209DCC8h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 8209DCC8h case    3:*/		if ( regs.CR[0].eq ) { return 0x8209DCD4;  }
		/* 8209DCC8h case    3:*/		return 0x8209DCCC;
		  /* 8209DCCCh */ case    4:  		/* li R3, -1 */
		/* 8209DCCCh case    4:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209DCCCh case    4:*/		return 0x8209DCD0;
		  /* 8209DCD0h */ case    5:  		/* b 44 */
		/* 8209DCD0h case    5:*/		return 0x8209DCFC;
		/* 8209DCD0h case    5:*/		return 0x8209DCD4;
	}
	return 0x8209DCD4;
} // Block from 8209DCBCh-8209DCD4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209DCD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DCD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DCD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DCD4);
		  /* 8209DCD4h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8209DCD4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209DCD4h case    0:*/		return 0x8209DCD8;
		  /* 8209DCD8h */ case    1:  		/* rlwinm. R11, R11, 0, 17, 17 */
		/* 8209DCD8h case    1:*/		cpu::op::rlwinm<1,0,17,17>(regs,&regs.R11,regs.R11);
		/* 8209DCD8h case    1:*/		return 0x8209DCDC;
		  /* 8209DCDCh */ case    2:  		/* bc 12, CR0_EQ, 28 */
		/* 8209DCDCh case    2:*/		if ( regs.CR[0].eq ) { return 0x8209DCF8;  }
		/* 8209DCDCh case    2:*/		return 0x8209DCE0;
		  /* 8209DCE0h */ case    3:  		/* mr R3, R31 */
		/* 8209DCE0h case    3:*/		regs.R3 = regs.R31;
		/* 8209DCE0h case    3:*/		return 0x8209DCE4;
		  /* 8209DCE4h */ case    4:  		/* bl -13156 */
		/* 8209DCE4h case    4:*/		regs.LR = 0x8209DCE8; return 0x8209A980;
		/* 8209DCE4h case    4:*/		return 0x8209DCE8;
		  /* 8209DCE8h */ case    5:  		/* bl 2504 */
		/* 8209DCE8h case    5:*/		regs.LR = 0x8209DCEC; return 0x8209E6B0;
		/* 8209DCE8h case    5:*/		return 0x8209DCEC;
		  /* 8209DCECh */ case    6:  		/* subfic R11, R3, 0 */
		/* 8209DCECh case    6:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R3,0x0);
		/* 8209DCECh case    6:*/		return 0x8209DCF0;
		  /* 8209DCF0h */ case    7:  		/* subfe R3, R11, R11 */
		/* 8209DCF0h case    7:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R11,regs.R11);
		/* 8209DCF0h case    7:*/		return 0x8209DCF4;
		  /* 8209DCF4h */ case    8:  		/* b 8 */
		/* 8209DCF4h case    8:*/		return 0x8209DCFC;
		/* 8209DCF4h case    8:*/		return 0x8209DCF8;
	}
	return 0x8209DCF8;
} // Block from 8209DCD4h-8209DCF8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209DCF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DCF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DCF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DCF8);
		  /* 8209DCF8h */ case    0:  		/* li R3, 0 */
		/* 8209DCF8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209DCF8h case    0:*/		return 0x8209DCFC;
	}
	return 0x8209DCFC;
} // Block from 8209DCF8h-8209DCFCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209DCFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DCFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DCFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DCFC);
		  /* 8209DCFCh */ case    0:  		/* addi R1, R1, 96 */
		/* 8209DCFCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209DCFCh case    0:*/		return 0x8209DD00;
		  /* 8209DD00h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209DD00h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209DD00h case    1:*/		return 0x8209DD04;
		  /* 8209DD04h */ case    2:  		/* mtspr LR, R12 */
		/* 8209DD04h case    2:*/		regs.LR = regs.R12;
		/* 8209DD04h case    2:*/		return 0x8209DD08;
		  /* 8209DD08h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8209DD08h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209DD08h case    3:*/		return 0x8209DD0C;
		  /* 8209DD0Ch */ case    4:  		/* bclr 20, CR0_LT */
		/* 8209DD0Ch case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209DD0Ch case    4:*/		return 0x8209DD10;
	}
	return 0x8209DD10;
} // Block from 8209DCFCh-8209DD10h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209DD10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DD10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DD10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DD10);
		  /* 8209DD10h */ case    0:  		/* lwz R17, <#[R6 - 11576]> */
		/* 8209DD10h case    0:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 8209DD10h case    0:*/		return 0x8209DD14;
		  /* 8209DD14h */ case    1:  		/* lwz R16, <#[R4 - 15160]> */
		/* 8209DD14h case    1:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC4C8) );
		/* 8209DD14h case    1:*/		return 0x8209DD18;
	}
	return 0x8209DD18;
} // Block from 8209DD10h-8209DD18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209DD18h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DD18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DD18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DD18);
		  /* 8209DD18h */ case    0:  		/* mfspr R12, LR */
		/* 8209DD18h case    0:*/		regs.R12 = regs.LR;
		/* 8209DD18h case    0:*/		return 0x8209DD1C;
		  /* 8209DD1Ch */ case    1:  		/* bl -51912 */
		/* 8209DD1Ch case    1:*/		regs.LR = 0x8209DD20; return 0x82091254;
		/* 8209DD1Ch case    1:*/		return 0x8209DD20;
		  /* 8209DD20h */ case    2:  		/* addi R31, R1, -144 */
		/* 8209DD20h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFF70);
		/* 8209DD20h case    2:*/		return 0x8209DD24;
		  /* 8209DD24h */ case    3:  		/* stwu R1, <#[R1 - 144]> */
		/* 8209DD24h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8209DD24h case    3:*/		return 0x8209DD28;
		  /* 8209DD28h */ case    4:  		/* mr R27, R3 */
		/* 8209DD28h case    4:*/		regs.R27 = regs.R3;
		/* 8209DD28h case    4:*/		return 0x8209DD2C;
		  /* 8209DD2Ch */ case    5:  		/* stw R3, <#[R31 + 164]> */
		/* 8209DD2Ch case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000000A4) );
		/* 8209DD2Ch case    5:*/		return 0x8209DD30;
		  /* 8209DD30h */ case    6:  		/* li R28, 0 */
		/* 8209DD30h case    6:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8209DD30h case    6:*/		return 0x8209DD34;
		  /* 8209DD34h */ case    7:  		/* li R3, 1 */
		/* 8209DD34h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8209DD34h case    7:*/		return 0x8209DD38;
		  /* 8209DD38h */ case    8:  		/* stw R28, <#[R31 + 84]> */
		/* 8209DD38h case    8:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000054) );
		/* 8209DD38h case    8:*/		return 0x8209DD3C;
		  /* 8209DD3Ch */ case    9:  		/* stw R28, <#[R31 + 88]> */
		/* 8209DD3Ch case    9:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000058) );
		/* 8209DD3Ch case    9:*/		return 0x8209DD40;
		  /* 8209DD40h */ case   10:  		/* bl -19176 */
		/* 8209DD40h case   10:*/		regs.LR = 0x8209DD44; return 0x82099258;
		/* 8209DD40h case   10:*/		return 0x8209DD44;
		  /* 8209DD44h */ case   11:  		/* nop */
		/* 8209DD44h case   11:*/		cpu::op::nop();
		/* 8209DD44h case   11:*/		return 0x8209DD48;
	}
	return 0x8209DD48;
} // Block from 8209DD18h-8209DD48h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8209DD48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DD48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DD48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DD48);
		  /* 8209DD48h */ case    0:  		/* lis R11, -32215 */
		/* 8209DD48h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8209DD48h case    0:*/		return 0x8209DD4C;
		  /* 8209DD4Ch */ case    1:  		/* lis R10, -32215 */
		/* 8209DD4Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 8209DD4Ch case    1:*/		return 0x8209DD50;
		  /* 8209DD50h */ case    2:  		/* addi R29, R11, -25520 */
		/* 8209DD50h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFF9C50);
		/* 8209DD50h case    2:*/		return 0x8209DD54;
		  /* 8209DD54h */ case    3:  		/* addi R10, R10, -25516 */
		/* 8209DD54h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFF9C54);
		/* 8209DD54h case    3:*/		return 0x8209DD58;
		  /* 8209DD58h */ case    4:  		/* stw R28, <#[R31 + 80]> */
		/* 8209DD58h case    4:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000050) );
		/* 8209DD58h case    4:*/		return 0x8209DD5C;
		  /* 8209DD5Ch */ case    5:  		/* lwz R11, <#[R10]> */
		/* 8209DD5Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8209DD5Ch case    5:*/		return 0x8209DD60;
		  /* 8209DD60h */ case    6:  		/* cmpw CR6, R28, R11 */
		/* 8209DD60h case    6:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R11);
		/* 8209DD60h case    6:*/		return 0x8209DD64;
		  /* 8209DD64h */ case    7:  		/* bc 4, CR6_LT, 176 */
		/* 8209DD64h case    7:*/		if ( !regs.CR[6].lt ) { return 0x8209DE14;  }
		/* 8209DD64h case    7:*/		return 0x8209DD68;
		  /* 8209DD68h */ case    8:  		/* lwz R11, <#[R29]> */
		/* 8209DD68h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8209DD68h case    8:*/		return 0x8209DD6C;
		  /* 8209DD6Ch */ case    9:  		/* rlwinm R30, R28, 2, 0, 29 */
		/* 8209DD6Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R28);
		/* 8209DD6Ch case    9:*/		return 0x8209DD70;
		  /* 8209DD70h */ case   10:  		/* lwzx R9, <#[R30 + R11]> */
		/* 8209DD70h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8209DD70h case   10:*/		return 0x8209DD74;
		  /* 8209DD74h */ case   11:  		/* cmplwi CR6, R9, 0 */
		/* 8209DD74h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8209DD74h case   11:*/		return 0x8209DD78;
		  /* 8209DD78h */ case   12:  		/* bc 12, CR6_EQ, 144 */
		/* 8209DD78h case   12:*/		if ( regs.CR[6].eq ) { return 0x8209DE08;  }
		/* 8209DD78h case   12:*/		return 0x8209DD7C;
		  /* 8209DD7Ch */ case   13:  		/* rlwinm R4, R9, 0, 0, 31 */
		/* 8209DD7Ch case   13:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R4,regs.R9);
		/* 8209DD7Ch case   13:*/		return 0x8209DD80;
		  /* 8209DD80h */ case   14:  		/* lwz R11, <#[R4 + 12]> */
		/* 8209DD80h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 8209DD80h case   14:*/		return 0x8209DD84;
		  /* 8209DD84h */ case   15:  		/* andi. R11, R11, 131 */
		/* 8209DD84h case   15:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x83);
		/* 8209DD84h case   15:*/		return 0x8209DD88;
		  /* 8209DD88h */ case   16:  		/* cmpwi CR0, R11, 0 */
		/* 8209DD88h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 8209DD88h case   16:*/		return 0x8209DD8C;
		  /* 8209DD8Ch */ case   17:  		/* bc 12, CR0_EQ, 124 */
		/* 8209DD8Ch case   17:*/		if ( regs.CR[0].eq ) { return 0x8209DE08;  }
		/* 8209DD8Ch case   17:*/		return 0x8209DD90;
		  /* 8209DD90h */ case   18:  		/* mr R3, R28 */
		/* 8209DD90h case   18:*/		regs.R3 = regs.R28;
		/* 8209DD90h case   18:*/		return 0x8209DD94;
		  /* 8209DD94h */ case   19:  		/* bl -13516 */
		/* 8209DD94h case   19:*/		regs.LR = 0x8209DD98; return 0x8209A8C8;
		/* 8209DD94h case   19:*/		return 0x8209DD98;
		  /* 8209DD98h */ case   20:  		/* nop */
		/* 8209DD98h case   20:*/		cpu::op::nop();
		/* 8209DD98h case   20:*/		return 0x8209DD9C;
	}
	return 0x8209DD9C;
} // Block from 8209DD48h-8209DD9Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8209DD9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DD9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DD9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DD9C);
		  /* 8209DD9Ch */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8209DD9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8209DD9Ch case    0:*/		return 0x8209DDA0;
		  /* 8209DDA0h */ case    1:  		/* lwzx R3, <#[R30 + R11]> */
		/* 8209DDA0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8209DDA0h case    1:*/		return 0x8209DDA4;
		  /* 8209DDA4h */ case    2:  		/* lwz R11, <#[R3 + 12]> */
		/* 8209DDA4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8209DDA4h case    2:*/		return 0x8209DDA8;
		  /* 8209DDA8h */ case    3:  		/* andi. R10, R11, 131 */
		/* 8209DDA8h case    3:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0x83);
		/* 8209DDA8h case    3:*/		return 0x8209DDAC;
		  /* 8209DDACh */ case    4:  		/* cmpwi CR0, R10, 0 */
		/* 8209DDACh case    4:*/		cpu::op::cmpwi<0>(regs,regs.R10,0x00000000);
		/* 8209DDACh case    4:*/		return 0x8209DDB0;
		  /* 8209DDB0h */ case    5:  		/* bc 12, CR0_EQ, 76 */
		/* 8209DDB0h case    5:*/		if ( regs.CR[0].eq ) { return 0x8209DDFC;  }
		/* 8209DDB0h case    5:*/		return 0x8209DDB4;
		  /* 8209DDB4h */ case    6:  		/* cmpwi CR6, R27, 1 */
		/* 8209DDB4h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000001);
		/* 8209DDB4h case    6:*/		return 0x8209DDB8;
		  /* 8209DDB8h */ case    7:  		/* bc 4, CR6_EQ, 32 */
		/* 8209DDB8h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8209DDD8;  }
		/* 8209DDB8h case    7:*/		return 0x8209DDBC;
		  /* 8209DDBCh */ case    8:  		/* bl -292 */
		/* 8209DDBCh case    8:*/		regs.LR = 0x8209DDC0; return 0x8209DC98;
		/* 8209DDBCh case    8:*/		return 0x8209DDC0;
		  /* 8209DDC0h */ case    9:  		/* cmpwi CR6, R3, -1 */
		/* 8209DDC0h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8209DDC0h case    9:*/		return 0x8209DDC4;
		  /* 8209DDC4h */ case   10:  		/* bc 12, CR6_EQ, 56 */
		/* 8209DDC4h case   10:*/		if ( regs.CR[6].eq ) { return 0x8209DDFC;  }
		/* 8209DDC4h case   10:*/		return 0x8209DDC8;
		  /* 8209DDC8h */ case   11:  		/* lwz R11, <#[R31 + 84]> */
		/* 8209DDC8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 8209DDC8h case   11:*/		return 0x8209DDCC;
		  /* 8209DDCCh */ case   12:  		/* addi R11, R11, 1 */
		/* 8209DDCCh case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209DDCCh case   12:*/		return 0x8209DDD0;
		  /* 8209DDD0h */ case   13:  		/* stw R11, <#[R31 + 84]> */
		/* 8209DDD0h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 8209DDD0h case   13:*/		return 0x8209DDD4;
		  /* 8209DDD4h */ case   14:  		/* b 40 */
		/* 8209DDD4h case   14:*/		return 0x8209DDFC;
		/* 8209DDD4h case   14:*/		return 0x8209DDD8;
	}
	return 0x8209DDD8;
} // Block from 8209DD9Ch-8209DDD8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8209DDD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DDD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DDD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DDD8);
		  /* 8209DDD8h */ case    0:  		/* cmpwi CR6, R27, 0 */
		/* 8209DDD8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 8209DDD8h case    0:*/		return 0x8209DDDC;
		  /* 8209DDDCh */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 8209DDDCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209DDFC;  }
		/* 8209DDDCh case    1:*/		return 0x8209DDE0;
		  /* 8209DDE0h */ case    2:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 8209DDE0h case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 8209DDE0h case    2:*/		return 0x8209DDE4;
		  /* 8209DDE4h */ case    3:  		/* bc 12, CR0_EQ, 24 */
		/* 8209DDE4h case    3:*/		if ( regs.CR[0].eq ) { return 0x8209DDFC;  }
		/* 8209DDE4h case    3:*/		return 0x8209DDE8;
		  /* 8209DDE8h */ case    4:  		/* bl -336 */
		/* 8209DDE8h case    4:*/		regs.LR = 0x8209DDEC; return 0x8209DC98;
		/* 8209DDE8h case    4:*/		return 0x8209DDEC;
		  /* 8209DDECh */ case    5:  		/* cmpwi CR6, R3, -1 */
		/* 8209DDECh case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8209DDECh case    5:*/		return 0x8209DDF0;
		  /* 8209DDF0h */ case    6:  		/* bc 4, CR6_EQ, 12 */
		/* 8209DDF0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8209DDFC;  }
		/* 8209DDF0h case    6:*/		return 0x8209DDF4;
		  /* 8209DDF4h */ case    7:  		/* li R11, -1 */
		/* 8209DDF4h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 8209DDF4h case    7:*/		return 0x8209DDF8;
		  /* 8209DDF8h */ case    8:  		/* stw R11, <#[R31 + 88]> */
		/* 8209DDF8h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 8209DDF8h case    8:*/		return 0x8209DDFC;
	}
	return 0x8209DDFC;
} // Block from 8209DDD8h-8209DDFCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209DDFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DDFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DDFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DDFC);
		  /* 8209DDFCh */ case    0:  		/* nop */
		/* 8209DDFCh case    0:*/		cpu::op::nop();
		/* 8209DDFCh case    0:*/		return 0x8209DE00;
		  /* 8209DE00h */ case    1:  		/* addi R12, R31, 144 */
		/* 8209DE00h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R31,0x90);
		/* 8209DE00h case    1:*/		return 0x8209DE04;
		  /* 8209DE04h */ case    2:  		/* bl 136 */
		/* 8209DE04h case    2:*/		regs.LR = 0x8209DE08; return 0x8209DE8C;
		/* 8209DE04h case    2:*/		return 0x8209DE08;
	}
	return 0x8209DE08;
} // Block from 8209DDFCh-8209DE08h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209DE08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DE08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DE08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DE08);
		  /* 8209DE08h */ case    0:  		/* nop */
		/* 8209DE08h case    0:*/		cpu::op::nop();
		/* 8209DE08h case    0:*/		return 0x8209DE0C;
		  /* 8209DE0Ch */ case    1:  		/* addi R28, R28, 1 */
		/* 8209DE0Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8209DE0Ch case    1:*/		return 0x8209DE10;
		  /* 8209DE10h */ case    2:  		/* b -184 */
		/* 8209DE10h case    2:*/		return 0x8209DD58;
		/* 8209DE10h case    2:*/		return 0x8209DE14;
	}
	return 0x8209DE14;
} // Block from 8209DE08h-8209DE14h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209DE14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DE14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DE14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DE14);
		  /* 8209DE14h */ case    0:  		/* nop */
		/* 8209DE14h case    0:*/		cpu::op::nop();
		/* 8209DE14h case    0:*/		return 0x8209DE18;
		  /* 8209DE18h */ case    1:  		/* addi R12, R31, 144 */
		/* 8209DE18h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R31,0x90);
		/* 8209DE18h case    1:*/		return 0x8209DE1C;
		  /* 8209DE1Ch */ case    2:  		/* bl 32 */
		/* 8209DE1Ch case    2:*/		regs.LR = 0x8209DE20; return 0x8209DE3C;
		/* 8209DE1Ch case    2:*/		return 0x8209DE20;
		  /* 8209DE20h */ case    3:  		/* lwz R11, <#[R31 + 164]> */
		/* 8209DE20h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000A4) );
		/* 8209DE20h case    3:*/		return 0x8209DE24;
		  /* 8209DE24h */ case    4:  		/* cmpwi CR6, R11, 1 */
		/* 8209DE24h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 8209DE24h case    4:*/		return 0x8209DE28;
		  /* 8209DE28h */ case    5:  		/* lwz R3, <#[R31 + 84]> */
		/* 8209DE28h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000054) );
		/* 8209DE28h case    5:*/		return 0x8209DE2C;
		  /* 8209DE2Ch */ case    6:  		/* bc 12, CR6_EQ, 8 */
		/* 8209DE2Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x8209DE34;  }
		/* 8209DE2Ch case    6:*/		return 0x8209DE30;
		  /* 8209DE30h */ case    7:  		/* lwz R3, <#[R31 + 88]> */
		/* 8209DE30h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000058) );
		/* 8209DE30h case    7:*/		return 0x8209DE34;
	}
	return 0x8209DE34;
} // Block from 8209DE14h-8209DE34h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209DE34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DE34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DE34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DE34);
		  /* 8209DE34h */ case    0:  		/* addi R1, R31, 144 */
		/* 8209DE34h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0x90);
		/* 8209DE34h case    0:*/		return 0x8209DE38;
		  /* 8209DE38h */ case    1:  		/* b -52116 */
		/* 8209DE38h case    1:*/		return 0x820912A4;
		/* 8209DE38h case    1:*/		return 0x8209DE3C;
	}
	return 0x8209DE3C;
} // Block from 8209DE34h-8209DE3Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209DE3Ch
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DE3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DE3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DE3C);
		  /* 8209DE3Ch */ case    0:  		/* mfspr R12, LR */
		/* 8209DE3Ch case    0:*/		regs.R12 = regs.LR;
		/* 8209DE3Ch case    0:*/		return 0x8209DE40;
		  /* 8209DE40h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209DE40h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209DE40h case    1:*/		return 0x8209DE44;
		  /* 8209DE44h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209DE44h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209DE44h case    2:*/		return 0x8209DE48;
		  /* 8209DE48h */ case    3:  		/* li R3, 1 */
		/* 8209DE48h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8209DE48h case    3:*/		return 0x8209DE4C;
		  /* 8209DE4Ch */ case    4:  		/* bl -20084 */
		/* 8209DE4Ch case    4:*/		regs.LR = 0x8209DE50; return 0x82098FD8;
		/* 8209DE4Ch case    4:*/		return 0x8209DE50;
		  /* 8209DE50h */ case    5:  		/* lwz R1, <#[R1]> */
		/* 8209DE50h case    5:*/		cpu::mem::load32z( regs, &regs.R1, (uint32)(regs.R1 + 0x00000000) );
		/* 8209DE50h case    5:*/		return 0x8209DE54;
		  /* 8209DE54h */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209DE54h case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209DE54h case    6:*/		return 0x8209DE58;
		  /* 8209DE58h */ case    7:  		/* mtspr LR, R12 */
		/* 8209DE58h case    7:*/		regs.LR = regs.R12;
		/* 8209DE58h case    7:*/		return 0x8209DE5C;
		  /* 8209DE5Ch */ case    8:  		/* bclr 20, CR0_LT */
		/* 8209DE5Ch case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209DE5Ch case    8:*/		return 0x8209DE60;
	}
	return 0x8209DE60;
} // Block from 8209DE3Ch-8209DE60h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209DE60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DE60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DE60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DE60);
		  /* 8209DE60h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8209DE60h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209DE60h case    0:*/		return 0x8209DE64;
		  /* 8209DE64h */ case    1:  		/* addi R31, R12, -144 */
		/* 8209DE64h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFF70);
		/* 8209DE64h case    1:*/		return 0x8209DE68;
		  /* 8209DE68h */ case    2:  		/* std R29, <#[R1 - 16]> */
		/* 8209DE68h case    2:*/		cpu::mem::store64( regs, regs.R29, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209DE68h case    2:*/		return 0x8209DE6C;
		  /* 8209DE6Ch */ case    3:  		/* std R28, <#[R1 - 24]> */
		/* 8209DE6Ch case    3:*/		cpu::mem::store64( regs, regs.R28, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209DE6Ch case    3:*/		return 0x8209DE70;
		  /* 8209DE70h */ case    4:  		/* mfspr R12, LR */
		/* 8209DE70h case    4:*/		regs.R12 = regs.LR;
		/* 8209DE70h case    4:*/		return 0x8209DE74;
		  /* 8209DE74h */ case    5:  		/* stw R12, <#[R1 - 32]> */
		/* 8209DE74h case    5:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 8209DE74h case    5:*/		return 0x8209DE78;
		  /* 8209DE78h */ case    6:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209DE78h case    6:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209DE78h case    6:*/		return 0x8209DE7C;
		  /* 8209DE7Ch */ case    7:  		/* lis R11, -32215 */
		/* 8209DE7Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8209DE7Ch case    7:*/		return 0x8209DE80;
		  /* 8209DE80h */ case    8:  		/* lwz R28, <#[R31 + 80]> */
		/* 8209DE80h case    8:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000050) );
		/* 8209DE80h case    8:*/		return 0x8209DE84;
		  /* 8209DE84h */ case    9:  		/* addi R29, R11, -25520 */
		/* 8209DE84h case    9:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFF9C50);
		/* 8209DE84h case    9:*/		return 0x8209DE88;
		  /* 8209DE88h */ case   10:  		/* b 32 */
		/* 8209DE88h case   10:*/		return 0x8209DEA8;
		/* 8209DE88h case   10:*/		return 0x8209DE8C;
	}
	return 0x8209DE8C;
} // Block from 8209DE60h-8209DE8Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209DE8Ch
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DE8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DE8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DE8C);
		  /* 8209DE8Ch */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8209DE8Ch case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209DE8Ch case    0:*/		return 0x8209DE90;
		  /* 8209DE90h */ case    1:  		/* addi R31, R12, -144 */
		/* 8209DE90h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFF70);
		/* 8209DE90h case    1:*/		return 0x8209DE94;
		  /* 8209DE94h */ case    2:  		/* std R29, <#[R1 - 16]> */
		/* 8209DE94h case    2:*/		cpu::mem::store64( regs, regs.R29, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209DE94h case    2:*/		return 0x8209DE98;
		  /* 8209DE98h */ case    3:  		/* std R28, <#[R1 - 24]> */
		/* 8209DE98h case    3:*/		cpu::mem::store64( regs, regs.R28, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209DE98h case    3:*/		return 0x8209DE9C;
		  /* 8209DE9Ch */ case    4:  		/* mfspr R12, LR */
		/* 8209DE9Ch case    4:*/		regs.R12 = regs.LR;
		/* 8209DE9Ch case    4:*/		return 0x8209DEA0;
		  /* 8209DEA0h */ case    5:  		/* stw R12, <#[R1 - 32]> */
		/* 8209DEA0h case    5:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 8209DEA0h case    5:*/		return 0x8209DEA4;
		  /* 8209DEA4h */ case    6:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209DEA4h case    6:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209DEA4h case    6:*/		return 0x8209DEA8;
	}
	return 0x8209DEA8;
} // Block from 8209DE8Ch-8209DEA8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209DEA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DEA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DEA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DEA8);
		  /* 8209DEA8h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8209DEA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8209DEA8h case    0:*/		return 0x8209DEAC;
		  /* 8209DEACh */ case    1:  		/* rlwinm R10, R28, 2, 0, 29 */
		/* 8209DEACh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R28);
		/* 8209DEACh case    1:*/		return 0x8209DEB0;
		  /* 8209DEB0h */ case    2:  		/* mr R3, R28 */
		/* 8209DEB0h case    2:*/		regs.R3 = regs.R28;
		/* 8209DEB0h case    2:*/		return 0x8209DEB4;
		  /* 8209DEB4h */ case    3:  		/* lwzx R4, <#[R10 + R11]> */
		/* 8209DEB4h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8209DEB4h case    3:*/		return 0x8209DEB8;
		  /* 8209DEB8h */ case    4:  		/* bl -13664 */
		/* 8209DEB8h case    4:*/		regs.LR = 0x8209DEBC; return 0x8209A958;
		/* 8209DEB8h case    4:*/		return 0x8209DEBC;
		  /* 8209DEBCh */ case    5:  		/* lis R10, -32215 */
		/* 8209DEBCh case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 8209DEBCh case    5:*/		return 0x8209DEC0;
		  /* 8209DEC0h */ case    6:  		/* lwz R27, <#[R31 + 164]> */
		/* 8209DEC0h case    6:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R31 + 0x000000A4) );
		/* 8209DEC0h case    6:*/		return 0x8209DEC4;
		  /* 8209DEC4h */ case    7:  		/* lis R11, -32215 */
		/* 8209DEC4h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8209DEC4h case    7:*/		return 0x8209DEC8;
		  /* 8209DEC8h */ case    8:  		/* lwz R28, <#[R31 + 80]> */
		/* 8209DEC8h case    8:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000050) );
		/* 8209DEC8h case    8:*/		return 0x8209DECC;
		  /* 8209DECCh */ case    9:  		/* addi R29, R10, -25520 */
		/* 8209DECCh case    9:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R10,0xFFFF9C50);
		/* 8209DECCh case    9:*/		return 0x8209DED0;
		  /* 8209DED0h */ case   10:  		/* addi R10, R11, -25516 */
		/* 8209DED0h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFF9C54);
		/* 8209DED0h case   10:*/		return 0x8209DED4;
		  /* 8209DED4h */ case   11:  		/* lwz R1, <#[R1]> */
		/* 8209DED4h case   11:*/		cpu::mem::load32z( regs, &regs.R1, (uint32)(regs.R1 + 0x00000000) );
		/* 8209DED4h case   11:*/		return 0x8209DED8;
		  /* 8209DED8h */ case   12:  		/* ld R31, <#[R1 - 8]> */
		/* 8209DED8h case   12:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209DED8h case   12:*/		return 0x8209DEDC;
		  /* 8209DEDCh */ case   13:  		/* ld R29, <#[R1 - 16]> */
		/* 8209DEDCh case   13:*/		cpu::mem::load64( regs, &regs.R29, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209DEDCh case   13:*/		return 0x8209DEE0;
		  /* 8209DEE0h */ case   14:  		/* ld R28, <#[R1 - 24]> */
		/* 8209DEE0h case   14:*/		cpu::mem::load64( regs, &regs.R28, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209DEE0h case   14:*/		return 0x8209DEE4;
		  /* 8209DEE4h */ case   15:  		/* lwz R12, <#[R1 - 32]> */
		/* 8209DEE4h case   15:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 8209DEE4h case   15:*/		return 0x8209DEE8;
		  /* 8209DEE8h */ case   16:  		/* mtspr LR, R12 */
		/* 8209DEE8h case   16:*/		regs.LR = regs.R12;
		/* 8209DEE8h case   16:*/		return 0x8209DEEC;
		  /* 8209DEECh */ case   17:  		/* bclr 20, CR0_LT */
		/* 8209DEECh case   17:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209DEECh case   17:*/		return 0x8209DEF0;
	}
	return 0x8209DEF0;
} // Block from 8209DEA8h-8209DEF0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8209DEF0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DEF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DEF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DEF0);
		  /* 8209DEF0h */ case    0:  		/* li R3, 1 */
		/* 8209DEF0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8209DEF0h case    0:*/		return 0x8209DEF4;
		  /* 8209DEF4h */ case    1:  		/* b -476 */
		/* 8209DEF4h case    1:*/		return 0x8209DD18;
		/* 8209DEF4h case    1:*/		return 0x8209DEF8;
	}
	return 0x8209DEF8;
} // Block from 8209DEF0h-8209DEF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209DEF8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DEF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DEF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DEF8);
		  /* 8209DEF8h */ case    0:  		/* mfspr R12, LR */
		/* 8209DEF8h case    0:*/		regs.R12 = regs.LR;
		/* 8209DEF8h case    0:*/		return 0x8209DEFC;
		  /* 8209DEFCh */ case    1:  		/* bl -52392 */
		/* 8209DEFCh case    1:*/		regs.LR = 0x8209DF00; return 0x82091254;
		/* 8209DEFCh case    1:*/		return 0x8209DF00;
		  /* 8209DF00h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8209DF00h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8209DF00h case    2:*/		return 0x8209DF04;
		  /* 8209DF04h */ case    3:  		/* mr R27, R3 */
		/* 8209DF04h case    3:*/		regs.R27 = regs.R3;
		/* 8209DF04h case    3:*/		return 0x8209DF08;
		  /* 8209DF08h */ case    4:  		/* mr R3, R4 */
		/* 8209DF08h case    4:*/		regs.R3 = regs.R4;
		/* 8209DF08h case    4:*/		return 0x8209DF0C;
		  /* 8209DF0Ch */ case    5:  		/* mr R31, R4 */
		/* 8209DF0Ch case    5:*/		regs.R31 = regs.R4;
		/* 8209DF0Ch case    5:*/		return 0x8209DF10;
		  /* 8209DF10h */ case    6:  		/* bl -13712 */
		/* 8209DF10h case    6:*/		regs.LR = 0x8209DF14; return 0x8209A980;
		/* 8209DF10h case    6:*/		return 0x8209DF14;
		  /* 8209DF14h */ case    7:  		/* lwz R11, <#[R31 + 12]> */
		/* 8209DF14h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209DF14h case    7:*/		return 0x8209DF18;
		  /* 8209DF18h */ case    8:  		/* mr R29, R3 */
		/* 8209DF18h case    8:*/		regs.R29 = regs.R3;
		/* 8209DF18h case    8:*/		return 0x8209DF1C;
		  /* 8209DF1Ch */ case    9:  		/* andi. R10, R11, 130 */
		/* 8209DF1Ch case    9:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0x82);
		/* 8209DF1Ch case    9:*/		return 0x8209DF20;
		  /* 8209DF20h */ case   10:  		/* cmpwi CR0, R10, 0 */
		/* 8209DF20h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R10,0x00000000);
		/* 8209DF20h case   10:*/		return 0x8209DF24;
		  /* 8209DF24h */ case   11:  		/* bc 4, CR0_EQ, 44 */
		/* 8209DF24h case   11:*/		if ( !regs.CR[0].eq ) { return 0x8209DF50;  }
		/* 8209DF24h case   11:*/		return 0x8209DF28;
		  /* 8209DF28h */ case   12:  		/* bl -36896 */
		/* 8209DF28h case   12:*/		regs.LR = 0x8209DF2C; return 0x82094F08;
		/* 8209DF28h case   12:*/		return 0x8209DF2C;
		  /* 8209DF2Ch */ case   13:  		/* li R10, 9 */
		/* 8209DF2Ch case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x9);
		/* 8209DF2Ch case   13:*/		return 0x8209DF30;
		  /* 8209DF30h */ case   14:  		/* mr R11, R3 */
		/* 8209DF30h case   14:*/		regs.R11 = regs.R3;
		/* 8209DF30h case   14:*/		return 0x8209DF34;
		  /* 8209DF34h */ case   15:  		/* stw R10, <#[R3]> */
		/* 8209DF34h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8209DF34h case   15:*/		return 0x8209DF38;
		  /* 8209DF38h */ case   16:  		/* lwz R11, <#[R31 + 12]> */
		/* 8209DF38h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209DF38h case   16:*/		return 0x8209DF3C;
		  /* 8209DF3Ch */ case   17:  		/* lis R3, 0 */
		/* 8209DF3Ch case   17:*/		cpu::op::lis<0>(regs,&regs.R3,0x0);
		/* 8209DF3Ch case   17:*/		return 0x8209DF40;
		  /* 8209DF40h */ case   18:  		/* ori R11, R11, 32 */
		/* 8209DF40h case   18:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x20);
		/* 8209DF40h case   18:*/		return 0x8209DF44;
		  /* 8209DF44h */ case   19:  		/* ori R3, R3, 65535 */
		/* 8209DF44h case   19:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xFFFF);
		/* 8209DF44h case   19:*/		return 0x8209DF48;
		  /* 8209DF48h */ case   20:  		/* stw R11, <#[R31 + 12]> */
		/* 8209DF48h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209DF48h case   20:*/		return 0x8209DF4C;
		  /* 8209DF4Ch */ case   21:  		/* b 396 */
		/* 8209DF4Ch case   21:*/		return 0x8209E0D8;
		/* 8209DF4Ch case   21:*/		return 0x8209DF50;
	}
	return 0x8209DF50;
} // Block from 8209DEF8h-8209DF50h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8209DF50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DF50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DF50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DF50);
		  /* 8209DF50h */ case    0:  		/* rlwinm. R10, R11, 0, 25, 25 */
		/* 8209DF50h case    0:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R11);
		/* 8209DF50h case    0:*/		return 0x8209DF54;
		  /* 8209DF54h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8209DF54h case    1:*/		if ( regs.CR[0].eq ) { return 0x8209DF64;  }
		/* 8209DF54h case    1:*/		return 0x8209DF58;
		  /* 8209DF58h */ case    2:  		/* bl -36944 */
		/* 8209DF58h case    2:*/		regs.LR = 0x8209DF5C; return 0x82094F08;
		/* 8209DF58h case    2:*/		return 0x8209DF5C;
		  /* 8209DF5Ch */ case    3:  		/* li R10, 34 */
		/* 8209DF5Ch case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x22);
		/* 8209DF5Ch case    3:*/		return 0x8209DF60;
		  /* 8209DF60h */ case    4:  		/* b -48 */
		/* 8209DF60h case    4:*/		return 0x8209DF30;
		/* 8209DF60h case    4:*/		return 0x8209DF64;
	}
	return 0x8209DF64;
} // Block from 8209DF50h-8209DF64h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209DF64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DF64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DF64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DF64);
		  /* 8209DF64h */ case    0:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 8209DF64h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 8209DF64h case    0:*/		return 0x8209DF68;
		  /* 8209DF68h */ case    1:  		/* li R10, 0 */
		/* 8209DF68h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8209DF68h case    1:*/		return 0x8209DF6C;
		  /* 8209DF6Ch */ case    2:  		/* bc 12, CR0_EQ, 32 */
		/* 8209DF6Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8209DF8C;  }
		/* 8209DF6Ch case    2:*/		return 0x8209DF70;
		  /* 8209DF70h */ case    3:  		/* rlwinm. R9, R11, 0, 27, 27 */
		/* 8209DF70h case    3:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R9,regs.R11);
		/* 8209DF70h case    3:*/		return 0x8209DF74;
		  /* 8209DF74h */ case    4:  		/* stw R10, <#[R31 + 4]> */
		/* 8209DF74h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8209DF74h case    4:*/		return 0x8209DF78;
		  /* 8209DF78h */ case    5:  		/* bc 12, CR0_EQ, 184 */
		/* 8209DF78h case    5:*/		if ( regs.CR[0].eq ) { return 0x8209E030;  }
		/* 8209DF78h case    5:*/		return 0x8209DF7C;
		  /* 8209DF7Ch */ case    6:  		/* lwz R9, <#[R31 + 8]> */
		/* 8209DF7Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 8209DF7Ch case    6:*/		return 0x8209DF80;
		  /* 8209DF80h */ case    7:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8209DF80h case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8209DF80h case    7:*/		return 0x8209DF84;
		  /* 8209DF84h */ case    8:  		/* stw R11, <#[R31 + 12]> */
		/* 8209DF84h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209DF84h case    8:*/		return 0x8209DF88;
		  /* 8209DF88h */ case    9:  		/* stw R9, <#[R31]> */
		/* 8209DF88h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8209DF88h case    9:*/		return 0x8209DF8C;
	}
	return 0x8209DF8C;
} // Block from 8209DF64h-8209DF8Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209DF8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DF8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DF8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DF8C);
		  /* 8209DF8Ch */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8209DF8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209DF8Ch case    0:*/		return 0x8209DF90;
		  /* 8209DF90h */ case    1:  		/* mr R28, R10 */
		/* 8209DF90h case    1:*/		regs.R28 = regs.R10;
		/* 8209DF90h case    1:*/		return 0x8209DF94;
		  /* 8209DF94h */ case    2:  		/* stw R10, <#[R31 + 4]> */
		/* 8209DF94h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8209DF94h case    2:*/		return 0x8209DF98;
		  /* 8209DF98h */ case    3:  		/* rlwinm R11, R11, 0, 28, 26 */
		/* 8209DF98h case    3:*/		cpu::op::rlwinm<0,0,28,26>(regs,&regs.R11,regs.R11);
		/* 8209DF98h case    3:*/		return 0x8209DF9C;
		  /* 8209DF9Ch */ case    4:  		/* ori R11, R11, 2 */
		/* 8209DF9Ch case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8209DF9Ch case    4:*/		return 0x8209DFA0;
		  /* 8209DFA0h */ case    5:  		/* andi. R10, R11, 268 */
		/* 8209DFA0h case    5:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0x10C);
		/* 8209DFA0h case    5:*/		return 0x8209DFA4;
		  /* 8209DFA4h */ case    6:  		/* stw R11, <#[R31 + 12]> */
		/* 8209DFA4h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209DFA4h case    6:*/		return 0x8209DFA8;
		  /* 8209DFA8h */ case    7:  		/* cmpwi CR0, R10, 0 */
		/* 8209DFA8h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R10,0x00000000);
		/* 8209DFA8h case    7:*/		return 0x8209DFAC;
		  /* 8209DFACh */ case    8:  		/* bc 4, CR0_EQ, 60 */
		/* 8209DFACh case    8:*/		if ( !regs.CR[0].eq ) { return 0x8209DFE8;  }
		/* 8209DFACh case    8:*/		return 0x8209DFB0;
		  /* 8209DFB0h */ case    9:  		/* bl -14544 */
		/* 8209DFB0h case    9:*/		regs.LR = 0x8209DFB4; return 0x8209A6E0;
		/* 8209DFB0h case    9:*/		return 0x8209DFB4;
		  /* 8209DFB4h */ case   10:  		/* addi R11, R3, 32 */
		/* 8209DFB4h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x20);
		/* 8209DFB4h case   10:*/		return 0x8209DFB8;
		  /* 8209DFB8h */ case   11:  		/* cmplw CR6, R31, R11 */
		/* 8209DFB8h case   11:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8209DFB8h case   11:*/		return 0x8209DFBC;
		  /* 8209DFBCh */ case   12:  		/* bc 12, CR6_EQ, 20 */
		/* 8209DFBCh case   12:*/		if ( regs.CR[6].eq ) { return 0x8209DFD0;  }
		/* 8209DFBCh case   12:*/		return 0x8209DFC0;
		  /* 8209DFC0h */ case   13:  		/* bl -14560 */
		/* 8209DFC0h case   13:*/		regs.LR = 0x8209DFC4; return 0x8209A6E0;
		/* 8209DFC0h case   13:*/		return 0x8209DFC4;
		  /* 8209DFC4h */ case   14:  		/* addi R11, R3, 64 */
		/* 8209DFC4h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x40);
		/* 8209DFC4h case   14:*/		return 0x8209DFC8;
		  /* 8209DFC8h */ case   15:  		/* cmplw CR6, R31, R11 */
		/* 8209DFC8h case   15:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8209DFC8h case   15:*/		return 0x8209DFCC;
		  /* 8209DFCCh */ case   16:  		/* bc 4, CR6_EQ, 20 */
		/* 8209DFCCh case   16:*/		if ( !regs.CR[6].eq ) { return 0x8209DFE0;  }
		/* 8209DFCCh case   16:*/		return 0x8209DFD0;
	}
	return 0x8209DFD0;
} // Block from 8209DF8Ch-8209DFD0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8209DFD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DFD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DFD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DFD0);
		  /* 8209DFD0h */ case    0:  		/* mr R3, R29 */
		/* 8209DFD0h case    0:*/		regs.R3 = regs.R29;
		/* 8209DFD0h case    0:*/		return 0x8209DFD4;
		  /* 8209DFD4h */ case    1:  		/* bl 1817900 */
		/* 8209DFD4h case    1:*/		regs.LR = 0x8209DFD8; return 0x82259D00;
		/* 8209DFD4h case    1:*/		return 0x8209DFD8;
		  /* 8209DFD8h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 8209DFD8h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209DFD8h case    2:*/		return 0x8209DFDC;
		  /* 8209DFDCh */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 8209DFDCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x8209DFE8;  }
		/* 8209DFDCh case    3:*/		return 0x8209DFE0;
	}
	return 0x8209DFE0;
} // Block from 8209DFD0h-8209DFE0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209DFE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DFE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DFE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DFE0);
		  /* 8209DFE0h */ case    0:  		/* mr R3, R31 */
		/* 8209DFE0h case    0:*/		regs.R3 = regs.R31;
		/* 8209DFE0h case    0:*/		return 0x8209DFE4;
		  /* 8209DFE4h */ case    1:  		/* bl -14732 */
		/* 8209DFE4h case    1:*/		regs.LR = 0x8209DFE8; return 0x8209A658;
		/* 8209DFE4h case    1:*/		return 0x8209DFE8;
	}
	return 0x8209DFE8;
} // Block from 8209DFE0h-8209DFE8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209DFE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209DFE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209DFE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209DFE8);
		  /* 8209DFE8h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8209DFE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209DFE8h case    0:*/		return 0x8209DFEC;
		  /* 8209DFECh */ case    1:  		/* andi. R11, R11, 264 */
		/* 8209DFECh case    1:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x108);
		/* 8209DFECh case    1:*/		return 0x8209DFF0;
		  /* 8209DFF0h */ case    2:  		/* cmpwi CR0, R11, 0 */
		/* 8209DFF0h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 8209DFF0h case    2:*/		return 0x8209DFF4;
		  /* 8209DFF4h */ case    3:  		/* bc 12, CR0_EQ, 188 */
		/* 8209DFF4h case    3:*/		if ( regs.CR[0].eq ) { return 0x8209E0B0;  }
		/* 8209DFF4h case    3:*/		return 0x8209DFF8;
		  /* 8209DFF8h */ case    4:  		/* lwz R10, <#[R31]> */
		/* 8209DFF8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8209DFF8h case    4:*/		return 0x8209DFFC;
		  /* 8209DFFCh */ case    5:  		/* lwz R4, <#[R31 + 8]> */
		/* 8209DFFCh case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 8209DFFCh case    5:*/		return 0x8209E000;
		  /* 8209E000h */ case    6:  		/* lwz R11, <#[R31 + 24]> */
		/* 8209E000h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8209E000h case    6:*/		return 0x8209E004;
		  /* 8209E004h */ case    7:  		/* subf. R30, R4, R10 */
		/* 8209E004h case    7:*/		cpu::op::subf<1>(regs,&regs.R30,regs.R4,regs.R10);
		/* 8209E004h case    7:*/		return 0x8209E008;
		  /* 8209E008h */ case    8:  		/* addi R11, R11, -2 */
		/* 8209E008h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFE);
		/* 8209E008h case    8:*/		return 0x8209E00C;
		  /* 8209E00Ch */ case    9:  		/* addi R10, R4, 2 */
		/* 8209E00Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x2);
		/* 8209E00Ch case    9:*/		return 0x8209E010;
		  /* 8209E010h */ case   10:  		/* stw R11, <#[R31 + 4]> */
		/* 8209E010h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8209E010h case   10:*/		return 0x8209E014;
		  /* 8209E014h */ case   11:  		/* stw R10, <#[R31]> */
		/* 8209E014h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8209E014h case   11:*/		return 0x8209E018;
		  /* 8209E018h */ case   12:  		/* bc 4, CR0_GT, 44 */
		/* 8209E018h case   12:*/		if ( !regs.CR[0].gt ) { return 0x8209E044;  }
		/* 8209E018h case   12:*/		return 0x8209E01C;
		  /* 8209E01Ch */ case   13:  		/* mr R5, R30 */
		/* 8209E01Ch case   13:*/		regs.R5 = regs.R30;
		/* 8209E01Ch case   13:*/		return 0x8209E020;
		  /* 8209E020h */ case   14:  		/* mr R3, R29 */
		/* 8209E020h case   14:*/		regs.R3 = regs.R29;
		/* 8209E020h case   14:*/		return 0x8209E024;
		  /* 8209E024h */ case   15:  		/* bl -15180 */
		/* 8209E024h case   15:*/		regs.LR = 0x8209E028; return 0x8209A4D8;
		/* 8209E024h case   15:*/		return 0x8209E028;
		  /* 8209E028h */ case   16:  		/* mr R28, R3 */
		/* 8209E028h case   16:*/		regs.R28 = regs.R3;
		/* 8209E028h case   16:*/		return 0x8209E02C;
		  /* 8209E02Ch */ case   17:  		/* b 120 */
		/* 8209E02Ch case   17:*/		return 0x8209E0A4;
		/* 8209E02Ch case   17:*/		return 0x8209E030;
	}
	return 0x8209E030;
} // Block from 8209DFE8h-8209E030h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8209E030h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E030);
		  /* 8209E030h */ case    0:  		/* ori R11, R11, 32 */
		/* 8209E030h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x20);
		/* 8209E030h case    0:*/		return 0x8209E034;
		  /* 8209E034h */ case    1:  		/* lis R3, 0 */
		/* 8209E034h case    1:*/		cpu::op::lis<0>(regs,&regs.R3,0x0);
		/* 8209E034h case    1:*/		return 0x8209E038;
		  /* 8209E038h */ case    2:  		/* stw R11, <#[R31 + 12]> */
		/* 8209E038h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209E038h case    2:*/		return 0x8209E03C;
		  /* 8209E03Ch */ case    3:  		/* ori R3, R3, 65535 */
		/* 8209E03Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xFFFF);
		/* 8209E03Ch case    3:*/		return 0x8209E040;
		  /* 8209E040h */ case    4:  		/* b 152 */
		/* 8209E040h case    4:*/		return 0x8209E0D8;
		/* 8209E040h case    4:*/		return 0x8209E044;
	}
	return 0x8209E044;
} // Block from 8209E030h-8209E044h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209E044h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E044( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E044) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E044);
		  /* 8209E044h */ case    0:  		/* cmpwi CR6, R29, -1 */
		/* 8209E044h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFF);
		/* 8209E044h case    0:*/		return 0x8209E048;
		  /* 8209E048h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 8209E048h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209E078;  }
		/* 8209E048h case    1:*/		return 0x8209E04C;
		  /* 8209E04Ch */ case    2:  		/* cmpwi CR6, R29, -2 */
		/* 8209E04Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFE);
		/* 8209E04Ch case    2:*/		return 0x8209E050;
		  /* 8209E050h */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 8209E050h case    3:*/		if ( regs.CR[6].eq ) { return 0x8209E078;  }
		/* 8209E050h case    3:*/		return 0x8209E054;
		  /* 8209E054h */ case    4:  		/* srawi R11, R29, 5 */
		/* 8209E054h case    4:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R29);
		/* 8209E054h case    4:*/		return 0x8209E058;
		  /* 8209E058h */ case    5:  		/* lis R10, -32215 */
		/* 8209E058h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 8209E058h case    5:*/		return 0x8209E05C;
		  /* 8209E05Ch */ case    6:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 8209E05Ch case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8209E05Ch case    6:*/		return 0x8209E060;
		  /* 8209E060h */ case    7:  		/* addi R10, R10, -25504 */
		/* 8209E060h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFF9C60);
		/* 8209E060h case    7:*/		return 0x8209E064;
		  /* 8209E064h */ case    8:  		/* rlwinm R11, R29, 0, 27, 31 */
		/* 8209E064h case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R29);
		/* 8209E064h case    8:*/		return 0x8209E068;
		  /* 8209E068h */ case    9:  		/* mulli R11, R11, 72 */
		/* 8209E068h case    9:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x48);
		/* 8209E068h case    9:*/		return 0x8209E06C;
		  /* 8209E06Ch */ case   10:  		/* lwzx R10, <#[R9 + R10]> */
		/* 8209E06Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8209E06Ch case   10:*/		return 0x8209E070;
		  /* 8209E070h */ case   11:  		/* add R11, R10, R11 */
		/* 8209E070h case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8209E070h case   11:*/		return 0x8209E074;
		  /* 8209E074h */ case   12:  		/* b 12 */
		/* 8209E074h case   12:*/		return 0x8209E080;
		/* 8209E074h case   12:*/		return 0x8209E078;
	}
	return 0x8209E078;
} // Block from 8209E044h-8209E078h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209E078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E078);
		  /* 8209E078h */ case    0:  		/* lis R11, -32217 */
		/* 8209E078h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 8209E078h case    0:*/		return 0x8209E07C;
		  /* 8209E07Ch */ case    1:  		/* addi R11, R11, 8872 */
		/* 8209E07Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x22A8);
		/* 8209E07Ch case    1:*/		return 0x8209E080;
	}
	return 0x8209E080;
} // Block from 8209E078h-8209E080h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209E080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E080);
		  /* 8209E080h */ case    0:  		/* lbz R11, <#[R11 + 4]> */
		/* 8209E080h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8209E080h case    0:*/		return 0x8209E084;
		  /* 8209E084h */ case    1:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 8209E084h case    1:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 8209E084h case    1:*/		return 0x8209E088;
		  /* 8209E088h */ case    2:  		/* bc 12, CR0_EQ, 28 */
		/* 8209E088h case    2:*/		if ( regs.CR[0].eq ) { return 0x8209E0A4;  }
		/* 8209E088h case    2:*/		return 0x8209E08C;
		  /* 8209E08Ch */ case    3:  		/* li R5, 2 */
		/* 8209E08Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8209E08Ch case    3:*/		return 0x8209E090;
	}
	return 0x8209E090;
} // Block from 8209E080h-8209E090h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209E090h
// Function '$I10_OUTPUT'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E090);
		  /* 8209E090h */ case    0:  		/* li R4, 0 */
		/* 8209E090h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8209E090h case    0:*/		return 0x8209E094;
		  /* 8209E094h */ case    1:  		/* mr R3, R29 */
		/* 8209E094h case    1:*/		regs.R3 = regs.R29;
		/* 8209E094h case    1:*/		return 0x8209E098;
		  /* 8209E098h */ case    2:  		/* bl -16616 */
		/* 8209E098h case    2:*/		regs.LR = 0x8209E09C; return 0x82099FB0;
		/* 8209E098h case    2:*/		return 0x8209E09C;
		  /* 8209E09Ch */ case    3:  		/* cmpdi CR6, R3, -1 */
		/* 8209E09Ch case    3:*/		cpu::op::cmpdi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8209E09Ch case    3:*/		return 0x8209E0A0;
		  /* 8209E0A0h */ case    4:  		/* bc 12, CR6_EQ, -360 */
		/* 8209E0A0h case    4:*/		if ( regs.CR[6].eq ) { return 0x8209DF38;  }
		/* 8209E0A0h case    4:*/		return 0x8209E0A4;
	}
	return 0x8209E0A4;
} // Block from 8209E090h-8209E0A4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209E0A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E0A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E0A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E0A4);
		  /* 8209E0A4h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8209E0A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8209E0A4h case    0:*/		return 0x8209E0A8;
		  /* 8209E0A8h */ case    1:  		/* sth R27, <#[R11]> */
		/* 8209E0A8h case    1:*/		cpu::mem::store16( regs, regs.R27, (uint32)(regs.R11 + 0x00000000) );
		/* 8209E0A8h case    1:*/		return 0x8209E0AC;
		  /* 8209E0ACh */ case    2:  		/* b 32 */
		/* 8209E0ACh case    2:*/		return 0x8209E0CC;
		/* 8209E0ACh case    2:*/		return 0x8209E0B0;
	}
	return 0x8209E0B0;
} // Block from 8209E0A4h-8209E0B0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209E0B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E0B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E0B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E0B0);
		  /* 8209E0B0h */ case    0:  		/* sth R27, <#[R1 + 80]> */
		/* 8209E0B0h case    0:*/		cpu::mem::store16( regs, regs.R27, (uint32)(regs.R1 + 0x00000050) );
		/* 8209E0B0h case    0:*/		return 0x8209E0B4;
		  /* 8209E0B4h */ case    1:  		/* li R5, 2 */
		/* 8209E0B4h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8209E0B4h case    1:*/		return 0x8209E0B8;
		  /* 8209E0B8h */ case    2:  		/* addi R4, R1, 80 */
		/* 8209E0B8h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8209E0B8h case    2:*/		return 0x8209E0BC;
		  /* 8209E0BCh */ case    3:  		/* mr R3, R29 */
		/* 8209E0BCh case    3:*/		regs.R3 = regs.R29;
		/* 8209E0BCh case    3:*/		return 0x8209E0C0;
		  /* 8209E0C0h */ case    4:  		/* li R30, 2 */
		/* 8209E0C0h case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 8209E0C0h case    4:*/		return 0x8209E0C4;
		  /* 8209E0C4h */ case    5:  		/* bl -15340 */
		/* 8209E0C4h case    5:*/		regs.LR = 0x8209E0C8; return 0x8209A4D8;
		/* 8209E0C4h case    5:*/		return 0x8209E0C8;
		  /* 8209E0C8h */ case    6:  		/* mr R28, R3 */
		/* 8209E0C8h case    6:*/		regs.R28 = regs.R3;
		/* 8209E0C8h case    6:*/		return 0x8209E0CC;
	}
	return 0x8209E0CC;
} // Block from 8209E0B0h-8209E0CCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209E0CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E0CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E0CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E0CC);
		  /* 8209E0CCh */ case    0:  		/* cmpw CR6, R28, R30 */
		/* 8209E0CCh case    0:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R30);
		/* 8209E0CCh case    0:*/		return 0x8209E0D0;
		  /* 8209E0D0h */ case    1:  		/* bc 4, CR6_EQ, -408 */
		/* 8209E0D0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209DF38;  }
		/* 8209E0D0h case    1:*/		return 0x8209E0D4;
		  /* 8209E0D4h */ case    2:  		/* rlwinm R3, R27, 0, 16, 31 */
		/* 8209E0D4h case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R3,regs.R27);
		/* 8209E0D4h case    2:*/		return 0x8209E0D8;
	}
	return 0x8209E0D8;
} // Block from 8209E0CCh-8209E0D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209E0D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E0D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E0D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E0D8);
		  /* 8209E0D8h */ case    0:  		/* addi R1, R1, 144 */
		/* 8209E0D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8209E0D8h case    0:*/		return 0x8209E0DC;
		  /* 8209E0DCh */ case    1:  		/* b -52792 */
		/* 8209E0DCh case    1:*/		return 0x820912A4;
		/* 8209E0DCh case    1:*/		return 0x8209E0E0;
	}
	return 0x8209E0E0;
} // Block from 8209E0D8h-8209E0E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209E0E0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E0E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E0E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E0E0);
		  /* 8209E0E0h */ case    0:  		/* mfspr R12, LR */
		/* 8209E0E0h case    0:*/		regs.R12 = regs.LR;
		/* 8209E0E0h case    0:*/		return 0x8209E0E4;
		  /* 8209E0E4h */ case    1:  		/* bl -52872 */
		/* 8209E0E4h case    1:*/		regs.LR = 0x8209E0E8; return 0x8209125C;
		/* 8209E0E4h case    1:*/		return 0x8209E0E8;
		  /* 8209E0E8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209E0E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209E0E8h case    2:*/		return 0x8209E0EC;
		  /* 8209E0ECh */ case    3:  		/* mr R31, R3 */
		/* 8209E0ECh case    3:*/		regs.R31 = regs.R3;
		/* 8209E0ECh case    3:*/		return 0x8209E0F0;
		  /* 8209E0F0h */ case    4:  		/* bl -14192 */
		/* 8209E0F0h case    4:*/		regs.LR = 0x8209E0F4; return 0x8209A980;
		/* 8209E0F0h case    4:*/		return 0x8209E0F4;
		  /* 8209E0F4h */ case    5:  		/* bl 1817612 */
		/* 8209E0F4h case    5:*/		regs.LR = 0x8209E0F8; return 0x82259D00;
		/* 8209E0F4h case    5:*/		return 0x8209E0F8;
		  /* 8209E0F8h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 8209E0F8h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209E0F8h case    6:*/		return 0x8209E0FC;
		  /* 8209E0FCh */ case    7:  		/* bc 12, CR0_EQ, 196 */
		/* 8209E0FCh case    7:*/		if ( regs.CR[0].eq ) { return 0x8209E1C0;  }
		/* 8209E0FCh case    7:*/		return 0x8209E100;
		  /* 8209E100h */ case    8:  		/* bl -14880 */
		/* 8209E100h case    8:*/		regs.LR = 0x8209E104; return 0x8209A6E0;
		/* 8209E100h case    8:*/		return 0x8209E104;
		  /* 8209E104h */ case    9:  		/* addi R11, R3, 32 */
		/* 8209E104h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x20);
		/* 8209E104h case    9:*/		return 0x8209E108;
		  /* 8209E108h */ case   10:  		/* cmplw CR6, R31, R11 */
		/* 8209E108h case   10:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8209E108h case   10:*/		return 0x8209E10C;
		  /* 8209E10Ch */ case   11:  		/* bc 4, CR6_EQ, 12 */
		/* 8209E10Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x8209E118;  }
		/* 8209E10Ch case   11:*/		return 0x8209E110;
		  /* 8209E110h */ case   12:  		/* li R10, 0 */
		/* 8209E110h case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8209E110h case   12:*/		return 0x8209E114;
		  /* 8209E114h */ case   13:  		/* b 24 */
		/* 8209E114h case   13:*/		return 0x8209E12C;
		/* 8209E114h case   13:*/		return 0x8209E118;
	}
	return 0x8209E118;
} // Block from 8209E0E0h-8209E118h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209E118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E118);
		  /* 8209E118h */ case    0:  		/* bl -14904 */
		/* 8209E118h case    0:*/		regs.LR = 0x8209E11C; return 0x8209A6E0;
		/* 8209E118h case    0:*/		return 0x8209E11C;
		  /* 8209E11Ch */ case    1:  		/* addi R11, R3, 64 */
		/* 8209E11Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x40);
		/* 8209E11Ch case    1:*/		return 0x8209E120;
		  /* 8209E120h */ case    2:  		/* cmplw CR6, R31, R11 */
		/* 8209E120h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8209E120h case    2:*/		return 0x8209E124;
		  /* 8209E124h */ case    3:  		/* bc 4, CR6_EQ, 156 */
		/* 8209E124h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8209E1C0;  }
		/* 8209E124h case    3:*/		return 0x8209E128;
		  /* 8209E128h */ case    4:  		/* li R10, 1 */
		/* 8209E128h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8209E128h case    4:*/		return 0x8209E12C;
	}
	return 0x8209E12C;
} // Block from 8209E118h-8209E12Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209E12Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E12C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E12C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E12C);
		  /* 8209E12Ch */ case    0:  		/* lis R9, -32215 */
		/* 8209E12Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8229);
		/* 8209E12Ch case    0:*/		return 0x8209E130;
		  /* 8209E130h */ case    1:  		/* lwz R11, <#[R9 - 30256]> */
		/* 8209E130h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0xFFFF89D0) );
		/* 8209E130h case    1:*/		return 0x8209E134;
		  /* 8209E134h */ case    2:  		/* addi R11, R11, 1 */
		/* 8209E134h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209E134h case    2:*/		return 0x8209E138;
		  /* 8209E138h */ case    3:  		/* stw R11, <#[R9 - 30256]> */
		/* 8209E138h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0xFFFF89D0) );
		/* 8209E138h case    3:*/		return 0x8209E13C;
		  /* 8209E13Ch */ case    4:  		/* lwz R11, <#[R31 + 12]> */
		/* 8209E13Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209E13Ch case    4:*/		return 0x8209E140;
		  /* 8209E140h */ case    5:  		/* andi. R11, R11, 268 */
		/* 8209E140h case    5:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x10C);
		/* 8209E140h case    5:*/		return 0x8209E144;
		  /* 8209E144h */ case    6:  		/* cmpwi CR0, R11, 0 */
		/* 8209E144h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 8209E144h case    6:*/		return 0x8209E148;
		  /* 8209E148h */ case    7:  		/* bc 4, CR0_EQ, 120 */
		/* 8209E148h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8209E1C0;  }
		/* 8209E148h case    7:*/		return 0x8209E14C;
		  /* 8209E14Ch */ case    8:  		/* lis R11, -32215 */
		/* 8209E14Ch case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8209E14Ch case    8:*/		return 0x8209E150;
		  /* 8209E150h */ case    9:  		/* rlwinm R29, R10, 2, 0, 29 */
		/* 8209E150h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R10);
		/* 8209E150h case    9:*/		return 0x8209E154;
		  /* 8209E154h */ case   10:  		/* addi R30, R11, -30204 */
		/* 8209E154h case   10:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFF8A04);
		/* 8209E154h case   10:*/		return 0x8209E158;
		  /* 8209E158h */ case   11:  		/* lwzx R11, <#[R29 + R30]> */
		/* 8209E158h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R30 + 0x00000000) );
		/* 8209E158h case   11:*/		return 0x8209E15C;
		  /* 8209E15Ch */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 8209E15Ch case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209E15Ch case   12:*/		return 0x8209E160;
		  /* 8209E160h */ case   13:  		/* bc 4, CR6_EQ, 52 */
		/* 8209E160h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8209E194;  }
		/* 8209E160h case   13:*/		return 0x8209E164;
		  /* 8209E164h */ case   14:  		/* li R3, 4096 */
		/* 8209E164h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x1000);
		/* 8209E164h case   14:*/		return 0x8209E168;
		  /* 8209E168h */ case   15:  		/* bl -43232 */
		/* 8209E168h case   15:*/		regs.LR = 0x8209E16C; return 0x82093888;
		/* 8209E168h case   15:*/		return 0x8209E16C;
		  /* 8209E16Ch */ case   16:  		/* stwx R3, <#[R29 + R30]> */
		/* 8209E16Ch case   16:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + regs.R30 + 0x00000000) );
		/* 8209E16Ch case   16:*/		return 0x8209E170;
		  /* 8209E170h */ case   17:  		/* cmplwi CR0, R3, 0 */
		/* 8209E170h case   17:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8209E170h case   17:*/		return 0x8209E174;
		  /* 8209E174h */ case   18:  		/* bc 4, CR0_EQ, 32 */
		/* 8209E174h case   18:*/		if ( !regs.CR[0].eq ) { return 0x8209E194;  }
		/* 8209E174h case   18:*/		return 0x8209E178;
		  /* 8209E178h */ case   19:  		/* li R10, 2 */
		/* 8209E178h case   19:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 8209E178h case   19:*/		return 0x8209E17C;
		  /* 8209E17Ch */ case   20:  		/* addi R11, R31, 20 */
		/* 8209E17Ch case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x14);
		/* 8209E17Ch case   20:*/		return 0x8209E180;
		  /* 8209E180h */ case   21:  		/* stw R10, <#[R31 + 24]> */
		/* 8209E180h case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 8209E180h case   21:*/		return 0x8209E184;
		  /* 8209E184h */ case   22:  		/* stw R11, <#[R31 + 8]> */
		/* 8209E184h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8209E184h case   22:*/		return 0x8209E188;
		  /* 8209E188h */ case   23:  		/* stw R11, <#[R31]> */
		/* 8209E188h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209E188h case   23:*/		return 0x8209E18C;
		  /* 8209E18Ch */ case   24:  		/* stw R10, <#[R31 + 4]> */
		/* 8209E18Ch case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8209E18Ch case   24:*/		return 0x8209E190;
		  /* 8209E190h */ case   25:  		/* b 28 */
		/* 8209E190h case   25:*/		return 0x8209E1AC;
		/* 8209E190h case   25:*/		return 0x8209E194;
	}
	return 0x8209E194;
} // Block from 8209E12Ch-8209E194h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8209E194h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E194( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E194) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E194);
		  /* 8209E194h */ case    0:  		/* lwzx R10, <#[R29 + R30]> */
		/* 8209E194h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + regs.R30 + 0x00000000) );
		/* 8209E194h case    0:*/		return 0x8209E198;
		  /* 8209E198h */ case    1:  		/* li R11, 4096 */
		/* 8209E198h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1000);
		/* 8209E198h case    1:*/		return 0x8209E19C;
		  /* 8209E19Ch */ case    2:  		/* stw R11, <#[R31 + 24]> */
		/* 8209E19Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8209E19Ch case    2:*/		return 0x8209E1A0;
		  /* 8209E1A0h */ case    3:  		/* stw R11, <#[R31 + 4]> */
		/* 8209E1A0h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8209E1A0h case    3:*/		return 0x8209E1A4;
		  /* 8209E1A4h */ case    4:  		/* stw R10, <#[R31 + 8]> */
		/* 8209E1A4h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8209E1A4h case    4:*/		return 0x8209E1A8;
		  /* 8209E1A8h */ case    5:  		/* stw R10, <#[R31]> */
		/* 8209E1A8h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8209E1A8h case    5:*/		return 0x8209E1AC;
	}
	return 0x8209E1AC;
} // Block from 8209E194h-8209E1ACh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209E1ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E1AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E1AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E1AC);
		  /* 8209E1ACh */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8209E1ACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209E1ACh case    0:*/		return 0x8209E1B0;
		  /* 8209E1B0h */ case    1:  		/* li R3, 1 */
		/* 8209E1B0h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8209E1B0h case    1:*/		return 0x8209E1B4;
		  /* 8209E1B4h */ case    2:  		/* ori R11, R11, 4354 */
		/* 8209E1B4h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1102);
		/* 8209E1B4h case    2:*/		return 0x8209E1B8;
		  /* 8209E1B8h */ case    3:  		/* stw R11, <#[R31 + 12]> */
		/* 8209E1B8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209E1B8h case    3:*/		return 0x8209E1BC;
		  /* 8209E1BCh */ case    4:  		/* b 8 */
		/* 8209E1BCh case    4:*/		return 0x8209E1C4;
		/* 8209E1BCh case    4:*/		return 0x8209E1C0;
	}
	return 0x8209E1C0;
} // Block from 8209E1ACh-8209E1C0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209E1C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E1C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E1C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E1C0);
		  /* 8209E1C0h */ case    0:  		/* li R3, 0 */
		/* 8209E1C0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209E1C0h case    0:*/		return 0x8209E1C4;
	}
	return 0x8209E1C4;
} // Block from 8209E1C0h-8209E1C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209E1C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E1C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E1C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E1C4);
		  /* 8209E1C4h */ case    0:  		/* addi R1, R1, 112 */
		/* 8209E1C4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8209E1C4h case    0:*/		return 0x8209E1C8;
		  /* 8209E1C8h */ case    1:  		/* b -53020 */
		/* 8209E1C8h case    1:*/		return 0x820912AC;
		/* 8209E1C8h case    1:*/		return 0x8209E1CC;
		  /* 8209E1CCh */ case    2:  		/* nop */
		/* 8209E1CCh case    2:*/		cpu::op::nop();
		/* 8209E1CCh case    2:*/		return 0x8209E1D0;
	}
	return 0x8209E1D0;
} // Block from 8209E1C4h-8209E1D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209E1D0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E1D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E1D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E1D0);
		  /* 8209E1D0h */ case    0:  		/* mfspr R12, LR */
		/* 8209E1D0h case    0:*/		regs.R12 = regs.LR;
		/* 8209E1D0h case    0:*/		return 0x8209E1D4;
		  /* 8209E1D4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209E1D4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209E1D4h case    1:*/		return 0x8209E1D8;
		  /* 8209E1D8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8209E1D8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209E1D8h case    2:*/		return 0x8209E1DC;
		  /* 8209E1DCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209E1DCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209E1DCh case    3:*/		return 0x8209E1E0;
		  /* 8209E1E0h */ case    4:  		/* mr R31, R4 */
		/* 8209E1E0h case    4:*/		regs.R31 = regs.R4;
		/* 8209E1E0h case    4:*/		return 0x8209E1E4;
		  /* 8209E1E4h */ case    5:  		/* cmpwi CR6, R3, 0 */
		/* 8209E1E4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8209E1E4h case    5:*/		return 0x8209E1E8;
		  /* 8209E1E8h */ case    6:  		/* bc 12, CR6_EQ, 56 */
		/* 8209E1E8h case    6:*/		if ( regs.CR[6].eq ) { return 0x8209E220;  }
		/* 8209E1E8h case    6:*/		return 0x8209E1EC;
		  /* 8209E1ECh */ case    7:  		/* lwz R11, <#[R4 + 12]> */
		/* 8209E1ECh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 8209E1ECh case    7:*/		return 0x8209E1F0;
		  /* 8209E1F0h */ case    8:  		/* rlwinm. R11, R11, 0, 19, 19 */
		/* 8209E1F0h case    8:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R11,regs.R11);
		/* 8209E1F0h case    8:*/		return 0x8209E1F4;
		  /* 8209E1F4h */ case    9:  		/* bc 12, CR0_EQ, 44 */
		/* 8209E1F4h case    9:*/		if ( regs.CR[0].eq ) { return 0x8209E220;  }
		/* 8209E1F4h case    9:*/		return 0x8209E1F8;
		  /* 8209E1F8h */ case   10:  		/* mr R3, R4 */
		/* 8209E1F8h case   10:*/		regs.R3 = regs.R4;
		/* 8209E1F8h case   10:*/		return 0x8209E1FC;
		  /* 8209E1FCh */ case   11:  		/* bl -1532 */
		/* 8209E1FCh case   11:*/		regs.LR = 0x8209E200; return 0x8209DC00;
		/* 8209E1FCh case   11:*/		return 0x8209E200;
		  /* 8209E200h */ case   12:  		/* li R11, 0 */
		/* 8209E200h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209E200h case   12:*/		return 0x8209E204;
		  /* 8209E204h */ case   13:  		/* stw R11, <#[R31 + 24]> */
		/* 8209E204h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8209E204h case   13:*/		return 0x8209E208;
		  /* 8209E208h */ case   14:  		/* stw R11, <#[R31]> */
		/* 8209E208h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209E208h case   14:*/		return 0x8209E20C;
		  /* 8209E20Ch */ case   15:  		/* stw R11, <#[R31 + 8]> */
		/* 8209E20Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8209E20Ch case   15:*/		return 0x8209E210;
		  /* 8209E210h */ case   16:  		/* lwz R11, <#[R31 + 12]> */
		/* 8209E210h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209E210h case   16:*/		return 0x8209E214;
		  /* 8209E214h */ case   17:  		/* rlwinm R11, R11, 0, 24, 22 */
		/* 8209E214h case   17:*/		cpu::op::rlwinm<0,0,24,22>(regs,&regs.R11,regs.R11);
		/* 8209E214h case   17:*/		return 0x8209E218;
		  /* 8209E218h */ case   18:  		/* rlwinm R11, R11, 0, 20, 18 */
		/* 8209E218h case   18:*/		cpu::op::rlwinm<0,0,20,18>(regs,&regs.R11,regs.R11);
		/* 8209E218h case   18:*/		return 0x8209E21C;
		  /* 8209E21Ch */ case   19:  		/* stw R11, <#[R31 + 12]> */
		/* 8209E21Ch case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209E21Ch case   19:*/		return 0x8209E220;
	}
	return 0x8209E220;
} // Block from 8209E1D0h-8209E220h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8209E220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E220);
		  /* 8209E220h */ case    0:  		/* addi R1, R1, 96 */
		/* 8209E220h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209E220h case    0:*/		return 0x8209E224;
		  /* 8209E224h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209E224h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209E224h case    1:*/		return 0x8209E228;
		  /* 8209E228h */ case    2:  		/* mtspr LR, R12 */
		/* 8209E228h case    2:*/		regs.LR = regs.R12;
		/* 8209E228h case    2:*/		return 0x8209E22C;
		  /* 8209E22Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8209E22Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209E22Ch case    3:*/		return 0x8209E230;
		  /* 8209E230h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8209E230h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209E230h case    4:*/		return 0x8209E234;
	}
	return 0x8209E234;
} // Block from 8209E220h-8209E234h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209E234h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E234( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E234) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E234);
		  /* 8209E234h */ case    0:  		/* nop */
		/* 8209E234h case    0:*/		cpu::op::nop();
		/* 8209E234h case    0:*/		return 0x8209E238;
		  /* 8209E238h */ case    1:  		/* nop */
		/* 8209E238h case    1:*/		cpu::op::nop();
		/* 8209E238h case    1:*/		return 0x8209E23C;
		  /* 8209E23Ch */ case    2:  		/* nop */
		/* 8209E23Ch case    2:*/		cpu::op::nop();
		/* 8209E23Ch case    2:*/		return 0x8209E240;
	}
	return 0x8209E240;
} // Block from 8209E234h-8209E240h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209E240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E240);
		  /* 8209E240h */ case    0:  		/* std R31, <#[R1 - 72]> */
		/* 8209E240h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFB8) );
		/* 8209E240h case    0:*/		return 0x8209E244;
		  /* 8209E244h */ case    1:  		/* mfspr R31, LR */
		/* 8209E244h case    1:*/		regs.R31 = regs.LR;
		/* 8209E244h case    1:*/		return 0x8209E248;
		  /* 8209E248h */ case    2:  		/* stwu R1, <#[R1 - 80]> */
		/* 8209E248h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFB0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFB0);
		/* 8209E248h case    2:*/		return 0x8209E24C;
		  /* 8209E24Ch */ case    3:  		/* li R5, 0 */
		/* 8209E24Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8209E24Ch case    3:*/		return 0x8209E250;
		  /* 8209E250h */ case    4:  		/* li R6, 0 */
		/* 8209E250h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8209E250h case    4:*/		return 0x8209E254;
		  /* 8209E254h */ case    5:  		/* bl 1897188 */
		/* 8209E254h case    5:*/		regs.LR = 0x8209E258; return 0x8226D538;
		/* 8209E254h case    5:*/		return 0x8209E258;
		  /* 8209E258h */ case    6:  		/* mtspr LR, R31 */
		/* 8209E258h case    6:*/		regs.LR = regs.R31;
		/* 8209E258h case    6:*/		return 0x8209E25C;
		  /* 8209E25Ch */ case    7:  		/* ld R31, <#[R1 + 8]> */
		/* 8209E25Ch case    7:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0x00000008) );
		/* 8209E25Ch case    7:*/		return 0x8209E260;
		  /* 8209E260h */ case    8:  		/* addi R1, R1, 80 */
		/* 8209E260h case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x50);
		/* 8209E260h case    8:*/		return 0x8209E264;
		  /* 8209E264h */ case    9:  		/* bclr 20, CR0_LT */
		/* 8209E264h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209E264h case    9:*/		return 0x8209E268;
	}
	return 0x8209E268;
} // Block from 8209E240h-8209E268h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209E268h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E268);
		  /* 8209E268h */ case    0:  		/* mfspr R12, LR */
		/* 8209E268h case    0:*/		regs.R12 = regs.LR;
		/* 8209E268h case    0:*/		return 0x8209E26C;
		  /* 8209E26Ch */ case    1:  		/* bl -53272 */
		/* 8209E26Ch case    1:*/		regs.LR = 0x8209E270; return 0x82091254;
		/* 8209E26Ch case    1:*/		return 0x8209E270;
		  /* 8209E270h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8209E270h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8209E270h case    2:*/		return 0x8209E274;
		  /* 8209E274h */ case    3:  		/* li R30, 0 */
		/* 8209E274h case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8209E274h case    3:*/		return 0x8209E278;
		  /* 8209E278h */ case    4:  		/* mr R29, R3 */
		/* 8209E278h case    4:*/		regs.R29 = regs.R3;
		/* 8209E278h case    4:*/		return 0x8209E27C;
		  /* 8209E27Ch */ case    5:  		/* mr R31, R5 */
		/* 8209E27Ch case    5:*/		regs.R31 = regs.R5;
		/* 8209E27Ch case    5:*/		return 0x8209E280;
		  /* 8209E280h */ case    6:  		/* stw R30, <#[R5 + 8]> */
		/* 8209E280h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R5 + 0x00000008) );
		/* 8209E280h case    6:*/		return 0x8209E284;
		  /* 8209E284h */ case    7:  		/* li R27, 16462 */
		/* 8209E284h case    7:*/		cpu::op::li<0>(regs,&regs.R27,0x404E);
		/* 8209E284h case    7:*/		return 0x8209E288;
		  /* 8209E288h */ case    8:  		/* stw R30, <#[R5 + 4]> */
		/* 8209E288h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R5 + 0x00000004) );
		/* 8209E288h case    8:*/		return 0x8209E28C;
		  /* 8209E28Ch */ case    9:  		/* cmplwi CR6, R4, 0 */
		/* 8209E28Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8209E28Ch case    9:*/		return 0x8209E290;
		  /* 8209E290h */ case   10:  		/* stw R30, <#[R5]> */
		/* 8209E290h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R5 + 0x00000000) );
		/* 8209E290h case   10:*/		return 0x8209E294;
		  /* 8209E294h */ case   11:  		/* bc 12, CR6_EQ, 452 */
		/* 8209E294h case   11:*/		if ( regs.CR[6].eq ) { return 0x8209E458;  }
		/* 8209E294h case   11:*/		return 0x8209E298;
		  /* 8209E298h */ case   12:  		/* mr R28, R4 */
		/* 8209E298h case   12:*/		regs.R28 = regs.R4;
		/* 8209E298h case   12:*/		return 0x8209E29C;
		  /* 8209E29Ch */ case   13:  		/* addi R3, R1, 80 */
		/* 8209E29Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8209E29Ch case   13:*/		return 0x8209E2A0;
		  /* 8209E2A0h */ case   14:  		/* li R5, 12 */
		/* 8209E2A0h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0xC);
		/* 8209E2A0h case   14:*/		return 0x8209E2A4;
		  /* 8209E2A4h */ case   15:  		/* mr R4, R31 */
		/* 8209E2A4h case   15:*/		regs.R4 = regs.R31;
		/* 8209E2A4h case   15:*/		return 0x8209E2A8;
		  /* 8209E2A8h */ case   16:  		/* bl -51448 */
		/* 8209E2A8h case   16:*/		regs.LR = 0x8209E2AC; return 0x820919B0;
		/* 8209E2A8h case   16:*/		return 0x8209E2AC;
		  /* 8209E2ACh */ case   17:  		/* lwz R10, <#[R31 + 8]> */
		/* 8209E2ACh case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8209E2ACh case   17:*/		return 0x8209E2B0;
		  /* 8209E2B0h */ case   18:  		/* lwz R11, <#[R31 + 4]> */
		/* 8209E2B0h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8209E2B0h case   18:*/		return 0x8209E2B4;
		  /* 8209E2B4h */ case   19:  		/* mr R9, R30 */
		/* 8209E2B4h case   19:*/		regs.R9 = regs.R30;
		/* 8209E2B4h case   19:*/		return 0x8209E2B8;
		  /* 8209E2B8h */ case   20:  		/* lwz R8, <#[R31]> */
		/* 8209E2B8h case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 8209E2B8h case   20:*/		return 0x8209E2BC;
		  /* 8209E2BCh */ case   21:  		/* rlwinm R6, R10, 1, 31, 31 */
		/* 8209E2BCh case   21:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R6,regs.R10);
		/* 8209E2BCh case   21:*/		return 0x8209E2C0;
		  /* 8209E2C0h */ case   22:  		/* rlwinm R5, R11, 1, 0, 30 */
		/* 8209E2C0h case   22:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R5,regs.R11);
		/* 8209E2C0h case   22:*/		return 0x8209E2C4;
		  /* 8209E2C4h */ case   23:  		/* lwz R7, <#[R1 + 88]> */
		/* 8209E2C4h case   23:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000058) );
		/* 8209E2C4h case   23:*/		return 0x8209E2C8;
		  /* 8209E2C8h */ case   24:  		/* rlwinm R8, R8, 1, 0, 30 */
		/* 8209E2C8h case   24:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R8,regs.R8);
		/* 8209E2C8h case   24:*/		return 0x8209E2CC;
		  /* 8209E2CCh */ case   25:  		/* rlwinm R11, R11, 1, 31, 31 */
		/* 8209E2CCh case   25:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R11);
		/* 8209E2CCh case   25:*/		return 0x8209E2D0;
		  /* 8209E2D0h */ case   26:  		/* or R6, R5, R6 */
		/* 8209E2D0h case   26:*/		cpu::op::or<0>(regs,&regs.R6,regs.R5,regs.R6);
		/* 8209E2D0h case   26:*/		return 0x8209E2D4;
		  /* 8209E2D4h */ case   27:  		/* or R8, R8, R11 */
		/* 8209E2D4h case   27:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 8209E2D4h case   27:*/		return 0x8209E2D8;
		  /* 8209E2D8h */ case   28:  		/* rlwinm R5, R6, 0, 0, 31 */
		/* 8209E2D8h case   28:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R5,regs.R6);
		/* 8209E2D8h case   28:*/		return 0x8209E2DC;
		  /* 8209E2DCh */ case   29:  		/* stw R6, <#[R31 + 4]> */
		/* 8209E2DCh case   29:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R31 + 0x00000004) );
		/* 8209E2DCh case   29:*/		return 0x8209E2E0;
		  /* 8209E2E0h */ case   30:  		/* stw R8, <#[R31]> */
		/* 8209E2E0h case   30:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 8209E2E0h case   30:*/		return 0x8209E2E4;
		  /* 8209E2E4h */ case   31:  		/* rlwinm R8, R8, 1, 0, 30 */
		/* 8209E2E4h case   31:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R8,regs.R8);
		/* 8209E2E4h case   31:*/		return 0x8209E2E8;
		  /* 8209E2E8h */ case   32:  		/* rlwinm R6, R6, 1, 31, 31 */
		/* 8209E2E8h case   32:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R6,regs.R6);
		/* 8209E2E8h case   32:*/		return 0x8209E2EC;
		  /* 8209E2ECh */ case   33:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 8209E2ECh case   33:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 8209E2ECh case   33:*/		return 0x8209E2F0;
		  /* 8209E2F0h */ case   34:  		/* rlwinm R4, R10, 2, 31, 31 */
		/* 8209E2F0h case   34:*/		cpu::op::rlwinm<0,2,31,31>(regs,&regs.R4,regs.R10);
		/* 8209E2F0h case   34:*/		return 0x8209E2F4;
		  /* 8209E2F4h */ case   35:  		/* rlwinm R5, R5, 1, 0, 30 */
		/* 8209E2F4h case   35:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R5,regs.R5);
		/* 8209E2F4h case   35:*/		return 0x8209E2F8;
		  /* 8209E2F8h */ case   36:  		/* rlwinm R3, R10, 1, 0, 30 */
		/* 8209E2F8h case   36:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R3,regs.R10);
		/* 8209E2F8h case   36:*/		return 0x8209E2FC;
		  /* 8209E2FCh */ case   37:  		/* or R6, R8, R6 */
		/* 8209E2FCh case   37:*/		cpu::op::or<0>(regs,&regs.R6,regs.R8,regs.R6);
		/* 8209E2FCh case   37:*/		return 0x8209E300;
		  /* 8209E300h */ case   38:  		/* or R10, R5, R4 */
		/* 8209E300h case   38:*/		cpu::op::or<0>(regs,&regs.R10,regs.R5,regs.R4);
		/* 8209E300h case   38:*/		return 0x8209E304;
		  /* 8209E304h */ case   39:  		/* stw R3, <#[R31 + 8]> */
		/* 8209E304h case   39:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 8209E304h case   39:*/		return 0x8209E308;
		  /* 8209E308h */ case   40:  		/* add R8, R11, R7 */
		/* 8209E308h case   40:*/		cpu::op::add<0>(regs,&regs.R8,regs.R11,regs.R7);
		/* 8209E308h case   40:*/		return 0x8209E30C;
		  /* 8209E30Ch */ case   41:  		/* stw R11, <#[R31 + 8]> */
		/* 8209E30Ch case   41:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8209E30Ch case   41:*/		return 0x8209E310;
		  /* 8209E310h */ case   42:  		/* stw R10, <#[R31 + 4]> */
		/* 8209E310h case   42:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8209E310h case   42:*/		return 0x8209E314;
		  /* 8209E314h */ case   43:  		/* stw R6, <#[R31]> */
		/* 8209E314h case   43:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R31 + 0x00000000) );
		/* 8209E314h case   43:*/		return 0x8209E318;
		  /* 8209E318h */ case   44:  		/* cmplw CR6, R8, R11 */
		/* 8209E318h case   44:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8209E318h case   44:*/		return 0x8209E31C;
		  /* 8209E31Ch */ case   45:  		/* bc 12, CR6_LT, 12 */
		/* 8209E31Ch case   45:*/		if ( regs.CR[6].lt ) { return 0x8209E328;  }
		/* 8209E31Ch case   45:*/		return 0x8209E320;
		  /* 8209E320h */ case   46:  		/* cmplw CR6, R8, R7 */
		/* 8209E320h case   46:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 8209E320h case   46:*/		return 0x8209E324;
		  /* 8209E324h */ case   47:  		/* bc 4, CR6_LT, 8 */
		/* 8209E324h case   47:*/		if ( !regs.CR[6].lt ) { return 0x8209E32C;  }
		/* 8209E324h case   47:*/		return 0x8209E328;
	}
	return 0x8209E328;
} // Block from 8209E268h-8209E328h (48 instructions)

//////////////////////////////////////////////////////
// Block at 8209E328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E328);
		  /* 8209E328h */ case    0:  		/* li R9, 1 */
		/* 8209E328h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8209E328h case    0:*/		return 0x8209E32C;
	}
	return 0x8209E32C;
} // Block from 8209E328h-8209E32Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209E32Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E32C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E32C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E32C);
		  /* 8209E32Ch */ case    0:  		/* stw R8, <#[R31 + 8]> */
		/* 8209E32Ch case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 8209E32Ch case    0:*/		return 0x8209E330;
		  /* 8209E330h */ case    1:  		/* cmpwi CR6, R9, 0 */
		/* 8209E330h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 8209E330h case    1:*/		return 0x8209E334;
		  /* 8209E334h */ case    2:  		/* bc 12, CR6_EQ, 52 */
		/* 8209E334h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209E368;  }
		/* 8209E334h case    2:*/		return 0x8209E338;
		  /* 8209E338h */ case    3:  		/* addi R11, R10, 1 */
		/* 8209E338h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x1);
		/* 8209E338h case    3:*/		return 0x8209E33C;
		  /* 8209E33Ch */ case    4:  		/* mr R9, R30 */
		/* 8209E33Ch case    4:*/		regs.R9 = regs.R30;
		/* 8209E33Ch case    4:*/		return 0x8209E340;
		  /* 8209E340h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 8209E340h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8209E340h case    5:*/		return 0x8209E344;
		  /* 8209E344h */ case    6:  		/* bc 12, CR6_LT, 12 */
		/* 8209E344h case    6:*/		if ( regs.CR[6].lt ) { return 0x8209E350;  }
		/* 8209E344h case    6:*/		return 0x8209E348;
		  /* 8209E348h */ case    7:  		/* cmplwi CR6, R11, 1 */
		/* 8209E348h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8209E348h case    7:*/		return 0x8209E34C;
		  /* 8209E34Ch */ case    8:  		/* bc 4, CR6_LT, 8 */
		/* 8209E34Ch case    8:*/		if ( !regs.CR[6].lt ) { return 0x8209E354;  }
		/* 8209E34Ch case    8:*/		return 0x8209E350;
	}
	return 0x8209E350;
} // Block from 8209E32Ch-8209E350h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209E350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E350);
		  /* 8209E350h */ case    0:  		/* li R9, 1 */
		/* 8209E350h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8209E350h case    0:*/		return 0x8209E354;
	}
	return 0x8209E354;
} // Block from 8209E350h-8209E354h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209E354h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E354( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E354) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E354);
		  /* 8209E354h */ case    0:  		/* stw R11, <#[R31 + 4]> */
		/* 8209E354h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8209E354h case    0:*/		return 0x8209E358;
		  /* 8209E358h */ case    1:  		/* cmpwi CR6, R9, 0 */
		/* 8209E358h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 8209E358h case    1:*/		return 0x8209E35C;
		  /* 8209E35Ch */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8209E35Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x8209E368;  }
		/* 8209E35Ch case    2:*/		return 0x8209E360;
		  /* 8209E360h */ case    3:  		/* addi R11, R6, 1 */
		/* 8209E360h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R6,0x1);
		/* 8209E360h case    3:*/		return 0x8209E364;
		  /* 8209E364h */ case    4:  		/* stw R11, <#[R31]> */
		/* 8209E364h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209E364h case    4:*/		return 0x8209E368;
	}
	return 0x8209E368;
} // Block from 8209E354h-8209E368h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209E368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E368);
		  /* 8209E368h */ case    0:  		/* lwz R10, <#[R31 + 4]> */
		/* 8209E368h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8209E368h case    0:*/		return 0x8209E36C;
		  /* 8209E36Ch */ case    1:  		/* mr R9, R30 */
		/* 8209E36Ch case    1:*/		regs.R9 = regs.R30;
		/* 8209E36Ch case    1:*/		return 0x8209E370;
		  /* 8209E370h */ case    2:  		/* lwz R7, <#[R1 + 84]> */
		/* 8209E370h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000054) );
		/* 8209E370h case    2:*/		return 0x8209E374;
		  /* 8209E374h */ case    3:  		/* add R11, R10, R7 */
		/* 8209E374h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R7);
		/* 8209E374h case    3:*/		return 0x8209E378;
		  /* 8209E378h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 8209E378h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8209E378h case    4:*/		return 0x8209E37C;
		  /* 8209E37Ch */ case    5:  		/* bc 12, CR6_LT, 12 */
		/* 8209E37Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x8209E388;  }
		/* 8209E37Ch case    5:*/		return 0x8209E380;
		  /* 8209E380h */ case    6:  		/* cmplw CR6, R11, R7 */
		/* 8209E380h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 8209E380h case    6:*/		return 0x8209E384;
		  /* 8209E384h */ case    7:  		/* bc 4, CR6_LT, 8 */
		/* 8209E384h case    7:*/		if ( !regs.CR[6].lt ) { return 0x8209E38C;  }
		/* 8209E384h case    7:*/		return 0x8209E388;
	}
	return 0x8209E388;
} // Block from 8209E368h-8209E388h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209E388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E388);
		  /* 8209E388h */ case    0:  		/* li R9, 1 */
		/* 8209E388h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8209E388h case    0:*/		return 0x8209E38C;
	}
	return 0x8209E38C;
} // Block from 8209E388h-8209E38Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209E38Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E38C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E38C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E38C);
		  /* 8209E38Ch */ case    0:  		/* stw R11, <#[R31 + 4]> */
		/* 8209E38Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8209E38Ch case    0:*/		return 0x8209E390;
		  /* 8209E390h */ case    1:  		/* cmpwi CR6, R9, 0 */
		/* 8209E390h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 8209E390h case    1:*/		return 0x8209E394;
		  /* 8209E394h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8209E394h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209E3A4;  }
		/* 8209E394h case    2:*/		return 0x8209E398;
		  /* 8209E398h */ case    3:  		/* lwz R10, <#[R31]> */
		/* 8209E398h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8209E398h case    3:*/		return 0x8209E39C;
		  /* 8209E39Ch */ case    4:  		/* addi R10, R10, 1 */
		/* 8209E39Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8209E39Ch case    4:*/		return 0x8209E3A0;
		  /* 8209E3A0h */ case    5:  		/* stw R10, <#[R31]> */
		/* 8209E3A0h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8209E3A0h case    5:*/		return 0x8209E3A4;
	}
	return 0x8209E3A4;
} // Block from 8209E38Ch-8209E3A4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209E3A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E3A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E3A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E3A4);
		  /* 8209E3A4h */ case    0:  		/* lwz R9, <#[R31]> */
		/* 8209E3A4h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8209E3A4h case    0:*/		return 0x8209E3A8;
		  /* 8209E3A8h */ case    1:  		/* rlwinm R7, R11, 1, 31, 31 */
		/* 8209E3A8h case    1:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R7,regs.R11);
		/* 8209E3A8h case    1:*/		return 0x8209E3AC;
		  /* 8209E3ACh */ case    2:  		/* lwz R10, <#[R1 + 80]> */
		/* 8209E3ACh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8209E3ACh case    2:*/		return 0x8209E3B0;
		  /* 8209E3B0h */ case    3:  		/* rlwinm R11, R8, 1, 0, 30 */
		/* 8209E3B0h case    3:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R8);
		/* 8209E3B0h case    3:*/		return 0x8209E3B4;
		  /* 8209E3B4h */ case    4:  		/* lwz R6, <#[R31 + 4]> */
		/* 8209E3B4h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000004) );
		/* 8209E3B4h case    4:*/		return 0x8209E3B8;
		  /* 8209E3B8h */ case    5:  		/* rlwinm R8, R8, 1, 31, 31 */
		/* 8209E3B8h case    5:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R8,regs.R8);
		/* 8209E3B8h case    5:*/		return 0x8209E3BC;
		  /* 8209E3BCh */ case    6:  		/* add R10, R9, R10 */
		/* 8209E3BCh case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8209E3BCh case    6:*/		return 0x8209E3C0;
		  /* 8209E3C0h */ case    7:  		/* stw R11, <#[R31 + 8]> */
		/* 8209E3C0h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8209E3C0h case    7:*/		return 0x8209E3C4;
		  /* 8209E3C4h */ case    8:  		/* rlwinm R9, R6, 1, 0, 30 */
		/* 8209E3C4h case    8:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R6);
		/* 8209E3C4h case    8:*/		return 0x8209E3C8;
		  /* 8209E3C8h */ case    9:  		/* rlwinm R10, R10, 1, 0, 30 */
		/* 8209E3C8h case    9:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R10);
		/* 8209E3C8h case    9:*/		return 0x8209E3CC;
		  /* 8209E3CCh */ case   10:  		/* or R8, R9, R8 */
		/* 8209E3CCh case   10:*/		cpu::op::or<0>(regs,&regs.R8,regs.R9,regs.R8);
		/* 8209E3CCh case   10:*/		return 0x8209E3D0;
		  /* 8209E3D0h */ case   11:  		/* or R6, R10, R7 */
		/* 8209E3D0h case   11:*/		cpu::op::or<0>(regs,&regs.R6,regs.R10,regs.R7);
		/* 8209E3D0h case   11:*/		return 0x8209E3D4;
		  /* 8209E3D4h */ case   12:  		/* stw R8, <#[R31 + 4]> */
		/* 8209E3D4h case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 8209E3D4h case   12:*/		return 0x8209E3D8;
		  /* 8209E3D8h */ case   13:  		/* mr R7, R30 */
		/* 8209E3D8h case   13:*/		regs.R7 = regs.R30;
		/* 8209E3D8h case   13:*/		return 0x8209E3DC;
		  /* 8209E3DCh */ case   14:  		/* stw R6, <#[R31]> */
		/* 8209E3DCh case   14:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R31 + 0x00000000) );
		/* 8209E3DCh case   14:*/		return 0x8209E3E0;
		  /* 8209E3E0h */ case   15:  		/* lbz R10, <#[R29]> */
		/* 8209E3E0h case   15:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 8209E3E0h case   15:*/		return 0x8209E3E4;
		  /* 8209E3E4h */ case   16:  		/* extsb R9, R10 */
		/* 8209E3E4h case   16:*/		cpu::op::extsb<0>(regs,&regs.R9,regs.R10);
		/* 8209E3E4h case   16:*/		return 0x8209E3E8;
		  /* 8209E3E8h */ case   17:  		/* add R10, R11, R9 */
		/* 8209E3E8h case   17:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R9);
		/* 8209E3E8h case   17:*/		return 0x8209E3EC;
		  /* 8209E3ECh */ case   18:  		/* stw R9, <#[R1 + 88]> */
		/* 8209E3ECh case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 8209E3ECh case   18:*/		return 0x8209E3F0;
		  /* 8209E3F0h */ case   19:  		/* cmplw CR6, R10, R11 */
		/* 8209E3F0h case   19:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8209E3F0h case   19:*/		return 0x8209E3F4;
		  /* 8209E3F4h */ case   20:  		/* bc 12, CR6_LT, 12 */
		/* 8209E3F4h case   20:*/		if ( regs.CR[6].lt ) { return 0x8209E400;  }
		/* 8209E3F4h case   20:*/		return 0x8209E3F8;
		  /* 8209E3F8h */ case   21:  		/* cmplw CR6, R10, R9 */
		/* 8209E3F8h case   21:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8209E3F8h case   21:*/		return 0x8209E3FC;
		  /* 8209E3FCh */ case   22:  		/* bc 4, CR6_LT, 8 */
		/* 8209E3FCh case   22:*/		if ( !regs.CR[6].lt ) { return 0x8209E404;  }
		/* 8209E3FCh case   22:*/		return 0x8209E400;
	}
	return 0x8209E400;
} // Block from 8209E3A4h-8209E400h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8209E400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E400);
		  /* 8209E400h */ case    0:  		/* li R7, 1 */
		/* 8209E400h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8209E400h case    0:*/		return 0x8209E404;
	}
	return 0x8209E404;
} // Block from 8209E400h-8209E404h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209E404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E404);
		  /* 8209E404h */ case    0:  		/* stw R10, <#[R31 + 8]> */
		/* 8209E404h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8209E404h case    0:*/		return 0x8209E408;
		  /* 8209E408h */ case    1:  		/* cmpwi CR6, R7, 0 */
		/* 8209E408h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 8209E408h case    1:*/		return 0x8209E40C;
		  /* 8209E40Ch */ case    2:  		/* bc 12, CR6_EQ, 52 */
		/* 8209E40Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x8209E440;  }
		/* 8209E40Ch case    2:*/		return 0x8209E410;
		  /* 8209E410h */ case    3:  		/* addi R11, R8, 1 */
		/* 8209E410h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0x1);
		/* 8209E410h case    3:*/		return 0x8209E414;
		  /* 8209E414h */ case    4:  		/* mr R10, R30 */
		/* 8209E414h case    4:*/		regs.R10 = regs.R30;
		/* 8209E414h case    4:*/		return 0x8209E418;
		  /* 8209E418h */ case    5:  		/* cmplw CR6, R11, R8 */
		/* 8209E418h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8209E418h case    5:*/		return 0x8209E41C;
		  /* 8209E41Ch */ case    6:  		/* bc 12, CR6_LT, 12 */
		/* 8209E41Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x8209E428;  }
		/* 8209E41Ch case    6:*/		return 0x8209E420;
		  /* 8209E420h */ case    7:  		/* cmplwi CR6, R11, 1 */
		/* 8209E420h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8209E420h case    7:*/		return 0x8209E424;
		  /* 8209E424h */ case    8:  		/* bc 4, CR6_LT, 8 */
		/* 8209E424h case    8:*/		if ( !regs.CR[6].lt ) { return 0x8209E42C;  }
		/* 8209E424h case    8:*/		return 0x8209E428;
	}
	return 0x8209E428;
} // Block from 8209E404h-8209E428h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209E428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E428);
		  /* 8209E428h */ case    0:  		/* li R10, 1 */
		/* 8209E428h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8209E428h case    0:*/		return 0x8209E42C;
	}
	return 0x8209E42C;
} // Block from 8209E428h-8209E42Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209E42Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E42C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E42C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E42C);
		  /* 8209E42Ch */ case    0:  		/* stw R11, <#[R31 + 4]> */
		/* 8209E42Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8209E42Ch case    0:*/		return 0x8209E430;
		  /* 8209E430h */ case    1:  		/* cmpwi CR6, R10, 0 */
		/* 8209E430h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8209E430h case    1:*/		return 0x8209E434;
		  /* 8209E434h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8209E434h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209E440;  }
		/* 8209E434h case    2:*/		return 0x8209E438;
		  /* 8209E438h */ case    3:  		/* addi R11, R6, 1 */
		/* 8209E438h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R6,0x1);
		/* 8209E438h case    3:*/		return 0x8209E43C;
		  /* 8209E43Ch */ case    4:  		/* stw R11, <#[R31]> */
		/* 8209E43Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209E43Ch case    4:*/		return 0x8209E440;
	}
	return 0x8209E440;
} // Block from 8209E42Ch-8209E440h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209E440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E440);
		  /* 8209E440h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8209E440h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209E440h case    0:*/		return 0x8209E444;
		  /* 8209E444h */ case    1:  		/* addic. R28, R28, -1 */
		/* 8209E444h case    1:*/		cpu::op::addic<1>(regs,&regs.R28,regs.R28,0xFFFFFFFF);
		/* 8209E444h case    1:*/		return 0x8209E448;
		  /* 8209E448h */ case    2:  		/* addi R29, R29, 1 */
		/* 8209E448h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8209E448h case    2:*/		return 0x8209E44C;
		  /* 8209E44Ch */ case    3:  		/* bc 4, CR0_EQ, -432 */
		/* 8209E44Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8209E29C;  }
		/* 8209E44Ch case    3:*/		return 0x8209E450;
		  /* 8209E450h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8209E450h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209E450h case    4:*/		return 0x8209E454;
		  /* 8209E454h */ case    5:  		/* bc 4, CR6_EQ, 144 */
		/* 8209E454h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8209E4E4;  }
		/* 8209E454h case    5:*/		return 0x8209E458;
	}
	return 0x8209E458;
} // Block from 8209E440h-8209E458h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209E458h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E458);
		  /* 8209E458h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8209E458h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8209E458h case    0:*/		return 0x8209E45C;
		  /* 8209E45Ch */ case    1:  		/* rlwinm R10, R27, 0, 16, 31 */
		/* 8209E45Ch case    1:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R27);
		/* 8209E45Ch case    1:*/		return 0x8209E460;
		  /* 8209E460h */ case    2:  		/* lwz R9, <#[R31 + 4]> */
		/* 8209E460h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 8209E460h case    2:*/		return 0x8209E464;
		  /* 8209E464h */ case    3:  		/* rlwinm R8, R11, 16, 16, 31 */
		/* 8209E464h case    3:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R8,regs.R11);
		/* 8209E464h case    3:*/		return 0x8209E468;
		  /* 8209E468h */ case    4:  		/* rlwinm R11, R11, 16, 0, 15 */
		/* 8209E468h case    4:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R11,regs.R11);
		/* 8209E468h case    4:*/		return 0x8209E46C;
		  /* 8209E46Ch */ case    5:  		/* rlwinm R7, R9, 16, 0, 15 */
		/* 8209E46Ch case    5:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R7,regs.R9);
		/* 8209E46Ch case    5:*/		return 0x8209E470;
		  /* 8209E470h */ case    6:  		/* stw R11, <#[R31 + 8]> */
		/* 8209E470h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8209E470h case    6:*/		return 0x8209E474;
		  /* 8209E474h */ case    7:  		/* rlwinm R9, R9, 16, 16, 31 */
		/* 8209E474h case    7:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R9,regs.R9);
		/* 8209E474h case    7:*/		return 0x8209E478;
		  /* 8209E478h */ case    8:  		/* addis R11, R10, 1 */
		/* 8209E478h case    8:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R10,0x1);
		/* 8209E478h case    8:*/		return 0x8209E47C;
		  /* 8209E47Ch */ case    9:  		/* or R8, R7, R8 */
		/* 8209E47Ch case    9:*/		cpu::op::or<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 8209E47Ch case    9:*/		return 0x8209E480;
		  /* 8209E480h */ case   10:  		/* stw R9, <#[R31]> */
		/* 8209E480h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8209E480h case   10:*/		return 0x8209E484;
		  /* 8209E484h */ case   11:  		/* addi R11, R11, -16 */
		/* 8209E484h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFF0);
		/* 8209E484h case   11:*/		return 0x8209E488;
		  /* 8209E488h */ case   12:  		/* rlwinm R10, R9, 0, 0, 31 */
		/* 8209E488h case   12:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R9);
		/* 8209E488h case   12:*/		return 0x8209E48C;
		  /* 8209E48Ch */ case   13:  		/* stw R8, <#[R31 + 4]> */
		/* 8209E48Ch case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 8209E48Ch case   13:*/		return 0x8209E490;
		  /* 8209E490h */ case   14:  		/* rlwinm R27, R11, 0, 16, 31 */
		/* 8209E490h case   14:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R27,regs.R11);
		/* 8209E490h case   14:*/		return 0x8209E494;
		  /* 8209E494h */ case   15:  		/* cmplwi CR6, R10, 0 */
		/* 8209E494h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8209E494h case   15:*/		return 0x8209E498;
		  /* 8209E498h */ case   16:  		/* bc 12, CR6_EQ, -64 */
		/* 8209E498h case   16:*/		if ( regs.CR[6].eq ) { return 0x8209E458;  }
		/* 8209E498h case   16:*/		return 0x8209E49C;
		  /* 8209E49Ch */ case   17:  		/* b 72 */
		/* 8209E49Ch case   17:*/		return 0x8209E4E4;
		/* 8209E49Ch case   17:*/		return 0x8209E4A0;
		  /* 8209E4A0h */ case   18:  		/* lwz R9, <#[R31 + 8]> */
		/* 8209E4A0h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 8209E4A0h case   18:*/		return 0x8209E4A4;
		  /* 8209E4A4h */ case   19:  		/* rlwinm R10, R27, 0, 16, 31 */
		/* 8209E4A4h case   19:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R27);
		/* 8209E4A4h case   19:*/		return 0x8209E4A8;
		  /* 8209E4A8h */ case   20:  		/* lwz R11, <#[R31 + 4]> */
		/* 8209E4A8h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8209E4A8h case   20:*/		return 0x8209E4AC;
		  /* 8209E4ACh */ case   21:  		/* rlwinm R6, R9, 1, 31, 31 */
		/* 8209E4ACh case   21:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R6,regs.R9);
		/* 8209E4ACh case   21:*/		return 0x8209E4B0;
		  /* 8209E4B0h */ case   22:  		/* lwz R7, <#[R31]> */
		/* 8209E4B0h case   22:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000000) );
		/* 8209E4B0h case   22:*/		return 0x8209E4B4;
		  /* 8209E4B4h */ case   23:  		/* rlwinm R9, R9, 1, 0, 30 */
		/* 8209E4B4h case   23:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R9);
		/* 8209E4B4h case   23:*/		return 0x8209E4B8;
		  /* 8209E4B8h */ case   24:  		/* rlwinm R8, R11, 1, 0, 30 */
		/* 8209E4B8h case   24:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R8,regs.R11);
		/* 8209E4B8h case   24:*/		return 0x8209E4BC;
		  /* 8209E4BCh */ case   25:  		/* stw R9, <#[R31 + 8]> */
		/* 8209E4BCh case   25:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 8209E4BCh case   25:*/		return 0x8209E4C0;
		  /* 8209E4C0h */ case   26:  		/* rlwinm R11, R11, 1, 31, 31 */
		/* 8209E4C0h case   26:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R11);
		/* 8209E4C0h case   26:*/		return 0x8209E4C4;
		  /* 8209E4C4h */ case   27:  		/* rlwinm R9, R7, 1, 0, 30 */
		/* 8209E4C4h case   27:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R7);
		/* 8209E4C4h case   27:*/		return 0x8209E4C8;
		  /* 8209E4C8h */ case   28:  		/* addis R10, R10, 1 */
		/* 8209E4C8h case   28:*/		cpu::op::addis<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8209E4C8h case   28:*/		return 0x8209E4CC;
		  /* 8209E4CCh */ case   29:  		/* or R8, R8, R6 */
		/* 8209E4CCh case   29:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R6);
		/* 8209E4CCh case   29:*/		return 0x8209E4D0;
		  /* 8209E4D0h */ case   30:  		/* addi R10, R10, -1 */
		/* 8209E4D0h case   30:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8209E4D0h case   30:*/		return 0x8209E4D4;
		  /* 8209E4D4h */ case   31:  		/* or R11, R9, R11 */
		/* 8209E4D4h case   31:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8209E4D4h case   31:*/		return 0x8209E4D8;
		  /* 8209E4D8h */ case   32:  		/* stw R8, <#[R31 + 4]> */
		/* 8209E4D8h case   32:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 8209E4D8h case   32:*/		return 0x8209E4DC;
		  /* 8209E4DCh */ case   33:  		/* rlwinm R27, R10, 0, 16, 31 */
		/* 8209E4DCh case   33:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R27,regs.R10);
		/* 8209E4DCh case   33:*/		return 0x8209E4E0;
		  /* 8209E4E0h */ case   34:  		/* stw R11, <#[R31]> */
		/* 8209E4E0h case   34:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209E4E0h case   34:*/		return 0x8209E4E4;
	}
	return 0x8209E4E4;
} // Block from 8209E458h-8209E4E4h (35 instructions)

//////////////////////////////////////////////////////
// Block at 8209E4E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E4E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E4E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E4E4);
		  /* 8209E4E4h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8209E4E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209E4E4h case    0:*/		return 0x8209E4E8;
		  /* 8209E4E8h */ case    1:  		/* rlwinm. R11, R11, 0, 16, 16 */
		/* 8209E4E8h case    1:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R11,regs.R11);
		/* 8209E4E8h case    1:*/		return 0x8209E4EC;
		  /* 8209E4ECh */ case    2:  		/* bc 12, CR0_EQ, -76 */
		/* 8209E4ECh case    2:*/		if ( regs.CR[0].eq ) { return 0x8209E4A0;  }
		/* 8209E4ECh case    2:*/		return 0x8209E4F0;
		  /* 8209E4F0h */ case    3:  		/* sth R27, <#[R31]> */
		/* 8209E4F0h case    3:*/		cpu::mem::store16( regs, regs.R27, (uint32)(regs.R31 + 0x00000000) );
		/* 8209E4F0h case    3:*/		return 0x8209E4F4;
		  /* 8209E4F4h */ case    4:  		/* addi R1, R1, 144 */
		/* 8209E4F4h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8209E4F4h case    4:*/		return 0x8209E4F8;
		  /* 8209E4F8h */ case    5:  		/* b -53844 */
		/* 8209E4F8h case    5:*/		return 0x820912A4;
		/* 8209E4F8h case    5:*/		return 0x8209E4FC;
		  /* 8209E4FCh */ case    6:  		/* nop */
		/* 8209E4FCh case    6:*/		cpu::op::nop();
		/* 8209E4FCh case    6:*/		return 0x8209E500;
	}
	return 0x8209E500;
} // Block from 8209E4E4h-8209E500h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209E500h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E500);
		  /* 8209E500h */ case    0:  		/* mfspr R12, LR */
		/* 8209E500h case    0:*/		regs.R12 = regs.LR;
		/* 8209E500h case    0:*/		return 0x8209E504;
		  /* 8209E504h */ case    1:  		/* bl -53928 */
		/* 8209E504h case    1:*/		regs.LR = 0x8209E508; return 0x8209125C;
		/* 8209E504h case    1:*/		return 0x8209E508;
		  /* 8209E508h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209E508h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209E508h case    2:*/		return 0x8209E50C;
		  /* 8209E50Ch */ case    3:  		/* mr R31, R3 */
		/* 8209E50Ch case    3:*/		regs.R31 = regs.R3;
		/* 8209E50Ch case    3:*/		return 0x8209E510;
		  /* 8209E510h */ case    4:  		/* li R30, -1 */
		/* 8209E510h case    4:*/		cpu::op::li<0>(regs,&regs.R30,0xFFFFFFFF);
		/* 8209E510h case    4:*/		return 0x8209E514;
		  /* 8209E514h */ case    5:  		/* cmplwi CR6, R3, 0 */
		/* 8209E514h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209E514h case    5:*/		return 0x8209E518;
		  /* 8209E518h */ case    6:  		/* bc 4, CR6_EQ, 28 */
		/* 8209E518h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8209E534;  }
		/* 8209E518h case    6:*/		return 0x8209E51C;
		  /* 8209E51Ch */ case    7:  		/* bl -38420 */
		/* 8209E51Ch case    7:*/		regs.LR = 0x8209E520; return 0x82094F08;
		/* 8209E51Ch case    7:*/		return 0x8209E520;
		  /* 8209E520h */ case    8:  		/* li R11, 22 */
		/* 8209E520h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 8209E520h case    8:*/		return 0x8209E524;
		  /* 8209E524h */ case    9:  		/* stw R11, <#[R3]> */
		/* 8209E524h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209E524h case    9:*/		return 0x8209E528;
		  /* 8209E528h */ case   10:  		/* bl -43976 */
		/* 8209E528h case   10:*/		regs.LR = 0x8209E52C; return 0x82093960;
		/* 8209E528h case   10:*/		return 0x8209E52C;
		  /* 8209E52Ch */ case   11:  		/* li R3, -1 */
		/* 8209E52Ch case   11:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209E52Ch case   11:*/		return 0x8209E530;
		  /* 8209E530h */ case   12:  		/* b 100 */
		/* 8209E530h case   12:*/		return 0x8209E594;
		/* 8209E530h case   12:*/		return 0x8209E534;
	}
	return 0x8209E534;
} // Block from 8209E500h-8209E534h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209E534h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E534( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E534) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E534);
		  /* 8209E534h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8209E534h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209E534h case    0:*/		return 0x8209E538;
		  /* 8209E538h */ case    1:  		/* li R29, 0 */
		/* 8209E538h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8209E538h case    1:*/		return 0x8209E53C;
		  /* 8209E53Ch */ case    2:  		/* andi. R11, R11, 131 */
		/* 8209E53Ch case    2:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x83);
		/* 8209E53Ch case    2:*/		return 0x8209E540;
		  /* 8209E540h */ case    3:  		/* cmpwi CR0, R11, 0 */
		/* 8209E540h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 8209E540h case    3:*/		return 0x8209E544;
		  /* 8209E544h */ case    4:  		/* bc 12, CR0_EQ, 72 */
		/* 8209E544h case    4:*/		if ( regs.CR[0].eq ) { return 0x8209E58C;  }
		/* 8209E544h case    4:*/		return 0x8209E548;
		  /* 8209E548h */ case    5:  		/* mr R3, R31 */
		/* 8209E548h case    5:*/		regs.R3 = regs.R31;
		/* 8209E548h case    5:*/		return 0x8209E54C;
		  /* 8209E54Ch */ case    6:  		/* bl -2380 */
		/* 8209E54Ch case    6:*/		regs.LR = 0x8209E550; return 0x8209DC00;
		/* 8209E54Ch case    6:*/		return 0x8209E550;
		  /* 8209E550h */ case    7:  		/* mr R30, R3 */
		/* 8209E550h case    7:*/		regs.R30 = regs.R3;
		/* 8209E550h case    7:*/		return 0x8209E554;
		  /* 8209E554h */ case    8:  		/* mr R3, R31 */
		/* 8209E554h case    8:*/		regs.R3 = regs.R31;
		/* 8209E554h case    8:*/		return 0x8209E558;
		  /* 8209E558h */ case    9:  		/* bl 1296 */
		/* 8209E558h case    9:*/		regs.LR = 0x8209E55C; return 0x8209EA68;
		/* 8209E558h case    9:*/		return 0x8209E55C;
		  /* 8209E55Ch */ case   10:  		/* mr R3, R31 */
		/* 8209E55Ch case   10:*/		regs.R3 = regs.R31;
		/* 8209E55Ch case   10:*/		return 0x8209E560;
		  /* 8209E560h */ case   11:  		/* bl -15328 */
		/* 8209E560h case   11:*/		regs.LR = 0x8209E564; return 0x8209A980;
		/* 8209E560h case   11:*/		return 0x8209E564;
		  /* 8209E564h */ case   12:  		/* bl 932 */
		/* 8209E564h case   12:*/		regs.LR = 0x8209E568; return 0x8209E908;
		/* 8209E564h case   12:*/		return 0x8209E568;
		  /* 8209E568h */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 8209E568h case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209E568h case   13:*/		return 0x8209E56C;
		  /* 8209E56Ch */ case   14:  		/* bc 4, CR0_LT, 12 */
		/* 8209E56Ch case   14:*/		if ( !regs.CR[0].lt ) { return 0x8209E578;  }
		/* 8209E56Ch case   14:*/		return 0x8209E570;
		  /* 8209E570h */ case   15:  		/* li R30, -1 */
		/* 8209E570h case   15:*/		cpu::op::li<0>(regs,&regs.R30,0xFFFFFFFF);
		/* 8209E570h case   15:*/		return 0x8209E574;
		  /* 8209E574h */ case   16:  		/* b 24 */
		/* 8209E574h case   16:*/		return 0x8209E58C;
		/* 8209E574h case   16:*/		return 0x8209E578;
	}
	return 0x8209E578;
} // Block from 8209E534h-8209E578h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8209E578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E578);
		  /* 8209E578h */ case    0:  		/* lwz R3, <#[R31 + 28]> */
		/* 8209E578h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000001C) );
		/* 8209E578h case    0:*/		return 0x8209E57C;
		  /* 8209E57Ch */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8209E57Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209E57Ch case    1:*/		return 0x8209E580;
		  /* 8209E580h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8209E580h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209E58C;  }
		/* 8209E580h case    2:*/		return 0x8209E584;
		  /* 8209E584h */ case    3:  		/* bl -44380 */
		/* 8209E584h case    3:*/		regs.LR = 0x8209E588; return 0x82093828;
		/* 8209E584h case    3:*/		return 0x8209E588;
		  /* 8209E588h */ case    4:  		/* stw R29, <#[R31 + 28]> */
		/* 8209E588h case    4:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x0000001C) );
		/* 8209E588h case    4:*/		return 0x8209E58C;
	}
	return 0x8209E58C;
} // Block from 8209E578h-8209E58Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209E58Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E58C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E58C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E58C);
		  /* 8209E58Ch */ case    0:  		/* mr R3, R30 */
		/* 8209E58Ch case    0:*/		regs.R3 = regs.R30;
		/* 8209E58Ch case    0:*/		return 0x8209E590;
		  /* 8209E590h */ case    1:  		/* stw R29, <#[R31 + 12]> */
		/* 8209E590h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209E590h case    1:*/		return 0x8209E594;
	}
	return 0x8209E594;
} // Block from 8209E58Ch-8209E594h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209E594h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E594( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E594) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E594);
		  /* 8209E594h */ case    0:  		/* addi R1, R1, 112 */
		/* 8209E594h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8209E594h case    0:*/		return 0x8209E598;
		  /* 8209E598h */ case    1:  		/* b -53996 */
		/* 8209E598h case    1:*/		return 0x820912AC;
		/* 8209E598h case    1:*/		return 0x8209E59C;
		  /* 8209E59Ch */ case    2:  		/* nop */
		/* 8209E59Ch case    2:*/		cpu::op::nop();
		/* 8209E59Ch case    2:*/		return 0x8209E5A0;
		  /* 8209E5A0h */ case    3:  		/* lwz R17, <#[R6 - 11576]> */
		/* 8209E5A0h case    3:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 8209E5A0h case    3:*/		return 0x8209E5A4;
		  /* 8209E5A4h */ case    4:  		/* lwz R16, <#[R4 - 15120]> */
		/* 8209E5A4h case    4:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC4F0) );
		/* 8209E5A4h case    4:*/		return 0x8209E5A8;
	}
	return 0x8209E5A8;
} // Block from 8209E594h-8209E5A8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209E5A8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E5A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E5A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E5A8);
		  /* 8209E5A8h */ case    0:  		/* mfspr R12, LR */
		/* 8209E5A8h case    0:*/		regs.R12 = regs.LR;
		/* 8209E5A8h case    0:*/		return 0x8209E5AC;
		  /* 8209E5ACh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209E5ACh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209E5ACh case    1:*/		return 0x8209E5B0;
		  /* 8209E5B0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8209E5B0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209E5B0h case    2:*/		return 0x8209E5B4;
		  /* 8209E5B4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8209E5B4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209E5B4h case    3:*/		return 0x8209E5B8;
		  /* 8209E5B8h */ case    4:  		/* addi R31, R1, -112 */
		/* 8209E5B8h case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFF90);
		/* 8209E5B8h case    4:*/		return 0x8209E5BC;
		  /* 8209E5BCh */ case    5:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209E5BCh case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209E5BCh case    5:*/		return 0x8209E5C0;
		  /* 8209E5C0h */ case    6:  		/* mr R30, R3 */
		/* 8209E5C0h case    6:*/		regs.R30 = regs.R3;
		/* 8209E5C0h case    6:*/		return 0x8209E5C4;
		  /* 8209E5C4h */ case    7:  		/* stw R3, <#[R31 + 132]> */
		/* 8209E5C4h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000084) );
		/* 8209E5C4h case    7:*/		return 0x8209E5C8;
		  /* 8209E5C8h */ case    8:  		/* addic R11, R3, -1 */
		/* 8209E5C8h case    8:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R3,0xFFFFFFFF);
		/* 8209E5C8h case    8:*/		return 0x8209E5CC;
		  /* 8209E5CCh */ case    9:  		/* li R10, -1 */
		/* 8209E5CCh case    9:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8209E5CCh case    9:*/		return 0x8209E5D0;
		  /* 8209E5D0h */ case   10:  		/* subfe. R11, R11, R3 */
		/* 8209E5D0h case   10:*/		cpu::op::subfe<1>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8209E5D0h case   10:*/		return 0x8209E5D4;
		  /* 8209E5D4h */ case   11:  		/* stw R10, <#[R31 + 80]> */
		/* 8209E5D4h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 8209E5D4h case   11:*/		return 0x8209E5D8;
		  /* 8209E5D8h */ case   12:  		/* bc 4, CR0_EQ, 28 */
		/* 8209E5D8h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8209E5F4;  }
		/* 8209E5D8h case   12:*/		return 0x8209E5DC;
		  /* 8209E5DCh */ case   13:  		/* bl -38612 */
		/* 8209E5DCh case   13:*/		regs.LR = 0x8209E5E0; return 0x82094F08;
		/* 8209E5DCh case   13:*/		return 0x8209E5E0;
		  /* 8209E5E0h */ case   14:  		/* li R11, 22 */
		/* 8209E5E0h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 8209E5E0h case   14:*/		return 0x8209E5E4;
		  /* 8209E5E4h */ case   15:  		/* stw R11, <#[R3]> */
		/* 8209E5E4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209E5E4h case   15:*/		return 0x8209E5E8;
		  /* 8209E5E8h */ case   16:  		/* bl -44168 */
		/* 8209E5E8h case   16:*/		regs.LR = 0x8209E5EC; return 0x82093960;
		/* 8209E5E8h case   16:*/		return 0x8209E5EC;
		  /* 8209E5ECh */ case   17:  		/* li R3, -1 */
		/* 8209E5ECh case   17:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209E5ECh case   17:*/		return 0x8209E5F0;
		  /* 8209E5F0h */ case   18:  		/* b 28 */
		/* 8209E5F0h case   18:*/		return 0x8209E60C;
		/* 8209E5F0h case   18:*/		return 0x8209E5F4;
	}
	return 0x8209E5F4;
} // Block from 8209E5A8h-8209E5F4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8209E5F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E5F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E5F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E5F4);
		  /* 8209E5F4h */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 8209E5F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8209E5F4h case    0:*/		return 0x8209E5F8;
		  /* 8209E5F8h */ case    1:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 8209E5F8h case    1:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 8209E5F8h case    1:*/		return 0x8209E5FC;
		  /* 8209E5FCh */ case    2:  		/* bc 12, CR0_EQ, 40 */
		/* 8209E5FCh case    2:*/		if ( regs.CR[0].eq ) { return 0x8209E624;  }
		/* 8209E5FCh case    2:*/		return 0x8209E600;
		  /* 8209E600h */ case    3:  		/* li R11, 0 */
		/* 8209E600h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209E600h case    3:*/		return 0x8209E604;
		  /* 8209E604h */ case    4:  		/* stw R11, <#[R30 + 12]> */
		/* 8209E604h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8209E604h case    4:*/		return 0x8209E608;
		  /* 8209E608h */ case    5:  		/* lwz R3, <#[R31 + 80]> */
		/* 8209E608h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 8209E608h case    5:*/		return 0x8209E60C;
	}
	return 0x8209E60C;
} // Block from 8209E5F4h-8209E60Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209E60Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E60C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E60C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E60C);
		  /* 8209E60Ch */ case    0:  		/* addi R1, R31, 112 */
		/* 8209E60Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0x70);
		/* 8209E60Ch case    0:*/		return 0x8209E610;
		  /* 8209E610h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209E610h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209E610h case    1:*/		return 0x8209E614;
		  /* 8209E614h */ case    2:  		/* mtspr LR, R12 */
		/* 8209E614h case    2:*/		regs.LR = regs.R12;
		/* 8209E614h case    2:*/		return 0x8209E618;
		  /* 8209E618h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 8209E618h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209E618h case    3:*/		return 0x8209E61C;
		  /* 8209E61Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8209E61Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209E61Ch case    4:*/		return 0x8209E620;
		  /* 8209E620h */ case    5:  		/* bclr 20, CR0_LT */
		/* 8209E620h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209E620h case    5:*/		return 0x8209E624;
	}
	return 0x8209E624;
} // Block from 8209E60Ch-8209E624h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209E624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E624);
		  /* 8209E624h */ case    0:  		/* mr R3, R30 */
		/* 8209E624h case    0:*/		regs.R3 = regs.R30;
		/* 8209E624h case    0:*/		return 0x8209E628;
		  /* 8209E628h */ case    1:  		/* bl -15824 */
		/* 8209E628h case    1:*/		regs.LR = 0x8209E62C; return 0x8209A858;
		/* 8209E628h case    1:*/		return 0x8209E62C;
		  /* 8209E62Ch */ case    2:  		/* nop */
		/* 8209E62Ch case    2:*/		cpu::op::nop();
		/* 8209E62Ch case    2:*/		return 0x8209E630;
	}
	return 0x8209E630;
} // Block from 8209E624h-8209E630h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209E630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E630);
		  /* 8209E630h */ case    0:  		/* mr R3, R30 */
		/* 8209E630h case    0:*/		regs.R3 = regs.R30;
		/* 8209E630h case    0:*/		return 0x8209E634;
		  /* 8209E634h */ case    1:  		/* bl -308 */
		/* 8209E634h case    1:*/		regs.LR = 0x8209E638; return 0x8209E500;
		/* 8209E634h case    1:*/		return 0x8209E638;
		  /* 8209E638h */ case    2:  		/* stw R3, <#[R31 + 80]> */
		/* 8209E638h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 8209E638h case    2:*/		return 0x8209E63C;
	}
	return 0x8209E63C;
} // Block from 8209E630h-8209E63Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209E63Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E63C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E63C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E63C);
		  /* 8209E63Ch */ case    0:  		/* nop */
		/* 8209E63Ch case    0:*/		cpu::op::nop();
		/* 8209E63Ch case    0:*/		return 0x8209E640;
		  /* 8209E640h */ case    1:  		/* addi R12, R31, 112 */
		/* 8209E640h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R31,0x70);
		/* 8209E640h case    1:*/		return 0x8209E644;
		  /* 8209E644h */ case    2:  		/* bl 40 */
		/* 8209E644h case    2:*/		regs.LR = 0x8209E648; return 0x8209E66C;
		/* 8209E644h case    2:*/		return 0x8209E648;
		  /* 8209E648h */ case    3:  		/* b -64 */
		/* 8209E648h case    3:*/		return 0x8209E608;
		/* 8209E648h case    3:*/		return 0x8209E64C;
	}
	return 0x8209E64C;
} // Block from 8209E63Ch-8209E64Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209E64Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E64C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E64C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E64C);
		  /* 8209E64Ch */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8209E64Ch case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209E64Ch case    0:*/		return 0x8209E650;
		  /* 8209E650h */ case    1:  		/* addi R31, R12, -112 */
		/* 8209E650h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFF90);
		/* 8209E650h case    1:*/		return 0x8209E654;
		  /* 8209E654h */ case    2:  		/* std R30, <#[R1 - 16]> */
		/* 8209E654h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209E654h case    2:*/		return 0x8209E658;
		  /* 8209E658h */ case    3:  		/* mfspr R12, LR */
		/* 8209E658h case    3:*/		regs.R12 = regs.LR;
		/* 8209E658h case    3:*/		return 0x8209E65C;
		  /* 8209E65Ch */ case    4:  		/* stw R12, <#[R1 - 24]> */
		/* 8209E65Ch case    4:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209E65Ch case    4:*/		return 0x8209E660;
		  /* 8209E660h */ case    5:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209E660h case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209E660h case    5:*/		return 0x8209E664;
		  /* 8209E664h */ case    6:  		/* lwz R30, <#[R31 + 132]> */
		/* 8209E664h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000084) );
		/* 8209E664h case    6:*/		return 0x8209E668;
		  /* 8209E668h */ case    7:  		/* b 28 */
		/* 8209E668h case    7:*/		return 0x8209E684;
		/* 8209E668h case    7:*/		return 0x8209E66C;
	}
	return 0x8209E66C;
} // Block from 8209E64Ch-8209E66Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209E66Ch
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E66C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E66C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E66C);
		  /* 8209E66Ch */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8209E66Ch case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209E66Ch case    0:*/		return 0x8209E670;
		  /* 8209E670h */ case    1:  		/* addi R31, R12, -112 */
		/* 8209E670h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFF90);
		/* 8209E670h case    1:*/		return 0x8209E674;
		  /* 8209E674h */ case    2:  		/* std R30, <#[R1 - 16]> */
		/* 8209E674h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209E674h case    2:*/		return 0x8209E678;
		  /* 8209E678h */ case    3:  		/* mfspr R12, LR */
		/* 8209E678h case    3:*/		regs.R12 = regs.LR;
		/* 8209E678h case    3:*/		return 0x8209E67C;
		  /* 8209E67Ch */ case    4:  		/* stw R12, <#[R1 - 24]> */
		/* 8209E67Ch case    4:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209E67Ch case    4:*/		return 0x8209E680;
		  /* 8209E680h */ case    5:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209E680h case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209E680h case    5:*/		return 0x8209E684;
	}
	return 0x8209E684;
} // Block from 8209E66Ch-8209E684h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209E684h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E684( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E684) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E684);
		  /* 8209E684h */ case    0:  		/* mr R3, R30 */
		/* 8209E684h case    0:*/		regs.R3 = regs.R30;
		/* 8209E684h case    0:*/		return 0x8209E688;
		  /* 8209E688h */ case    1:  		/* bl -15728 */
		/* 8209E688h case    1:*/		regs.LR = 0x8209E68C; return 0x8209A918;
		/* 8209E688h case    1:*/		return 0x8209E68C;
		  /* 8209E68Ch */ case    2:  		/* lwz R1, <#[R1]> */
		/* 8209E68Ch case    2:*/		cpu::mem::load32z( regs, &regs.R1, (uint32)(regs.R1 + 0x00000000) );
		/* 8209E68Ch case    2:*/		return 0x8209E690;
		  /* 8209E690h */ case    3:  		/* ld R31, <#[R1 - 8]> */
		/* 8209E690h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209E690h case    3:*/		return 0x8209E694;
		  /* 8209E694h */ case    4:  		/* ld R30, <#[R1 - 16]> */
		/* 8209E694h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209E694h case    4:*/		return 0x8209E698;
		  /* 8209E698h */ case    5:  		/* lwz R12, <#[R1 - 24]> */
		/* 8209E698h case    5:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209E698h case    5:*/		return 0x8209E69C;
		  /* 8209E69Ch */ case    6:  		/* mtspr LR, R12 */
		/* 8209E69Ch case    6:*/		regs.LR = regs.R12;
		/* 8209E69Ch case    6:*/		return 0x8209E6A0;
		  /* 8209E6A0h */ case    7:  		/* bclr 20, CR0_LT */
		/* 8209E6A0h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209E6A0h case    7:*/		return 0x8209E6A4;
	}
	return 0x8209E6A4;
} // Block from 8209E684h-8209E6A4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209E6A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E6A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E6A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E6A4);
		  /* 8209E6A4h */ case    0:  		/* nop */
		/* 8209E6A4h case    0:*/		cpu::op::nop();
		/* 8209E6A4h case    0:*/		return 0x8209E6A8;
		  /* 8209E6A8h */ case    1:  		/* lwz R17, <#[R6 - 11576]> */
		/* 8209E6A8h case    1:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 8209E6A8h case    1:*/		return 0x8209E6AC;
		  /* 8209E6ACh */ case    2:  		/* lwz R16, <#[R4 - 15096]> */
		/* 8209E6ACh case    2:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC508) );
		/* 8209E6ACh case    2:*/		return 0x8209E6B0;
	}
	return 0x8209E6B0;
} // Block from 8209E6A4h-8209E6B0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209E6B0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E6B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E6B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E6B0);
		  /* 8209E6B0h */ case    0:  		/* mfspr R12, LR */
		/* 8209E6B0h case    0:*/		regs.R12 = regs.LR;
		/* 8209E6B0h case    0:*/		return 0x8209E6B4;
		  /* 8209E6B4h */ case    1:  		/* bl -54368 */
		/* 8209E6B4h case    1:*/		regs.LR = 0x8209E6B8; return 0x82091254;
		/* 8209E6B4h case    1:*/		return 0x8209E6B8;
		  /* 8209E6B8h */ case    2:  		/* addi R31, R1, -144 */
		/* 8209E6B8h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFF70);
		/* 8209E6B8h case    2:*/		return 0x8209E6BC;
		  /* 8209E6BCh */ case    3:  		/* stwu R1, <#[R1 - 144]> */
		/* 8209E6BCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8209E6BCh case    3:*/		return 0x8209E6C0;
		  /* 8209E6C0h */ case    4:  		/* mr R27, R3 */
		/* 8209E6C0h case    4:*/		regs.R27 = regs.R3;
		/* 8209E6C0h case    4:*/		return 0x8209E6C4;
		  /* 8209E6C4h */ case    5:  		/* stw R3, <#[R31 + 164]> */
		/* 8209E6C4h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000000A4) );
		/* 8209E6C4h case    5:*/		return 0x8209E6C8;
		  /* 8209E6C8h */ case    6:  		/* cmpwi CR6, R3, -2 */
		/* 8209E6C8h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFE);
		/* 8209E6C8h case    6:*/		return 0x8209E6CC;
		  /* 8209E6CCh */ case    7:  		/* bc 4, CR6_EQ, 28 */
		/* 8209E6CCh case    7:*/		if ( !regs.CR[6].eq ) { return 0x8209E6E8;  }
		/* 8209E6CCh case    7:*/		return 0x8209E6D0;
		  /* 8209E6D0h */ case    8:  		/* bl -38856 */
		/* 8209E6D0h case    8:*/		regs.LR = 0x8209E6D4; return 0x82094F08;
		/* 8209E6D0h case    8:*/		return 0x8209E6D4;
		  /* 8209E6D4h */ case    9:  		/* mr R11, R3 */
		/* 8209E6D4h case    9:*/		regs.R11 = regs.R3;
		/* 8209E6D4h case    9:*/		return 0x8209E6D8;
		  /* 8209E6D8h */ case   10:  		/* li R10, 9 */
		/* 8209E6D8h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x9);
		/* 8209E6D8h case   10:*/		return 0x8209E6DC;
		  /* 8209E6DCh */ case   11:  		/* li R3, -1 */
		/* 8209E6DCh case   11:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209E6DCh case   11:*/		return 0x8209E6E0;
		  /* 8209E6E0h */ case   12:  		/* stw R10, <#[R11]> */
		/* 8209E6E0h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209E6E0h case   12:*/		return 0x8209E6E4;
		  /* 8209E6E4h */ case   13:  		/* b 220 */
		/* 8209E6E4h case   13:*/		return 0x8209E7C0;
		/* 8209E6E4h case   13:*/		return 0x8209E6E8;
	}
	return 0x8209E6E8;
} // Block from 8209E6B0h-8209E6E8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209E6E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E6E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E6E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E6E8);
		  /* 8209E6E8h */ case    0:  		/* cmpwi CR6, R27, 0 */
		/* 8209E6E8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 8209E6E8h case    0:*/		return 0x8209E6EC;
		  /* 8209E6ECh */ case    1:  		/* bc 12, CR6_LT, 20 */
		/* 8209E6ECh case    1:*/		if ( regs.CR[6].lt ) { return 0x8209E700;  }
		/* 8209E6ECh case    1:*/		return 0x8209E6F0;
		  /* 8209E6F0h */ case    2:  		/* lis R11, -32215 */
		/* 8209E6F0h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8209E6F0h case    2:*/		return 0x8209E6F4;
		  /* 8209E6F4h */ case    3:  		/* lwz R11, <#[R11 - 25512]> */
		/* 8209E6F4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFF9C58) );
		/* 8209E6F4h case    3:*/		return 0x8209E6F8;
		  /* 8209E6F8h */ case    4:  		/* cmplw CR6, R27, R11 */
		/* 8209E6F8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 8209E6F8h case    4:*/		return 0x8209E6FC;
		  /* 8209E6FCh */ case    5:  		/* bc 12, CR6_LT, 28 */
		/* 8209E6FCh case    5:*/		if ( regs.CR[6].lt ) { return 0x8209E718;  }
		/* 8209E6FCh case    5:*/		return 0x8209E700;
	}
	return 0x8209E700;
} // Block from 8209E6E8h-8209E700h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209E700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E700);
		  /* 8209E700h */ case    0:  		/* bl -38904 */
		/* 8209E700h case    0:*/		regs.LR = 0x8209E704; return 0x82094F08;
		/* 8209E700h case    0:*/		return 0x8209E704;
		  /* 8209E704h */ case    1:  		/* li R11, 9 */
		/* 8209E704h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 8209E704h case    1:*/		return 0x8209E708;
		  /* 8209E708h */ case    2:  		/* stw R11, <#[R3]> */
		/* 8209E708h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209E708h case    2:*/		return 0x8209E70C;
		  /* 8209E70Ch */ case    3:  		/* bl -44460 */
		/* 8209E70Ch case    3:*/		regs.LR = 0x8209E710; return 0x82093960;
		/* 8209E70Ch case    3:*/		return 0x8209E710;
		  /* 8209E710h */ case    4:  		/* li R3, -1 */
		/* 8209E710h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209E710h case    4:*/		return 0x8209E714;
		  /* 8209E714h */ case    5:  		/* b 172 */
		/* 8209E714h case    5:*/		return 0x8209E7C0;
		/* 8209E714h case    5:*/		return 0x8209E718;
	}
	return 0x8209E718;
} // Block from 8209E700h-8209E718h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209E718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E718);
		  /* 8209E718h */ case    0:  		/* srawi R11, R27, 5 */
		/* 8209E718h case    0:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R27);
		/* 8209E718h case    0:*/		return 0x8209E71C;
		  /* 8209E71Ch */ case    1:  		/* lis R10, -32215 */
		/* 8209E71Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 8209E71Ch case    1:*/		return 0x8209E720;
		  /* 8209E720h */ case    2:  		/* rlwinm R28, R11, 2, 0, 29 */
		/* 8209E720h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R11);
		/* 8209E720h case    2:*/		return 0x8209E724;
		  /* 8209E724h */ case    3:  		/* addi R29, R10, -25504 */
		/* 8209E724h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R10,0xFFFF9C60);
		/* 8209E724h case    3:*/		return 0x8209E728;
		  /* 8209E728h */ case    4:  		/* rlwinm R11, R27, 0, 27, 31 */
		/* 8209E728h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R27);
		/* 8209E728h case    4:*/		return 0x8209E72C;
		  /* 8209E72Ch */ case    5:  		/* mulli R30, R11, 72 */
		/* 8209E72Ch case    5:*/		cpu::op::mulli<0>(regs,&regs.R30,regs.R11,0x48);
		/* 8209E72Ch case    5:*/		return 0x8209E730;
		  /* 8209E730h */ case    6:  		/* lwzx R11, <#[R28 + R29]> */
		/* 8209E730h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R29 + 0x00000000) );
		/* 8209E730h case    6:*/		return 0x8209E734;
		  /* 8209E734h */ case    7:  		/* add R11, R30, R11 */
		/* 8209E734h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 8209E734h case    7:*/		return 0x8209E738;
		  /* 8209E738h */ case    8:  		/* lbz R11, <#[R11 + 4]> */
		/* 8209E738h case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8209E738h case    8:*/		return 0x8209E73C;
		  /* 8209E73Ch */ case    9:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8209E73Ch case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8209E73Ch case    9:*/		return 0x8209E740;
		  /* 8209E740h */ case   10:  		/* bc 12, CR0_EQ, -64 */
		/* 8209E740h case   10:*/		if ( regs.CR[0].eq ) { return 0x8209E700;  }
		/* 8209E740h case   10:*/		return 0x8209E744;
		  /* 8209E744h */ case   11:  		/* mr R3, R27 */
		/* 8209E744h case   11:*/		regs.R3 = regs.R27;
		/* 8209E744h case   11:*/		return 0x8209E748;
		  /* 8209E748h */ case   12:  		/* bl -3424 */
		/* 8209E748h case   12:*/		regs.LR = 0x8209E74C; return 0x8209D9E8;
		/* 8209E748h case   12:*/		return 0x8209E74C;
		  /* 8209E74Ch */ case   13:  		/* nop */
		/* 8209E74Ch case   13:*/		cpu::op::nop();
		/* 8209E74Ch case   13:*/		return 0x8209E750;
	}
	return 0x8209E750;
} // Block from 8209E718h-8209E750h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209E750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E750);
		  /* 8209E750h */ case    0:  		/* lwzx R11, <#[R28 + R29]> */
		/* 8209E750h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R29 + 0x00000000) );
		/* 8209E750h case    0:*/		return 0x8209E754;
		  /* 8209E754h */ case    1:  		/* add R11, R30, R11 */
		/* 8209E754h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 8209E754h case    1:*/		return 0x8209E758;
		  /* 8209E758h */ case    2:  		/* lbz R11, <#[R11 + 4]> */
		/* 8209E758h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8209E758h case    2:*/		return 0x8209E75C;
		  /* 8209E75Ch */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8209E75Ch case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8209E75Ch case    3:*/		return 0x8209E760;
		  /* 8209E760h */ case    4:  		/* bc 12, CR0_EQ, 60 */
		/* 8209E760h case    4:*/		if ( regs.CR[0].eq ) { return 0x8209E79C;  }
		/* 8209E760h case    4:*/		return 0x8209E764;
		  /* 8209E764h */ case    5:  		/* mr R3, R27 */
		/* 8209E764h case    5:*/		regs.R3 = regs.R27;
		/* 8209E764h case    5:*/		return 0x8209E768;
		  /* 8209E768h */ case    6:  		/* bl -3648 */
		/* 8209E768h case    6:*/		regs.LR = 0x8209E76C; return 0x8209D928;
		/* 8209E768h case    6:*/		return 0x8209E76C;
		  /* 8209E76Ch */ case    7:  		/* bl 1871164 */
		/* 8209E76Ch case    7:*/		regs.LR = 0x8209E770; return 0x822674A8;
		/* 8209E76Ch case    7:*/		return 0x8209E770;
		  /* 8209E770h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 8209E770h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209E770h case    8:*/		return 0x8209E774;
		  /* 8209E774h */ case    9:  		/* bc 4, CR0_EQ, 16 */
		/* 8209E774h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8209E784;  }
		/* 8209E774h case    9:*/		return 0x8209E778;
		  /* 8209E778h */ case   10:  		/* bl -82040 */
		/* 8209E778h case   10:*/		regs.LR = 0x8209E77C; return 0x8208A700;
		/* 8209E778h case   10:*/		return 0x8209E77C;
		  /* 8209E77Ch */ case   11:  		/* mr R30, R3 */
		/* 8209E77Ch case   11:*/		regs.R30 = regs.R3;
		/* 8209E77Ch case   11:*/		return 0x8209E780;
		  /* 8209E780h */ case   12:  		/* b 8 */
		/* 8209E780h case   12:*/		return 0x8209E788;
		/* 8209E780h case   12:*/		return 0x8209E784;
	}
	return 0x8209E784;
} // Block from 8209E750h-8209E784h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209E784h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E784( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E784) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E784);
		  /* 8209E784h */ case    0:  		/* li R30, 0 */
		/* 8209E784h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8209E784h case    0:*/		return 0x8209E788;
	}
	return 0x8209E788;
} // Block from 8209E784h-8209E788h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209E788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E788);
		  /* 8209E788h */ case    0:  		/* stw R30, <#[R31 + 80]> */
		/* 8209E788h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000050) );
		/* 8209E788h case    0:*/		return 0x8209E78C;
		  /* 8209E78Ch */ case    1:  		/* cmpwi CR6, R30, 0 */
		/* 8209E78Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 8209E78Ch case    1:*/		return 0x8209E790;
		  /* 8209E790h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 8209E790h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209E7B0;  }
		/* 8209E790h case    2:*/		return 0x8209E794;
		  /* 8209E794h */ case    3:  		/* bl -38996 */
		/* 8209E794h case    3:*/		regs.LR = 0x8209E798; return 0x82094F40;
		/* 8209E794h case    3:*/		return 0x8209E798;
		  /* 8209E798h */ case    4:  		/* stw R30, <#[R3]> */
		/* 8209E798h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8209E798h case    4:*/		return 0x8209E79C;
	}
	return 0x8209E79C;
} // Block from 8209E788h-8209E79Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209E79Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E79C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E79C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E79C);
		  /* 8209E79Ch */ case    0:  		/* bl -39060 */
		/* 8209E79Ch case    0:*/		regs.LR = 0x8209E7A0; return 0x82094F08;
		/* 8209E79Ch case    0:*/		return 0x8209E7A0;
		  /* 8209E7A0h */ case    1:  		/* li R11, 9 */
		/* 8209E7A0h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 8209E7A0h case    1:*/		return 0x8209E7A4;
		  /* 8209E7A4h */ case    2:  		/* li R10, -1 */
		/* 8209E7A4h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8209E7A4h case    2:*/		return 0x8209E7A8;
		  /* 8209E7A8h */ case    3:  		/* stw R11, <#[R3]> */
		/* 8209E7A8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209E7A8h case    3:*/		return 0x8209E7AC;
		  /* 8209E7ACh */ case    4:  		/* stw R10, <#[R31 + 80]> */
		/* 8209E7ACh case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 8209E7ACh case    4:*/		return 0x8209E7B0;
	}
	return 0x8209E7B0;
} // Block from 8209E79Ch-8209E7B0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209E7B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E7B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E7B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E7B0);
		  /* 8209E7B0h */ case    0:  		/* nop */
		/* 8209E7B0h case    0:*/		cpu::op::nop();
		/* 8209E7B0h case    0:*/		return 0x8209E7B4;
		  /* 8209E7B4h */ case    1:  		/* addi R12, R31, 144 */
		/* 8209E7B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R31,0x90);
		/* 8209E7B4h case    1:*/		return 0x8209E7B8;
		  /* 8209E7B8h */ case    2:  		/* bl 48 */
		/* 8209E7B8h case    2:*/		regs.LR = 0x8209E7BC; return 0x8209E7E8;
		/* 8209E7B8h case    2:*/		return 0x8209E7BC;
		  /* 8209E7BCh */ case    3:  		/* lwz R3, <#[R31 + 80]> */
		/* 8209E7BCh case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 8209E7BCh case    3:*/		return 0x8209E7C0;
	}
	return 0x8209E7C0;
} // Block from 8209E7B0h-8209E7C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209E7C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E7C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E7C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E7C0);
		  /* 8209E7C0h */ case    0:  		/* addi R1, R31, 144 */
		/* 8209E7C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0x90);
		/* 8209E7C0h case    0:*/		return 0x8209E7C4;
		  /* 8209E7C4h */ case    1:  		/* b -54560 */
		/* 8209E7C4h case    1:*/		return 0x820912A4;
		/* 8209E7C4h case    1:*/		return 0x8209E7C8;
	}
	return 0x8209E7C8;
} // Block from 8209E7C0h-8209E7C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209E7C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E7C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E7C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E7C8);
		  /* 8209E7C8h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8209E7C8h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209E7C8h case    0:*/		return 0x8209E7CC;
		  /* 8209E7CCh */ case    1:  		/* addi R31, R12, -144 */
		/* 8209E7CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFF70);
		/* 8209E7CCh case    1:*/		return 0x8209E7D0;
		  /* 8209E7D0h */ case    2:  		/* std R27, <#[R1 - 16]> */
		/* 8209E7D0h case    2:*/		cpu::mem::store64( regs, regs.R27, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209E7D0h case    2:*/		return 0x8209E7D4;
		  /* 8209E7D4h */ case    3:  		/* mfspr R12, LR */
		/* 8209E7D4h case    3:*/		regs.R12 = regs.LR;
		/* 8209E7D4h case    3:*/		return 0x8209E7D8;
		  /* 8209E7D8h */ case    4:  		/* stw R12, <#[R1 - 24]> */
		/* 8209E7D8h case    4:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209E7D8h case    4:*/		return 0x8209E7DC;
		  /* 8209E7DCh */ case    5:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209E7DCh case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209E7DCh case    5:*/		return 0x8209E7E0;
		  /* 8209E7E0h */ case    6:  		/* lwz R27, <#[R31 + 164]> */
		/* 8209E7E0h case    6:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R31 + 0x000000A4) );
		/* 8209E7E0h case    6:*/		return 0x8209E7E4;
		  /* 8209E7E4h */ case    7:  		/* b 28 */
		/* 8209E7E4h case    7:*/		return 0x8209E800;
		/* 8209E7E4h case    7:*/		return 0x8209E7E8;
	}
	return 0x8209E7E8;
} // Block from 8209E7C8h-8209E7E8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209E7E8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E7E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E7E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E7E8);
		  /* 8209E7E8h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8209E7E8h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209E7E8h case    0:*/		return 0x8209E7EC;
		  /* 8209E7ECh */ case    1:  		/* addi R31, R12, -144 */
		/* 8209E7ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFF70);
		/* 8209E7ECh case    1:*/		return 0x8209E7F0;
		  /* 8209E7F0h */ case    2:  		/* std R27, <#[R1 - 16]> */
		/* 8209E7F0h case    2:*/		cpu::mem::store64( regs, regs.R27, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209E7F0h case    2:*/		return 0x8209E7F4;
		  /* 8209E7F4h */ case    3:  		/* mfspr R12, LR */
		/* 8209E7F4h case    3:*/		regs.R12 = regs.LR;
		/* 8209E7F4h case    3:*/		return 0x8209E7F8;
		  /* 8209E7F8h */ case    4:  		/* stw R12, <#[R1 - 24]> */
		/* 8209E7F8h case    4:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209E7F8h case    4:*/		return 0x8209E7FC;
		  /* 8209E7FCh */ case    5:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209E7FCh case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209E7FCh case    5:*/		return 0x8209E800;
	}
	return 0x8209E800;
} // Block from 8209E7E8h-8209E800h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209E800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E800);
		  /* 8209E800h */ case    0:  		/* mr R3, R27 */
		/* 8209E800h case    0:*/		regs.R3 = regs.R27;
		/* 8209E800h case    0:*/		return 0x8209E804;
		  /* 8209E804h */ case    1:  		/* bl -3356 */
		/* 8209E804h case    1:*/		regs.LR = 0x8209E808; return 0x8209DAE8;
		/* 8209E804h case    1:*/		return 0x8209E808;
		  /* 8209E808h */ case    2:  		/* lwz R1, <#[R1]> */
		/* 8209E808h case    2:*/		cpu::mem::load32z( regs, &regs.R1, (uint32)(regs.R1 + 0x00000000) );
		/* 8209E808h case    2:*/		return 0x8209E80C;
		  /* 8209E80Ch */ case    3:  		/* ld R31, <#[R1 - 8]> */
		/* 8209E80Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209E80Ch case    3:*/		return 0x8209E810;
		  /* 8209E810h */ case    4:  		/* ld R27, <#[R1 - 16]> */
		/* 8209E810h case    4:*/		cpu::mem::load64( regs, &regs.R27, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209E810h case    4:*/		return 0x8209E814;
		  /* 8209E814h */ case    5:  		/* lwz R12, <#[R1 - 24]> */
		/* 8209E814h case    5:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209E814h case    5:*/		return 0x8209E818;
		  /* 8209E818h */ case    6:  		/* mtspr LR, R12 */
		/* 8209E818h case    6:*/		regs.LR = regs.R12;
		/* 8209E818h case    6:*/		return 0x8209E81C;
		  /* 8209E81Ch */ case    7:  		/* bclr 20, CR0_LT */
		/* 8209E81Ch case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209E81Ch case    7:*/		return 0x8209E820;
	}
	return 0x8209E820;
} // Block from 8209E800h-8209E820h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209E820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E820);
		  /* 8209E820h */ case    0:  		/* mfspr R12, LR */
		/* 8209E820h case    0:*/		regs.R12 = regs.LR;
		/* 8209E820h case    0:*/		return 0x8209E824;
		  /* 8209E824h */ case    1:  		/* bl -54728 */
		/* 8209E824h case    1:*/		regs.LR = 0x8209E828; return 0x8209125C;
		/* 8209E824h case    1:*/		return 0x8209E828;
		  /* 8209E828h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209E828h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209E828h case    2:*/		return 0x8209E82C;
		  /* 8209E82Ch */ case    3:  		/* mr R31, R3 */
		/* 8209E82Ch case    3:*/		regs.R31 = regs.R3;
		/* 8209E82Ch case    3:*/		return 0x8209E830;
		  /* 8209E830h */ case    4:  		/* bl -3848 */
		/* 8209E830h case    4:*/		regs.LR = 0x8209E834; return 0x8209D928;
		/* 8209E830h case    4:*/		return 0x8209E834;
		  /* 8209E834h */ case    5:  		/* lis R11, -32215 */
		/* 8209E834h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8209E834h case    5:*/		return 0x8209E838;
		  /* 8209E838h */ case    6:  		/* cmpwi CR6, R3, -1 */
		/* 8209E838h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8209E838h case    6:*/		return 0x8209E83C;
		  /* 8209E83Ch */ case    7:  		/* addi R29, R11, -25504 */
		/* 8209E83Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFF9C60);
		/* 8209E83Ch case    7:*/		return 0x8209E840;
		  /* 8209E840h */ case    8:  		/* bc 12, CR6_EQ, 108 */
		/* 8209E840h case    8:*/		if ( regs.CR[6].eq ) { return 0x8209E8AC;  }
		/* 8209E840h case    8:*/		return 0x8209E844;
		  /* 8209E844h */ case    9:  		/* lwz R11, <#[R29]> */
		/* 8209E844h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8209E844h case    9:*/		return 0x8209E848;
		  /* 8209E848h */ case   10:  		/* cmpwi CR6, R31, 1 */
		/* 8209E848h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000001);
		/* 8209E848h case   10:*/		return 0x8209E84C;
		  /* 8209E84Ch */ case   11:  		/* bc 4, CR6_EQ, 16 */
		/* 8209E84Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x8209E85C;  }
		/* 8209E84Ch case   11:*/		return 0x8209E850;
		  /* 8209E850h */ case   12:  		/* lbz R10, <#[R11 + 148]> */
		/* 8209E850h case   12:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000094) );
		/* 8209E850h case   12:*/		return 0x8209E854;
		  /* 8209E854h */ case   13:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 8209E854h case   13:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 8209E854h case   13:*/		return 0x8209E858;
		  /* 8209E858h */ case   14:  		/* bc 4, CR0_EQ, 24 */
		/* 8209E858h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8209E870;  }
		/* 8209E858h case   14:*/		return 0x8209E85C;
	}
	return 0x8209E85C;
} // Block from 8209E820h-8209E85Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8209E85Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E85C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E85C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E85C);
		  /* 8209E85Ch */ case    0:  		/* cmpwi CR6, R31, 2 */
		/* 8209E85Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000002);
		/* 8209E85Ch case    0:*/		return 0x8209E860;
		  /* 8209E860h */ case    1:  		/* bc 4, CR6_EQ, 44 */
		/* 8209E860h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209E88C;  }
		/* 8209E860h case    1:*/		return 0x8209E864;
		  /* 8209E864h */ case    2:  		/* lbz R11, <#[R11 + 76]> */
		/* 8209E864h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 8209E864h case    2:*/		return 0x8209E868;
		  /* 8209E868h */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8209E868h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8209E868h case    3:*/		return 0x8209E86C;
		  /* 8209E86Ch */ case    4:  		/* bc 12, CR0_EQ, 32 */
		/* 8209E86Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x8209E88C;  }
		/* 8209E86Ch case    4:*/		return 0x8209E870;
	}
	return 0x8209E870;
} // Block from 8209E85Ch-8209E870h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209E870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E870);
		  /* 8209E870h */ case    0:  		/* li R3, 2 */
		/* 8209E870h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 8209E870h case    0:*/		return 0x8209E874;
		  /* 8209E874h */ case    1:  		/* bl -3916 */
		/* 8209E874h case    1:*/		regs.LR = 0x8209E878; return 0x8209D928;
		/* 8209E874h case    1:*/		return 0x8209E878;
		  /* 8209E878h */ case    2:  		/* mr R30, R3 */
		/* 8209E878h case    2:*/		regs.R30 = regs.R3;
		/* 8209E878h case    2:*/		return 0x8209E87C;
		  /* 8209E87Ch */ case    3:  		/* li R3, 1 */
		/* 8209E87Ch case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8209E87Ch case    3:*/		return 0x8209E880;
		  /* 8209E880h */ case    4:  		/* bl -3928 */
		/* 8209E880h case    4:*/		regs.LR = 0x8209E884; return 0x8209D928;
		/* 8209E880h case    4:*/		return 0x8209E884;
		  /* 8209E884h */ case    5:  		/* cmpw CR6, R3, R30 */
		/* 8209E884h case    5:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R30);
		/* 8209E884h case    5:*/		return 0x8209E888;
		  /* 8209E888h */ case    6:  		/* bc 12, CR6_EQ, 36 */
		/* 8209E888h case    6:*/		if ( regs.CR[6].eq ) { return 0x8209E8AC;  }
		/* 8209E888h case    6:*/		return 0x8209E88C;
	}
	return 0x8209E88C;
} // Block from 8209E870h-8209E88Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209E88Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E88C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E88C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E88C);
		  /* 8209E88Ch */ case    0:  		/* mr R3, R31 */
		/* 8209E88Ch case    0:*/		regs.R3 = regs.R31;
		/* 8209E88Ch case    0:*/		return 0x8209E890;
		  /* 8209E890h */ case    1:  		/* bl -3944 */
		/* 8209E890h case    1:*/		regs.LR = 0x8209E894; return 0x8209D928;
		/* 8209E890h case    1:*/		return 0x8209E894;
		  /* 8209E894h */ case    2:  		/* bl -90252 */
		/* 8209E894h case    2:*/		regs.LR = 0x8209E898; return 0x82088808;
		/* 8209E894h case    2:*/		return 0x8209E898;
		  /* 8209E898h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 8209E898h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209E898h case    3:*/		return 0x8209E89C;
		  /* 8209E89Ch */ case    4:  		/* bc 4, CR0_EQ, 16 */
		/* 8209E89Ch case    4:*/		if ( !regs.CR[0].eq ) { return 0x8209E8AC;  }
		/* 8209E89Ch case    4:*/		return 0x8209E8A0;
		  /* 8209E8A0h */ case    5:  		/* bl -82336 */
		/* 8209E8A0h case    5:*/		regs.LR = 0x8209E8A4; return 0x8208A700;
		/* 8209E8A0h case    5:*/		return 0x8209E8A4;
		  /* 8209E8A4h */ case    6:  		/* mr R30, R3 */
		/* 8209E8A4h case    6:*/		regs.R30 = regs.R3;
		/* 8209E8A4h case    6:*/		return 0x8209E8A8;
		  /* 8209E8A8h */ case    7:  		/* b 8 */
		/* 8209E8A8h case    7:*/		return 0x8209E8B0;
		/* 8209E8A8h case    7:*/		return 0x8209E8AC;
	}
	return 0x8209E8AC;
} // Block from 8209E88Ch-8209E8ACh (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209E8ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E8AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E8AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E8AC);
		  /* 8209E8ACh */ case    0:  		/* li R30, 0 */
		/* 8209E8ACh case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8209E8ACh case    0:*/		return 0x8209E8B0;
	}
	return 0x8209E8B0;
} // Block from 8209E8ACh-8209E8B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209E8B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E8B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E8B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E8B0);
		  /* 8209E8B0h */ case    0:  		/* mr R3, R31 */
		/* 8209E8B0h case    0:*/		regs.R3 = regs.R31;
		/* 8209E8B0h case    0:*/		return 0x8209E8B4;
		  /* 8209E8B4h */ case    1:  		/* bl -4132 */
		/* 8209E8B4h case    1:*/		regs.LR = 0x8209E8B8; return 0x8209D890;
		/* 8209E8B4h case    1:*/		return 0x8209E8B8;
		  /* 8209E8B8h */ case    2:  		/* srawi R11, R31, 5 */
		/* 8209E8B8h case    2:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R31);
		/* 8209E8B8h case    2:*/		return 0x8209E8BC;
		  /* 8209E8BCh */ case    3:  		/* rlwinm R10, R31, 0, 27, 31 */
		/* 8209E8BCh case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R31);
		/* 8209E8BCh case    3:*/		return 0x8209E8C0;
		  /* 8209E8C0h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8209E8C0h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8209E8C0h case    4:*/		return 0x8209E8C4;
		  /* 8209E8C4h */ case    5:  		/* mulli R10, R10, 72 */
		/* 8209E8C4h case    5:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x48);
		/* 8209E8C4h case    5:*/		return 0x8209E8C8;
		  /* 8209E8C8h */ case    6:  		/* cmplwi CR6, R30, 0 */
		/* 8209E8C8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8209E8C8h case    6:*/		return 0x8209E8CC;
		  /* 8209E8CCh */ case    7:  		/* lwzx R11, <#[R11 + R29]> */
		/* 8209E8CCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 8209E8CCh case    7:*/		return 0x8209E8D0;
		  /* 8209E8D0h */ case    8:  		/* add R11, R11, R10 */
		/* 8209E8D0h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8209E8D0h case    8:*/		return 0x8209E8D4;
		  /* 8209E8D4h */ case    9:  		/* li R10, 0 */
		/* 8209E8D4h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8209E8D4h case    9:*/		return 0x8209E8D8;
		  /* 8209E8D8h */ case   10:  		/* stb R10, <#[R11 + 4]> */
		/* 8209E8D8h case   10:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8209E8D8h case   10:*/		return 0x8209E8DC;
		  /* 8209E8DCh */ case   11:  		/* bc 12, CR6_EQ, 20 */
		/* 8209E8DCh case   11:*/		if ( regs.CR[6].eq ) { return 0x8209E8F0;  }
		/* 8209E8DCh case   11:*/		return 0x8209E8E0;
		  /* 8209E8E0h */ case   12:  		/* mr R3, R30 */
		/* 8209E8E0h case   12:*/		regs.R3 = regs.R30;
		/* 8209E8E0h case   12:*/		return 0x8209E8E4;
		  /* 8209E8E4h */ case   13:  		/* bl -39276 */
		/* 8209E8E4h case   13:*/		regs.LR = 0x8209E8E8; return 0x82094F78;
		/* 8209E8E4h case   13:*/		return 0x8209E8E8;
		  /* 8209E8E8h */ case   14:  		/* li R3, -1 */
		/* 8209E8E8h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209E8E8h case   14:*/		return 0x8209E8EC;
		  /* 8209E8ECh */ case   15:  		/* b 8 */
		/* 8209E8ECh case   15:*/		return 0x8209E8F4;
		/* 8209E8ECh case   15:*/		return 0x8209E8F0;
	}
	return 0x8209E8F0;
} // Block from 8209E8B0h-8209E8F0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8209E8F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E8F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E8F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E8F0);
		  /* 8209E8F0h */ case    0:  		/* li R3, 0 */
		/* 8209E8F0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209E8F0h case    0:*/		return 0x8209E8F4;
	}
	return 0x8209E8F4;
} // Block from 8209E8F0h-8209E8F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209E8F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E8F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E8F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E8F4);
		  /* 8209E8F4h */ case    0:  		/* addi R1, R1, 112 */
		/* 8209E8F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8209E8F4h case    0:*/		return 0x8209E8F8;
		  /* 8209E8F8h */ case    1:  		/* b -54860 */
		/* 8209E8F8h case    1:*/		return 0x820912AC;
		/* 8209E8F8h case    1:*/		return 0x8209E8FC;
		  /* 8209E8FCh */ case    2:  		/* nop */
		/* 8209E8FCh case    2:*/		cpu::op::nop();
		/* 8209E8FCh case    2:*/		return 0x8209E900;
		  /* 8209E900h */ case    3:  		/* lwz R17, <#[R6 - 11576]> */
		/* 8209E900h case    3:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 8209E900h case    3:*/		return 0x8209E904;
		  /* 8209E904h */ case    4:  		/* lwz R16, <#[R4 - 15072]> */
		/* 8209E904h case    4:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC520) );
		/* 8209E904h case    4:*/		return 0x8209E908;
	}
	return 0x8209E908;
} // Block from 8209E8F4h-8209E908h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209E908h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E908);
		  /* 8209E908h */ case    0:  		/* mfspr R12, LR */
		/* 8209E908h case    0:*/		regs.R12 = regs.LR;
		/* 8209E908h case    0:*/		return 0x8209E90C;
		  /* 8209E90Ch */ case    1:  		/* bl -54968 */
		/* 8209E90Ch case    1:*/		regs.LR = 0x8209E910; return 0x82091254;
		/* 8209E90Ch case    1:*/		return 0x8209E910;
		  /* 8209E910h */ case    2:  		/* addi R31, R1, -144 */
		/* 8209E910h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFF70);
		/* 8209E910h case    2:*/		return 0x8209E914;
		  /* 8209E914h */ case    3:  		/* stwu R1, <#[R1 - 144]> */
		/* 8209E914h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8209E914h case    3:*/		return 0x8209E918;
		  /* 8209E918h */ case    4:  		/* mr R30, R3 */
		/* 8209E918h case    4:*/		regs.R30 = regs.R3;
		/* 8209E918h case    4:*/		return 0x8209E91C;
		  /* 8209E91Ch */ case    5:  		/* stw R3, <#[R31 + 164]> */
		/* 8209E91Ch case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000000A4) );
		/* 8209E91Ch case    5:*/		return 0x8209E920;
		  /* 8209E920h */ case    6:  		/* cmpwi CR6, R3, -2 */
		/* 8209E920h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFE);
		/* 8209E920h case    6:*/		return 0x8209E924;
		  /* 8209E924h */ case    7:  		/* bc 4, CR6_EQ, 40 */
		/* 8209E924h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8209E94C;  }
		/* 8209E924h case    7:*/		return 0x8209E928;
		  /* 8209E928h */ case    8:  		/* bl -39400 */
		/* 8209E928h case    8:*/		regs.LR = 0x8209E92C; return 0x82094F40;
		/* 8209E928h case    8:*/		return 0x8209E92C;
		  /* 8209E92Ch */ case    9:  		/* li R11, 0 */
		/* 8209E92Ch case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209E92Ch case    9:*/		return 0x8209E930;
		  /* 8209E930h */ case   10:  		/* stw R11, <#[R3]> */
		/* 8209E930h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209E930h case   10:*/		return 0x8209E934;
		  /* 8209E934h */ case   11:  		/* bl -39468 */
		/* 8209E934h case   11:*/		regs.LR = 0x8209E938; return 0x82094F08;
		/* 8209E934h case   11:*/		return 0x8209E938;
		  /* 8209E938h */ case   12:  		/* mr R11, R3 */
		/* 8209E938h case   12:*/		regs.R11 = regs.R3;
		/* 8209E938h case   12:*/		return 0x8209E93C;
		  /* 8209E93Ch */ case   13:  		/* li R10, 9 */
		/* 8209E93Ch case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x9);
		/* 8209E93Ch case   13:*/		return 0x8209E940;
		  /* 8209E940h */ case   14:  		/* li R3, -1 */
		/* 8209E940h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209E940h case   14:*/		return 0x8209E944;
		  /* 8209E944h */ case   15:  		/* stw R10, <#[R11]> */
		/* 8209E944h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209E944h case   15:*/		return 0x8209E948;
		  /* 8209E948h */ case   16:  		/* b 192 */
		/* 8209E948h case   16:*/		return 0x8209EA08;
		/* 8209E948h case   16:*/		return 0x8209E94C;
	}
	return 0x8209E94C;
} // Block from 8209E908h-8209E94Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8209E94Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E94C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E94C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E94C);
		  /* 8209E94Ch */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 8209E94Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 8209E94Ch case    0:*/		return 0x8209E950;
		  /* 8209E950h */ case    1:  		/* bc 12, CR6_LT, 20 */
		/* 8209E950h case    1:*/		if ( regs.CR[6].lt ) { return 0x8209E964;  }
		/* 8209E950h case    1:*/		return 0x8209E954;
		  /* 8209E954h */ case    2:  		/* lis R11, -32215 */
		/* 8209E954h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8209E954h case    2:*/		return 0x8209E958;
		  /* 8209E958h */ case    3:  		/* lwz R11, <#[R11 - 25512]> */
		/* 8209E958h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFF9C58) );
		/* 8209E958h case    3:*/		return 0x8209E95C;
		  /* 8209E95Ch */ case    4:  		/* cmplw CR6, R30, R11 */
		/* 8209E95Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8209E95Ch case    4:*/		return 0x8209E960;
		  /* 8209E960h */ case    5:  		/* bc 12, CR6_LT, 40 */
		/* 8209E960h case    5:*/		if ( regs.CR[6].lt ) { return 0x8209E988;  }
		/* 8209E960h case    5:*/		return 0x8209E964;
	}
	return 0x8209E964;
} // Block from 8209E94Ch-8209E964h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209E964h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E964( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E964) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E964);
		  /* 8209E964h */ case    0:  		/* bl -39460 */
		/* 8209E964h case    0:*/		regs.LR = 0x8209E968; return 0x82094F40;
		/* 8209E964h case    0:*/		return 0x8209E968;
		  /* 8209E968h */ case    1:  		/* li R11, 0 */
		/* 8209E968h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209E968h case    1:*/		return 0x8209E96C;
		  /* 8209E96Ch */ case    2:  		/* stw R11, <#[R3]> */
		/* 8209E96Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209E96Ch case    2:*/		return 0x8209E970;
		  /* 8209E970h */ case    3:  		/* bl -39528 */
		/* 8209E970h case    3:*/		regs.LR = 0x8209E974; return 0x82094F08;
		/* 8209E970h case    3:*/		return 0x8209E974;
		  /* 8209E974h */ case    4:  		/* li R11, 9 */
		/* 8209E974h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 8209E974h case    4:*/		return 0x8209E978;
		  /* 8209E978h */ case    5:  		/* stw R11, <#[R3]> */
		/* 8209E978h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209E978h case    5:*/		return 0x8209E97C;
		  /* 8209E97Ch */ case    6:  		/* bl -45084 */
		/* 8209E97Ch case    6:*/		regs.LR = 0x8209E980; return 0x82093960;
		/* 8209E97Ch case    6:*/		return 0x8209E980;
		  /* 8209E980h */ case    7:  		/* li R3, -1 */
		/* 8209E980h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8209E980h case    7:*/		return 0x8209E984;
		  /* 8209E984h */ case    8:  		/* b 132 */
		/* 8209E984h case    8:*/		return 0x8209EA08;
		/* 8209E984h case    8:*/		return 0x8209E988;
	}
	return 0x8209E988;
} // Block from 8209E964h-8209E988h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209E988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E988);
		  /* 8209E988h */ case    0:  		/* srawi R11, R30, 5 */
		/* 8209E988h case    0:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R30);
		/* 8209E988h case    0:*/		return 0x8209E98C;
		  /* 8209E98Ch */ case    1:  		/* lis R10, -32215 */
		/* 8209E98Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 8209E98Ch case    1:*/		return 0x8209E990;
		  /* 8209E990h */ case    2:  		/* rlwinm R27, R11, 2, 0, 29 */
		/* 8209E990h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R11);
		/* 8209E990h case    2:*/		return 0x8209E994;
		  /* 8209E994h */ case    3:  		/* addi R28, R10, -25504 */
		/* 8209E994h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R10,0xFFFF9C60);
		/* 8209E994h case    3:*/		return 0x8209E998;
		  /* 8209E998h */ case    4:  		/* rlwinm R11, R30, 0, 27, 31 */
		/* 8209E998h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R30);
		/* 8209E998h case    4:*/		return 0x8209E99C;
		  /* 8209E99Ch */ case    5:  		/* mulli R29, R11, 72 */
		/* 8209E99Ch case    5:*/		cpu::op::mulli<0>(regs,&regs.R29,regs.R11,0x48);
		/* 8209E99Ch case    5:*/		return 0x8209E9A0;
		  /* 8209E9A0h */ case    6:  		/* lwzx R11, <#[R27 + R28]> */
		/* 8209E9A0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + regs.R28 + 0x00000000) );
		/* 8209E9A0h case    6:*/		return 0x8209E9A4;
		  /* 8209E9A4h */ case    7:  		/* add R11, R11, R29 */
		/* 8209E9A4h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8209E9A4h case    7:*/		return 0x8209E9A8;
		  /* 8209E9A8h */ case    8:  		/* lbz R11, <#[R11 + 4]> */
		/* 8209E9A8h case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8209E9A8h case    8:*/		return 0x8209E9AC;
		  /* 8209E9ACh */ case    9:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8209E9ACh case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8209E9ACh case    9:*/		return 0x8209E9B0;
		  /* 8209E9B0h */ case   10:  		/* bc 12, CR0_EQ, -76 */
		/* 8209E9B0h case   10:*/		if ( regs.CR[0].eq ) { return 0x8209E964;  }
		/* 8209E9B0h case   10:*/		return 0x8209E9B4;
		  /* 8209E9B4h */ case   11:  		/* mr R3, R30 */
		/* 8209E9B4h case   11:*/		regs.R3 = regs.R30;
		/* 8209E9B4h case   11:*/		return 0x8209E9B8;
		  /* 8209E9B8h */ case   12:  		/* bl -4048 */
		/* 8209E9B8h case   12:*/		regs.LR = 0x8209E9BC; return 0x8209D9E8;
		/* 8209E9B8h case   12:*/		return 0x8209E9BC;
		  /* 8209E9BCh */ case   13:  		/* nop */
		/* 8209E9BCh case   13:*/		cpu::op::nop();
		/* 8209E9BCh case   13:*/		return 0x8209E9C0;
	}
	return 0x8209E9C0;
} // Block from 8209E988h-8209E9C0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209E9C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E9C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E9C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E9C0);
		  /* 8209E9C0h */ case    0:  		/* lwzx R11, <#[R27 + R28]> */
		/* 8209E9C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + regs.R28 + 0x00000000) );
		/* 8209E9C0h case    0:*/		return 0x8209E9C4;
		  /* 8209E9C4h */ case    1:  		/* add R11, R11, R29 */
		/* 8209E9C4h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8209E9C4h case    1:*/		return 0x8209E9C8;
		  /* 8209E9C8h */ case    2:  		/* lbz R11, <#[R11 + 4]> */
		/* 8209E9C8h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8209E9C8h case    2:*/		return 0x8209E9CC;
		  /* 8209E9CCh */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8209E9CCh case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8209E9CCh case    3:*/		return 0x8209E9D0;
		  /* 8209E9D0h */ case    4:  		/* bc 12, CR0_EQ, 20 */
		/* 8209E9D0h case    4:*/		if ( regs.CR[0].eq ) { return 0x8209E9E4;  }
		/* 8209E9D0h case    4:*/		return 0x8209E9D4;
		  /* 8209E9D4h */ case    5:  		/* mr R3, R30 */
		/* 8209E9D4h case    5:*/		regs.R3 = regs.R30;
		/* 8209E9D4h case    5:*/		return 0x8209E9D8;
		  /* 8209E9D8h */ case    6:  		/* bl -440 */
		/* 8209E9D8h case    6:*/		regs.LR = 0x8209E9DC; return 0x8209E820;
		/* 8209E9D8h case    6:*/		return 0x8209E9DC;
		  /* 8209E9DCh */ case    7:  		/* stw R3, <#[R31 + 80]> */
		/* 8209E9DCh case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 8209E9DCh case    7:*/		return 0x8209E9E0;
		  /* 8209E9E0h */ case    8:  		/* b 24 */
		/* 8209E9E0h case    8:*/		return 0x8209E9F8;
		/* 8209E9E0h case    8:*/		return 0x8209E9E4;
	}
	return 0x8209E9E4;
} // Block from 8209E9C0h-8209E9E4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209E9E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E9E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E9E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E9E4);
		  /* 8209E9E4h */ case    0:  		/* bl -39644 */
		/* 8209E9E4h case    0:*/		regs.LR = 0x8209E9E8; return 0x82094F08;
		/* 8209E9E4h case    0:*/		return 0x8209E9E8;
		  /* 8209E9E8h */ case    1:  		/* li R11, 9 */
		/* 8209E9E8h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 8209E9E8h case    1:*/		return 0x8209E9EC;
		  /* 8209E9ECh */ case    2:  		/* li R10, -1 */
		/* 8209E9ECh case    2:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8209E9ECh case    2:*/		return 0x8209E9F0;
		  /* 8209E9F0h */ case    3:  		/* stw R11, <#[R3]> */
		/* 8209E9F0h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209E9F0h case    3:*/		return 0x8209E9F4;
		  /* 8209E9F4h */ case    4:  		/* stw R10, <#[R31 + 80]> */
		/* 8209E9F4h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 8209E9F4h case    4:*/		return 0x8209E9F8;
	}
	return 0x8209E9F8;
} // Block from 8209E9E4h-8209E9F8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209E9F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209E9F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209E9F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209E9F8);
		  /* 8209E9F8h */ case    0:  		/* nop */
		/* 8209E9F8h case    0:*/		cpu::op::nop();
		/* 8209E9F8h case    0:*/		return 0x8209E9FC;
		  /* 8209E9FCh */ case    1:  		/* addi R12, R31, 144 */
		/* 8209E9FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R31,0x90);
		/* 8209E9FCh case    1:*/		return 0x8209EA00;
		  /* 8209EA00h */ case    2:  		/* bl 48 */
		/* 8209EA00h case    2:*/		regs.LR = 0x8209EA04; return 0x8209EA30;
		/* 8209EA00h case    2:*/		return 0x8209EA04;
		  /* 8209EA04h */ case    3:  		/* lwz R3, <#[R31 + 80]> */
		/* 8209EA04h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 8209EA04h case    3:*/		return 0x8209EA08;
	}
	return 0x8209EA08;
} // Block from 8209E9F8h-8209EA08h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209EA08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EA08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EA08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EA08);
		  /* 8209EA08h */ case    0:  		/* addi R1, R31, 144 */
		/* 8209EA08h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0x90);
		/* 8209EA08h case    0:*/		return 0x8209EA0C;
		  /* 8209EA0Ch */ case    1:  		/* b -55144 */
		/* 8209EA0Ch case    1:*/		return 0x820912A4;
		/* 8209EA0Ch case    1:*/		return 0x8209EA10;
	}
	return 0x8209EA10;
} // Block from 8209EA08h-8209EA10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209EA10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EA10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EA10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EA10);
		  /* 8209EA10h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8209EA10h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209EA10h case    0:*/		return 0x8209EA14;
		  /* 8209EA14h */ case    1:  		/* addi R31, R12, -144 */
		/* 8209EA14h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFF70);
		/* 8209EA14h case    1:*/		return 0x8209EA18;
		  /* 8209EA18h */ case    2:  		/* std R30, <#[R1 - 16]> */
		/* 8209EA18h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209EA18h case    2:*/		return 0x8209EA1C;
		  /* 8209EA1Ch */ case    3:  		/* mfspr R12, LR */
		/* 8209EA1Ch case    3:*/		regs.R12 = regs.LR;
		/* 8209EA1Ch case    3:*/		return 0x8209EA20;
		  /* 8209EA20h */ case    4:  		/* stw R12, <#[R1 - 24]> */
		/* 8209EA20h case    4:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209EA20h case    4:*/		return 0x8209EA24;
		  /* 8209EA24h */ case    5:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209EA24h case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209EA24h case    5:*/		return 0x8209EA28;
		  /* 8209EA28h */ case    6:  		/* lwz R30, <#[R31 + 164]> */
		/* 8209EA28h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x000000A4) );
		/* 8209EA28h case    6:*/		return 0x8209EA2C;
		  /* 8209EA2Ch */ case    7:  		/* b 28 */
		/* 8209EA2Ch case    7:*/		return 0x8209EA48;
		/* 8209EA2Ch case    7:*/		return 0x8209EA30;
	}
	return 0x8209EA30;
} // Block from 8209EA10h-8209EA30h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209EA30h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EA30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EA30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EA30);
		  /* 8209EA30h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8209EA30h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209EA30h case    0:*/		return 0x8209EA34;
		  /* 8209EA34h */ case    1:  		/* addi R31, R12, -144 */
		/* 8209EA34h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R12,0xFFFFFF70);
		/* 8209EA34h case    1:*/		return 0x8209EA38;
		  /* 8209EA38h */ case    2:  		/* std R30, <#[R1 - 16]> */
		/* 8209EA38h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209EA38h case    2:*/		return 0x8209EA3C;
		  /* 8209EA3Ch */ case    3:  		/* mfspr R12, LR */
		/* 8209EA3Ch case    3:*/		regs.R12 = regs.LR;
		/* 8209EA3Ch case    3:*/		return 0x8209EA40;
		  /* 8209EA40h */ case    4:  		/* stw R12, <#[R1 - 24]> */
		/* 8209EA40h case    4:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209EA40h case    4:*/		return 0x8209EA44;
		  /* 8209EA44h */ case    5:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209EA44h case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209EA44h case    5:*/		return 0x8209EA48;
	}
	return 0x8209EA48;
} // Block from 8209EA30h-8209EA48h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209EA48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EA48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EA48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EA48);
		  /* 8209EA48h */ case    0:  		/* mr R3, R30 */
		/* 8209EA48h case    0:*/		regs.R3 = regs.R30;
		/* 8209EA48h case    0:*/		return 0x8209EA4C;
		  /* 8209EA4Ch */ case    1:  		/* bl -3940 */
		/* 8209EA4Ch case    1:*/		regs.LR = 0x8209EA50; return 0x8209DAE8;
		/* 8209EA4Ch case    1:*/		return 0x8209EA50;
		  /* 8209EA50h */ case    2:  		/* lwz R1, <#[R1]> */
		/* 8209EA50h case    2:*/		cpu::mem::load32z( regs, &regs.R1, (uint32)(regs.R1 + 0x00000000) );
		/* 8209EA50h case    2:*/		return 0x8209EA54;
		  /* 8209EA54h */ case    3:  		/* ld R31, <#[R1 - 8]> */
		/* 8209EA54h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209EA54h case    3:*/		return 0x8209EA58;
		  /* 8209EA58h */ case    4:  		/* ld R30, <#[R1 - 16]> */
		/* 8209EA58h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209EA58h case    4:*/		return 0x8209EA5C;
		  /* 8209EA5Ch */ case    5:  		/* lwz R12, <#[R1 - 24]> */
		/* 8209EA5Ch case    5:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209EA5Ch case    5:*/		return 0x8209EA60;
		  /* 8209EA60h */ case    6:  		/* mtspr LR, R12 */
		/* 8209EA60h case    6:*/		regs.LR = regs.R12;
		/* 8209EA60h case    6:*/		return 0x8209EA64;
		  /* 8209EA64h */ case    7:  		/* bclr 20, CR0_LT */
		/* 8209EA64h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209EA64h case    7:*/		return 0x8209EA68;
	}
	return 0x8209EA68;
} // Block from 8209EA48h-8209EA68h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209EA68h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EA68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EA68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EA68);
		  /* 8209EA68h */ case    0:  		/* mfspr R12, LR */
		/* 8209EA68h case    0:*/		regs.R12 = regs.LR;
		/* 8209EA68h case    0:*/		return 0x8209EA6C;
		  /* 8209EA6Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209EA6Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209EA6Ch case    1:*/		return 0x8209EA70;
		  /* 8209EA70h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8209EA70h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209EA70h case    2:*/		return 0x8209EA74;
		  /* 8209EA74h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209EA74h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209EA74h case    3:*/		return 0x8209EA78;
		  /* 8209EA78h */ case    4:  		/* lwz R11, <#[R3 + 12]> */
		/* 8209EA78h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8209EA78h case    4:*/		return 0x8209EA7C;
		  /* 8209EA7Ch */ case    5:  		/* mr R31, R3 */
		/* 8209EA7Ch case    5:*/		regs.R31 = regs.R3;
		/* 8209EA7Ch case    5:*/		return 0x8209EA80;
		  /* 8209EA80h */ case    6:  		/* andi. R10, R11, 131 */
		/* 8209EA80h case    6:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0x83);
		/* 8209EA80h case    6:*/		return 0x8209EA84;
		  /* 8209EA84h */ case    7:  		/* cmpwi CR0, R10, 0 */
		/* 8209EA84h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R10,0x00000000);
		/* 8209EA84h case    7:*/		return 0x8209EA88;
		  /* 8209EA88h */ case    8:  		/* bc 12, CR0_EQ, 52 */
		/* 8209EA88h case    8:*/		if ( regs.CR[0].eq ) { return 0x8209EABC;  }
		/* 8209EA88h case    8:*/		return 0x8209EA8C;
		  /* 8209EA8Ch */ case    9:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 8209EA8Ch case    9:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 8209EA8Ch case    9:*/		return 0x8209EA90;
		  /* 8209EA90h */ case   10:  		/* bc 12, CR0_EQ, 44 */
		/* 8209EA90h case   10:*/		if ( regs.CR[0].eq ) { return 0x8209EABC;  }
		/* 8209EA90h case   10:*/		return 0x8209EA94;
		  /* 8209EA94h */ case   11:  		/* lwz R3, <#[R3 + 8]> */
		/* 8209EA94h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000008) );
		/* 8209EA94h case   11:*/		return 0x8209EA98;
		  /* 8209EA98h */ case   12:  		/* bl -45680 */
		/* 8209EA98h case   12:*/		regs.LR = 0x8209EA9C; return 0x82093828;
		/* 8209EA98h case   12:*/		return 0x8209EA9C;
		  /* 8209EA9Ch */ case   13:  		/* li R11, 0 */
		/* 8209EA9Ch case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209EA9Ch case   13:*/		return 0x8209EAA0;
		  /* 8209EAA0h */ case   14:  		/* stw R11, <#[R31]> */
		/* 8209EAA0h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209EAA0h case   14:*/		return 0x8209EAA4;
		  /* 8209EAA4h */ case   15:  		/* stw R11, <#[R31 + 8]> */
		/* 8209EAA4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8209EAA4h case   15:*/		return 0x8209EAA8;
		  /* 8209EAA8h */ case   16:  		/* stw R11, <#[R31 + 4]> */
		/* 8209EAA8h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8209EAA8h case   16:*/		return 0x8209EAAC;
		  /* 8209EAACh */ case   17:  		/* lwz R11, <#[R31 + 12]> */
		/* 8209EAACh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209EAACh case   17:*/		return 0x8209EAB0;
		  /* 8209EAB0h */ case   18:  		/* rlwinm R11, R11, 0, 29, 27 */
		/* 8209EAB0h case   18:*/		cpu::op::rlwinm<0,0,29,27>(regs,&regs.R11,regs.R11);
		/* 8209EAB0h case   18:*/		return 0x8209EAB4;
		  /* 8209EAB4h */ case   19:  		/* rlwinm R11, R11, 0, 22, 20 */
		/* 8209EAB4h case   19:*/		cpu::op::rlwinm<0,0,22,20>(regs,&regs.R11,regs.R11);
		/* 8209EAB4h case   19:*/		return 0x8209EAB8;
		  /* 8209EAB8h */ case   20:  		/* stw R11, <#[R31 + 12]> */
		/* 8209EAB8h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8209EAB8h case   20:*/		return 0x8209EABC;
	}
	return 0x8209EABC;
} // Block from 8209EA68h-8209EABCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 8209EABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EABC);
		  /* 8209EABCh */ case    0:  		/* addi R1, R1, 96 */
		/* 8209EABCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209EABCh case    0:*/		return 0x8209EAC0;
		  /* 8209EAC0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209EAC0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209EAC0h case    1:*/		return 0x8209EAC4;
		  /* 8209EAC4h */ case    2:  		/* mtspr LR, R12 */
		/* 8209EAC4h case    2:*/		regs.LR = regs.R12;
		/* 8209EAC4h case    2:*/		return 0x8209EAC8;
		  /* 8209EAC8h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8209EAC8h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209EAC8h case    3:*/		return 0x8209EACC;
		  /* 8209EACCh */ case    4:  		/* bclr 20, CR0_LT */
		/* 8209EACCh case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209EACCh case    4:*/		return 0x8209EAD0;
	}
	return 0x8209EAD0;
} // Block from 8209EABCh-8209EAD0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209EAD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EAD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EAD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EAD0);
		  /* 8209EAD0h */ case    0:  		/* mfspr R12, LR */
		/* 8209EAD0h case    0:*/		regs.R12 = regs.LR;
		/* 8209EAD0h case    0:*/		return 0x8209EAD4;
		  /* 8209EAD4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209EAD4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209EAD4h case    1:*/		return 0x8209EAD8;
		  /* 8209EAD8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8209EAD8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209EAD8h case    2:*/		return 0x8209EADC;
		  /* 8209EADCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209EADCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209EADCh case    3:*/		return 0x8209EAE0;
		  /* 8209EAE0h */ case    4:  		/* lis R10, -32255 */
		/* 8209EAE0h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8209EAE0h case    4:*/		return 0x8209EAE4;
		  /* 8209EAE4h */ case    5:  		/* li R11, 0 */
		/* 8209EAE4h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209EAE4h case    5:*/		return 0x8209EAE8;
		  /* 8209EAE8h */ case    6:  		/* addi R10, R10, -24480 */
		/* 8209EAE8h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFA060);
		/* 8209EAE8h case    6:*/		return 0x8209EAEC;
		  /* 8209EAECh */ case    7:  		/* stw R11, <#[R3 + 4]> */
		/* 8209EAECh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8209EAECh case    7:*/		return 0x8209EAF0;
		  /* 8209EAF0h */ case    8:  		/* mr R31, R3 */
		/* 8209EAF0h case    8:*/		regs.R31 = regs.R3;
		/* 8209EAF0h case    8:*/		return 0x8209EAF4;
		  /* 8209EAF4h */ case    9:  		/* stw R10, <#[R3]> */
		/* 8209EAF4h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8209EAF4h case    9:*/		return 0x8209EAF8;
		  /* 8209EAF8h */ case   10:  		/* stb R11, <#[R3 + 8]> */
		/* 8209EAF8h case   10:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8209EAF8h case   10:*/		return 0x8209EAFC;
		  /* 8209EAFCh */ case   11:  		/* bl -46684 */
		/* 8209EAFCh case   11:*/		regs.LR = 0x8209EB00; return 0x820934A0;
		/* 8209EAFCh case   11:*/		return 0x8209EB00;
		  /* 8209EB00h */ case   12:  		/* lis R11, -32255 */
		/* 8209EB00h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209EB00h case   12:*/		return 0x8209EB04;
		  /* 8209EB04h */ case   13:  		/* mr R3, R31 */
		/* 8209EB04h case   13:*/		regs.R3 = regs.R31;
		/* 8209EB04h case   13:*/		return 0x8209EB08;
		  /* 8209EB08h */ case   14:  		/* addi R11, R11, -24480 */
		/* 8209EB08h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFA060);
		/* 8209EB08h case   14:*/		return 0x8209EB0C;
		  /* 8209EB0Ch */ case   15:  		/* stw R11, <#[R31]> */
		/* 8209EB0Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209EB0Ch case   15:*/		return 0x8209EB10;
		  /* 8209EB10h */ case   16:  		/* addi R1, R1, 96 */
		/* 8209EB10h case   16:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209EB10h case   16:*/		return 0x8209EB14;
		  /* 8209EB14h */ case   17:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209EB14h case   17:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209EB14h case   17:*/		return 0x8209EB18;
		  /* 8209EB18h */ case   18:  		/* mtspr LR, R12 */
		/* 8209EB18h case   18:*/		regs.LR = regs.R12;
		/* 8209EB18h case   18:*/		return 0x8209EB1C;
		  /* 8209EB1Ch */ case   19:  		/* ld R31, <#[R1 - 16]> */
		/* 8209EB1Ch case   19:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209EB1Ch case   19:*/		return 0x8209EB20;
		  /* 8209EB20h */ case   20:  		/* bclr 20, CR0_LT */
		/* 8209EB20h case   20:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209EB20h case   20:*/		return 0x8209EB24;
	}
	return 0x8209EB24;
} // Block from 8209EAD0h-8209EB24h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8209EB24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EB24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EB24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EB24);
		  /* 8209EB24h */ case    0:  		/* nop */
		/* 8209EB24h case    0:*/		cpu::op::nop();
		/* 8209EB24h case    0:*/		return 0x8209EB28;
	}
	return 0x8209EB28;
} // Block from 8209EB24h-8209EB28h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209EB28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EB28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EB28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EB28);
		  /* 8209EB28h */ case    0:  		/* b -46480 */
		/* 8209EB28h case    0:*/		return 0x82093598;
		/* 8209EB28h case    0:*/		return 0x8209EB2C;
		  /* 8209EB2Ch */ case    1:  		/* nop */
		/* 8209EB2Ch case    1:*/		cpu::op::nop();
		/* 8209EB2Ch case    1:*/		return 0x8209EB30;
	}
	return 0x8209EB30;
} // Block from 8209EB28h-8209EB30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209EB30h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EB30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EB30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EB30);
		  /* 8209EB30h */ case    0:  		/* mfspr R12, LR */
		/* 8209EB30h case    0:*/		regs.R12 = regs.LR;
		/* 8209EB30h case    0:*/		return 0x8209EB34;
		  /* 8209EB34h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209EB34h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209EB34h case    1:*/		return 0x8209EB38;
		  /* 8209EB38h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209EB38h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209EB38h case    2:*/		return 0x8209EB3C;
		  /* 8209EB3Ch */ case    3:  		/* mr R4, R3 */
		/* 8209EB3Ch case    3:*/		regs.R4 = regs.R3;
		/* 8209EB3Ch case    3:*/		return 0x8209EB40;
		  /* 8209EB40h */ case    4:  		/* addi R3, R1, 80 */
		/* 8209EB40h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8209EB40h case    4:*/		return 0x8209EB44;
		  /* 8209EB44h */ case    5:  		/* bl -116 */
		/* 8209EB44h case    5:*/		regs.LR = 0x8209EB48; return 0x8209EAD0;
		/* 8209EB44h case    5:*/		return 0x8209EB48;
		  /* 8209EB48h */ case    6:  		/* lis R11, -32255 */
		/* 8209EB48h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209EB48h case    6:*/		return 0x8209EB4C;
		  /* 8209EB4Ch */ case    7:  		/* lis R10, -32251 */
		/* 8209EB4Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8209EB4Ch case    7:*/		return 0x8209EB50;
		  /* 8209EB50h */ case    8:  		/* addi R11, R11, -24480 */
		/* 8209EB50h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFA060);
		/* 8209EB50h case    8:*/		return 0x8209EB54;
		  /* 8209EB54h */ case    9:  		/* addi R4, R10, -14756 */
		/* 8209EB54h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0xFFFFC65C);
		/* 8209EB54h case    9:*/		return 0x8209EB58;
		  /* 8209EB58h */ case   10:  		/* stw R11, <#[R1 + 80]> */
		/* 8209EB58h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8209EB58h case   10:*/		return 0x8209EB5C;
		  /* 8209EB5Ch */ case   11:  		/* addi R3, R1, 80 */
		/* 8209EB5Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8209EB5Ch case   11:*/		return 0x8209EB60;
		  /* 8209EB60h */ case   12:  		/* bl -22184 */
		/* 8209EB60h case   12:*/		regs.LR = 0x8209EB64; return 0x820994B8;
		/* 8209EB60h case   12:*/		return 0x8209EB64;
		  /* 8209EB64h */ case   13:  		/* nop */
		/* 8209EB64h case   13:*/		cpu::op::nop();
		/* 8209EB64h case   13:*/		return 0x8209EB68;
	}
	return 0x8209EB68;
} // Block from 8209EB30h-8209EB68h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209EB68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EB68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EB68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EB68);
		  /* 8209EB68h */ case    0:  		/* mfspr R12, LR */
		/* 8209EB68h case    0:*/		regs.R12 = regs.LR;
		/* 8209EB68h case    0:*/		return 0x8209EB6C;
		  /* 8209EB6Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209EB6Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209EB6Ch case    1:*/		return 0x8209EB70;
		  /* 8209EB70h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8209EB70h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209EB70h case    2:*/		return 0x8209EB74;
		  /* 8209EB74h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209EB74h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209EB74h case    3:*/		return 0x8209EB78;
		  /* 8209EB78h */ case    4:  		/* lis R10, -32255 */
		/* 8209EB78h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8209EB78h case    4:*/		return 0x8209EB7C;
		  /* 8209EB7Ch */ case    5:  		/* li R11, 0 */
		/* 8209EB7Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209EB7Ch case    5:*/		return 0x8209EB80;
		  /* 8209EB80h */ case    6:  		/* addi R10, R10, -24480 */
		/* 8209EB80h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFA060);
		/* 8209EB80h case    6:*/		return 0x8209EB84;
		  /* 8209EB84h */ case    7:  		/* stw R11, <#[R3 + 4]> */
		/* 8209EB84h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8209EB84h case    7:*/		return 0x8209EB88;
		  /* 8209EB88h */ case    8:  		/* mr R31, R3 */
		/* 8209EB88h case    8:*/		regs.R31 = regs.R3;
		/* 8209EB88h case    8:*/		return 0x8209EB8C;
		  /* 8209EB8Ch */ case    9:  		/* stw R10, <#[R3]> */
		/* 8209EB8Ch case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8209EB8Ch case    9:*/		return 0x8209EB90;
		  /* 8209EB90h */ case   10:  		/* stb R11, <#[R3 + 8]> */
		/* 8209EB90h case   10:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8209EB90h case   10:*/		return 0x8209EB94;
		  /* 8209EB94h */ case   11:  		/* bl -46724 */
		/* 8209EB94h case   11:*/		regs.LR = 0x8209EB98; return 0x82093510;
		/* 8209EB94h case   11:*/		return 0x8209EB98;
		  /* 8209EB98h */ case   12:  		/* lis R11, -32255 */
		/* 8209EB98h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209EB98h case   12:*/		return 0x8209EB9C;
		  /* 8209EB9Ch */ case   13:  		/* mr R3, R31 */
		/* 8209EB9Ch case   13:*/		regs.R3 = regs.R31;
		/* 8209EB9Ch case   13:*/		return 0x8209EBA0;
		  /* 8209EBA0h */ case   14:  		/* addi R11, R11, -24480 */
		/* 8209EBA0h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFA060);
		/* 8209EBA0h case   14:*/		return 0x8209EBA4;
		  /* 8209EBA4h */ case   15:  		/* stw R11, <#[R31]> */
		/* 8209EBA4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209EBA4h case   15:*/		return 0x8209EBA8;
		  /* 8209EBA8h */ case   16:  		/* addi R1, R1, 96 */
		/* 8209EBA8h case   16:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209EBA8h case   16:*/		return 0x8209EBAC;
		  /* 8209EBACh */ case   17:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209EBACh case   17:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209EBACh case   17:*/		return 0x8209EBB0;
		  /* 8209EBB0h */ case   18:  		/* mtspr LR, R12 */
		/* 8209EBB0h case   18:*/		regs.LR = regs.R12;
		/* 8209EBB0h case   18:*/		return 0x8209EBB4;
		  /* 8209EBB4h */ case   19:  		/* ld R31, <#[R1 - 16]> */
		/* 8209EBB4h case   19:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209EBB4h case   19:*/		return 0x8209EBB8;
		  /* 8209EBB8h */ case   20:  		/* bclr 20, CR0_LT */
		/* 8209EBB8h case   20:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209EBB8h case   20:*/		return 0x8209EBBC;
	}
	return 0x8209EBBC;
} // Block from 8209EB68h-8209EBBCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 8209EBBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EBBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EBBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EBBC);
		  /* 8209EBBCh */ case    0:  		/* nop */
		/* 8209EBBCh case    0:*/		cpu::op::nop();
		/* 8209EBBCh case    0:*/		return 0x8209EBC0;
	}
	return 0x8209EBC0;
} // Block from 8209EBBCh-8209EBC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209EBC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EBC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EBC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EBC0);
		  /* 8209EBC0h */ case    0:  		/* mfspr R12, LR */
		/* 8209EBC0h case    0:*/		regs.R12 = regs.LR;
		/* 8209EBC0h case    0:*/		return 0x8209EBC4;
		  /* 8209EBC4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209EBC4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209EBC4h case    1:*/		return 0x8209EBC8;
		  /* 8209EBC8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8209EBC8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209EBC8h case    2:*/		return 0x8209EBCC;
		  /* 8209EBCCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209EBCCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209EBCCh case    3:*/		return 0x8209EBD0;
		  /* 8209EBD0h */ case    4:  		/* mr R31, R3 */
		/* 8209EBD0h case    4:*/		regs.R31 = regs.R3;
		/* 8209EBD0h case    4:*/		return 0x8209EBD4;
		  /* 8209EBD4h */ case    5:  		/* bl -108 */
		/* 8209EBD4h case    5:*/		regs.LR = 0x8209EBD8; return 0x8209EB68;
		/* 8209EBD4h case    5:*/		return 0x8209EBD8;
		  /* 8209EBD8h */ case    6:  		/* lis R11, -32255 */
		/* 8209EBD8h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209EBD8h case    6:*/		return 0x8209EBDC;
		  /* 8209EBDCh */ case    7:  		/* mr R3, R31 */
		/* 8209EBDCh case    7:*/		regs.R3 = regs.R31;
		/* 8209EBDCh case    7:*/		return 0x8209EBE0;
		  /* 8209EBE0h */ case    8:  		/* addi R11, R11, -24480 */
		/* 8209EBE0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFA060);
		/* 8209EBE0h case    8:*/		return 0x8209EBE4;
		  /* 8209EBE4h */ case    9:  		/* stw R11, <#[R31]> */
		/* 8209EBE4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209EBE4h case    9:*/		return 0x8209EBE8;
		  /* 8209EBE8h */ case   10:  		/* addi R1, R1, 96 */
		/* 8209EBE8h case   10:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209EBE8h case   10:*/		return 0x8209EBEC;
		  /* 8209EBECh */ case   11:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209EBECh case   11:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209EBECh case   11:*/		return 0x8209EBF0;
		  /* 8209EBF0h */ case   12:  		/* mtspr LR, R12 */
		/* 8209EBF0h case   12:*/		regs.LR = regs.R12;
		/* 8209EBF0h case   12:*/		return 0x8209EBF4;
		  /* 8209EBF4h */ case   13:  		/* ld R31, <#[R1 - 16]> */
		/* 8209EBF4h case   13:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209EBF4h case   13:*/		return 0x8209EBF8;
		  /* 8209EBF8h */ case   14:  		/* bclr 20, CR0_LT */
		/* 8209EBF8h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209EBF8h case   14:*/		return 0x8209EBFC;
	}
	return 0x8209EBFC;
} // Block from 8209EBC0h-8209EBFCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 8209EBFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EBFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EBFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EBFC);
		  /* 8209EBFCh */ case    0:  		/* nop */
		/* 8209EBFCh case    0:*/		cpu::op::nop();
		/* 8209EBFCh case    0:*/		return 0x8209EC00;
	}
	return 0x8209EC00;
} // Block from 8209EBFCh-8209EC00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209EC00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EC00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EC00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EC00);
		  /* 8209EC00h */ case    0:  		/* mfspr R12, LR */
		/* 8209EC00h case    0:*/		regs.R12 = regs.LR;
		/* 8209EC00h case    0:*/		return 0x8209EC04;
		  /* 8209EC04h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209EC04h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209EC04h case    1:*/		return 0x8209EC08;
		  /* 8209EC08h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8209EC08h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209EC08h case    2:*/		return 0x8209EC0C;
		  /* 8209EC0Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209EC0Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209EC0Ch case    3:*/		return 0x8209EC10;
		  /* 8209EC10h */ case    4:  		/* lbz R11, <#[R3]> */
		/* 8209EC10h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209EC10h case    4:*/		return 0x8209EC14;
		  /* 8209EC14h */ case    5:  		/* cmplwi CR6, R11, 118 */
		/* 8209EC14h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000076);
		/* 8209EC14h case    5:*/		return 0x8209EC18;
		  /* 8209EC18h */ case    6:  		/* bc 4, CR6_EQ, 120 */
		/* 8209EC18h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8209EC90;  }
		/* 8209EC18h case    6:*/		return 0x8209EC1C;
		  /* 8209EC1Ch */ case    7:  		/* mr R11, R3 */
		/* 8209EC1Ch case    7:*/		regs.R11 = regs.R3;
		/* 8209EC1Ch case    7:*/		return 0x8209EC20;
		  /* 8209EC20h */ case    8:  		/* lbz R10, <#[R11]> */
		/* 8209EC20h case    8:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209EC20h case    8:*/		return 0x8209EC24;
		  /* 8209EC24h */ case    9:  		/* addi R11, R11, 1 */
		/* 8209EC24h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209EC24h case    9:*/		return 0x8209EC28;
		  /* 8209EC28h */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 8209EC28h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8209EC28h case   10:*/		return 0x8209EC2C;
		  /* 8209EC2Ch */ case   11:  		/* bc 4, CR6_EQ, -12 */
		/* 8209EC2Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x8209EC20;  }
		/* 8209EC2Ch case   11:*/		return 0x8209EC30;
		  /* 8209EC30h */ case   12:  		/* subf R11, R3, R11 */
		/* 8209EC30h case   12:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 8209EC30h case   12:*/		return 0x8209EC34;
		  /* 8209EC34h */ case   13:  		/* addi R11, R11, -1 */
		/* 8209EC34h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8209EC34h case   13:*/		return 0x8209EC38;
		  /* 8209EC38h */ case   14:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 8209EC38h case   14:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 8209EC38h case   14:*/		return 0x8209EC3C;
		  /* 8209EC3Ch */ case   15:  		/* add R11, R11, R3 */
		/* 8209EC3Ch case   15:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8209EC3Ch case   15:*/		return 0x8209EC40;
		  /* 8209EC40h */ case   16:  		/* subf R10, R3, R11 */
		/* 8209EC40h case   16:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R3,regs.R11);
		/* 8209EC40h case   16:*/		return 0x8209EC44;
		  /* 8209EC44h */ case   17:  		/* cmpwi CR6, R10, 3 */
		/* 8209EC44h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000003);
		/* 8209EC44h case   17:*/		return 0x8209EC48;
		  /* 8209EC48h */ case   18:  		/* bc 4, CR6_GT, 72 */
		/* 8209EC48h case   18:*/		if ( !regs.CR[6].gt ) { return 0x8209EC90;  }
		/* 8209EC48h case   18:*/		return 0x8209EC4C;
		  /* 8209EC4Ch */ case   19:  		/* addi R31, R11, -3 */
		/* 8209EC4Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFFFFFD);
		/* 8209EC4Ch case   19:*/		return 0x8209EC50;
		  /* 8209EC50h */ case   20:  		/* lis R11, -32255 */
		/* 8209EC50h case   20:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209EC50h case   20:*/		return 0x8209EC54;
		  /* 8209EC54h */ case   21:  		/* li R5, 3 */
		/* 8209EC54h case   21:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 8209EC54h case   21:*/		return 0x8209EC58;
		  /* 8209EC58h */ case   22:  		/* addi R4, R11, -14744 */
		/* 8209EC58h case   22:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC668);
		/* 8209EC58h case   22:*/		return 0x8209EC5C;
		  /* 8209EC5Ch */ case   23:  		/* mr R3, R31 */
		/* 8209EC5Ch case   23:*/		regs.R3 = regs.R31;
		/* 8209EC5Ch case   23:*/		return 0x8209EC60;
		  /* 8209EC60h */ case   24:  		/* bl -51440 */
		/* 8209EC60h case   24:*/		regs.LR = 0x8209EC64; return 0x82092370;
		/* 8209EC60h case   24:*/		return 0x8209EC64;
		  /* 8209EC64h */ case   25:  		/* cmpwi CR0, R3, 0 */
		/* 8209EC64h case   25:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209EC64h case   25:*/		return 0x8209EC68;
		  /* 8209EC68h */ case   26:  		/* bc 12, CR0_EQ, 32 */
		/* 8209EC68h case   26:*/		if ( regs.CR[0].eq ) { return 0x8209EC88;  }
		/* 8209EC68h case   26:*/		return 0x8209EC6C;
		  /* 8209EC6Ch */ case   27:  		/* lis R11, -32255 */
		/* 8209EC6Ch case   27:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209EC6Ch case   27:*/		return 0x8209EC70;
		  /* 8209EC70h */ case   28:  		/* li R5, 3 */
		/* 8209EC70h case   28:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 8209EC70h case   28:*/		return 0x8209EC74;
		  /* 8209EC74h */ case   29:  		/* addi R4, R11, -14748 */
		/* 8209EC74h case   29:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC664);
		/* 8209EC74h case   29:*/		return 0x8209EC78;
		  /* 8209EC78h */ case   30:  		/* mr R3, R31 */
		/* 8209EC78h case   30:*/		regs.R3 = regs.R31;
		/* 8209EC78h case   30:*/		return 0x8209EC7C;
		  /* 8209EC7Ch */ case   31:  		/* bl -51468 */
		/* 8209EC7Ch case   31:*/		regs.LR = 0x8209EC80; return 0x82092370;
		/* 8209EC7Ch case   31:*/		return 0x8209EC80;
		  /* 8209EC80h */ case   32:  		/* cmpwi CR0, R3, 0 */
		/* 8209EC80h case   32:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209EC80h case   32:*/		return 0x8209EC84;
		  /* 8209EC84h */ case   33:  		/* bc 4, CR0_EQ, 12 */
		/* 8209EC84h case   33:*/		if ( !regs.CR[0].eq ) { return 0x8209EC90;  }
		/* 8209EC84h case   33:*/		return 0x8209EC88;
	}
	return 0x8209EC88;
} // Block from 8209EC00h-8209EC88h (34 instructions)

//////////////////////////////////////////////////////
// Block at 8209EC88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EC88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EC88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EC88);
		  /* 8209EC88h */ case    0:  		/* li R3, 1 */
		/* 8209EC88h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8209EC88h case    0:*/		return 0x8209EC8C;
		  /* 8209EC8Ch */ case    1:  		/* b 8 */
		/* 8209EC8Ch case    1:*/		return 0x8209EC94;
		/* 8209EC8Ch case    1:*/		return 0x8209EC90;
	}
	return 0x8209EC90;
} // Block from 8209EC88h-8209EC90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209EC90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EC90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EC90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EC90);
		  /* 8209EC90h */ case    0:  		/* li R3, 0 */
		/* 8209EC90h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209EC90h case    0:*/		return 0x8209EC94;
	}
	return 0x8209EC94;
} // Block from 8209EC90h-8209EC94h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209EC94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EC94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EC94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EC94);
		  /* 8209EC94h */ case    0:  		/* addi R1, R1, 96 */
		/* 8209EC94h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209EC94h case    0:*/		return 0x8209EC98;
		  /* 8209EC98h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209EC98h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209EC98h case    1:*/		return 0x8209EC9C;
		  /* 8209EC9Ch */ case    2:  		/* mtspr LR, R12 */
		/* 8209EC9Ch case    2:*/		regs.LR = regs.R12;
		/* 8209EC9Ch case    2:*/		return 0x8209ECA0;
	}
	return 0x8209ECA0;
} // Block from 8209EC94h-8209ECA0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209ECA0h
// Function '__jump_unwind'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209ECA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209ECA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209ECA0);
		  /* 8209ECA0h */ case    0:  		/* ld R31, <#[R1 - 16]> */
		/* 8209ECA0h case    0:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209ECA0h case    0:*/		return 0x8209ECA4;
		  /* 8209ECA4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8209ECA4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209ECA4h case    1:*/		return 0x8209ECA8;
	}
	return 0x8209ECA8;
} // Block from 8209ECA0h-8209ECA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209ECA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209ECA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209ECA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209ECA8);
		  /* 8209ECA8h */ case    0:  		/* mfspr R12, LR */
		/* 8209ECA8h case    0:*/		regs.R12 = regs.LR;
		/* 8209ECA8h case    0:*/		return 0x8209ECAC;
		  /* 8209ECACh */ case    1:  		/* bl -55888 */
		/* 8209ECACh case    1:*/		regs.LR = 0x8209ECB0; return 0x8209125C;
		/* 8209ECACh case    1:*/		return 0x8209ECB0;
		  /* 8209ECB0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209ECB0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209ECB0h case    2:*/		return 0x8209ECB4;
		  /* 8209ECB4h */ case    3:  		/* lbz R11, <#[R3]> */
		/* 8209ECB4h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209ECB4h case    3:*/		return 0x8209ECB8;
		  /* 8209ECB8h */ case    4:  		/* mr R31, R3 */
		/* 8209ECB8h case    4:*/		regs.R31 = regs.R3;
		/* 8209ECB8h case    4:*/		return 0x8209ECBC;
		  /* 8209ECBCh */ case    5:  		/* mr R29, R4 */
		/* 8209ECBCh case    5:*/		regs.R29 = regs.R4;
		/* 8209ECBCh case    5:*/		return 0x8209ECC0;
		  /* 8209ECC0h */ case    6:  		/* cmplwi CR6, R11, 118 */
		/* 8209ECC0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000076);
		/* 8209ECC0h case    6:*/		return 0x8209ECC4;
		  /* 8209ECC4h */ case    7:  		/* bc 4, CR6_EQ, 136 */
		/* 8209ECC4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8209ED4C;  }
		/* 8209ECC4h case    7:*/		return 0x8209ECC8;
	}
	return 0x8209ECC8;
} // Block from 8209ECA8h-8209ECC8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209ECC8h
// Function '_fclose_nolock'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209ECC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209ECC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209ECC8);
		  /* 8209ECC8h */ case    0:  		/* mr R11, R3 */
		/* 8209ECC8h case    0:*/		regs.R11 = regs.R3;
		/* 8209ECC8h case    0:*/		return 0x8209ECCC;
		  /* 8209ECCCh */ case    1:  		/* lbz R10, <#[R11]> */
		/* 8209ECCCh case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209ECCCh case    1:*/		return 0x8209ECD0;
		  /* 8209ECD0h */ case    2:  		/* addi R11, R11, 1 */
		/* 8209ECD0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209ECD0h case    2:*/		return 0x8209ECD4;
		  /* 8209ECD4h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 8209ECD4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8209ECD4h case    3:*/		return 0x8209ECD8;
		  /* 8209ECD8h */ case    4:  		/* bc 4, CR6_EQ, -12 */
		/* 8209ECD8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8209ECCC;  }
		/* 8209ECD8h case    4:*/		return 0x8209ECDC;
		  /* 8209ECDCh */ case    5:  		/* subf R11, R31, R11 */
		/* 8209ECDCh case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 8209ECDCh case    5:*/		return 0x8209ECE0;
		  /* 8209ECE0h */ case    6:  		/* addi R11, R11, -1 */
		/* 8209ECE0h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8209ECE0h case    6:*/		return 0x8209ECE4;
		  /* 8209ECE4h */ case    7:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 8209ECE4h case    7:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 8209ECE4h case    7:*/		return 0x8209ECE8;
		  /* 8209ECE8h */ case    8:  		/* add R11, R11, R31 */
		/* 8209ECE8h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 8209ECE8h case    8:*/		return 0x8209ECEC;
		  /* 8209ECECh */ case    9:  		/* subf R10, R31, R11 */
		/* 8209ECECh case    9:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R31,regs.R11);
		/* 8209ECECh case    9:*/		return 0x8209ECF0;
		  /* 8209ECF0h */ case   10:  		/* cmpwi CR6, R10, 3 */
		/* 8209ECF0h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000003);
		/* 8209ECF0h case   10:*/		return 0x8209ECF4;
		  /* 8209ECF4h */ case   11:  		/* bc 4, CR6_GT, 88 */
		/* 8209ECF4h case   11:*/		if ( !regs.CR[6].gt ) { return 0x8209ED4C;  }
		/* 8209ECF4h case   11:*/		return 0x8209ECF8;
		  /* 8209ECF8h */ case   12:  		/* addi R30, R11, -3 */
		/* 8209ECF8h case   12:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFFFFD);
		/* 8209ECF8h case   12:*/		return 0x8209ECFC;
		  /* 8209ECFCh */ case   13:  		/* lis R11, -32255 */
		/* 8209ECFCh case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209ECFCh case   13:*/		return 0x8209ED00;
		  /* 8209ED00h */ case   14:  		/* li R5, 3 */
		/* 8209ED00h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 8209ED00h case   14:*/		return 0x8209ED04;
		  /* 8209ED04h */ case   15:  		/* addi R4, R11, -14744 */
		/* 8209ED04h case   15:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC668);
		/* 8209ED04h case   15:*/		return 0x8209ED08;
		  /* 8209ED08h */ case   16:  		/* mr R3, R30 */
		/* 8209ED08h case   16:*/		regs.R3 = regs.R30;
		/* 8209ED08h case   16:*/		return 0x8209ED0C;
		  /* 8209ED0Ch */ case   17:  		/* bl -51612 */
		/* 8209ED0Ch case   17:*/		regs.LR = 0x8209ED10; return 0x82092370;
		/* 8209ED0Ch case   17:*/		return 0x8209ED10;
		  /* 8209ED10h */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 8209ED10h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209ED10h case   18:*/		return 0x8209ED14;
		  /* 8209ED14h */ case   19:  		/* bc 4, CR0_EQ, 16 */
		/* 8209ED14h case   19:*/		if ( !regs.CR[0].eq ) { return 0x8209ED24;  }
		/* 8209ED14h case   19:*/		return 0x8209ED18;
		  /* 8209ED18h */ case   20:  		/* lis R11, -32255 */
		/* 8209ED18h case   20:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209ED18h case   20:*/		return 0x8209ED1C;
		  /* 8209ED1Ch */ case   21:  		/* addi R3, R11, -15748 */
		/* 8209ED1Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFC27C);
		/* 8209ED1Ch case   21:*/		return 0x8209ED20;
		  /* 8209ED20h */ case   22:  		/* b 100 */
		/* 8209ED20h case   22:*/		return 0x8209ED84;
		/* 8209ED20h case   22:*/		return 0x8209ED24;
	}
	return 0x8209ED24;
} // Block from 8209ECC8h-8209ED24h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8209ED24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209ED24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209ED24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209ED24);
		  /* 8209ED24h */ case    0:  		/* lis R11, -32255 */
		/* 8209ED24h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209ED24h case    0:*/		return 0x8209ED28;
		  /* 8209ED28h */ case    1:  		/* li R5, 3 */
		/* 8209ED28h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 8209ED28h case    1:*/		return 0x8209ED2C;
		  /* 8209ED2Ch */ case    2:  		/* addi R4, R11, -14748 */
		/* 8209ED2Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC664);
		/* 8209ED2Ch case    2:*/		return 0x8209ED30;
		  /* 8209ED30h */ case    3:  		/* mr R3, R30 */
		/* 8209ED30h case    3:*/		regs.R3 = regs.R30;
		/* 8209ED30h case    3:*/		return 0x8209ED34;
		  /* 8209ED34h */ case    4:  		/* bl -51652 */
		/* 8209ED34h case    4:*/		regs.LR = 0x8209ED38; return 0x82092370;
		/* 8209ED34h case    4:*/		return 0x8209ED38;
		  /* 8209ED38h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 8209ED38h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209ED38h case    5:*/		return 0x8209ED3C;
		  /* 8209ED3Ch */ case    6:  		/* bc 4, CR0_EQ, 16 */
		/* 8209ED3Ch case    6:*/		if ( !regs.CR[0].eq ) { return 0x8209ED4C;  }
		/* 8209ED3Ch case    6:*/		return 0x8209ED40;
		  /* 8209ED40h */ case    7:  		/* lis R11, -32255 */
		/* 8209ED40h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209ED40h case    7:*/		return 0x8209ED44;
		  /* 8209ED44h */ case    8:  		/* addi R3, R11, -15760 */
		/* 8209ED44h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFC270);
		/* 8209ED44h case    8:*/		return 0x8209ED48;
		  /* 8209ED48h */ case    9:  		/* b 60 */
		/* 8209ED48h case    9:*/		return 0x8209ED84;
		/* 8209ED48h case    9:*/		return 0x8209ED4C;
	}
	return 0x8209ED4C;
} // Block from 8209ED24h-8209ED4Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209ED4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209ED4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209ED4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209ED4C);
		  /* 8209ED4Ch */ case    0:  		/* rlwinm. R11, R29, 0, 11, 11 */
		/* 8209ED4Ch case    0:*/		cpu::op::rlwinm<1,0,11,11>(regs,&regs.R11,regs.R29);
		/* 8209ED4Ch case    0:*/		return 0x8209ED50;
		  /* 8209ED50h */ case    1:  		/* bc 4, CR0_EQ, 48 */
		/* 8209ED50h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8209ED80;  }
		/* 8209ED50h case    1:*/		return 0x8209ED54;
		  /* 8209ED54h */ case    2:  		/* lbz R11, <#[R31]> */
		/* 8209ED54h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209ED54h case    2:*/		return 0x8209ED58;
		  /* 8209ED58h */ case    3:  		/* extsb R11, R11 */
		/* 8209ED58h case    3:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 8209ED58h case    3:*/		return 0x8209ED5C;
		  /* 8209ED5Ch */ case    4:  		/* cmpwi CR6, R11, 118 */
		/* 8209ED5Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000076);
		/* 8209ED5Ch case    4:*/		return 0x8209ED60;
		  /* 8209ED60h */ case    5:  		/* bc 4, CR6_EQ, 16 */
		/* 8209ED60h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8209ED70;  }
		/* 8209ED60h case    5:*/		return 0x8209ED64;
		  /* 8209ED64h */ case    6:  		/* lis R11, -32255 */
		/* 8209ED64h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209ED64h case    6:*/		return 0x8209ED68;
		  /* 8209ED68h */ case    7:  		/* addi R31, R11, -15728 */
		/* 8209ED68h case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFFC290);
		/* 8209ED68h case    7:*/		return 0x8209ED6C;
		  /* 8209ED6Ch */ case    8:  		/* b 20 */
		/* 8209ED6Ch case    8:*/		return 0x8209ED80;
		/* 8209ED6Ch case    8:*/		return 0x8209ED70;
	}
	return 0x8209ED70;
} // Block from 8209ED4Ch-8209ED70h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209ED70h
// Function 'fclose'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209ED70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209ED70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209ED70);
		  /* 8209ED70h */ case    0:  		/* cmpwi CR6, R11, 112 */
		/* 8209ED70h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000070);
		/* 8209ED70h case    0:*/		return 0x8209ED74;
		  /* 8209ED74h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 8209ED74h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209ED80;  }
		/* 8209ED74h case    1:*/		return 0x8209ED78;
		  /* 8209ED78h */ case    2:  		/* lis R11, -32255 */
		/* 8209ED78h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209ED78h case    2:*/		return 0x8209ED7C;
		  /* 8209ED7Ch */ case    3:  		/* addi R31, R11, -15568 */
		/* 8209ED7Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFFC330);
		/* 8209ED7Ch case    3:*/		return 0x8209ED80;
	}
	return 0x8209ED80;
} // Block from 8209ED70h-8209ED80h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209ED80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209ED80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209ED80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209ED80);
		  /* 8209ED80h */ case    0:  		/* mr R3, R31 */
		/* 8209ED80h case    0:*/		regs.R3 = regs.R31;
		/* 8209ED80h case    0:*/		return 0x8209ED84;
	}
	return 0x8209ED84;
} // Block from 8209ED80h-8209ED84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209ED84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209ED84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209ED84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209ED84);
		  /* 8209ED84h */ case    0:  		/* addi R1, R1, 112 */
		/* 8209ED84h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8209ED84h case    0:*/		return 0x8209ED88;
		  /* 8209ED88h */ case    1:  		/* b -56028 */
		/* 8209ED88h case    1:*/		return 0x820912AC;
		/* 8209ED88h case    1:*/		return 0x8209ED8C;
		  /* 8209ED8Ch */ case    2:  		/* nop */
		/* 8209ED8Ch case    2:*/		cpu::op::nop();
		/* 8209ED8Ch case    2:*/		return 0x8209ED90;
	}
	return 0x8209ED90;
} // Block from 8209ED84h-8209ED90h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209ED90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209ED90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209ED90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209ED90);
		  /* 8209ED90h */ case    0:  		/* mfspr R12, LR */
		/* 8209ED90h case    0:*/		regs.R12 = regs.LR;
		/* 8209ED90h case    0:*/		return 0x8209ED94;
		  /* 8209ED94h */ case    1:  		/* bl -56124 */
		/* 8209ED94h case    1:*/		regs.LR = 0x8209ED98; return 0x82091258;
		/* 8209ED94h case    1:*/		return 0x8209ED98;
		  /* 8209ED98h */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 8209ED98h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209ED98h case    2:*/		return 0x8209ED9C;
		  /* 8209ED9Ch */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 8209ED9Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8209EDAC;  }
		/* 8209ED9Ch case    3:*/		return 0x8209EDA0;
		  /* 8209EDA0h */ case    4:  		/* lis R3, -30602 */
		/* 8209EDA0h case    4:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8876);
		/* 8209EDA0h case    4:*/		return 0x8209EDA4;
		  /* 8209EDA4h */ case    5:  		/* ori R3, R3, 2156 */
		/* 8209EDA4h case    5:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x86C);
		/* 8209EDA4h case    5:*/		return 0x8209EDA8;
		  /* 8209EDA8h */ case    6:  		/* b 124 */
		/* 8209EDA8h case    6:*/		return 0x8209EE24;
		/* 8209EDA8h case    6:*/		return 0x8209EDAC;
	}
	return 0x8209EDAC;
} // Block from 8209ED90h-8209EDACh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209EDACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EDAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EDAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EDAC);
		  /* 8209EDACh */ case    0:  		/* lis R11, -32255 */
		/* 8209EDACh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209EDACh case    0:*/		return 0x8209EDB0;
		  /* 8209EDB0h */ case    1:  		/* li R30, 0 */
		/* 8209EDB0h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8209EDB0h case    1:*/		return 0x8209EDB4;
		  /* 8209EDB4h */ case    2:  		/* li R31, 49 */
		/* 8209EDB4h case    2:*/		cpu::op::li<0>(regs,&regs.R31,0x31);
		/* 8209EDB4h case    2:*/		return 0x8209EDB8;
		  /* 8209EDB8h */ case    3:  		/* addi R29, R11, -15376 */
		/* 8209EDB8h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFFC3F0);
		/* 8209EDB8h case    3:*/		return 0x8209EDBC;
		  /* 8209EDBCh */ case    4:  		/* add R11, R31, R30 */
		/* 8209EDBCh case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R30);
		/* 8209EDBCh case    4:*/		return 0x8209EDC0;
		  /* 8209EDC0h */ case    5:  		/* mr R10, R3 */
		/* 8209EDC0h case    5:*/		regs.R10 = regs.R3;
		/* 8209EDC0h case    5:*/		return 0x8209EDC4;
		  /* 8209EDC4h */ case    6:  		/* rlwinm R9, R11, 31, 1, 31 */
		/* 8209EDC4h case    6:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R9,regs.R11);
		/* 8209EDC4h case    6:*/		return 0x8209EDC8;
		  /* 8209EDC8h */ case    7:  		/* mulli R8, R9, 12 */
		/* 8209EDC8h case    7:*/		cpu::op::mulli<0>(regs,&regs.R8,regs.R9,0xC);
		/* 8209EDC8h case    7:*/		return 0x8209EDCC;
		  /* 8209EDCCh */ case    8:  		/* lwzx R11, <#[R8 + R29]> */
		/* 8209EDCCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R29 + 0x00000000) );
		/* 8209EDCCh case    8:*/		return 0x8209EDD0;
		  /* 8209EDD0h */ case    9:  		/* add R7, R8, R29 */
		/* 8209EDD0h case    9:*/		cpu::op::add<0>(regs,&regs.R7,regs.R8,regs.R29);
		/* 8209EDD0h case    9:*/		return 0x8209EDD4;
		  /* 8209EDD4h */ case   10:  		/* lbz R6, <#[R11]> */
		/* 8209EDD4h case   10:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8209EDD4h case   10:*/		return 0x8209EDD8;
		  /* 8209EDD8h */ case   11:  		/* lbz R28, <#[R10]> */
		/* 8209EDD8h case   11:*/		cpu::mem::load8z( regs, &regs.R28, (uint32)(regs.R10 + 0x00000000) );
		/* 8209EDD8h case   11:*/		return 0x8209EDDC;
		  /* 8209EDDCh */ case   12:  		/* cmpwi CR0, R6, 0 */
		/* 8209EDDCh case   12:*/		cpu::op::cmpwi<0>(regs,regs.R6,0x00000000);
		/* 8209EDDCh case   12:*/		return 0x8209EDE0;
		  /* 8209EDE0h */ case   13:  		/* subf R6, R28, R6 */
		/* 8209EDE0h case   13:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R28,regs.R6);
		/* 8209EDE0h case   13:*/		return 0x8209EDE4;
		  /* 8209EDE4h */ case   14:  		/* bc 12, CR0_EQ, 20 */
		/* 8209EDE4h case   14:*/		if ( regs.CR[0].eq ) { return 0x8209EDF8;  }
		/* 8209EDE4h case   14:*/		return 0x8209EDE8;
		  /* 8209EDE8h */ case   15:  		/* addi R11, R11, 1 */
		/* 8209EDE8h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209EDE8h case   15:*/		return 0x8209EDEC;
		  /* 8209EDECh */ case   16:  		/* addi R10, R10, 1 */
		/* 8209EDECh case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8209EDECh case   16:*/		return 0x8209EDF0;
		  /* 8209EDF0h */ case   17:  		/* cmpwi CR6, R6, 0 */
		/* 8209EDF0h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 8209EDF0h case   17:*/		return 0x8209EDF4;
		  /* 8209EDF4h */ case   18:  		/* bc 12, CR6_EQ, -32 */
		/* 8209EDF4h case   18:*/		if ( regs.CR[6].eq ) { return 0x8209EDD4;  }
		/* 8209EDF4h case   18:*/		return 0x8209EDF8;
	}
	return 0x8209EDF8;
} // Block from 8209EDACh-8209EDF8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8209EDF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EDF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EDF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EDF8);
		  /* 8209EDF8h */ case    0:  		/* cmpwi CR0, R6, 0 */
		/* 8209EDF8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R6,0x00000000);
		/* 8209EDF8h case    0:*/		return 0x8209EDFC;
		  /* 8209EDFCh */ case    1:  		/* bc 12, CR0_EQ, 44 */
		/* 8209EDFCh case    1:*/		if ( regs.CR[0].eq ) { return 0x8209EE28;  }
		/* 8209EDFCh case    1:*/		return 0x8209EE00;
		  /* 8209EE00h */ case    2:  		/* cmpwi CR6, R6, 0 */
		/* 8209EE00h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 8209EE00h case    2:*/		return 0x8209EE04;
		  /* 8209EE04h */ case    3:  		/* bc 4, CR6_LT, 12 */
		/* 8209EE04h case    3:*/		if ( !regs.CR[6].lt ) { return 0x8209EE10;  }
		/* 8209EE04h case    3:*/		return 0x8209EE08;
		  /* 8209EE08h */ case    4:  		/* addi R30, R9, 1 */
		/* 8209EE08h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R9,0x1);
		/* 8209EE08h case    4:*/		return 0x8209EE0C;
		  /* 8209EE0Ch */ case    5:  		/* b 8 */
		/* 8209EE0Ch case    5:*/		return 0x8209EE14;
		/* 8209EE0Ch case    5:*/		return 0x8209EE10;
	}
	return 0x8209EE10;
} // Block from 8209EDF8h-8209EE10h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209EE10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EE10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EE10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EE10);
		  /* 8209EE10h */ case    0:  		/* mr R31, R9 */
		/* 8209EE10h case    0:*/		regs.R31 = regs.R9;
		/* 8209EE10h case    0:*/		return 0x8209EE14;
	}
	return 0x8209EE14;
} // Block from 8209EE10h-8209EE14h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209EE14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EE14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EE14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EE14);
		  /* 8209EE14h */ case    0:  		/* cmplw CR6, R30, R31 */
		/* 8209EE14h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R31);
		/* 8209EE14h case    0:*/		return 0x8209EE18;
		  /* 8209EE18h */ case    1:  		/* bc 12, CR6_LT, -92 */
		/* 8209EE18h case    1:*/		if ( regs.CR[6].lt ) { return 0x8209EDBC;  }
		/* 8209EE18h case    1:*/		return 0x8209EE1C;
		  /* 8209EE1Ch */ case    2:  		/* lis R3, -32768 */
		/* 8209EE1Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8209EE1Ch case    2:*/		return 0x8209EE20;
		  /* 8209EE20h */ case    3:  		/* ori R3, R3, 16389 */
		/* 8209EE20h case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8209EE20h case    3:*/		return 0x8209EE24;
	}
	return 0x8209EE24;
} // Block from 8209EE14h-8209EE24h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209EE24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EE24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EE24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EE24);
		  /* 8209EE24h */ case    0:  		/* b -56188 */
		/* 8209EE24h case    0:*/		return 0x820912A8;
		/* 8209EE24h case    0:*/		return 0x8209EE28;
	}
	return 0x8209EE28;
} // Block from 8209EE24h-8209EE28h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209EE28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EE28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EE28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EE28);
		  /* 8209EE28h */ case    0:  		/* addi R11, R29, 8 */
		/* 8209EE28h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x8);
		/* 8209EE28h case    0:*/		return 0x8209EE2C;
		  /* 8209EE2Ch */ case    1:  		/* lwzx R11, <#[R8 + R11]> */
		/* 8209EE2Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8209EE2Ch case    1:*/		return 0x8209EE30;
		  /* 8209EE30h */ case    2:  		/* and R11, R11, R4 */
		/* 8209EE30h case    2:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 8209EE30h case    2:*/		return 0x8209EE34;
		  /* 8209EE34h */ case    3:  		/* cmplw CR6, R11, R4 */
		/* 8209EE34h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 8209EE34h case    3:*/		return 0x8209EE38;
		  /* 8209EE38h */ case    4:  		/* bc 4, CR6_EQ, -28 */
		/* 8209EE38h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8209EE1C;  }
		/* 8209EE38h case    4:*/		return 0x8209EE3C;
		  /* 8209EE3Ch */ case    5:  		/* cmplwi CR6, R5, 0 */
		/* 8209EE3Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8209EE3Ch case    5:*/		return 0x8209EE40;
		  /* 8209EE40h */ case    6:  		/* bc 12, CR6_EQ, 28 */
		/* 8209EE40h case    6:*/		if ( regs.CR[6].eq ) { return 0x8209EE5C;  }
		/* 8209EE40h case    6:*/		return 0x8209EE44;
		  /* 8209EE44h */ case    7:  		/* lwz R11, <#[R7]> */
		/* 8209EE44h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 8209EE44h case    7:*/		return 0x8209EE48;
		  /* 8209EE48h */ case    8:  		/* stw R11, <#[R5]> */
		/* 8209EE48h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8209EE48h case    8:*/		return 0x8209EE4C;
		  /* 8209EE4Ch */ case    9:  		/* lwz R11, <#[R7 + 4]> */
		/* 8209EE4Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000004) );
		/* 8209EE4Ch case    9:*/		return 0x8209EE50;
		  /* 8209EE50h */ case   10:  		/* stw R11, <#[R5 + 4]> */
		/* 8209EE50h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000004) );
		/* 8209EE50h case   10:*/		return 0x8209EE54;
		  /* 8209EE54h */ case   11:  		/* lwz R11, <#[R7 + 8]> */
		/* 8209EE54h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000008) );
		/* 8209EE54h case   11:*/		return 0x8209EE58;
		  /* 8209EE58h */ case   12:  		/* stw R11, <#[R5 + 8]> */
		/* 8209EE58h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 8209EE58h case   12:*/		return 0x8209EE5C;
	}
	return 0x8209EE5C;
} // Block from 8209EE28h-8209EE5Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209EE5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EE5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EE5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EE5C);
		  /* 8209EE5Ch */ case    0:  		/* li R3, 0 */
		/* 8209EE5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209EE5Ch case    0:*/		return 0x8209EE60;
		  /* 8209EE60h */ case    1:  		/* b -60 */
		/* 8209EE60h case    1:*/		return 0x8209EE24;
		/* 8209EE60h case    1:*/		return 0x8209EE64;
		  /* 8209EE64h */ case    2:  		/* nop */
		/* 8209EE64h case    2:*/		cpu::op::nop();
		/* 8209EE64h case    2:*/		return 0x8209EE68;
		  /* 8209EE68h */ case    3:  		/* lis R11, -32255 */
		/* 8209EE68h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209EE68h case    3:*/		return 0x8209EE6C;
		  /* 8209EE6Ch */ case    4:  		/* li R9, 49 */
		/* 8209EE6Ch case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x31);
		/* 8209EE6Ch case    4:*/		return 0x8209EE70;
		  /* 8209EE70h */ case    5:  		/* addi R10, R11, -15376 */
		/* 8209EE70h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFC3F0);
		/* 8209EE70h case    5:*/		return 0x8209EE74;
		  /* 8209EE74h */ case    6:  		/* addi R11, R10, 596 */
		/* 8209EE74h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x254);
		/* 8209EE74h case    6:*/		return 0x8209EE78;
	}
	return 0x8209EE78;
} // Block from 8209EE5Ch-8209EE78h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209EE78h
// Function '_commit'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EE78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EE78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EE78);
		  /* 8209EE78h */ case    0:  		/* addi R11, R11, -12 */
		/* 8209EE78h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFF4);
		/* 8209EE78h case    0:*/		return 0x8209EE7C;
		  /* 8209EE7Ch */ case    1:  		/* addi R9, R9, -1 */
		/* 8209EE7Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8209EE7Ch case    1:*/		return 0x8209EE80;
		  /* 8209EE80h */ case    2:  		/* lwz R8, <#[R11 - 4]> */
		/* 8209EE80h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 8209EE80h case    2:*/		return 0x8209EE84;
		  /* 8209EE84h */ case    3:  		/* cmplw CR6, R8, R3 */
		/* 8209EE84h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R3);
		/* 8209EE84h case    3:*/		return 0x8209EE88;
		  /* 8209EE88h */ case    4:  		/* bc 4, CR6_EQ, 20 */
		/* 8209EE88h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8209EE9C;  }
		/* 8209EE88h case    4:*/		return 0x8209EE8C;
		  /* 8209EE8Ch */ case    5:  		/* lwz R8, <#[R11]> */
		/* 8209EE8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8209EE8Ch case    5:*/		return 0x8209EE90;
		  /* 8209EE90h */ case    6:  		/* and R8, R8, R4 */
		/* 8209EE90h case    6:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R4);
		/* 8209EE90h case    6:*/		return 0x8209EE94;
		  /* 8209EE94h */ case    7:  		/* cmplw CR6, R8, R4 */
		/* 8209EE94h case    7:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R4);
		/* 8209EE94h case    7:*/		return 0x8209EE98;
		  /* 8209EE98h */ case    8:  		/* bc 12, CR6_EQ, 28 */
		/* 8209EE98h case    8:*/		if ( regs.CR[6].eq ) { return 0x8209EEB4;  }
		/* 8209EE98h case    8:*/		return 0x8209EE9C;
	}
	return 0x8209EE9C;
} // Block from 8209EE78h-8209EE9Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209EE9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EE9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EE9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EE9C);
		  /* 8209EE9Ch */ case    0:  		/* addi R8, R10, 8 */
		/* 8209EE9Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x8);
		/* 8209EE9Ch case    0:*/		return 0x8209EEA0;
		  /* 8209EEA0h */ case    1:  		/* cmplw CR6, R11, R8 */
		/* 8209EEA0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8209EEA0h case    1:*/		return 0x8209EEA4;
		  /* 8209EEA4h */ case    2:  		/* bc 12, CR6_GT, -44 */
		/* 8209EEA4h case    2:*/		if ( regs.CR[6].gt ) { return 0x8209EE78;  }
		/* 8209EEA4h case    2:*/		return 0x8209EEA8;
		  /* 8209EEA8h */ case    3:  		/* lis R3, -32768 */
		/* 8209EEA8h case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8209EEA8h case    3:*/		return 0x8209EEAC;
		  /* 8209EEACh */ case    4:  		/* ori R3, R3, 16389 */
		/* 8209EEACh case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8209EEACh case    4:*/		return 0x8209EEB0;
		  /* 8209EEB0h */ case    5:  		/* bclr 20, CR0_LT */
		/* 8209EEB0h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209EEB0h case    5:*/		return 0x8209EEB4;
	}
	return 0x8209EEB4;
} // Block from 8209EE9Ch-8209EEB4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209EEB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EEB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EEB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EEB4);
		  /* 8209EEB4h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 8209EEB4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8209EEB4h case    0:*/		return 0x8209EEB8;
		  /* 8209EEB8h */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 8209EEB8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209EEDC;  }
		/* 8209EEB8h case    1:*/		return 0x8209EEBC;
		  /* 8209EEBCh */ case    2:  		/* mulli R11, R9, 12 */
		/* 8209EEBCh case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R9,0xC);
		/* 8209EEBCh case    2:*/		return 0x8209EEC0;
		  /* 8209EEC0h */ case    3:  		/* lwzx R9, <#[R11 + R10]> */
		/* 8209EEC0h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8209EEC0h case    3:*/		return 0x8209EEC4;
		  /* 8209EEC4h */ case    4:  		/* add R11, R11, R10 */
		/* 8209EEC4h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8209EEC4h case    4:*/		return 0x8209EEC8;
		  /* 8209EEC8h */ case    5:  		/* stw R9, <#[R5]> */
		/* 8209EEC8h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R5 + 0x00000000) );
		/* 8209EEC8h case    5:*/		return 0x8209EECC;
		  /* 8209EECCh */ case    6:  		/* lwz R10, <#[R11 + 4]> */
		/* 8209EECCh case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8209EECCh case    6:*/		return 0x8209EED0;
		  /* 8209EED0h */ case    7:  		/* stw R10, <#[R5 + 4]> */
		/* 8209EED0h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R5 + 0x00000004) );
		/* 8209EED0h case    7:*/		return 0x8209EED4;
		  /* 8209EED4h */ case    8:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209EED4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209EED4h case    8:*/		return 0x8209EED8;
		  /* 8209EED8h */ case    9:  		/* stw R11, <#[R5 + 8]> */
		/* 8209EED8h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 8209EED8h case    9:*/		return 0x8209EEDC;
	}
	return 0x8209EEDC;
} // Block from 8209EEB4h-8209EEDCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209EEDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EEDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EEDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EEDC);
		  /* 8209EEDCh */ case    0:  		/* li R3, 0 */
		/* 8209EEDCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209EEDCh case    0:*/		return 0x8209EEE0;
		  /* 8209EEE0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8209EEE0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209EEE0h case    1:*/		return 0x8209EEE4;
	}
	return 0x8209EEE4;
} // Block from 8209EEDCh-8209EEE4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209EEE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EEE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EEE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EEE4);
		  /* 8209EEE4h */ case    0:  		/* nop */
		/* 8209EEE4h case    0:*/		cpu::op::nop();
		/* 8209EEE4h case    0:*/		return 0x8209EEE8;
	}
	return 0x8209EEE8;
} // Block from 8209EEE4h-8209EEE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209EEE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EEE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EEE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EEE8);
		  /* 8209EEE8h */ case    0:  		/* mfspr R12, LR */
		/* 8209EEE8h case    0:*/		regs.R12 = regs.LR;
		/* 8209EEE8h case    0:*/		return 0x8209EEEC;
		  /* 8209EEECh */ case    1:  		/* bl -56468 */
		/* 8209EEECh case    1:*/		regs.LR = 0x8209EEF0; return 0x82091258;
		/* 8209EEECh case    1:*/		return 0x8209EEF0;
		  /* 8209EEF0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8209EEF0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8209EEF0h case    2:*/		return 0x8209EEF4;
		  /* 8209EEF4h */ case    3:  		/* li R28, 0 */
		/* 8209EEF4h case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8209EEF4h case    3:*/		return 0x8209EEF8;
		  /* 8209EEF8h */ case    4:  		/* mr R30, R3 */
		/* 8209EEF8h case    4:*/		regs.R30 = regs.R3;
		/* 8209EEF8h case    4:*/		return 0x8209EEFC;
		  /* 8209EEFCh */ case    5:  		/* cmplwi CR6, R4, 0 */
		/* 8209EEFCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8209EEFCh case    5:*/		return 0x8209EF00;
		  /* 8209EF00h */ case    6:  		/* mr R29, R28 */
		/* 8209EF00h case    6:*/		regs.R29 = regs.R28;
		/* 8209EF00h case    6:*/		return 0x8209EF04;
		  /* 8209EF04h */ case    7:  		/* bc 4, CR6_EQ, 16 */
		/* 8209EF04h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8209EF14;  }
		/* 8209EF04h case    7:*/		return 0x8209EF08;
		  /* 8209EF08h */ case    8:  		/* lis R29, -32761 */
		/* 8209EF08h case    8:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8007);
		/* 8209EF08h case    8:*/		return 0x8209EF0C;
		  /* 8209EF0Ch */ case    9:  		/* ori R29, R29, 87 */
		/* 8209EF0Ch case    9:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R29,0x57);
		/* 8209EF0Ch case    9:*/		return 0x8209EF10;
		  /* 8209EF10h */ case   10:  		/* b 56 */
		/* 8209EF10h case   10:*/		return 0x8209EF48;
		/* 8209EF10h case   10:*/		return 0x8209EF14;
	}
	return 0x8209EF14;
} // Block from 8209EEE8h-8209EF14h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209EF14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EF14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EF14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EF14);
		  /* 8209EF14h */ case    0:  		/* addi R31, R4, -1 */
		/* 8209EF14h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R4,0xFFFFFFFF);
		/* 8209EF14h case    0:*/		return 0x8209EF18;
		  /* 8209EF18h */ case    1:  		/* mr R3, R30 */
		/* 8209EF18h case    1:*/		regs.R3 = regs.R30;
		/* 8209EF18h case    1:*/		return 0x8209EF1C;
		  /* 8209EF1Ch */ case    2:  		/* mr R4, R31 */
		/* 8209EF1Ch case    2:*/		regs.R4 = regs.R31;
		/* 8209EF1Ch case    2:*/		return 0x8209EF20;
		  /* 8209EF20h */ case    3:  		/* bl -16216 */
		/* 8209EF20h case    3:*/		regs.LR = 0x8209EF24; return 0x8209AFC8;
		/* 8209EF20h case    3:*/		return 0x8209EF24;
		  /* 8209EF24h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 8209EF24h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209EF24h case    4:*/		return 0x8209EF28;
		  /* 8209EF28h */ case    5:  		/* bc 12, CR0_LT, 20 */
		/* 8209EF28h case    5:*/		if ( regs.CR[0].lt ) { return 0x8209EF3C;  }
		/* 8209EF28h case    5:*/		return 0x8209EF2C;
		  /* 8209EF2Ch */ case    6:  		/* cmplw CR6, R3, R31 */
		/* 8209EF2Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R31);
		/* 8209EF2Ch case    6:*/		return 0x8209EF30;
		  /* 8209EF30h */ case    7:  		/* bc 12, CR6_GT, 12 */
		/* 8209EF30h case    7:*/		if ( regs.CR[6].gt ) { return 0x8209EF3C;  }
		/* 8209EF30h case    7:*/		return 0x8209EF34;
		  /* 8209EF34h */ case    8:  		/* bc 4, CR6_EQ, 20 */
		/* 8209EF34h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8209EF48;  }
		/* 8209EF34h case    8:*/		return 0x8209EF38;
		  /* 8209EF38h */ case    9:  		/* b 12 */
		/* 8209EF38h case    9:*/		return 0x8209EF44;
		/* 8209EF38h case    9:*/		return 0x8209EF3C;
	}
	return 0x8209EF3C;
} // Block from 8209EF14h-8209EF3Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209EF3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EF3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EF3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EF3C);
		  /* 8209EF3Ch */ case    0:  		/* lis R29, -32761 */
		/* 8209EF3Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8007);
		/* 8209EF3Ch case    0:*/		return 0x8209EF40;
		  /* 8209EF40h */ case    1:  		/* ori R29, R29, 122 */
		/* 8209EF40h case    1:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R29,0x7A);
		/* 8209EF40h case    1:*/		return 0x8209EF44;
	}
	return 0x8209EF44;
} // Block from 8209EF3Ch-8209EF44h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209EF44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EF44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EF44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EF44);
		  /* 8209EF44h */ case    0:  		/* stbx R28, <#[R31 + R30]> */
		/* 8209EF44h case    0:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R31 + regs.R30 + 0x00000000) );
		/* 8209EF44h case    0:*/		return 0x8209EF48;
	}
	return 0x8209EF48;
} // Block from 8209EF44h-8209EF48h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209EF48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EF48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EF48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EF48);
		  /* 8209EF48h */ case    0:  		/* mr R3, R29 */
		/* 8209EF48h case    0:*/		regs.R3 = regs.R29;
		/* 8209EF48h case    0:*/		return 0x8209EF4C;
		  /* 8209EF4Ch */ case    1:  		/* addi R1, R1, 128 */
		/* 8209EF4Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8209EF4Ch case    1:*/		return 0x8209EF50;
		  /* 8209EF50h */ case    2:  		/* b -56488 */
		/* 8209EF50h case    2:*/		return 0x820912A8;
		/* 8209EF50h case    2:*/		return 0x8209EF54;
		  /* 8209EF54h */ case    3:  		/* nop */
		/* 8209EF54h case    3:*/		cpu::op::nop();
		/* 8209EF54h case    3:*/		return 0x8209EF58;
		  /* 8209EF58h */ case    4:  		/* lis R4, 9345 */
		/* 8209EF58h case    4:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8209EF58h case    4:*/		return 0x8209EF5C;
		  /* 8209EF5Ch */ case    5:  		/* b -93532 */
		/* 8209EF5Ch case    5:*/		return 0x82088200;
		/* 8209EF5Ch case    5:*/		return 0x8209EF60;
		  /* 8209EF60h */ case    6:  		/* lis R4, 9345 */
		/* 8209EF60h case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8209EF60h case    6:*/		return 0x8209EF64;
		  /* 8209EF64h */ case    7:  		/* b -93228 */
		/* 8209EF64h case    7:*/		return 0x82088338;
		/* 8209EF64h case    7:*/		return 0x8209EF68;
	}
	return 0x8209EF68;
} // Block from 8209EF48h-8209EF68h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209EF68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EF68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EF68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EF68);
		  /* 8209EF68h */ case    0:  		/* mr R11, R3 */
		/* 8209EF68h case    0:*/		regs.R11 = regs.R3;
		/* 8209EF68h case    0:*/		return 0x8209EF6C;
		  /* 8209EF6Ch */ case    1:  		/* lis R10, -32256 */
		/* 8209EF6Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8209EF6Ch case    1:*/		return 0x8209EF70;
		  /* 8209EF70h */ case    2:  		/* mr R3, R4 */
		/* 8209EF70h case    2:*/		regs.R3 = regs.R4;
		/* 8209EF70h case    2:*/		return 0x8209EF74;
		  /* 8209EF74h */ case    3:  		/* addi R4, R10, 4485 */
		/* 8209EF74h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x1185);
		/* 8209EF74h case    3:*/		return 0x8209EF78;
		  /* 8209EF78h */ case    4:  		/* lwz R8, <#[R11 + 16]> */
		/* 8209EF78h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 8209EF78h case    4:*/		return 0x8209EF7C;
		  /* 8209EF7Ch */ case    5:  		/* lwz R7, <#[R11 + 12]> */
		/* 8209EF7Ch case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 8209EF7Ch case    5:*/		return 0x8209EF80;
		  /* 8209EF80h */ case    6:  		/* lwz R6, <#[R11 + 8]> */
		/* 8209EF80h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000008) );
		/* 8209EF80h case    6:*/		return 0x8209EF84;
		  /* 8209EF84h */ case    7:  		/* lwz R5, <#[R11 + 4]> */
		/* 8209EF84h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000004) );
		/* 8209EF84h case    7:*/		return 0x8209EF88;
		  /* 8209EF88h */ case    8:  		/* b 19496 */
		/* 8209EF88h case    8:*/		return 0x820A3BB0;
		/* 8209EF88h case    8:*/		return 0x8209EF8C;
		  /* 8209EF8Ch */ case    9:  		/* nop */
		/* 8209EF8Ch case    9:*/		cpu::op::nop();
		/* 8209EF8Ch case    9:*/		return 0x8209EF90;
	}
	return 0x8209EF90;
} // Block from 8209EF68h-8209EF90h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209EF90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EF90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EF90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EF90);
		  /* 8209EF90h */ case    0:  		/* mfspr R12, LR */
		/* 8209EF90h case    0:*/		regs.R12 = regs.LR;
		/* 8209EF90h case    0:*/		return 0x8209EF94;
		  /* 8209EF94h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209EF94h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209EF94h case    1:*/		return 0x8209EF98;
		  /* 8209EF98h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8209EF98h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209EF98h case    2:*/		return 0x8209EF9C;
		  /* 8209EF9Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209EF9Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209EF9Ch case    3:*/		return 0x8209EFA0;
		  /* 8209EFA0h */ case    4:  		/* lis R11, -32255 */
		/* 8209EFA0h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209EFA0h case    4:*/		return 0x8209EFA4;
		  /* 8209EFA4h */ case    5:  		/* mr R31, R3 */
		/* 8209EFA4h case    5:*/		regs.R31 = regs.R3;
		/* 8209EFA4h case    5:*/		return 0x8209EFA8;
		  /* 8209EFA8h */ case    6:  		/* addi R11, R11, -14788 */
		/* 8209EFA8h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFC63C);
		/* 8209EFA8h case    6:*/		return 0x8209EFAC;
		  /* 8209EFACh */ case    7:  		/* rlwinm. R10, R4, 0, 31, 31 */
		/* 8209EFACh case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R4);
		/* 8209EFACh case    7:*/		return 0x8209EFB0;
		  /* 8209EFB0h */ case    8:  		/* stw R11, <#[R3]> */
		/* 8209EFB0h case    8:*/		regs.IO->MEM_WRITE( 0x8209EFB0, (uint32)(regs.R3 + 0x00000000), 4, &regs.R11 );
		/* 8209EFB0h case    8:*/		return 0x8209EFB4;
		  /* 8209EFB4h */ case    9:  		/* bc 12, CR0_EQ, 8 */
		/* 8209EFB4h case    9:*/		if ( regs.CR[0].eq ) { return 0x8209EFBC;  }
		/* 8209EFB4h case    9:*/		return 0x8209EFB8;
		  /* 8209EFB8h */ case   10:  		/* bl -52304 */
		/* 8209EFB8h case   10:*/		regs.LR = 0x8209EFBC; return 0x82092368;
		/* 8209EFB8h case   10:*/		return 0x8209EFBC;
	}
	return 0x8209EFBC;
} // Block from 8209EF90h-8209EFBCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209EFBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EFBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EFBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EFBC);
		  /* 8209EFBCh */ case    0:  		/* mr R3, R31 */
		/* 8209EFBCh case    0:*/		regs.R3 = regs.R31;
		/* 8209EFBCh case    0:*/		return 0x8209EFC0;
		  /* 8209EFC0h */ case    1:  		/* addi R1, R1, 96 */
		/* 8209EFC0h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209EFC0h case    1:*/		return 0x8209EFC4;
		  /* 8209EFC4h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209EFC4h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209EFC4h case    2:*/		return 0x8209EFC8;
		  /* 8209EFC8h */ case    3:  		/* mtspr LR, R12 */
		/* 8209EFC8h case    3:*/		regs.LR = regs.R12;
		/* 8209EFC8h case    3:*/		return 0x8209EFCC;
		  /* 8209EFCCh */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8209EFCCh case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209EFCCh case    4:*/		return 0x8209EFD0;
		  /* 8209EFD0h */ case    5:  		/* bclr 20, CR0_LT */
		/* 8209EFD0h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209EFD0h case    5:*/		return 0x8209EFD4;
	}
	return 0x8209EFD4;
} // Block from 8209EFBCh-8209EFD4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209EFD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EFD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EFD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EFD4);
		  /* 8209EFD4h */ case    0:  		/* nop */
		/* 8209EFD4h case    0:*/		cpu::op::nop();
		/* 8209EFD4h case    0:*/		return 0x8209EFD8;
	}
	return 0x8209EFD8;
} // Block from 8209EFD4h-8209EFD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209EFD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EFD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EFD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EFD8);
		  /* 8209EFD8h */ case    0:  		/* mfspr R12, LR */
		/* 8209EFD8h case    0:*/		regs.R12 = regs.LR;
		/* 8209EFD8h case    0:*/		return 0x8209EFDC;
		  /* 8209EFDCh */ case    1:  		/* bl -56736 */
		/* 8209EFDCh case    1:*/		regs.LR = 0x8209EFE0; return 0x8209123C;
		/* 8209EFDCh case    1:*/		return 0x8209EFE0;
		  /* 8209EFE0h */ case    2:  		/* stwu R1, <#[R1 - 2688]> */
		/* 8209EFE0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFF580) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFF580);
		/* 8209EFE0h case    2:*/		return 0x8209EFE4;
		  /* 8209EFE4h */ case    3:  		/* li R22, 0 */
		/* 8209EFE4h case    3:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 8209EFE4h case    3:*/		return 0x8209EFE8;
	}
	return 0x8209EFE8;
} // Block from 8209EFD8h-8209EFE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209EFE8h
// Function '__mtold12'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209EFE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209EFE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209EFE8);
		  /* 8209EFE8h */ case    0:  		/* mr R30, R3 */
		/* 8209EFE8h case    0:*/		regs.R30 = regs.R3;
		/* 8209EFE8h case    0:*/		return 0x8209EFEC;
		  /* 8209EFECh */ case    1:  		/* stw R22, <#[R1 + 100]> */
		/* 8209EFECh case    1:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000064) );
		/* 8209EFECh case    1:*/		return 0x8209EFF0;
		  /* 8209EFF0h */ case    2:  		/* addi R3, R1, 304 */
		/* 8209EFF0h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x130);
		/* 8209EFF0h case    2:*/		return 0x8209EFF4;
		  /* 8209EFF4h */ case    3:  		/* stw R22, <#[R1 + 96]> */
		/* 8209EFF4h case    3:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000060) );
		/* 8209EFF4h case    3:*/		return 0x8209EFF8;
		  /* 8209EFF8h */ case    4:  		/* mr R25, R4 */
		/* 8209EFF8h case    4:*/		regs.R25 = regs.R4;
		/* 8209EFF8h case    4:*/		return 0x8209EFFC;
		  /* 8209EFFCh */ case    5:  		/* mr R29, R5 */
		/* 8209EFFCh case    5:*/		regs.R29 = regs.R5;
		/* 8209EFFCh case    5:*/		return 0x8209F000;
		  /* 8209F000h */ case    6:  		/* mr R27, R6 */
		/* 8209F000h case    6:*/		regs.R27 = regs.R6;
		/* 8209F000h case    6:*/		return 0x8209F004;
		  /* 8209F004h */ case    7:  		/* mr R24, R7 */
		/* 8209F004h case    7:*/		regs.R24 = regs.R7;
		/* 8209F004h case    7:*/		return 0x8209F008;
		  /* 8209F008h */ case    8:  		/* mr R21, R8 */
		/* 8209F008h case    8:*/		regs.R21 = regs.R8;
		/* 8209F008h case    8:*/		return 0x8209F00C;
		  /* 8209F00Ch */ case    9:  		/* mr R23, R9 */
		/* 8209F00Ch case    9:*/		regs.R23 = regs.R9;
		/* 8209F00Ch case    9:*/		return 0x8209F010;
		  /* 8209F010h */ case   10:  		/* mr R26, R10 */
		/* 8209F010h case   10:*/		regs.R26 = regs.R10;
		/* 8209F010h case   10:*/		return 0x8209F014;
		  /* 8209F014h */ case   11:  		/* bl 8396 */
		/* 8209F014h case   11:*/		regs.LR = 0x8209F018; return 0x820A10E0;
		/* 8209F014h case   11:*/		return 0x8209F018;
		  /* 8209F018h */ case   12:  		/* cmplwi CR6, R24, 0 */
		/* 8209F018h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 8209F018h case   12:*/		return 0x8209F01C;
		  /* 8209F01Ch */ case   13:  		/* bc 12, CR6_EQ, 8 */
		/* 8209F01Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x8209F024;  }
		/* 8209F01Ch case   13:*/		return 0x8209F020;
		  /* 8209F020h */ case   14:  		/* stw R22, <#[R24]> */
		/* 8209F020h case   14:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R24 + 0x00000000) );
		/* 8209F020h case   14:*/		return 0x8209F024;
	}
	return 0x8209F024;
} // Block from 8209EFE8h-8209F024h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8209F024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F024);
		  /* 8209F024h */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 8209F024h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 8209F024h case    0:*/		return 0x8209F028;
		  /* 8209F028h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 8209F028h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209F030;  }
		/* 8209F028h case    1:*/		return 0x8209F02C;
		  /* 8209F02Ch */ case    2:  		/* stw R22, <#[R23]> */
		/* 8209F02Ch case    2:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R23 + 0x00000000) );
		/* 8209F02Ch case    2:*/		return 0x8209F030;
	}
	return 0x8209F030;
} // Block from 8209F024h-8209F030h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209F030h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F030);
		  /* 8209F030h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 8209F030h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 8209F030h case    0:*/		return 0x8209F034;
		  /* 8209F034h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 8209F034h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209F050;  }
		/* 8209F034h case    1:*/		return 0x8209F038;
		  /* 8209F038h */ case    2:  		/* lwz R11, <#[R26 + 20]> */
		/* 8209F038h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 8209F038h case    2:*/		return 0x8209F03C;
		  /* 8209F03Ch */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8209F03Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209F03Ch case    3:*/		return 0x8209F040;
		  /* 8209F040h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 8209F040h case    4:*/		if ( regs.CR[6].eq ) { return 0x8209F050;  }
		/* 8209F040h case    4:*/		return 0x8209F044;
		  /* 8209F044h */ case    5:  		/* lis R31, -30602 */
		/* 8209F044h case    5:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8876);
		/* 8209F044h case    5:*/		return 0x8209F048;
		  /* 8209F048h */ case    6:  		/* ori R31, R31, 2156 */
		/* 8209F048h case    6:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0x86C);
		/* 8209F048h case    6:*/		return 0x8209F04C;
		  /* 8209F04Ch */ case    7:  		/* b 576 */
		/* 8209F04Ch case    7:*/		return 0x8209F28C;
		/* 8209F04Ch case    7:*/		return 0x8209F050;
	}
	return 0x8209F050;
} // Block from 8209F030h-8209F050h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209F050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F050);
		  /* 8209F050h */ case    0:  		/* lis R12, -863 */
		/* 8209F050h case    0:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFFCA1);
		/* 8209F050h case    0:*/		return 0x8209F054;
		  /* 8209F054h */ case    1:  		/* ori R12, R12, 57792 */
		/* 8209F054h case    1:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xE1C0);
		/* 8209F054h case    1:*/		return 0x8209F058;
		  /* 8209F058h */ case    2:  		/* and. R11, R27, R12 */
		/* 8209F058h case    2:*/		cpu::op::and<1>(regs,&regs.R11,regs.R27,regs.R12);
		/* 8209F058h case    2:*/		return 0x8209F05C;
		  /* 8209F05Ch */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 8209F05Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x8209F06C;  }
		/* 8209F05Ch case    3:*/		return 0x8209F060;
		  /* 8209F060h */ case    4:  		/* lis R31, -30602 */
		/* 8209F060h case    4:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8876);
		/* 8209F060h case    4:*/		return 0x8209F064;
		  /* 8209F064h */ case    5:  		/* ori R31, R31, 2156 */
		/* 8209F064h case    5:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0x86C);
		/* 8209F064h case    5:*/		return 0x8209F068;
		  /* 8209F068h */ case    6:  		/* b 520 */
		/* 8209F068h case    6:*/		return 0x8209F270;
		/* 8209F068h case    6:*/		return 0x8209F06C;
	}
	return 0x8209F06C;
} // Block from 8209F050h-8209F06Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209F06Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F06C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F06C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F06C);
		  /* 8209F06Ch */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8209F06Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8209F06Ch case    0:*/		return 0x8209F070;
		  /* 8209F070h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8209F070h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209F070h case    1:*/		return 0x8209F074;
		  /* 8209F074h */ case    2:  		/* bc 12, CR6_EQ, -20 */
		/* 8209F074h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209F060;  }
		/* 8209F074h case    2:*/		return 0x8209F078;
		  /* 8209F078h */ case    3:  		/* mr R28, R22 */
		/* 8209F078h case    3:*/		regs.R28 = regs.R22;
		/* 8209F078h case    3:*/		return 0x8209F07C;
		  /* 8209F07Ch */ case    4:  		/* cmplwi CR6, R26, 0 */
		/* 8209F07Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 8209F07Ch case    4:*/		return 0x8209F080;
		  /* 8209F080h */ case    5:  		/* bc 12, CR6_EQ, 164 */
		/* 8209F080h case    5:*/		if ( regs.CR[6].eq ) { return 0x8209F124;  }
		/* 8209F080h case    5:*/		return 0x8209F084;
		  /* 8209F084h */ case    6:  		/* lwz R11, <#[R26]> */
		/* 8209F084h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8209F084h case    6:*/		return 0x8209F088;
		  /* 8209F088h */ case    7:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 8209F088h case    7:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 8209F088h case    7:*/		return 0x8209F08C;
		  /* 8209F08Ch */ case    8:  		/* bc 12, CR0_EQ, 152 */
		/* 8209F08Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x8209F124;  }
		/* 8209F08Ch case    8:*/		return 0x8209F090;
		  /* 8209F090h */ case    9:  		/* bl 704584 */
		/* 8209F090h case    9:*/		regs.LR = 0x8209F094; return 0x8214B0D8;
		/* 8209F090h case    9:*/		return 0x8209F094;
		  /* 8209F094h */ case   10:  		/* or. R28, R3, R3 */
		/* 8209F094h case   10:*/		cpu::op::or<1>(regs,&regs.R28,regs.R3,regs.R3);
		/* 8209F094h case   10:*/		return 0x8209F098;
		  /* 8209F098h */ case   11:  		/* stw R28, <#[R26 + 20]> */
		/* 8209F098h case   11:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R26 + 0x00000014) );
		/* 8209F098h case   11:*/		return 0x8209F09C;
		  /* 8209F09Ch */ case   12:  		/* bc 4, CR0_EQ, 16 */
		/* 8209F09Ch case   12:*/		if ( !regs.CR[0].eq ) { return 0x8209F0AC;  }
		/* 8209F09Ch case   12:*/		return 0x8209F0A0;
		  /* 8209F0A0h */ case   13:  		/* lis R31, -32761 */
		/* 8209F0A0h case   13:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8007);
		/* 8209F0A0h case   13:*/		return 0x8209F0A4;
		  /* 8209F0A4h */ case   14:  		/* ori R31, R31, 14 */
		/* 8209F0A4h case   14:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0xE);
		/* 8209F0A4h case   14:*/		return 0x8209F0A8;
		  /* 8209F0A8h */ case   15:  		/* b 456 */
		/* 8209F0A8h case   15:*/		return 0x8209F270;
		/* 8209F0A8h case   15:*/		return 0x8209F0AC;
	}
	return 0x8209F0AC;
} // Block from 8209F06Ch-8209F0ACh (16 instructions)

//////////////////////////////////////////////////////
// Block at 8209F0ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F0AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F0AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F0AC);
		  /* 8209F0ACh */ case    0:  		/* lis R11, -32255 */
		/* 8209F0ACh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209F0ACh case    0:*/		return 0x8209F0B0;
		  /* 8209F0B0h */ case    1:  		/* li R5, 0 */
		/* 8209F0B0h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8209F0B0h case    1:*/		return 0x8209F0B4;
		  /* 8209F0B4h */ case    2:  		/* addi R4, R11, -14728 */
		/* 8209F0B4h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC678);
		/* 8209F0B4h case    2:*/		return 0x8209F0B8;
		  /* 8209F0B8h */ case    3:  		/* mr R3, R28 */
		/* 8209F0B8h case    3:*/		regs.R3 = regs.R28;
		/* 8209F0B8h case    3:*/		return 0x8209F0BC;
		  /* 8209F0BCh */ case    4:  		/* bl 693428 */
		/* 8209F0BCh case    4:*/		regs.LR = 0x8209F0C0; return 0x82148570;
		/* 8209F0BCh case    4:*/		return 0x8209F0C0;
		  /* 8209F0C0h */ case    5:  		/* lwz R11, <#[R30]> */
		/* 8209F0C0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8209F0C0h case    5:*/		return 0x8209F0C4;
		  /* 8209F0C4h */ case    6:  		/* mr R3, R30 */
		/* 8209F0C4h case    6:*/		regs.R3 = regs.R30;
		/* 8209F0C4h case    6:*/		return 0x8209F0C8;
		  /* 8209F0C8h */ case    7:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209F0C8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F0C8h case    7:*/		return 0x8209F0CC;
		  /* 8209F0CCh */ case    8:  		/* mtspr CTR, R11 */
		/* 8209F0CCh case    8:*/		regs.CTR = regs.R11;
		/* 8209F0CCh case    8:*/		return 0x8209F0D0;
		  /* 8209F0D0h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 8209F0D0h case    9:*/		if ( 1 ) { regs.LR = 0x8209F0D4; return (uint32)regs.CTR; }
		/* 8209F0D0h case    9:*/		return 0x8209F0D4;
		  /* 8209F0D4h */ case   10:  		/* cmplwi CR0, R3, 0 */
		/* 8209F0D4h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8209F0D4h case   10:*/		return 0x8209F0D8;
		  /* 8209F0D8h */ case   11:  		/* bc 12, CR0_EQ, 60 */
		/* 8209F0D8h case   11:*/		if ( regs.CR[0].eq ) { return 0x8209F114;  }
		/* 8209F0D8h case   11:*/		return 0x8209F0DC;
		  /* 8209F0DCh */ case   12:  		/* lwz R11, <#[R30]> */
		/* 8209F0DCh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8209F0DCh case   12:*/		return 0x8209F0E0;
		  /* 8209F0E0h */ case   13:  		/* mr R3, R30 */
		/* 8209F0E0h case   13:*/		regs.R3 = regs.R30;
		/* 8209F0E0h case   13:*/		return 0x8209F0E4;
		  /* 8209F0E4h */ case   14:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209F0E4h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F0E4h case   14:*/		return 0x8209F0E8;
		  /* 8209F0E8h */ case   15:  		/* mtspr CTR, R11 */
		/* 8209F0E8h case   15:*/		regs.CTR = regs.R11;
		/* 8209F0E8h case   15:*/		return 0x8209F0EC;
		  /* 8209F0ECh */ case   16:  		/* bcctrl 20, CR0_LT */
		/* 8209F0ECh case   16:*/		if ( 1 ) { regs.LR = 0x8209F0F0; return (uint32)regs.CTR; }
		/* 8209F0ECh case   16:*/		return 0x8209F0F0;
		  /* 8209F0F0h */ case   17:  		/* lwz R4, <#[R3]> */
		/* 8209F0F0h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000000) );
		/* 8209F0F0h case   17:*/		return 0x8209F0F4;
		  /* 8209F0F4h */ case   18:  		/* mr R31, R3 */
		/* 8209F0F4h case   18:*/		regs.R31 = regs.R3;
		/* 8209F0F4h case   18:*/		return 0x8209F0F8;
		  /* 8209F0F8h */ case   19:  		/* b 20 */
		/* 8209F0F8h case   19:*/		return 0x8209F10C;
		/* 8209F0F8h case   19:*/		return 0x8209F0FC;
		  /* 8209F0FCh */ case   20:  		/* mr R3, R28 */
		/* 8209F0FCh case   20:*/		regs.R3 = regs.R28;
		/* 8209F0FCh case   20:*/		return 0x8209F100;
		  /* 8209F100h */ case   21:  		/* lwz R5, <#[R31 + 4]> */
		/* 8209F100h case   21:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000004) );
		/* 8209F100h case   21:*/		return 0x8209F104;
		  /* 8209F104h */ case   22:  		/* bl 707172 */
		/* 8209F104h case   22:*/		regs.LR = 0x8209F108; return 0x8214BB68;
		/* 8209F104h case   22:*/		return 0x8209F108;
		  /* 8209F108h */ case   23:  		/* lwzu R4, <#[R31 + 8]> */
		/* 8209F108h case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		regs.R31 = (uint32)(regs.R31 + 0x00000008);
		/* 8209F108h case   23:*/		return 0x8209F10C;
	}
	return 0x8209F10C;
} // Block from 8209F0ACh-8209F10Ch (24 instructions)

//////////////////////////////////////////////////////
// Block at 8209F10Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F10C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F10C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F10C);
		  /* 8209F10Ch */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 8209F10Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8209F10Ch case    0:*/		return 0x8209F110;
		  /* 8209F110h */ case    1:  		/* bc 4, CR6_EQ, -20 */
		/* 8209F110h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209F0FC;  }
		/* 8209F110h case    1:*/		return 0x8209F114;
	}
	return 0x8209F114;
} // Block from 8209F10Ch-8209F114h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209F114h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F114( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F114) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F114);
		  /* 8209F114h */ case    0:  		/* mr R5, R26 */
		/* 8209F114h case    0:*/		regs.R5 = regs.R26;
		/* 8209F114h case    0:*/		return 0x8209F118;
		  /* 8209F118h */ case    1:  		/* mr R4, R27 */
		/* 8209F118h case    1:*/		regs.R4 = regs.R27;
		/* 8209F118h case    1:*/		return 0x8209F11C;
		  /* 8209F11Ch */ case    2:  		/* mr R3, R28 */
		/* 8209F11Ch case    2:*/		regs.R3 = regs.R28;
		/* 8209F11Ch case    2:*/		return 0x8209F120;
		  /* 8209F120h */ case    3:  		/* bl 704512 */
		/* 8209F120h case    3:*/		regs.LR = 0x8209F124; return 0x8214B120;
		/* 8209F120h case    3:*/		return 0x8209F124;
	}
	return 0x8209F124;
} // Block from 8209F114h-8209F124h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209F124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F124);
		  /* 8209F124h */ case    0:  		/* mr R4, R27 */
		/* 8209F124h case    0:*/		regs.R4 = regs.R27;
		/* 8209F124h case    0:*/		return 0x8209F128;
		  /* 8209F128h */ case    1:  		/* lwz R3, <#[R29]> */
		/* 8209F128h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 8209F128h case    1:*/		return 0x8209F12C;
		  /* 8209F12Ch */ case    2:  		/* bl -1156 */
		/* 8209F12Ch case    2:*/		regs.LR = 0x8209F130; return 0x8209ECA8;
		/* 8209F12Ch case    2:*/		return 0x8209F130;
		  /* 8209F130h */ case    3:  		/* stw R3, <#[R29]> */
		/* 8209F130h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 8209F130h case    3:*/		return 0x8209F134;
		  /* 8209F134h */ case    4:  		/* lwz R11, <#[R30]> */
		/* 8209F134h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8209F134h case    4:*/		return 0x8209F138;
		  /* 8209F138h */ case    5:  		/* addi R4, R1, 304 */
		/* 8209F138h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x130);
		/* 8209F138h case    5:*/		return 0x8209F13C;
		  /* 8209F13Ch */ case    6:  		/* stw R26, <#[R1 + 2576]> */
		/* 8209F13Ch case    6:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000A10) );
		/* 8209F13Ch case    6:*/		return 0x8209F140;
		  /* 8209F140h */ case    7:  		/* mr R3, R30 */
		/* 8209F140h case    7:*/		regs.R3 = regs.R30;
		/* 8209F140h case    7:*/		return 0x8209F144;
		  /* 8209F144h */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 8209F144h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8209F144h case    8:*/		return 0x8209F148;
		  /* 8209F148h */ case    9:  		/* mtspr CTR, R11 */
		/* 8209F148h case    9:*/		regs.CTR = regs.R11;
		/* 8209F148h case    9:*/		return 0x8209F14C;
		  /* 8209F14Ch */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 8209F14Ch case   10:*/		if ( 1 ) { regs.LR = 0x8209F150; return (uint32)regs.CTR; }
		/* 8209F14Ch case   10:*/		return 0x8209F150;
		  /* 8209F150h */ case   11:  		/* or. R31, R3, R3 */
		/* 8209F150h case   11:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 8209F150h case   11:*/		return 0x8209F154;
		  /* 8209F154h */ case   12:  		/* bc 12, CR0_LT, 284 */
		/* 8209F154h case   12:*/		if ( regs.CR[0].lt ) { return 0x8209F270;  }
		/* 8209F154h case   12:*/		return 0x8209F158;
		  /* 8209F158h */ case   13:  		/* lwz R3, <#[R29]> */
		/* 8209F158h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 8209F158h case   13:*/		return 0x8209F15C;
		  /* 8209F15Ch */ case   14:  		/* bl -1372 */
		/* 8209F15Ch case   14:*/		regs.LR = 0x8209F160; return 0x8209EC00;
		/* 8209F15Ch case   14:*/		return 0x8209F160;
		  /* 8209F160h */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 8209F160h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209F160h case   15:*/		return 0x8209F164;
		  /* 8209F164h */ case   16:  		/* addi R3, R1, 304 */
		/* 8209F164h case   16:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x130);
		/* 8209F164h case   16:*/		return 0x8209F168;
		  /* 8209F168h */ case   17:  		/* bc 12, CR0_EQ, 16 */
		/* 8209F168h case   17:*/		if ( regs.CR[0].eq ) { return 0x8209F178;  }
		/* 8209F168h case   17:*/		return 0x8209F16C;
		  /* 8209F16Ch */ case   18:  		/* lis R11, -32255 */
		/* 8209F16Ch case   18:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209F16Ch case   18:*/		return 0x8209F170;
		  /* 8209F170h */ case   19:  		/* addi R4, R11, -14760 */
		/* 8209F170h case   19:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC658);
		/* 8209F170h case   19:*/		return 0x8209F174;
		  /* 8209F174h */ case   20:  		/* b 12 */
		/* 8209F174h case   20:*/		return 0x8209F180;
		/* 8209F174h case   20:*/		return 0x8209F178;
	}
	return 0x8209F178;
} // Block from 8209F124h-8209F178h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8209F178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F178);
		  /* 8209F178h */ case    0:  		/* lis R11, -32255 */
		/* 8209F178h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209F178h case    0:*/		return 0x8209F17C;
		  /* 8209F17Ch */ case    1:  		/* addi R4, R11, -14776 */
		/* 8209F17Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC648);
		/* 8209F17Ch case    1:*/		return 0x8209F180;
	}
	return 0x8209F180;
} // Block from 8209F178h-8209F180h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209F180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F180);
		  /* 8209F180h */ case    0:  		/* bl 12904 */
		/* 8209F180h case    0:*/		regs.LR = 0x8209F184; return 0x820A23E8;
		/* 8209F180h case    0:*/		return 0x8209F184;
		  /* 8209F184h */ case    1:  		/* li R4, 0 */
		/* 8209F184h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8209F184h case    1:*/		return 0x8209F188;
		  /* 8209F188h */ case    2:  		/* addi R3, R1, 112 */
		/* 8209F188h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 8209F188h case    2:*/		return 0x8209F18C;
		  /* 8209F18Ch */ case    3:  		/* bl 62572 */
		/* 8209F18Ch case    3:*/		regs.LR = 0x8209F190; return 0x820AE5F8;
		/* 8209F18Ch case    3:*/		return 0x8209F190;
		  /* 8209F190h */ case    4:  		/* addi R11, R1, 96 */
		/* 8209F190h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 8209F190h case    4:*/		return 0x8209F194;
		  /* 8209F194h */ case    5:  		/* addi R10, R1, 100 */
		/* 8209F194h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x64);
		/* 8209F194h case    5:*/		return 0x8209F198;
		  /* 8209F198h */ case    6:  		/* lwz R8, <#[R29]> */
		/* 8209F198h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000000) );
		/* 8209F198h case    6:*/		return 0x8209F19C;
		  /* 8209F19Ch */ case    7:  		/* ori R9, R27, 256 */
		/* 8209F19Ch case    7:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R27,0x100);
		/* 8209F19Ch case    7:*/		return 0x8209F1A0;
		  /* 8209F1A0h */ case    8:  		/* stw R26, <#[R1 + 92]> */
		/* 8209F1A0h case    8:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x0000005C) );
		/* 8209F1A0h case    8:*/		return 0x8209F1A4;
		  /* 8209F1A4h */ case    9:  		/* li R7, 0 */
		/* 8209F1A4h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8209F1A4h case    9:*/		return 0x8209F1A8;
		  /* 8209F1A8h */ case   10:  		/* stw R11, <#[R1 + 84]> */
		/* 8209F1A8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8209F1A8h case   10:*/		return 0x8209F1AC;
		  /* 8209F1ACh */ case   11:  		/* mr R6, R25 */
		/* 8209F1ACh case   11:*/		regs.R6 = regs.R25;
		/* 8209F1ACh case   11:*/		return 0x8209F1B0;
		  /* 8209F1B0h */ case   12:  		/* li R5, 0 */
		/* 8209F1B0h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8209F1B0h case   12:*/		return 0x8209F1B4;
		  /* 8209F1B4h */ case   13:  		/* addi R4, R1, 304 */
		/* 8209F1B4h case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x130);
		/* 8209F1B4h case   13:*/		return 0x8209F1B8;
		  /* 8209F1B8h */ case   14:  		/* addi R3, R1, 112 */
		/* 8209F1B8h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 8209F1B8h case   14:*/		return 0x8209F1BC;
		  /* 8209F1BCh */ case   15:  		/* bl 150892 */
		/* 8209F1BCh case   15:*/		regs.LR = 0x8209F1C0; return 0x820C3F28;
		/* 8209F1BCh case   15:*/		return 0x8209F1C0;
		  /* 8209F1C0h */ case   16:  		/* or. R31, R3, R3 */
		/* 8209F1C0h case   16:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 8209F1C0h case   16:*/		return 0x8209F1C4;
		  /* 8209F1C4h */ case   17:  		/* addi R3, R1, 112 */
		/* 8209F1C4h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 8209F1C4h case   17:*/		return 0x8209F1C8;
		  /* 8209F1C8h */ case   18:  		/* bc 4, CR0_LT, 12 */
		/* 8209F1C8h case   18:*/		if ( !regs.CR[0].lt ) { return 0x8209F1D4;  }
		/* 8209F1C8h case   18:*/		return 0x8209F1CC;
		  /* 8209F1CCh */ case   19:  		/* bl 70532 */
		/* 8209F1CCh case   19:*/		regs.LR = 0x8209F1D0; return 0x820B0550;
		/* 8209F1CCh case   19:*/		return 0x8209F1D0;
		  /* 8209F1D0h */ case   20:  		/* b 160 */
		/* 8209F1D0h case   20:*/		return 0x8209F270;
		/* 8209F1D0h case   20:*/		return 0x8209F1D4;
	}
	return 0x8209F1D4;
} // Block from 8209F180h-8209F1D4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8209F1D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F1D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F1D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F1D4);
		  /* 8209F1D4h */ case    0:  		/* bl 70524 */
		/* 8209F1D4h case    0:*/		regs.LR = 0x8209F1D8; return 0x820B0550;
		/* 8209F1D4h case    0:*/		return 0x8209F1D8;
		  /* 8209F1D8h */ case    1:  		/* addi R3, R1, 328 */
		/* 8209F1D8h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x148);
		/* 8209F1D8h case    1:*/		return 0x8209F1DC;
		  /* 8209F1DCh */ case    2:  		/* bl 27460 */
		/* 8209F1DCh case    2:*/		regs.LR = 0x8209F1E0; return 0x820A5D20;
		/* 8209F1DCh case    2:*/		return 0x8209F1E0;
		  /* 8209F1E0h */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 8209F1E0h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8209F1E0h case    3:*/		return 0x8209F1E4;
		  /* 8209F1E4h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 8209F1E4h case    4:*/		if ( regs.CR[0].eq ) { return 0x8209F1F4;  }
		/* 8209F1E4h case    4:*/		return 0x8209F1E8;
		  /* 8209F1E8h */ case    5:  		/* lis R31, -30602 */
		/* 8209F1E8h case    5:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8876);
		/* 8209F1E8h case    5:*/		return 0x8209F1EC;
		  /* 8209F1ECh */ case    6:  		/* ori R31, R31, 2905 */
		/* 8209F1ECh case    6:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0xB59);
		/* 8209F1ECh case    6:*/		return 0x8209F1F0;
		  /* 8209F1F0h */ case    7:  		/* b 128 */
		/* 8209F1F0h case    7:*/		return 0x8209F270;
		/* 8209F1F0h case    7:*/		return 0x8209F1F4;
	}
	return 0x8209F1F4;
} // Block from 8209F1D4h-8209F1F4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209F1F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F1F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F1F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F1F4);
		  /* 8209F1F4h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 8209F1F4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8209F1F4h case    0:*/		return 0x8209F1F8;
		  /* 8209F1F8h */ case    1:  		/* bc 12, CR6_EQ, 80 */
		/* 8209F1F8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209F248;  }
		/* 8209F1F8h case    1:*/		return 0x8209F1FC;
		  /* 8209F1FCh */ case    2:  		/* mr R3, R28 */
		/* 8209F1FCh case    2:*/		regs.R3 = regs.R28;
		/* 8209F1FCh case    2:*/		return 0x8209F200;
		  /* 8209F200h */ case    3:  		/* bl 707304 */
		/* 8209F200h case    3:*/		regs.LR = 0x8209F204; return 0x8214BCE8;
		/* 8209F200h case    3:*/		return 0x8209F204;
		  /* 8209F204h */ case    4:  		/* addi R29, R26, 12 */
		/* 8209F204h case    4:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R26,0xC);
		/* 8209F204h case    4:*/		return 0x8209F208;
		  /* 8209F208h */ case    5:  		/* mr R30, R3 */
		/* 8209F208h case    5:*/		regs.R30 = regs.R3;
		/* 8209F208h case    5:*/		return 0x8209F20C;
		  /* 8209F20Ch */ case    6:  		/* mr R4, R29 */
		/* 8209F20Ch case    6:*/		regs.R4 = regs.R29;
		/* 8209F20Ch case    6:*/		return 0x8209F210;
		  /* 8209F210h */ case    7:  		/* bl 26832 */
		/* 8209F210h case    7:*/		regs.LR = 0x8209F214; return 0x820A5AE0;
		/* 8209F210h case    7:*/		return 0x8209F214;
		  /* 8209F214h */ case    8:  		/* or. R31, R3, R3 */
		/* 8209F214h case    8:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 8209F214h case    8:*/		return 0x8209F218;
		  /* 8209F218h */ case    9:  		/* bc 12, CR0_LT, 48 */
		/* 8209F218h case    9:*/		if ( regs.CR[0].lt ) { return 0x8209F248;  }
		/* 8209F218h case    9:*/		return 0x8209F21C;
		  /* 8209F21Ch */ case   10:  		/* lwz R3, <#[R29]> */
		/* 8209F21Ch case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 8209F21Ch case   10:*/		return 0x8209F220;
		  /* 8209F220h */ case   11:  		/* lwz R11, <#[R3]> */
		/* 8209F220h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209F220h case   11:*/		return 0x8209F224;
		  /* 8209F224h */ case   12:  		/* lwz R11, <#[R11 + 12]> */
		/* 8209F224h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8209F224h case   12:*/		return 0x8209F228;
		  /* 8209F228h */ case   13:  		/* mtspr CTR, R11 */
		/* 8209F228h case   13:*/		regs.CTR = regs.R11;
		/* 8209F228h case   13:*/		return 0x8209F22C;
		  /* 8209F22Ch */ case   14:  		/* bcctrl 20, CR0_LT */
		/* 8209F22Ch case   14:*/		if ( 1 ) { regs.LR = 0x8209F230; return (uint32)regs.CTR; }
		/* 8209F22Ch case   14:*/		return 0x8209F230;
		  /* 8209F230h */ case   15:  		/* mr R4, R3 */
		/* 8209F230h case   15:*/		regs.R4 = regs.R3;
		/* 8209F230h case   15:*/		return 0x8209F234;
		  /* 8209F234h */ case   16:  		/* addi R6, R1, 104 */
		/* 8209F234h case   16:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x68);
		/* 8209F234h case   16:*/		return 0x8209F238;
		  /* 8209F238h */ case   17:  		/* mr R5, R30 */
		/* 8209F238h case   17:*/		regs.R5 = regs.R30;
		/* 8209F238h case   17:*/		return 0x8209F23C;
		  /* 8209F23Ch */ case   18:  		/* mr R3, R28 */
		/* 8209F23Ch case   18:*/		regs.R3 = regs.R28;
		/* 8209F23Ch case   18:*/		return 0x8209F240;
		  /* 8209F240h */ case   19:  		/* bl 707248 */
		/* 8209F240h case   19:*/		regs.LR = 0x8209F244; return 0x8214BCF0;
		/* 8209F240h case   19:*/		return 0x8209F244;
		  /* 8209F244h */ case   20:  		/* mr R31, R3 */
		/* 8209F244h case   20:*/		regs.R31 = regs.R3;
		/* 8209F244h case   20:*/		return 0x8209F248;
	}
	return 0x8209F248;
} // Block from 8209F1F4h-8209F248h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8209F248h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F248);
		  /* 8209F248h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 8209F248h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 8209F248h case    0:*/		return 0x8209F24C;
		  /* 8209F24Ch */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8209F24Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8209F25C;  }
		/* 8209F24Ch case    1:*/		return 0x8209F250;
		  /* 8209F250h */ case    2:  		/* lwz R11, <#[R1 + 100]> */
		/* 8209F250h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 8209F250h case    2:*/		return 0x8209F254;
		  /* 8209F254h */ case    3:  		/* stw R22, <#[R1 + 100]> */
		/* 8209F254h case    3:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000064) );
		/* 8209F254h case    3:*/		return 0x8209F258;
		  /* 8209F258h */ case    4:  		/* stw R11, <#[R24]> */
		/* 8209F258h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 8209F258h case    4:*/		return 0x8209F25C;
	}
	return 0x8209F25C;
} // Block from 8209F248h-8209F25Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209F25Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F25C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F25C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F25C);
		  /* 8209F25Ch */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 8209F25Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 8209F25Ch case    0:*/		return 0x8209F260;
		  /* 8209F260h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8209F260h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209F270;  }
		/* 8209F260h case    1:*/		return 0x8209F264;
		  /* 8209F264h */ case    2:  		/* lwz R11, <#[R1 + 96]> */
		/* 8209F264h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 8209F264h case    2:*/		return 0x8209F268;
		  /* 8209F268h */ case    3:  		/* stw R22, <#[R1 + 96]> */
		/* 8209F268h case    3:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000060) );
		/* 8209F268h case    3:*/		return 0x8209F26C;
		  /* 8209F26Ch */ case    4:  		/* stw R11, <#[R23]> */
		/* 8209F26Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8209F26Ch case    4:*/		return 0x8209F270;
	}
	return 0x8209F270;
} // Block from 8209F25Ch-8209F270h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209F270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F270);
		  /* 8209F270h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 8209F270h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 8209F270h case    0:*/		return 0x8209F274;
		  /* 8209F274h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 8209F274h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209F28C;  }
		/* 8209F274h case    1:*/		return 0x8209F278;
		  /* 8209F278h */ case    2:  		/* lwz R3, <#[R26 + 20]> */
		/* 8209F278h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x00000014) );
		/* 8209F278h case    2:*/		return 0x8209F27C;
		  /* 8209F27Ch */ case    3:  		/* cmplwi CR6, R3, 0 */
		/* 8209F27Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209F27Ch case    3:*/		return 0x8209F280;
	}
	return 0x8209F280;
} // Block from 8209F270h-8209F280h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209F280h
// Function '_close_nolock'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F280);
		  /* 8209F280h */ case    0:  		/* bc 12, CR6_EQ, 12 */
		/* 8209F280h case    0:*/		if ( regs.CR[6].eq ) { return 0x8209F28C;  }
		/* 8209F280h case    0:*/		return 0x8209F284;
		  /* 8209F284h */ case    1:  		/* bl 684772 */
		/* 8209F284h case    1:*/		regs.LR = 0x8209F288; return 0x82146568;
		/* 8209F284h case    1:*/		return 0x8209F288;
		  /* 8209F288h */ case    2:  		/* stw R22, <#[R26 + 20]> */
		/* 8209F288h case    2:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R26 + 0x00000014) );
		/* 8209F288h case    2:*/		return 0x8209F28C;
	}
	return 0x8209F28C;
} // Block from 8209F280h-8209F28Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209F28Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F28C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F28C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F28C);
		  /* 8209F28Ch */ case    0:  		/* cmplwi CR6, R21, 0 */
		/* 8209F28Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 8209F28Ch case    0:*/		return 0x8209F290;
		  /* 8209F290h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8209F290h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209F2A0;  }
		/* 8209F290h case    1:*/		return 0x8209F294;
		  /* 8209F294h */ case    2:  		/* mr R4, R21 */
		/* 8209F294h case    2:*/		regs.R4 = regs.R21;
		/* 8209F294h case    2:*/		return 0x8209F298;
		  /* 8209F298h */ case    3:  		/* addi R3, R1, 328 */
		/* 8209F298h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x148);
		/* 8209F298h case    3:*/		return 0x8209F29C;
		  /* 8209F29Ch */ case    4:  		/* bl 27084 */
		/* 8209F29Ch case    4:*/		regs.LR = 0x8209F2A0; return 0x820A5C68;
		/* 8209F29Ch case    4:*/		return 0x8209F2A0;
	}
	return 0x8209F2A0;
} // Block from 8209F28Ch-8209F2A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209F2A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F2A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F2A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F2A0);
		  /* 8209F2A0h */ case    0:  		/* lwz R3, <#[R1 + 96]> */
		/* 8209F2A0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 8209F2A0h case    0:*/		return 0x8209F2A4;
		  /* 8209F2A4h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8209F2A4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209F2A4h case    1:*/		return 0x8209F2A8;
		  /* 8209F2A8h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 8209F2A8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209F2C0;  }
		/* 8209F2A8h case    2:*/		return 0x8209F2AC;
		  /* 8209F2ACh */ case    3:  		/* lwz R11, <#[R3]> */
		/* 8209F2ACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209F2ACh case    3:*/		return 0x8209F2B0;
		  /* 8209F2B0h */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209F2B0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F2B0h case    4:*/		return 0x8209F2B4;
		  /* 8209F2B4h */ case    5:  		/* mtspr CTR, R11 */
		/* 8209F2B4h case    5:*/		regs.CTR = regs.R11;
		/* 8209F2B4h case    5:*/		return 0x8209F2B8;
		  /* 8209F2B8h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 8209F2B8h case    6:*/		if ( 1 ) { regs.LR = 0x8209F2BC; return (uint32)regs.CTR; }
		/* 8209F2B8h case    6:*/		return 0x8209F2BC;
		  /* 8209F2BCh */ case    7:  		/* stw R22, <#[R1 + 96]> */
		/* 8209F2BCh case    7:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000060) );
		/* 8209F2BCh case    7:*/		return 0x8209F2C0;
	}
	return 0x8209F2C0;
} // Block from 8209F2A0h-8209F2C0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209F2C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F2C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F2C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F2C0);
		  /* 8209F2C0h */ case    0:  		/* lwz R3, <#[R1 + 100]> */
		/* 8209F2C0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000064) );
		/* 8209F2C0h case    0:*/		return 0x8209F2C4;
		  /* 8209F2C4h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8209F2C4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209F2C4h case    1:*/		return 0x8209F2C8;
		  /* 8209F2C8h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 8209F2C8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209F2E0;  }
		/* 8209F2C8h case    2:*/		return 0x8209F2CC;
		  /* 8209F2CCh */ case    3:  		/* lwz R11, <#[R3]> */
		/* 8209F2CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209F2CCh case    3:*/		return 0x8209F2D0;
		  /* 8209F2D0h */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209F2D0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F2D0h case    4:*/		return 0x8209F2D4;
		  /* 8209F2D4h */ case    5:  		/* mtspr CTR, R11 */
		/* 8209F2D4h case    5:*/		regs.CTR = regs.R11;
		/* 8209F2D4h case    5:*/		return 0x8209F2D8;
		  /* 8209F2D8h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 8209F2D8h case    6:*/		if ( 1 ) { regs.LR = 0x8209F2DC; return (uint32)regs.CTR; }
		/* 8209F2D8h case    6:*/		return 0x8209F2DC;
		  /* 8209F2DCh */ case    7:  		/* stw R22, <#[R1 + 100]> */
		/* 8209F2DCh case    7:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000064) );
		/* 8209F2DCh case    7:*/		return 0x8209F2E0;
	}
	return 0x8209F2E0;
} // Block from 8209F2C0h-8209F2E0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209F2E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F2E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F2E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F2E0);
		  /* 8209F2E0h */ case    0:  		/* addi R3, R1, 304 */
		/* 8209F2E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x130);
		/* 8209F2E0h case    0:*/		return 0x8209F2E4;
		  /* 8209F2E4h */ case    1:  		/* bl 14220 */
		/* 8209F2E4h case    1:*/		regs.LR = 0x8209F2E8; return 0x820A2A70;
		/* 8209F2E4h case    1:*/		return 0x8209F2E8;
		  /* 8209F2E8h */ case    2:  		/* mr R3, R31 */
		/* 8209F2E8h case    2:*/		regs.R3 = regs.R31;
		/* 8209F2E8h case    2:*/		return 0x8209F2EC;
		  /* 8209F2ECh */ case    3:  		/* addi R1, R1, 2688 */
		/* 8209F2ECh case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA80);
		/* 8209F2ECh case    3:*/		return 0x8209F2F0;
		  /* 8209F2F0h */ case    4:  		/* b -57444 */
		/* 8209F2F0h case    4:*/		return 0x8209128C;
		/* 8209F2F0h case    4:*/		return 0x8209F2F4;
		  /* 8209F2F4h */ case    5:  		/* nop */
		/* 8209F2F4h case    5:*/		cpu::op::nop();
		/* 8209F2F4h case    5:*/		return 0x8209F2F8;
	}
	return 0x8209F2F8;
} // Block from 8209F2E0h-8209F2F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209F2F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F2F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F2F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F2F8);
		  /* 8209F2F8h */ case    0:  		/* mfspr R12, LR */
		/* 8209F2F8h case    0:*/		regs.R12 = regs.LR;
		/* 8209F2F8h case    0:*/		return 0x8209F2FC;
		  /* 8209F2FCh */ case    1:  		/* bl -57548 */
		/* 8209F2FCh case    1:*/		regs.LR = 0x8209F300; return 0x82091230;
		/* 8209F2FCh case    1:*/		return 0x8209F300;
		  /* 8209F300h */ case    2:  		/* stwu R1, <#[R1 - 256]> */
		/* 8209F300h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 8209F300h case    2:*/		return 0x8209F304;
		  /* 8209F304h */ case    3:  		/* lis R30, -32215 */
		/* 8209F304h case    3:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8229);
		/* 8209F304h case    3:*/		return 0x8209F308;
		  /* 8209F308h */ case    4:  		/* mr R28, R3 */
		/* 8209F308h case    4:*/		regs.R28 = regs.R3;
		/* 8209F308h case    4:*/		return 0x8209F30C;
		  /* 8209F30Ch */ case    5:  		/* mr R27, R4 */
		/* 8209F30Ch case    5:*/		regs.R27 = regs.R4;
		/* 8209F30Ch case    5:*/		return 0x8209F310;
		  /* 8209F310h */ case    6:  		/* mr R25, R5 */
		/* 8209F310h case    6:*/		regs.R25 = regs.R5;
		/* 8209F310h case    6:*/		return 0x8209F314;
		  /* 8209F314h */ case    7:  		/* mr R31, R6 */
		/* 8209F314h case    7:*/		regs.R31 = regs.R6;
		/* 8209F314h case    7:*/		return 0x8209F318;
		  /* 8209F318h */ case    8:  		/* lbz R11, <#[R30 - 30131]> */
		/* 8209F318h case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0xFFFF8A4D) );
		/* 8209F318h case    8:*/		return 0x8209F31C;
		  /* 8209F31Ch */ case    9:  		/* mr R24, R7 */
		/* 8209F31Ch case    9:*/		regs.R24 = regs.R7;
		/* 8209F31Ch case    9:*/		return 0x8209F320;
		  /* 8209F320h */ case   10:  		/* mr R22, R8 */
		/* 8209F320h case   10:*/		regs.R22 = regs.R8;
		/* 8209F320h case   10:*/		return 0x8209F324;
		  /* 8209F324h */ case   11:  		/* mr R21, R9 */
		/* 8209F324h case   11:*/		regs.R21 = regs.R9;
		/* 8209F324h case   11:*/		return 0x8209F328;
		  /* 8209F328h */ case   12:  		/* mr R23, R10 */
		/* 8209F328h case   12:*/		regs.R23 = regs.R10;
		/* 8209F328h case   12:*/		return 0x8209F32C;
		  /* 8209F32Ch */ case   13:  		/* lis R29, -32215 */
		/* 8209F32Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8229);
		/* 8209F32Ch case   13:*/		return 0x8209F330;
		  /* 8209F330h */ case   14:  		/* cmplwi CR0, R11, 0 */
		/* 8209F330h case   14:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8209F330h case   14:*/		return 0x8209F334;
		  /* 8209F334h */ case   15:  		/* bc 4, CR0_EQ, 52 */
		/* 8209F334h case   15:*/		if ( !regs.CR[0].eq ) { return 0x8209F368;  }
		/* 8209F334h case   15:*/		return 0x8209F338;
		  /* 8209F338h */ case   16:  		/* lis R11, -32255 */
		/* 8209F338h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209F338h case   16:*/		return 0x8209F33C;
		  /* 8209F33Ch */ case   17:  		/* addi R3, R11, -14488 */
		/* 8209F33Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFC768);
		/* 8209F33Ch case   17:*/		return 0x8209F340;
		  /* 8209F340h */ case   18:  		/* bl 1868392 */
		/* 8209F340h case   18:*/		regs.LR = 0x8209F344; return 0x822675A8;
		/* 8209F340h case   18:*/		return 0x8209F344;
		  /* 8209F344h */ case   19:  		/* cmpwi CR6, R3, -1 */
		/* 8209F344h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8209F344h case   19:*/		return 0x8209F348;
		  /* 8209F348h */ case   20:  		/* bc 12, CR6_EQ, 24 */
		/* 8209F348h case   20:*/		if ( regs.CR[6].eq ) { return 0x8209F360;  }
		/* 8209F348h case   20:*/		return 0x8209F34C;
		  /* 8209F34Ch */ case   21:  		/* li R11, 1 */
		/* 8209F34Ch case   21:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8209F34Ch case   21:*/		return 0x8209F350;
		  /* 8209F350h */ case   22:  		/* lis R10, -32255 */
		/* 8209F350h case   22:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8209F350h case   22:*/		return 0x8209F354;
		  /* 8209F354h */ case   23:  		/* stb R11, <#[R29 - 30132]> */
		/* 8209F354h case   23:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R29 + 0xFFFF8A4C) );
		/* 8209F354h case   23:*/		return 0x8209F358;
		  /* 8209F358h */ case   24:  		/* addi R3, R10, -14576 */
		/* 8209F358h case   24:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xFFFFC710);
		/* 8209F358h case   24:*/		return 0x8209F35C;
		  /* 8209F35Ch */ case   25:  		/* bl -94212 */
		/* 8209F35Ch case   25:*/		regs.LR = 0x8209F360; return 0x82088358;
		/* 8209F35Ch case   25:*/		return 0x8209F360;
	}
	return 0x8209F360;
} // Block from 8209F2F8h-8209F360h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8209F360h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F360);
		  /* 8209F360h */ case    0:  		/* li R11, 1 */
		/* 8209F360h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8209F360h case    0:*/		return 0x8209F364;
		  /* 8209F364h */ case    1:  		/* stb R11, <#[R30 - 30131]> */
		/* 8209F364h case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0xFFFF8A4D) );
		/* 8209F364h case    1:*/		return 0x8209F368;
	}
	return 0x8209F368;
} // Block from 8209F360h-8209F368h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209F368h
// Function '_close'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F368);
		  /* 8209F368h */ case    0:  		/* mr R10, R23 */
		/* 8209F368h case    0:*/		regs.R10 = regs.R23;
		/* 8209F368h case    0:*/		return 0x8209F36C;
		  /* 8209F36Ch */ case    1:  		/* mr R9, R21 */
		/* 8209F36Ch case    1:*/		regs.R9 = regs.R21;
		/* 8209F36Ch case    1:*/		return 0x8209F370;
		  /* 8209F370h */ case    2:  		/* mr R8, R22 */
		/* 8209F370h case    2:*/		regs.R8 = regs.R22;
		/* 8209F370h case    2:*/		return 0x8209F374;
		  /* 8209F374h */ case    3:  		/* mr R7, R24 */
		/* 8209F374h case    3:*/		regs.R7 = regs.R24;
		/* 8209F374h case    3:*/		return 0x8209F378;
		  /* 8209F378h */ case    4:  		/* mr R6, R31 */
		/* 8209F378h case    4:*/		regs.R6 = regs.R31;
		/* 8209F378h case    4:*/		return 0x8209F37C;
		  /* 8209F37Ch */ case    5:  		/* mr R5, R25 */
		/* 8209F37Ch case    5:*/		regs.R5 = regs.R25;
		/* 8209F37Ch case    5:*/		return 0x8209F380;
		  /* 8209F380h */ case    6:  		/* mr R4, R27 */
		/* 8209F380h case    6:*/		regs.R4 = regs.R27;
		/* 8209F380h case    6:*/		return 0x8209F384;
		  /* 8209F384h */ case    7:  		/* mr R3, R28 */
		/* 8209F384h case    7:*/		regs.R3 = regs.R28;
		/* 8209F384h case    7:*/		return 0x8209F388;
		  /* 8209F388h */ case    8:  		/* bl -944 */
		/* 8209F388h case    8:*/		regs.LR = 0x8209F38C; return 0x8209EFD8;
		/* 8209F388h case    8:*/		return 0x8209F38C;
		  /* 8209F38Ch */ case    9:  		/* or. R20, R3, R3 */
		/* 8209F38Ch case    9:*/		cpu::op::or<1>(regs,&regs.R20,regs.R3,regs.R3);
		/* 8209F38Ch case    9:*/		return 0x8209F390;
		  /* 8209F390h */ case   10:  		/* bc 12, CR0_LT, 1056 */
		/* 8209F390h case   10:*/		if ( regs.CR[0].lt ) { return 0x8209F7B0;  }
		/* 8209F390h case   10:*/		return 0x8209F394;
		  /* 8209F394h */ case   11:  		/* lbz R11, <#[R29 - 30132]> */
		/* 8209F394h case   11:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0xFFFF8A4C) );
		/* 8209F394h case   11:*/		return 0x8209F398;
		  /* 8209F398h */ case   12:  		/* cmplwi CR0, R11, 0 */
		/* 8209F398h case   12:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8209F398h case   12:*/		return 0x8209F39C;
		  /* 8209F39Ch */ case   13:  		/* bc 12, CR0_EQ, 1044 */
		/* 8209F39Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x8209F7B0;  }
		/* 8209F39Ch case   13:*/		return 0x8209F3A0;
		  /* 8209F3A0h */ case   14:  		/* rlwinm. R11, R31, 0, 6, 6 */
		/* 8209F3A0h case   14:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R11,regs.R31);
		/* 8209F3A0h case   14:*/		return 0x8209F3A4;
		  /* 8209F3A4h */ case   15:  		/* bc 4, CR0_EQ, 1036 */
		/* 8209F3A4h case   15:*/		if ( !regs.CR[0].eq ) { return 0x8209F7B0;  }
		/* 8209F3A4h case   15:*/		return 0x8209F3A8;
		  /* 8209F3A8h */ case   16:  		/* rlwinm. R11, R31, 0, 11, 11 */
		/* 8209F3A8h case   16:*/		cpu::op::rlwinm<1,0,11,11>(regs,&regs.R11,regs.R31);
		/* 8209F3A8h case   16:*/		return 0x8209F3AC;
		  /* 8209F3ACh */ case   17:  		/* bc 4, CR0_EQ, 1028 */
		/* 8209F3ACh case   17:*/		if ( !regs.CR[0].eq ) { return 0x8209F7B0;  }
		/* 8209F3ACh case   17:*/		return 0x8209F3B0;
		  /* 8209F3B0h */ case   18:  		/* cmplwi CR6, R24, 0 */
		/* 8209F3B0h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 8209F3B0h case   18:*/		return 0x8209F3B4;
		  /* 8209F3B4h */ case   19:  		/* bc 12, CR6_EQ, 1020 */
		/* 8209F3B4h case   19:*/		if ( regs.CR[6].eq ) { return 0x8209F7B0;  }
		/* 8209F3B4h case   19:*/		return 0x8209F3B8;
		  /* 8209F3B8h */ case   20:  		/* lwz R11, <#[R24]> */
		/* 8209F3B8h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 8209F3B8h case   20:*/		return 0x8209F3BC;
		  /* 8209F3BCh */ case   21:  		/* cmplwi CR6, R11, 0 */
		/* 8209F3BCh case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209F3BCh case   21:*/		return 0x8209F3C0;
		  /* 8209F3C0h */ case   22:  		/* bc 12, CR6_EQ, 1008 */
		/* 8209F3C0h case   22:*/		if ( regs.CR[6].eq ) { return 0x8209F7B0;  }
		/* 8209F3C0h case   22:*/		return 0x8209F3C4;
		  /* 8209F3C4h */ case   23:  		/* lwz R11, <#[R25]> */
		/* 8209F3C4h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 8209F3C4h case   23:*/		return 0x8209F3C8;
		  /* 8209F3C8h */ case   24:  		/* li R29, 0 */
		/* 8209F3C8h case   24:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8209F3C8h case   24:*/		return 0x8209F3CC;
		  /* 8209F3CCh */ case   25:  		/* oris R6, R31, 16 */
		/* 8209F3CCh case   25:*/		cpu::op::oris<0>(regs,&regs.R6,regs.R31,0x10);
		/* 8209F3CCh case   25:*/		return 0x8209F3D0;
		  /* 8209F3D0h */ case   26:  		/* stw R29, <#[R1 + 112]> */
		/* 8209F3D0h case   26:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000070) );
		/* 8209F3D0h case   26:*/		return 0x8209F3D4;
		  /* 8209F3D4h */ case   27:  		/* oris R26, R31, 512 */
		/* 8209F3D4h case   27:*/		cpu::op::oris<0>(regs,&regs.R26,regs.R31,0x200);
		/* 8209F3D4h case   27:*/		return 0x8209F3D8;
		  /* 8209F3D8h */ case   28:  		/* stw R29, <#[R1 + 116]> */
		/* 8209F3D8h case   28:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000074) );
		/* 8209F3D8h case   28:*/		return 0x8209F3DC;
		  /* 8209F3DCh */ case   29:  		/* stw R29, <#[R1 + 120]> */
		/* 8209F3DCh case   29:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000078) );
		/* 8209F3DCh case   29:*/		return 0x8209F3E0;
		  /* 8209F3E0h */ case   30:  		/* lbz R11, <#[R11]> */
		/* 8209F3E0h case   30:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8209F3E0h case   30:*/		return 0x8209F3E4;
		  /* 8209F3E4h */ case   31:  		/* cmplwi CR6, R11, 118 */
		/* 8209F3E4h case   31:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000076);
		/* 8209F3E4h case   31:*/		return 0x8209F3E8;
		  /* 8209F3E8h */ case   32:  		/* stw R29, <#[R1 + 124]> */
		/* 8209F3E8h case   32:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x0000007C) );
		/* 8209F3E8h case   32:*/		return 0x8209F3EC;
		  /* 8209F3ECh */ case   33:  		/* bc 4, CR6_EQ, 16 */
		/* 8209F3ECh case   33:*/		if ( !regs.CR[6].eq ) { return 0x8209F3FC;  }
		/* 8209F3ECh case   33:*/		return 0x8209F3F0;
		  /* 8209F3F0h */ case   34:  		/* lis R11, -32255 */
		/* 8209F3F0h case   34:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209F3F0h case   34:*/		return 0x8209F3F4;
		  /* 8209F3F4h */ case   35:  		/* addi R11, R11, -15728 */
		/* 8209F3F4h case   35:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFC290);
		/* 8209F3F4h case   35:*/		return 0x8209F3F8;
		  /* 8209F3F8h */ case   36:  		/* b 12 */
		/* 8209F3F8h case   36:*/		return 0x8209F404;
		/* 8209F3F8h case   36:*/		return 0x8209F3FC;
	}
	return 0x8209F3FC;
} // Block from 8209F368h-8209F3FCh (37 instructions)

//////////////////////////////////////////////////////
// Block at 8209F3FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F3FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F3FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F3FC);
		  /* 8209F3FCh */ case    0:  		/* lis R11, -32255 */
		/* 8209F3FCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209F3FCh case    0:*/		return 0x8209F400;
		  /* 8209F400h */ case    1:  		/* addi R11, R11, -15568 */
		/* 8209F400h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFC330);
		/* 8209F400h case    1:*/		return 0x8209F404;
	}
	return 0x8209F404;
} // Block from 8209F3FCh-8209F404h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209F404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F404);
		  /* 8209F404h */ case    0:  		/* stw R11, <#[R1 + 132]> */
		/* 8209F404h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 8209F404h case    0:*/		return 0x8209F408;
		  /* 8209F408h */ case    1:  		/* mr R10, R23 */
		/* 8209F408h case    1:*/		regs.R10 = regs.R23;
		/* 8209F408h case    1:*/		return 0x8209F40C;
		  /* 8209F40Ch */ case    2:  		/* addi R9, R1, 124 */
		/* 8209F40Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x7C);
		/* 8209F40Ch case    2:*/		return 0x8209F410;
		  /* 8209F410h */ case    3:  		/* addi R8, R1, 116 */
		/* 8209F410h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x74);
		/* 8209F410h case    3:*/		return 0x8209F414;
		  /* 8209F414h */ case    4:  		/* addi R7, R1, 120 */
		/* 8209F414h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x78);
		/* 8209F414h case    4:*/		return 0x8209F418;
		  /* 8209F418h */ case    5:  		/* addi R5, R1, 132 */
		/* 8209F418h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x84);
		/* 8209F418h case    5:*/		return 0x8209F41C;
		  /* 8209F41Ch */ case    6:  		/* mr R4, R27 */
		/* 8209F41Ch case    6:*/		regs.R4 = regs.R27;
		/* 8209F41Ch case    6:*/		return 0x8209F420;
		  /* 8209F420h */ case    7:  		/* mr R3, R28 */
		/* 8209F420h case    7:*/		regs.R3 = regs.R28;
		/* 8209F420h case    7:*/		return 0x8209F424;
		  /* 8209F424h */ case    8:  		/* bl -1100 */
		/* 8209F424h case    8:*/		regs.LR = 0x8209F428; return 0x8209EFD8;
		/* 8209F424h case    8:*/		return 0x8209F428;
		  /* 8209F428h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 8209F428h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209F428h case    9:*/		return 0x8209F42C;
		  /* 8209F42Ch */ case   10:  		/* bc 4, CR0_LT, 24 */
		/* 8209F42Ch case   10:*/		if ( !regs.CR[0].lt ) { return 0x8209F444;  }
		/* 8209F42Ch case   10:*/		return 0x8209F430;
		  /* 8209F430h */ case   11:  		/* lwz R3, <#[R1 + 116]> */
		/* 8209F430h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000074) );
		/* 8209F430h case   11:*/		return 0x8209F434;
		  /* 8209F434h */ case   12:  		/* cmplwi CR6, R3, 0 */
		/* 8209F434h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209F434h case   12:*/		return 0x8209F438;
		  /* 8209F438h */ case   13:  		/* bc 12, CR6_EQ, 888 */
		/* 8209F438h case   13:*/		if ( regs.CR[6].eq ) { return 0x8209F7B0;  }
		/* 8209F438h case   13:*/		return 0x8209F43C;
		  /* 8209F43Ch */ case   14:  		/* lwz R11, <#[R3]> */
		/* 8209F43Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209F43Ch case   14:*/		return 0x8209F440;
		  /* 8209F440h */ case   15:  		/* b 868 */
		/* 8209F440h case   15:*/		return 0x8209F7A4;
		/* 8209F440h case   15:*/		return 0x8209F444;
	}
	return 0x8209F444;
} // Block from 8209F404h-8209F444h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8209F444h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F444( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F444) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F444);
		  /* 8209F444h */ case    0:  		/* addi R4, R1, 112 */
		/* 8209F444h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 8209F444h case    0:*/		return 0x8209F448;
		  /* 8209F448h */ case    1:  		/* lis R3, 1 */
		/* 8209F448h case    1:*/		cpu::op::lis<0>(regs,&regs.R3,0x1);
		/* 8209F448h case    1:*/		return 0x8209F44C;
		  /* 8209F44Ch */ case    2:  		/* bl 26260 */
		/* 8209F44Ch case    2:*/		regs.LR = 0x8209F450; return 0x820A5AE0;
		/* 8209F44Ch case    2:*/		return 0x8209F450;
		  /* 8209F450h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 8209F450h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209F450h case    3:*/		return 0x8209F454;
		  /* 8209F454h */ case    4:  		/* bc 4, CR0_LT, 72 */
		/* 8209F454h case    4:*/		if ( !regs.CR[0].lt ) { return 0x8209F49C;  }
		/* 8209F454h case    4:*/		return 0x8209F458;
		  /* 8209F458h */ case    5:  		/* lwz R3, <#[R1 + 116]> */
		/* 8209F458h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000074) );
		/* 8209F458h case    5:*/		return 0x8209F45C;
		  /* 8209F45Ch */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 8209F45Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209F45Ch case    6:*/		return 0x8209F460;
		  /* 8209F460h */ case    7:  		/* bc 12, CR6_EQ, 24 */
		/* 8209F460h case    7:*/		if ( regs.CR[6].eq ) { return 0x8209F478;  }
		/* 8209F460h case    7:*/		return 0x8209F464;
		  /* 8209F464h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 8209F464h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209F464h case    8:*/		return 0x8209F468;
		  /* 8209F468h */ case    9:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209F468h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F468h case    9:*/		return 0x8209F46C;
		  /* 8209F46Ch */ case   10:  		/* mtspr CTR, R11 */
		/* 8209F46Ch case   10:*/		regs.CTR = regs.R11;
		/* 8209F46Ch case   10:*/		return 0x8209F470;
		  /* 8209F470h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 8209F470h case   11:*/		if ( 1 ) { regs.LR = 0x8209F474; return (uint32)regs.CTR; }
		/* 8209F470h case   11:*/		return 0x8209F474;
		  /* 8209F474h */ case   12:  		/* stw R29, <#[R1 + 116]> */
		/* 8209F474h case   12:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000074) );
		/* 8209F474h case   12:*/		return 0x8209F478;
	}
	return 0x8209F478;
} // Block from 8209F444h-8209F478h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209F478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F478);
		  /* 8209F478h */ case    0:  		/* lwz R3, <#[R1 + 120]> */
		/* 8209F478h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000078) );
		/* 8209F478h case    0:*/		return 0x8209F47C;
		  /* 8209F47Ch */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8209F47Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209F47Ch case    1:*/		return 0x8209F480;
		  /* 8209F480h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 8209F480h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209F494;  }
		/* 8209F480h case    2:*/		return 0x8209F484;
		  /* 8209F484h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 8209F484h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209F484h case    3:*/		return 0x8209F488;
		  /* 8209F488h */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209F488h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F488h case    4:*/		return 0x8209F48C;
		  /* 8209F48Ch */ case    5:  		/* mtspr CTR, R11 */
		/* 8209F48Ch case    5:*/		regs.CTR = regs.R11;
		/* 8209F48Ch case    5:*/		return 0x8209F490;
		  /* 8209F490h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 8209F490h case    6:*/		if ( 1 ) { regs.LR = 0x8209F494; return (uint32)regs.CTR; }
		/* 8209F490h case    6:*/		return 0x8209F494;
	}
	return 0x8209F494;
} // Block from 8209F478h-8209F494h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209F494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F494);
		  /* 8209F494h */ case    0:  		/* lwz R3, <#[R1 + 124]> */
		/* 8209F494h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000007C) );
		/* 8209F494h case    0:*/		return 0x8209F498;
		  /* 8209F498h */ case    1:  		/* b -100 */
		/* 8209F498h case    1:*/		return 0x8209F434;
		/* 8209F498h case    1:*/		return 0x8209F49C;
	}
	return 0x8209F49C;
} // Block from 8209F494h-8209F49Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209F49Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F49C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F49C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F49C);
		  /* 8209F49Ch */ case    0:  		/* stw R29, <#[R1 + 128]> */
		/* 8209F49Ch case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000080) );
		/* 8209F49Ch case    0:*/		return 0x8209F4A0;
		  /* 8209F4A0h */ case    1:  		/* lwz R3, <#[R1 + 112]> */
		/* 8209F4A0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000070) );
		/* 8209F4A0h case    1:*/		return 0x8209F4A4;
		  /* 8209F4A4h */ case    2:  		/* lwz R11, <#[R3]> */
		/* 8209F4A4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209F4A4h case    2:*/		return 0x8209F4A8;
		  /* 8209F4A8h */ case    3:  		/* lwz R11, <#[R11 + 16]> */
		/* 8209F4A8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 8209F4A8h case    3:*/		return 0x8209F4AC;
		  /* 8209F4ACh */ case    4:  		/* mtspr CTR, R11 */
		/* 8209F4ACh case    4:*/		regs.CTR = regs.R11;
		/* 8209F4ACh case    4:*/		return 0x8209F4B0;
		  /* 8209F4B0h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 8209F4B0h case    5:*/		if ( 1 ) { regs.LR = 0x8209F4B4; return (uint32)regs.CTR; }
		/* 8209F4B0h case    5:*/		return 0x8209F4B4;
		  /* 8209F4B4h */ case    6:  		/* lwz R11, <#[R1 + 112]> */
		/* 8209F4B4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 8209F4B4h case    6:*/		return 0x8209F4B8;
		  /* 8209F4B8h */ case    7:  		/* lwz R10, <#[R11]> */
		/* 8209F4B8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209F4B8h case    7:*/		return 0x8209F4BC;
		  /* 8209F4BCh */ case    8:  		/* mr R31, R3 */
		/* 8209F4BCh case    8:*/		regs.R31 = regs.R3;
		/* 8209F4BCh case    8:*/		return 0x8209F4C0;
		  /* 8209F4C0h */ case    9:  		/* mr R3, R11 */
		/* 8209F4C0h case    9:*/		regs.R3 = regs.R11;
		/* 8209F4C0h case    9:*/		return 0x8209F4C4;
		  /* 8209F4C4h */ case   10:  		/* lwz R11, <#[R10 + 12]> */
		/* 8209F4C4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 8209F4C4h case   10:*/		return 0x8209F4C8;
	}
	return 0x8209F4C8;
} // Block from 8209F49Ch-8209F4C8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209F4C8h
// Function '_freebuf'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F4C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F4C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F4C8);
		  /* 8209F4C8h */ case    0:  		/* mtspr CTR, R11 */
		/* 8209F4C8h case    0:*/		regs.CTR = regs.R11;
		/* 8209F4C8h case    0:*/		return 0x8209F4CC;
		  /* 8209F4CCh */ case    1:  		/* bcctrl 20, CR0_LT */
		/* 8209F4CCh case    1:*/		if ( 1 ) { regs.LR = 0x8209F4D0; return (uint32)regs.CTR; }
		/* 8209F4CCh case    1:*/		return 0x8209F4D0;
		  /* 8209F4D0h */ case    2:  		/* li R4, 0 */
		/* 8209F4D0h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8209F4D0h case    2:*/		return 0x8209F4D4;
		  /* 8209F4D4h */ case    3:  		/* mr R5, R31 */
		/* 8209F4D4h case    3:*/		regs.R5 = regs.R31;
		/* 8209F4D4h case    3:*/		return 0x8209F4D8;
		  /* 8209F4D8h */ case    4:  		/* bl -57752 */
		/* 8209F4D8h case    4:*/		regs.LR = 0x8209F4DC; return 0x82091340;
		/* 8209F4D8h case    4:*/		return 0x8209F4DC;
		  /* 8209F4DCh */ case    5:  		/* cmplwi CR6, R23, 0 */
		/* 8209F4DCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 8209F4DCh case    5:*/		return 0x8209F4E0;
		  /* 8209F4E0h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 8209F4E0h case    6:*/		if ( regs.CR[6].eq ) { return 0x8209F4EC;  }
		/* 8209F4E0h case    6:*/		return 0x8209F4E4;
		  /* 8209F4E4h */ case    7:  		/* lwz R30, <#[R23 + 16]> */
		/* 8209F4E4h case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R23 + 0x00000010) );
		/* 8209F4E4h case    7:*/		return 0x8209F4E8;
		  /* 8209F4E8h */ case    8:  		/* b 8 */
		/* 8209F4E8h case    8:*/		return 0x8209F4F0;
		/* 8209F4E8h case    8:*/		return 0x8209F4EC;
	}
	return 0x8209F4EC;
} // Block from 8209F4C8h-8209F4ECh (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209F4ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F4EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F4EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F4EC);
		  /* 8209F4ECh */ case    0:  		/* mr R30, R29 */
		/* 8209F4ECh case    0:*/		regs.R30 = regs.R29;
		/* 8209F4ECh case    0:*/		return 0x8209F4F0;
	}
	return 0x8209F4F0;
} // Block from 8209F4ECh-8209F4F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209F4F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F4F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F4F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F4F0);
		  /* 8209F4F0h */ case    0:  		/* lwz R3, <#[R1 + 112]> */
		/* 8209F4F0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000070) );
		/* 8209F4F0h case    0:*/		return 0x8209F4F4;
		  /* 8209F4F4h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 8209F4F4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209F4F4h case    1:*/		return 0x8209F4F8;
		  /* 8209F4F8h */ case    2:  		/* lwz R11, <#[R11 + 16]> */
		/* 8209F4F8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 8209F4F8h case    2:*/		return 0x8209F4FC;
		  /* 8209F4FCh */ case    3:  		/* mtspr CTR, R11 */
		/* 8209F4FCh case    3:*/		regs.CTR = regs.R11;
		/* 8209F4FCh case    3:*/		return 0x8209F500;
		  /* 8209F500h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8209F500h case    4:*/		if ( 1 ) { regs.LR = 0x8209F504; return (uint32)regs.CTR; }
		/* 8209F500h case    4:*/		return 0x8209F504;
		  /* 8209F504h */ case    5:  		/* lwz R11, <#[R1 + 112]> */
		/* 8209F504h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 8209F504h case    5:*/		return 0x8209F508;
		  /* 8209F508h */ case    6:  		/* mr R27, R3 */
		/* 8209F508h case    6:*/		regs.R27 = regs.R3;
		/* 8209F508h case    6:*/		return 0x8209F50C;
		  /* 8209F50Ch */ case    7:  		/* mr R3, R11 */
		/* 8209F50Ch case    7:*/		regs.R3 = regs.R11;
		/* 8209F50Ch case    7:*/		return 0x8209F510;
		  /* 8209F510h */ case    8:  		/* lwz R10, <#[R11]> */
		/* 8209F510h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209F510h case    8:*/		return 0x8209F514;
		  /* 8209F514h */ case    9:  		/* lwz R11, <#[R10 + 12]> */
		/* 8209F514h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 8209F514h case    9:*/		return 0x8209F518;
		  /* 8209F518h */ case   10:  		/* mtspr CTR, R11 */
		/* 8209F518h case   10:*/		regs.CTR = regs.R11;
		/* 8209F518h case   10:*/		return 0x8209F51C;
		  /* 8209F51Ch */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 8209F51Ch case   11:*/		if ( 1 ) { regs.LR = 0x8209F520; return (uint32)regs.CTR; }
		/* 8209F51Ch case   11:*/		return 0x8209F520;
		  /* 8209F520h */ case   12:  		/* lwz R31, <#[R1 + 120]> */
		/* 8209F520h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000078) );
		/* 8209F520h case   12:*/		return 0x8209F524;
		  /* 8209F524h */ case   13:  		/* mr R19, R3 */
		/* 8209F524h case   13:*/		regs.R19 = regs.R3;
		/* 8209F524h case   13:*/		return 0x8209F528;
		  /* 8209F528h */ case   14:  		/* mr R3, R31 */
		/* 8209F528h case   14:*/		regs.R3 = regs.R31;
		/* 8209F528h case   14:*/		return 0x8209F52C;
		  /* 8209F52Ch */ case   15:  		/* lwz R11, <#[R31]> */
		/* 8209F52Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209F52Ch case   15:*/		return 0x8209F530;
	}
	return 0x8209F530;
} // Block from 8209F4F0h-8209F530h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8209F530h
// Function '??0logic_error@std@@QAA@PBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F530);
		  /* 8209F530h */ case    0:  		/* lwz R11, <#[R11 + 16]> */
		/* 8209F530h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 8209F530h case    0:*/		return 0x8209F534;
		  /* 8209F534h */ case    1:  		/* mtspr CTR, R11 */
		/* 8209F534h case    1:*/		regs.CTR = regs.R11;
		/* 8209F534h case    1:*/		return 0x8209F538;
		  /* 8209F538h */ case    2:  		/* bcctrl 20, CR0_LT */
		/* 8209F538h case    2:*/		if ( 1 ) { regs.LR = 0x8209F53C; return (uint32)regs.CTR; }
		/* 8209F538h case    2:*/		return 0x8209F53C;
		  /* 8209F53Ch */ case    3:  		/* lwz R11, <#[R31]> */
		/* 8209F53Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209F53Ch case    3:*/		return 0x8209F540;
		  /* 8209F540h */ case    4:  		/* mr R18, R3 */
		/* 8209F540h case    4:*/		regs.R18 = regs.R3;
		/* 8209F540h case    4:*/		return 0x8209F544;
		  /* 8209F544h */ case    5:  		/* mr R3, R31 */
		/* 8209F544h case    5:*/		regs.R3 = regs.R31;
		/* 8209F544h case    5:*/		return 0x8209F548;
		  /* 8209F548h */ case    6:  		/* lwz R11, <#[R11 + 12]> */
		/* 8209F548h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8209F548h case    6:*/		return 0x8209F54C;
		  /* 8209F54Ch */ case    7:  		/* mtspr CTR, R11 */
		/* 8209F54Ch case    7:*/		regs.CTR = regs.R11;
		/* 8209F54Ch case    7:*/		return 0x8209F550;
		  /* 8209F550h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 8209F550h case    8:*/		if ( 1 ) { regs.LR = 0x8209F554; return (uint32)regs.CTR; }
		/* 8209F550h case    8:*/		return 0x8209F554;
		  /* 8209F554h */ case    9:  		/* lwz R28, <#[R1 + 124]> */
		/* 8209F554h case    9:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x0000007C) );
		/* 8209F554h case    9:*/		return 0x8209F558;
		  /* 8209F558h */ case   10:  		/* lis R11, -32222 */
		/* 8209F558h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8209F558h case   10:*/		return 0x8209F55C;
		  /* 8209F55Ch */ case   11:  		/* mr R4, R18 */
		/* 8209F55Ch case   11:*/		regs.R4 = regs.R18;
		/* 8209F55Ch case   11:*/		return 0x8209F560;
		  /* 8209F560h */ case   12:  		/* stw R30, <#[R1 + 100]> */
		/* 8209F560h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000064) );
		/* 8209F560h case   12:*/		return 0x8209F564;
		  /* 8209F564h */ case   13:  		/* mr R5, R19 */
		/* 8209F564h case   13:*/		regs.R5 = regs.R19;
		/* 8209F564h case   13:*/		return 0x8209F568;
		  /* 8209F568h */ case   14:  		/* stw R29, <#[R1 + 92]> */
		/* 8209F568h case   14:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x0000005C) );
		/* 8209F568h case   14:*/		return 0x8209F56C;
		  /* 8209F56Ch */ case   15:  		/* mr R6, R27 */
		/* 8209F56Ch case   15:*/		regs.R6 = regs.R27;
		/* 8209F56Ch case   15:*/		return 0x8209F570;
		  /* 8209F570h */ case   16:  		/* addi R7, R1, 128 */
		/* 8209F570h case   16:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x80);
		/* 8209F570h case   16:*/		return 0x8209F574;
		  /* 8209F574h */ case   17:  		/* mr R8, R26 */
		/* 8209F574h case   17:*/		regs.R8 = regs.R26;
		/* 8209F574h case   17:*/		return 0x8209F578;
		  /* 8209F578h */ case   18:  		/* stw R28, <#[R1 + 84]> */
		/* 8209F578h case   18:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 8209F578h case   18:*/		return 0x8209F57C;
		  /* 8209F57Ch */ case   19:  		/* li R9, 0 */
		/* 8209F57Ch case   19:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8209F57Ch case   19:*/		return 0x8209F580;
		  /* 8209F580h */ case   20:  		/* addi R10, R11, -11328 */
		/* 8209F580h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFD3C0);
		/* 8209F580h case   20:*/		return 0x8209F584;
		  /* 8209F584h */ case   21:  		/* bl 723556 */
		/* 8209F584h case   21:*/		regs.LR = 0x8209F588; return 0x8214FFE8;
		/* 8209F584h case   21:*/		return 0x8209F588;
	}
	return 0x8209F588;
} // Block from 8209F530h-8209F588h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8209F588h
// Function '??1length_error@std@@UAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F588( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F588) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F588);
		  /* 8209F588h */ case    0:  		/* cmpwi CR0, R3, 0 */
		/* 8209F588h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8209F588h case    0:*/		return 0x8209F58C;
		  /* 8209F58Ch */ case    1:  		/* bc 4, CR0_LT, 92 */
		/* 8209F58Ch case    1:*/		if ( !regs.CR[0].lt ) { return 0x8209F5E8;  }
		/* 8209F58Ch case    1:*/		return 0x8209F590;
	}
	return 0x8209F590;
} // Block from 8209F588h-8209F590h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209F590h
// Function '?_Xlength_error@std@@YAXPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F590( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F590) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F590);
		  /* 8209F590h */ case    0:  		/* lwz R3, <#[R1 + 116]> */
		/* 8209F590h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000074) );
		/* 8209F590h case    0:*/		return 0x8209F594;
		  /* 8209F594h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8209F594h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209F594h case    1:*/		return 0x8209F598;
		  /* 8209F598h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 8209F598h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209F5B0;  }
		/* 8209F598h case    2:*/		return 0x8209F59C;
		  /* 8209F59Ch */ case    3:  		/* lwz R11, <#[R3]> */
		/* 8209F59Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209F59Ch case    3:*/		return 0x8209F5A0;
		  /* 8209F5A0h */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209F5A0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F5A0h case    4:*/		return 0x8209F5A4;
		  /* 8209F5A4h */ case    5:  		/* mtspr CTR, R11 */
		/* 8209F5A4h case    5:*/		regs.CTR = regs.R11;
		/* 8209F5A4h case    5:*/		return 0x8209F5A8;
		  /* 8209F5A8h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 8209F5A8h case    6:*/		if ( 1 ) { regs.LR = 0x8209F5AC; return (uint32)regs.CTR; }
		/* 8209F5A8h case    6:*/		return 0x8209F5AC;
		  /* 8209F5ACh */ case    7:  		/* stw R29, <#[R1 + 116]> */
		/* 8209F5ACh case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000074) );
		/* 8209F5ACh case    7:*/		return 0x8209F5B0;
	}
	return 0x8209F5B0;
} // Block from 8209F590h-8209F5B0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209F5B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F5B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F5B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F5B0);
		  /* 8209F5B0h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8209F5B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209F5B0h case    0:*/		return 0x8209F5B4;
		  /* 8209F5B4h */ case    1:  		/* mr R3, R31 */
		/* 8209F5B4h case    1:*/		regs.R3 = regs.R31;
		/* 8209F5B4h case    1:*/		return 0x8209F5B8;
		  /* 8209F5B8h */ case    2:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209F5B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F5B8h case    2:*/		return 0x8209F5BC;
		  /* 8209F5BCh */ case    3:  		/* mtspr CTR, R11 */
		/* 8209F5BCh case    3:*/		regs.CTR = regs.R11;
		/* 8209F5BCh case    3:*/		return 0x8209F5C0;
		  /* 8209F5C0h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8209F5C0h case    4:*/		if ( 1 ) { regs.LR = 0x8209F5C4; return (uint32)regs.CTR; }
		/* 8209F5C0h case    4:*/		return 0x8209F5C4;
		  /* 8209F5C4h */ case    5:  		/* cmplwi CR6, R28, 0 */
		/* 8209F5C4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8209F5C4h case    5:*/		return 0x8209F5C8;
	}
	return 0x8209F5C8;
} // Block from 8209F5B0h-8209F5C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209F5C8h
// Function '??_Elogic_error@std@@UAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F5C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F5C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F5C8);
		  /* 8209F5C8h */ case    0:  		/* bc 12, CR6_EQ, 24 */
		/* 8209F5C8h case    0:*/		if ( regs.CR[6].eq ) { return 0x8209F5E0;  }
		/* 8209F5C8h case    0:*/		return 0x8209F5CC;
		  /* 8209F5CCh */ case    1:  		/* lwz R11, <#[R28]> */
		/* 8209F5CCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8209F5CCh case    1:*/		return 0x8209F5D0;
		  /* 8209F5D0h */ case    2:  		/* mr R3, R28 */
		/* 8209F5D0h case    2:*/		regs.R3 = regs.R28;
		/* 8209F5D0h case    2:*/		return 0x8209F5D4;
		  /* 8209F5D4h */ case    3:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209F5D4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F5D4h case    3:*/		return 0x8209F5D8;
		  /* 8209F5D8h */ case    4:  		/* mtspr CTR, R11 */
		/* 8209F5D8h case    4:*/		regs.CTR = regs.R11;
		/* 8209F5D8h case    4:*/		return 0x8209F5DC;
		  /* 8209F5DCh */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 8209F5DCh case    5:*/		if ( 1 ) { regs.LR = 0x8209F5E0; return (uint32)regs.CTR; }
		/* 8209F5DCh case    5:*/		return 0x8209F5E0;
	}
	return 0x8209F5E0;
} // Block from 8209F5C8h-8209F5E0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209F5E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F5E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F5E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F5E0);
		  /* 8209F5E0h */ case    0:  		/* lwz R3, <#[R1 + 112]> */
		/* 8209F5E0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000070) );
		/* 8209F5E0h case    0:*/		return 0x8209F5E4;
		  /* 8209F5E4h */ case    1:  		/* b -432 */
		/* 8209F5E4h case    1:*/		return 0x8209F434;
		/* 8209F5E4h case    1:*/		return 0x8209F5E8;
	}
	return 0x8209F5E8;
} // Block from 8209F5E0h-8209F5E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209F5E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F5E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F5E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F5E8);
		  /* 8209F5E8h */ case    0:  		/* lwz R11, <#[R25]> */
		/* 8209F5E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 8209F5E8h case    0:*/		return 0x8209F5EC;
		  /* 8209F5ECh */ case    1:  		/* li R7, 0 */
		/* 8209F5ECh case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8209F5ECh case    1:*/		return 0x8209F5F0;
		  /* 8209F5F0h */ case    2:  		/* lwz R3, <#[R24]> */
		/* 8209F5F0h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000000) );
		/* 8209F5F0h case    2:*/		return 0x8209F5F4;
		  /* 8209F5F4h */ case    3:  		/* li R6, 0 */
		/* 8209F5F4h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8209F5F4h case    3:*/		return 0x8209F5F8;
		  /* 8209F5F8h */ case    4:  		/* li R5, 0 */
		/* 8209F5F8h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8209F5F8h case    4:*/		return 0x8209F5FC;
		  /* 8209F5FCh */ case    5:  		/* mr R4, R31 */
		/* 8209F5FCh case    5:*/		regs.R4 = regs.R31;
		/* 8209F5FCh case    5:*/		return 0x8209F600;
		  /* 8209F600h */ case    6:  		/* lbz R11, <#[R11]> */
		/* 8209F600h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8209F600h case    6:*/		return 0x8209F604;
		  /* 8209F604h */ case    7:  		/* cmplwi CR6, R11, 118 */
		/* 8209F604h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000076);
		/* 8209F604h case    7:*/		return 0x8209F608;
		  /* 8209F608h */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 8209F608h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8209F614;  }
		/* 8209F608h case    8:*/		return 0x8209F60C;
		  /* 8209F60Ch */ case    9:  		/* bl 706284 */
		/* 8209F60Ch case    9:*/		regs.LR = 0x8209F610; return 0x8214BCF8;
		/* 8209F60Ch case    9:*/		return 0x8209F610;
		  /* 8209F610h */ case   10:  		/* b 8 */
		/* 8209F610h case   10:*/		return 0x8209F618;
		/* 8209F610h case   10:*/		return 0x8209F614;
	}
	return 0x8209F614;
} // Block from 8209F5E8h-8209F614h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209F614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F614);
		  /* 8209F614h */ case    0:  		/* bl 706276 */
		/* 8209F614h case    0:*/		regs.LR = 0x8209F618; return 0x8214BCF8;
		/* 8209F614h case    0:*/		return 0x8209F618;
	}
	return 0x8209F618;
} // Block from 8209F614h-8209F618h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209F618h
// Function '??0logic_error@std@@QAA@ABV01@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F618);
		  /* 8209F618h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 8209F618h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8209F618h case    0:*/		return 0x8209F61C;
		  /* 8209F61Ch */ case    1:  		/* bc 4, CR6_EQ, 300 */
		/* 8209F61Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209F748;  }
		/* 8209F61Ch case    1:*/		return 0x8209F620;
		  /* 8209F620h */ case    2:  		/* lis R11, -32255 */
		/* 8209F620h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209F620h case    2:*/		return 0x8209F624;
		  /* 8209F624h */ case    3:  		/* addi R3, R11, -14712 */
		/* 8209F624h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFC688);
		/* 8209F624h case    3:*/		return 0x8209F628;
		  /* 8209F628h */ case    4:  		/* bl -94928 */
		/* 8209F628h case    4:*/		regs.LR = 0x8209F62C; return 0x82088358;
		/* 8209F628h case    4:*/		return 0x8209F62C;
		  /* 8209F62Ch */ case    5:  		/* stw R29, <#[R1 + 124]> */
		/* 8209F62Ch case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x0000007C) );
		/* 8209F62Ch case    5:*/		return 0x8209F630;
		  /* 8209F630h */ case    6:  		/* addi R4, R1, 124 */
		/* 8209F630h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x7C);
		/* 8209F630h case    6:*/		return 0x8209F634;
		  /* 8209F634h */ case    7:  		/* lwz R3, <#[R1 + 128]> */
		/* 8209F634h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000080) );
		/* 8209F634h case    7:*/		return 0x8209F638;
		  /* 8209F638h */ case    8:  		/* bl 25768 */
		/* 8209F638h case    8:*/		regs.LR = 0x8209F63C; return 0x820A5AE0;
		/* 8209F638h case    8:*/		return 0x8209F63C;
		  /* 8209F63Ch */ case    9:  		/* or. R20, R3, R3 */
		/* 8209F63Ch case    9:*/		cpu::op::or<1>(regs,&regs.R20,regs.R3,regs.R3);
		/* 8209F63Ch case    9:*/		return 0x8209F640;
		  /* 8209F640h */ case   10:  		/* bc 12, CR0_LT, -176 */
		/* 8209F640h case   10:*/		if ( regs.CR[0].lt ) { return 0x8209F590;  }
		/* 8209F640h case   10:*/		return 0x8209F644;
		  /* 8209F644h */ case   11:  		/* lwz R3, <#[R1 + 112]> */
		/* 8209F644h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000070) );
		/* 8209F644h case   11:*/		return 0x8209F648;
		  /* 8209F648h */ case   12:  		/* lwz R30, <#[R1 + 128]> */
		/* 8209F648h case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000080) );
		/* 8209F648h case   12:*/		return 0x8209F64C;
		  /* 8209F64Ch */ case   13:  		/* lwz R11, <#[R3]> */
		/* 8209F64Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209F64Ch case   13:*/		return 0x8209F650;
		  /* 8209F650h */ case   14:  		/* lwz R11, <#[R11 + 12]> */
		/* 8209F650h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8209F650h case   14:*/		return 0x8209F654;
		  /* 8209F654h */ case   15:  		/* mtspr CTR, R11 */
		/* 8209F654h case   15:*/		regs.CTR = regs.R11;
		/* 8209F654h case   15:*/		return 0x8209F658;
		  /* 8209F658h */ case   16:  		/* bcctrl 20, CR0_LT */
		/* 8209F658h case   16:*/		if ( 1 ) { regs.LR = 0x8209F65C; return (uint32)regs.CTR; }
		/* 8209F658h case   16:*/		return 0x8209F65C;
		  /* 8209F65Ch */ case   17:  		/* lwz R11, <#[R1 + 124]> */
		/* 8209F65Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000007C) );
		/* 8209F65Ch case   17:*/		return 0x8209F660;
		  /* 8209F660h */ case   18:  		/* mr R27, R3 */
		/* 8209F660h case   18:*/		regs.R27 = regs.R3;
		/* 8209F660h case   18:*/		return 0x8209F664;
		  /* 8209F664h */ case   19:  		/* mr R3, R11 */
		/* 8209F664h case   19:*/		regs.R3 = regs.R11;
		/* 8209F664h case   19:*/		return 0x8209F668;
		  /* 8209F668h */ case   20:  		/* lwz R10, <#[R11]> */
		/* 8209F668h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209F668h case   20:*/		return 0x8209F66C;
		  /* 8209F66Ch */ case   21:  		/* lwz R11, <#[R10 + 12]> */
		/* 8209F66Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 8209F66Ch case   21:*/		return 0x8209F670;
	}
	return 0x8209F670;
} // Block from 8209F618h-8209F670h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8209F670h
// Function '??0length_error@std@@QAA@ABV01@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F670);
		  /* 8209F670h */ case    0:  		/* mtspr CTR, R11 */
		/* 8209F670h case    0:*/		regs.CTR = regs.R11;
		/* 8209F670h case    0:*/		return 0x8209F674;
		  /* 8209F674h */ case    1:  		/* bcctrl 20, CR0_LT */
		/* 8209F674h case    1:*/		if ( 1 ) { regs.LR = 0x8209F678; return (uint32)regs.CTR; }
		/* 8209F674h case    1:*/		return 0x8209F678;
		  /* 8209F678h */ case    2:  		/* mr R4, R27 */
		/* 8209F678h case    2:*/		regs.R4 = regs.R27;
		/* 8209F678h case    2:*/		return 0x8209F67C;
		  /* 8209F67Ch */ case    3:  		/* mr R5, R30 */
		/* 8209F67Ch case    3:*/		regs.R5 = regs.R30;
		/* 8209F67Ch case    3:*/		return 0x8209F680;
		  /* 8209F680h */ case    4:  		/* bl -56528 */
		/* 8209F680h case    4:*/		regs.LR = 0x8209F684; return 0x820919B0;
		/* 8209F680h case    4:*/		return 0x8209F684;
		  /* 8209F684h */ case    5:  		/* lwz R3, <#[R1 + 112]> */
		/* 8209F684h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000070) );
		/* 8209F684h case    5:*/		return 0x8209F688;
		  /* 8209F688h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 8209F688h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209F688h case    6:*/		return 0x8209F68C;
		  /* 8209F68Ch */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 8209F68Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x8209F6A0;  }
		/* 8209F68Ch case    7:*/		return 0x8209F690;
		  /* 8209F690h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 8209F690h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209F690h case    8:*/		return 0x8209F694;
		  /* 8209F694h */ case    9:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209F694h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F694h case    9:*/		return 0x8209F698;
		  /* 8209F698h */ case   10:  		/* mtspr CTR, R11 */
		/* 8209F698h case   10:*/		regs.CTR = regs.R11;
		/* 8209F698h case   10:*/		return 0x8209F69C;
		  /* 8209F69Ch */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 8209F69Ch case   11:*/		if ( 1 ) { regs.LR = 0x8209F6A0; return (uint32)regs.CTR; }
		/* 8209F69Ch case   11:*/		return 0x8209F6A0;
	}
	return 0x8209F6A0;
} // Block from 8209F670h-8209F6A0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8209F6A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F6A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F6A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F6A0);
		  /* 8209F6A0h */ case    0:  		/* lwz R11, <#[R1 + 124]> */
		/* 8209F6A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000007C) );
		/* 8209F6A0h case    0:*/		return 0x8209F6A4;
		  /* 8209F6A4h */ case    1:  		/* mr R3, R31 */
		/* 8209F6A4h case    1:*/		regs.R3 = regs.R31;
		/* 8209F6A4h case    1:*/		return 0x8209F6A8;
		  /* 8209F6A8h */ case    2:  		/* stw R11, <#[R1 + 112]> */
		/* 8209F6A8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 8209F6A8h case    2:*/		return 0x8209F6AC;
		  /* 8209F6ACh */ case    3:  		/* lwz R11, <#[R31]> */
		/* 8209F6ACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209F6ACh case    3:*/		return 0x8209F6B0;
	}
	return 0x8209F6B0;
} // Block from 8209F6A0h-8209F6B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209F6B0h
// Function '??_EPreProcessorInitializeFromMemory@D3DXShader@@UAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F6B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F6B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F6B0);
		  /* 8209F6B0h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209F6B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F6B0h case    0:*/		return 0x8209F6B4;
		  /* 8209F6B4h */ case    1:  		/* mtspr CTR, R11 */
		/* 8209F6B4h case    1:*/		regs.CTR = regs.R11;
		/* 8209F6B4h case    1:*/		return 0x8209F6B8;
		  /* 8209F6B8h */ case    2:  		/* bcctrl 20, CR0_LT */
		/* 8209F6B8h case    2:*/		if ( 1 ) { regs.LR = 0x8209F6BC; return (uint32)regs.CTR; }
		/* 8209F6B8h case    2:*/		return 0x8209F6BC;
		  /* 8209F6BCh */ case    3:  		/* lwz R3, <#[R24]> */
		/* 8209F6BCh case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000000) );
		/* 8209F6BCh case    3:*/		return 0x8209F6C0;
		  /* 8209F6C0h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 8209F6C0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209F6C0h case    4:*/		return 0x8209F6C4;
		  /* 8209F6C4h */ case    5:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209F6C4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F6C4h case    5:*/		return 0x8209F6C8;
		  /* 8209F6C8h */ case    6:  		/* mtspr CTR, R11 */
		/* 8209F6C8h case    6:*/		regs.CTR = regs.R11;
		/* 8209F6C8h case    6:*/		return 0x8209F6CC;
		  /* 8209F6CCh */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 8209F6CCh case    7:*/		if ( 1 ) { regs.LR = 0x8209F6D0; return (uint32)regs.CTR; }
		/* 8209F6CCh case    7:*/		return 0x8209F6D0;
		  /* 8209F6D0h */ case    8:  		/* lwz R11, <#[R1 + 112]> */
		/* 8209F6D0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 8209F6D0h case    8:*/		return 0x8209F6D4;
		  /* 8209F6D4h */ case    9:  		/* stw R11, <#[R24]> */
		/* 8209F6D4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 8209F6D4h case    9:*/		return 0x8209F6D8;
		  /* 8209F6D8h */ case   10:  		/* lwz R3, <#[R22]> */
		/* 8209F6D8h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000000) );
		/* 8209F6D8h case   10:*/		return 0x8209F6DC;
		  /* 8209F6DCh */ case   11:  		/* cmplwi CR6, R3, 0 */
		/* 8209F6DCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209F6DCh case   11:*/		return 0x8209F6E0;
		  /* 8209F6E0h */ case   12:  		/* bc 12, CR6_EQ, 20 */
		/* 8209F6E0h case   12:*/		if ( regs.CR[6].eq ) { return 0x8209F6F4;  }
		/* 8209F6E0h case   12:*/		return 0x8209F6E4;
		  /* 8209F6E4h */ case   13:  		/* lwz R11, <#[R3]> */
		/* 8209F6E4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209F6E4h case   13:*/		return 0x8209F6E8;
		  /* 8209F6E8h */ case   14:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209F6E8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F6E8h case   14:*/		return 0x8209F6EC;
		  /* 8209F6ECh */ case   15:  		/* mtspr CTR, R11 */
		/* 8209F6ECh case   15:*/		regs.CTR = regs.R11;
		/* 8209F6ECh case   15:*/		return 0x8209F6F0;
		  /* 8209F6F0h */ case   16:  		/* bcctrl 20, CR0_LT */
		/* 8209F6F0h case   16:*/		if ( 1 ) { regs.LR = 0x8209F6F4; return (uint32)regs.CTR; }
		/* 8209F6F0h case   16:*/		return 0x8209F6F4;
	}
	return 0x8209F6F4;
} // Block from 8209F6B0h-8209F6F4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8209F6F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F6F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F6F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F6F4);
		  /* 8209F6F4h */ case    0:  		/* lwz R11, <#[R1 + 116]> */
		/* 8209F6F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 8209F6F4h case    0:*/		return 0x8209F6F8;
	}
	return 0x8209F6F8;
} // Block from 8209F6F4h-8209F6F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209F6F8h
// Function '?IsCpuTarget@D3DXShader@@YAHPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F6F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F6F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F6F8);
		  /* 8209F6F8h */ case    0:  		/* stw R11, <#[R22]> */
		/* 8209F6F8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 8209F6F8h case    0:*/		return 0x8209F6FC;
		  /* 8209F6FCh */ case    1:  		/* lwz R3, <#[R21]> */
		/* 8209F6FCh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R21 + 0x00000000) );
		/* 8209F6FCh case    1:*/		return 0x8209F700;
		  /* 8209F700h */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 8209F700h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209F700h case    2:*/		return 0x8209F704;
		  /* 8209F704h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 8209F704h case    3:*/		if ( regs.CR[6].eq ) { return 0x8209F718;  }
		/* 8209F704h case    3:*/		return 0x8209F708;
		  /* 8209F708h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 8209F708h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209F708h case    4:*/		return 0x8209F70C;
		  /* 8209F70Ch */ case    5:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209F70Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F70Ch case    5:*/		return 0x8209F710;
		  /* 8209F710h */ case    6:  		/* mtspr CTR, R11 */
		/* 8209F710h case    6:*/		regs.CTR = regs.R11;
		/* 8209F710h case    6:*/		return 0x8209F714;
		  /* 8209F714h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 8209F714h case    7:*/		if ( 1 ) { regs.LR = 0x8209F718; return (uint32)regs.CTR; }
		/* 8209F714h case    7:*/		return 0x8209F718;
	}
	return 0x8209F718;
} // Block from 8209F6F8h-8209F718h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209F718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F718);
		  /* 8209F718h */ case    0:  		/* stw R28, <#[R21]> */
		/* 8209F718h case    0:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R21 + 0x00000000) );
		/* 8209F718h case    0:*/		return 0x8209F71C;
		  /* 8209F71Ch */ case    1:  		/* cmplwi CR6, R23, 0 */
		/* 8209F71Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 8209F71Ch case    1:*/		return 0x8209F720;
		  /* 8209F720h */ case    2:  		/* bc 12, CR6_EQ, 144 */
		/* 8209F720h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209F7B0;  }
		/* 8209F720h case    2:*/		return 0x8209F724;
		  /* 8209F724h */ case    3:  		/* lwz R3, <#[R23 + 12]> */
		/* 8209F724h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x0000000C) );
		/* 8209F724h case    3:*/		return 0x8209F728;
		  /* 8209F728h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 8209F728h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209F728h case    4:*/		return 0x8209F72C;
		  /* 8209F72Ch */ case    5:  		/* bc 12, CR6_EQ, 132 */
		/* 8209F72Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x8209F7B0;  }
		/* 8209F72Ch case    5:*/		return 0x8209F730;
		  /* 8209F730h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 8209F730h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209F730h case    6:*/		return 0x8209F734;
		  /* 8209F734h */ case    7:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209F734h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F734h case    7:*/		return 0x8209F738;
		  /* 8209F738h */ case    8:  		/* mtspr CTR, R11 */
		/* 8209F738h case    8:*/		regs.CTR = regs.R11;
		/* 8209F738h case    8:*/		return 0x8209F73C;
		  /* 8209F73Ch */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 8209F73Ch case    9:*/		if ( 1 ) { regs.LR = 0x8209F740; return (uint32)regs.CTR; }
		/* 8209F73Ch case    9:*/		return 0x8209F740;
		  /* 8209F740h */ case   10:  		/* stw R29, <#[R23 + 12]> */
		/* 8209F740h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R23 + 0x0000000C) );
		/* 8209F740h case   10:*/		return 0x8209F744;
		  /* 8209F744h */ case   11:  		/* b 108 */
		/* 8209F744h case   11:*/		return 0x8209F7B0;
		/* 8209F744h case   11:*/		return 0x8209F748;
	}
	return 0x8209F748;
} // Block from 8209F718h-8209F748h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8209F748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F748);
		  /* 8209F748h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8209F748h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209F748h case    0:*/		return 0x8209F74C;
		  /* 8209F74Ch */ case    1:  		/* mr R3, R31 */
		/* 8209F74Ch case    1:*/		regs.R3 = regs.R31;
		/* 8209F74Ch case    1:*/		return 0x8209F750;
		  /* 8209F750h */ case    2:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209F750h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F750h case    2:*/		return 0x8209F754;
		  /* 8209F754h */ case    3:  		/* mtspr CTR, R11 */
		/* 8209F754h case    3:*/		regs.CTR = regs.R11;
		/* 8209F754h case    3:*/		return 0x8209F758;
		  /* 8209F758h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8209F758h case    4:*/		if ( 1 ) { regs.LR = 0x8209F75C; return (uint32)regs.CTR; }
		/* 8209F758h case    4:*/		return 0x8209F75C;
		  /* 8209F75Ch */ case    5:  		/* lwz R3, <#[R1 + 112]> */
		/* 8209F75Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000070) );
		/* 8209F75Ch case    5:*/		return 0x8209F760;
		  /* 8209F760h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 8209F760h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209F760h case    6:*/		return 0x8209F764;
		  /* 8209F764h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 8209F764h case    7:*/		if ( regs.CR[6].eq ) { return 0x8209F778;  }
		/* 8209F764h case    7:*/		return 0x8209F768;
		  /* 8209F768h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 8209F768h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209F768h case    8:*/		return 0x8209F76C;
		  /* 8209F76Ch */ case    9:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209F76Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F76Ch case    9:*/		return 0x8209F770;
		  /* 8209F770h */ case   10:  		/* mtspr CTR, R11 */
		/* 8209F770h case   10:*/		regs.CTR = regs.R11;
		/* 8209F770h case   10:*/		return 0x8209F774;
		  /* 8209F774h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 8209F774h case   11:*/		if ( 1 ) { regs.LR = 0x8209F778; return (uint32)regs.CTR; }
		/* 8209F774h case   11:*/		return 0x8209F778;
	}
	return 0x8209F778;
} // Block from 8209F748h-8209F778h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8209F778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F778);
		  /* 8209F778h */ case    0:  		/* lwz R3, <#[R1 + 116]> */
		/* 8209F778h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000074) );
		/* 8209F778h case    0:*/		return 0x8209F77C;
		  /* 8209F77Ch */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8209F77Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209F77Ch case    1:*/		return 0x8209F780;
		  /* 8209F780h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 8209F780h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209F794;  }
		/* 8209F780h case    2:*/		return 0x8209F784;
		  /* 8209F784h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 8209F784h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209F784h case    3:*/		return 0x8209F788;
		  /* 8209F788h */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209F788h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F788h case    4:*/		return 0x8209F78C;
		  /* 8209F78Ch */ case    5:  		/* mtspr CTR, R11 */
		/* 8209F78Ch case    5:*/		regs.CTR = regs.R11;
		/* 8209F78Ch case    5:*/		return 0x8209F790;
		  /* 8209F790h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 8209F790h case    6:*/		if ( 1 ) { regs.LR = 0x8209F794; return (uint32)regs.CTR; }
		/* 8209F790h case    6:*/		return 0x8209F794;
	}
	return 0x8209F794;
} // Block from 8209F778h-8209F794h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209F794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F794);
		  /* 8209F794h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 8209F794h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8209F794h case    0:*/		return 0x8209F798;
		  /* 8209F798h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 8209F798h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209F7B0;  }
		/* 8209F798h case    1:*/		return 0x8209F79C;
		  /* 8209F79Ch */ case    2:  		/* lwz R11, <#[R28]> */
		/* 8209F79Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8209F79Ch case    2:*/		return 0x8209F7A0;
	}
	return 0x8209F7A0;
} // Block from 8209F794h-8209F7A0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209F7A0h
// Function '?PromoteTarget@D3DXShader@@YAPBDPBDK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F7A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F7A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F7A0);
		  /* 8209F7A0h */ case    0:  		/* mr R3, R28 */
		/* 8209F7A0h case    0:*/		regs.R3 = regs.R28;
		/* 8209F7A0h case    0:*/		return 0x8209F7A4;
	}
	return 0x8209F7A4;
} // Block from 8209F7A0h-8209F7A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209F7A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F7A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F7A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F7A4);
		  /* 8209F7A4h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209F7A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F7A4h case    0:*/		return 0x8209F7A8;
		  /* 8209F7A8h */ case    1:  		/* mtspr CTR, R11 */
		/* 8209F7A8h case    1:*/		regs.CTR = regs.R11;
		/* 8209F7A8h case    1:*/		return 0x8209F7AC;
		  /* 8209F7ACh */ case    2:  		/* bcctrl 20, CR0_LT */
		/* 8209F7ACh case    2:*/		if ( 1 ) { regs.LR = 0x8209F7B0; return (uint32)regs.CTR; }
		/* 8209F7ACh case    2:*/		return 0x8209F7B0;
	}
	return 0x8209F7B0;
} // Block from 8209F7A4h-8209F7B0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209F7B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F7B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F7B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F7B0);
		  /* 8209F7B0h */ case    0:  		/* mr R3, R20 */
		/* 8209F7B0h case    0:*/		regs.R3 = regs.R20;
		/* 8209F7B0h case    0:*/		return 0x8209F7B4;
		  /* 8209F7B4h */ case    1:  		/* addi R1, R1, 256 */
		/* 8209F7B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 8209F7B4h case    1:*/		return 0x8209F7B8;
		  /* 8209F7B8h */ case    2:  		/* b -58680 */
		/* 8209F7B8h case    2:*/		return 0x82091280;
		/* 8209F7B8h case    2:*/		return 0x8209F7BC;
		  /* 8209F7BCh */ case    3:  		/* nop */
		/* 8209F7BCh case    3:*/		cpu::op::nop();
		/* 8209F7BCh case    3:*/		return 0x8209F7C0;
	}
	return 0x8209F7C0;
} // Block from 8209F7B0h-8209F7C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209F7C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F7C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F7C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F7C0);
		  /* 8209F7C0h */ case    0:  		/* mfspr R12, LR */
		/* 8209F7C0h case    0:*/		regs.R12 = regs.LR;
		/* 8209F7C0h case    0:*/		return 0x8209F7C4;
		  /* 8209F7C4h */ case    1:  		/* bl -58748 */
		/* 8209F7C4h case    1:*/		regs.LR = 0x8209F7C8; return 0x82091248;
		/* 8209F7C4h case    1:*/		return 0x8209F7C8;
		  /* 8209F7C8h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 8209F7C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 8209F7C8h case    2:*/		return 0x8209F7CC;
		  /* 8209F7CCh */ case    3:  		/* mr R30, R3 */
		/* 8209F7CCh case    3:*/		regs.R30 = regs.R3;
		/* 8209F7CCh case    3:*/		return 0x8209F7D0;
		  /* 8209F7D0h */ case    4:  		/* mr R29, R4 */
		/* 8209F7D0h case    4:*/		regs.R29 = regs.R4;
		/* 8209F7D0h case    4:*/		return 0x8209F7D4;
		  /* 8209F7D4h */ case    5:  		/* mr R28, R5 */
		/* 8209F7D4h case    5:*/		regs.R28 = regs.R5;
		/* 8209F7D4h case    5:*/		return 0x8209F7D8;
		  /* 8209F7D8h */ case    6:  		/* mr R31, R6 */
		/* 8209F7D8h case    6:*/		regs.R31 = regs.R6;
		/* 8209F7D8h case    6:*/		return 0x8209F7DC;
		  /* 8209F7DCh */ case    7:  		/* mr R27, R7 */
		/* 8209F7DCh case    7:*/		regs.R27 = regs.R7;
		/* 8209F7DCh case    7:*/		return 0x8209F7E0;
		  /* 8209F7E0h */ case    8:  		/* mr R26, R8 */
		/* 8209F7E0h case    8:*/		regs.R26 = regs.R8;
		/* 8209F7E0h case    8:*/		return 0x8209F7E4;
		  /* 8209F7E4h */ case    9:  		/* mr R25, R9 */
		/* 8209F7E4h case    9:*/		regs.R25 = regs.R9;
		/* 8209F7E4h case    9:*/		return 0x8209F7E8;
		  /* 8209F7E8h */ case   10:  		/* mr R24, R10 */
		/* 8209F7E8h case   10:*/		regs.R24 = regs.R10;
		/* 8209F7E8h case   10:*/		return 0x8209F7EC;
		  /* 8209F7ECh */ case   11:  		/* bl -1268 */
		/* 8209F7ECh case   11:*/		regs.LR = 0x8209F7F0; return 0x8209F2F8;
		/* 8209F7ECh case   11:*/		return 0x8209F7F0;
		  /* 8209F7F0h */ case   12:  		/* lis R11, -30602 */
		/* 8209F7F0h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8876);
		/* 8209F7F0h case   12:*/		return 0x8209F7F4;
		  /* 8209F7F4h */ case   13:  		/* ori R11, R11, 2924 */
		/* 8209F7F4h case   13:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xB6C);
		/* 8209F7F4h case   13:*/		return 0x8209F7F8;
		  /* 8209F7F8h */ case   14:  		/* cmpw CR6, R3, R11 */
		/* 8209F7F8h case   14:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R11);
		/* 8209F7F8h case   14:*/		return 0x8209F7FC;
		  /* 8209F7FCh */ case   15:  		/* bc 4, CR6_EQ, 48 */
		/* 8209F7FCh case   15:*/		if ( !regs.CR[6].eq ) { return 0x8209F82C;  }
		/* 8209F7FCh case   15:*/		return 0x8209F800;
		  /* 8209F800h */ case   16:  		/* rlwinm. R11, R31, 0, 29, 29 */
		/* 8209F800h case   16:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R31);
		/* 8209F800h case   16:*/		return 0x8209F804;
		  /* 8209F804h */ case   17:  		/* bc 4, CR0_EQ, 40 */
		/* 8209F804h case   17:*/		if ( !regs.CR[0].eq ) { return 0x8209F82C;  }
		/* 8209F804h case   17:*/		return 0x8209F808;
		  /* 8209F808h */ case   18:  		/* mr R10, R24 */
		/* 8209F808h case   18:*/		regs.R10 = regs.R24;
		/* 8209F808h case   18:*/		return 0x8209F80C;
		  /* 8209F80Ch */ case   19:  		/* mr R9, R25 */
		/* 8209F80Ch case   19:*/		regs.R9 = regs.R25;
		/* 8209F80Ch case   19:*/		return 0x8209F810;
		  /* 8209F810h */ case   20:  		/* mr R8, R26 */
		/* 8209F810h case   20:*/		regs.R8 = regs.R26;
		/* 8209F810h case   20:*/		return 0x8209F814;
		  /* 8209F814h */ case   21:  		/* mr R7, R27 */
		/* 8209F814h case   21:*/		regs.R7 = regs.R27;
		/* 8209F814h case   21:*/		return 0x8209F818;
		  /* 8209F818h */ case   22:  		/* ori R6, R31, 4 */
		/* 8209F818h case   22:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R31,0x4);
		/* 8209F818h case   22:*/		return 0x8209F81C;
		  /* 8209F81Ch */ case   23:  		/* mr R5, R28 */
		/* 8209F81Ch case   23:*/		regs.R5 = regs.R28;
		/* 8209F81Ch case   23:*/		return 0x8209F820;
		  /* 8209F820h */ case   24:  		/* mr R4, R29 */
		/* 8209F820h case   24:*/		regs.R4 = regs.R29;
		/* 8209F820h case   24:*/		return 0x8209F824;
		  /* 8209F824h */ case   25:  		/* mr R3, R30 */
		/* 8209F824h case   25:*/		regs.R3 = regs.R30;
		/* 8209F824h case   25:*/		return 0x8209F828;
		  /* 8209F828h */ case   26:  		/* bl -1328 */
		/* 8209F828h case   26:*/		regs.LR = 0x8209F82C; return 0x8209F2F8;
		/* 8209F828h case   26:*/		return 0x8209F82C;
	}
	return 0x8209F82C;
} // Block from 8209F7C0h-8209F82Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 8209F82Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F82C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F82C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F82C);
		  /* 8209F82Ch */ case    0:  		/* addi R1, R1, 160 */
		/* 8209F82Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 8209F82Ch case    0:*/		return 0x8209F830;
		  /* 8209F830h */ case    1:  		/* b -58776 */
		/* 8209F830h case    1:*/		return 0x82091298;
		/* 8209F830h case    1:*/		return 0x8209F834;
		  /* 8209F834h */ case    2:  		/* nop */
		/* 8209F834h case    2:*/		cpu::op::nop();
		/* 8209F834h case    2:*/		return 0x8209F838;
	}
	return 0x8209F838;
} // Block from 8209F82Ch-8209F838h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209F838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F838);
		  /* 8209F838h */ case    0:  		/* mfspr R12, LR */
		/* 8209F838h case    0:*/		regs.R12 = regs.LR;
		/* 8209F838h case    0:*/		return 0x8209F83C;
		  /* 8209F83Ch */ case    1:  		/* bl -58860 */
		/* 8209F83Ch case    1:*/		regs.LR = 0x8209F840; return 0x82091250;
		/* 8209F83Ch case    1:*/		return 0x8209F840;
		  /* 8209F840h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 8209F840h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 8209F840h case    2:*/		return 0x8209F844;
		  /* 8209F844h */ case    3:  		/* li R31, 0 */
		/* 8209F844h case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8209F844h case    3:*/		return 0x8209F848;
		  /* 8209F848h */ case    4:  		/* stw R5, <#[R1 + 92]> */
		/* 8209F848h case    4:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x0000005C) );
		/* 8209F848h case    4:*/		return 0x8209F84C;
		  /* 8209F84Ch */ case    5:  		/* mr R28, R7 */
		/* 8209F84Ch case    5:*/		regs.R28 = regs.R7;
		/* 8209F84Ch case    5:*/		return 0x8209F850;
		  /* 8209F850h */ case    6:  		/* mr R26, R8 */
		/* 8209F850h case    6:*/		regs.R26 = regs.R8;
		/* 8209F850h case    6:*/		return 0x8209F854;
		  /* 8209F854h */ case    7:  		/* stw R31, <#[R1 + 88]> */
		/* 8209F854h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000058) );
		/* 8209F854h case    7:*/		return 0x8209F858;
		  /* 8209F858h */ case    8:  		/* mr R29, R9 */
		/* 8209F858h case    8:*/		regs.R29 = regs.R9;
		/* 8209F858h case    8:*/		return 0x8209F85C;
		  /* 8209F85Ch */ case    9:  		/* stw R31, <#[R1 + 80]> */
		/* 8209F85Ch case    9:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 8209F85Ch case    9:*/		return 0x8209F860;
		  /* 8209F860h */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 8209F860h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8209F860h case   10:*/		return 0x8209F864;
		  /* 8209F864h */ case   11:  		/* stw R31, <#[R1 + 84]> */
		/* 8209F864h case   11:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 8209F864h case   11:*/		return 0x8209F868;
		  /* 8209F868h */ case   12:  		/* bc 4, CR6_EQ, 36 */
		/* 8209F868h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8209F88C;  }
		/* 8209F868h case   12:*/		return 0x8209F86C;
		  /* 8209F86Ch */ case   13:  		/* li R10, 8 */
		/* 8209F86Ch case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x8);
		/* 8209F86Ch case   13:*/		return 0x8209F870;
		  /* 8209F870h */ case   14:  		/* addi R11, R1, 88 */
		/* 8209F870h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x58);
		/* 8209F870h case   14:*/		return 0x8209F874;
		  /* 8209F874h */ case   15:  		/* mr R9, R31 */
		/* 8209F874h case   15:*/		regs.R9 = regs.R31;
		/* 8209F874h case   15:*/		return 0x8209F878;
		  /* 8209F878h */ case   16:  		/* mtspr CTR, R10 */
		/* 8209F878h case   16:*/		regs.CTR = regs.R10;
		/* 8209F878h case   16:*/		return 0x8209F87C;
		  /* 8209F87Ch */ case   17:  		/* stdu R9, <#[R11 + 8]> */
		/* 8209F87Ch case   17:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		regs.R11 = (uint32)(regs.R11 + 0x00000008);
		/* 8209F87Ch case   17:*/		return 0x8209F880;
		  /* 8209F880h */ case   18:  		/* bc 16, CR0_LT, -4 */
		/* 8209F880h case   18:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8209F87C;  }
		/* 8209F880h case   18:*/		return 0x8209F884;
		  /* 8209F884h */ case   19:  		/* stw R9, <#[R11 + 8]> */
		/* 8209F884h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F884h case   19:*/		return 0x8209F888;
	}
	return 0x8209F888;
} // Block from 8209F838h-8209F888h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8209F888h
// Function 'D3DXGetTargetDescByName'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F888);
		  /* 8209F888h */ case    0:  		/* addi R10, R1, 96 */
		/* 8209F888h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 8209F888h case    0:*/		return 0x8209F88C;
	}
	return 0x8209F88C;
} // Block from 8209F888h-8209F88Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209F88Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F88C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F88C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F88C);
		  /* 8209F88Ch */ case    0:  		/* mr R9, R31 */
		/* 8209F88Ch case    0:*/		regs.R9 = regs.R31;
		/* 8209F88Ch case    0:*/		return 0x8209F890;
		  /* 8209F890h */ case    1:  		/* cmplwi CR6, R5, 0 */
		/* 8209F890h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8209F890h case    1:*/		return 0x8209F894;
		  /* 8209F894h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 8209F894h case    2:*/		if ( regs.CR[6].eq ) { return 0x8209F8B8;  }
		/* 8209F894h case    2:*/		return 0x8209F898;
		  /* 8209F898h */ case    3:  		/* lbz R11, <#[R5]> */
		/* 8209F898h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8209F898h case    3:*/		return 0x8209F89C;
		  /* 8209F89Ch */ case    4:  		/* extsb R11, R11 */
		/* 8209F89Ch case    4:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 8209F89Ch case    4:*/		return 0x8209F8A0;
		  /* 8209F8A0h */ case    5:  		/* cmpwi CR6, R11, 118 */
		/* 8209F8A0h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000076);
		/* 8209F8A0h case    5:*/		return 0x8209F8A4;
		  /* 8209F8A4h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 8209F8A4h case    6:*/		if ( regs.CR[6].eq ) { return 0x8209F8B8;  }
		/* 8209F8A4h case    6:*/		return 0x8209F8A8;
		  /* 8209F8A8h */ case    7:  		/* cmpwi CR6, R11, 112 */
		/* 8209F8A8h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000070);
		/* 8209F8A8h case    7:*/		return 0x8209F8AC;
		  /* 8209F8ACh */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 8209F8ACh case    8:*/		if ( regs.CR[6].eq ) { return 0x8209F8B8;  }
		/* 8209F8ACh case    8:*/		return 0x8209F8B0;
		  /* 8209F8B0h */ case    9:  		/* li R9, 1 */
		/* 8209F8B0h case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8209F8B0h case    9:*/		return 0x8209F8B4;
		  /* 8209F8B4h */ case   10:  		/* oris R6, R6, 16 */
		/* 8209F8B4h case   10:*/		cpu::op::oris<0>(regs,&regs.R6,regs.R6,0x10);
		/* 8209F8B4h case   10:*/		return 0x8209F8B8;
	}
	return 0x8209F8B8;
} // Block from 8209F88Ch-8209F8B8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209F8B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F8B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F8B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F8B8);
		  /* 8209F8B8h */ case    0:  		/* rlwinm. R11, R9, 0, 24, 31 */
		/* 8209F8B8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R9);
		/* 8209F8B8h case    0:*/		return 0x8209F8BC;
		  /* 8209F8BCh */ case    1:  		/* bc 4, CR0_EQ, 228 */
		/* 8209F8BCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x8209F9A0;  }
		/* 8209F8BCh case    1:*/		return 0x8209F8C0;
		  /* 8209F8C0h */ case    2:  		/* rlwinm. R11, R6, 0, 11, 11 */
		/* 8209F8C0h case    2:*/		cpu::op::rlwinm<1,0,11,11>(regs,&regs.R11,regs.R6);
		/* 8209F8C0h case    2:*/		return 0x8209F8C4;
		  /* 8209F8C4h */ case    3:  		/* bc 4, CR0_EQ, 220 */
		/* 8209F8C4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8209F9A0;  }
		/* 8209F8C4h case    3:*/		return 0x8209F8C8;
		  /* 8209F8C8h */ case    4:  		/* addi R9, R1, 84 */
		/* 8209F8C8h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x54);
		/* 8209F8C8h case    4:*/		return 0x8209F8CC;
		  /* 8209F8CCh */ case    5:  		/* addi R8, R1, 80 */
		/* 8209F8CCh case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 8209F8CCh case    5:*/		return 0x8209F8D0;
		  /* 8209F8D0h */ case    6:  		/* addi R7, R1, 88 */
		/* 8209F8D0h case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x58);
		/* 8209F8D0h case    6:*/		return 0x8209F8D4;
		  /* 8209F8D4h */ case    7:  		/* addi R5, R1, 92 */
		/* 8209F8D4h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x5C);
		/* 8209F8D4h case    7:*/		return 0x8209F8D8;
		  /* 8209F8D8h */ case    8:  		/* bl -280 */
		/* 8209F8D8h case    8:*/		regs.LR = 0x8209F8DC; return 0x8209F7C0;
		/* 8209F8D8h case    8:*/		return 0x8209F8DC;
		  /* 8209F8DCh */ case    9:  		/* or. R27, R3, R3 */
		/* 8209F8DCh case    9:*/		cpu::op::or<1>(regs,&regs.R27,regs.R3,regs.R3);
		/* 8209F8DCh case    9:*/		return 0x8209F8E0;
		  /* 8209F8E0h */ case   10:  		/* bc 12, CR0_LT, 56 */
		/* 8209F8E0h case   10:*/		if ( regs.CR[0].lt ) { return 0x8209F918;  }
		/* 8209F8E0h case   10:*/		return 0x8209F8E4;
		  /* 8209F8E4h */ case   11:  		/* cmplwi CR6, R29, 0 */
		/* 8209F8E4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8209F8E4h case   11:*/		return 0x8209F8E8;
		  /* 8209F8E8h */ case   12:  		/* bc 12, CR6_EQ, 20 */
		/* 8209F8E8h case   12:*/		if ( regs.CR[6].eq ) { return 0x8209F8FC;  }
		/* 8209F8E8h case   12:*/		return 0x8209F8EC;
		  /* 8209F8ECh */ case   13:  		/* lwz R11, <#[R1 + 84]> */
		/* 8209F8ECh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8209F8ECh case   13:*/		return 0x8209F8F0;
		  /* 8209F8F0h */ case   14:  		/* mr R30, R31 */
		/* 8209F8F0h case   14:*/		regs.R30 = regs.R31;
		/* 8209F8F0h case   14:*/		return 0x8209F8F4;
		  /* 8209F8F4h */ case   15:  		/* stw R11, <#[R29]> */
		/* 8209F8F4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8209F8F4h case   15:*/		return 0x8209F8F8;
		  /* 8209F8F8h */ case   16:  		/* b 8 */
		/* 8209F8F8h case   16:*/		return 0x8209F900;
		/* 8209F8F8h case   16:*/		return 0x8209F8FC;
	}
	return 0x8209F8FC;
} // Block from 8209F8B8h-8209F8FCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 8209F8FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F8FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F8FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F8FC);
		  /* 8209F8FCh */ case    0:  		/* lwz R30, <#[R1 + 84]> */
		/* 8209F8FCh case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 8209F8FCh case    0:*/		return 0x8209F900;
	}
	return 0x8209F900;
} // Block from 8209F8FCh-8209F900h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209F900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F900);
		  /* 8209F900h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 8209F900h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8209F900h case    0:*/		return 0x8209F904;
		  /* 8209F904h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 8209F904h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209F91C;  }
		/* 8209F904h case    1:*/		return 0x8209F908;
		  /* 8209F908h */ case    2:  		/* lwz R11, <#[R1 + 88]> */
		/* 8209F908h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8209F908h case    2:*/		return 0x8209F90C;
		  /* 8209F90Ch */ case    3:  		/* mr R3, R31 */
		/* 8209F90Ch case    3:*/		regs.R3 = regs.R31;
		/* 8209F90Ch case    3:*/		return 0x8209F910;
		  /* 8209F910h */ case    4:  		/* stw R11, <#[R28]> */
		/* 8209F910h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8209F910h case    4:*/		return 0x8209F914;
		  /* 8209F914h */ case    5:  		/* b 12 */
		/* 8209F914h case    5:*/		return 0x8209F920;
		/* 8209F914h case    5:*/		return 0x8209F918;
	}
	return 0x8209F918;
} // Block from 8209F900h-8209F918h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209F918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F918);
		  /* 8209F918h */ case    0:  		/* lwz R30, <#[R1 + 84]> */
		/* 8209F918h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 8209F918h case    0:*/		return 0x8209F91C;
	}
	return 0x8209F91C;
} // Block from 8209F918h-8209F91Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209F91Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F91C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F91C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F91C);
		  /* 8209F91Ch */ case    0:  		/* lwz R3, <#[R1 + 88]> */
		/* 8209F91Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000058) );
		/* 8209F91Ch case    0:*/		return 0x8209F920;
	}
	return 0x8209F920;
} // Block from 8209F91Ch-8209F920h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209F920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F920);
		  /* 8209F920h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 8209F920h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 8209F920h case    0:*/		return 0x8209F924;
		  /* 8209F924h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 8209F924h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209F93C;  }
		/* 8209F924h case    1:*/		return 0x8209F928;
		  /* 8209F928h */ case    2:  		/* lwz R10, <#[R1 + 80]> */
		/* 8209F928h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8209F928h case    2:*/		return 0x8209F92C;
		  /* 8209F92Ch */ case    3:  		/* mr R11, R31 */
		/* 8209F92Ch case    3:*/		regs.R11 = regs.R31;
		/* 8209F92Ch case    3:*/		return 0x8209F930;
		  /* 8209F930h */ case    4:  		/* stw R31, <#[R1 + 80]> */
		/* 8209F930h case    4:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 8209F930h case    4:*/		return 0x8209F934;
		  /* 8209F934h */ case    5:  		/* stw R10, <#[R26]> */
		/* 8209F934h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 8209F934h case    5:*/		return 0x8209F938;
		  /* 8209F938h */ case    6:  		/* b 8 */
		/* 8209F938h case    6:*/		return 0x8209F940;
		/* 8209F938h case    6:*/		return 0x8209F93C;
	}
	return 0x8209F93C;
} // Block from 8209F920h-8209F93Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209F93Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F93C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F93C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F93C);
		  /* 8209F93Ch */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 8209F93Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8209F93Ch case    0:*/		return 0x8209F940;
	}
	return 0x8209F940;
} // Block from 8209F93Ch-8209F940h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209F940h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F940);
		  /* 8209F940h */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 8209F940h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209F940h case    0:*/		return 0x8209F944;
		  /* 8209F944h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 8209F944h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209F95C;  }
		/* 8209F944h case    1:*/		return 0x8209F948;
		  /* 8209F948h */ case    2:  		/* lwz R11, <#[R3]> */
		/* 8209F948h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209F948h case    2:*/		return 0x8209F94C;
		  /* 8209F94Ch */ case    3:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209F94Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F94Ch case    3:*/		return 0x8209F950;
		  /* 8209F950h */ case    4:  		/* mtspr CTR, R11 */
		/* 8209F950h case    4:*/		regs.CTR = regs.R11;
		/* 8209F950h case    4:*/		return 0x8209F954;
		  /* 8209F954h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 8209F954h case    5:*/		if ( 1 ) { regs.LR = 0x8209F958; return (uint32)regs.CTR; }
		/* 8209F954h case    5:*/		return 0x8209F958;
		  /* 8209F958h */ case    6:  		/* lwz R11, <#[R1 + 80]> */
		/* 8209F958h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8209F958h case    6:*/		return 0x8209F95C;
	}
	return 0x8209F95C;
} // Block from 8209F940h-8209F95Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209F95Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F95C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F95C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F95C);
		  /* 8209F95Ch */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 8209F95Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8209F95Ch case    0:*/		return 0x8209F960;
	}
	return 0x8209F960;
} // Block from 8209F95Ch-8209F960h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209F960h
// Function 'D3DXGetTargetDescByVersion'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F960);
		  /* 8209F960h */ case    0:  		/* bc 12, CR6_EQ, 28 */
		/* 8209F960h case    0:*/		if ( regs.CR[6].eq ) { return 0x8209F97C;  }
		/* 8209F960h case    0:*/		return 0x8209F964;
		  /* 8209F964h */ case    1:  		/* lwz R11, <#[R30]> */
		/* 8209F964h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8209F964h case    1:*/		return 0x8209F968;
		  /* 8209F968h */ case    2:  		/* mr R3, R30 */
		/* 8209F968h case    2:*/		regs.R3 = regs.R30;
		/* 8209F968h case    2:*/		return 0x8209F96C;
		  /* 8209F96Ch */ case    3:  		/* lwz R11, <#[R11 + 8]> */
		/* 8209F96Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8209F96Ch case    3:*/		return 0x8209F970;
		  /* 8209F970h */ case    4:  		/* mtspr CTR, R11 */
		/* 8209F970h case    4:*/		regs.CTR = regs.R11;
		/* 8209F970h case    4:*/		return 0x8209F974;
		  /* 8209F974h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 8209F974h case    5:*/		if ( 1 ) { regs.LR = 0x8209F978; return (uint32)regs.CTR; }
		/* 8209F974h case    5:*/		return 0x8209F978;
		  /* 8209F978h */ case    6:  		/* lwz R11, <#[R1 + 80]> */
		/* 8209F978h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8209F978h case    6:*/		return 0x8209F97C;
	}
	return 0x8209F97C;
} // Block from 8209F960h-8209F97Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209F97Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F97C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F97C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F97C);
		  /* 8209F97Ch */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8209F97Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8209F97Ch case    0:*/		return 0x8209F980;
		  /* 8209F980h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 8209F980h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209F998;  }
		/* 8209F980h case    1:*/		return 0x8209F984;
		  /* 8209F984h */ case    2:  		/* lwz R10, <#[R11]> */
		/* 8209F984h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209F984h case    2:*/		return 0x8209F988;
		  /* 8209F988h */ case    3:  		/* mr R3, R11 */
		/* 8209F988h case    3:*/		regs.R3 = regs.R11;
		/* 8209F988h case    3:*/		return 0x8209F98C;
		  /* 8209F98Ch */ case    4:  		/* lwz R11, <#[R10 + 8]> */
		/* 8209F98Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8209F98Ch case    4:*/		return 0x8209F990;
		  /* 8209F990h */ case    5:  		/* mtspr CTR, R11 */
		/* 8209F990h case    5:*/		regs.CTR = regs.R11;
		/* 8209F990h case    5:*/		return 0x8209F994;
		  /* 8209F994h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 8209F994h case    6:*/		if ( 1 ) { regs.LR = 0x8209F998; return (uint32)regs.CTR; }
		/* 8209F994h case    6:*/		return 0x8209F998;
	}
	return 0x8209F998;
} // Block from 8209F97Ch-8209F998h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209F998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F998);
		  /* 8209F998h */ case    0:  		/* mr R3, R27 */
		/* 8209F998h case    0:*/		regs.R3 = regs.R27;
		/* 8209F998h case    0:*/		return 0x8209F99C;
		  /* 8209F99Ch */ case    1:  		/* b 24 */
		/* 8209F99Ch case    1:*/		return 0x8209F9B4;
		/* 8209F99Ch case    1:*/		return 0x8209F9A0;
	}
	return 0x8209F9A0;
} // Block from 8209F998h-8209F9A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209F9A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F9A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F9A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F9A0);
		  /* 8209F9A0h */ case    0:  		/* mr R9, R29 */
		/* 8209F9A0h case    0:*/		regs.R9 = regs.R29;
		/* 8209F9A0h case    0:*/		return 0x8209F9A4;
		  /* 8209F9A4h */ case    1:  		/* mr R8, R26 */
		/* 8209F9A4h case    1:*/		regs.R8 = regs.R26;
		/* 8209F9A4h case    1:*/		return 0x8209F9A8;
		  /* 8209F9A8h */ case    2:  		/* mr R7, R28 */
		/* 8209F9A8h case    2:*/		regs.R7 = regs.R28;
		/* 8209F9A8h case    2:*/		return 0x8209F9AC;
		  /* 8209F9ACh */ case    3:  		/* addi R5, R1, 92 */
		/* 8209F9ACh case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x5C);
		/* 8209F9ACh case    3:*/		return 0x8209F9B0;
		  /* 8209F9B0h */ case    4:  		/* bl -496 */
		/* 8209F9B0h case    4:*/		regs.LR = 0x8209F9B4; return 0x8209F7C0;
		/* 8209F9B0h case    4:*/		return 0x8209F9B4;
	}
	return 0x8209F9B4;
} // Block from 8209F9A0h-8209F9B4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209F9B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F9B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F9B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F9B4);
		  /* 8209F9B4h */ case    0:  		/* addi R1, R1, 224 */
		/* 8209F9B4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 8209F9B4h case    0:*/		return 0x8209F9B8;
		  /* 8209F9B8h */ case    1:  		/* b -59160 */
		/* 8209F9B8h case    1:*/		return 0x820912A0;
		/* 8209F9B8h case    1:*/		return 0x8209F9BC;
		  /* 8209F9BCh */ case    2:  		/* nop */
		/* 8209F9BCh case    2:*/		cpu::op::nop();
		/* 8209F9BCh case    2:*/		return 0x8209F9C0;
	}
	return 0x8209F9C0;
} // Block from 8209F9B4h-8209F9C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209F9C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F9C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F9C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F9C0);
		  /* 8209F9C0h */ case    0:  		/* mfspr R12, LR */
		/* 8209F9C0h case    0:*/		regs.R12 = regs.LR;
		/* 8209F9C0h case    0:*/		return 0x8209F9C4;
		  /* 8209F9C4h */ case    1:  		/* bl -59240 */
		/* 8209F9C4h case    1:*/		regs.LR = 0x8209F9C8; return 0x8209125C;
		/* 8209F9C4h case    1:*/		return 0x8209F9C8;
		  /* 8209F9C8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209F9C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209F9C8h case    2:*/		return 0x8209F9CC;
		  /* 8209F9CCh */ case    3:  		/* mr R30, R3 */
		/* 8209F9CCh case    3:*/		regs.R30 = regs.R3;
		/* 8209F9CCh case    3:*/		return 0x8209F9D0;
		  /* 8209F9D0h */ case    4:  		/* mr R29, R4 */
		/* 8209F9D0h case    4:*/		regs.R29 = regs.R4;
		/* 8209F9D0h case    4:*/		return 0x8209F9D4;
		  /* 8209F9D4h */ case    5:  		/* li R31, 0 */
		/* 8209F9D4h case    5:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8209F9D4h case    5:*/		return 0x8209F9D8;
		  /* 8209F9D8h */ case    6:  		/* cmplwi CR6, R4, 0 */
		/* 8209F9D8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8209F9D8h case    6:*/		return 0x8209F9DC;
		  /* 8209F9DCh */ case    7:  		/* bc 12, CR6_EQ, 8 */
		/* 8209F9DCh case    7:*/		if ( regs.CR[6].eq ) { return 0x8209F9E4;  }
		/* 8209F9DCh case    7:*/		return 0x8209F9E0;
	}
	return 0x8209F9E0;
} // Block from 8209F9C0h-8209F9E0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209F9E0h
// Function '?StringVPrintfWorkerA@@YAJPADIPBD0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F9E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F9E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F9E0);
		  /* 8209F9E0h */ case    0:  		/* stw R31, <#[R4]> */
		/* 8209F9E0h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R4 + 0x00000000) );
		/* 8209F9E0h case    0:*/		return 0x8209F9E4;
	}
	return 0x8209F9E4;
} // Block from 8209F9E0h-8209F9E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209F9E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F9E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F9E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F9E4);
		  /* 8209F9E4h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 8209F9E4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8209F9E4h case    0:*/		return 0x8209F9E8;
		  /* 8209F9E8h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8209F9E8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209F9F8;  }
		/* 8209F9E8h case    1:*/		return 0x8209F9EC;
		  /* 8209F9ECh */ case    2:  		/* lis R3, -30602 */
		/* 8209F9ECh case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8876);
		/* 8209F9ECh case    2:*/		return 0x8209F9F0;
		  /* 8209F9F0h */ case    3:  		/* ori R3, R3, 2156 */
		/* 8209F9F0h case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x86C);
		/* 8209F9F0h case    3:*/		return 0x8209F9F4;
		  /* 8209F9F4h */ case    4:  		/* b 172 */
		/* 8209F9F4h case    4:*/		return 0x8209FAA0;
		/* 8209F9F4h case    4:*/		return 0x8209F9F8;
	}
	return 0x8209F9F8;
} // Block from 8209F9E4h-8209F9F8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209F9F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209F9F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209F9F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209F9F8);
		  /* 8209F9F8h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 8209F9F8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8209F9F8h case    0:*/		return 0x8209F9FC;
		  /* 8209F9FCh */ case    1:  		/* bc 12, CR6_EQ, -16 */
		/* 8209F9FCh case    1:*/		if ( regs.CR[6].eq ) { return 0x8209F9EC;  }
		/* 8209F9FCh case    1:*/		return 0x8209FA00;
		  /* 8209FA00h */ case    2:  		/* lwz R11, <#[R30]> */
		/* 8209FA00h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8209FA00h case    2:*/		return 0x8209FA04;
		  /* 8209FA04h */ case    3:  		/* lis R10, 4138 */
		/* 8209FA04h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x102A);
		/* 8209FA04h case    3:*/		return 0x8209FA08;
		  /* 8209FA08h */ case    4:  		/* ori R10, R10, 4352 */
		/* 8209FA08h case    4:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1100);
		/* 8209FA08h case    4:*/		return 0x8209FA0C;
		  /* 8209FA0Ch */ case    5:  		/* rlwinm R9, R11, 0, 0, 23 */
		/* 8209FA0Ch case    5:*/		cpu::op::rlwinm<0,0,0,23>(regs,&regs.R9,regs.R11);
		/* 8209FA0Ch case    5:*/		return 0x8209FA10;
		  /* 8209FA10h */ case    6:  		/* cmplw CR6, R9, R10 */
		/* 8209FA10h case    6:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 8209FA10h case    6:*/		return 0x8209FA14;
		  /* 8209FA14h */ case    7:  		/* bc 12, CR6_EQ, 32 */
		/* 8209FA14h case    7:*/		if ( regs.CR[6].eq ) { return 0x8209FA34;  }
		/* 8209FA14h case    7:*/		return 0x8209FA18;
		  /* 8209FA18h */ case    8:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 8209FA18h case    8:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 8209FA18h case    8:*/		return 0x8209FA1C;
		  /* 8209FA1Ch */ case    9:  		/* lis R10, -2 */
		/* 8209FA1Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFE);
		/* 8209FA1Ch case    9:*/		return 0x8209FA20;
		  /* 8209FA20h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 8209FA20h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8209FA20h case   10:*/		return 0x8209FA24;
		  /* 8209FA24h */ case   11:  		/* bc 12, CR6_EQ, 16 */
		/* 8209FA24h case   11:*/		if ( regs.CR[6].eq ) { return 0x8209FA34;  }
		/* 8209FA24h case   11:*/		return 0x8209FA28;
		  /* 8209FA28h */ case   12:  		/* lis R10, -1 */
		/* 8209FA28h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8209FA28h case   12:*/		return 0x8209FA2C;
		  /* 8209FA2Ch */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 8209FA2Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8209FA2Ch case   13:*/		return 0x8209FA30;
		  /* 8209FA30h */ case   14:  		/* bc 4, CR6_EQ, 104 */
		/* 8209FA30h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8209FA98;  }
		/* 8209FA30h case   14:*/		return 0x8209FA34;
	}
	return 0x8209FA34;
} // Block from 8209F9F8h-8209FA34h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8209FA34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FA34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FA34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FA34);
		  /* 8209FA34h */ case    0:  		/* lis R4, 9345 */
		/* 8209FA34h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8209FA34h case    0:*/		return 0x8209FA38;
		  /* 8209FA38h */ case    1:  		/* li R3, 32 */
		/* 8209FA38h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x20);
		/* 8209FA38h case    1:*/		return 0x8209FA3C;
		  /* 8209FA3Ch */ case    2:  		/* bl -96316 */
		/* 8209FA3Ch case    2:*/		regs.LR = 0x8209FA40; return 0x82088200;
		/* 8209FA3Ch case    2:*/		return 0x8209FA40;
		  /* 8209FA40h */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 8209FA40h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8209FA40h case    3:*/		return 0x8209FA44;
		  /* 8209FA44h */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 8209FA44h case    4:*/		if ( regs.CR[0].eq ) { return 0x8209FA50;  }
		/* 8209FA44h case    4:*/		return 0x8209FA48;
		  /* 8209FA48h */ case    5:  		/* bl 166704 */
		/* 8209FA48h case    5:*/		regs.LR = 0x8209FA4C; return 0x820C8578;
		/* 8209FA48h case    5:*/		return 0x8209FA4C;
		  /* 8209FA4Ch */ case    6:  		/* mr R31, R3 */
		/* 8209FA4Ch case    6:*/		regs.R31 = regs.R3;
		/* 8209FA4Ch case    6:*/		return 0x8209FA50;
	}
	return 0x8209FA50;
} // Block from 8209FA34h-8209FA50h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209FA50h
// Function '?D3DXMemAlloc@@YAPAXK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FA50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FA50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FA50);
		  /* 8209FA50h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 8209FA50h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8209FA50h case    0:*/		return 0x8209FA54;
		  /* 8209FA54h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8209FA54h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209FA64;  }
		/* 8209FA54h case    1:*/		return 0x8209FA58;
	}
	return 0x8209FA58;
} // Block from 8209FA50h-8209FA58h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209FA58h
// Function '?D3DXMemFree@@YAXPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FA58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FA58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FA58);
		  /* 8209FA58h */ case    0:  		/* lis R3, -32761 */
		/* 8209FA58h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 8209FA58h case    0:*/		return 0x8209FA5C;
		  /* 8209FA5Ch */ case    1:  		/* ori R3, R3, 14 */
		/* 8209FA5Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 8209FA5Ch case    1:*/		return 0x8209FA60;
	}
	return 0x8209FA60;
} // Block from 8209FA58h-8209FA60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209FA60h
// Function '?Initialize@PreProcessorInitializeFromMemory@D3DXShader@@UAAJPAVCPreProcessor@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FA60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FA60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FA60);
		  /* 8209FA60h */ case    0:  		/* b 64 */
		/* 8209FA60h case    0:*/		return 0x8209FAA0;
		/* 8209FA60h case    0:*/		return 0x8209FA64;
	}
	return 0x8209FA64;
} // Block from 8209FA60h-8209FA64h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209FA64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FA64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FA64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FA64);
		  /* 8209FA64h */ case    0:  		/* li R5, 0 */
		/* 8209FA64h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8209FA64h case    0:*/		return 0x8209FA68;
		  /* 8209FA68h */ case    1:  		/* mr R4, R30 */
		/* 8209FA68h case    1:*/		regs.R4 = regs.R30;
		/* 8209FA68h case    1:*/		return 0x8209FA6C;
		  /* 8209FA6Ch */ case    2:  		/* mr R3, R31 */
		/* 8209FA6Ch case    2:*/		regs.R3 = regs.R31;
		/* 8209FA6Ch case    2:*/		return 0x8209FA70;
		  /* 8209FA70h */ case    3:  		/* bl 167976 */
		/* 8209FA70h case    3:*/		regs.LR = 0x8209FA74; return 0x820C8A98;
		/* 8209FA70h case    3:*/		return 0x8209FA74;
		  /* 8209FA74h */ case    4:  		/* or. R30, R3, R3 */
		/* 8209FA74h case    4:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 8209FA74h case    4:*/		return 0x8209FA78;
		  /* 8209FA78h */ case    5:  		/* bc 4, CR0_LT, 32 */
		/* 8209FA78h case    5:*/		if ( !regs.CR[0].lt ) { return 0x8209FA98;  }
		/* 8209FA78h case    5:*/		return 0x8209FA7C;
		  /* 8209FA7Ch */ case    6:  		/* mr R3, R31 */
		/* 8209FA7Ch case    6:*/		regs.R3 = regs.R31;
		/* 8209FA7Ch case    6:*/		return 0x8209FA80;
		  /* 8209FA80h */ case    7:  		/* bl 163032 */
		/* 8209FA80h case    7:*/		regs.LR = 0x8209FA84; return 0x820C7758;
		/* 8209FA80h case    7:*/		return 0x8209FA84;
		  /* 8209FA84h */ case    8:  		/* lis R4, 9345 */
		/* 8209FA84h case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8209FA84h case    8:*/		return 0x8209FA88;
	}
	return 0x8209FA88;
} // Block from 8209FA64h-8209FA88h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209FA88h
// Function '?D3DXCompileShader_Common3@@YAJPAVPreProcessorInitializer@D3DXShader@@PBDPAPBDKPAPAUID3DXBuffer@@3PAPAUID3DXConstantTable@@PAU_D3DXSHADER_COMPILE_PARAMETERSA@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FA88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FA88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FA88);
		  /* 8209FA88h */ case    0:  		/* mr R3, R31 */
		/* 8209FA88h case    0:*/		regs.R3 = regs.R31;
		/* 8209FA88h case    0:*/		return 0x8209FA8C;
		  /* 8209FA8Ch */ case    1:  		/* bl -96084 */
		/* 8209FA8Ch case    1:*/		regs.LR = 0x8209FA90; return 0x82088338;
		/* 8209FA8Ch case    1:*/		return 0x8209FA90;
		  /* 8209FA90h */ case    2:  		/* mr R3, R30 */
		/* 8209FA90h case    2:*/		regs.R3 = regs.R30;
		/* 8209FA90h case    2:*/		return 0x8209FA94;
		  /* 8209FA94h */ case    3:  		/* b 12 */
		/* 8209FA94h case    3:*/		return 0x8209FAA0;
		/* 8209FA94h case    3:*/		return 0x8209FA98;
	}
	return 0x8209FA98;
} // Block from 8209FA88h-8209FA98h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209FA98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FA98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FA98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FA98);
		  /* 8209FA98h */ case    0:  		/* li R3, 0 */
		/* 8209FA98h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209FA98h case    0:*/		return 0x8209FA9C;
		  /* 8209FA9Ch */ case    1:  		/* stw R31, <#[R29]> */
		/* 8209FA9Ch case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R29 + 0x00000000) );
		/* 8209FA9Ch case    1:*/		return 0x8209FAA0;
	}
	return 0x8209FAA0;
} // Block from 8209FA98h-8209FAA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209FAA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FAA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FAA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FAA0);
		  /* 8209FAA0h */ case    0:  		/* addi R1, R1, 112 */
		/* 8209FAA0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8209FAA0h case    0:*/		return 0x8209FAA4;
		  /* 8209FAA4h */ case    1:  		/* b -59384 */
		/* 8209FAA4h case    1:*/		return 0x820912AC;
		/* 8209FAA4h case    1:*/		return 0x8209FAA8;
		  /* 8209FAA8h */ case    2:  		/* b -232 */
		/* 8209FAA8h case    2:*/		return 0x8209F9C0;
		/* 8209FAA8h case    2:*/		return 0x8209FAAC;
		  /* 8209FAACh */ case    3:  		/* nop */
		/* 8209FAACh case    3:*/		cpu::op::nop();
		/* 8209FAACh case    3:*/		return 0x8209FAB0;
	}
	return 0x8209FAB0;
} // Block from 8209FAA0h-8209FAB0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209FAB0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FAB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FAB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FAB0);
		  /* 8209FAB0h */ case    0:  		/* mfspr R12, LR */
		/* 8209FAB0h case    0:*/		regs.R12 = regs.LR;
		/* 8209FAB0h case    0:*/		return 0x8209FAB4;
		  /* 8209FAB4h */ case    1:  		/* bl -59484 */
		/* 8209FAB4h case    1:*/		regs.LR = 0x8209FAB8; return 0x82091258;
		/* 8209FAB4h case    1:*/		return 0x8209FAB8;
		  /* 8209FAB8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8209FAB8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8209FAB8h case    2:*/		return 0x8209FABC;
		  /* 8209FABCh */ case    3:  		/* li R31, 0 */
		/* 8209FABCh case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8209FABCh case    3:*/		return 0x8209FAC0;
		  /* 8209FAC0h */ case    4:  		/* mr R30, R3 */
		/* 8209FAC0h case    4:*/		regs.R30 = regs.R3;
		/* 8209FAC0h case    4:*/		return 0x8209FAC4;
		  /* 8209FAC4h */ case    5:  		/* stw R31, <#[R5]> */
		/* 8209FAC4h case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R5 + 0x00000000) );
		/* 8209FAC4h case    5:*/		return 0x8209FAC8;
		  /* 8209FAC8h */ case    6:  		/* mr R29, R4 */
		/* 8209FAC8h case    6:*/		regs.R29 = regs.R4;
		/* 8209FAC8h case    6:*/		return 0x8209FACC;
		  /* 8209FACCh */ case    7:  		/* lis R4, 9345 */
		/* 8209FACCh case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8209FACCh case    7:*/		return 0x8209FAD0;
		  /* 8209FAD0h */ case    8:  		/* li R3, 32 */
		/* 8209FAD0h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x20);
		/* 8209FAD0h case    8:*/		return 0x8209FAD4;
		  /* 8209FAD4h */ case    9:  		/* mr R28, R5 */
		/* 8209FAD4h case    9:*/		regs.R28 = regs.R5;
		/* 8209FAD4h case    9:*/		return 0x8209FAD8;
		  /* 8209FAD8h */ case   10:  		/* bl -96472 */
		/* 8209FAD8h case   10:*/		regs.LR = 0x8209FADC; return 0x82088200;
		/* 8209FAD8h case   10:*/		return 0x8209FADC;
		  /* 8209FADCh */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 8209FADCh case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8209FADCh case   11:*/		return 0x8209FAE0;
		  /* 8209FAE0h */ case   12:  		/* bc 12, CR0_EQ, 12 */
		/* 8209FAE0h case   12:*/		if ( regs.CR[0].eq ) { return 0x8209FAEC;  }
		/* 8209FAE0h case   12:*/		return 0x8209FAE4;
		  /* 8209FAE4h */ case   13:  		/* bl 166548 */
		/* 8209FAE4h case   13:*/		regs.LR = 0x8209FAE8; return 0x820C8578;
		/* 8209FAE4h case   13:*/		return 0x8209FAE8;
		  /* 8209FAE8h */ case   14:  		/* mr R31, R3 */
		/* 8209FAE8h case   14:*/		regs.R31 = regs.R3;
		/* 8209FAE8h case   14:*/		return 0x8209FAEC;
	}
	return 0x8209FAEC;
} // Block from 8209FAB0h-8209FAECh (15 instructions)

//////////////////////////////////////////////////////
// Block at 8209FAECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FAEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FAEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FAEC);
		  /* 8209FAECh */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 8209FAECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8209FAECh case    0:*/		return 0x8209FAF0;
		  /* 8209FAF0h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8209FAF0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209FB00;  }
		/* 8209FAF0h case    1:*/		return 0x8209FAF4;
		  /* 8209FAF4h */ case    2:  		/* lis R3, -32761 */
		/* 8209FAF4h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 8209FAF4h case    2:*/		return 0x8209FAF8;
		  /* 8209FAF8h */ case    3:  		/* ori R3, R3, 14 */
		/* 8209FAF8h case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 8209FAF8h case    3:*/		return 0x8209FAFC;
		  /* 8209FAFCh */ case    4:  		/* b 68 */
		/* 8209FAFCh case    4:*/		return 0x8209FB40;
		/* 8209FAFCh case    4:*/		return 0x8209FB00;
	}
	return 0x8209FB00;
} // Block from 8209FAECh-8209FB00h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209FB00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FB00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FB00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FB00);
		  /* 8209FB00h */ case    0:  		/* li R6, 0 */
		/* 8209FB00h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8209FB00h case    0:*/		return 0x8209FB04;
		  /* 8209FB04h */ case    1:  		/* mr R5, R29 */
		/* 8209FB04h case    1:*/		regs.R5 = regs.R29;
		/* 8209FB04h case    1:*/		return 0x8209FB08;
		  /* 8209FB08h */ case    2:  		/* mr R4, R30 */
		/* 8209FB08h case    2:*/		regs.R4 = regs.R30;
		/* 8209FB08h case    2:*/		return 0x8209FB0C;
		  /* 8209FB0Ch */ case    3:  		/* mr R3, R31 */
		/* 8209FB0Ch case    3:*/		regs.R3 = regs.R31;
		/* 8209FB0Ch case    3:*/		return 0x8209FB10;
		  /* 8209FB10h */ case    4:  		/* bl 166552 */
		/* 8209FB10h case    4:*/		regs.LR = 0x8209FB14; return 0x820C85A8;
		/* 8209FB10h case    4:*/		return 0x8209FB14;
		  /* 8209FB14h */ case    5:  		/* or. R30, R3, R3 */
		/* 8209FB14h case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 8209FB14h case    5:*/		return 0x8209FB18;
		  /* 8209FB18h */ case    6:  		/* bc 4, CR0_LT, 32 */
		/* 8209FB18h case    6:*/		if ( !regs.CR[0].lt ) { return 0x8209FB38;  }
		/* 8209FB18h case    6:*/		return 0x8209FB1C;
		  /* 8209FB1Ch */ case    7:  		/* mr R3, R31 */
		/* 8209FB1Ch case    7:*/		regs.R3 = regs.R31;
		/* 8209FB1Ch case    7:*/		return 0x8209FB20;
		  /* 8209FB20h */ case    8:  		/* bl 162872 */
		/* 8209FB20h case    8:*/		regs.LR = 0x8209FB24; return 0x820C7758;
		/* 8209FB20h case    8:*/		return 0x8209FB24;
		  /* 8209FB24h */ case    9:  		/* lis R4, 9345 */
		/* 8209FB24h case    9:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 8209FB24h case    9:*/		return 0x8209FB28;
		  /* 8209FB28h */ case   10:  		/* mr R3, R31 */
		/* 8209FB28h case   10:*/		regs.R3 = regs.R31;
		/* 8209FB28h case   10:*/		return 0x8209FB2C;
		  /* 8209FB2Ch */ case   11:  		/* bl -96244 */
		/* 8209FB2Ch case   11:*/		regs.LR = 0x8209FB30; return 0x82088338;
		/* 8209FB2Ch case   11:*/		return 0x8209FB30;
		  /* 8209FB30h */ case   12:  		/* mr R3, R30 */
		/* 8209FB30h case   12:*/		regs.R3 = regs.R30;
		/* 8209FB30h case   12:*/		return 0x8209FB34;
		  /* 8209FB34h */ case   13:  		/* b 12 */
		/* 8209FB34h case   13:*/		return 0x8209FB40;
		/* 8209FB34h case   13:*/		return 0x8209FB38;
	}
	return 0x8209FB38;
} // Block from 8209FB00h-8209FB38h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209FB38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FB38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FB38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FB38);
		  /* 8209FB38h */ case    0:  		/* stw R31, <#[R28]> */
		/* 8209FB38h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R28 + 0x00000000) );
		/* 8209FB38h case    0:*/		return 0x8209FB3C;
		  /* 8209FB3Ch */ case    1:  		/* li R3, 0 */
		/* 8209FB3Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209FB3Ch case    1:*/		return 0x8209FB40;
	}
	return 0x8209FB40;
} // Block from 8209FB38h-8209FB40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209FB40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FB40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FB40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FB40);
		  /* 8209FB40h */ case    0:  		/* addi R1, R1, 128 */
		/* 8209FB40h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8209FB40h case    0:*/		return 0x8209FB44;
		  /* 8209FB44h */ case    1:  		/* b -59548 */
		/* 8209FB44h case    1:*/		return 0x820912A8;
		/* 8209FB44h case    1:*/		return 0x8209FB48;
	}
	return 0x8209FB48;
} // Block from 8209FB40h-8209FB48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209FB48h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FB48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FB48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FB48);
		  /* 8209FB48h */ case    0:  		/* mfspr R12, LR */
		/* 8209FB48h case    0:*/		regs.R12 = regs.LR;
		/* 8209FB48h case    0:*/		return 0x8209FB4C;
		  /* 8209FB4Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209FB4Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209FB4Ch case    1:*/		return 0x8209FB50;
		  /* 8209FB50h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8209FB50h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209FB50h case    2:*/		return 0x8209FB54;
		  /* 8209FB54h */ case    3:  		/* stwu R1, <#[R1 - 128]> */
		/* 8209FB54h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8209FB54h case    3:*/		return 0x8209FB58;
		  /* 8209FB58h */ case    4:  		/* lis R31, -32255 */
		/* 8209FB58h case    4:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8201);
		/* 8209FB58h case    4:*/		return 0x8209FB5C;
		  /* 8209FB5Ch */ case    5:  		/* stw R4, <#[R1 + 88]> */
		/* 8209FB5Ch case    5:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x00000058) );
		/* 8209FB5Ch case    5:*/		return 0x8209FB60;
		  /* 8209FB60h */ case    6:  		/* stw R3, <#[R1 + 84]> */
		/* 8209FB60h case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 8209FB60h case    6:*/		return 0x8209FB64;
		  /* 8209FB64h */ case    7:  		/* mr R11, R7 */
		/* 8209FB64h case    7:*/		regs.R11 = regs.R7;
		/* 8209FB64h case    7:*/		return 0x8209FB68;
		  /* 8209FB68h */ case    8:  		/* addi R4, R31, -14740 */
		/* 8209FB68h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0xFFFFC66C);
		/* 8209FB68h case    8:*/		return 0x8209FB6C;
		  /* 8209FB6Ch */ case    9:  		/* stw R5, <#[R1 + 92]> */
		/* 8209FB6Ch case    9:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x0000005C) );
		/* 8209FB6Ch case    9:*/		return 0x8209FB70;
		  /* 8209FB70h */ case   10:  		/* stw R6, <#[R1 + 96]> */
		/* 8209FB70h case   10:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x00000060) );
		/* 8209FB70h case   10:*/		return 0x8209FB74;
		  /* 8209FB74h */ case   11:  		/* mr R7, R10 */
		/* 8209FB74h case   11:*/		regs.R7 = regs.R10;
		/* 8209FB74h case   11:*/		return 0x8209FB78;
		  /* 8209FB78h */ case   12:  		/* stw R4, <#[R1 + 80]> */
		/* 8209FB78h case   12:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 8209FB78h case   12:*/		return 0x8209FB7C;
		  /* 8209FB7Ch */ case   13:  		/* mr R6, R9 */
		/* 8209FB7Ch case   13:*/		regs.R6 = regs.R9;
		/* 8209FB7Ch case   13:*/		return 0x8209FB80;
		  /* 8209FB80h */ case   14:  		/* mr R5, R8 */
		/* 8209FB80h case   14:*/		regs.R5 = regs.R8;
		/* 8209FB80h case   14:*/		return 0x8209FB84;
		  /* 8209FB84h */ case   15:  		/* lwz R9, <#[R1 + 220]> */
		/* 8209FB84h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000DC) );
		/* 8209FB84h case   15:*/		return 0x8209FB88;
		  /* 8209FB88h */ case   16:  		/* li R10, 0 */
		/* 8209FB88h case   16:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8209FB88h case   16:*/		return 0x8209FB8C;
		  /* 8209FB8Ch */ case   17:  		/* lwz R8, <#[R1 + 212]> */
		/* 8209FB8Ch case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x000000D4) );
		/* 8209FB8Ch case   17:*/		return 0x8209FB90;
		  /* 8209FB90h */ case   18:  		/* mr R4, R11 */
		/* 8209FB90h case   18:*/		regs.R4 = regs.R11;
		/* 8209FB90h case   18:*/		return 0x8209FB94;
		  /* 8209FB94h */ case   19:  		/* addi R3, R1, 80 */
		/* 8209FB94h case   19:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8209FB94h case   19:*/		return 0x8209FB98;
		  /* 8209FB98h */ case   20:  		/* bl -864 */
		/* 8209FB98h case   20:*/		regs.LR = 0x8209FB9C; return 0x8209F838;
		/* 8209FB98h case   20:*/		return 0x8209FB9C;
		  /* 8209FB9Ch */ case   21:  		/* addi R1, R1, 128 */
		/* 8209FB9Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8209FB9Ch case   21:*/		return 0x8209FBA0;
		  /* 8209FBA0h */ case   22:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209FBA0h case   22:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209FBA0h case   22:*/		return 0x8209FBA4;
		  /* 8209FBA4h */ case   23:  		/* mtspr LR, R12 */
		/* 8209FBA4h case   23:*/		regs.LR = regs.R12;
		/* 8209FBA4h case   23:*/		return 0x8209FBA8;
		  /* 8209FBA8h */ case   24:  		/* ld R31, <#[R1 - 16]> */
		/* 8209FBA8h case   24:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209FBA8h case   24:*/		return 0x8209FBAC;
		  /* 8209FBACh */ case   25:  		/* bclr 20, CR0_LT */
		/* 8209FBACh case   25:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209FBACh case   25:*/		return 0x8209FBB0;
	}
	return 0x8209FBB0;
} // Block from 8209FB48h-8209FBB0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8209FBB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FBB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FBB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FBB0);
		  /* 8209FBB0h */ case    0:  		/* mfspr R12, LR */
		/* 8209FBB0h case    0:*/		regs.R12 = regs.LR;
		/* 8209FBB0h case    0:*/		return 0x8209FBB4;
		  /* 8209FBB4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209FBB4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209FBB4h case    1:*/		return 0x8209FBB8;
		  /* 8209FBB8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8209FBB8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209FBB8h case    2:*/		return 0x8209FBBC;
		  /* 8209FBBCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209FBBCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209FBBCh case    3:*/		return 0x8209FBC0;
		  /* 8209FBC0h */ case    4:  		/* mr R31, R3 */
		/* 8209FBC0h case    4:*/		regs.R31 = regs.R3;
		/* 8209FBC0h case    4:*/		return 0x8209FBC4;
		  /* 8209FBC4h */ case    5:  		/* bl 25540 */
		/* 8209FBC4h case    5:*/		regs.LR = 0x8209FBC8; return 0x820A5F88;
		/* 8209FBC4h case    5:*/		return 0x8209FBC8;
		  /* 8209FBC8h */ case    6:  		/* addi R3, R31, 84 */
		/* 8209FBC8h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x54);
		/* 8209FBC8h case    6:*/		return 0x8209FBCC;
		  /* 8209FBCCh */ case    7:  		/* bl 168684 */
		/* 8209FBCCh case    7:*/		regs.LR = 0x8209FBD0; return 0x820C8EB8;
		/* 8209FBCCh case    7:*/		return 0x8209FBD0;
		  /* 8209FBD0h */ case    8:  		/* li R11, 0 */
		/* 8209FBD0h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209FBD0h case    8:*/		return 0x8209FBD4;
		  /* 8209FBD4h */ case    9:  		/* mr R3, R31 */
		/* 8209FBD4h case    9:*/		regs.R3 = regs.R31;
		/* 8209FBD4h case    9:*/		return 0x8209FBD8;
		  /* 8209FBD8h */ case   10:  		/* stw R11, <#[R31 + 80]> */
		/* 8209FBD8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8209FBD8h case   10:*/		return 0x8209FBDC;
		  /* 8209FBDCh */ case   11:  		/* stw R11, <#[R31 + 96]> */
		/* 8209FBDCh case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 8209FBDCh case   11:*/		return 0x8209FBE0;
		  /* 8209FBE0h */ case   12:  		/* stw R11, <#[R31 + 116]> */
		/* 8209FBE0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000074) );
		/* 8209FBE0h case   12:*/		return 0x8209FBE4;
		  /* 8209FBE4h */ case   13:  		/* stw R11, <#[R31 + 120]> */
		/* 8209FBE4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000078) );
		/* 8209FBE4h case   13:*/		return 0x8209FBE8;
		  /* 8209FBE8h */ case   14:  		/* stw R11, <#[R31 + 124]> */
		/* 8209FBE8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000007C) );
		/* 8209FBE8h case   14:*/		return 0x8209FBEC;
		  /* 8209FBECh */ case   15:  		/* stw R11, <#[R31 + 100]> */
		/* 8209FBECh case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000064) );
		/* 8209FBECh case   15:*/		return 0x8209FBF0;
		  /* 8209FBF0h */ case   16:  		/* stw R11, <#[R31 + 104]> */
		/* 8209FBF0h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 8209FBF0h case   16:*/		return 0x8209FBF4;
		  /* 8209FBF4h */ case   17:  		/* stw R11, <#[R31 + 128]> */
		/* 8209FBF4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000080) );
		/* 8209FBF4h case   17:*/		return 0x8209FBF8;
		  /* 8209FBF8h */ case   18:  		/* stw R11, <#[R31 + 132]> */
		/* 8209FBF8h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 8209FBF8h case   18:*/		return 0x8209FBFC;
		  /* 8209FBFCh */ case   19:  		/* addi R1, R1, 96 */
		/* 8209FBFCh case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209FBFCh case   19:*/		return 0x8209FC00;
		  /* 8209FC00h */ case   20:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209FC00h case   20:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209FC00h case   20:*/		return 0x8209FC04;
		  /* 8209FC04h */ case   21:  		/* mtspr LR, R12 */
		/* 8209FC04h case   21:*/		regs.LR = regs.R12;
		/* 8209FC04h case   21:*/		return 0x8209FC08;
		  /* 8209FC08h */ case   22:  		/* ld R31, <#[R1 - 16]> */
		/* 8209FC08h case   22:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209FC08h case   22:*/		return 0x8209FC0C;
		  /* 8209FC0Ch */ case   23:  		/* bclr 20, CR0_LT */
		/* 8209FC0Ch case   23:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209FC0Ch case   23:*/		return 0x8209FC10;
	}
	return 0x8209FC10;
} // Block from 8209FBB0h-8209FC10h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8209FC10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FC10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FC10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FC10);
		  /* 8209FC10h */ case    0:  		/* mfspr R12, LR */
		/* 8209FC10h case    0:*/		regs.R12 = regs.LR;
		/* 8209FC10h case    0:*/		return 0x8209FC14;
		  /* 8209FC14h */ case    1:  		/* bl -59844 */
		/* 8209FC14h case    1:*/		regs.LR = 0x8209FC18; return 0x82091250;
		/* 8209FC14h case    1:*/		return 0x8209FC18;
		  /* 8209FC18h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8209FC18h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8209FC18h case    2:*/		return 0x8209FC1C;
		  /* 8209FC1Ch */ case    3:  		/* mr R31, R3 */
		/* 8209FC1Ch case    3:*/		regs.R31 = regs.R3;
		/* 8209FC1Ch case    3:*/		return 0x8209FC20;
		  /* 8209FC20h */ case    4:  		/* mr R28, R4 */
		/* 8209FC20h case    4:*/		regs.R28 = regs.R4;
		/* 8209FC20h case    4:*/		return 0x8209FC24;
		  /* 8209FC24h */ case    5:  		/* mr R29, R5 */
		/* 8209FC24h case    5:*/		regs.R29 = regs.R5;
		/* 8209FC24h case    5:*/		return 0x8209FC28;
		  /* 8209FC28h */ case    6:  		/* li R26, 0 */
		/* 8209FC28h case    6:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8209FC28h case    6:*/		return 0x8209FC2C;
		  /* 8209FC2Ch */ case    7:  		/* mr R11, R5 */
		/* 8209FC2Ch case    7:*/		regs.R11 = regs.R5;
		/* 8209FC2Ch case    7:*/		return 0x8209FC30;
		  /* 8209FC30h */ case    8:  		/* lbz R10, <#[R11]> */
		/* 8209FC30h case    8:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209FC30h case    8:*/		return 0x8209FC34;
		  /* 8209FC34h */ case    9:  		/* addi R11, R11, 1 */
		/* 8209FC34h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209FC34h case    9:*/		return 0x8209FC38;
		  /* 8209FC38h */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 8209FC38h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8209FC38h case   10:*/		return 0x8209FC3C;
		  /* 8209FC3Ch */ case   11:  		/* bc 4, CR6_EQ, -12 */
		/* 8209FC3Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x8209FC30;  }
		/* 8209FC3Ch case   11:*/		return 0x8209FC40;
		  /* 8209FC40h */ case   12:  		/* subf R11, R29, R11 */
		/* 8209FC40h case   12:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 8209FC40h case   12:*/		return 0x8209FC44;
		  /* 8209FC44h */ case   13:  		/* li R5, 1 */
		/* 8209FC44h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8209FC44h case   13:*/		return 0x8209FC48;
		  /* 8209FC48h */ case   14:  		/* addi R11, R11, -1 */
		/* 8209FC48h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8209FC48h case   14:*/		return 0x8209FC4C;
		  /* 8209FC4Ch */ case   15:  		/* mr R3, R28 */
		/* 8209FC4Ch case   15:*/		regs.R3 = regs.R28;
		/* 8209FC4Ch case   15:*/		return 0x8209FC50;
		  /* 8209FC50h */ case   16:  		/* rlwinm R27, R11, 0, 0, 31 */
		/* 8209FC50h case   16:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R27,regs.R11);
		/* 8209FC50h case   16:*/		return 0x8209FC54;
		  /* 8209FC54h */ case   17:  		/* addi R30, R27, 1 */
		/* 8209FC54h case   17:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R27,0x1);
		/* 8209FC54h case   17:*/		return 0x8209FC58;
		  /* 8209FC58h */ case   18:  		/* mr R4, R30 */
		/* 8209FC58h case   18:*/		regs.R4 = regs.R30;
		/* 8209FC58h case   18:*/		return 0x8209FC5C;
		  /* 8209FC5Ch */ case   19:  		/* bl 169092 */
		/* 8209FC5Ch case   19:*/		regs.LR = 0x8209FC60; return 0x820C90E0;
		/* 8209FC5Ch case   19:*/		return 0x8209FC60;
		  /* 8209FC60h */ case   20:  		/* cmplwi CR0, R3, 0 */
		/* 8209FC60h case   20:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8209FC60h case   20:*/		return 0x8209FC64;
		  /* 8209FC64h */ case   21:  		/* stw R3, <#[R31 + 104]> */
		/* 8209FC64h case   21:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000068) );
		/* 8209FC64h case   21:*/		return 0x8209FC68;
		  /* 8209FC68h */ case   22:  		/* bc 12, CR0_EQ, 32 */
		/* 8209FC68h case   22:*/		if ( regs.CR[0].eq ) { return 0x8209FC88;  }
		/* 8209FC68h case   22:*/		return 0x8209FC6C;
		  /* 8209FC6Ch */ case   23:  		/* li R5, 1 */
		/* 8209FC6Ch case   23:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8209FC6Ch case   23:*/		return 0x8209FC70;
		  /* 8209FC70h */ case   24:  		/* mr R4, R30 */
		/* 8209FC70h case   24:*/		regs.R4 = regs.R30;
		/* 8209FC70h case   24:*/		return 0x8209FC74;
		  /* 8209FC74h */ case   25:  		/* mr R3, R28 */
		/* 8209FC74h case   25:*/		regs.R3 = regs.R28;
		/* 8209FC74h case   25:*/		return 0x8209FC78;
		  /* 8209FC78h */ case   26:  		/* bl 169064 */
		/* 8209FC78h case   26:*/		regs.LR = 0x8209FC7C; return 0x820C90E0;
		/* 8209FC78h case   26:*/		return 0x8209FC7C;
		  /* 8209FC7Ch */ case   27:  		/* cmplwi CR0, R3, 0 */
		/* 8209FC7Ch case   27:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8209FC7Ch case   27:*/		return 0x8209FC80;
		  /* 8209FC80h */ case   28:  		/* stw R3, <#[R31 + 100]> */
		/* 8209FC80h case   28:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000064) );
		/* 8209FC80h case   28:*/		return 0x8209FC84;
		  /* 8209FC84h */ case   29:  		/* bc 4, CR0_EQ, 16 */
		/* 8209FC84h case   29:*/		if ( !regs.CR[0].eq ) { return 0x8209FC94;  }
		/* 8209FC84h case   29:*/		return 0x8209FC88;
	}
	return 0x8209FC88;
} // Block from 8209FC10h-8209FC88h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8209FC88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FC88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FC88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FC88);
		  /* 8209FC88h */ case    0:  		/* lis R26, -32761 */
		/* 8209FC88h case    0:*/		cpu::op::lis<0>(regs,&regs.R26,0xFFFF8007);
		/* 8209FC88h case    0:*/		return 0x8209FC8C;
		  /* 8209FC8Ch */ case    1:  		/* ori R26, R26, 14 */
		/* 8209FC8Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R26,regs.R26,0xE);
		/* 8209FC8Ch case    1:*/		return 0x8209FC90;
		  /* 8209FC90h */ case    2:  		/* b 80 */
		/* 8209FC90h case    2:*/		return 0x8209FCE0;
		/* 8209FC90h case    2:*/		return 0x8209FC94;
	}
	return 0x8209FC94;
} // Block from 8209FC88h-8209FC94h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209FC94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FC94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FC94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FC94);
		  /* 8209FC94h */ case    0:  		/* mr R5, R30 */
		/* 8209FC94h case    0:*/		regs.R5 = regs.R30;
		/* 8209FC94h case    0:*/		return 0x8209FC98;
		  /* 8209FC98h */ case    1:  		/* lwz R3, <#[R31 + 104]> */
		/* 8209FC98h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000068) );
		/* 8209FC98h case    1:*/		return 0x8209FC9C;
		  /* 8209FC9Ch */ case    2:  		/* mr R4, R29 */
		/* 8209FC9Ch case    2:*/		regs.R4 = regs.R29;
		/* 8209FC9Ch case    2:*/		return 0x8209FCA0;
		  /* 8209FCA0h */ case    3:  		/* bl -53720 */
		/* 8209FCA0h case    3:*/		regs.LR = 0x8209FCA4; return 0x82092AC8;
		/* 8209FCA0h case    3:*/		return 0x8209FCA4;
		  /* 8209FCA4h */ case    4:  		/* li R4, 92 */
		/* 8209FCA4h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x5C);
		/* 8209FCA4h case    4:*/		return 0x8209FCA8;
		  /* 8209FCA8h */ case    5:  		/* lwz R3, <#[R31 + 104]> */
		/* 8209FCA8h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000068) );
		/* 8209FCA8h case    5:*/		return 0x8209FCAC;
		  /* 8209FCACh */ case    6:  		/* bl -51420 */
		/* 8209FCACh case    6:*/		regs.LR = 0x8209FCB0; return 0x820933D0;
		/* 8209FCACh case    6:*/		return 0x8209FCB0;
		  /* 8209FCB0h */ case    7:  		/* or. R29, R3, R3 */
		/* 8209FCB0h case    7:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 8209FCB0h case    7:*/		return 0x8209FCB4;
		  /* 8209FCB4h */ case    8:  		/* bc 12, CR0_EQ, 8 */
		/* 8209FCB4h case    8:*/		if ( regs.CR[0].eq ) { return 0x8209FCBC;  }
		/* 8209FCB4h case    8:*/		return 0x8209FCB8;
		  /* 8209FCB8h */ case    9:  		/* addi R29, R29, 1 */
		/* 8209FCB8h case    9:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8209FCB8h case    9:*/		return 0x8209FCBC;
	}
	return 0x8209FCBC;
} // Block from 8209FC94h-8209FCBCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 8209FCBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FCBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FCBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FCBC);
		  /* 8209FCBCh */ case    0:  		/* lwz R11, <#[R31 + 104]> */
		/* 8209FCBCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 8209FCBCh case    0:*/		return 0x8209FCC0;
		  /* 8209FCC0h */ case    1:  		/* mr R5, R30 */
		/* 8209FCC0h case    1:*/		regs.R5 = regs.R30;
		/* 8209FCC0h case    1:*/		return 0x8209FCC4;
		  /* 8209FCC4h */ case    2:  		/* stbx R26, <#[R11 + R27]> */
		/* 8209FCC4h case    2:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 8209FCC4h case    2:*/		return 0x8209FCC8;
		  /* 8209FCC8h */ case    3:  		/* lwz R4, <#[R31 + 104]> */
		/* 8209FCC8h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000068) );
		/* 8209FCC8h case    3:*/		return 0x8209FCCC;
		  /* 8209FCCCh */ case    4:  		/* lwz R3, <#[R31 + 100]> */
		/* 8209FCCCh case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000064) );
		/* 8209FCCCh case    4:*/		return 0x8209FCD0;
		  /* 8209FCD0h */ case    5:  		/* bl -58144 */
		/* 8209FCD0h case    5:*/		regs.LR = 0x8209FCD4; return 0x820919B0;
		/* 8209FCD0h case    5:*/		return 0x8209FCD4;
		  /* 8209FCD4h */ case    6:  		/* cmplwi CR6, R29, 0 */
		/* 8209FCD4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8209FCD4h case    6:*/		return 0x8209FCD8;
		  /* 8209FCD8h */ case    7:  		/* bc 12, CR6_EQ, 8 */
		/* 8209FCD8h case    7:*/		if ( regs.CR[6].eq ) { return 0x8209FCE0;  }
		/* 8209FCD8h case    7:*/		return 0x8209FCDC;
		  /* 8209FCDCh */ case    8:  		/* stb R26, <#[R29]> */
		/* 8209FCDCh case    8:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R29 + 0x00000000) );
		/* 8209FCDCh case    8:*/		return 0x8209FCE0;
	}
	return 0x8209FCE0;
} // Block from 8209FCBCh-8209FCE0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8209FCE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FCE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FCE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FCE0);
		  /* 8209FCE0h */ case    0:  		/* mr R3, R26 */
		/* 8209FCE0h case    0:*/		regs.R3 = regs.R26;
		/* 8209FCE0h case    0:*/		return 0x8209FCE4;
		  /* 8209FCE4h */ case    1:  		/* addi R1, R1, 144 */
		/* 8209FCE4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8209FCE4h case    1:*/		return 0x8209FCE8;
		  /* 8209FCE8h */ case    2:  		/* b -59976 */
		/* 8209FCE8h case    2:*/		return 0x820912A0;
		/* 8209FCE8h case    2:*/		return 0x8209FCEC;
		  /* 8209FCECh */ case    3:  		/* nop */
		/* 8209FCECh case    3:*/		cpu::op::nop();
		/* 8209FCECh case    3:*/		return 0x8209FCF0;
	}
	return 0x8209FCF0;
} // Block from 8209FCE0h-8209FCF0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8209FCF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FCF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FCF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FCF0);
		  /* 8209FCF0h */ case    0:  		/* mfspr R12, LR */
		/* 8209FCF0h case    0:*/		regs.R12 = regs.LR;
		/* 8209FCF0h case    0:*/		return 0x8209FCF4;
		  /* 8209FCF4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209FCF4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209FCF4h case    1:*/		return 0x8209FCF8;
		  /* 8209FCF8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8209FCF8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209FCF8h case    2:*/		return 0x8209FCFC;
		  /* 8209FCFCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209FCFCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209FCFCh case    3:*/		return 0x8209FD00;
		  /* 8209FD00h */ case    4:  		/* mr R31, R3 */
		/* 8209FD00h case    4:*/		regs.R31 = regs.R3;
		/* 8209FD00h case    4:*/		return 0x8209FD04;
		  /* 8209FD04h */ case    5:  		/* lwz R3, <#[R3 + 96]> */
		/* 8209FD04h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000060) );
		/* 8209FD04h case    5:*/		return 0x8209FD08;
		  /* 8209FD08h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 8209FD08h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8209FD08h case    6:*/		return 0x8209FD0C;
		  /* 8209FD0Ch */ case    7:  		/* bc 12, CR6_EQ, 40 */
		/* 8209FD0Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x8209FD34;  }
		/* 8209FD0Ch case    7:*/		return 0x8209FD10;
		  /* 8209FD10h */ case    8:  		/* lwz R4, <#[R31 + 116]> */
		/* 8209FD10h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000074) );
		/* 8209FD10h case    8:*/		return 0x8209FD14;
		  /* 8209FD14h */ case    9:  		/* cmplwi CR6, R4, 0 */
		/* 8209FD14h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8209FD14h case    9:*/		return 0x8209FD18;
		  /* 8209FD18h */ case   10:  		/* bc 12, CR6_EQ, 28 */
		/* 8209FD18h case   10:*/		if ( regs.CR[6].eq ) { return 0x8209FD34;  }
		/* 8209FD18h case   10:*/		return 0x8209FD1C;
		  /* 8209FD1Ch */ case   11:  		/* lwz R11, <#[R3]> */
		/* 8209FD1Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8209FD1Ch case   11:*/		return 0x8209FD20;
		  /* 8209FD20h */ case   12:  		/* lwz R11, <#[R11 + 4]> */
		/* 8209FD20h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8209FD20h case   12:*/		return 0x8209FD24;
		  /* 8209FD24h */ case   13:  		/* mtspr CTR, R11 */
		/* 8209FD24h case   13:*/		regs.CTR = regs.R11;
		/* 8209FD24h case   13:*/		return 0x8209FD28;
		  /* 8209FD28h */ case   14:  		/* bcctrl 20, CR0_LT */
		/* 8209FD28h case   14:*/		if ( 1 ) { regs.LR = 0x8209FD2C; return (uint32)regs.CTR; }
		/* 8209FD28h case   14:*/		return 0x8209FD2C;
		  /* 8209FD2Ch */ case   15:  		/* li R11, 0 */
		/* 8209FD2Ch case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209FD2Ch case   15:*/		return 0x8209FD30;
		  /* 8209FD30h */ case   16:  		/* stw R11, <#[R31 + 116]> */
		/* 8209FD30h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000074) );
		/* 8209FD30h case   16:*/		return 0x8209FD34;
	}
	return 0x8209FD34;
} // Block from 8209FCF0h-8209FD34h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8209FD34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FD34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FD34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FD34);
		  /* 8209FD34h */ case    0:  		/* addi R1, R1, 96 */
		/* 8209FD34h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209FD34h case    0:*/		return 0x8209FD38;
		  /* 8209FD38h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209FD38h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209FD38h case    1:*/		return 0x8209FD3C;
		  /* 8209FD3Ch */ case    2:  		/* mtspr LR, R12 */
		/* 8209FD3Ch case    2:*/		regs.LR = regs.R12;
		/* 8209FD3Ch case    2:*/		return 0x8209FD40;
		  /* 8209FD40h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8209FD40h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209FD40h case    3:*/		return 0x8209FD44;
		  /* 8209FD44h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8209FD44h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209FD44h case    4:*/		return 0x8209FD48;
	}
	return 0x8209FD48;
} // Block from 8209FD34h-8209FD48h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209FD48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FD48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FD48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FD48);
		  /* 8209FD48h */ case    0:  		/* mfspr R12, LR */
		/* 8209FD48h case    0:*/		regs.R12 = regs.LR;
		/* 8209FD48h case    0:*/		return 0x8209FD4C;
		  /* 8209FD4Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209FD4Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209FD4Ch case    1:*/		return 0x8209FD50;
		  /* 8209FD50h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8209FD50h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209FD50h case    2:*/		return 0x8209FD54;
		  /* 8209FD54h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8209FD54h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209FD54h case    3:*/		return 0x8209FD58;
		  /* 8209FD58h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8209FD58h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8209FD58h case    4:*/		return 0x8209FD5C;
		  /* 8209FD5Ch */ case    5:  		/* mr R31, R3 */
		/* 8209FD5Ch case    5:*/		regs.R31 = regs.R3;
		/* 8209FD5Ch case    5:*/		return 0x8209FD60;
		  /* 8209FD60h */ case    6:  		/* bl 185072 */
		/* 8209FD60h case    6:*/		regs.LR = 0x8209FD64; return 0x820CD050;
		/* 8209FD60h case    6:*/		return 0x8209FD64;
		  /* 8209FD64h */ case    7:  		/* or. R30, R3, R3 */
		/* 8209FD64h case    7:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 8209FD64h case    7:*/		return 0x8209FD68;
		  /* 8209FD68h */ case    8:  		/* bc 12, CR0_LT, 24 */
		/* 8209FD68h case    8:*/		if ( regs.CR[0].lt ) { return 0x8209FD80;  }
		/* 8209FD68h case    8:*/		return 0x8209FD6C;
		  /* 8209FD6Ch */ case    9:  		/* li R11, 1 */
		/* 8209FD6Ch case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8209FD6Ch case    9:*/		return 0x8209FD70;
		  /* 8209FD70h */ case   10:  		/* mr R3, R31 */
		/* 8209FD70h case   10:*/		regs.R3 = regs.R31;
		/* 8209FD70h case   10:*/		return 0x8209FD74;
		  /* 8209FD74h */ case   11:  		/* stw R11, <#[R31 + 2264]> */
		/* 8209FD74h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000008D8) );
		/* 8209FD74h case   11:*/		return 0x8209FD78;
		  /* 8209FD78h */ case   12:  		/* bl 169008 */
		/* 8209FD78h case   12:*/		regs.LR = 0x8209FD7C; return 0x820C91A8;
		/* 8209FD78h case   12:*/		return 0x8209FD7C;
		  /* 8209FD7Ch */ case   13:  		/* stw R3, <#[R31 + 2268]> */
		/* 8209FD7Ch case   13:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000008DC) );
		/* 8209FD7Ch case   13:*/		return 0x8209FD80;
	}
	return 0x8209FD80;
} // Block from 8209FD48h-8209FD80h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209FD80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FD80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FD80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FD80);
		  /* 8209FD80h */ case    0:  		/* stw R30, <#[R31 + 2260]> */
		/* 8209FD80h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x000008D4) );
		/* 8209FD80h case    0:*/		return 0x8209FD84;
		  /* 8209FD84h */ case    1:  		/* addi R1, R1, 112 */
		/* 8209FD84h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8209FD84h case    1:*/		return 0x8209FD88;
		  /* 8209FD88h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209FD88h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209FD88h case    2:*/		return 0x8209FD8C;
		  /* 8209FD8Ch */ case    3:  		/* mtspr LR, R12 */
		/* 8209FD8Ch case    3:*/		regs.LR = regs.R12;
		/* 8209FD8Ch case    3:*/		return 0x8209FD90;
		  /* 8209FD90h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 8209FD90h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209FD90h case    4:*/		return 0x8209FD94;
		  /* 8209FD94h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 8209FD94h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209FD94h case    5:*/		return 0x8209FD98;
		  /* 8209FD98h */ case    6:  		/* bclr 20, CR0_LT */
		/* 8209FD98h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209FD98h case    6:*/		return 0x8209FD9C;
	}
	return 0x8209FD9C;
} // Block from 8209FD80h-8209FD9Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209FD9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FD9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FD9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FD9C);
		  /* 8209FD9Ch */ case    0:  		/* nop */
		/* 8209FD9Ch case    0:*/		cpu::op::nop();
		/* 8209FD9Ch case    0:*/		return 0x8209FDA0;
	}
	return 0x8209FDA0;
} // Block from 8209FD9Ch-8209FDA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209FDA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FDA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FDA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FDA0);
		  /* 8209FDA0h */ case    0:  		/* mfspr R12, LR */
		/* 8209FDA0h case    0:*/		regs.R12 = regs.LR;
		/* 8209FDA0h case    0:*/		return 0x8209FDA4;
		  /* 8209FDA4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209FDA4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209FDA4h case    1:*/		return 0x8209FDA8;
	}
	return 0x8209FDA8;
} // Block from 8209FDA0h-8209FDA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209FDA8h
// Function '?D3DXCompileShader_Common2@@YAJPAVPreProcessorInitializer@D3DXShader@@PBDPAPBDKPAPAUID3DXBuffer@@3PAPAUID3DXConstantTable@@PAU_D3DXSHADER_COMPILE_PARAMETERSA@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FDA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FDA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FDA8);
		  /* 8209FDA8h */ case    0:  		/* std R31, <#[R1 - 16]> */
		/* 8209FDA8h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209FDA8h case    0:*/		return 0x8209FDAC;
		  /* 8209FDACh */ case    1:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209FDACh case    1:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209FDACh case    1:*/		return 0x8209FDB0;
		  /* 8209FDB0h */ case    2:  		/* lwz R11, <#[R3 + 2264]> */
		/* 8209FDB0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000008D8) );
		/* 8209FDB0h case    2:*/		return 0x8209FDB4;
		  /* 8209FDB4h */ case    3:  		/* mr R31, R3 */
		/* 8209FDB4h case    3:*/		regs.R31 = regs.R3;
		/* 8209FDB4h case    3:*/		return 0x8209FDB8;
		  /* 8209FDB8h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 8209FDB8h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8209FDB8h case    4:*/		return 0x8209FDBC;
		  /* 8209FDBCh */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 8209FDBCh case    5:*/		if ( regs.CR[6].eq ) { return 0x8209FDD4;  }
		/* 8209FDBCh case    5:*/		return 0x8209FDC0;
		  /* 8209FDC0h */ case    6:  		/* lwz R3, <#[R3 + 2268]> */
		/* 8209FDC0h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x000008DC) );
		/* 8209FDC0h case    6:*/		return 0x8209FDC4;
		  /* 8209FDC4h */ case    7:  		/* bl 168932 */
		/* 8209FDC4h case    7:*/		regs.LR = 0x8209FDC8; return 0x820C91A8;
		/* 8209FDC4h case    7:*/		return 0x8209FDC8;
		  /* 8209FDC8h */ case    8:  		/* bl 185312 */
		/* 8209FDC8h case    8:*/		regs.LR = 0x8209FDCC; return 0x820CD1A8;
		/* 8209FDC8h case    8:*/		return 0x8209FDCC;
		  /* 8209FDCCh */ case    9:  		/* li R11, 0 */
		/* 8209FDCCh case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209FDCCh case    9:*/		return 0x8209FDD0;
		  /* 8209FDD0h */ case   10:  		/* stw R11, <#[R31 + 2264]> */
		/* 8209FDD0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000008D8) );
		/* 8209FDD0h case   10:*/		return 0x8209FDD4;
	}
	return 0x8209FDD4;
} // Block from 8209FDA8h-8209FDD4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8209FDD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FDD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FDD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FDD4);
		  /* 8209FDD4h */ case    0:  		/* addi R1, R1, 96 */
		/* 8209FDD4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8209FDD4h case    0:*/		return 0x8209FDD8;
		  /* 8209FDD8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209FDD8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209FDD8h case    1:*/		return 0x8209FDDC;
		  /* 8209FDDCh */ case    2:  		/* mtspr LR, R12 */
		/* 8209FDDCh case    2:*/		regs.LR = regs.R12;
		/* 8209FDDCh case    2:*/		return 0x8209FDE0;
		  /* 8209FDE0h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8209FDE0h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209FDE0h case    3:*/		return 0x8209FDE4;
		  /* 8209FDE4h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8209FDE4h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209FDE4h case    4:*/		return 0x8209FDE8;
	}
	return 0x8209FDE8;
} // Block from 8209FDD4h-8209FDE8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209FDE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FDE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FDE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FDE8);
		  /* 8209FDE8h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 8209FDE8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8209FDE8h case    0:*/		return 0x8209FDEC;
		  /* 8209FDECh */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8209FDECh case    1:*/		if ( regs.CR[6].eq ) { return 0x8209FDFC;  }
		/* 8209FDECh case    1:*/		return 0x8209FDF0;
		  /* 8209FDF0h */ case    2:  		/* lwz R11, <#[R3 + 2204]> */
		/* 8209FDF0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000089C) );
		/* 8209FDF0h case    2:*/		return 0x8209FDF4;
		  /* 8209FDF4h */ case    3:  		/* lwz R11, <#[R11 + 32]> */
		/* 8209FDF4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 8209FDF4h case    3:*/		return 0x8209FDF8;
		  /* 8209FDF8h */ case    4:  		/* stw R11, <#[R4]> */
		/* 8209FDF8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8209FDF8h case    4:*/		return 0x8209FDFC;
	}
	return 0x8209FDFC;
} // Block from 8209FDE8h-8209FDFCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209FDFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FDFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FDFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FDFC);
		  /* 8209FDFCh */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 8209FDFCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8209FDFCh case    0:*/		return 0x8209FE00;
		  /* 8209FE00h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8209FE00h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209FE10;  }
		/* 8209FE00h case    1:*/		return 0x8209FE04;
		  /* 8209FE04h */ case    2:  		/* lwz R11, <#[R3 + 2204]> */
		/* 8209FE04h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000089C) );
		/* 8209FE04h case    2:*/		return 0x8209FE08;
		  /* 8209FE08h */ case    3:  		/* lwz R11, <#[R11 + 40]> */
		/* 8209FE08h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8209FE08h case    3:*/		return 0x8209FE0C;
		  /* 8209FE0Ch */ case    4:  		/* stw R11, <#[R5]> */
		/* 8209FE0Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8209FE0Ch case    4:*/		return 0x8209FE10;
	}
	return 0x8209FE10;
} // Block from 8209FDFCh-8209FE10h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209FE10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FE10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FE10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FE10);
		  /* 8209FE10h */ case    0:  		/* li R3, 0 */
		/* 8209FE10h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209FE10h case    0:*/		return 0x8209FE14;
		  /* 8209FE14h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8209FE14h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209FE14h case    1:*/		return 0x8209FE18;
	}
	return 0x8209FE18;
} // Block from 8209FE10h-8209FE18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209FE18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FE18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FE18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FE18);
		  /* 8209FE18h */ case    0:  		/* lwz R11, <#[R3 + 2196]> */
		/* 8209FE18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000894) );
		/* 8209FE18h case    0:*/		return 0x8209FE1C;
		  /* 8209FE1Ch */ case    1:  		/* lwz R10, <#[R11 + 128]> */
		/* 8209FE1Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000080) );
		/* 8209FE1Ch case    1:*/		return 0x8209FE20;
		  /* 8209FE20h */ case    2:  		/* b 12 */
		/* 8209FE20h case    2:*/		return 0x8209FE2C;
		/* 8209FE20h case    2:*/		return 0x8209FE24;
		  /* 8209FE24h */ case    3:  		/* mr R11, R10 */
		/* 8209FE24h case    3:*/		regs.R11 = regs.R10;
		/* 8209FE24h case    3:*/		return 0x8209FE28;
		  /* 8209FE28h */ case    4:  		/* lwz R10, <#[R10 + 128]> */
		/* 8209FE28h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000080) );
		/* 8209FE28h case    4:*/		return 0x8209FE2C;
	}
	return 0x8209FE2C;
} // Block from 8209FE18h-8209FE2Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8209FE2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FE2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FE2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FE2C);
		  /* 8209FE2Ch */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 8209FE2Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8209FE2Ch case    0:*/		return 0x8209FE30;
		  /* 8209FE30h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 8209FE30h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209FE24;  }
		/* 8209FE30h case    1:*/		return 0x8209FE34;
		  /* 8209FE34h */ case    2:  		/* cmplwi CR6, R4, 0 */
		/* 8209FE34h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8209FE34h case    2:*/		return 0x8209FE38;
		  /* 8209FE38h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 8209FE38h case    3:*/		if ( regs.CR[6].eq ) { return 0x8209FE44;  }
		/* 8209FE38h case    3:*/		return 0x8209FE3C;
		  /* 8209FE3Ch */ case    4:  		/* lwz R10, <#[R11]> */
		/* 8209FE3Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8209FE3Ch case    4:*/		return 0x8209FE40;
		  /* 8209FE40h */ case    5:  		/* stw R10, <#[R4]> */
		/* 8209FE40h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 8209FE40h case    5:*/		return 0x8209FE44;
	}
	return 0x8209FE44;
} // Block from 8209FE2Ch-8209FE44h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8209FE44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FE44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FE44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FE44);
		  /* 8209FE44h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 8209FE44h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8209FE44h case    0:*/		return 0x8209FE48;
		  /* 8209FE48h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 8209FE48h case    1:*/		if ( regs.CR[6].eq ) { return 0x8209FE68;  }
		/* 8209FE48h case    1:*/		return 0x8209FE4C;
		  /* 8209FE4Ch */ case    2:  		/* lwz R10, <#[R11 + 8]> */
		/* 8209FE4Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8209FE4Ch case    2:*/		return 0x8209FE50;
		  /* 8209FE50h */ case    3:  		/* lwz R11, <#[R11]> */
		/* 8209FE50h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8209FE50h case    3:*/		return 0x8209FE54;
		  /* 8209FE54h */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 8209FE54h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8209FE54h case    4:*/		return 0x8209FE58;
		  /* 8209FE58h */ case    5:  		/* subf R11, R11, R10 */
		/* 8209FE58h case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8209FE58h case    5:*/		return 0x8209FE5C;
		  /* 8209FE5Ch */ case    6:  		/* bc 4, CR6_LT, 8 */
		/* 8209FE5Ch case    6:*/		if ( !regs.CR[6].lt ) { return 0x8209FE64;  }
		/* 8209FE5Ch case    6:*/		return 0x8209FE60;
		  /* 8209FE60h */ case    7:  		/* li R11, 0 */
		/* 8209FE60h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8209FE60h case    7:*/		return 0x8209FE64;
	}
	return 0x8209FE64;
} // Block from 8209FE44h-8209FE64h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209FE64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FE64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FE64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FE64);
		  /* 8209FE64h */ case    0:  		/* stw R11, <#[R5]> */
		/* 8209FE64h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8209FE64h case    0:*/		return 0x8209FE68;
	}
	return 0x8209FE68;
} // Block from 8209FE64h-8209FE68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8209FE68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FE68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FE68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FE68);
		  /* 8209FE68h */ case    0:  		/* li R3, 0 */
		/* 8209FE68h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209FE68h case    0:*/		return 0x8209FE6C;
		  /* 8209FE6Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8209FE6Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209FE6Ch case    1:*/		return 0x8209FE70;
	}
	return 0x8209FE70;
} // Block from 8209FE68h-8209FE70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209FE70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FE70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FE70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FE70);
		  /* 8209FE70h */ case    0:  		/* mfspr R12, LR */
		/* 8209FE70h case    0:*/		regs.R12 = regs.LR;
		/* 8209FE70h case    0:*/		return 0x8209FE74;
		  /* 8209FE74h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209FE74h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209FE74h case    1:*/		return 0x8209FE78;
		  /* 8209FE78h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8209FE78h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209FE78h case    2:*/		return 0x8209FE7C;
		  /* 8209FE7Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8209FE7Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209FE7Ch case    3:*/		return 0x8209FE80;
		  /* 8209FE80h */ case    4:  		/* stwu R1, <#[R1 - 368]> */
		/* 8209FE80h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE90);
		/* 8209FE80h case    4:*/		return 0x8209FE84;
		  /* 8209FE84h */ case    5:  		/* mr R30, R3 */
		/* 8209FE84h case    5:*/		regs.R30 = regs.R3;
		/* 8209FE84h case    5:*/		return 0x8209FE88;
		  /* 8209FE88h */ case    6:  		/* lwz R3, <#[R3 + 2204]> */
		/* 8209FE88h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000089C) );
		/* 8209FE88h case    6:*/		return 0x8209FE8C;
		  /* 8209FE8Ch */ case    7:  		/* li R4, 0 */
		/* 8209FE8Ch case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8209FE8Ch case    7:*/		return 0x8209FE90;
		  /* 8209FE90h */ case    8:  		/* lwz R31, <#[R3]> */
		/* 8209FE90h case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 8209FE90h case    8:*/		return 0x8209FE94;
		  /* 8209FE94h */ case    9:  		/* bl 30412 */
		/* 8209FE94h case    9:*/		regs.LR = 0x8209FE98; return 0x820A7560;
		/* 8209FE94h case    9:*/		return 0x8209FE98;
		  /* 8209FE98h */ case   10:  		/* lwz R11, <#[R30 + 1652]> */
		/* 8209FE98h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000674) );
		/* 8209FE98h case   10:*/		return 0x8209FE9C;
		  /* 8209FE9Ch */ case   11:  		/* cmpwi CR6, R11, 0 */
		/* 8209FE9Ch case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8209FE9Ch case   11:*/		return 0x8209FEA0;
		  /* 8209FEA0h */ case   12:  		/* bc 12, CR6_EQ, 284 */
		/* 8209FEA0h case   12:*/		if ( regs.CR[6].eq ) { return 0x8209FFBC;  }
		/* 8209FEA0h case   12:*/		return 0x8209FEA4;
		  /* 8209FEA4h */ case   13:  		/* lwz R6, <#[R30 + 2204]> */
		/* 8209FEA4h case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x0000089C) );
		/* 8209FEA4h case   13:*/		return 0x8209FEA8;
		  /* 8209FEA8h */ case   14:  		/* lwz R11, <#[R6]> */
		/* 8209FEA8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 8209FEA8h case   14:*/		return 0x8209FEAC;
		  /* 8209FEACh */ case   15:  		/* b 40 */
		/* 8209FEACh case   15:*/		return 0x8209FED4;
		/* 8209FEACh case   15:*/		return 0x8209FEB0;
		  /* 8209FEB0h */ case   16:  		/* lbz R11, <#[R31]> */
		/* 8209FEB0h case   16:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8209FEB0h case   16:*/		return 0x8209FEB4;
		  /* 8209FEB4h */ case   17:  		/* extsb R11, R11 */
		/* 8209FEB4h case   17:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 8209FEB4h case   17:*/		return 0x8209FEB8;
		  /* 8209FEB8h */ case   18:  		/* cmpwi CR6, R11, 32 */
		/* 8209FEB8h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000020);
		/* 8209FEB8h case   18:*/		return 0x8209FEBC;
		  /* 8209FEBCh */ case   19:  		/* bc 12, CR6_EQ, 12 */
		/* 8209FEBCh case   19:*/		if ( regs.CR[6].eq ) { return 0x8209FEC8;  }
		/* 8209FEBCh case   19:*/		return 0x8209FEC0;
		  /* 8209FEC0h */ case   20:  		/* cmpwi CR6, R11, 9 */
		/* 8209FEC0h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000009);
		/* 8209FEC0h case   20:*/		return 0x8209FEC4;
		  /* 8209FEC4h */ case   21:  		/* bc 4, CR6_EQ, 24 */
		/* 8209FEC4h case   21:*/		if ( !regs.CR[6].eq ) { return 0x8209FEDC;  }
		/* 8209FEC4h case   21:*/		return 0x8209FEC8;
	}
	return 0x8209FEC8;
} // Block from 8209FE70h-8209FEC8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8209FEC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FEC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FEC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FEC8);
		  /* 8209FEC8h */ case    0:  		/* lwz R11, <#[R30 + 2204]> */
		/* 8209FEC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000089C) );
		/* 8209FEC8h case    0:*/		return 0x8209FECC;
		  /* 8209FECCh */ case    1:  		/* addi R31, R31, 1 */
		/* 8209FECCh case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8209FECCh case    1:*/		return 0x8209FED0;
		  /* 8209FED0h */ case    2:  		/* lwz R11, <#[R11]> */
		/* 8209FED0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8209FED0h case    2:*/		return 0x8209FED4;
	}
	return 0x8209FED4;
} // Block from 8209FEC8h-8209FED4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8209FED4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FED4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FED4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FED4);
		  /* 8209FED4h */ case    0:  		/* cmplw CR6, R31, R11 */
		/* 8209FED4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8209FED4h case    0:*/		return 0x8209FED8;
		  /* 8209FED8h */ case    1:  		/* bc 12, CR6_LT, -40 */
		/* 8209FED8h case    1:*/		if ( regs.CR[6].lt ) { return 0x8209FEB0;  }
		/* 8209FED8h case    1:*/		return 0x8209FEDC;
	}
	return 0x8209FEDC;
} // Block from 8209FED4h-8209FEDCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209FEDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FEDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FEDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FEDC);
		  /* 8209FEDCh */ case    0:  		/* li R5, 0 */
		/* 8209FEDCh case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8209FEDCh case    0:*/		return 0x8209FEE0;
		  /* 8209FEE0h */ case    1:  		/* addi R10, R31, 2 */
		/* 8209FEE0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x2);
		/* 8209FEE0h case    1:*/		return 0x8209FEE4;
		  /* 8209FEE4h */ case    2:  		/* addi R11, R31, 1 */
		/* 8209FEE4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x1);
		/* 8209FEE4h case    2:*/		return 0x8209FEE8;
		  /* 8209FEE8h */ case    3:  		/* lwz R9, <#[R6]> */
		/* 8209FEE8h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000000) );
		/* 8209FEE8h case    3:*/		return 0x8209FEEC;
		  /* 8209FEECh */ case    4:  		/* cmplw CR6, R31, R9 */
		/* 8209FEECh case    4:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R9);
		/* 8209FEECh case    4:*/		return 0x8209FEF0;
		  /* 8209FEF0h */ case    5:  		/* bc 4, CR6_LT, 152 */
		/* 8209FEF0h case    5:*/		if ( !regs.CR[6].lt ) { return 0x8209FF88;  }
		/* 8209FEF0h case    5:*/		return 0x8209FEF4;
		  /* 8209FEF4h */ case    6:  		/* lbz R8, <#[R31]> */
		/* 8209FEF4h case    6:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 8209FEF4h case    6:*/		return 0x8209FEF8;
		  /* 8209FEF8h */ case    7:  		/* extsb R7, R8 */
		/* 8209FEF8h case    7:*/		cpu::op::extsb<0>(regs,&regs.R7,regs.R8);
		/* 8209FEF8h case    7:*/		return 0x8209FEFC;
		  /* 8209FEFCh */ case    8:  		/* cmpwi CR6, R7, 92 */
		/* 8209FEFCh case    8:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x0000005C);
		/* 8209FEFCh case    8:*/		return 0x8209FF00;
		  /* 8209FF00h */ case    9:  		/* bc 4, CR6_EQ, 96 */
		/* 8209FF00h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8209FF60;  }
		/* 8209FF00h case    9:*/		return 0x8209FF04;
		  /* 8209FF04h */ case   10:  		/* cmplw CR6, R11, R9 */
		/* 8209FF04h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8209FF04h case   10:*/		return 0x8209FF08;
		  /* 8209FF08h */ case   11:  		/* bc 4, CR6_LT, 32 */
		/* 8209FF08h case   11:*/		if ( !regs.CR[6].lt ) { return 0x8209FF28;  }
		/* 8209FF08h case   11:*/		return 0x8209FF0C;
		  /* 8209FF0Ch */ case   12:  		/* lbz R4, <#[R11]> */
		/* 8209FF0Ch case   12:*/		cpu::mem::load8z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 8209FF0Ch case   12:*/		return 0x8209FF10;
		  /* 8209FF10h */ case   13:  		/* cmplwi CR6, R4, 10 */
		/* 8209FF10h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000000A);
		/* 8209FF10h case   13:*/		return 0x8209FF14;
		  /* 8209FF14h */ case   14:  		/* bc 4, CR6_EQ, 20 */
		/* 8209FF14h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8209FF28;  }
		/* 8209FF14h case   14:*/		return 0x8209FF18;
		  /* 8209FF18h */ case   15:  		/* addi R31, R31, 2 */
		/* 8209FF18h case   15:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x2);
		/* 8209FF18h case   15:*/		return 0x8209FF1C;
		  /* 8209FF1Ch */ case   16:  		/* addi R11, R11, 2 */
		/* 8209FF1Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8209FF1Ch case   16:*/		return 0x8209FF20;
		  /* 8209FF20h */ case   17:  		/* addi R10, R10, 2 */
		/* 8209FF20h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 8209FF20h case   17:*/		return 0x8209FF24;
		  /* 8209FF24h */ case   18:  		/* b 92 */
		/* 8209FF24h case   18:*/		return 0x8209FF80;
		/* 8209FF24h case   18:*/		return 0x8209FF28;
	}
	return 0x8209FF28;
} // Block from 8209FEDCh-8209FF28h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8209FF28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FF28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FF28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FF28);
		  /* 8209FF28h */ case    0:  		/* cmpwi CR6, R7, 92 */
		/* 8209FF28h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x0000005C);
		/* 8209FF28h case    0:*/		return 0x8209FF2C;
		  /* 8209FF2Ch */ case    1:  		/* bc 4, CR6_EQ, 52 */
		/* 8209FF2Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8209FF60;  }
		/* 8209FF2Ch case    1:*/		return 0x8209FF30;
		  /* 8209FF30h */ case    2:  		/* cmplw CR6, R10, R9 */
		/* 8209FF30h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8209FF30h case    2:*/		return 0x8209FF34;
		  /* 8209FF34h */ case    3:  		/* bc 4, CR6_LT, 44 */
		/* 8209FF34h case    3:*/		if ( !regs.CR[6].lt ) { return 0x8209FF60;  }
		/* 8209FF34h case    3:*/		return 0x8209FF38;
		  /* 8209FF38h */ case    4:  		/* lbz R9, <#[R11]> */
		/* 8209FF38h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8209FF38h case    4:*/		return 0x8209FF3C;
		  /* 8209FF3Ch */ case    5:  		/* cmplwi CR6, R9, 13 */
		/* 8209FF3Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000000D);
		/* 8209FF3Ch case    5:*/		return 0x8209FF40;
		  /* 8209FF40h */ case    6:  		/* bc 4, CR6_EQ, 32 */
		/* 8209FF40h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8209FF60;  }
		/* 8209FF40h case    6:*/		return 0x8209FF44;
		  /* 8209FF44h */ case    7:  		/* lbz R9, <#[R10]> */
		/* 8209FF44h case    7:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8209FF44h case    7:*/		return 0x8209FF48;
		  /* 8209FF48h */ case    8:  		/* cmplwi CR6, R9, 10 */
		/* 8209FF48h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000000A);
		/* 8209FF48h case    8:*/		return 0x8209FF4C;
		  /* 8209FF4Ch */ case    9:  		/* bc 4, CR6_EQ, 20 */
		/* 8209FF4Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x8209FF60;  }
		/* 8209FF4Ch case    9:*/		return 0x8209FF50;
		  /* 8209FF50h */ case   10:  		/* addi R31, R31, 3 */
		/* 8209FF50h case   10:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x3);
		/* 8209FF50h case   10:*/		return 0x8209FF54;
		  /* 8209FF54h */ case   11:  		/* addi R11, R11, 3 */
		/* 8209FF54h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 8209FF54h case   11:*/		return 0x8209FF58;
		  /* 8209FF58h */ case   12:  		/* addi R10, R10, 3 */
		/* 8209FF58h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x3);
		/* 8209FF58h case   12:*/		return 0x8209FF5C;
		  /* 8209FF5Ch */ case   13:  		/* b 36 */
		/* 8209FF5Ch case   13:*/		return 0x8209FF80;
		/* 8209FF5Ch case   13:*/		return 0x8209FF60;
	}
	return 0x8209FF60;
} // Block from 8209FF28h-8209FF60h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8209FF60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FF60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FF60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FF60);
		  /* 8209FF60h */ case    0:  		/* cmpwi CR6, R7, 13 */
		/* 8209FF60h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x0000000D);
		/* 8209FF60h case    0:*/		return 0x8209FF64;
		  /* 8209FF64h */ case    1:  		/* addi R31, R31, 1 */
		/* 8209FF64h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8209FF64h case    1:*/		return 0x8209FF68;
		  /* 8209FF68h */ case    2:  		/* addi R11, R11, 1 */
		/* 8209FF68h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8209FF68h case    2:*/		return 0x8209FF6C;
		  /* 8209FF6Ch */ case    3:  		/* addi R10, R10, 1 */
		/* 8209FF6Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8209FF6Ch case    3:*/		return 0x8209FF70;
		  /* 8209FF70h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 8209FF70h case    4:*/		if ( regs.CR[6].eq ) { return 0x8209FF80;  }
		/* 8209FF70h case    4:*/		return 0x8209FF74;
		  /* 8209FF74h */ case    5:  		/* addi R9, R1, 80 */
		/* 8209FF74h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x50);
		/* 8209FF74h case    5:*/		return 0x8209FF78;
		  /* 8209FF78h */ case    6:  		/* stbx R8, <#[R5 + R9]> */
		/* 8209FF78h case    6:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R5 + regs.R9 + 0x00000000) );
		/* 8209FF78h case    6:*/		return 0x8209FF7C;
		  /* 8209FF7Ch */ case    7:  		/* addi R5, R5, 1 */
		/* 8209FF7Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 8209FF7Ch case    7:*/		return 0x8209FF80;
	}
	return 0x8209FF80;
} // Block from 8209FF60h-8209FF80h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8209FF80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FF80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FF80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FF80);
		  /* 8209FF80h */ case    0:  		/* cmplwi CR6, R5, 255 */
		/* 8209FF80h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x000000FF);
		/* 8209FF80h case    0:*/		return 0x8209FF84;
		  /* 8209FF84h */ case    1:  		/* bc 12, CR6_LT, -156 */
		/* 8209FF84h case    1:*/		if ( regs.CR[6].lt ) { return 0x8209FEE8;  }
		/* 8209FF84h case    1:*/		return 0x8209FF88;
	}
	return 0x8209FF88;
} // Block from 8209FF80h-8209FF88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8209FF88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FF88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FF88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FF88);
		  /* 8209FF88h */ case    0:  		/* addi R11, R1, 80 */
		/* 8209FF88h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8209FF88h case    0:*/		return 0x8209FF8C;
		  /* 8209FF8Ch */ case    1:  		/* li R10, 0 */
		/* 8209FF8Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8209FF8Ch case    1:*/		return 0x8209FF90;
		  /* 8209FF90h */ case    2:  		/* lis R9, -32255 */
		/* 8209FF90h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 8209FF90h case    2:*/		return 0x8209FF94;
		  /* 8209FF94h */ case    3:  		/* addi R7, R1, 80 */
		/* 8209FF94h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 8209FF94h case    3:*/		return 0x8209FF98;
		  /* 8209FF98h */ case    4:  		/* addi R6, R9, -10984 */
		/* 8209FF98h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R9,0xFFFFD518);
		/* 8209FF98h case    4:*/		return 0x8209FF9C;
		  /* 8209FF9Ch */ case    5:  		/* stbx R10, <#[R5 + R11]> */
		/* 8209FF9Ch case    5:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 8209FF9Ch case    5:*/		return 0x8209FFA0;
		  /* 8209FFA0h */ case    6:  		/* li R5, 0 */
		/* 8209FFA0h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8209FFA0h case    6:*/		return 0x8209FFA4;
		  /* 8209FFA4h */ case    7:  		/* addi R4, R30, 2216 */
		/* 8209FFA4h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x8A8);
		/* 8209FFA4h case    7:*/		return 0x8209FFA8;
		  /* 8209FFA8h */ case    8:  		/* addi R3, R30, 24 */
		/* 8209FFA8h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x18);
		/* 8209FFA8h case    8:*/		return 0x8209FFAC;
		  /* 8209FFACh */ case    9:  		/* bl 29156 */
		/* 8209FFACh case    9:*/		regs.LR = 0x8209FFB0; return 0x820A7190;
		/* 8209FFACh case    9:*/		return 0x8209FFB0;
		  /* 8209FFB0h */ case   10:  		/* li R11, 1 */
		/* 8209FFB0h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8209FFB0h case   10:*/		return 0x8209FFB4;
		  /* 8209FFB4h */ case   11:  		/* stw R11, <#[R30 + 1644]> */
		/* 8209FFB4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000066C) );
		/* 8209FFB4h case   11:*/		return 0x8209FFB8;
		  /* 8209FFB8h */ case   12:  		/* stw R11, <#[R30 + 1640]> */
		/* 8209FFB8h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000668) );
		/* 8209FFB8h case   12:*/		return 0x8209FFBC;
	}
	return 0x8209FFBC;
} // Block from 8209FF88h-8209FFBCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 8209FFBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FFBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FFBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FFBC);
		  /* 8209FFBCh */ case    0:  		/* li R3, 0 */
		/* 8209FFBCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8209FFBCh case    0:*/		return 0x8209FFC0;
		  /* 8209FFC0h */ case    1:  		/* addi R1, R1, 368 */
		/* 8209FFC0h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x170);
		/* 8209FFC0h case    1:*/		return 0x8209FFC4;
		  /* 8209FFC4h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 8209FFC4h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209FFC4h case    2:*/		return 0x8209FFC8;
		  /* 8209FFC8h */ case    3:  		/* mtspr LR, R12 */
		/* 8209FFC8h case    3:*/		regs.LR = regs.R12;
		/* 8209FFC8h case    3:*/		return 0x8209FFCC;
		  /* 8209FFCCh */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 8209FFCCh case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8209FFCCh case    4:*/		return 0x8209FFD0;
		  /* 8209FFD0h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 8209FFD0h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209FFD0h case    5:*/		return 0x8209FFD4;
		  /* 8209FFD4h */ case    6:  		/* bclr 20, CR0_LT */
		/* 8209FFD4h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8209FFD4h case    6:*/		return 0x8209FFD8;
	}
	return 0x8209FFD8;
} // Block from 8209FFBCh-8209FFD8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8209FFD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8209FFD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8209FFD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8209FFD8);
		  /* 8209FFD8h */ case    0:  		/* mfspr R12, LR */
		/* 8209FFD8h case    0:*/		regs.R12 = regs.LR;
		/* 8209FFD8h case    0:*/		return 0x8209FFDC;
		  /* 8209FFDCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8209FFDCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8209FFDCh case    1:*/		return 0x8209FFE0;
		  /* 8209FFE0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8209FFE0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8209FFE0h case    2:*/		return 0x8209FFE4;
		  /* 8209FFE4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8209FFE4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8209FFE4h case    3:*/		return 0x8209FFE8;
		  /* 8209FFE8h */ case    4:  		/* lwz R11, <#[R3 + 2196]> */
		/* 8209FFE8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000894) );
		/* 8209FFE8h case    4:*/		return 0x8209FFEC;
		  /* 8209FFECh */ case    5:  		/* mr R31, R3 */
		/* 8209FFECh case    5:*/		regs.R31 = regs.R3;
		/* 8209FFECh case    5:*/		return 0x8209FFF0;
		  /* 8209FFF0h */ case    6:  		/* lwz R10, <#[R11 + 80]> */
		/* 8209FFF0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000050) );
		/* 8209FFF0h case    6:*/		return 0x8209FFF4;
		  /* 8209FFF4h */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 8209FFF4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8209FFF4h case    7:*/		return 0x8209FFF8;
		  /* 8209FFF8h */ case    8:  		/* bc 4, CR6_EQ, 48 */
		/* 8209FFF8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820A0028;  }
		/* 8209FFF8h case    8:*/		return 0x8209FFFC;
		  /* 8209FFFCh */ case    9:  		/* lis R11, -32255 */
		/* 8209FFFCh case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8209FFFCh case    9:*/		return 0x820A0000;
		  /* 820A0000h */ case   10:  		/* li R5, 1508 */
		/* 820A0000h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x5E4);
		/* 820A0000h case   10:*/		return 0x820A0004;
		  /* 820A0004h */ case   11:  		/* addi R6, R11, -10936 */
		/* 820A0004h case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD548);
		/* 820A0004h case   11:*/		return 0x820A0008;
		  /* 820A0008h */ case   12:  		/* addi R4, R31, 2216 */
		/* 820A0008h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x8A8);
		/* 820A0008h case   12:*/		return 0x820A000C;
		  /* 820A000Ch */ case   13:  		/* addi R3, R31, 24 */
		/* 820A000Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x18);
		/* 820A000Ch case   13:*/		return 0x820A0010;
		  /* 820A0010h */ case   14:  		/* bl 29056 */
		/* 820A0010h case   14:*/		regs.LR = 0x820A0014; return 0x820A7190;
		/* 820A0010h case   14:*/		return 0x820A0014;
		  /* 820A0014h */ case   15:  		/* li R11, 1 */
		/* 820A0014h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A0014h case   15:*/		return 0x820A0018;
		  /* 820A0018h */ case   16:  		/* lis R3, -32768 */
		/* 820A0018h case   16:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820A0018h case   16:*/		return 0x820A001C;
		  /* 820A001Ch */ case   17:  		/* stw R11, <#[R31 + 1640]> */
		/* 820A001Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000668) );
		/* 820A001Ch case   17:*/		return 0x820A0020;
		  /* 820A0020h */ case   18:  		/* ori R3, R3, 16389 */
		/* 820A0020h case   18:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820A0020h case   18:*/		return 0x820A0024;
		  /* 820A0024h */ case   19:  		/* b 96 */
		/* 820A0024h case   19:*/		return 0x820A0084;
		/* 820A0024h case   19:*/		return 0x820A0028;
	}
	return 0x820A0028;
} // Block from 8209FFD8h-820A0028h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820A0028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0028);
		  /* 820A0028h */ case    0:  		/* lwz R11, <#[R10 + 8]> */
		/* 820A0028h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 820A0028h case    0:*/		return 0x820A002C;
		  /* 820A002Ch */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820A002Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A002Ch case    1:*/		return 0x820A0030;
		  /* 820A0030h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 820A0030h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A0044;  }
		/* 820A0030h case    2:*/		return 0x820A0034;
		  /* 820A0034h */ case    3:  		/* lis R11, -32255 */
		/* 820A0034h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A0034h case    3:*/		return 0x820A0038;
		  /* 820A0038h */ case    4:  		/* li R5, 1513 */
		/* 820A0038h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x5E9);
		/* 820A0038h case    4:*/		return 0x820A003C;
		  /* 820A003Ch */ case    5:  		/* addi R6, R11, -10972 */
		/* 820A003Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD524);
		/* 820A003Ch case    5:*/		return 0x820A0040;
		  /* 820A0040h */ case    6:  		/* b -56 */
		/* 820A0040h case    6:*/		return 0x820A0008;
		/* 820A0040h case    6:*/		return 0x820A0044;
	}
	return 0x820A0044;
} // Block from 820A0028h-820A0044h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A0044h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0044( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0044) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0044);
		  /* 820A0044h */ case    0:  		/* cmpwi CR6, R4, 0 */
		/* 820A0044h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 820A0044h case    0:*/		return 0x820A0048;
		  /* 820A0048h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 820A0048h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A0068;  }
		/* 820A0048h case    1:*/		return 0x820A004C;
		  /* 820A004Ch */ case    2:  		/* lwz R11, <#[R10]> */
		/* 820A004Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820A004Ch case    2:*/		return 0x820A0050;
		  /* 820A0050h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 820A0050h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A0050h case    3:*/		return 0x820A0054;
		  /* 820A0054h */ case    4:  		/* bc 4, CR6_EQ, 20 */
		/* 820A0054h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820A0068;  }
		/* 820A0054h case    4:*/		return 0x820A0058;
		  /* 820A0058h */ case    5:  		/* lwz R11, <#[R10 + 4]> */
		/* 820A0058h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 820A0058h case    5:*/		return 0x820A005C;
		  /* 820A005Ch */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 820A005Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A005Ch case    6:*/		return 0x820A0060;
		  /* 820A0060h */ case    7:  		/* li R11, 1 */
		/* 820A0060h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A0060h case    7:*/		return 0x820A0064;
		  /* 820A0064h */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 820A0064h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820A006C;  }
		/* 820A0064h case    8:*/		return 0x820A0068;
	}
	return 0x820A0068;
} // Block from 820A0044h-820A0068h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A0068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0068);
		  /* 820A0068h */ case    0:  		/* li R11, 0 */
		/* 820A0068h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A0068h case    0:*/		return 0x820A006C;
	}
	return 0x820A006C;
} // Block from 820A0068h-820A006Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A006Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A006C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A006C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A006C);
		  /* 820A006Ch */ case    0:  		/* stw R11, <#[R31 + 1656]> */
		/* 820A006Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000678) );
		/* 820A006Ch case    0:*/		return 0x820A0070;
		  /* 820A0070h */ case    1:  		/* cmpwi CR6, R4, 0 */
		/* 820A0070h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 820A0070h case    1:*/		return 0x820A0074;
		  /* 820A0074h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 820A0074h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A0080;  }
		/* 820A0074h case    2:*/		return 0x820A0078;
		  /* 820A0078h */ case    3:  		/* li R11, 1 */
		/* 820A0078h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A0078h case    3:*/		return 0x820A007C;
		  /* 820A007Ch */ case    4:  		/* stw R11, <#[R10]> */
		/* 820A007Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820A007Ch case    4:*/		return 0x820A0080;
	}
	return 0x820A0080;
} // Block from 820A006Ch-820A0080h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A0080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0080);
		  /* 820A0080h */ case    0:  		/* li R3, 0 */
		/* 820A0080h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A0080h case    0:*/		return 0x820A0084;
	}
	return 0x820A0084;
} // Block from 820A0080h-820A0084h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A0084h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0084( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0084) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0084);
		  /* 820A0084h */ case    0:  		/* addi R1, R1, 96 */
		/* 820A0084h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820A0084h case    0:*/		return 0x820A0088;
		  /* 820A0088h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A0088h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A0088h case    1:*/		return 0x820A008C;
		  /* 820A008Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820A008Ch case    2:*/		regs.LR = regs.R12;
		/* 820A008Ch case    2:*/		return 0x820A0090;
		  /* 820A0090h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820A0090h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A0090h case    3:*/		return 0x820A0094;
		  /* 820A0094h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820A0094h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A0094h case    4:*/		return 0x820A0098;
	}
	return 0x820A0098;
} // Block from 820A0084h-820A0098h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A0098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0098);
		  /* 820A0098h */ case    0:  		/* mfspr R12, LR */
		/* 820A0098h case    0:*/		regs.R12 = regs.LR;
		/* 820A0098h case    0:*/		return 0x820A009C;
		  /* 820A009Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A009Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A009Ch case    1:*/		return 0x820A00A0;
		  /* 820A00A0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820A00A0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A00A0h case    2:*/		return 0x820A00A4;
		  /* 820A00A4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820A00A4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820A00A4h case    3:*/		return 0x820A00A8;
		  /* 820A00A8h */ case    4:  		/* lwz R11, <#[R3 + 2196]> */
		/* 820A00A8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000894) );
		/* 820A00A8h case    4:*/		return 0x820A00AC;
		  /* 820A00ACh */ case    5:  		/* mr R31, R3 */
		/* 820A00ACh case    5:*/		regs.R31 = regs.R3;
		/* 820A00ACh case    5:*/		return 0x820A00B0;
		  /* 820A00B0h */ case    6:  		/* lwz R11, <#[R11 + 80]> */
		/* 820A00B0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 820A00B0h case    6:*/		return 0x820A00B4;
		  /* 820A00B4h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 820A00B4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A00B4h case    7:*/		return 0x820A00B8;
		  /* 820A00B8h */ case    8:  		/* bc 4, CR6_EQ, 48 */
		/* 820A00B8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820A00E8;  }
		/* 820A00B8h case    8:*/		return 0x820A00BC;
		  /* 820A00BCh */ case    9:  		/* lis R11, -32255 */
		/* 820A00BCh case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A00BCh case    9:*/		return 0x820A00C0;
		  /* 820A00C0h */ case   10:  		/* li R5, 1509 */
		/* 820A00C0h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x5E5);
		/* 820A00C0h case   10:*/		return 0x820A00C4;
		  /* 820A00C4h */ case   11:  		/* addi R6, R11, -10880 */
		/* 820A00C4h case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD580);
		/* 820A00C4h case   11:*/		return 0x820A00C8;
		  /* 820A00C8h */ case   12:  		/* addi R4, R31, 2216 */
		/* 820A00C8h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x8A8);
		/* 820A00C8h case   12:*/		return 0x820A00CC;
		  /* 820A00CCh */ case   13:  		/* addi R3, R31, 24 */
		/* 820A00CCh case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x18);
		/* 820A00CCh case   13:*/		return 0x820A00D0;
		  /* 820A00D0h */ case   14:  		/* bl 28864 */
		/* 820A00D0h case   14:*/		regs.LR = 0x820A00D4; return 0x820A7190;
		/* 820A00D0h case   14:*/		return 0x820A00D4;
		  /* 820A00D4h */ case   15:  		/* li R11, 1 */
		/* 820A00D4h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A00D4h case   15:*/		return 0x820A00D8;
		  /* 820A00D8h */ case   16:  		/* lis R3, -32768 */
		/* 820A00D8h case   16:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820A00D8h case   16:*/		return 0x820A00DC;
		  /* 820A00DCh */ case   17:  		/* stw R11, <#[R31 + 1640]> */
		/* 820A00DCh case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000668) );
		/* 820A00DCh case   17:*/		return 0x820A00E0;
		  /* 820A00E0h */ case   18:  		/* ori R3, R3, 16389 */
		/* 820A00E0h case   18:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820A00E0h case   18:*/		return 0x820A00E4;
		  /* 820A00E4h */ case   19:  		/* b 84 */
		/* 820A00E4h case   19:*/		return 0x820A0138;
		/* 820A00E4h case   19:*/		return 0x820A00E8;
	}
	return 0x820A00E8;
} // Block from 820A0098h-820A00E8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820A00E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A00E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A00E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A00E8);
		  /* 820A00E8h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 820A00E8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820A00E8h case    0:*/		return 0x820A00EC;
		  /* 820A00ECh */ case    1:  		/* cmpwi CR6, R10, 0 */
		/* 820A00ECh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820A00ECh case    1:*/		return 0x820A00F0;
		  /* 820A00F0h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 820A00F0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A0104;  }
		/* 820A00F0h case    2:*/		return 0x820A00F4;
		  /* 820A00F4h */ case    3:  		/* lis R11, -32255 */
		/* 820A00F4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A00F4h case    3:*/		return 0x820A00F8;
		  /* 820A00F8h */ case    4:  		/* li R5, 1514 */
		/* 820A00F8h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x5EA);
		/* 820A00F8h case    4:*/		return 0x820A00FC;
		  /* 820A00FCh */ case    5:  		/* addi R6, R11, -10916 */
		/* 820A00FCh case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD55C);
		/* 820A00FCh case    5:*/		return 0x820A0100;
		  /* 820A0100h */ case    6:  		/* b -56 */
		/* 820A0100h case    6:*/		return 0x820A00C8;
		/* 820A0100h case    6:*/		return 0x820A0104;
	}
	return 0x820A0104;
} // Block from 820A00E8h-820A0104h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A0104h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0104( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0104) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0104);
		  /* 820A0104h */ case    0:  		/* lwz R10, <#[R11]> */
		/* 820A0104h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A0104h case    0:*/		return 0x820A0108;
		  /* 820A0108h */ case    1:  		/* li R9, 1 */
		/* 820A0108h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820A0108h case    1:*/		return 0x820A010C;
		  /* 820A010Ch */ case    2:  		/* cmpwi CR6, R10, 0 */
		/* 820A010Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820A010Ch case    2:*/		return 0x820A0110;
		  /* 820A0110h */ case    3:  		/* bc 4, CR6_EQ, 20 */
		/* 820A0110h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A0124;  }
		/* 820A0110h case    3:*/		return 0x820A0114;
		  /* 820A0114h */ case    4:  		/* lwz R10, <#[R11 + 4]> */
		/* 820A0114h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820A0114h case    4:*/		return 0x820A0118;
		  /* 820A0118h */ case    5:  		/* cmpwi CR6, R10, 0 */
		/* 820A0118h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820A0118h case    5:*/		return 0x820A011C;
		  /* 820A011Ch */ case    6:  		/* mr R10, R9 */
		/* 820A011Ch case    6:*/		regs.R10 = regs.R9;
		/* 820A011Ch case    6:*/		return 0x820A0120;
		  /* 820A0120h */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 820A0120h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820A0128;  }
		/* 820A0120h case    7:*/		return 0x820A0124;
	}
	return 0x820A0124;
} // Block from 820A0104h-820A0124h (8 instructions)

